<html>
<head>
<title>reduce-vars.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
reduce-vars.js</font>
</center></td></tr></table>
<pre><span class="s0">/***********************************************************************</span>

  <span class="s0">A JavaScript tokenizer / parser / beautifier / compressor.</span>
  <span class="s0">https://github.com/mishoo/UglifyJS2</span>

  <span class="s0">-------------------------------- (C) ---------------------------------</span>

                           <span class="s0">Author: Mihai Bazon</span>
                         <span class="s0">&lt;mihai.bazon@gmail.com&gt;</span>
                       <span class="s0">http://mihai.bazon.net/blog</span>

  <span class="s0">Distributed under the BSD license:</span>

    <span class="s0">Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt;</span>

    <span class="s0">Redistribution and use in source and binary forms, with or without</span>
    <span class="s0">modification, are permitted provided that the following conditions</span>
    <span class="s0">are met:</span>

        <span class="s0">* Redistributions of source code must retain the above</span>
          <span class="s0">copyright notice, this list of conditions and the following</span>
          <span class="s0">disclaimer.</span>

        <span class="s0">* Redistributions in binary form must reproduce the above</span>
          <span class="s0">copyright notice, this list of conditions and the following</span>
          <span class="s0">disclaimer in the documentation and/or other materials</span>
          <span class="s0">provided with the distribution.</span>

    <span class="s0">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY</span>
    <span class="s0">EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
    <span class="s0">IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span>
    <span class="s0">PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE</span>
    <span class="s0">LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,</span>
    <span class="s0">OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,</span>
    <span class="s0">PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span>
    <span class="s0">PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
    <span class="s0">THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR</span>
    <span class="s0">TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF</span>
    <span class="s0">THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
    <span class="s0">SUCH DAMAGE.</span>

 <span class="s0">***********************************************************************/</span>

<span class="s2">import </span><span class="s3">{</span>
    <span class="s1">AST_Accessor</span><span class="s3">,</span>
    <span class="s1">AST_Array</span><span class="s3">,</span>
    <span class="s1">AST_Assign</span><span class="s3">,</span>
    <span class="s1">AST_Await</span><span class="s3">,</span>
    <span class="s1">AST_Binary</span><span class="s3">,</span>
    <span class="s1">AST_Block</span><span class="s3">,</span>
    <span class="s1">AST_Call</span><span class="s3">,</span>
    <span class="s1">AST_Case</span><span class="s3">,</span>
    <span class="s1">AST_Chain</span><span class="s3">,</span>
    <span class="s1">AST_Class</span><span class="s3">,</span>
    <span class="s1">AST_ClassStaticBlock</span><span class="s3">,</span>
    <span class="s1">AST_ClassExpression</span><span class="s3">,</span>
    <span class="s1">AST_Conditional</span><span class="s3">,</span>
    <span class="s1">AST_Default</span><span class="s3">,</span>
    <span class="s1">AST_Defun</span><span class="s3">,</span>
    <span class="s1">AST_Destructuring</span><span class="s3">,</span>
    <span class="s1">AST_Do</span><span class="s3">,</span>
    <span class="s1">AST_Exit</span><span class="s3">,</span>
    <span class="s1">AST_Expansion</span><span class="s3">,</span>
    <span class="s1">AST_For</span><span class="s3">,</span>
    <span class="s1">AST_ForIn</span><span class="s3">,</span>
    <span class="s1">AST_If</span><span class="s3">,</span>
    <span class="s1">AST_LabeledStatement</span><span class="s3">,</span>
    <span class="s1">AST_Lambda</span><span class="s3">,</span>
    <span class="s1">AST_New</span><span class="s3">,</span>
    <span class="s1">AST_Node</span><span class="s3">,</span>
    <span class="s1">AST_Number</span><span class="s3">,</span>
    <span class="s1">AST_ObjectKeyVal</span><span class="s3">,</span>
    <span class="s1">AST_PropAccess</span><span class="s3">,</span>
    <span class="s1">AST_Scope</span><span class="s3">,</span>
    <span class="s1">AST_Sequence</span><span class="s3">,</span>
    <span class="s1">AST_SimpleStatement</span><span class="s3">,</span>
    <span class="s1">AST_Symbol</span><span class="s3">,</span>
    <span class="s1">AST_SymbolCatch</span><span class="s3">,</span>
    <span class="s1">AST_SymbolConst</span><span class="s3">,</span>
    <span class="s1">AST_SymbolDeclaration</span><span class="s3">,</span>
    <span class="s1">AST_SymbolDefun</span><span class="s3">,</span>
    <span class="s1">AST_SymbolFunarg</span><span class="s3">,</span>
    <span class="s1">AST_SymbolLambda</span><span class="s3">,</span>
    <span class="s1">AST_SymbolRef</span><span class="s3">,</span>
    <span class="s1">AST_This</span><span class="s3">,</span>
    <span class="s1">AST_Toplevel</span><span class="s3">,</span>
    <span class="s1">AST_Try</span><span class="s3">,</span>
    <span class="s1">AST_Unary</span><span class="s3">,</span>
    <span class="s1">AST_UnaryPrefix</span><span class="s3">,</span>
    <span class="s1">AST_Undefined</span><span class="s3">,</span>
    <span class="s1">AST_VarDef</span><span class="s3">,</span>
    <span class="s1">AST_While</span><span class="s3">,</span>
    <span class="s1">AST_Yield</span><span class="s3">,</span>

    <span class="s1">walk</span><span class="s3">,</span>
    <span class="s1">walk_body</span><span class="s3">,</span>

    <span class="s1">TreeWalker</span><span class="s3">,</span>
<span class="s3">} </span><span class="s1">from </span><span class="s4">&quot;../ast.js&quot;</span><span class="s3">;</span>
<span class="s2">import </span><span class="s3">{ </span><span class="s1">HOP</span><span class="s3">, </span><span class="s1">make_node</span><span class="s3">, </span><span class="s1">noop </span><span class="s3">} </span><span class="s1">from </span><span class="s4">&quot;../utils/index.js&quot;</span><span class="s3">;</span>

<span class="s2">import </span><span class="s3">{ </span><span class="s1">lazy_op</span><span class="s3">, </span><span class="s1">is_modified</span><span class="s3">, </span><span class="s1">is_lhs </span><span class="s3">} </span><span class="s1">from </span><span class="s4">&quot;./inference.js&quot;</span><span class="s3">;</span>
<span class="s2">import </span><span class="s3">{ </span><span class="s1">INLINED</span><span class="s3">, </span><span class="s1">clear_flag </span><span class="s3">} </span><span class="s1">from </span><span class="s4">&quot;./compressor-flags.js&quot;</span><span class="s3">;</span>
<span class="s2">import </span><span class="s3">{ </span><span class="s1">read_property</span><span class="s3">, </span><span class="s1">has_break_or_continue</span><span class="s3">, </span><span class="s1">is_recursive_ref </span><span class="s3">} </span><span class="s1">from </span><span class="s4">&quot;./common.js&quot;</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* Define the method AST_Node#reduce_vars, which goes through the AST in</span>
 <span class="s0">* execution order to perform basic flow analysis</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">func</span><span class="s3">) {</span>
    <span class="s1">node</span><span class="s3">.</span><span class="s1">DEFMETHOD</span><span class="s3">(</span><span class="s4">&quot;reduce_vars&quot;</span><span class="s3">, </span><span class="s1">func</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_Node</span><span class="s3">, </span><span class="s1">noop</span><span class="s3">);</span>

<span class="s0">/** Clear definition properties */</span>
<span class="s2">function </span><span class="s1">reset_def</span><span class="s3">(</span><span class="s1">compressor</span><span class="s3">, </span><span class="s1">def</span><span class="s3">) {</span>
    <span class="s1">def</span><span class="s3">.</span><span class="s1">assignments </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
    <span class="s1">def</span><span class="s3">.</span><span class="s1">chained </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
    <span class="s1">def</span><span class="s3">.</span><span class="s1">direct_access </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
    <span class="s1">def</span><span class="s3">.</span><span class="s1">escaped </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
    <span class="s1">def</span><span class="s3">.</span><span class="s1">recursive_refs </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
    <span class="s1">def</span><span class="s3">.</span><span class="s1">references </span><span class="s3">= [];</span>
    <span class="s1">def</span><span class="s3">.</span><span class="s1">single_use </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span>
        <span class="s1">def</span><span class="s3">.</span><span class="s1">scope</span><span class="s3">.</span><span class="s1">pinned</span><span class="s3">()</span>
        <span class="s3">|| (</span><span class="s1">def</span><span class="s3">.</span><span class="s1">orig</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] </span><span class="s2">instanceof </span><span class="s1">AST_SymbolFunarg </span><span class="s3">&amp;&amp; </span><span class="s1">def</span><span class="s3">.</span><span class="s1">scope</span><span class="s3">.</span><span class="s1">uses_arguments</span><span class="s3">)</span>
    <span class="s3">) {</span>
        <span class="s1">def</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">def</span><span class="s3">.</span><span class="s1">orig</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] </span><span class="s2">instanceof </span><span class="s1">AST_SymbolConst </span><span class="s3">|| !</span><span class="s1">compressor</span><span class="s3">.</span><span class="s1">exposed</span><span class="s3">(</span><span class="s1">def</span><span class="s3">)) {</span>
        <span class="s1">def</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">= </span><span class="s1">def</span><span class="s3">.</span><span class="s1">init</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
        <span class="s1">def</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
    <span class="s3">}</span>
<span class="s3">}</span>

<span class="s2">function </span><span class="s1">reset_variables</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">, </span><span class="s1">node</span><span class="s3">) {</span>
    <span class="s1">node</span><span class="s3">.</span><span class="s1">variables</span><span class="s3">.</span><span class="s1">forEach</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">def</span><span class="s3">) {</span>
        <span class="s1">reset_def</span><span class="s3">(</span><span class="s1">compressor</span><span class="s3">, </span><span class="s1">def</span><span class="s3">);</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">def</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">=== </span><span class="s2">null</span><span class="s3">) {</span>
            <span class="s1">tw</span><span class="s3">.</span><span class="s1">defs_to_safe_ids</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">def</span><span class="s3">.</span><span class="s1">id</span><span class="s3">, </span><span class="s1">tw</span><span class="s3">.</span><span class="s1">safe_ids</span><span class="s3">);</span>
            <span class="s1">mark</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">def</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
        <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">def</span><span class="s3">.</span><span class="s1">fixed</span><span class="s3">) {</span>
            <span class="s1">tw</span><span class="s3">.</span><span class="s1">loop_ids</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">def</span><span class="s3">.</span><span class="s1">id</span><span class="s3">, </span><span class="s1">tw</span><span class="s3">.</span><span class="s1">in_loop</span><span class="s3">);</span>
            <span class="s1">mark</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">def</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
        <span class="s3">}</span>
    <span class="s3">});</span>
<span class="s3">}</span>

<span class="s2">function </span><span class="s1">reset_block_variables</span><span class="s3">(</span><span class="s1">compressor</span><span class="s3">, </span><span class="s1">node</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">block_scope</span><span class="s3">) </span><span class="s1">node</span><span class="s3">.</span><span class="s1">block_scope</span><span class="s3">.</span><span class="s1">variables</span><span class="s3">.</span><span class="s1">forEach</span><span class="s3">((</span><span class="s1">def</span><span class="s3">) =&gt; {</span>
        <span class="s1">reset_def</span><span class="s3">(</span><span class="s1">compressor</span><span class="s3">, </span><span class="s1">def</span><span class="s3">);</span>
    <span class="s3">});</span>
<span class="s3">}</span>

<span class="s2">function </span><span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">) {</span>
    <span class="s1">tw</span><span class="s3">.</span><span class="s1">safe_ids </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">.</span><span class="s1">safe_ids</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s2">function </span><span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">) {</span>
    <span class="s1">tw</span><span class="s3">.</span><span class="s1">safe_ids </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">getPrototypeOf</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">.</span><span class="s1">safe_ids</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s2">function </span><span class="s1">mark</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">def</span><span class="s3">, </span><span class="s1">safe</span><span class="s3">) {</span>
    <span class="s1">tw</span><span class="s3">.</span><span class="s1">safe_ids</span><span class="s3">[</span><span class="s1">def</span><span class="s3">.</span><span class="s1">id</span><span class="s3">] = </span><span class="s1">safe</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s2">function </span><span class="s1">safe_to_read</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">def</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">def</span><span class="s3">.</span><span class="s1">single_use </span><span class="s3">== </span><span class="s4">&quot;m&quot;</span><span class="s3">) </span><span class="s2">return false</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">tw</span><span class="s3">.</span><span class="s1">safe_ids</span><span class="s3">[</span><span class="s1">def</span><span class="s3">.</span><span class="s1">id</span><span class="s3">]) {</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">def</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) {</span>
            <span class="s2">var </span><span class="s1">orig </span><span class="s3">= </span><span class="s1">def</span><span class="s3">.</span><span class="s1">orig</span><span class="s3">[</span><span class="s5">0</span><span class="s3">];</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">orig </span><span class="s2">instanceof </span><span class="s1">AST_SymbolFunarg </span><span class="s3">|| </span><span class="s1">orig</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;arguments&quot;</span><span class="s3">) </span><span class="s2">return false</span><span class="s3">;</span>
            <span class="s1">def</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">= </span><span class="s1">make_node</span><span class="s3">(</span><span class="s1">AST_Undefined</span><span class="s3">, </span><span class="s1">orig</span><span class="s3">);</span>
        <span class="s3">}</span>
        <span class="s2">return true</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">return </span><span class="s1">def</span><span class="s3">.</span><span class="s1">fixed </span><span class="s2">instanceof </span><span class="s1">AST_Defun</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s2">function </span><span class="s1">safe_to_assign</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">def</span><span class="s3">, </span><span class="s1">scope</span><span class="s3">, </span><span class="s1">value</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">def</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s2">return true</span><span class="s3">;</span>
    <span class="s2">let </span><span class="s1">def_safe_ids</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">def</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">=== </span><span class="s2">null</span>
        <span class="s3">&amp;&amp; (</span><span class="s1">def_safe_ids </span><span class="s3">= </span><span class="s1">tw</span><span class="s3">.</span><span class="s1">defs_to_safe_ids</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">def</span><span class="s3">.</span><span class="s1">id</span><span class="s3">))</span>
    <span class="s3">) {</span>
        <span class="s1">def_safe_ids</span><span class="s3">[</span><span class="s1">def</span><span class="s3">.</span><span class="s1">id</span><span class="s3">] = </span><span class="s2">false</span><span class="s3">;</span>
        <span class="s1">tw</span><span class="s3">.</span><span class="s1">defs_to_safe_ids</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">def</span><span class="s3">.</span><span class="s1">id</span><span class="s3">);</span>
        <span class="s2">return true</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">HOP</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">.</span><span class="s1">safe_ids</span><span class="s3">, </span><span class="s1">def</span><span class="s3">.</span><span class="s1">id</span><span class="s3">)) </span><span class="s2">return false</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">safe_to_read</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">def</span><span class="s3">)) </span><span class="s2">return false</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">def</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">=== </span><span class="s2">false</span><span class="s3">) </span><span class="s2">return false</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">def</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">!= </span><span class="s2">null </span><span class="s3">&amp;&amp; (!</span><span class="s1">value </span><span class="s3">|| </span><span class="s1">def</span><span class="s3">.</span><span class="s1">references</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s1">def</span><span class="s3">.</span><span class="s1">assignments</span><span class="s3">)) </span><span class="s2">return false</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">def</span><span class="s3">.</span><span class="s1">fixed </span><span class="s2">instanceof </span><span class="s1">AST_Defun</span><span class="s3">) {</span>
        <span class="s2">return </span><span class="s1">value </span><span class="s2">instanceof </span><span class="s1">AST_Node </span><span class="s3">&amp;&amp; </span><span class="s1">def</span><span class="s3">.</span><span class="s1">fixed</span><span class="s3">.</span><span class="s1">parent_scope </span><span class="s3">=== </span><span class="s1">scope</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">return </span><span class="s1">def</span><span class="s3">.</span><span class="s1">orig</span><span class="s3">.</span><span class="s1">every</span><span class="s3">((</span><span class="s1">sym</span><span class="s3">) =&gt; {</span>
        <span class="s2">return </span><span class="s3">!(</span><span class="s1">sym </span><span class="s2">instanceof </span><span class="s1">AST_SymbolConst</span>
            <span class="s3">|| </span><span class="s1">sym </span><span class="s2">instanceof </span><span class="s1">AST_SymbolDefun</span>
            <span class="s3">|| </span><span class="s1">sym </span><span class="s2">instanceof </span><span class="s1">AST_SymbolLambda</span><span class="s3">);</span>
    <span class="s3">});</span>
<span class="s3">}</span>

<span class="s2">function </span><span class="s1">ref_once</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">, </span><span class="s1">def</span><span class="s3">) {</span>
    <span class="s2">return </span><span class="s1">compressor</span><span class="s3">.</span><span class="s1">option</span><span class="s3">(</span><span class="s4">&quot;unused&quot;</span><span class="s3">)</span>
        <span class="s3">&amp;&amp; !</span><span class="s1">def</span><span class="s3">.</span><span class="s1">scope</span><span class="s3">.</span><span class="s1">pinned</span><span class="s3">()</span>
        <span class="s3">&amp;&amp; </span><span class="s1">def</span><span class="s3">.</span><span class="s1">references</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s1">def</span><span class="s3">.</span><span class="s1">recursive_refs </span><span class="s3">== </span><span class="s5">1</span>
        <span class="s3">&amp;&amp; </span><span class="s1">tw</span><span class="s3">.</span><span class="s1">loop_ids</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">def</span><span class="s3">.</span><span class="s1">id</span><span class="s3">) === </span><span class="s1">tw</span><span class="s3">.</span><span class="s1">in_loop</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s2">function </span><span class="s1">is_immutable</span><span class="s3">(</span><span class="s1">value</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">value</span><span class="s3">) </span><span class="s2">return false</span><span class="s3">;</span>
    <span class="s2">return </span><span class="s1">value</span><span class="s3">.</span><span class="s1">is_constant</span><span class="s3">()</span>
        <span class="s3">|| </span><span class="s1">value </span><span class="s2">instanceof </span><span class="s1">AST_Lambda</span>
        <span class="s3">|| </span><span class="s1">value </span><span class="s2">instanceof </span><span class="s1">AST_This</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s6">// A definition &quot;escapes&quot; when its value can leave the point of use.</span>
<span class="s6">// Example: `a = b || c`</span>
<span class="s6">// In this example, &quot;b&quot; and &quot;c&quot; are escaping, because they're going into &quot;a&quot;</span>
<span class="s6">//</span>
<span class="s6">// def.escaped is != 0 when it escapes.</span>
<span class="s6">//</span>
<span class="s6">// When greater than 1, it means that N chained properties will be read off</span>
<span class="s6">// of that def before an escape occurs. This is useful for evaluating</span>
<span class="s6">// property accesses, where you need to know when to stop.</span>
<span class="s2">function </span><span class="s1">mark_escaped</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">scope</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">level </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">depth </span><span class="s3">= </span><span class="s5">1</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">parent </span><span class="s3">= </span><span class="s1">tw</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">(</span><span class="s1">level</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">value</span><span class="s3">) {</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">value</span><span class="s3">.</span><span class="s1">is_constant</span><span class="s3">()) </span><span class="s2">return</span><span class="s3">;</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">value </span><span class="s2">instanceof </span><span class="s1">AST_ClassExpression</span><span class="s3">) </span><span class="s2">return</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s2">if </span><span class="s3">(</span>
        <span class="s1">parent </span><span class="s2">instanceof </span><span class="s1">AST_Assign </span><span class="s3">&amp;&amp; (</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">operator </span><span class="s3">=== </span><span class="s4">&quot;=&quot; </span><span class="s3">|| </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">logical</span><span class="s3">) &amp;&amp; </span><span class="s1">node </span><span class="s3">=== </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">right</span>
        <span class="s3">|| </span><span class="s1">parent </span><span class="s2">instanceof </span><span class="s1">AST_Call </span><span class="s3">&amp;&amp; (</span><span class="s1">node </span><span class="s3">!== </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">expression </span><span class="s3">|| </span><span class="s1">parent </span><span class="s2">instanceof </span><span class="s1">AST_New</span><span class="s3">)</span>
        <span class="s3">|| </span><span class="s1">parent </span><span class="s2">instanceof </span><span class="s1">AST_Exit </span><span class="s3">&amp;&amp; </span><span class="s1">node </span><span class="s3">=== </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">value </span><span class="s3">&amp;&amp; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">scope </span><span class="s3">!== </span><span class="s1">d</span><span class="s3">.</span><span class="s1">scope</span>
        <span class="s3">|| </span><span class="s1">parent </span><span class="s2">instanceof </span><span class="s1">AST_VarDef </span><span class="s3">&amp;&amp; </span><span class="s1">node </span><span class="s3">=== </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">value</span>
        <span class="s3">|| </span><span class="s1">parent </span><span class="s2">instanceof </span><span class="s1">AST_Yield </span><span class="s3">&amp;&amp; </span><span class="s1">node </span><span class="s3">=== </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">value </span><span class="s3">&amp;&amp; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">scope </span><span class="s3">!== </span><span class="s1">d</span><span class="s3">.</span><span class="s1">scope</span>
    <span class="s3">) {</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">depth </span><span class="s3">&gt; </span><span class="s5">1 </span><span class="s3">&amp;&amp; !(</span><span class="s1">value </span><span class="s3">&amp;&amp; </span><span class="s1">value</span><span class="s3">.</span><span class="s1">is_constant_expression</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">))) </span><span class="s1">depth </span><span class="s3">= </span><span class="s5">1</span><span class="s3">;</span>
        <span class="s2">if </span><span class="s3">(!</span><span class="s1">d</span><span class="s3">.</span><span class="s1">escaped </span><span class="s3">|| </span><span class="s1">d</span><span class="s3">.</span><span class="s1">escaped </span><span class="s3">&gt; </span><span class="s1">depth</span><span class="s3">) </span><span class="s1">d</span><span class="s3">.</span><span class="s1">escaped </span><span class="s3">= </span><span class="s1">depth</span><span class="s3">;</span>
        <span class="s2">return</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span>
        <span class="s1">parent </span><span class="s2">instanceof </span><span class="s1">AST_Array</span>
        <span class="s3">|| </span><span class="s1">parent </span><span class="s2">instanceof </span><span class="s1">AST_Await</span>
        <span class="s3">|| </span><span class="s1">parent </span><span class="s2">instanceof </span><span class="s1">AST_Binary </span><span class="s3">&amp;&amp; </span><span class="s1">lazy_op</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">operator</span><span class="s3">)</span>
        <span class="s3">|| </span><span class="s1">parent </span><span class="s2">instanceof </span><span class="s1">AST_Conditional </span><span class="s3">&amp;&amp; </span><span class="s1">node </span><span class="s3">!== </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">condition</span>
        <span class="s3">|| </span><span class="s1">parent </span><span class="s2">instanceof </span><span class="s1">AST_Expansion</span>
        <span class="s3">|| </span><span class="s1">parent </span><span class="s2">instanceof </span><span class="s1">AST_Sequence </span><span class="s3">&amp;&amp; </span><span class="s1">node </span><span class="s3">=== </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">tail_node</span><span class="s3">()</span>
    <span class="s3">) {</span>
        <span class="s1">mark_escaped</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">scope</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">, </span><span class="s1">level </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">depth</span><span class="s3">);</span>
    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">parent </span><span class="s2">instanceof </span><span class="s1">AST_ObjectKeyVal </span><span class="s3">&amp;&amp; </span><span class="s1">node </span><span class="s3">=== </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">value</span><span class="s3">) {</span>
        <span class="s2">var </span><span class="s1">obj </span><span class="s3">= </span><span class="s1">tw</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">(</span><span class="s1">level </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">);</span>

        <span class="s1">mark_escaped</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">scope</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">level </span><span class="s3">+ </span><span class="s5">2</span><span class="s3">, </span><span class="s1">depth</span><span class="s3">);</span>
    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">parent </span><span class="s2">instanceof </span><span class="s1">AST_PropAccess </span><span class="s3">&amp;&amp; </span><span class="s1">node </span><span class="s3">=== </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">expression</span><span class="s3">) {</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">read_property</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">property</span><span class="s3">);</span>

        <span class="s1">mark_escaped</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">scope</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">level </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">depth </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">);</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">value</span><span class="s3">) </span><span class="s2">return</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">level </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">) </span><span class="s2">return</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">parent </span><span class="s2">instanceof </span><span class="s1">AST_Sequence </span><span class="s3">&amp;&amp; </span><span class="s1">node </span><span class="s3">!== </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">tail_node</span><span class="s3">()) </span><span class="s2">return</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">parent </span><span class="s2">instanceof </span><span class="s1">AST_SimpleStatement</span><span class="s3">) </span><span class="s2">return</span><span class="s3">;</span>

    <span class="s1">d</span><span class="s3">.</span><span class="s1">direct_access </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s2">const </span><span class="s1">suppress </span><span class="s3">= </span><span class="s1">node </span><span class="s3">=&gt; </span><span class="s1">walk</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">node </span><span class="s3">=&gt; {</span>
    <span class="s2">if </span><span class="s3">(!(</span><span class="s1">node </span><span class="s2">instanceof </span><span class="s1">AST_Symbol</span><span class="s3">)) </span><span class="s2">return</span><span class="s3">;</span>
    <span class="s2">var </span><span class="s1">d </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">definition</span><span class="s3">();</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">d</span><span class="s3">) </span><span class="s2">return</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">node </span><span class="s2">instanceof </span><span class="s1">AST_SymbolRef</span><span class="s3">) </span><span class="s1">d</span><span class="s3">.</span><span class="s1">references</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">node</span><span class="s3">);</span>
    <span class="s1">d</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_Accessor</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">descend</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">) {</span>
    <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">reset_variables</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">, </span><span class="s2">this</span><span class="s3">);</span>
    <span class="s1">descend</span><span class="s3">();</span>
    <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_Assign</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">descend</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">node </span><span class="s3">= </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">left </span><span class="s2">instanceof </span><span class="s1">AST_Destructuring</span><span class="s3">) {</span>
        <span class="s1">suppress</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">left</span><span class="s3">);</span>
        <span class="s2">return</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s2">const </span><span class="s1">finish_walk </span><span class="s3">= () =&gt; {</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">logical</span><span class="s3">) {</span>
            <span class="s1">node</span><span class="s3">.</span><span class="s1">left</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>

            <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
            <span class="s1">node</span><span class="s3">.</span><span class="s1">right</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
            <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>

            <span class="s2">return true</span><span class="s3">;</span>
        <span class="s3">}</span>
    <span class="s3">};</span>

    <span class="s2">var </span><span class="s1">sym </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">left</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(!(</span><span class="s1">sym </span><span class="s2">instanceof </span><span class="s1">AST_SymbolRef</span><span class="s3">)) </span><span class="s2">return </span><span class="s1">finish_walk</span><span class="s3">();</span>

    <span class="s2">var </span><span class="s1">def </span><span class="s3">= </span><span class="s1">sym</span><span class="s3">.</span><span class="s1">definition</span><span class="s3">();</span>
    <span class="s2">var </span><span class="s1">safe </span><span class="s3">= </span><span class="s1">safe_to_assign</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">def</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">.</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">right</span><span class="s3">);</span>
    <span class="s1">def</span><span class="s3">.</span><span class="s1">assignments</span><span class="s3">++;</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">safe</span><span class="s3">) </span><span class="s2">return </span><span class="s1">finish_walk</span><span class="s3">();</span>

    <span class="s2">var </span><span class="s1">fixed </span><span class="s3">= </span><span class="s1">def</span><span class="s3">.</span><span class="s1">fixed</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">fixed </span><span class="s3">&amp;&amp; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">operator </span><span class="s3">!= </span><span class="s4">&quot;=&quot; </span><span class="s3">&amp;&amp; !</span><span class="s1">node</span><span class="s3">.</span><span class="s1">logical</span><span class="s3">) </span><span class="s2">return </span><span class="s1">finish_walk</span><span class="s3">();</span>

    <span class="s2">var </span><span class="s1">eq </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">operator </span><span class="s3">== </span><span class="s4">&quot;=&quot;</span><span class="s3">;</span>
    <span class="s2">var </span><span class="s1">value </span><span class="s3">= </span><span class="s1">eq </span><span class="s3">? </span><span class="s1">node</span><span class="s3">.</span><span class="s1">right </span><span class="s3">: </span><span class="s1">node</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">is_modified</span><span class="s3">(</span><span class="s1">compressor</span><span class="s3">, </span><span class="s1">tw</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)) </span><span class="s2">return </span><span class="s1">finish_walk</span><span class="s3">();</span>

    <span class="s1">def</span><span class="s3">.</span><span class="s1">references</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">sym</span><span class="s3">);</span>

    <span class="s2">if </span><span class="s3">(!</span><span class="s1">node</span><span class="s3">.</span><span class="s1">logical</span><span class="s3">) {</span>
        <span class="s2">if </span><span class="s3">(!</span><span class="s1">eq</span><span class="s3">) </span><span class="s1">def</span><span class="s3">.</span><span class="s1">chained </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>

        <span class="s1">def</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">= </span><span class="s1">eq </span><span class="s3">? </span><span class="s2">function</span><span class="s3">() {</span>
            <span class="s2">return </span><span class="s1">node</span><span class="s3">.</span><span class="s1">right</span><span class="s3">;</span>
        <span class="s3">} : </span><span class="s2">function</span><span class="s3">() {</span>
            <span class="s2">return </span><span class="s1">make_node</span><span class="s3">(</span><span class="s1">AST_Binary</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, {</span>
                <span class="s1">operator</span><span class="s3">: </span><span class="s1">node</span><span class="s3">.</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">),</span>
                <span class="s1">left</span><span class="s3">: </span><span class="s1">fixed </span><span class="s2">instanceof </span><span class="s1">AST_Node </span><span class="s3">? </span><span class="s1">fixed </span><span class="s3">: </span><span class="s1">fixed</span><span class="s3">(),</span>
                <span class="s1">right</span><span class="s3">: </span><span class="s1">node</span><span class="s3">.</span><span class="s1">right</span>
            <span class="s3">});</span>
        <span class="s3">};</span>
    <span class="s3">}</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">logical</span><span class="s3">) {</span>
        <span class="s1">mark</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">def</span><span class="s3">, </span><span class="s2">false</span><span class="s3">);</span>
        <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
        <span class="s1">node</span><span class="s3">.</span><span class="s1">right</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
        <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
        <span class="s2">return true</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s1">mark</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">def</span><span class="s3">, </span><span class="s2">false</span><span class="s3">);</span>
    <span class="s1">node</span><span class="s3">.</span><span class="s1">right</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">mark</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">def</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>

    <span class="s1">mark_escaped</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">def</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">.</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">);</span>

    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_Binary</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">lazy_op</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">operator</span><span class="s3">)) </span><span class="s2">return</span><span class="s3">;</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">left</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">right</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_Block</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">descend</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">) {</span>
    <span class="s1">reset_block_variables</span><span class="s3">(</span><span class="s1">compressor</span><span class="s3">, </span><span class="s2">this</span><span class="s3">);</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_Case</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">) {</span>
    <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">expression</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">walk_body</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_Class</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">descend</span><span class="s3">) {</span>
    <span class="s1">clear_flag</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">INLINED</span><span class="s3">);</span>
    <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">descend</span><span class="s3">();</span>
    <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_ClassStaticBlock</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">descend</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">) {</span>
    <span class="s1">reset_block_variables</span><span class="s3">(</span><span class="s1">compressor</span><span class="s3">, </span><span class="s2">this</span><span class="s3">);</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_Conditional</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">) {</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">condition</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">consequent</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">alternative</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_Chain</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">descend</span><span class="s3">) {</span>
    <span class="s6">// Chains' conditions apply left-to-right, cumulatively.</span>
    <span class="s6">// If we walk normally we don't go in that order because we would pop before pushing again</span>
    <span class="s6">// Solution: AST_PropAccess and AST_Call push when they are optional, and never pop.</span>
    <span class="s6">// Then we pop everything when they are done being walked.</span>
    <span class="s2">const </span><span class="s1">safe_ids </span><span class="s3">= </span><span class="s1">tw</span><span class="s3">.</span><span class="s1">safe_ids</span><span class="s3">;</span>

    <span class="s1">descend</span><span class="s3">();</span>

    <span class="s6">// Unroll back to start</span>
    <span class="s1">tw</span><span class="s3">.</span><span class="s1">safe_ids </span><span class="s3">= </span><span class="s1">safe_ids</span><span class="s3">;</span>
    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_Call</span><span class="s3">, </span><span class="s2">function </span><span class="s3">(</span><span class="s1">tw</span><span class="s3">) {</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">expression</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">optional</span><span class="s3">) {</span>
        <span class="s6">// Never pop -- it's popped at AST_Chain above</span>
        <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s2">for </span><span class="s3">(</span><span class="s2">const </span><span class="s1">arg of </span><span class="s2">this</span><span class="s3">.</span><span class="s1">args</span><span class="s3">) </span><span class="s1">arg</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>

    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_PropAccess</span><span class="s3">, </span><span class="s2">function </span><span class="s3">(</span><span class="s1">tw</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s2">this</span><span class="s3">.</span><span class="s1">optional</span><span class="s3">) </span><span class="s2">return</span><span class="s3">;</span>

    <span class="s2">this</span><span class="s3">.</span><span class="s1">expression</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>

    <span class="s6">// Never pop -- it's popped at AST_Chain above</span>
    <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">property </span><span class="s2">instanceof </span><span class="s1">AST_Node</span><span class="s3">) </span><span class="s2">this</span><span class="s3">.</span><span class="s1">property</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>

    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_Default</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">descend</span><span class="s3">) {</span>
    <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">descend</span><span class="s3">();</span>
    <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s2">function </span><span class="s1">mark_lambda</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">descend</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">) {</span>
    <span class="s1">clear_flag</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">INLINED</span><span class="s3">);</span>
    <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">reset_variables</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">, </span><span class="s2">this</span><span class="s3">);</span>

    <span class="s2">var </span><span class="s1">iife</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s2">this</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s3">&amp;&amp; !</span><span class="s2">this</span><span class="s3">.</span><span class="s1">uses_arguments</span>
        <span class="s3">&amp;&amp; !</span><span class="s2">this</span><span class="s3">.</span><span class="s1">pinned</span><span class="s3">()</span>
        <span class="s3">&amp;&amp; (</span><span class="s1">iife </span><span class="s3">= </span><span class="s1">tw</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">()) </span><span class="s2">instanceof </span><span class="s1">AST_Call</span>
        <span class="s3">&amp;&amp; </span><span class="s1">iife</span><span class="s3">.</span><span class="s1">expression </span><span class="s3">=== </span><span class="s2">this</span>
        <span class="s3">&amp;&amp; !</span><span class="s1">iife</span><span class="s3">.</span><span class="s1">args</span><span class="s3">.</span><span class="s1">some</span><span class="s3">(</span><span class="s1">arg </span><span class="s3">=&gt; </span><span class="s1">arg </span><span class="s2">instanceof </span><span class="s1">AST_Expansion</span><span class="s3">)</span>
        <span class="s3">&amp;&amp; </span><span class="s2">this</span><span class="s3">.</span><span class="s1">argnames</span><span class="s3">.</span><span class="s1">every</span><span class="s3">(</span><span class="s1">arg_name </span><span class="s3">=&gt; </span><span class="s1">arg_name </span><span class="s2">instanceof </span><span class="s1">AST_Symbol</span><span class="s3">)</span>
    <span class="s3">) {</span>
        <span class="s6">// Virtually turn IIFE parameters into variable definitions:</span>
        <span class="s6">//   (function(a,b) {...})(c,d) =&gt; (function() {var a=c,b=d; ...})()</span>
        <span class="s6">// So existing transformation rules can work on them.</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s1">argnames</span><span class="s3">.</span><span class="s1">forEach</span><span class="s3">((</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">i</span><span class="s3">) =&gt; {</span>
            <span class="s2">if </span><span class="s3">(!</span><span class="s1">arg</span><span class="s3">.</span><span class="s1">definition</span><span class="s3">) </span><span class="s2">return</span><span class="s3">;</span>
            <span class="s2">var </span><span class="s1">d </span><span class="s3">= </span><span class="s1">arg</span><span class="s3">.</span><span class="s1">definition</span><span class="s3">();</span>
            <span class="s6">// Avoid setting fixed when there's more than one origin for a variable value</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">d</span><span class="s3">.</span><span class="s1">orig</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">) </span><span class="s2">return</span><span class="s3">;</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">d</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">=== </span><span class="s1">undefined </span><span class="s3">&amp;&amp; (!</span><span class="s2">this</span><span class="s3">.</span><span class="s1">uses_arguments </span><span class="s3">|| </span><span class="s1">tw</span><span class="s3">.</span><span class="s1">has_directive</span><span class="s3">(</span><span class="s4">&quot;use strict&quot;</span><span class="s3">))) {</span>
                <span class="s1">d</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">= </span><span class="s2">function</span><span class="s3">() {</span>
                    <span class="s2">return </span><span class="s1">iife</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] || </span><span class="s1">make_node</span><span class="s3">(</span><span class="s1">AST_Undefined</span><span class="s3">, </span><span class="s1">iife</span><span class="s3">);</span>
                <span class="s3">};</span>
                <span class="s1">tw</span><span class="s3">.</span><span class="s1">loop_ids</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">d</span><span class="s3">.</span><span class="s1">id</span><span class="s3">, </span><span class="s1">tw</span><span class="s3">.</span><span class="s1">in_loop</span><span class="s3">);</span>
                <span class="s1">mark</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
            <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
                <span class="s1">d</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
            <span class="s3">}</span>
        <span class="s3">});</span>
    <span class="s3">}</span>

    <span class="s1">descend</span><span class="s3">();</span>
    <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>

    <span class="s1">handle_defined_after_hoist</span><span class="s3">(</span><span class="s2">this</span><span class="s3">);</span>

    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* It's possible for a hoisted function to use something that's not defined yet. Example:</span>
 <span class="s0">*</span>
 <span class="s0">* hoisted();</span>
 <span class="s0">* var defined_after = true;</span>
 <span class="s0">* function hoisted() {</span>
 <span class="s0">*   // use defined_after</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* This function is called on the parent to handle this issue.</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">handle_defined_after_hoist</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">) {</span>
    <span class="s2">const </span><span class="s1">defuns </span><span class="s3">= [];</span>
    <span class="s1">walk</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">, </span><span class="s1">node </span><span class="s3">=&gt; {</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">node </span><span class="s3">=== </span><span class="s1">parent</span><span class="s3">) </span><span class="s2">return</span><span class="s3">;</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">node </span><span class="s2">instanceof </span><span class="s1">AST_Defun</span><span class="s3">) </span><span class="s1">defuns</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">node</span><span class="s3">);</span>
        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">node </span><span class="s2">instanceof </span><span class="s1">AST_Scope</span>
            <span class="s3">|| </span><span class="s1">node </span><span class="s2">instanceof </span><span class="s1">AST_SimpleStatement</span>
        <span class="s3">) </span><span class="s2">return true</span><span class="s3">;</span>
    <span class="s3">});</span>

    <span class="s2">const </span><span class="s1">symbols_of_interest </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Set</span><span class="s3">();</span>
    <span class="s2">const </span><span class="s1">defuns_of_interest </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Set</span><span class="s3">();</span>
    <span class="s2">const </span><span class="s1">potential_conflicts </span><span class="s3">= [];</span>

    <span class="s2">for </span><span class="s3">(</span><span class="s2">const </span><span class="s1">defun of defuns</span><span class="s3">) {</span>
        <span class="s2">const </span><span class="s1">fname_def </span><span class="s3">= </span><span class="s1">defun</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">definition</span><span class="s3">();</span>
        <span class="s2">const </span><span class="s1">found_self_ref_in_other_defuns </span><span class="s3">= </span><span class="s1">defuns</span><span class="s3">.</span><span class="s1">some</span><span class="s3">(</span>
            <span class="s1">d </span><span class="s3">=&gt; </span><span class="s1">d </span><span class="s3">!== </span><span class="s1">defun </span><span class="s3">&amp;&amp; </span><span class="s1">d</span><span class="s3">.</span><span class="s1">enclosed</span><span class="s3">.</span><span class="s1">indexOf</span><span class="s3">(</span><span class="s1">fname_def</span><span class="s3">) !== -</span><span class="s5">1</span>
        <span class="s3">);</span>

        <span class="s2">for </span><span class="s3">(</span><span class="s2">const </span><span class="s1">def of defun</span><span class="s3">.</span><span class="s1">enclosed</span><span class="s3">) {</span>
            <span class="s2">if </span><span class="s3">(</span>
                <span class="s1">def</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">=== </span><span class="s2">false</span>
                <span class="s3">|| </span><span class="s1">def </span><span class="s3">=== </span><span class="s1">fname_def</span>
                <span class="s3">|| </span><span class="s1">def</span><span class="s3">.</span><span class="s1">scope</span><span class="s3">.</span><span class="s1">get_defun_scope</span><span class="s3">() !== </span><span class="s1">parent</span>
            <span class="s3">) {</span>
                <span class="s2">continue</span><span class="s3">;</span>
            <span class="s3">}</span>

            <span class="s6">// defun is hoisted, so always safe</span>
            <span class="s2">if </span><span class="s3">(</span>
                <span class="s1">def</span><span class="s3">.</span><span class="s1">assignments </span><span class="s3">=== </span><span class="s5">0</span>
                <span class="s3">&amp;&amp; </span><span class="s1">def</span><span class="s3">.</span><span class="s1">orig</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s5">1</span>
                <span class="s3">&amp;&amp; </span><span class="s1">def</span><span class="s3">.</span><span class="s1">orig</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] </span><span class="s2">instanceof </span><span class="s1">AST_SymbolDefun</span>
            <span class="s3">) {</span>
                <span class="s2">continue</span><span class="s3">;</span>
            <span class="s3">}</span>

            <span class="s2">if </span><span class="s3">(</span><span class="s1">found_self_ref_in_other_defuns</span><span class="s3">) {</span>
                <span class="s1">def</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
                <span class="s2">continue</span><span class="s3">;</span>
            <span class="s3">}</span>

            <span class="s6">// for the slower checks below this loop</span>
            <span class="s1">potential_conflicts</span><span class="s3">.</span><span class="s1">push</span><span class="s3">({ </span><span class="s1">defun</span><span class="s3">, </span><span class="s1">def</span><span class="s3">, </span><span class="s1">fname_def </span><span class="s3">});</span>
            <span class="s1">symbols_of_interest</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">def</span><span class="s3">.</span><span class="s1">id</span><span class="s3">);</span>
            <span class="s1">symbols_of_interest</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">fname_def</span><span class="s3">.</span><span class="s1">id</span><span class="s3">);</span>
            <span class="s1">defuns_of_interest</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">defun</span><span class="s3">);</span>
        <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s6">// linearize all symbols, and locate defs that are read after the defun</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">potential_conflicts</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) {</span>
        <span class="s6">// All &quot;symbols of interest&quot;, that is, defuns or defs, that we found.</span>
        <span class="s6">// These are placed in order so we can check which is after which.</span>
        <span class="s2">const </span><span class="s1">found_symbols </span><span class="s3">= [];</span>
        <span class="s6">// Indices of `found_symbols` which are writes</span>
        <span class="s2">const </span><span class="s1">found_symbol_writes </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Set</span><span class="s3">();</span>
        <span class="s6">// Defun ranges are recorded because we don't care if a function uses the def internally</span>
        <span class="s2">const </span><span class="s1">defun_ranges </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Map</span><span class="s3">();</span>

        <span class="s2">let </span><span class="s1">tw</span><span class="s3">;</span>
        <span class="s1">parent</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">((</span><span class="s1">tw </span><span class="s3">= </span><span class="s2">new </span><span class="s1">TreeWalker</span><span class="s3">((</span><span class="s1">node</span><span class="s3">, </span><span class="s1">descend</span><span class="s3">) =&gt; {</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">node </span><span class="s2">instanceof </span><span class="s1">AST_Defun </span><span class="s3">&amp;&amp; </span><span class="s1">defuns_of_interest</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)) {</span>
                <span class="s2">const </span><span class="s1">start </span><span class="s3">= </span><span class="s1">found_symbols</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
                <span class="s1">descend</span><span class="s3">();</span>
                <span class="s2">const </span><span class="s1">end </span><span class="s3">= </span><span class="s1">found_symbols</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>

                <span class="s1">defun_ranges</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, { </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end </span><span class="s3">});</span>
                <span class="s2">return true</span><span class="s3">;</span>
            <span class="s3">}</span>
            <span class="s6">// if we found a defun on the list, mark IN_DEFUN=id and descend</span>

            <span class="s2">if </span><span class="s3">(</span><span class="s1">node </span><span class="s2">instanceof </span><span class="s1">AST_Symbol </span><span class="s3">&amp;&amp; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">thedef</span><span class="s3">) {</span>
                <span class="s2">const </span><span class="s1">id </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">definition</span><span class="s3">().</span><span class="s1">id</span><span class="s3">;</span>
                <span class="s2">if </span><span class="s3">(</span><span class="s1">symbols_of_interest</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">id</span><span class="s3">)) {</span>
                    <span class="s2">if </span><span class="s3">(</span><span class="s1">node </span><span class="s2">instanceof </span><span class="s1">AST_SymbolDeclaration </span><span class="s3">|| </span><span class="s1">is_lhs</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">tw</span><span class="s3">)) {</span>
                        <span class="s1">found_symbol_writes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">found_symbols</span><span class="s3">.</span><span class="s1">length</span><span class="s3">);</span>
                    <span class="s3">}</span>
                    <span class="s1">found_symbols</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">id</span><span class="s3">);</span>
                <span class="s3">}</span>
            <span class="s3">}</span>
        <span class="s3">})));</span>

        <span class="s2">for </span><span class="s3">(</span><span class="s2">const </span><span class="s3">{ </span><span class="s1">def</span><span class="s3">, </span><span class="s1">defun</span><span class="s3">, </span><span class="s1">fname_def </span><span class="s3">} </span><span class="s1">of potential_conflicts</span><span class="s3">) {</span>
            <span class="s2">const </span><span class="s1">defun_range </span><span class="s3">= </span><span class="s1">defun_ranges</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">defun</span><span class="s3">);</span>

            <span class="s6">// find the index in `found_symbols`, with some special rules:</span>
            <span class="s2">const </span><span class="s1">find </span><span class="s3">= (</span><span class="s1">sym_id</span><span class="s3">, </span><span class="s1">starting_at </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">must_be_write </span><span class="s3">= </span><span class="s2">false</span><span class="s3">) =&gt; {</span>
                <span class="s2">let </span><span class="s1">index </span><span class="s3">= </span><span class="s1">starting_at</span><span class="s3">;</span>

                <span class="s2">for </span><span class="s3">(;;) {</span>
                    <span class="s1">index </span><span class="s3">= </span><span class="s1">found_symbols</span><span class="s3">.</span><span class="s1">indexOf</span><span class="s3">(</span><span class="s1">sym_id</span><span class="s3">, </span><span class="s1">index</span><span class="s3">);</span>

                    <span class="s2">if </span><span class="s3">(</span><span class="s1">index </span><span class="s3">=== -</span><span class="s5">1</span><span class="s3">) {</span>
                        <span class="s2">break</span><span class="s3">;</span>
                    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">index </span><span class="s3">&gt;= </span><span class="s1">defun_range</span><span class="s3">.</span><span class="s1">start </span><span class="s3">&amp;&amp; </span><span class="s1">index </span><span class="s3">&lt; </span><span class="s1">defun_range</span><span class="s3">.</span><span class="s1">end</span><span class="s3">) {</span>
                        <span class="s1">index </span><span class="s3">= </span><span class="s1">defun_range</span><span class="s3">.</span><span class="s1">end</span><span class="s3">;</span>
                        <span class="s2">continue</span><span class="s3">;</span>
                    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">must_be_write </span><span class="s3">&amp;&amp; !</span><span class="s1">found_symbol_writes</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">index</span><span class="s3">)) {</span>
                        <span class="s1">index</span><span class="s3">++;</span>
                        <span class="s2">continue</span><span class="s3">;</span>
                    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
                        <span class="s2">break</span><span class="s3">;</span>
                    <span class="s3">}</span>
                <span class="s3">}</span>

                <span class="s2">return </span><span class="s1">index</span><span class="s3">;</span>
            <span class="s3">};</span>

            <span class="s2">const </span><span class="s1">read_defun_at </span><span class="s3">= </span><span class="s1">find</span><span class="s3">(</span><span class="s1">fname_def</span><span class="s3">.</span><span class="s1">id</span><span class="s3">);</span>
            <span class="s2">const </span><span class="s1">wrote_def_at </span><span class="s3">= </span><span class="s1">find</span><span class="s3">(</span><span class="s1">def</span><span class="s3">.</span><span class="s1">id</span><span class="s3">, </span><span class="s1">read_defun_at </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>

            <span class="s2">const </span><span class="s1">wrote_def_after_reading_defun </span><span class="s3">= </span><span class="s1">read_defun_at </span><span class="s3">!= -</span><span class="s5">1 </span><span class="s3">&amp;&amp; </span><span class="s1">wrote_def_at </span><span class="s3">!= -</span><span class="s5">1 </span><span class="s3">&amp;&amp; </span><span class="s1">wrote_def_at </span><span class="s3">&gt; </span><span class="s1">read_defun_at</span><span class="s3">;</span>

            <span class="s2">if </span><span class="s3">(</span><span class="s1">wrote_def_after_reading_defun</span><span class="s3">) {</span>
                <span class="s1">def</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
            <span class="s3">}</span>
        <span class="s3">}</span>
    <span class="s3">}</span>
<span class="s3">}</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_Lambda</span><span class="s3">, </span><span class="s1">mark_lambda</span><span class="s3">);</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_Do</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">descend</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">) {</span>
    <span class="s1">reset_block_variables</span><span class="s3">(</span><span class="s1">compressor</span><span class="s3">, </span><span class="s2">this</span><span class="s3">);</span>
    <span class="s2">const </span><span class="s1">saved_loop </span><span class="s3">= </span><span class="s1">tw</span><span class="s3">.</span><span class="s1">in_loop</span><span class="s3">;</span>
    <span class="s1">tw</span><span class="s3">.</span><span class="s1">in_loop </span><span class="s3">= </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">has_break_or_continue</span><span class="s3">(</span><span class="s2">this</span><span class="s3">)) {</span>
        <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
        <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">condition</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">tw</span><span class="s3">.</span><span class="s1">in_loop </span><span class="s3">= </span><span class="s1">saved_loop</span><span class="s3">;</span>
    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_For</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">descend</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">) {</span>
    <span class="s1">reset_block_variables</span><span class="s3">(</span><span class="s1">compressor</span><span class="s3">, </span><span class="s2">this</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">init</span><span class="s3">) </span><span class="s2">this</span><span class="s3">.</span><span class="s1">init</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">const </span><span class="s1">saved_loop </span><span class="s3">= </span><span class="s1">tw</span><span class="s3">.</span><span class="s1">in_loop</span><span class="s3">;</span>
    <span class="s1">tw</span><span class="s3">.</span><span class="s1">in_loop </span><span class="s3">= </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">condition</span><span class="s3">) </span><span class="s2">this</span><span class="s3">.</span><span class="s1">condition</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">step</span><span class="s3">) {</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">has_break_or_continue</span><span class="s3">(</span><span class="s2">this</span><span class="s3">)) {</span>
            <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
            <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
        <span class="s3">}</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s1">step</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">tw</span><span class="s3">.</span><span class="s1">in_loop </span><span class="s3">= </span><span class="s1">saved_loop</span><span class="s3">;</span>
    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_ForIn</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">descend</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">) {</span>
    <span class="s1">reset_block_variables</span><span class="s3">(</span><span class="s1">compressor</span><span class="s3">, </span><span class="s2">this</span><span class="s3">);</span>
    <span class="s1">suppress</span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">init</span><span class="s3">);</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">object</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">const </span><span class="s1">saved_loop </span><span class="s3">= </span><span class="s1">tw</span><span class="s3">.</span><span class="s1">in_loop</span><span class="s3">;</span>
    <span class="s1">tw</span><span class="s3">.</span><span class="s1">in_loop </span><span class="s3">= </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">tw</span><span class="s3">.</span><span class="s1">in_loop </span><span class="s3">= </span><span class="s1">saved_loop</span><span class="s3">;</span>
    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_If</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">) {</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">condition</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">alternative</span><span class="s3">) {</span>
        <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s1">alternative</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
        <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_LabeledStatement</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">) {</span>
    <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_SymbolCatch</span><span class="s3">, </span><span class="s2">function</span><span class="s3">() {</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">definition</span><span class="s3">().</span><span class="s1">fixed </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_SymbolRef</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">descend</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">d </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">definition</span><span class="s3">();</span>
    <span class="s1">d</span><span class="s3">.</span><span class="s1">references</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s2">this</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">d</span><span class="s3">.</span><span class="s1">references</span><span class="s3">.</span><span class="s1">length </span><span class="s3">== </span><span class="s5">1</span>
        <span class="s3">&amp;&amp; !</span><span class="s1">d</span><span class="s3">.</span><span class="s1">fixed</span>
        <span class="s3">&amp;&amp; </span><span class="s1">d</span><span class="s3">.</span><span class="s1">orig</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] </span><span class="s2">instanceof </span><span class="s1">AST_SymbolDefun</span><span class="s3">) {</span>
        <span class="s1">tw</span><span class="s3">.</span><span class="s1">loop_ids</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">d</span><span class="s3">.</span><span class="s1">id</span><span class="s3">, </span><span class="s1">tw</span><span class="s3">.</span><span class="s1">in_loop</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s2">var </span><span class="s1">fixed_value</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">d</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">=== </span><span class="s1">undefined </span><span class="s3">|| !</span><span class="s1">safe_to_read</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">d</span><span class="s3">)) {</span>
        <span class="s1">d</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">d</span><span class="s3">.</span><span class="s1">fixed</span><span class="s3">) {</span>
        <span class="s1">fixed_value </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">fixed_value</span><span class="s3">();</span>
        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">fixed_value </span><span class="s2">instanceof </span><span class="s1">AST_Lambda</span>
            <span class="s3">&amp;&amp; </span><span class="s1">is_recursive_ref</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">d</span><span class="s3">)</span>
        <span class="s3">) {</span>
            <span class="s1">d</span><span class="s3">.</span><span class="s1">recursive_refs</span><span class="s3">++;</span>
        <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">fixed_value</span>
            <span class="s3">&amp;&amp; !</span><span class="s1">compressor</span><span class="s3">.</span><span class="s1">exposed</span><span class="s3">(</span><span class="s1">d</span><span class="s3">)</span>
            <span class="s3">&amp;&amp; </span><span class="s1">ref_once</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">, </span><span class="s1">d</span><span class="s3">)</span>
        <span class="s3">) {</span>
            <span class="s1">d</span><span class="s3">.</span><span class="s1">single_use </span><span class="s3">=</span>
                <span class="s1">fixed_value </span><span class="s2">instanceof </span><span class="s1">AST_Lambda </span><span class="s3">&amp;&amp; !</span><span class="s1">fixed_value</span><span class="s3">.</span><span class="s1">pinned</span><span class="s3">()</span>
                <span class="s3">|| </span><span class="s1">fixed_value </span><span class="s2">instanceof </span><span class="s1">AST_Class</span>
                <span class="s3">|| </span><span class="s1">d</span><span class="s3">.</span><span class="s1">scope </span><span class="s3">=== </span><span class="s2">this</span><span class="s3">.</span><span class="s1">scope </span><span class="s3">&amp;&amp; </span><span class="s1">fixed_value</span><span class="s3">.</span><span class="s1">is_constant_expression</span><span class="s3">();</span>
        <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
            <span class="s1">d</span><span class="s3">.</span><span class="s1">single_use </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
        <span class="s3">}</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">is_modified</span><span class="s3">(</span><span class="s1">compressor</span><span class="s3">, </span><span class="s1">tw</span><span class="s3">, </span><span class="s2">this</span><span class="s3">, </span><span class="s1">fixed_value</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">is_immutable</span><span class="s3">(</span><span class="s1">fixed_value</span><span class="s3">))) {</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">d</span><span class="s3">.</span><span class="s1">single_use</span><span class="s3">) {</span>
                <span class="s1">d</span><span class="s3">.</span><span class="s1">single_use </span><span class="s3">= </span><span class="s4">&quot;m&quot;</span><span class="s3">;</span>
            <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
                <span class="s1">d</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
            <span class="s3">}</span>
        <span class="s3">}</span>
    <span class="s3">}</span>
    <span class="s1">mark_escaped</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s2">this</span><span class="s3">.</span><span class="s1">scope</span><span class="s3">, </span><span class="s2">this</span><span class="s3">, </span><span class="s1">fixed_value</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">);</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_Toplevel</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">descend</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">) {</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">globals</span><span class="s3">.</span><span class="s1">forEach</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">def</span><span class="s3">) {</span>
        <span class="s1">reset_def</span><span class="s3">(</span><span class="s1">compressor</span><span class="s3">, </span><span class="s1">def</span><span class="s3">);</span>
    <span class="s3">});</span>
    <span class="s1">reset_variables</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">, </span><span class="s2">this</span><span class="s3">);</span>
    <span class="s1">descend</span><span class="s3">();</span>
    <span class="s1">handle_defined_after_hoist</span><span class="s3">(</span><span class="s2">this</span><span class="s3">);</span>
    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_Try</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">descend</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">) {</span>
    <span class="s1">reset_block_variables</span><span class="s3">(</span><span class="s1">compressor</span><span class="s3">, </span><span class="s2">this</span><span class="s3">);</span>
    <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">bcatch</span><span class="s3">) {</span>
        <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s1">bcatch</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
        <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">bfinally</span><span class="s3">) </span><span class="s2">this</span><span class="s3">.</span><span class="s1">bfinally</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_Unary</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">node </span><span class="s3">= </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">operator </span><span class="s3">!== </span><span class="s4">&quot;++&quot; </span><span class="s3">&amp;&amp; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">operator </span><span class="s3">!== </span><span class="s4">&quot;--&quot;</span><span class="s3">) </span><span class="s2">return</span><span class="s3">;</span>
    <span class="s2">var </span><span class="s1">exp </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">expression</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(!(</span><span class="s1">exp </span><span class="s2">instanceof </span><span class="s1">AST_SymbolRef</span><span class="s3">)) </span><span class="s2">return</span><span class="s3">;</span>
    <span class="s2">var </span><span class="s1">def </span><span class="s3">= </span><span class="s1">exp</span><span class="s3">.</span><span class="s1">definition</span><span class="s3">();</span>
    <span class="s2">var </span><span class="s1">safe </span><span class="s3">= </span><span class="s1">safe_to_assign</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">def</span><span class="s3">, </span><span class="s1">exp</span><span class="s3">.</span><span class="s1">scope</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
    <span class="s1">def</span><span class="s3">.</span><span class="s1">assignments</span><span class="s3">++;</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">safe</span><span class="s3">) </span><span class="s2">return</span><span class="s3">;</span>
    <span class="s2">var </span><span class="s1">fixed </span><span class="s3">= </span><span class="s1">def</span><span class="s3">.</span><span class="s1">fixed</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">fixed</span><span class="s3">) </span><span class="s2">return</span><span class="s3">;</span>
    <span class="s1">def</span><span class="s3">.</span><span class="s1">references</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">exp</span><span class="s3">);</span>
    <span class="s1">def</span><span class="s3">.</span><span class="s1">chained </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>
    <span class="s1">def</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">= </span><span class="s2">function</span><span class="s3">() {</span>
        <span class="s2">return </span><span class="s1">make_node</span><span class="s3">(</span><span class="s1">AST_Binary</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, {</span>
            <span class="s1">operator</span><span class="s3">: </span><span class="s1">node</span><span class="s3">.</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">),</span>
            <span class="s1">left</span><span class="s3">: </span><span class="s1">make_node</span><span class="s3">(</span><span class="s1">AST_UnaryPrefix</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, {</span>
                <span class="s1">operator</span><span class="s3">: </span><span class="s4">&quot;+&quot;</span><span class="s3">,</span>
                <span class="s1">expression</span><span class="s3">: </span><span class="s1">fixed </span><span class="s2">instanceof </span><span class="s1">AST_Node </span><span class="s3">? </span><span class="s1">fixed </span><span class="s3">: </span><span class="s1">fixed</span><span class="s3">()</span>
            <span class="s3">}),</span>
            <span class="s1">right</span><span class="s3">: </span><span class="s1">make_node</span><span class="s3">(</span><span class="s1">AST_Number</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, {</span>
                <span class="s1">value</span><span class="s3">: </span><span class="s5">1</span>
            <span class="s3">})</span>
        <span class="s3">});</span>
    <span class="s3">};</span>
    <span class="s1">mark</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">def</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_VarDef</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">descend</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">node </span><span class="s3">= </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">name </span><span class="s2">instanceof </span><span class="s1">AST_Destructuring</span><span class="s3">) {</span>
        <span class="s1">suppress</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">);</span>
        <span class="s2">return</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">var </span><span class="s1">d </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">definition</span><span class="s3">();</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">) {</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">safe_to_assign</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)) {</span>
            <span class="s1">d</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">= </span><span class="s2">function</span><span class="s3">() {</span>
                <span class="s2">return </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">;</span>
            <span class="s3">};</span>
            <span class="s1">tw</span><span class="s3">.</span><span class="s1">loop_ids</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">d</span><span class="s3">.</span><span class="s1">id</span><span class="s3">, </span><span class="s1">tw</span><span class="s3">.</span><span class="s1">in_loop</span><span class="s3">);</span>
            <span class="s1">mark</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s2">false</span><span class="s3">);</span>
            <span class="s1">descend</span><span class="s3">();</span>
            <span class="s1">mark</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
            <span class="s2">return true</span><span class="s3">;</span>
        <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
            <span class="s1">d</span><span class="s3">.</span><span class="s1">fixed </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
        <span class="s3">}</span>
    <span class="s3">}</span>
<span class="s3">});</span>

<span class="s1">def_reduce_vars</span><span class="s3">(</span><span class="s1">AST_While</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">, </span><span class="s1">descend</span><span class="s3">, </span><span class="s1">compressor</span><span class="s3">) {</span>
    <span class="s1">reset_block_variables</span><span class="s3">(</span><span class="s1">compressor</span><span class="s3">, </span><span class="s2">this</span><span class="s3">);</span>
    <span class="s2">const </span><span class="s1">saved_loop </span><span class="s3">= </span><span class="s1">tw</span><span class="s3">.</span><span class="s1">in_loop</span><span class="s3">;</span>
    <span class="s1">tw</span><span class="s3">.</span><span class="s1">in_loop </span><span class="s3">= </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s1">push</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">descend</span><span class="s3">();</span>
    <span class="s1">pop</span><span class="s3">(</span><span class="s1">tw</span><span class="s3">);</span>
    <span class="s1">tw</span><span class="s3">.</span><span class="s1">in_loop </span><span class="s3">= </span><span class="s1">saved_loop</span><span class="s3">;</span>
    <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">});</span>
</pre>
</body>
</html>