<html>
<head>
<title>784eeb44942c572930519ed4b7ebbaea525204829abbd8e44cf591f3ac22abf1.json</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #cf8e6d;}
.s3 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
784eeb44942c572930519ed4b7ebbaea525204829abbd8e44cf591f3ac22abf1.json</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;ast&quot;</span><span class="s0">:</span><span class="s2">null</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">:</span><span class="s1">&quot;'use strict';</span><span class="s2">\n\n</span><span class="s1">import </span><span class="s2">\&quot;</span><span class="s1">core-js/modules/es.typed-array.to-reversed.js</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import </span><span class="s2">\&quot;</span><span class="s1">core-js/modules/es.typed-array.to-sorted.js</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import </span><span class="s2">\&quot;</span><span class="s1">core-js/modules/es.typed-array.with.js</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import </span><span class="s2">\&quot;</span><span class="s1">core-js/modules/es.array.push.js</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import bind from './helpers/bind.js';</span><span class="s2">\n\n</span><span class="s1">// utils is a library of generic helper functions non-specific to axios</span><span class="s2">\n\n</span><span class="s1">const {</span><span class="s2">\n  </span><span class="s1">toString</span><span class="s2">\n</span><span class="s1">} = Object.prototype;</span><span class="s2">\n</span><span class="s1">const {</span><span class="s2">\n  </span><span class="s1">getPrototypeOf</span><span class="s2">\n</span><span class="s1">} = Object;</span><span class="s2">\n</span><span class="s1">const kindOf = (cache =&gt; thing =&gt; {</span><span class="s2">\n  </span><span class="s1">const str = toString.call(thing);</span><span class="s2">\n  </span><span class="s1">return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());</span><span class="s2">\n</span><span class="s1">})(Object.create(null));</span><span class="s2">\n</span><span class="s1">const kindOfTest = type =&gt; {</span><span class="s2">\n  </span><span class="s1">type = type.toLowerCase();</span><span class="s2">\n  </span><span class="s1">return thing =&gt; kindOf(thing) === type;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const typeOfTest = type =&gt; thing =&gt; typeof thing === type;</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is an Array</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {Object} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is an Array, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const {</span><span class="s2">\n  </span><span class="s1">isArray</span><span class="s2">\n</span><span class="s1">} = Array;</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is undefined</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if the value is undefined, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isUndefined = typeOfTest('undefined');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a Buffer</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a Buffer, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isBuffer(val) {</span><span class="s2">\n  </span><span class="s1">return val !== null &amp;&amp; !isUndefined(val) &amp;&amp; val.constructor !== null &amp;&amp; !isUndefined(val.constructor) &amp;&amp; isFunction(val.constructor.isBuffer) &amp;&amp; val.constructor.isBuffer(val);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is an ArrayBuffer</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is an ArrayBuffer, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isArrayBuffer = kindOfTest('ArrayBuffer');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a view on an ArrayBuffer</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isArrayBufferView(val) {</span><span class="s2">\n  </span><span class="s1">let result;</span><span class="s2">\n  </span><span class="s1">if (typeof ArrayBuffer !== 'undefined' &amp;&amp; ArrayBuffer.isView) {</span><span class="s2">\n    </span><span class="s1">result = ArrayBuffer.isView(val);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">result = val &amp;&amp; val.buffer &amp;&amp; isArrayBuffer(val.buffer);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a String</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a String, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isString = typeOfTest('string');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a Function</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a Function, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isFunction = typeOfTest('function');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a Number</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a Number, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isNumber = typeOfTest('number');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is an Object</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} thing The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is an Object, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isObject = thing =&gt; thing !== null &amp;&amp; typeof thing === 'object';</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a Boolean</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} thing The value to test</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a Boolean, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isBoolean = thing =&gt; thing === true || thing === false;</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a plain Object</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a plain Object, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isPlainObject = val =&gt; {</span><span class="s2">\n  </span><span class="s1">if (kindOf(val) !== 'object') {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">const prototype = getPrototypeOf(val);</span><span class="s2">\n  </span><span class="s1">return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) &amp;&amp; !(Symbol.toStringTag in val) &amp;&amp; !(Symbol.iterator in val);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a Date</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a Date, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isDate = kindOfTest('Date');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a File</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a File, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isFile = kindOfTest('File');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a Blob</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a Blob, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isBlob = kindOfTest('Blob');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a FileList</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a File, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isFileList = kindOfTest('FileList');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a Stream</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a Stream, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isStream = val =&gt; isObject(val) &amp;&amp; isFunction(val.pipe);</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a FormData</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} thing The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is an FormData, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isFormData = thing =&gt; {</span><span class="s2">\n  </span><span class="s1">let kind;</span><span class="s2">\n  </span><span class="s1">return thing &amp;&amp; (typeof FormData === 'function' &amp;&amp; thing instanceof FormData || isFunction(thing.append) &amp;&amp; ((kind = kindOf(thing)) === 'formdata' ||</span><span class="s2">\n  </span><span class="s1">// detect form-data instance</span><span class="s2">\n  </span><span class="s1">kind === 'object' &amp;&amp; isFunction(thing.toString) &amp;&amp; thing.toString() === '[object FormData]'));</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a URLSearchParams object</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a URLSearchParams object, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isURLSearchParams = kindOfTest('URLSearchParams');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Trim excess whitespace off the beginning and end of a string</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {String} str The String to trim</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {String} The String freed of excess whitespace</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const trim = str =&gt; str.trim ? str.trim() : str.replace(/^[</span><span class="s2">\\</span><span class="s1">s</span><span class="s2">\\</span><span class="s1">uFEFF</span><span class="s2">\\</span><span class="s1">xA0]+|[</span><span class="s2">\\</span><span class="s1">s</span><span class="s2">\\</span><span class="s1">uFEFF</span><span class="s2">\\</span><span class="s1">xA0]+$/g, '');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Iterate over an Array or an Object invoking a function for each item.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* If `obj` is an Array callback will be called passing</span><span class="s2">\n </span><span class="s1">* the value, index, and complete array for each item.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* If 'obj' is an Object callback will be called passing</span><span class="s2">\n </span><span class="s1">* the value, key, and complete object for each property.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {Object|Array} obj The object to iterate</span><span class="s2">\n </span><span class="s1">* @param {Function} fn The callback to invoke for each item</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {Boolean} [allOwnKeys = false]</span><span class="s2">\n </span><span class="s1">* @returns {any}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function forEach(obj, fn, {</span><span class="s2">\n  </span><span class="s1">allOwnKeys = false</span><span class="s2">\n</span><span class="s1">} = {}) {</span><span class="s2">\n  </span><span class="s1">// Don't bother if no value provided</span><span class="s2">\n  </span><span class="s1">if (obj === null || typeof obj === 'undefined') {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let i;</span><span class="s2">\n  </span><span class="s1">let l;</span><span class="s2">\n\n  </span><span class="s1">// Force an array if not already something iterable</span><span class="s2">\n  </span><span class="s1">if (typeof obj !== 'object') {</span><span class="s2">\n    </span><span class="s1">/*eslint no-param-reassign:0*/</span><span class="s2">\n    </span><span class="s1">obj = [obj];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isArray(obj)) {</span><span class="s2">\n    </span><span class="s1">// Iterate over array values</span><span class="s2">\n    </span><span class="s1">for (i = 0, l = obj.length; i &lt; l; i++) {</span><span class="s2">\n      </span><span class="s1">fn.call(null, obj[i], i, obj);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">// Iterate over object keys</span><span class="s2">\n    </span><span class="s1">const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);</span><span class="s2">\n    </span><span class="s1">const len = keys.length;</span><span class="s2">\n    </span><span class="s1">let key;</span><span class="s2">\n    </span><span class="s1">for (i = 0; i &lt; len; i++) {</span><span class="s2">\n      </span><span class="s1">key = keys[i];</span><span class="s2">\n      </span><span class="s1">fn.call(null, obj[key], key, obj);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function findKey(obj, key) {</span><span class="s2">\n  </span><span class="s1">key = key.toLowerCase();</span><span class="s2">\n  </span><span class="s1">const keys = Object.keys(obj);</span><span class="s2">\n  </span><span class="s1">let i = keys.length;</span><span class="s2">\n  </span><span class="s1">let _key;</span><span class="s2">\n  </span><span class="s1">while (i-- &gt; 0) {</span><span class="s2">\n    </span><span class="s1">_key = keys[i];</span><span class="s2">\n    </span><span class="s1">if (key === _key.toLowerCase()) {</span><span class="s2">\n      </span><span class="s1">return _key;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const _global = (() =&gt; {</span><span class="s2">\n  </span><span class="s1">/*eslint no-undef:0*/</span><span class="s2">\n  </span><span class="s1">if (typeof globalThis !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) return globalThis;</span><span class="s2">\n  </span><span class="s1">return typeof self !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">? self : typeof window !== 'undefined' ? window : global;</span><span class="s2">\n</span><span class="s1">})();</span><span class="s2">\n</span><span class="s1">const isContextDefined = context =&gt; !isUndefined(context) &amp;&amp; context !== _global;</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Accepts varargs expecting each argument to be an object, then</span><span class="s2">\n </span><span class="s1">* immutably merges the properties of each object and returns result.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* When multiple objects contain the same key the later object in</span><span class="s2">\n </span><span class="s1">* the arguments list will take precedence.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Example:</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* ```js</span><span class="s2">\n </span><span class="s1">* var result = merge({foo: 123}, {foo: 456});</span><span class="s2">\n </span><span class="s1">* console.log(result.foo); // outputs 456</span><span class="s2">\n </span><span class="s1">* ```</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {Object} obj1 Object to merge</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {Object} Result of all merge properties</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function merge( /* obj1, obj2, obj3, ... */</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">const {</span><span class="s2">\n    </span><span class="s1">caseless</span><span class="s2">\n  </span><span class="s1">} = isContextDefined(this) &amp;&amp; this || {};</span><span class="s2">\n  </span><span class="s1">const result = {};</span><span class="s2">\n  </span><span class="s1">const assignValue = (val, key) =&gt; {</span><span class="s2">\n    </span><span class="s1">const targetKey = caseless &amp;&amp; findKey(result, key) || key;</span><span class="s2">\n    </span><span class="s1">if (isPlainObject(result[targetKey]) &amp;&amp; isPlainObject(val)) {</span><span class="s2">\n      </span><span class="s1">result[targetKey] = merge(result[targetKey], val);</span><span class="s2">\n    </span><span class="s1">} else if (isPlainObject(val)) {</span><span class="s2">\n      </span><span class="s1">result[targetKey] = merge({}, val);</span><span class="s2">\n    </span><span class="s1">} else if (isArray(val)) {</span><span class="s2">\n      </span><span class="s1">result[targetKey] = val.slice();</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">result[targetKey] = val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">for (let i = 0, l = arguments.length; i &lt; l; i++) {</span><span class="s2">\n    </span><span class="s1">arguments[i] &amp;&amp; forEach(arguments[i], assignValue);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Extends object a by mutably adding to it the properties of object b.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {Object} a The object to be extended</span><span class="s2">\n </span><span class="s1">* @param {Object} b The object to copy properties from</span><span class="s2">\n </span><span class="s1">* @param {Object} thisArg The object to bind function to</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {Boolean} [allOwnKeys]</span><span class="s2">\n </span><span class="s1">* @returns {Object} The resulting value of object a</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const extend = (a, b, thisArg, {</span><span class="s2">\n  </span><span class="s1">allOwnKeys</span><span class="s2">\n</span><span class="s1">} = {}) =&gt; {</span><span class="s2">\n  </span><span class="s1">forEach(b, (val, key) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (thisArg &amp;&amp; isFunction(val)) {</span><span class="s2">\n      </span><span class="s1">a[key] = bind(val, thisArg);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">a[key] = val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, {</span><span class="s2">\n    </span><span class="s1">allOwnKeys</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return a;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {string} content with BOM</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {string} content value without BOM</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const stripBOM = content =&gt; {</span><span class="s2">\n  </span><span class="s1">if (content.charCodeAt(0) === 0xFEFF) {</span><span class="s2">\n    </span><span class="s1">content = content.slice(1);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return content;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Inherit the prototype methods from one constructor into another</span><span class="s2">\n </span><span class="s1">* @param {function} constructor</span><span class="s2">\n </span><span class="s1">* @param {function} superConstructor</span><span class="s2">\n </span><span class="s1">* @param {object} [props]</span><span class="s2">\n </span><span class="s1">* @param {object} [descriptors]</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {void}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const inherits = (constructor, superConstructor, props, descriptors) =&gt; {</span><span class="s2">\n  </span><span class="s1">constructor.prototype = Object.create(superConstructor.prototype, descriptors);</span><span class="s2">\n  </span><span class="s1">constructor.prototype.constructor = constructor;</span><span class="s2">\n  </span><span class="s1">Object.defineProperty(constructor, 'super', {</span><span class="s2">\n    </span><span class="s1">value: superConstructor.prototype</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">props &amp;&amp; Object.assign(constructor.prototype, props);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Resolve object with deep prototype chain to a flat object</span><span class="s2">\n </span><span class="s1">* @param {Object} sourceObj source object</span><span class="s2">\n </span><span class="s1">* @param {Object} [destObj]</span><span class="s2">\n </span><span class="s1">* @param {Function|Boolean} [filter]</span><span class="s2">\n </span><span class="s1">* @param {Function} [propFilter]</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {Object}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const toFlatObject = (sourceObj, destObj, filter, propFilter) =&gt; {</span><span class="s2">\n  </span><span class="s1">let props;</span><span class="s2">\n  </span><span class="s1">let i;</span><span class="s2">\n  </span><span class="s1">let prop;</span><span class="s2">\n  </span><span class="s1">const merged = {};</span><span class="s2">\n  </span><span class="s1">destObj = destObj || {};</span><span class="s2">\n  </span><span class="s1">// eslint-disable-next-line no-eq-null,eqeqeq</span><span class="s2">\n  </span><span class="s1">if (sourceObj == null) return destObj;</span><span class="s2">\n  </span><span class="s1">do {</span><span class="s2">\n    </span><span class="s1">props = Object.getOwnPropertyNames(sourceObj);</span><span class="s2">\n    </span><span class="s1">i = props.length;</span><span class="s2">\n    </span><span class="s1">while (i-- &gt; 0) {</span><span class="s2">\n      </span><span class="s1">prop = props[i];</span><span class="s2">\n      </span><span class="s1">if ((!propFilter || propFilter(prop, sourceObj, destObj)) &amp;&amp; !merged[prop]) {</span><span class="s2">\n        </span><span class="s1">destObj[prop] = sourceObj[prop];</span><span class="s2">\n        </span><span class="s1">merged[prop] = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">sourceObj = filter !== false &amp;&amp; getPrototypeOf(sourceObj);</span><span class="s2">\n  </span><span class="s1">} while (sourceObj &amp;&amp; (!filter || filter(sourceObj, destObj)) &amp;&amp; sourceObj !== Object.prototype);</span><span class="s2">\n  </span><span class="s1">return destObj;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determines whether a string ends with the characters of a specified string</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {String} str</span><span class="s2">\n </span><span class="s1">* @param {String} searchString</span><span class="s2">\n </span><span class="s1">* @param {Number} [position= 0]</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const endsWith = (str, searchString, position) =&gt; {</span><span class="s2">\n  </span><span class="s1">str = String(str);</span><span class="s2">\n  </span><span class="s1">if (position === undefined || position &gt; str.length) {</span><span class="s2">\n    </span><span class="s1">position = str.length;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">position -= searchString.length;</span><span class="s2">\n  </span><span class="s1">const lastIndex = str.indexOf(searchString, position);</span><span class="s2">\n  </span><span class="s1">return lastIndex !== -1 &amp;&amp; lastIndex === position;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Returns new array from array like object or null if failed</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} [thing]</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {?Array}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const toArray = thing =&gt; {</span><span class="s2">\n  </span><span class="s1">if (!thing) return null;</span><span class="s2">\n  </span><span class="s1">if (isArray(thing)) return thing;</span><span class="s2">\n  </span><span class="s1">let i = thing.length;</span><span class="s2">\n  </span><span class="s1">if (!isNumber(i)) return null;</span><span class="s2">\n  </span><span class="s1">const arr = new Array(i);</span><span class="s2">\n  </span><span class="s1">while (i-- &gt; 0) {</span><span class="s2">\n    </span><span class="s1">arr[i] = thing[i];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return arr;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Checking if the Uint8Array exists and if it does, it returns a function that checks if the</span><span class="s2">\n </span><span class="s1">* thing passed in is an instance of Uint8Array</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {TypedArray}</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {Array}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">// eslint-disable-next-line func-names</span><span class="s2">\n</span><span class="s1">const isTypedArray = (TypedArray =&gt; {</span><span class="s2">\n  </span><span class="s1">// eslint-disable-next-line func-names</span><span class="s2">\n  </span><span class="s1">return thing =&gt; {</span><span class="s2">\n    </span><span class="s1">return TypedArray &amp;&amp; thing instanceof TypedArray;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">})(typeof Uint8Array !== 'undefined' &amp;&amp; getPrototypeOf(Uint8Array));</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* For each entry in the object, call the function with the key and value.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {Object&lt;any, any&gt;} obj - The object to iterate over.</span><span class="s2">\n </span><span class="s1">* @param {Function} fn - The function to call for each entry.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {void}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const forEachEntry = (obj, fn) =&gt; {</span><span class="s2">\n  </span><span class="s1">const generator = obj &amp;&amp; obj[Symbol.iterator];</span><span class="s2">\n  </span><span class="s1">const iterator = generator.call(obj);</span><span class="s2">\n  </span><span class="s1">let result;</span><span class="s2">\n  </span><span class="s1">while ((result = iterator.next()) &amp;&amp; !result.done) {</span><span class="s2">\n    </span><span class="s1">const pair = result.value;</span><span class="s2">\n    </span><span class="s1">fn.call(obj, pair[0], pair[1]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* It takes a regular expression and a string, and returns an array of all the matches</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {string} regExp - The regular expression to match against.</span><span class="s2">\n </span><span class="s1">* @param {string} str - The string to search.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {Array&lt;boolean&gt;}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const matchAll = (regExp, str) =&gt; {</span><span class="s2">\n  </span><span class="s1">let matches;</span><span class="s2">\n  </span><span class="s1">const arr = [];</span><span class="s2">\n  </span><span class="s1">while ((matches = regExp.exec(str)) !== null) {</span><span class="s2">\n    </span><span class="s1">arr.push(matches);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return arr;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */</span><span class="s2">\n</span><span class="s1">const isHTMLForm = kindOfTest('HTMLFormElement');</span><span class="s2">\n</span><span class="s1">const toCamelCase = str =&gt; {</span><span class="s2">\n  </span><span class="s1">return str.toLowerCase().replace(/[-_</span><span class="s2">\\</span><span class="s1">s]([a-z</span><span class="s2">\\</span><span class="s1">d])(</span><span class="s2">\\</span><span class="s1">w*)/g, function replacer(m, p1, p2) {</span><span class="s2">\n    </span><span class="s1">return p1.toUpperCase() + p2;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/* Creating a function that will check if an object has a property. */</span><span class="s2">\n</span><span class="s1">const hasOwnProperty = (({</span><span class="s2">\n  </span><span class="s1">hasOwnProperty</span><span class="s2">\n</span><span class="s1">}) =&gt; (obj, prop) =&gt; hasOwnProperty.call(obj, prop))(Object.prototype);</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a RegExp object</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a RegExp object, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isRegExp = kindOfTest('RegExp');</span><span class="s2">\n</span><span class="s1">const reduceDescriptors = (obj, reducer) =&gt; {</span><span class="s2">\n  </span><span class="s1">const descriptors = Object.getOwnPropertyDescriptors(obj);</span><span class="s2">\n  </span><span class="s1">const reducedDescriptors = {};</span><span class="s2">\n  </span><span class="s1">forEach(descriptors, (descriptor, name) =&gt; {</span><span class="s2">\n    </span><span class="s1">let ret;</span><span class="s2">\n    </span><span class="s1">if ((ret = reducer(descriptor, name, obj)) !== false) {</span><span class="s2">\n      </span><span class="s1">reducedDescriptors[name] = ret || descriptor;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">Object.defineProperties(obj, reducedDescriptors);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Makes all methods read-only</span><span class="s2">\n </span><span class="s1">* @param {Object} obj</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n\n</span><span class="s1">const freezeMethods = obj =&gt; {</span><span class="s2">\n  </span><span class="s1">reduceDescriptors(obj, (descriptor, name) =&gt; {</span><span class="s2">\n    </span><span class="s1">// skip restricted props in strict mode</span><span class="s2">\n    </span><span class="s1">if (isFunction(obj) &amp;&amp; ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const value = obj[name];</span><span class="s2">\n    </span><span class="s1">if (!isFunction(value)) return;</span><span class="s2">\n    </span><span class="s1">descriptor.enumerable = false;</span><span class="s2">\n    </span><span class="s1">if ('writable' in descriptor) {</span><span class="s2">\n      </span><span class="s1">descriptor.writable = false;</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!descriptor.set) {</span><span class="s2">\n      </span><span class="s1">descriptor.set = () =&gt; {</span><span class="s2">\n        </span><span class="s1">throw Error('Can not rewrite read-only method </span><span class="s2">\\</span><span class="s1">'' + name + '</span><span class="s2">\\</span><span class="s1">'');</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const toObjectSet = (arrayOrString, delimiter) =&gt; {</span><span class="s2">\n  </span><span class="s1">const obj = {};</span><span class="s2">\n  </span><span class="s1">const define = arr =&gt; {</span><span class="s2">\n    </span><span class="s1">arr.forEach(value =&gt; {</span><span class="s2">\n      </span><span class="s1">obj[value] = true;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));</span><span class="s2">\n  </span><span class="s1">return obj;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const noop = () =&gt; {};</span><span class="s2">\n</span><span class="s1">const toFiniteNumber = (value, defaultValue) =&gt; {</span><span class="s2">\n  </span><span class="s1">value = +value;</span><span class="s2">\n  </span><span class="s1">return Number.isFinite(value) ? value : defaultValue;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const ALPHA = 'abcdefghijklmnopqrstuvwxyz';</span><span class="s2">\n</span><span class="s1">const DIGIT = '0123456789';</span><span class="s2">\n</span><span class="s1">const ALPHABET = {</span><span class="s2">\n  </span><span class="s1">DIGIT,</span><span class="s2">\n  </span><span class="s1">ALPHA,</span><span class="s2">\n  </span><span class="s1">ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) =&gt; {</span><span class="s2">\n  </span><span class="s1">let str = '';</span><span class="s2">\n  </span><span class="s1">const {</span><span class="s2">\n    </span><span class="s1">length</span><span class="s2">\n  </span><span class="s1">} = alphabet;</span><span class="s2">\n  </span><span class="s1">while (size--) {</span><span class="s2">\n    </span><span class="s1">str += alphabet[Math.random() * length | 0];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return str;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* If the thing is a FormData object, return true, otherwise return false.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {unknown} thing - The thing to check.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isSpecCompliantForm(thing) {</span><span class="s2">\n  </span><span class="s1">return !!(thing &amp;&amp; isFunction(thing.append) &amp;&amp; thing[Symbol.toStringTag] === 'FormData' &amp;&amp; thing[Symbol.iterator]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const toJSONObject = obj =&gt; {</span><span class="s2">\n  </span><span class="s1">const stack = new Array(10);</span><span class="s2">\n  </span><span class="s1">const visit = (source, i) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (isObject(source)) {</span><span class="s2">\n      </span><span class="s1">if (stack.indexOf(source) &gt;= 0) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (!('toJSON' in source)) {</span><span class="s2">\n        </span><span class="s1">stack[i] = source;</span><span class="s2">\n        </span><span class="s1">const target = isArray(source) ? [] : {};</span><span class="s2">\n        </span><span class="s1">forEach(source, (value, key) =&gt; {</span><span class="s2">\n          </span><span class="s1">const reducedValue = visit(value, i + 1);</span><span class="s2">\n          </span><span class="s1">!isUndefined(reducedValue) &amp;&amp; (target[key] = reducedValue);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">stack[i] = undefined;</span><span class="s2">\n        </span><span class="s1">return target;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return source;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return visit(obj, 0);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const isAsyncFn = kindOfTest('AsyncFunction');</span><span class="s2">\n</span><span class="s1">const isThenable = thing =&gt; thing &amp;&amp; (isObject(thing) || isFunction(thing)) &amp;&amp; isFunction(thing.then) &amp;&amp; isFunction(thing.catch);</span><span class="s2">\n</span><span class="s1">export default {</span><span class="s2">\n  </span><span class="s1">isArray,</span><span class="s2">\n  </span><span class="s1">isArrayBuffer,</span><span class="s2">\n  </span><span class="s1">isBuffer,</span><span class="s2">\n  </span><span class="s1">isFormData,</span><span class="s2">\n  </span><span class="s1">isArrayBufferView,</span><span class="s2">\n  </span><span class="s1">isString,</span><span class="s2">\n  </span><span class="s1">isNumber,</span><span class="s2">\n  </span><span class="s1">isBoolean,</span><span class="s2">\n  </span><span class="s1">isObject,</span><span class="s2">\n  </span><span class="s1">isPlainObject,</span><span class="s2">\n  </span><span class="s1">isUndefined,</span><span class="s2">\n  </span><span class="s1">isDate,</span><span class="s2">\n  </span><span class="s1">isFile,</span><span class="s2">\n  </span><span class="s1">isBlob,</span><span class="s2">\n  </span><span class="s1">isRegExp,</span><span class="s2">\n  </span><span class="s1">isFunction,</span><span class="s2">\n  </span><span class="s1">isStream,</span><span class="s2">\n  </span><span class="s1">isURLSearchParams,</span><span class="s2">\n  </span><span class="s1">isTypedArray,</span><span class="s2">\n  </span><span class="s1">isFileList,</span><span class="s2">\n  </span><span class="s1">forEach,</span><span class="s2">\n  </span><span class="s1">merge,</span><span class="s2">\n  </span><span class="s1">extend,</span><span class="s2">\n  </span><span class="s1">trim,</span><span class="s2">\n  </span><span class="s1">stripBOM,</span><span class="s2">\n  </span><span class="s1">inherits,</span><span class="s2">\n  </span><span class="s1">toFlatObject,</span><span class="s2">\n  </span><span class="s1">kindOf,</span><span class="s2">\n  </span><span class="s1">kindOfTest,</span><span class="s2">\n  </span><span class="s1">endsWith,</span><span class="s2">\n  </span><span class="s1">toArray,</span><span class="s2">\n  </span><span class="s1">forEachEntry,</span><span class="s2">\n  </span><span class="s1">matchAll,</span><span class="s2">\n  </span><span class="s1">isHTMLForm,</span><span class="s2">\n  </span><span class="s1">hasOwnProperty,</span><span class="s2">\n  </span><span class="s1">hasOwnProp: hasOwnProperty,</span><span class="s2">\n  </span><span class="s1">// an alias to avoid ESLint no-prototype-builtins detection</span><span class="s2">\n  </span><span class="s1">reduceDescriptors,</span><span class="s2">\n  </span><span class="s1">freezeMethods,</span><span class="s2">\n  </span><span class="s1">toObjectSet,</span><span class="s2">\n  </span><span class="s1">toCamelCase,</span><span class="s2">\n  </span><span class="s1">noop,</span><span class="s2">\n  </span><span class="s1">toFiniteNumber,</span><span class="s2">\n  </span><span class="s1">findKey,</span><span class="s2">\n  </span><span class="s1">global: _global,</span><span class="s2">\n  </span><span class="s1">isContextDefined,</span><span class="s2">\n  </span><span class="s1">ALPHABET,</span><span class="s2">\n  </span><span class="s1">generateString,</span><span class="s2">\n  </span><span class="s1">isSpecCompliantForm,</span><span class="s2">\n  </span><span class="s1">toJSONObject,</span><span class="s2">\n  </span><span class="s1">isAsyncFn,</span><span class="s2">\n  </span><span class="s1">isThenable</span><span class="s2">\n</span><span class="s1">};&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">:{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s3">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrototypeOf&quot;</span><span class="s0">,</span><span class="s1">&quot;kindOf&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;thing&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;create&quot;</span><span class="s0">,</span><span class="s1">&quot;kindOfTest&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;typeOfTest&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isUndefined&quot;</span><span class="s0">,</span><span class="s1">&quot;isBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrayBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrayBufferView&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;ArrayBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;isView&quot;</span><span class="s0">,</span><span class="s1">&quot;buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;isString&quot;</span><span class="s0">,</span><span class="s1">&quot;isNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;isObject&quot;</span><span class="s0">,</span><span class="s1">&quot;isBoolean&quot;</span><span class="s0">,</span><span class="s1">&quot;isPlainObject&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;toStringTag&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;isDate&quot;</span><span class="s0">,</span><span class="s1">&quot;isFile&quot;</span><span class="s0">,</span><span class="s1">&quot;isBlob&quot;</span><span class="s0">,</span><span class="s1">&quot;isFileList&quot;</span><span class="s0">,</span><span class="s1">&quot;isStream&quot;</span><span class="s0">,</span><span class="s1">&quot;pipe&quot;</span><span class="s0">,</span><span class="s1">&quot;isFormData&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;FormData&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;isURLSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;trim&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;allOwnKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;l&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;getOwnPropertyNames&quot;</span><span class="s0">,</span><span class="s1">&quot;len&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;findKey&quot;</span><span class="s0">,</span><span class="s1">&quot;_key&quot;</span><span class="s0">,</span><span class="s1">&quot;_global&quot;</span><span class="s0">,</span><span class="s1">&quot;globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;self&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;global&quot;</span><span class="s0">,</span><span class="s1">&quot;isContextDefined&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;merge&quot;</span><span class="s0">,</span><span class="s1">&quot;caseless&quot;</span><span class="s0">,</span><span class="s1">&quot;assignValue&quot;</span><span class="s0">,</span><span class="s1">&quot;targetKey&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;extend&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;thisArg&quot;</span><span class="s0">,</span><span class="s1">&quot;stripBOM&quot;</span><span class="s0">,</span><span class="s1">&quot;content&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;inherits&quot;</span><span class="s0">,</span><span class="s1">&quot;superConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;descriptors&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;toFlatObject&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceObj&quot;</span><span class="s0">,</span><span class="s1">&quot;destObj&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;propFilter&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;merged&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;searchString&quot;</span><span class="s0">,</span><span class="s1">&quot;position&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;lastIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;toArray&quot;</span><span class="s0">,</span><span class="s1">&quot;arr&quot;</span><span class="s0">,</span><span class="s1">&quot;isTypedArray&quot;</span><span class="s0">,</span><span class="s1">&quot;TypedArray&quot;</span><span class="s0">,</span><span class="s1">&quot;Uint8Array&quot;</span><span class="s0">,</span><span class="s1">&quot;forEachEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;generator&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;pair&quot;</span><span class="s0">,</span><span class="s1">&quot;matchAll&quot;</span><span class="s0">,</span><span class="s1">&quot;regExp&quot;</span><span class="s0">,</span><span class="s1">&quot;matches&quot;</span><span class="s0">,</span><span class="s1">&quot;exec&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;isHTMLForm&quot;</span><span class="s0">,</span><span class="s1">&quot;toCamelCase&quot;</span><span class="s0">,</span><span class="s1">&quot;replacer&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;p1&quot;</span><span class="s0">,</span><span class="s1">&quot;p2&quot;</span><span class="s0">,</span><span class="s1">&quot;toUpperCase&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;reduceDescriptors&quot;</span><span class="s0">,</span><span class="s1">&quot;reducer&quot;</span><span class="s0">,</span><span class="s1">&quot;getOwnPropertyDescriptors&quot;</span><span class="s0">,</span><span class="s1">&quot;reducedDescriptors&quot;</span><span class="s0">,</span><span class="s1">&quot;descriptor&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;ret&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;freezeMethods&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;writable&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;toObjectSet&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayOrString&quot;</span><span class="s0">,</span><span class="s1">&quot;delimiter&quot;</span><span class="s0">,</span><span class="s1">&quot;define&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;noop&quot;</span><span class="s0">,</span><span class="s1">&quot;toFiniteNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultValue&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;isFinite&quot;</span><span class="s0">,</span><span class="s1">&quot;ALPHA&quot;</span><span class="s0">,</span><span class="s1">&quot;DIGIT&quot;</span><span class="s0">,</span><span class="s1">&quot;ALPHABET&quot;</span><span class="s0">,</span><span class="s1">&quot;ALPHA_DIGIT&quot;</span><span class="s0">,</span><span class="s1">&quot;generateString&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;alphabet&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;random&quot;</span><span class="s0">,</span><span class="s1">&quot;isSpecCompliantForm&quot;</span><span class="s0">,</span><span class="s1">&quot;toJSONObject&quot;</span><span class="s0">,</span><span class="s1">&quot;stack&quot;</span><span class="s0">,</span><span class="s1">&quot;visit&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;reducedValue&quot;</span><span class="s0">,</span><span class="s1">&quot;isAsyncFn&quot;</span><span class="s0">,</span><span class="s1">&quot;isThenable&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProp&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;E:/work/project/manager/vue/node_modules/axios/lib/utils.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;'use strict';</span><span class="s2">\n\n</span><span class="s1">import bind from './helpers/bind.js';</span><span class="s2">\n\n</span><span class="s1">// utils is a library of generic helper functions non-specific to axios</span><span class="s2">\n\n</span><span class="s1">const {toString} = Object.prototype;</span><span class="s2">\n</span><span class="s1">const {getPrototypeOf} = Object;</span><span class="s2">\n\n</span><span class="s1">const kindOf = (cache =&gt; thing =&gt; {</span><span class="s2">\n    </span><span class="s1">const str = toString.call(thing);</span><span class="s2">\n    </span><span class="s1">return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());</span><span class="s2">\n</span><span class="s1">})(Object.create(null));</span><span class="s2">\n\n</span><span class="s1">const kindOfTest = (type) =&gt; {</span><span class="s2">\n  </span><span class="s1">type = type.toLowerCase();</span><span class="s2">\n  </span><span class="s1">return (thing) =&gt; kindOf(thing) === type</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const typeOfTest = type =&gt; thing =&gt; typeof thing === type;</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is an Array</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {Object} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is an Array, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const {isArray} = Array;</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is undefined</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if the value is undefined, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isUndefined = typeOfTest('undefined');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a Buffer</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a Buffer, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isBuffer(val) {</span><span class="s2">\n  </span><span class="s1">return val !== null &amp;&amp; !isUndefined(val) &amp;&amp; val.constructor !== null &amp;&amp; !isUndefined(val.constructor)</span><span class="s2">\n    </span><span class="s1">&amp;&amp; isFunction(val.constructor.isBuffer) &amp;&amp; val.constructor.isBuffer(val);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is an ArrayBuffer</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is an ArrayBuffer, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isArrayBuffer = kindOfTest('ArrayBuffer');</span><span class="s2">\n\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a view on an ArrayBuffer</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isArrayBufferView(val) {</span><span class="s2">\n  </span><span class="s1">let result;</span><span class="s2">\n  </span><span class="s1">if ((typeof ArrayBuffer !== 'undefined') &amp;&amp; (ArrayBuffer.isView)) {</span><span class="s2">\n    </span><span class="s1">result = ArrayBuffer.isView(val);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">result = (val) &amp;&amp; (val.buffer) &amp;&amp; (isArrayBuffer(val.buffer));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a String</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a String, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isString = typeOfTest('string');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a Function</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a Function, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isFunction = typeOfTest('function');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a Number</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a Number, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isNumber = typeOfTest('number');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is an Object</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} thing The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is an Object, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isObject = (thing) =&gt; thing !== null &amp;&amp; typeof thing === 'object';</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a Boolean</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} thing The value to test</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a Boolean, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isBoolean = thing =&gt; thing === true || thing === false;</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a plain Object</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a plain Object, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isPlainObject = (val) =&gt; {</span><span class="s2">\n  </span><span class="s1">if (kindOf(val) !== 'object') {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">const prototype = getPrototypeOf(val);</span><span class="s2">\n  </span><span class="s1">return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) &amp;&amp; !(Symbol.toStringTag in val) &amp;&amp; !(Symbol.iterator in val);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a Date</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a Date, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isDate = kindOfTest('Date');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a File</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a File, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isFile = kindOfTest('File');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a Blob</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a Blob, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isBlob = kindOfTest('Blob');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a FileList</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a File, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isFileList = kindOfTest('FileList');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a Stream</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a Stream, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isStream = (val) =&gt; isObject(val) &amp;&amp; isFunction(val.pipe);</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a FormData</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} thing The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is an FormData, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isFormData = (thing) =&gt; {</span><span class="s2">\n  </span><span class="s1">let kind;</span><span class="s2">\n  </span><span class="s1">return thing &amp;&amp; (</span><span class="s2">\n    </span><span class="s1">(typeof FormData === 'function' &amp;&amp; thing instanceof FormData) || (</span><span class="s2">\n      </span><span class="s1">isFunction(thing.append) &amp;&amp; (</span><span class="s2">\n        </span><span class="s1">(kind = kindOf(thing)) === 'formdata' ||</span><span class="s2">\n        </span><span class="s1">// detect form-data instance</span><span class="s2">\n        </span><span class="s1">(kind === 'object' &amp;&amp; isFunction(thing.toString) &amp;&amp; thing.toString() === '[object FormData]')</span><span class="s2">\n      </span><span class="s1">)</span><span class="s2">\n    </span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a URLSearchParams object</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a URLSearchParams object, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isURLSearchParams = kindOfTest('URLSearchParams');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Trim excess whitespace off the beginning and end of a string</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {String} str The String to trim</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {String} The String freed of excess whitespace</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const trim = (str) =&gt; str.trim ?</span><span class="s2">\n  </span><span class="s1">str.trim() : str.replace(/^[</span><span class="s2">\\</span><span class="s1">s</span><span class="s2">\\</span><span class="s1">uFEFF</span><span class="s2">\\</span><span class="s1">xA0]+|[</span><span class="s2">\\</span><span class="s1">s</span><span class="s2">\\</span><span class="s1">uFEFF</span><span class="s2">\\</span><span class="s1">xA0]+$/g, '');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Iterate over an Array or an Object invoking a function for each item.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* If `obj` is an Array callback will be called passing</span><span class="s2">\n </span><span class="s1">* the value, index, and complete array for each item.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* If 'obj' is an Object callback will be called passing</span><span class="s2">\n </span><span class="s1">* the value, key, and complete object for each property.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {Object|Array} obj The object to iterate</span><span class="s2">\n </span><span class="s1">* @param {Function} fn The callback to invoke for each item</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {Boolean} [allOwnKeys = false]</span><span class="s2">\n </span><span class="s1">* @returns {any}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function forEach(obj, fn, {allOwnKeys = false} = {}) {</span><span class="s2">\n  </span><span class="s1">// Don't bother if no value provided</span><span class="s2">\n  </span><span class="s1">if (obj === null || typeof obj === 'undefined') {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">let i;</span><span class="s2">\n  </span><span class="s1">let l;</span><span class="s2">\n\n  </span><span class="s1">// Force an array if not already something iterable</span><span class="s2">\n  </span><span class="s1">if (typeof obj !== 'object') {</span><span class="s2">\n    </span><span class="s1">/*eslint no-param-reassign:0*/</span><span class="s2">\n    </span><span class="s1">obj = [obj];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (isArray(obj)) {</span><span class="s2">\n    </span><span class="s1">// Iterate over array values</span><span class="s2">\n    </span><span class="s1">for (i = 0, l = obj.length; i &lt; l; i++) {</span><span class="s2">\n      </span><span class="s1">fn.call(null, obj[i], i, obj);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">// Iterate over object keys</span><span class="s2">\n    </span><span class="s1">const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);</span><span class="s2">\n    </span><span class="s1">const len = keys.length;</span><span class="s2">\n    </span><span class="s1">let key;</span><span class="s2">\n\n    </span><span class="s1">for (i = 0; i &lt; len; i++) {</span><span class="s2">\n      </span><span class="s1">key = keys[i];</span><span class="s2">\n      </span><span class="s1">fn.call(null, obj[key], key, obj);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function findKey(obj, key) {</span><span class="s2">\n  </span><span class="s1">key = key.toLowerCase();</span><span class="s2">\n  </span><span class="s1">const keys = Object.keys(obj);</span><span class="s2">\n  </span><span class="s1">let i = keys.length;</span><span class="s2">\n  </span><span class="s1">let _key;</span><span class="s2">\n  </span><span class="s1">while (i-- &gt; 0) {</span><span class="s2">\n    </span><span class="s1">_key = keys[i];</span><span class="s2">\n    </span><span class="s1">if (key === _key.toLowerCase()) {</span><span class="s2">\n      </span><span class="s1">return _key;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const _global = (() =&gt; {</span><span class="s2">\n  </span><span class="s1">/*eslint no-undef:0*/</span><span class="s2">\n  </span><span class="s1">if (typeof globalThis !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) return globalThis;</span><span class="s2">\n  </span><span class="s1">return typeof self !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">? self : (typeof window !== 'undefined' ? window : global)</span><span class="s2">\n</span><span class="s1">})();</span><span class="s2">\n\n</span><span class="s1">const isContextDefined = (context) =&gt; !isUndefined(context) &amp;&amp; context !== _global;</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Accepts varargs expecting each argument to be an object, then</span><span class="s2">\n </span><span class="s1">* immutably merges the properties of each object and returns result.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* When multiple objects contain the same key the later object in</span><span class="s2">\n </span><span class="s1">* the arguments list will take precedence.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Example:</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* ```js</span><span class="s2">\n </span><span class="s1">* var result = merge({foo: 123}, {foo: 456});</span><span class="s2">\n </span><span class="s1">* console.log(result.foo); // outputs 456</span><span class="s2">\n </span><span class="s1">* ```</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {Object} obj1 Object to merge</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {Object} Result of all merge properties</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function merge(/* obj1, obj2, obj3, ... */) {</span><span class="s2">\n  </span><span class="s1">const {caseless} = isContextDefined(this) &amp;&amp; this || {};</span><span class="s2">\n  </span><span class="s1">const result = {};</span><span class="s2">\n  </span><span class="s1">const assignValue = (val, key) =&gt; {</span><span class="s2">\n    </span><span class="s1">const targetKey = caseless &amp;&amp; findKey(result, key) || key;</span><span class="s2">\n    </span><span class="s1">if (isPlainObject(result[targetKey]) &amp;&amp; isPlainObject(val)) {</span><span class="s2">\n      </span><span class="s1">result[targetKey] = merge(result[targetKey], val);</span><span class="s2">\n    </span><span class="s1">} else if (isPlainObject(val)) {</span><span class="s2">\n      </span><span class="s1">result[targetKey] = merge({}, val);</span><span class="s2">\n    </span><span class="s1">} else if (isArray(val)) {</span><span class="s2">\n      </span><span class="s1">result[targetKey] = val.slice();</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">result[targetKey] = val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">for (let i = 0, l = arguments.length; i &lt; l; i++) {</span><span class="s2">\n    </span><span class="s1">arguments[i] &amp;&amp; forEach(arguments[i], assignValue);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Extends object a by mutably adding to it the properties of object b.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {Object} a The object to be extended</span><span class="s2">\n </span><span class="s1">* @param {Object} b The object to copy properties from</span><span class="s2">\n </span><span class="s1">* @param {Object} thisArg The object to bind function to</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {Boolean} [allOwnKeys]</span><span class="s2">\n </span><span class="s1">* @returns {Object} The resulting value of object a</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const extend = (a, b, thisArg, {allOwnKeys}= {}) =&gt; {</span><span class="s2">\n  </span><span class="s1">forEach(b, (val, key) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (thisArg &amp;&amp; isFunction(val)) {</span><span class="s2">\n      </span><span class="s1">a[key] = bind(val, thisArg);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">a[key] = val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, {allOwnKeys});</span><span class="s2">\n  </span><span class="s1">return a;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {string} content with BOM</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {string} content value without BOM</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const stripBOM = (content) =&gt; {</span><span class="s2">\n  </span><span class="s1">if (content.charCodeAt(0) === 0xFEFF) {</span><span class="s2">\n    </span><span class="s1">content = content.slice(1);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return content;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Inherit the prototype methods from one constructor into another</span><span class="s2">\n </span><span class="s1">* @param {function} constructor</span><span class="s2">\n </span><span class="s1">* @param {function} superConstructor</span><span class="s2">\n </span><span class="s1">* @param {object} [props]</span><span class="s2">\n </span><span class="s1">* @param {object} [descriptors]</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {void}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const inherits = (constructor, superConstructor, props, descriptors) =&gt; {</span><span class="s2">\n  </span><span class="s1">constructor.prototype = Object.create(superConstructor.prototype, descriptors);</span><span class="s2">\n  </span><span class="s1">constructor.prototype.constructor = constructor;</span><span class="s2">\n  </span><span class="s1">Object.defineProperty(constructor, 'super', {</span><span class="s2">\n    </span><span class="s1">value: superConstructor.prototype</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">props &amp;&amp; Object.assign(constructor.prototype, props);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Resolve object with deep prototype chain to a flat object</span><span class="s2">\n </span><span class="s1">* @param {Object} sourceObj source object</span><span class="s2">\n </span><span class="s1">* @param {Object} [destObj]</span><span class="s2">\n </span><span class="s1">* @param {Function|Boolean} [filter]</span><span class="s2">\n </span><span class="s1">* @param {Function} [propFilter]</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {Object}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const toFlatObject = (sourceObj, destObj, filter, propFilter) =&gt; {</span><span class="s2">\n  </span><span class="s1">let props;</span><span class="s2">\n  </span><span class="s1">let i;</span><span class="s2">\n  </span><span class="s1">let prop;</span><span class="s2">\n  </span><span class="s1">const merged = {};</span><span class="s2">\n\n  </span><span class="s1">destObj = destObj || {};</span><span class="s2">\n  </span><span class="s1">// eslint-disable-next-line no-eq-null,eqeqeq</span><span class="s2">\n  </span><span class="s1">if (sourceObj == null) return destObj;</span><span class="s2">\n\n  </span><span class="s1">do {</span><span class="s2">\n    </span><span class="s1">props = Object.getOwnPropertyNames(sourceObj);</span><span class="s2">\n    </span><span class="s1">i = props.length;</span><span class="s2">\n    </span><span class="s1">while (i-- &gt; 0) {</span><span class="s2">\n      </span><span class="s1">prop = props[i];</span><span class="s2">\n      </span><span class="s1">if ((!propFilter || propFilter(prop, sourceObj, destObj)) &amp;&amp; !merged[prop]) {</span><span class="s2">\n        </span><span class="s1">destObj[prop] = sourceObj[prop];</span><span class="s2">\n        </span><span class="s1">merged[prop] = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">sourceObj = filter !== false &amp;&amp; getPrototypeOf(sourceObj);</span><span class="s2">\n  </span><span class="s1">} while (sourceObj &amp;&amp; (!filter || filter(sourceObj, destObj)) &amp;&amp; sourceObj !== Object.prototype);</span><span class="s2">\n\n  </span><span class="s1">return destObj;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determines whether a string ends with the characters of a specified string</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {String} str</span><span class="s2">\n </span><span class="s1">* @param {String} searchString</span><span class="s2">\n </span><span class="s1">* @param {Number} [position= 0]</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const endsWith = (str, searchString, position) =&gt; {</span><span class="s2">\n  </span><span class="s1">str = String(str);</span><span class="s2">\n  </span><span class="s1">if (position === undefined || position &gt; str.length) {</span><span class="s2">\n    </span><span class="s1">position = str.length;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">position -= searchString.length;</span><span class="s2">\n  </span><span class="s1">const lastIndex = str.indexOf(searchString, position);</span><span class="s2">\n  </span><span class="s1">return lastIndex !== -1 &amp;&amp; lastIndex === position;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Returns new array from array like object or null if failed</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} [thing]</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {?Array}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const toArray = (thing) =&gt; {</span><span class="s2">\n  </span><span class="s1">if (!thing) return null;</span><span class="s2">\n  </span><span class="s1">if (isArray(thing)) return thing;</span><span class="s2">\n  </span><span class="s1">let i = thing.length;</span><span class="s2">\n  </span><span class="s1">if (!isNumber(i)) return null;</span><span class="s2">\n  </span><span class="s1">const arr = new Array(i);</span><span class="s2">\n  </span><span class="s1">while (i-- &gt; 0) {</span><span class="s2">\n    </span><span class="s1">arr[i] = thing[i];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return arr;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Checking if the Uint8Array exists and if it does, it returns a function that checks if the</span><span class="s2">\n </span><span class="s1">* thing passed in is an instance of Uint8Array</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {TypedArray}</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {Array}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">// eslint-disable-next-line func-names</span><span class="s2">\n</span><span class="s1">const isTypedArray = (TypedArray =&gt; {</span><span class="s2">\n  </span><span class="s1">// eslint-disable-next-line func-names</span><span class="s2">\n  </span><span class="s1">return thing =&gt; {</span><span class="s2">\n    </span><span class="s1">return TypedArray &amp;&amp; thing instanceof TypedArray;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">})(typeof Uint8Array !== 'undefined' &amp;&amp; getPrototypeOf(Uint8Array));</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* For each entry in the object, call the function with the key and value.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {Object&lt;any, any&gt;} obj - The object to iterate over.</span><span class="s2">\n </span><span class="s1">* @param {Function} fn - The function to call for each entry.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {void}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const forEachEntry = (obj, fn) =&gt; {</span><span class="s2">\n  </span><span class="s1">const generator = obj &amp;&amp; obj[Symbol.iterator];</span><span class="s2">\n\n  </span><span class="s1">const iterator = generator.call(obj);</span><span class="s2">\n\n  </span><span class="s1">let result;</span><span class="s2">\n\n  </span><span class="s1">while ((result = iterator.next()) &amp;&amp; !result.done) {</span><span class="s2">\n    </span><span class="s1">const pair = result.value;</span><span class="s2">\n    </span><span class="s1">fn.call(obj, pair[0], pair[1]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* It takes a regular expression and a string, and returns an array of all the matches</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {string} regExp - The regular expression to match against.</span><span class="s2">\n </span><span class="s1">* @param {string} str - The string to search.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {Array&lt;boolean&gt;}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const matchAll = (regExp, str) =&gt; {</span><span class="s2">\n  </span><span class="s1">let matches;</span><span class="s2">\n  </span><span class="s1">const arr = [];</span><span class="s2">\n\n  </span><span class="s1">while ((matches = regExp.exec(str)) !== null) {</span><span class="s2">\n    </span><span class="s1">arr.push(matches);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return arr;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */</span><span class="s2">\n</span><span class="s1">const isHTMLForm = kindOfTest('HTMLFormElement');</span><span class="s2">\n\n</span><span class="s1">const toCamelCase = str =&gt; {</span><span class="s2">\n  </span><span class="s1">return str.toLowerCase().replace(/[-_</span><span class="s2">\\</span><span class="s1">s]([a-z</span><span class="s2">\\</span><span class="s1">d])(</span><span class="s2">\\</span><span class="s1">w*)/g,</span><span class="s2">\n    </span><span class="s1">function replacer(m, p1, p2) {</span><span class="s2">\n      </span><span class="s1">return p1.toUpperCase() + p2;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/* Creating a function that will check if an object has a property. */</span><span class="s2">\n</span><span class="s1">const hasOwnProperty = (({hasOwnProperty}) =&gt; (obj, prop) =&gt; hasOwnProperty.call(obj, prop))(Object.prototype);</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if a value is a RegExp object</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {*} val The value to test</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean} True if value is a RegExp object, otherwise false</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isRegExp = kindOfTest('RegExp');</span><span class="s2">\n\n</span><span class="s1">const reduceDescriptors = (obj, reducer) =&gt; {</span><span class="s2">\n  </span><span class="s1">const descriptors = Object.getOwnPropertyDescriptors(obj);</span><span class="s2">\n  </span><span class="s1">const reducedDescriptors = {};</span><span class="s2">\n\n  </span><span class="s1">forEach(descriptors, (descriptor, name) =&gt; {</span><span class="s2">\n    </span><span class="s1">let ret;</span><span class="s2">\n    </span><span class="s1">if ((ret = reducer(descriptor, name, obj)) !== false) {</span><span class="s2">\n      </span><span class="s1">reducedDescriptors[name] = ret || descriptor;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n\n  </span><span class="s1">Object.defineProperties(obj, reducedDescriptors);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Makes all methods read-only</span><span class="s2">\n </span><span class="s1">* @param {Object} obj</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n\n</span><span class="s1">const freezeMethods = (obj) =&gt; {</span><span class="s2">\n  </span><span class="s1">reduceDescriptors(obj, (descriptor, name) =&gt; {</span><span class="s2">\n    </span><span class="s1">// skip restricted props in strict mode</span><span class="s2">\n    </span><span class="s1">if (isFunction(obj) &amp;&amp; ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const value = obj[name];</span><span class="s2">\n\n    </span><span class="s1">if (!isFunction(value)) return;</span><span class="s2">\n\n    </span><span class="s1">descriptor.enumerable = false;</span><span class="s2">\n\n    </span><span class="s1">if ('writable' in descriptor) {</span><span class="s2">\n      </span><span class="s1">descriptor.writable = false;</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (!descriptor.set) {</span><span class="s2">\n      </span><span class="s1">descriptor.set = () =&gt; {</span><span class="s2">\n        </span><span class="s1">throw Error('Can not rewrite read-only method </span><span class="s2">\\</span><span class="s1">'' + name + '</span><span class="s2">\\</span><span class="s1">'');</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const toObjectSet = (arrayOrString, delimiter) =&gt; {</span><span class="s2">\n  </span><span class="s1">const obj = {};</span><span class="s2">\n\n  </span><span class="s1">const define = (arr) =&gt; {</span><span class="s2">\n    </span><span class="s1">arr.forEach(value =&gt; {</span><span class="s2">\n      </span><span class="s1">obj[value] = true;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));</span><span class="s2">\n\n  </span><span class="s1">return obj;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const noop = () =&gt; {}</span><span class="s2">\n\n</span><span class="s1">const toFiniteNumber = (value, defaultValue) =&gt; {</span><span class="s2">\n  </span><span class="s1">value = +value;</span><span class="s2">\n  </span><span class="s1">return Number.isFinite(value) ? value : defaultValue;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const ALPHA = 'abcdefghijklmnopqrstuvwxyz'</span><span class="s2">\n\n</span><span class="s1">const DIGIT = '0123456789';</span><span class="s2">\n\n</span><span class="s1">const ALPHABET = {</span><span class="s2">\n  </span><span class="s1">DIGIT,</span><span class="s2">\n  </span><span class="s1">ALPHA,</span><span class="s2">\n  </span><span class="s1">ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) =&gt; {</span><span class="s2">\n  </span><span class="s1">let str = '';</span><span class="s2">\n  </span><span class="s1">const {length} = alphabet;</span><span class="s2">\n  </span><span class="s1">while (size--) {</span><span class="s2">\n    </span><span class="s1">str += alphabet[Math.random() * length|0]</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return str;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* If the thing is a FormData object, return true, otherwise return false.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param {unknown} thing - The thing to check.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @returns {boolean}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isSpecCompliantForm(thing) {</span><span class="s2">\n  </span><span class="s1">return !!(thing &amp;&amp; isFunction(thing.append) &amp;&amp; thing[Symbol.toStringTag] === 'FormData' &amp;&amp; thing[Symbol.iterator]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const toJSONObject = (obj) =&gt; {</span><span class="s2">\n  </span><span class="s1">const stack = new Array(10);</span><span class="s2">\n\n  </span><span class="s1">const visit = (source, i) =&gt; {</span><span class="s2">\n\n    </span><span class="s1">if (isObject(source)) {</span><span class="s2">\n      </span><span class="s1">if (stack.indexOf(source) &gt;= 0) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if(!('toJSON' in source)) {</span><span class="s2">\n        </span><span class="s1">stack[i] = source;</span><span class="s2">\n        </span><span class="s1">const target = isArray(source) ? [] : {};</span><span class="s2">\n\n        </span><span class="s1">forEach(source, (value, key) =&gt; {</span><span class="s2">\n          </span><span class="s1">const reducedValue = visit(value, i + 1);</span><span class="s2">\n          </span><span class="s1">!isUndefined(reducedValue) &amp;&amp; (target[key] = reducedValue);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n\n        </span><span class="s1">stack[i] = undefined;</span><span class="s2">\n\n        </span><span class="s1">return target;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return source;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return visit(obj, 0);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const isAsyncFn = kindOfTest('AsyncFunction');</span><span class="s2">\n\n</span><span class="s1">const isThenable = (thing) =&gt;</span><span class="s2">\n  </span><span class="s1">thing &amp;&amp; (isObject(thing) || isFunction(thing)) &amp;&amp; isFunction(thing.then) &amp;&amp; isFunction(thing.catch);</span><span class="s2">\n\n</span><span class="s1">export default {</span><span class="s2">\n  </span><span class="s1">isArray,</span><span class="s2">\n  </span><span class="s1">isArrayBuffer,</span><span class="s2">\n  </span><span class="s1">isBuffer,</span><span class="s2">\n  </span><span class="s1">isFormData,</span><span class="s2">\n  </span><span class="s1">isArrayBufferView,</span><span class="s2">\n  </span><span class="s1">isString,</span><span class="s2">\n  </span><span class="s1">isNumber,</span><span class="s2">\n  </span><span class="s1">isBoolean,</span><span class="s2">\n  </span><span class="s1">isObject,</span><span class="s2">\n  </span><span class="s1">isPlainObject,</span><span class="s2">\n  </span><span class="s1">isUndefined,</span><span class="s2">\n  </span><span class="s1">isDate,</span><span class="s2">\n  </span><span class="s1">isFile,</span><span class="s2">\n  </span><span class="s1">isBlob,</span><span class="s2">\n  </span><span class="s1">isRegExp,</span><span class="s2">\n  </span><span class="s1">isFunction,</span><span class="s2">\n  </span><span class="s1">isStream,</span><span class="s2">\n  </span><span class="s1">isURLSearchParams,</span><span class="s2">\n  </span><span class="s1">isTypedArray,</span><span class="s2">\n  </span><span class="s1">isFileList,</span><span class="s2">\n  </span><span class="s1">forEach,</span><span class="s2">\n  </span><span class="s1">merge,</span><span class="s2">\n  </span><span class="s1">extend,</span><span class="s2">\n  </span><span class="s1">trim,</span><span class="s2">\n  </span><span class="s1">stripBOM,</span><span class="s2">\n  </span><span class="s1">inherits,</span><span class="s2">\n  </span><span class="s1">toFlatObject,</span><span class="s2">\n  </span><span class="s1">kindOf,</span><span class="s2">\n  </span><span class="s1">kindOfTest,</span><span class="s2">\n  </span><span class="s1">endsWith,</span><span class="s2">\n  </span><span class="s1">toArray,</span><span class="s2">\n  </span><span class="s1">forEachEntry,</span><span class="s2">\n  </span><span class="s1">matchAll,</span><span class="s2">\n  </span><span class="s1">isHTMLForm,</span><span class="s2">\n  </span><span class="s1">hasOwnProperty,</span><span class="s2">\n  </span><span class="s1">hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection</span><span class="s2">\n  </span><span class="s1">reduceDescriptors,</span><span class="s2">\n  </span><span class="s1">freezeMethods,</span><span class="s2">\n  </span><span class="s1">toObjectSet,</span><span class="s2">\n  </span><span class="s1">toCamelCase,</span><span class="s2">\n  </span><span class="s1">noop,</span><span class="s2">\n  </span><span class="s1">toFiniteNumber,</span><span class="s2">\n  </span><span class="s1">findKey,</span><span class="s2">\n  </span><span class="s1">global: _global,</span><span class="s2">\n  </span><span class="s1">isContextDefined,</span><span class="s2">\n  </span><span class="s1">ALPHABET,</span><span class="s2">\n  </span><span class="s1">generateString,</span><span class="s2">\n  </span><span class="s1">isSpecCompliantForm,</span><span class="s2">\n  </span><span class="s1">toJSONObject,</span><span class="s2">\n  </span><span class="s1">isAsyncFn,</span><span class="s2">\n  </span><span class="s1">isThenable</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">},</span><span class="s1">&quot;metadata&quot;</span><span class="s0">:{},</span><span class="s1">&quot;sourceType&quot;</span><span class="s0">:</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;externalDependencies&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>