<html>
<head>
<title>trace-mapping.mjs.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
trace-mapping.mjs.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;trace-mapping.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/resolve.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/strip-filename.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/sourcemap-segment.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/sort.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/binary-search.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/by-source.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/any-map.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/trace-mapping.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import resolveUri from '@jridgewell/resolve-uri';</span><span class="s3">\n\n</span><span class="s1">export default function resolve(input: string, base: string | undefined): string {</span><span class="s3">\n  </span><span class="s1">// The base is always treated as a directory, if it's not empty.</span><span class="s3">\n  </span><span class="s1">// https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327</span><span class="s3">\n  </span><span class="s1">// https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401</span><span class="s3">\n  </span><span class="s1">if (base &amp;&amp; !base.endsWith('/')) base += '/';</span><span class="s3">\n\n  </span><span class="s1">return resolveUri(input, base);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Removes everything after the last </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">, but leaves the slash.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function stripFilename(path: string | undefined | null): string {</span><span class="s3">\n  </span><span class="s1">if (!path) return '';</span><span class="s3">\n  </span><span class="s1">const index = path.lastIndexOf('/');</span><span class="s3">\n  </span><span class="s1">return path.slice(0, index + 1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;type GeneratedColumn = number;</span><span class="s3">\n</span><span class="s1">type SourcesIndex = number;</span><span class="s3">\n</span><span class="s1">type SourceLine = number;</span><span class="s3">\n</span><span class="s1">type SourceColumn = number;</span><span class="s3">\n</span><span class="s1">type NamesIndex = number;</span><span class="s3">\n\n</span><span class="s1">type GeneratedLine = number;</span><span class="s3">\n\n</span><span class="s1">export type SourceMapSegment =</span><span class="s3">\n  </span><span class="s1">| [GeneratedColumn]</span><span class="s3">\n  </span><span class="s1">| [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]</span><span class="s3">\n  </span><span class="s1">| [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];</span><span class="s3">\n\n</span><span class="s1">export type ReverseSegment = [SourceColumn, GeneratedLine, GeneratedColumn];</span><span class="s3">\n\n</span><span class="s1">export const COLUMN = 0;</span><span class="s3">\n</span><span class="s1">export const SOURCES_INDEX = 1;</span><span class="s3">\n</span><span class="s1">export const SOURCE_LINE = 2;</span><span class="s3">\n</span><span class="s1">export const SOURCE_COLUMN = 3;</span><span class="s3">\n</span><span class="s1">export const NAMES_INDEX = 4;</span><span class="s3">\n\n</span><span class="s1">export const REV_GENERATED_LINE = 1;</span><span class="s3">\n</span><span class="s1">export const REV_GENERATED_COLUMN = 2;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { COLUMN } from './sourcemap-segment';</span><span class="s3">\n\n</span><span class="s1">import type { SourceMapSegment } from './sourcemap-segment';</span><span class="s3">\n\n</span><span class="s1">export default function maybeSort(</span><span class="s3">\n  </span><span class="s1">mappings: SourceMapSegment[][],</span><span class="s3">\n  </span><span class="s1">owned: boolean,</span><span class="s3">\n</span><span class="s1">): SourceMapSegment[][] {</span><span class="s3">\n  </span><span class="s1">const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);</span><span class="s3">\n  </span><span class="s1">if (unsortedIndex === mappings.length) return mappings;</span><span class="s3">\n\n  </span><span class="s1">// If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If</span><span class="s3">\n  </span><span class="s1">// not, we do not want to modify the consumer's input array.</span><span class="s3">\n  </span><span class="s1">if (!owned) mappings = mappings.slice();</span><span class="s3">\n\n  </span><span class="s1">for (let i = unsortedIndex; i &lt; mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {</span><span class="s3">\n    </span><span class="s1">mappings[i] = sortSegments(mappings[i], owned);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return mappings;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function nextUnsortedSegmentLine(mappings: SourceMapSegment[][], start: number): number {</span><span class="s3">\n  </span><span class="s1">for (let i = start; i &lt; mappings.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (!isSorted(mappings[i])) return i;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return mappings.length;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isSorted(line: SourceMapSegment[]): boolean {</span><span class="s3">\n  </span><span class="s1">for (let j = 1; j &lt; line.length; j++) {</span><span class="s3">\n    </span><span class="s1">if (line[j][COLUMN] &lt; line[j - 1][COLUMN]) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function sortSegments(line: SourceMapSegment[], owned: boolean): SourceMapSegment[] {</span><span class="s3">\n  </span><span class="s1">if (!owned) line = line.slice();</span><span class="s3">\n  </span><span class="s1">return line.sort(sortComparator);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {</span><span class="s3">\n  </span><span class="s1">return a[COLUMN] - b[COLUMN];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';</span><span class="s3">\n</span><span class="s1">import { COLUMN } from './sourcemap-segment';</span><span class="s3">\n\n</span><span class="s1">export type MemoState = {</span><span class="s3">\n  </span><span class="s1">lastKey: number;</span><span class="s3">\n  </span><span class="s1">lastNeedle: number;</span><span class="s3">\n  </span><span class="s1">lastIndex: number;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export let found = false;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A binary search implementation that returns the index if a match is found.</span><span class="s3">\n </span><span class="s1">* If no match is found, then the left-index (the index associated with the item that comes just</span><span class="s3">\n </span><span class="s1">* before the desired index) is returned. To maintain proper sort order, a splice would happen at</span><span class="s3">\n </span><span class="s1">* the next index:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* ```js</span><span class="s3">\n </span><span class="s1">* const array = [1, 3];</span><span class="s3">\n </span><span class="s1">* const needle = 2;</span><span class="s3">\n </span><span class="s1">* const index = binarySearch(array, needle, (item, needle) =&gt; item - needle);</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* assert.equal(index, 0);</span><span class="s3">\n </span><span class="s1">* array.splice(index + 1, 0, needle);</span><span class="s3">\n </span><span class="s1">* assert.deepEqual(array, [1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function binarySearch(</span><span class="s3">\n  </span><span class="s1">haystack: SourceMapSegment[] | ReverseSegment[],</span><span class="s3">\n  </span><span class="s1">needle: number,</span><span class="s3">\n  </span><span class="s1">low: number,</span><span class="s3">\n  </span><span class="s1">high: number,</span><span class="s3">\n</span><span class="s1">): number {</span><span class="s3">\n  </span><span class="s1">while (low &lt;= high) {</span><span class="s3">\n    </span><span class="s1">const mid = low + ((high - low) &gt;&gt; 1);</span><span class="s3">\n    </span><span class="s1">const cmp = haystack[mid][COLUMN] - needle;</span><span class="s3">\n\n    </span><span class="s1">if (cmp === 0) {</span><span class="s3">\n      </span><span class="s1">found = true;</span><span class="s3">\n      </span><span class="s1">return mid;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (cmp &lt; 0) {</span><span class="s3">\n      </span><span class="s1">low = mid + 1;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">high = mid - 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">found = false;</span><span class="s3">\n  </span><span class="s1">return low - 1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function upperBound(</span><span class="s3">\n  </span><span class="s1">haystack: SourceMapSegment[] | ReverseSegment[],</span><span class="s3">\n  </span><span class="s1">needle: number,</span><span class="s3">\n  </span><span class="s1">index: number,</span><span class="s3">\n</span><span class="s1">): number {</span><span class="s3">\n  </span><span class="s1">for (let i = index + 1; i &lt; haystack.length; index = i++) {</span><span class="s3">\n    </span><span class="s1">if (haystack[i][COLUMN] !== needle) break;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function lowerBound(</span><span class="s3">\n  </span><span class="s1">haystack: SourceMapSegment[] | ReverseSegment[],</span><span class="s3">\n  </span><span class="s1">needle: number,</span><span class="s3">\n  </span><span class="s1">index: number,</span><span class="s3">\n</span><span class="s1">): number {</span><span class="s3">\n  </span><span class="s1">for (let i = index - 1; i &gt;= 0; index = i--) {</span><span class="s3">\n    </span><span class="s1">if (haystack[i][COLUMN] !== needle) break;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function memoizedState(): MemoState {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">lastKey: -1,</span><span class="s3">\n    </span><span class="s1">lastNeedle: -1,</span><span class="s3">\n    </span><span class="s1">lastIndex: -1,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This overly complicated beast is just to record the last tested line/column and the resulting</span><span class="s3">\n </span><span class="s1">* index, allowing us to skip a few tests if mappings are monotonically increasing.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function memoizedBinarySearch(</span><span class="s3">\n  </span><span class="s1">haystack: SourceMapSegment[] | ReverseSegment[],</span><span class="s3">\n  </span><span class="s1">needle: number,</span><span class="s3">\n  </span><span class="s1">state: MemoState,</span><span class="s3">\n  </span><span class="s1">key: number,</span><span class="s3">\n</span><span class="s1">): number {</span><span class="s3">\n  </span><span class="s1">const { lastKey, lastNeedle, lastIndex } = state;</span><span class="s3">\n\n  </span><span class="s1">let low = 0;</span><span class="s3">\n  </span><span class="s1">let high = haystack.length - 1;</span><span class="s3">\n  </span><span class="s1">if (key === lastKey) {</span><span class="s3">\n    </span><span class="s1">if (needle === lastNeedle) {</span><span class="s3">\n      </span><span class="s1">found = lastIndex !== -1 &amp;&amp; haystack[lastIndex][COLUMN] === needle;</span><span class="s3">\n      </span><span class="s1">return lastIndex;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (needle &gt;= lastNeedle) {</span><span class="s3">\n      </span><span class="s1">// lastIndex may be -1 if the previous needle was not found.</span><span class="s3">\n      </span><span class="s1">low = lastIndex === -1 ? 0 : lastIndex;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">high = lastIndex;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">state.lastKey = key;</span><span class="s3">\n  </span><span class="s1">state.lastNeedle = needle;</span><span class="s3">\n\n  </span><span class="s1">return (state.lastIndex = binarySearch(haystack, needle, low, high));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { COLUMN, SOURCES_INDEX, SOURCE_LINE, SOURCE_COLUMN } from './sourcemap-segment';</span><span class="s3">\n</span><span class="s1">import { memoizedBinarySearch, upperBound } from './binary-search';</span><span class="s3">\n\n</span><span class="s1">import type { ReverseSegment, SourceMapSegment } from './sourcemap-segment';</span><span class="s3">\n</span><span class="s1">import type { MemoState } from './binary-search';</span><span class="s3">\n\n</span><span class="s1">export type Source = {</span><span class="s3">\n  </span><span class="s1">__proto__: null;</span><span class="s3">\n  </span><span class="s1">[line: number]: Exclude&lt;ReverseSegment, [number]&gt;[];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Rebuilds the original source files, with mappings that are ordered by source line/column instead</span><span class="s3">\n</span><span class="s1">// of generated line/column.</span><span class="s3">\n</span><span class="s1">export default function buildBySources(</span><span class="s3">\n  </span><span class="s1">decoded: readonly SourceMapSegment[][],</span><span class="s3">\n  </span><span class="s1">memos: MemoState[],</span><span class="s3">\n</span><span class="s1">): Source[] {</span><span class="s3">\n  </span><span class="s1">const sources: Source[] = memos.map(buildNullArray);</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; decoded.length; i++) {</span><span class="s3">\n    </span><span class="s1">const line = decoded[i];</span><span class="s3">\n    </span><span class="s1">for (let j = 0; j &lt; line.length; j++) {</span><span class="s3">\n      </span><span class="s1">const seg = line[j];</span><span class="s3">\n      </span><span class="s1">if (seg.length === 1) continue;</span><span class="s3">\n\n      </span><span class="s1">const sourceIndex = seg[SOURCES_INDEX];</span><span class="s3">\n      </span><span class="s1">const sourceLine = seg[SOURCE_LINE];</span><span class="s3">\n      </span><span class="s1">const sourceColumn = seg[SOURCE_COLUMN];</span><span class="s3">\n      </span><span class="s1">const originalSource = sources[sourceIndex];</span><span class="s3">\n      </span><span class="s1">const originalLine = (originalSource[sourceLine] ||= []);</span><span class="s3">\n      </span><span class="s1">const memo = memos[sourceIndex];</span><span class="s3">\n\n      </span><span class="s1">// The binary search either found a match, or it found the left-index just before where the</span><span class="s3">\n      </span><span class="s1">// segment should go. Either way, we want to insert after that. And there may be multiple</span><span class="s3">\n      </span><span class="s1">// generated segments associated with an original location, so there may need to move several</span><span class="s3">\n      </span><span class="s1">// indexes before we find where we need to insert.</span><span class="s3">\n      </span><span class="s1">const index = upperBound(</span><span class="s3">\n        </span><span class="s1">originalLine,</span><span class="s3">\n        </span><span class="s1">sourceColumn,</span><span class="s3">\n        </span><span class="s1">memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return sources;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function insert&lt;T&gt;(array: T[], index: number, value: T) {</span><span class="s3">\n  </span><span class="s1">for (let i = array.length; i &gt; index; i--) {</span><span class="s3">\n    </span><span class="s1">array[i] = array[i - 1];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">array[index] = value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like</span><span class="s3">\n</span><span class="s1">// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.</span><span class="s3">\n</span><span class="s1">// Numeric properties on objects are magically sorted in ascending order by the engine regardless of</span><span class="s3">\n</span><span class="s1">// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending</span><span class="s3">\n</span><span class="s1">// order when iterating with for-in.</span><span class="s3">\n</span><span class="s1">function buildNullArray&lt;T extends { __proto__: null }&gt;(): T {</span><span class="s3">\n  </span><span class="s1">return { __proto__: null } as T;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { TraceMap, presortedDecodedMap, decodedMappings } from './trace-mapping';</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">COLUMN,</span><span class="s3">\n  </span><span class="s1">SOURCES_INDEX,</span><span class="s3">\n  </span><span class="s1">SOURCE_LINE,</span><span class="s3">\n  </span><span class="s1">SOURCE_COLUMN,</span><span class="s3">\n  </span><span class="s1">NAMES_INDEX,</span><span class="s3">\n</span><span class="s1">} from './sourcemap-segment';</span><span class="s3">\n\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Section,</span><span class="s3">\n  </span><span class="s1">SectionedSourceMap,</span><span class="s3">\n  </span><span class="s1">DecodedSourceMap,</span><span class="s3">\n  </span><span class="s1">SectionedSourceMapInput,</span><span class="s3">\n  </span><span class="s1">Ro,</span><span class="s3">\n</span><span class="s1">} from './types';</span><span class="s3">\n</span><span class="s1">import type { SourceMapSegment } from './sourcemap-segment';</span><span class="s3">\n\n</span><span class="s1">type AnyMap = {</span><span class="s3">\n  </span><span class="s1">new (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;</span><span class="s3">\n  </span><span class="s1">(map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export const AnyMap: AnyMap = function (map, mapUrl) {</span><span class="s3">\n  </span><span class="s1">const parsed =</span><span class="s3">\n    </span><span class="s1">typeof map === 'string' ? (JSON.parse(map) as Exclude&lt;SectionedSourceMapInput, string&gt;) : map;</span><span class="s3">\n\n  </span><span class="s1">if (!('sections' in parsed)) return new TraceMap(parsed, mapUrl);</span><span class="s3">\n\n  </span><span class="s1">const mappings: SourceMapSegment[][] = [];</span><span class="s3">\n  </span><span class="s1">const sources: string[] = [];</span><span class="s3">\n  </span><span class="s1">const sourcesContent: (string | null)[] = [];</span><span class="s3">\n  </span><span class="s1">const names: string[] = [];</span><span class="s3">\n\n  </span><span class="s1">recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);</span><span class="s3">\n\n  </span><span class="s1">const joined: DecodedSourceMap = {</span><span class="s3">\n    </span><span class="s1">version: 3,</span><span class="s3">\n    </span><span class="s1">file: parsed.file,</span><span class="s3">\n    </span><span class="s1">names,</span><span class="s3">\n    </span><span class="s1">sources,</span><span class="s3">\n    </span><span class="s1">sourcesContent,</span><span class="s3">\n    </span><span class="s1">mappings,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">return presortedDecodedMap(joined);</span><span class="s3">\n</span><span class="s1">} as AnyMap;</span><span class="s3">\n\n</span><span class="s1">function recurse(</span><span class="s3">\n  </span><span class="s1">input: Ro&lt;SectionedSourceMap&gt;,</span><span class="s3">\n  </span><span class="s1">mapUrl: string | null | undefined,</span><span class="s3">\n  </span><span class="s1">mappings: SourceMapSegment[][],</span><span class="s3">\n  </span><span class="s1">sources: string[],</span><span class="s3">\n  </span><span class="s1">sourcesContent: (string | null)[],</span><span class="s3">\n  </span><span class="s1">names: string[],</span><span class="s3">\n  </span><span class="s1">lineOffset: number,</span><span class="s3">\n  </span><span class="s1">columnOffset: number,</span><span class="s3">\n  </span><span class="s1">stopLine: number,</span><span class="s3">\n  </span><span class="s1">stopColumn: number,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { sections } = input;</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; sections.length; i++) {</span><span class="s3">\n    </span><span class="s1">const { map, offset } = sections[i];</span><span class="s3">\n\n    </span><span class="s1">let sl = stopLine;</span><span class="s3">\n    </span><span class="s1">let sc = stopColumn;</span><span class="s3">\n    </span><span class="s1">if (i + 1 &lt; sections.length) {</span><span class="s3">\n      </span><span class="s1">const nextOffset = sections[i + 1].offset;</span><span class="s3">\n      </span><span class="s1">sl = Math.min(stopLine, lineOffset + nextOffset.line);</span><span class="s3">\n\n      </span><span class="s1">if (sl === stopLine) {</span><span class="s3">\n        </span><span class="s1">sc = Math.min(stopColumn, columnOffset + nextOffset.column);</span><span class="s3">\n      </span><span class="s1">} else if (sl &lt; stopLine) {</span><span class="s3">\n        </span><span class="s1">sc = columnOffset + nextOffset.column;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">addSection(</span><span class="s3">\n      </span><span class="s1">map,</span><span class="s3">\n      </span><span class="s1">mapUrl,</span><span class="s3">\n      </span><span class="s1">mappings,</span><span class="s3">\n      </span><span class="s1">sources,</span><span class="s3">\n      </span><span class="s1">sourcesContent,</span><span class="s3">\n      </span><span class="s1">names,</span><span class="s3">\n      </span><span class="s1">lineOffset + offset.line,</span><span class="s3">\n      </span><span class="s1">columnOffset + offset.column,</span><span class="s3">\n      </span><span class="s1">sl,</span><span class="s3">\n      </span><span class="s1">sc,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function addSection(</span><span class="s3">\n  </span><span class="s1">input: Ro&lt;Section['map']&gt;,</span><span class="s3">\n  </span><span class="s1">mapUrl: string | null | undefined,</span><span class="s3">\n  </span><span class="s1">mappings: SourceMapSegment[][],</span><span class="s3">\n  </span><span class="s1">sources: string[],</span><span class="s3">\n  </span><span class="s1">sourcesContent: (string | null)[],</span><span class="s3">\n  </span><span class="s1">names: string[],</span><span class="s3">\n  </span><span class="s1">lineOffset: number,</span><span class="s3">\n  </span><span class="s1">columnOffset: number,</span><span class="s3">\n  </span><span class="s1">stopLine: number,</span><span class="s3">\n  </span><span class="s1">stopColumn: number,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if ('sections' in input) return recurse(...(arguments as unknown as Parameters&lt;typeof recurse&gt;));</span><span class="s3">\n\n  </span><span class="s1">const map = new TraceMap(input, mapUrl);</span><span class="s3">\n  </span><span class="s1">const sourcesOffset = sources.length;</span><span class="s3">\n  </span><span class="s1">const namesOffset = names.length;</span><span class="s3">\n  </span><span class="s1">const decoded = decodedMappings(map);</span><span class="s3">\n  </span><span class="s1">const { resolvedSources, sourcesContent: contents } = map;</span><span class="s3">\n\n  </span><span class="s1">append(sources, resolvedSources);</span><span class="s3">\n  </span><span class="s1">append(names, map.names);</span><span class="s3">\n  </span><span class="s1">if (contents) append(sourcesContent, contents);</span><span class="s3">\n  </span><span class="s1">else for (let i = 0; i &lt; resolvedSources.length; i++) sourcesContent.push(null);</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; decoded.length; i++) {</span><span class="s3">\n    </span><span class="s1">const lineI = lineOffset + i;</span><span class="s3">\n\n    </span><span class="s1">// We can only add so many lines before we step into the range that the next section's map</span><span class="s3">\n    </span><span class="s1">// controls. When we get to the last line, then we'll start checking the segments to see if</span><span class="s3">\n    </span><span class="s1">// they've crossed into the column range. But it may not have any columns that overstep, so we</span><span class="s3">\n    </span><span class="s1">// still need to check that we don't overstep lines, too.</span><span class="s3">\n    </span><span class="s1">if (lineI &gt; stopLine) return;</span><span class="s3">\n\n    </span><span class="s1">// The out line may already exist in mappings (if we're continuing the line started by a</span><span class="s3">\n    </span><span class="s1">// previous section). Or, we may have jumped ahead several lines to start this section.</span><span class="s3">\n    </span><span class="s1">const out = getLine(mappings, lineI);</span><span class="s3">\n    </span><span class="s1">// On the 0th loop, the section's column offset shifts us forward. On all other lines (since the</span><span class="s3">\n    </span><span class="s1">// map can be multiple lines), it doesn't.</span><span class="s3">\n    </span><span class="s1">const cOffset = i === 0 ? columnOffset : 0;</span><span class="s3">\n\n    </span><span class="s1">const line = decoded[i];</span><span class="s3">\n    </span><span class="s1">for (let j = 0; j &lt; line.length; j++) {</span><span class="s3">\n      </span><span class="s1">const seg = line[j];</span><span class="s3">\n      </span><span class="s1">const column = cOffset + seg[COLUMN];</span><span class="s3">\n\n      </span><span class="s1">// If this segment steps into the column range that the next section's map controls, we need</span><span class="s3">\n      </span><span class="s1">// to stop early.</span><span class="s3">\n      </span><span class="s1">if (lineI === stopLine &amp;&amp; column &gt;= stopColumn) return;</span><span class="s3">\n\n      </span><span class="s1">if (seg.length === 1) {</span><span class="s3">\n        </span><span class="s1">out.push([column]);</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];</span><span class="s3">\n      </span><span class="s1">const sourceLine = seg[SOURCE_LINE];</span><span class="s3">\n      </span><span class="s1">const sourceColumn = seg[SOURCE_COLUMN];</span><span class="s3">\n      </span><span class="s1">out.push(</span><span class="s3">\n        </span><span class="s1">seg.length === 4</span><span class="s3">\n          </span><span class="s1">? [column, sourcesIndex, sourceLine, sourceColumn]</span><span class="s3">\n          </span><span class="s1">: [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]],</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function append&lt;T&gt;(arr: T[], other: T[]) {</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; other.length; i++) arr.push(other[i]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getLine&lt;T&gt;(arr: T[][], index: number): T[] {</span><span class="s3">\n  </span><span class="s1">for (let i = arr.length; i &lt;= index; i++) arr[i] = [];</span><span class="s3">\n  </span><span class="s1">return arr[index];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { encode, decode } from '@jridgewell/sourcemap-codec';</span><span class="s3">\n\n</span><span class="s1">import resolve from './resolve';</span><span class="s3">\n</span><span class="s1">import stripFilename from './strip-filename';</span><span class="s3">\n</span><span class="s1">import maybeSort from './sort';</span><span class="s3">\n</span><span class="s1">import buildBySources from './by-source';</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">memoizedState,</span><span class="s3">\n  </span><span class="s1">memoizedBinarySearch,</span><span class="s3">\n  </span><span class="s1">upperBound,</span><span class="s3">\n  </span><span class="s1">lowerBound,</span><span class="s3">\n  </span><span class="s1">found as bsFound,</span><span class="s3">\n</span><span class="s1">} from './binary-search';</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">COLUMN,</span><span class="s3">\n  </span><span class="s1">SOURCES_INDEX,</span><span class="s3">\n  </span><span class="s1">SOURCE_LINE,</span><span class="s3">\n  </span><span class="s1">SOURCE_COLUMN,</span><span class="s3">\n  </span><span class="s1">NAMES_INDEX,</span><span class="s3">\n  </span><span class="s1">REV_GENERATED_LINE,</span><span class="s3">\n  </span><span class="s1">REV_GENERATED_COLUMN,</span><span class="s3">\n</span><span class="s1">} from './sourcemap-segment';</span><span class="s3">\n\n</span><span class="s1">import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">SourceMapV3,</span><span class="s3">\n  </span><span class="s1">DecodedSourceMap,</span><span class="s3">\n  </span><span class="s1">EncodedSourceMap,</span><span class="s3">\n  </span><span class="s1">InvalidOriginalMapping,</span><span class="s3">\n  </span><span class="s1">OriginalMapping,</span><span class="s3">\n  </span><span class="s1">InvalidGeneratedMapping,</span><span class="s3">\n  </span><span class="s1">GeneratedMapping,</span><span class="s3">\n  </span><span class="s1">SourceMapInput,</span><span class="s3">\n  </span><span class="s1">Needle,</span><span class="s3">\n  </span><span class="s1">SourceNeedle,</span><span class="s3">\n  </span><span class="s1">SourceMap,</span><span class="s3">\n  </span><span class="s1">EachMapping,</span><span class="s3">\n  </span><span class="s1">Bias,</span><span class="s3">\n</span><span class="s1">} from './types';</span><span class="s3">\n</span><span class="s1">import type { Source } from './by-source';</span><span class="s3">\n</span><span class="s1">import type { MemoState } from './binary-search';</span><span class="s3">\n\n</span><span class="s1">export type { SourceMapSegment } from './sourcemap-segment';</span><span class="s3">\n</span><span class="s1">export type {</span><span class="s3">\n  </span><span class="s1">SourceMapInput,</span><span class="s3">\n  </span><span class="s1">SectionedSourceMapInput,</span><span class="s3">\n  </span><span class="s1">DecodedSourceMap,</span><span class="s3">\n  </span><span class="s1">EncodedSourceMap,</span><span class="s3">\n  </span><span class="s1">SectionedSourceMap,</span><span class="s3">\n  </span><span class="s1">InvalidOriginalMapping,</span><span class="s3">\n  </span><span class="s1">OriginalMapping as Mapping,</span><span class="s3">\n  </span><span class="s1">OriginalMapping,</span><span class="s3">\n  </span><span class="s1">InvalidGeneratedMapping,</span><span class="s3">\n  </span><span class="s1">GeneratedMapping,</span><span class="s3">\n  </span><span class="s1">EachMapping,</span><span class="s3">\n</span><span class="s1">} from './types';</span><span class="s3">\n\n</span><span class="s1">const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';</span><span class="s3">\n</span><span class="s1">const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';</span><span class="s3">\n\n</span><span class="s1">export const LEAST_UPPER_BOUND = -1;</span><span class="s3">\n</span><span class="s1">export const GREATEST_LOWER_BOUND = 1;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the encoded (VLQ string) form of the SourceMap's mappings field.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let encodedMappings: (map: TraceMap) =&gt; EncodedSourceMap['mappings'];</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let decodedMappings: (map: TraceMap) =&gt; Readonly&lt;DecodedSourceMap['mappings']&gt;;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A low-level API to find the segment associated with a generated line/column (think, from a</span><span class="s3">\n </span><span class="s1">* stack trace). Line and column here are 0-based, unlike `originalPositionFor`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let traceSegment: (</span><span class="s3">\n  </span><span class="s1">map: TraceMap,</span><span class="s3">\n  </span><span class="s1">line: number,</span><span class="s3">\n  </span><span class="s1">column: number,</span><span class="s3">\n</span><span class="s1">) =&gt; Readonly&lt;SourceMapSegment&gt; | null;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A higher-level API to find the source/line/column associated with a generated line/column</span><span class="s3">\n </span><span class="s1">* (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in</span><span class="s3">\n </span><span class="s1">* `source-map` library.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let originalPositionFor: (</span><span class="s3">\n  </span><span class="s1">map: TraceMap,</span><span class="s3">\n  </span><span class="s1">needle: Needle,</span><span class="s3">\n</span><span class="s1">) =&gt; OriginalMapping | InvalidOriginalMapping;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Finds the generated line/column position of the provided source/line/column source position.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let generatedPositionFor: (</span><span class="s3">\n  </span><span class="s1">map: TraceMap,</span><span class="s3">\n  </span><span class="s1">needle: SourceNeedle,</span><span class="s3">\n</span><span class="s1">) =&gt; GeneratedMapping | InvalidGeneratedMapping;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Finds all generated line/column positions of the provided source/line/column source position.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let allGeneratedPositionsFor: (map: TraceMap, needle: SourceNeedle) =&gt; GeneratedMapping[];</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Iterates each mapping in generated position order.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let eachMapping: (map: TraceMap, cb: (mapping: EachMapping) =&gt; void) =&gt; void;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Retrieves the source content for a particular source, if its found. Returns null if not.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let sourceContentFor: (map: TraceMap, source: string) =&gt; string | null;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A helper that skips sorting of the input map's mappings array, which can be expensive for larger</span><span class="s3">\n </span><span class="s1">* maps.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let presortedDecodedMap: (map: DecodedSourceMap, mapUrl?: string) =&gt; TraceMap;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects</span><span class="s3">\n </span><span class="s1">* a sourcemap, or to JSON.stringify.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let decodedMap: (</span><span class="s3">\n  </span><span class="s1">map: TraceMap,</span><span class="s3">\n</span><span class="s1">) =&gt; Omit&lt;DecodedSourceMap, 'mappings'&gt; &amp; { mappings: readonly SourceMapSegment[][] };</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects</span><span class="s3">\n </span><span class="s1">* a sourcemap, or to JSON.stringify.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let encodedMap: (map: TraceMap) =&gt; EncodedSourceMap;</span><span class="s3">\n\n</span><span class="s1">export { AnyMap } from './any-map';</span><span class="s3">\n\n</span><span class="s1">export class TraceMap implements SourceMap {</span><span class="s3">\n  </span><span class="s1">declare version: SourceMapV3['version'];</span><span class="s3">\n  </span><span class="s1">declare file: SourceMapV3['file'];</span><span class="s3">\n  </span><span class="s1">declare names: SourceMapV3['names'];</span><span class="s3">\n  </span><span class="s1">declare sourceRoot: SourceMapV3['sourceRoot'];</span><span class="s3">\n  </span><span class="s1">declare sources: SourceMapV3['sources'];</span><span class="s3">\n  </span><span class="s1">declare sourcesContent: SourceMapV3['sourcesContent'];</span><span class="s3">\n\n  </span><span class="s1">declare resolvedSources: string[];</span><span class="s3">\n  </span><span class="s1">private declare _encoded: string | undefined;</span><span class="s3">\n\n  </span><span class="s1">private declare _decoded: SourceMapSegment[][] | undefined;</span><span class="s3">\n  </span><span class="s1">private declare _decodedMemo: MemoState;</span><span class="s3">\n\n  </span><span class="s1">private declare _bySources: Source[] | undefined;</span><span class="s3">\n  </span><span class="s1">private declare _bySourceMemos: MemoState[] | undefined;</span><span class="s3">\n\n  </span><span class="s1">constructor(map: SourceMapInput, mapUrl?: string | null) {</span><span class="s3">\n    </span><span class="s1">const isString = typeof map === 'string';</span><span class="s3">\n\n    </span><span class="s1">if (!isString &amp;&amp; (map as unknown as { _decodedMemo: any })._decodedMemo) return map as TraceMap;</span><span class="s3">\n\n    </span><span class="s1">const parsed = (isString ? JSON.parse(map) : map) as DecodedSourceMap | EncodedSourceMap;</span><span class="s3">\n\n    </span><span class="s1">const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;</span><span class="s3">\n    </span><span class="s1">this.version = version;</span><span class="s3">\n    </span><span class="s1">this.file = file;</span><span class="s3">\n    </span><span class="s1">this.names = names;</span><span class="s3">\n    </span><span class="s1">this.sourceRoot = sourceRoot;</span><span class="s3">\n    </span><span class="s1">this.sources = sources;</span><span class="s3">\n    </span><span class="s1">this.sourcesContent = sourcesContent;</span><span class="s3">\n\n    </span><span class="s1">const from = resolve(sourceRoot || '', stripFilename(mapUrl));</span><span class="s3">\n    </span><span class="s1">this.resolvedSources = sources.map((s) =&gt; resolve(s || '', from));</span><span class="s3">\n\n    </span><span class="s1">const { mappings } = parsed;</span><span class="s3">\n    </span><span class="s1">if (typeof mappings === 'string') {</span><span class="s3">\n      </span><span class="s1">this._encoded = mappings;</span><span class="s3">\n      </span><span class="s1">this._decoded = undefined;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this._encoded = undefined;</span><span class="s3">\n      </span><span class="s1">this._decoded = maybeSort(mappings, isString);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._decodedMemo = memoizedState();</span><span class="s3">\n    </span><span class="s1">this._bySources = undefined;</span><span class="s3">\n    </span><span class="s1">this._bySourceMemos = undefined;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">encodedMappings = (map) =&gt; {</span><span class="s3">\n      </span><span class="s1">return (map._encoded ??= encode(map._decoded!));</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">decodedMappings = (map) =&gt; {</span><span class="s3">\n      </span><span class="s1">return (map._decoded ||= decode(map._encoded!));</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">traceSegment = (map, line, column) =&gt; {</span><span class="s3">\n      </span><span class="s1">const decoded = decodedMappings(map);</span><span class="s3">\n\n      </span><span class="s1">// It's common for parent source maps to have pointers to lines that have no</span><span class="s3">\n      </span><span class="s1">// mapping (like a </span><span class="s3">\&quot;</span><span class="s1">//# sourceMappingURL=</span><span class="s3">\&quot;</span><span class="s1">) at the end of the child file.</span><span class="s3">\n      </span><span class="s1">if (line &gt;= decoded.length) return null;</span><span class="s3">\n\n      </span><span class="s1">const segments = decoded[line];</span><span class="s3">\n      </span><span class="s1">const index = traceSegmentInternal(</span><span class="s3">\n        </span><span class="s1">segments,</span><span class="s3">\n        </span><span class="s1">map._decodedMemo,</span><span class="s3">\n        </span><span class="s1">line,</span><span class="s3">\n        </span><span class="s1">column,</span><span class="s3">\n        </span><span class="s1">GREATEST_LOWER_BOUND,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">return index === -1 ? null : segments[index];</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">originalPositionFor = (map, { line, column, bias }) =&gt; {</span><span class="s3">\n      </span><span class="s1">line--;</span><span class="s3">\n      </span><span class="s1">if (line &lt; 0) throw new Error(LINE_GTR_ZERO);</span><span class="s3">\n      </span><span class="s1">if (column &lt; 0) throw new Error(COL_GTR_EQ_ZERO);</span><span class="s3">\n\n      </span><span class="s1">const decoded = decodedMappings(map);</span><span class="s3">\n\n      </span><span class="s1">// It's common for parent source maps to have pointers to lines that have no</span><span class="s3">\n      </span><span class="s1">// mapping (like a </span><span class="s3">\&quot;</span><span class="s1">//# sourceMappingURL=</span><span class="s3">\&quot;</span><span class="s1">) at the end of the child file.</span><span class="s3">\n      </span><span class="s1">if (line &gt;= decoded.length) return OMapping(null, null, null, null);</span><span class="s3">\n\n      </span><span class="s1">const segments = decoded[line];</span><span class="s3">\n      </span><span class="s1">const index = traceSegmentInternal(</span><span class="s3">\n        </span><span class="s1">segments,</span><span class="s3">\n        </span><span class="s1">map._decodedMemo,</span><span class="s3">\n        </span><span class="s1">line,</span><span class="s3">\n        </span><span class="s1">column,</span><span class="s3">\n        </span><span class="s1">bias || GREATEST_LOWER_BOUND,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">if (index === -1) return OMapping(null, null, null, null);</span><span class="s3">\n\n      </span><span class="s1">const segment = segments[index];</span><span class="s3">\n      </span><span class="s1">if (segment.length === 1) return OMapping(null, null, null, null);</span><span class="s3">\n\n      </span><span class="s1">const { names, resolvedSources } = map;</span><span class="s3">\n      </span><span class="s1">return OMapping(</span><span class="s3">\n        </span><span class="s1">resolvedSources[segment[SOURCES_INDEX]],</span><span class="s3">\n        </span><span class="s1">segment[SOURCE_LINE] + 1,</span><span class="s3">\n        </span><span class="s1">segment[SOURCE_COLUMN],</span><span class="s3">\n        </span><span class="s1">segment.length === 5 ? names[segment[NAMES_INDEX]] : null,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">allGeneratedPositionsFor = (map, { source, line, column, bias }) =&gt; {</span><span class="s3">\n      </span><span class="s1">// SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.</span><span class="s3">\n      </span><span class="s1">return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">generatedPositionFor = (map, { source, line, column, bias }) =&gt; {</span><span class="s3">\n      </span><span class="s1">return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">eachMapping = (map, cb) =&gt; {</span><span class="s3">\n      </span><span class="s1">const decoded = decodedMappings(map);</span><span class="s3">\n      </span><span class="s1">const { names, resolvedSources } = map;</span><span class="s3">\n\n      </span><span class="s1">for (let i = 0; i &lt; decoded.length; i++) {</span><span class="s3">\n        </span><span class="s1">const line = decoded[i];</span><span class="s3">\n        </span><span class="s1">for (let j = 0; j &lt; line.length; j++) {</span><span class="s3">\n          </span><span class="s1">const seg = line[j];</span><span class="s3">\n\n          </span><span class="s1">const generatedLine = i + 1;</span><span class="s3">\n          </span><span class="s1">const generatedColumn = seg[0];</span><span class="s3">\n          </span><span class="s1">let source = null;</span><span class="s3">\n          </span><span class="s1">let originalLine = null;</span><span class="s3">\n          </span><span class="s1">let originalColumn = null;</span><span class="s3">\n          </span><span class="s1">let name = null;</span><span class="s3">\n          </span><span class="s1">if (seg.length !== 1) {</span><span class="s3">\n            </span><span class="s1">source = resolvedSources[seg[1]];</span><span class="s3">\n            </span><span class="s1">originalLine = seg[2] + 1;</span><span class="s3">\n            </span><span class="s1">originalColumn = seg[3];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (seg.length === 5) name = names[seg[4]];</span><span class="s3">\n\n          </span><span class="s1">cb({</span><span class="s3">\n            </span><span class="s1">generatedLine,</span><span class="s3">\n            </span><span class="s1">generatedColumn,</span><span class="s3">\n            </span><span class="s1">source,</span><span class="s3">\n            </span><span class="s1">originalLine,</span><span class="s3">\n            </span><span class="s1">originalColumn,</span><span class="s3">\n            </span><span class="s1">name,</span><span class="s3">\n          </span><span class="s1">} as EachMapping);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">sourceContentFor = (map, source) =&gt; {</span><span class="s3">\n      </span><span class="s1">const { sources, resolvedSources, sourcesContent } = map;</span><span class="s3">\n      </span><span class="s1">if (sourcesContent == null) return null;</span><span class="s3">\n\n      </span><span class="s1">let index = sources.indexOf(source);</span><span class="s3">\n      </span><span class="s1">if (index === -1) index = resolvedSources.indexOf(source);</span><span class="s3">\n\n      </span><span class="s1">return index === -1 ? null : sourcesContent[index];</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">presortedDecodedMap = (map, mapUrl) =&gt; {</span><span class="s3">\n      </span><span class="s1">const tracer = new TraceMap(clone(map, []), mapUrl);</span><span class="s3">\n      </span><span class="s1">tracer._decoded = map.mappings;</span><span class="s3">\n      </span><span class="s1">return tracer;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">decodedMap = (map) =&gt; {</span><span class="s3">\n      </span><span class="s1">return clone(map, decodedMappings(map));</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">encodedMap = (map) =&gt; {</span><span class="s3">\n      </span><span class="s1">return clone(map, encodedMappings(map));</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">function generatedPosition(</span><span class="s3">\n      </span><span class="s1">map: TraceMap,</span><span class="s3">\n      </span><span class="s1">source: string,</span><span class="s3">\n      </span><span class="s1">line: number,</span><span class="s3">\n      </span><span class="s1">column: number,</span><span class="s3">\n      </span><span class="s1">bias: Bias,</span><span class="s3">\n      </span><span class="s1">all: false,</span><span class="s3">\n    </span><span class="s1">): GeneratedMapping | InvalidGeneratedMapping;</span><span class="s3">\n    </span><span class="s1">function generatedPosition(</span><span class="s3">\n      </span><span class="s1">map: TraceMap,</span><span class="s3">\n      </span><span class="s1">source: string,</span><span class="s3">\n      </span><span class="s1">line: number,</span><span class="s3">\n      </span><span class="s1">column: number,</span><span class="s3">\n      </span><span class="s1">bias: Bias,</span><span class="s3">\n      </span><span class="s1">all: true,</span><span class="s3">\n    </span><span class="s1">): GeneratedMapping[];</span><span class="s3">\n    </span><span class="s1">function generatedPosition(</span><span class="s3">\n      </span><span class="s1">map: TraceMap,</span><span class="s3">\n      </span><span class="s1">source: string,</span><span class="s3">\n      </span><span class="s1">line: number,</span><span class="s3">\n      </span><span class="s1">column: number,</span><span class="s3">\n      </span><span class="s1">bias: Bias,</span><span class="s3">\n      </span><span class="s1">all: boolean,</span><span class="s3">\n    </span><span class="s1">): GeneratedMapping | InvalidGeneratedMapping | GeneratedMapping[] {</span><span class="s3">\n      </span><span class="s1">line--;</span><span class="s3">\n      </span><span class="s1">if (line &lt; 0) throw new Error(LINE_GTR_ZERO);</span><span class="s3">\n      </span><span class="s1">if (column &lt; 0) throw new Error(COL_GTR_EQ_ZERO);</span><span class="s3">\n\n      </span><span class="s1">const { sources, resolvedSources } = map;</span><span class="s3">\n      </span><span class="s1">let sourceIndex = sources.indexOf(source);</span><span class="s3">\n      </span><span class="s1">if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);</span><span class="s3">\n      </span><span class="s1">if (sourceIndex === -1) return all ? [] : GMapping(null, null);</span><span class="s3">\n\n      </span><span class="s1">const generated = (map._bySources ||= buildBySources(</span><span class="s3">\n        </span><span class="s1">decodedMappings(map),</span><span class="s3">\n        </span><span class="s1">(map._bySourceMemos = sources.map(memoizedState)),</span><span class="s3">\n      </span><span class="s1">));</span><span class="s3">\n\n      </span><span class="s1">const segments = generated[sourceIndex][line];</span><span class="s3">\n      </span><span class="s1">if (segments == null) return all ? [] : GMapping(null, null);</span><span class="s3">\n\n      </span><span class="s1">const memo = map._bySourceMemos![sourceIndex];</span><span class="s3">\n\n      </span><span class="s1">if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);</span><span class="s3">\n\n      </span><span class="s1">const index = traceSegmentInternal(segments, memo, line, column, bias);</span><span class="s3">\n      </span><span class="s1">if (index === -1) return GMapping(null, null);</span><span class="s3">\n\n      </span><span class="s1">const segment = segments[index];</span><span class="s3">\n      </span><span class="s1">return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function clone&lt;T extends string | readonly SourceMapSegment[][]&gt;(</span><span class="s3">\n  </span><span class="s1">map: TraceMap | DecodedSourceMap | EncodedSourceMap,</span><span class="s3">\n  </span><span class="s1">mappings: T,</span><span class="s3">\n</span><span class="s1">): T extends string ? EncodedSourceMap : DecodedSourceMap {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">version: map.version,</span><span class="s3">\n    </span><span class="s1">file: map.file,</span><span class="s3">\n    </span><span class="s1">names: map.names,</span><span class="s3">\n    </span><span class="s1">sourceRoot: map.sourceRoot,</span><span class="s3">\n    </span><span class="s1">sources: map.sources,</span><span class="s3">\n    </span><span class="s1">sourcesContent: map.sourcesContent,</span><span class="s3">\n    </span><span class="s1">mappings,</span><span class="s3">\n  </span><span class="s1">} as any;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function OMapping(source: null, line: null, column: null, name: null): InvalidOriginalMapping;</span><span class="s3">\n</span><span class="s1">function OMapping(</span><span class="s3">\n  </span><span class="s1">source: string,</span><span class="s3">\n  </span><span class="s1">line: number,</span><span class="s3">\n  </span><span class="s1">column: number,</span><span class="s3">\n  </span><span class="s1">name: string | null,</span><span class="s3">\n</span><span class="s1">): OriginalMapping;</span><span class="s3">\n</span><span class="s1">function OMapping(</span><span class="s3">\n  </span><span class="s1">source: string | null,</span><span class="s3">\n  </span><span class="s1">line: number | null,</span><span class="s3">\n  </span><span class="s1">column: number | null,</span><span class="s3">\n  </span><span class="s1">name: string | null,</span><span class="s3">\n</span><span class="s1">): OriginalMapping | InvalidOriginalMapping {</span><span class="s3">\n  </span><span class="s1">return { source, line, column, name } as any;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function GMapping(line: null, column: null): InvalidGeneratedMapping;</span><span class="s3">\n</span><span class="s1">function GMapping(line: number, column: number): GeneratedMapping;</span><span class="s3">\n</span><span class="s1">function GMapping(</span><span class="s3">\n  </span><span class="s1">line: number | null,</span><span class="s3">\n  </span><span class="s1">column: number | null,</span><span class="s3">\n</span><span class="s1">): GeneratedMapping | InvalidGeneratedMapping {</span><span class="s3">\n  </span><span class="s1">return { line, column } as any;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function traceSegmentInternal(</span><span class="s3">\n  </span><span class="s1">segments: SourceMapSegment[],</span><span class="s3">\n  </span><span class="s1">memo: MemoState,</span><span class="s3">\n  </span><span class="s1">line: number,</span><span class="s3">\n  </span><span class="s1">column: number,</span><span class="s3">\n  </span><span class="s1">bias: Bias,</span><span class="s3">\n</span><span class="s1">): number;</span><span class="s3">\n</span><span class="s1">function traceSegmentInternal(</span><span class="s3">\n  </span><span class="s1">segments: ReverseSegment[],</span><span class="s3">\n  </span><span class="s1">memo: MemoState,</span><span class="s3">\n  </span><span class="s1">line: number,</span><span class="s3">\n  </span><span class="s1">column: number,</span><span class="s3">\n  </span><span class="s1">bias: Bias,</span><span class="s3">\n</span><span class="s1">): number;</span><span class="s3">\n</span><span class="s1">function traceSegmentInternal(</span><span class="s3">\n  </span><span class="s1">segments: SourceMapSegment[] | ReverseSegment[],</span><span class="s3">\n  </span><span class="s1">memo: MemoState,</span><span class="s3">\n  </span><span class="s1">line: number,</span><span class="s3">\n  </span><span class="s1">column: number,</span><span class="s3">\n  </span><span class="s1">bias: Bias,</span><span class="s3">\n</span><span class="s1">): number {</span><span class="s3">\n  </span><span class="s1">let index = memoizedBinarySearch(segments, column, memo, line);</span><span class="s3">\n  </span><span class="s1">if (bsFound) {</span><span class="s3">\n    </span><span class="s1">index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);</span><span class="s3">\n  </span><span class="s1">} else if (bias === LEAST_UPPER_BOUND) index++;</span><span class="s3">\n\n  </span><span class="s1">if (index === -1 || index === segments.length) return -1;</span><span class="s3">\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function sliceGeneratedPositions(</span><span class="s3">\n  </span><span class="s1">segments: ReverseSegment[],</span><span class="s3">\n  </span><span class="s1">memo: MemoState,</span><span class="s3">\n  </span><span class="s1">line: number,</span><span class="s3">\n  </span><span class="s1">column: number,</span><span class="s3">\n  </span><span class="s1">bias: Bias,</span><span class="s3">\n</span><span class="s1">): GeneratedMapping[] {</span><span class="s3">\n  </span><span class="s1">let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);</span><span class="s3">\n\n  </span><span class="s1">// We ignored the bias when tracing the segment so that we're guarnateed to find the first (in</span><span class="s3">\n  </span><span class="s1">// insertion order) segment that matched. Even if we did respect the bias when tracing, we would</span><span class="s3">\n  </span><span class="s1">// still need to call `lowerBound()` to find the first segment, which is slower than just looking</span><span class="s3">\n  </span><span class="s1">// for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the</span><span class="s3">\n  </span><span class="s1">// binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to</span><span class="s3">\n  </span><span class="s1">// match LEAST_UPPER_BOUND.</span><span class="s3">\n  </span><span class="s1">if (!bsFound &amp;&amp; bias === LEAST_UPPER_BOUND) min++;</span><span class="s3">\n\n  </span><span class="s1">if (min === -1 || min === segments.length) return [];</span><span class="s3">\n\n  </span><span class="s1">// We may have found the segment that started at an earlier column. If this is the case, then we</span><span class="s3">\n  </span><span class="s1">// need to slice all generated segments that match _that_ column, because all such segments span</span><span class="s3">\n  </span><span class="s1">// to our desired column.</span><span class="s3">\n  </span><span class="s1">const matchedColumn = bsFound ? column : segments[min][COLUMN];</span><span class="s3">\n\n  </span><span class="s1">// The binary search is not guaranteed to find the lower bound when a match wasn't found.</span><span class="s3">\n  </span><span class="s1">if (!bsFound) min = lowerBound(segments, matchedColumn, min);</span><span class="s3">\n  </span><span class="s1">const max = upperBound(segments, matchedColumn, min);</span><span class="s3">\n\n  </span><span class="s1">const result = [];</span><span class="s3">\n  </span><span class="s1">for (; min &lt;= max; min++) {</span><span class="s3">\n    </span><span class="s1">const segment = segments[min];</span><span class="s3">\n    </span><span class="s1">result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;bsFound&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>