<html>
<head>
<title>v3-generated.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #7a7e85;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
.s7 { color: #67a37c; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
v3-generated.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">declare type ASTModifiers </span><span class="s1">= {</span>
    <span class="s1">[</span><span class="s0">key</span><span class="s1">: </span><span class="s0">string</span><span class="s1">]: </span><span class="s0">boolean</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s0">declare type AsyncComponentFactory </span><span class="s1">= () =&gt; {</span>
    <span class="s0">component</span><span class="s1">: </span><span class="s0">Promise</span><span class="s1">&lt;</span><span class="s0">any</span><span class="s1">&gt;;</span>
    <span class="s0">loading</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">;</span>
    <span class="s0">error</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">;</span>
    <span class="s0">delay</span><span class="s1">?: </span><span class="s0">number</span><span class="s1">;</span>
    <span class="s0">timeout</span><span class="s1">?: </span><span class="s0">number</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s0">declare </span><span class="s2">interface </span><span class="s0">AsyncComponentOptions </span><span class="s1">{</span>
    <span class="s0">loader</span><span class="s1">: </span><span class="s0">Function</span><span class="s1">;</span>
    <span class="s0">loadingComponent</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">;</span>
    <span class="s0">errorComponent</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">;</span>
    <span class="s0">delay</span><span class="s1">?: </span><span class="s0">number</span><span class="s1">;</span>
    <span class="s0">timeout</span><span class="s1">?: </span><span class="s0">number</span><span class="s1">;</span>
    <span class="s0">suspensible</span><span class="s1">?: </span><span class="s0">boolean</span><span class="s1">;</span>
    <span class="s0">onError</span><span class="s1">?: (</span><span class="s0">error</span><span class="s1">: </span><span class="s0">Error</span><span class="s1">, </span><span class="s0">retry</span><span class="s1">: () =&gt; </span><span class="s2">void</span><span class="s1">, </span><span class="s0">fail</span><span class="s1">: () =&gt; </span><span class="s2">void</span><span class="s1">, </span><span class="s0">attempts</span><span class="s1">: </span><span class="s0">number</span><span class="s1">) =&gt; </span><span class="s0">any</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">declare type BaseTypes </span><span class="s1">= </span><span class="s0">string </span><span class="s1">| </span><span class="s0">number </span><span class="s1">| </span><span class="s0">boolean</span><span class="s1">;</span>

<span class="s0">declare type Builtin </span><span class="s1">= </span><span class="s0">Primitive </span><span class="s1">| </span><span class="s0">Function </span><span class="s1">| </span><span class="s0">Date </span><span class="s1">| </span><span class="s0">Error </span><span class="s1">| </span><span class="s0">RegExp</span><span class="s1">;</span>

<span class="s0">declare type CollectionTypes </span><span class="s1">= </span><span class="s0">IterableCollections </span><span class="s1">| </span><span class="s0">WeakCollections</span><span class="s1">;</span>

<span class="s3">/* Excluded from this release type: Component */</span>

<span class="s3">/* Excluded from this release type: ComponentOptions */</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">computed</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s0">getter</span><span class="s1">: </span><span class="s0">ComputedGetter</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;, </span><span class="s0">debugOptions</span><span class="s1">?: </span><span class="s0">DebuggerOptions</span><span class="s1">): </span><span class="s0">ComputedRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">computed</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s0">options</span><span class="s1">: </span><span class="s0">WritableComputedOptions</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;, </span><span class="s0">debugOptions</span><span class="s1">?: </span><span class="s0">DebuggerOptions</span><span class="s1">): </span><span class="s0">WritableComputedRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;;</span>

<span class="s2">export </span><span class="s0">declare type ComputedGetter</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; = (</span><span class="s0">...args</span><span class="s1">: </span><span class="s0">any</span><span class="s1">[]) =&gt; </span><span class="s0">T</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">interface </span><span class="s0">ComputedRef</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s1">= </span><span class="s0">any</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s0">WritableComputedRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; {</span>
    <span class="s0">readonly value</span><span class="s1">: </span><span class="s0">T</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s0">ComputedRefSymbol</span><span class="s1">]: </span><span class="s2">true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">declare </span><span class="s2">const </span><span class="s0">ComputedRefSymbol</span><span class="s1">: </span><span class="s0">unique symbol</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare type ComputedSetter</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; = (</span><span class="s0">v</span><span class="s1">: </span><span class="s0">T</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>

<span class="s3">/* Excluded from this release type: Config */</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">customRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s0">factory</span><span class="s1">: </span><span class="s0">CustomRefFactory</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;): </span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;;</span>

<span class="s2">export </span><span class="s0">declare type CustomRefFactory</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; = (</span><span class="s0">track</span><span class="s1">: () =&gt; </span><span class="s2">void</span><span class="s1">, </span><span class="s0">trigger</span><span class="s1">: () =&gt; </span><span class="s2">void</span><span class="s1">) =&gt; {</span>
    <span class="s0">get</span><span class="s1">: () =&gt; </span><span class="s0">T</span><span class="s1">;</span>
    <span class="s0">set</span><span class="s1">: (</span><span class="s0">value</span><span class="s1">: </span><span class="s0">T</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s2">export </span><span class="s0">declare type DebuggerEvent </span><span class="s1">= {</span>
    <span class="s3">/* Excluded from this release type: effect */</span>
<span class="s1">} &amp; </span><span class="s0">DebuggerEventExtraInfo</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare type DebuggerEventExtraInfo </span><span class="s1">= {</span>
    <span class="s0">target</span><span class="s1">: </span><span class="s0">object</span><span class="s1">;</span>
    <span class="s0">type</span><span class="s1">: </span><span class="s0">TrackOpTypes </span><span class="s1">| </span><span class="s0">TriggerOpTypes</span><span class="s1">;</span>
    <span class="s0">key</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">;</span>
    <span class="s0">newValue</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">;</span>
    <span class="s0">oldValue</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">interface </span><span class="s0">DebuggerOptions </span><span class="s1">{</span>
    <span class="s0">onTrack</span><span class="s1">?: (</span><span class="s0">event</span><span class="s1">: </span><span class="s0">DebuggerEvent</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">onTrigger</span><span class="s1">?: (</span><span class="s0">event</span><span class="s1">: </span><span class="s0">DebuggerEvent</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">export </span><span class="s0">declare type DeepReadonly</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; = </span><span class="s0">T </span><span class="s2">extends </span><span class="s0">Builtin </span><span class="s1">? </span><span class="s0">T </span><span class="s1">: </span><span class="s0">T </span><span class="s2">extends </span><span class="s0">Map</span><span class="s1">&lt;</span><span class="s0">infer K</span><span class="s1">, </span><span class="s0">infer V</span><span class="s1">&gt; ? </span><span class="s0">ReadonlyMap</span><span class="s1">&lt;</span><span class="s0">DeepReadonly</span><span class="s1">&lt;</span><span class="s0">K</span><span class="s1">&gt;, </span><span class="s0">DeepReadonly</span><span class="s1">&lt;</span><span class="s0">V</span><span class="s1">&gt;&gt; : </span><span class="s0">T </span><span class="s2">extends </span><span class="s0">ReadonlyMap</span><span class="s1">&lt;</span><span class="s0">infer K</span><span class="s1">, </span><span class="s0">infer V</span><span class="s1">&gt; ? </span><span class="s0">ReadonlyMap</span><span class="s1">&lt;</span><span class="s0">DeepReadonly</span><span class="s1">&lt;</span><span class="s0">K</span><span class="s1">&gt;, </span><span class="s0">DeepReadonly</span><span class="s1">&lt;</span><span class="s0">V</span><span class="s1">&gt;&gt; : </span><span class="s0">T </span><span class="s2">extends </span><span class="s0">WeakMap</span><span class="s1">&lt;</span><span class="s0">infer K</span><span class="s1">, </span><span class="s0">infer V</span><span class="s1">&gt; ? </span><span class="s0">WeakMap</span><span class="s1">&lt;</span><span class="s0">DeepReadonly</span><span class="s1">&lt;</span><span class="s0">K</span><span class="s1">&gt;, </span><span class="s0">DeepReadonly</span><span class="s1">&lt;</span><span class="s0">V</span><span class="s1">&gt;&gt; : </span><span class="s0">T </span><span class="s2">extends </span><span class="s0">Set</span><span class="s1">&lt;</span><span class="s0">infer U</span><span class="s1">&gt; ? </span><span class="s0">ReadonlySet</span><span class="s1">&lt;</span><span class="s0">DeepReadonly</span><span class="s1">&lt;</span><span class="s0">U</span><span class="s1">&gt;&gt; : </span><span class="s0">T </span><span class="s2">extends </span><span class="s0">ReadonlySet</span><span class="s1">&lt;</span><span class="s0">infer U</span><span class="s1">&gt; ? </span><span class="s0">ReadonlySet</span><span class="s1">&lt;</span><span class="s0">DeepReadonly</span><span class="s1">&lt;</span><span class="s0">U</span><span class="s1">&gt;&gt; : </span><span class="s0">T </span><span class="s2">extends </span><span class="s0">WeakSet</span><span class="s1">&lt;</span><span class="s0">infer U</span><span class="s1">&gt; ? </span><span class="s0">WeakSet</span><span class="s1">&lt;</span><span class="s0">DeepReadonly</span><span class="s1">&lt;</span><span class="s0">U</span><span class="s1">&gt;&gt; : </span><span class="s0">T </span><span class="s2">extends </span><span class="s0">Promise</span><span class="s1">&lt;</span><span class="s0">infer U</span><span class="s1">&gt; ? </span><span class="s0">Promise</span><span class="s1">&lt;</span><span class="s0">DeepReadonly</span><span class="s1">&lt;</span><span class="s0">U</span><span class="s1">&gt;&gt; : </span><span class="s0">T </span><span class="s2">extends </span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">infer U</span><span class="s1">&gt; ? </span><span class="s0">Readonly</span><span class="s1">&lt;</span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">DeepReadonly</span><span class="s1">&lt;</span><span class="s0">U</span><span class="s1">&gt;&gt;&gt; : </span><span class="s0">T </span><span class="s2">extends </span><span class="s1">{} ? {</span>
    <span class="s0">readonly </span><span class="s1">[</span><span class="s0">K </span><span class="s2">in </span><span class="s0">keyof T</span><span class="s1">]: </span><span class="s0">DeepReadonly</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">[</span><span class="s0">K</span><span class="s1">]&gt;;</span>
<span class="s1">} : </span><span class="s0">Readonly</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;;</span>

<span class="s3">/* Excluded from this release type: defineAsyncComponent */</span>

<span class="s3">/* Excluded from this release type: defineComponent */</span>

<span class="s4">/**</span>
 <span class="s4">* Delete a property and trigger change if necessary.</span>
 <span class="s4">*/</span>
<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">del</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s0">array</span><span class="s1">: </span><span class="s0">T</span><span class="s1">[], </span><span class="s0">key</span><span class="s1">: </span><span class="s0">number</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">del</span><span class="s1">(</span><span class="s0">object</span><span class="s1">: </span><span class="s0">object</span><span class="s1">, </span><span class="s0">key</span><span class="s1">: </span><span class="s0">string </span><span class="s1">| </span><span class="s0">number</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>

<span class="s3">/* Excluded from this release type: Dep */</span>

<span class="s3">/* Excluded from this release type: DepTarget */</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">class </span><span class="s0">EffectScope </span><span class="s1">{</span>
    <span class="s0">detached</span><span class="s1">: </span><span class="s0">boolean</span><span class="s1">;</span>
    <span class="s3">/* Excluded from this release type: active */</span>
    <span class="s3">/* Excluded from this release type: effects */</span>
    <span class="s3">/* Excluded from this release type: cleanups */</span>
    <span class="s3">/* Excluded from this release type: parent */</span>
    <span class="s3">/* Excluded from this release type: scopes */</span>
    <span class="s3">/* Excluded from this release type: _vm */</span>
    <span class="s4">/**</span>
     <span class="s4">* track a child scope's index in its parent's scopes array for optimized</span>
     <span class="s4">* removal</span>
     <span class="s4">*/</span>
    <span class="s2">private </span><span class="s0">index</span><span class="s1">;</span>
    <span class="s0">constructor</span><span class="s1">(</span><span class="s0">detached</span><span class="s1">?: </span><span class="s0">boolean</span><span class="s1">);</span>
    <span class="s0">run</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s0">fn</span><span class="s1">: () =&gt; </span><span class="s0">T</span><span class="s1">): </span><span class="s0">T </span><span class="s1">| </span><span class="s0">undefined</span><span class="s1">;</span>
    <span class="s3">/* Excluded from this release type: on */</span>
    <span class="s3">/* Excluded from this release type: off */</span>
    <span class="s0">stop</span><span class="s1">(</span><span class="s0">fromParent</span><span class="s1">?: </span><span class="s0">boolean</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">effectScope</span><span class="s1">(</span><span class="s0">detached</span><span class="s1">?: </span><span class="s0">boolean</span><span class="s1">): </span><span class="s0">EffectScope</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare type ErrorCapturedHook</span><span class="s1">&lt;</span><span class="s0">TError </span><span class="s1">= </span><span class="s0">unknown</span><span class="s1">&gt; = (</span><span class="s0">err</span><span class="s1">: </span><span class="s0">TError</span><span class="s1">, </span><span class="s0">instance</span><span class="s1">: </span><span class="s0">any</span><span class="s1">, </span><span class="s0">info</span><span class="s1">: </span><span class="s0">string</span><span class="s1">) =&gt; </span><span class="s0">boolean </span><span class="s1">| </span><span class="s2">void</span><span class="s1">;</span>

<span class="s3">/* Excluded from this release type: getCurrentInstance */</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">getCurrentScope</span><span class="s1">(): </span><span class="s0">EffectScope </span><span class="s1">| </span><span class="s0">undefined</span><span class="s1">;</span>

<span class="s3">/* Excluded from this release type: GlobalAPI */</span>

<span class="s3">/* Excluded from this release type: h */</span>

<span class="s0">declare type IfAny</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">, </span><span class="s0">Y</span><span class="s1">, </span><span class="s0">N</span><span class="s1">&gt; = </span><span class="s5">0 </span><span class="s2">extends </span><span class="s5">1 </span><span class="s1">&amp; </span><span class="s0">T </span><span class="s1">? </span><span class="s0">Y </span><span class="s1">: </span><span class="s0">N</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">inject</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s0">key</span><span class="s1">: </span><span class="s0">InjectionKey</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; | </span><span class="s0">string</span><span class="s1">): </span><span class="s0">T </span><span class="s1">| </span><span class="s0">undefined</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">inject</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s0">key</span><span class="s1">: </span><span class="s0">InjectionKey</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; | </span><span class="s0">string</span><span class="s1">, </span><span class="s0">defaultValue</span><span class="s1">: </span><span class="s0">T</span><span class="s1">, </span><span class="s0">treatDefaultAsFactory</span><span class="s1">?: </span><span class="s2">false</span><span class="s1">): </span><span class="s0">T</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">inject</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s0">key</span><span class="s1">: </span><span class="s0">InjectionKey</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; | </span><span class="s0">string</span><span class="s1">, </span><span class="s0">defaultValue</span><span class="s1">: </span><span class="s0">T </span><span class="s1">| (() =&gt; </span><span class="s0">T</span><span class="s1">), </span><span class="s0">treatDefaultAsFactory</span><span class="s1">: </span><span class="s2">true</span><span class="s1">): </span><span class="s0">T</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">interface </span><span class="s0">InjectionKey</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s0">Symbol </span><span class="s1">{</span>
<span class="s1">}</span>

<span class="s0">declare type InjectKey </span><span class="s1">= </span><span class="s0">string </span><span class="s1">| </span><span class="s0">Symbol</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">isProxy</span><span class="s1">(</span><span class="s0">value</span><span class="s1">: </span><span class="s0">unknown</span><span class="s1">): </span><span class="s0">boolean</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">isReactive</span><span class="s1">(</span><span class="s0">value</span><span class="s1">: </span><span class="s0">unknown</span><span class="s1">): </span><span class="s0">boolean</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">isReadonly</span><span class="s1">(</span><span class="s0">value</span><span class="s1">: </span><span class="s0">unknown</span><span class="s1">): </span><span class="s0">boolean</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">isRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s0">r</span><span class="s1">: </span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; | </span><span class="s0">unknown</span><span class="s1">): </span><span class="s0">r </span><span class="s1">is </span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">isShallow</span><span class="s1">(</span><span class="s0">value</span><span class="s1">: </span><span class="s0">unknown</span><span class="s1">): </span><span class="s0">boolean</span><span class="s1">;</span>

<span class="s0">declare type IterableCollections </span><span class="s1">= </span><span class="s0">Map</span><span class="s1">&lt;</span><span class="s0">any</span><span class="s1">, </span><span class="s0">any</span><span class="s1">&gt; | </span><span class="s0">Set</span><span class="s1">&lt;</span><span class="s0">any</span><span class="s1">&gt;;</span>

<span class="s0">declare type MapSources</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">, </span><span class="s0">Immediate</span><span class="s1">&gt; = {</span>
    <span class="s1">[</span><span class="s0">K </span><span class="s2">in </span><span class="s0">keyof T</span><span class="s1">]: </span><span class="s0">T</span><span class="s1">[</span><span class="s0">K</span><span class="s1">] </span><span class="s2">extends </span><span class="s0">WatchSource</span><span class="s1">&lt;</span><span class="s0">infer V</span><span class="s1">&gt; ? </span><span class="s0">Immediate </span><span class="s2">extends true </span><span class="s1">? </span><span class="s0">V </span><span class="s1">| </span><span class="s0">undefined </span><span class="s1">: </span><span class="s0">V </span><span class="s1">: </span><span class="s0">T</span><span class="s1">[</span><span class="s0">K</span><span class="s1">] </span><span class="s2">extends </span><span class="s0">object </span><span class="s1">? </span><span class="s0">Immediate </span><span class="s2">extends true </span><span class="s1">? </span><span class="s0">T</span><span class="s1">[</span><span class="s0">K</span><span class="s1">] | </span><span class="s0">undefined </span><span class="s1">: </span><span class="s0">T</span><span class="s1">[</span><span class="s0">K</span><span class="s1">] : </span><span class="s0">never</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">markRaw</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s2">extends </span><span class="s0">object</span><span class="s1">&gt;(</span><span class="s0">value</span><span class="s1">: </span><span class="s0">T</span><span class="s1">): </span><span class="s0">T </span><span class="s1">&amp; {</span>
    <span class="s1">[</span><span class="s0">RawSymbol</span><span class="s1">]?: </span><span class="s2">true</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s3">/* Excluded from this release type: mergeDefaults */</span>

<span class="s0">declare type MultiWatchSources </span><span class="s1">= (</span><span class="s0">WatchSource</span><span class="s1">&lt;</span><span class="s0">unknown</span><span class="s1">&gt; | </span><span class="s0">object</span><span class="s1">)[];</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">nextTick</span><span class="s1">(): </span><span class="s0">Promise</span><span class="s1">&lt;</span><span class="s2">void</span><span class="s1">&gt;;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">nextTick</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s2">this</span><span class="s1">: </span><span class="s0">T</span><span class="s1">, </span><span class="s0">cb</span><span class="s1">: (</span><span class="s2">this</span><span class="s1">: </span><span class="s0">T</span><span class="s1">, </span><span class="s0">...args</span><span class="s1">: </span><span class="s0">any</span><span class="s1">[]) =&gt; </span><span class="s0">any</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">nextTick</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s0">cb</span><span class="s1">: (</span><span class="s2">this</span><span class="s1">: </span><span class="s0">T</span><span class="s1">, </span><span class="s0">...args</span><span class="s1">: </span><span class="s0">any</span><span class="s1">[]) =&gt; </span><span class="s0">any</span><span class="s1">, </span><span class="s0">ctx</span><span class="s1">: </span><span class="s0">T</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">const </span><span class="s0">onActivated</span><span class="s1">: (</span><span class="s0">fn</span><span class="s1">: () =&gt; </span><span class="s2">void</span><span class="s1">, </span><span class="s0">target</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">const </span><span class="s0">onBeforeMount</span><span class="s1">: (</span><span class="s0">fn</span><span class="s1">: () =&gt; </span><span class="s2">void</span><span class="s1">, </span><span class="s0">target</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">const </span><span class="s0">onBeforeUnmount</span><span class="s1">: (</span><span class="s0">fn</span><span class="s1">: () =&gt; </span><span class="s2">void</span><span class="s1">, </span><span class="s0">target</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">const </span><span class="s0">onBeforeUpdate</span><span class="s1">: (</span><span class="s0">fn</span><span class="s1">: () =&gt; </span><span class="s2">void</span><span class="s1">, </span><span class="s0">target</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>

<span class="s0">declare type OnCleanup </span><span class="s1">= (</span><span class="s0">cleanupFn</span><span class="s1">: () =&gt; </span><span class="s2">void</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">const </span><span class="s0">onDeactivated</span><span class="s1">: (</span><span class="s0">fn</span><span class="s1">: () =&gt; </span><span class="s2">void</span><span class="s1">, </span><span class="s0">target</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">onErrorCaptured</span><span class="s1">&lt;</span><span class="s0">TError </span><span class="s1">= </span><span class="s0">Error</span><span class="s1">&gt;(</span><span class="s0">hook</span><span class="s1">: </span><span class="s0">ErrorCapturedHook</span><span class="s1">&lt;</span><span class="s0">TError</span><span class="s1">&gt;, </span><span class="s0">target</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">const </span><span class="s0">onMounted</span><span class="s1">: (</span><span class="s0">fn</span><span class="s1">: () =&gt; </span><span class="s2">void</span><span class="s1">, </span><span class="s0">target</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">const </span><span class="s0">onRenderTracked</span><span class="s1">: (</span><span class="s0">fn</span><span class="s1">: (</span><span class="s0">e</span><span class="s1">: </span><span class="s0">DebuggerEvent</span><span class="s1">) =&gt; </span><span class="s0">any</span><span class="s1">, </span><span class="s0">target</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">const </span><span class="s0">onRenderTriggered</span><span class="s1">: (</span><span class="s0">fn</span><span class="s1">: (</span><span class="s0">e</span><span class="s1">: </span><span class="s0">DebuggerEvent</span><span class="s1">) =&gt; </span><span class="s0">any</span><span class="s1">, </span><span class="s0">target</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">onScopeDispose</span><span class="s1">(</span><span class="s0">fn</span><span class="s1">: () =&gt; </span><span class="s2">void</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">const </span><span class="s0">onServerPrefetch</span><span class="s1">: (</span><span class="s0">fn</span><span class="s1">: () =&gt; </span><span class="s2">void</span><span class="s1">, </span><span class="s0">target</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">const </span><span class="s0">onUnmounted</span><span class="s1">: (</span><span class="s0">fn</span><span class="s1">: () =&gt; </span><span class="s2">void</span><span class="s1">, </span><span class="s0">target</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">const </span><span class="s0">onUpdated</span><span class="s1">: (</span><span class="s0">fn</span><span class="s1">: () =&gt; </span><span class="s2">void</span><span class="s1">, </span><span class="s0">target</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>

<span class="s0">declare type Primitive </span><span class="s1">= </span><span class="s0">string </span><span class="s1">| </span><span class="s0">number </span><span class="s1">| </span><span class="s0">boolean </span><span class="s1">| </span><span class="s0">bigint </span><span class="s1">| </span><span class="s0">symbol </span><span class="s1">| </span><span class="s0">undefined </span><span class="s1">| </span><span class="s2">null</span><span class="s1">;</span>

<span class="s0">declare type PropOptions </span><span class="s1">= {</span>
    <span class="s0">type</span><span class="s1">?: </span><span class="s0">Function </span><span class="s1">| </span><span class="s0">Array</span><span class="s1">&lt;</span><span class="s0">Function</span><span class="s1">&gt; | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">default</span><span class="s1">?: </span><span class="s0">any</span><span class="s1">;</span>
    <span class="s0">required</span><span class="s1">?: </span><span class="s0">boolean </span><span class="s1">| </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s0">validator</span><span class="s1">?: </span><span class="s0">Function </span><span class="s1">| </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">provide</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s0">key</span><span class="s1">: </span><span class="s0">InjectionKey</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; | </span><span class="s0">string </span><span class="s1">| </span><span class="s0">number</span><span class="s1">, </span><span class="s0">value</span><span class="s1">: </span><span class="s0">T</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">proxyRefs</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s2">extends </span><span class="s0">object</span><span class="s1">&gt;(</span><span class="s0">objectWithRefs</span><span class="s1">: </span><span class="s0">T</span><span class="s1">): </span><span class="s0">ShallowUnwrapRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;;</span>

<span class="s0">declare </span><span class="s2">const </span><span class="s0">RawSymbol</span><span class="s1">: </span><span class="s0">unique symbol</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">reactive</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s2">extends </span><span class="s0">object</span><span class="s1">&gt;(</span><span class="s0">target</span><span class="s1">: </span><span class="s0">T</span><span class="s1">): </span><span class="s0">UnwrapNestedRefs</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">const enum </span><span class="s0">ReactiveFlags </span><span class="s1">{</span>
    <span class="s0">SKIP </span><span class="s1">= </span><span class="s6">&quot;__v_skip&quot;</span><span class="s1">,</span>
    <span class="s0">IS_READONLY </span><span class="s1">= </span><span class="s6">&quot;__v_isReadonly&quot;</span><span class="s1">,</span>
    <span class="s0">IS_SHALLOW </span><span class="s1">= </span><span class="s6">&quot;__v_isShallow&quot;</span><span class="s1">,</span>
    <span class="s0">RAW </span><span class="s1">= </span><span class="s6">&quot;__v_raw&quot;</span>
<span class="s1">}</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">readonly</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s2">extends </span><span class="s0">object</span><span class="s1">&gt;(</span><span class="s0">target</span><span class="s1">: </span><span class="s0">T</span><span class="s1">): </span><span class="s0">DeepReadonly</span><span class="s1">&lt;</span><span class="s0">UnwrapNestedRefs</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;&gt;;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">interface </span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s1">= </span><span class="s0">any</span><span class="s1">&gt; {</span>
    <span class="s0">value</span><span class="s1">: </span><span class="s0">T</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Type differentiator only.</span>
     <span class="s4">* We need this to be in public d.ts but don't want it to show up in IDE</span>
     <span class="s4">* autocomplete, so we use a private Symbol instead.</span>
     <span class="s4">*/</span>
    <span class="s1">[</span><span class="s0">RefSymbol</span><span class="s1">]: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s3">/* Excluded from this release type: dep */</span>
    <span class="s3">/* Excluded from this release type: __v_isRef */</span>
<span class="s1">}</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">ref</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s2">extends </span><span class="s0">object</span><span class="s1">&gt;(</span><span class="s0">value</span><span class="s1">: </span><span class="s0">T</span><span class="s1">): [</span><span class="s0">T</span><span class="s1">] </span><span class="s2">extends </span><span class="s1">[</span><span class="s0">Ref</span><span class="s1">] ? </span><span class="s0">T </span><span class="s1">: </span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">UnwrapRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;&gt;;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">ref</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s0">value</span><span class="s1">: </span><span class="s0">T</span><span class="s1">): </span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">UnwrapRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;&gt;;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">ref</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s1">= </span><span class="s0">any</span><span class="s1">&gt;(): </span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s1">| </span><span class="s0">undefined</span><span class="s1">&gt;;</span>

<span class="s3">/* Excluded from this release type: RefFlag */</span>

<span class="s0">declare </span><span class="s2">const </span><span class="s0">RefSymbol</span><span class="s1">: </span><span class="s0">unique symbol</span><span class="s1">;</span>

<span class="s4">/**</span>
 <span class="s4">* This is a special exported interface for other packages to declare</span>
 <span class="s4">* additional types that should bail out for ref unwrapping. For example</span>
 <span class="s4">* \@vue/runtime-dom can declare it like so in its d.ts:</span>
 <span class="s4">*</span>
 <span class="s4">* ``` ts</span>
 <span class="s4">* declare module 'vue' {</span>
 <span class="s4">*   export interface RefUnwrapBailTypes {</span>
 <span class="s4">*     runtimeDOMBailTypes: Node | Window</span>
 <span class="s4">*   }</span>
 <span class="s4">* }</span>
 <span class="s4">* ```</span>
 <span class="s4">*</span>
 <span class="s4">* Note that api-extractor somehow refuses to include `declare module`</span>
 <span class="s4">* augmentations in its generated d.ts, so we have to manually append them</span>
 <span class="s4">* to the final generated d.ts in our build process.</span>
 <span class="s4">*/</span>
<span class="s2">export </span><span class="s0">declare </span><span class="s2">interface </span><span class="s0">RefUnwrapBailTypes </span><span class="s1">{</span>
    <span class="s0">runtimeDOMBailTypes</span><span class="s1">: </span><span class="s0">Node </span><span class="s1">| </span><span class="s0">Window</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">/* Excluded from this release type: ScopedSlotsData */</span>

<span class="s4">/**</span>
 <span class="s4">* Set a property on an object. Adds the new property and</span>
 <span class="s4">* triggers change notification if the property doesn't</span>
 <span class="s4">* already exist.</span>
 <span class="s4">*/</span>
<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">set</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s0">array</span><span class="s1">: </span><span class="s0">T</span><span class="s1">[], </span><span class="s0">key</span><span class="s1">: </span><span class="s0">number</span><span class="s1">, </span><span class="s0">value</span><span class="s1">: </span><span class="s0">T</span><span class="s1">): </span><span class="s0">T</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">set</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s0">object</span><span class="s1">: </span><span class="s0">object</span><span class="s1">, </span><span class="s0">key</span><span class="s1">: </span><span class="s0">string </span><span class="s1">| </span><span class="s0">number</span><span class="s1">, </span><span class="s0">value</span><span class="s1">: </span><span class="s0">T</span><span class="s1">): </span><span class="s0">T</span><span class="s1">;</span>

<span class="s3">/* Excluded from this release type: SetupContext */</span>

<span class="s2">export </span><span class="s0">declare type ShallowReactive</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; = </span><span class="s0">T </span><span class="s1">&amp; {</span>
    <span class="s1">[</span><span class="s0">ShallowReactiveMarker</span><span class="s1">]?: </span><span class="s2">true</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s4">/**</span>
 <span class="s4">* Return a shallowly-reactive copy of the original object, where only the root</span>
 <span class="s4">* level properties are reactive. It also does not auto-unwrap refs (even at the</span>
 <span class="s4">* root level).</span>
 <span class="s4">*/</span>
<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">shallowReactive</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s2">extends </span><span class="s0">object</span><span class="s1">&gt;(</span><span class="s0">target</span><span class="s1">: </span><span class="s0">T</span><span class="s1">): </span><span class="s0">ShallowReactive</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;;</span>

<span class="s0">declare </span><span class="s2">const </span><span class="s0">ShallowReactiveMarker</span><span class="s1">: </span><span class="s0">unique symbol</span><span class="s1">;</span>

<span class="s4">/**</span>
 <span class="s4">* Returns a reactive-copy of the original object, where only the root level</span>
 <span class="s4">* properties are readonly, and does NOT unwrap refs nor recursively convert</span>
 <span class="s4">* returned properties.</span>
 <span class="s4">* This is used for creating the props proxy object for stateful components.</span>
 <span class="s4">*/</span>
<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">shallowReadonly</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s2">extends </span><span class="s0">object</span><span class="s1">&gt;(</span><span class="s0">target</span><span class="s1">: </span><span class="s0">T</span><span class="s1">): </span><span class="s0">Readonly</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;;</span>

<span class="s2">export </span><span class="s0">declare type ShallowRef</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s1">= </span><span class="s0">any</span><span class="s1">&gt; = </span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; &amp; {</span>
    <span class="s1">[</span><span class="s0">ShallowRefMarker</span><span class="s1">]?: </span><span class="s2">true</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">shallowRef</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s2">extends </span><span class="s0">object</span><span class="s1">&gt;(</span><span class="s0">value</span><span class="s1">: </span><span class="s0">T</span><span class="s1">): </span><span class="s0">T </span><span class="s2">extends </span><span class="s0">Ref </span><span class="s1">? </span><span class="s0">T </span><span class="s1">: </span><span class="s0">ShallowRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">shallowRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s0">value</span><span class="s1">: </span><span class="s0">T</span><span class="s1">): </span><span class="s0">ShallowRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">shallowRef</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s1">= </span><span class="s0">any</span><span class="s1">&gt;(): </span><span class="s0">ShallowRef</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s1">| </span><span class="s0">undefined</span><span class="s1">&gt;;</span>

<span class="s0">declare </span><span class="s2">const </span><span class="s0">ShallowRefMarker</span><span class="s1">: </span><span class="s0">unique symbol</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare type ShallowUnwrapRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; = {</span>
    <span class="s1">[</span><span class="s0">K </span><span class="s2">in </span><span class="s0">keyof T</span><span class="s1">]: </span><span class="s0">T</span><span class="s1">[</span><span class="s0">K</span><span class="s1">] </span><span class="s2">extends </span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">infer V</span><span class="s1">&gt; ? </span><span class="s0">V </span><span class="s1">: </span><span class="s0">T</span><span class="s1">[</span><span class="s0">K</span><span class="s1">] </span><span class="s2">extends </span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">infer V</span><span class="s1">&gt; | </span><span class="s0">undefined </span><span class="s1">? </span><span class="s0">unknown </span><span class="s2">extends </span><span class="s0">V </span><span class="s1">? </span><span class="s0">undefined </span><span class="s1">: </span><span class="s0">V </span><span class="s1">| </span><span class="s0">undefined </span><span class="s1">: </span><span class="s0">T</span><span class="s1">[</span><span class="s0">K</span><span class="s1">];</span>
<span class="s1">};</span>

<span class="s0">declare </span><span class="s2">interface </span><span class="s0">SimpleSet </span><span class="s1">{</span>
    <span class="s0">has</span><span class="s1">(</span><span class="s0">key</span><span class="s1">: </span><span class="s0">string </span><span class="s1">| </span><span class="s0">number</span><span class="s1">): </span><span class="s0">boolean</span><span class="s1">;</span>
    <span class="s0">add</span><span class="s1">(</span><span class="s0">key</span><span class="s1">: </span><span class="s0">string </span><span class="s1">| </span><span class="s0">number</span><span class="s1">): </span><span class="s0">any</span><span class="s1">;</span>
    <span class="s0">clear</span><span class="s1">(): </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">toRaw</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s0">observed</span><span class="s1">: </span><span class="s0">T</span><span class="s1">): </span><span class="s0">T</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare type ToRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; = </span><span class="s0">IfAny</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">, </span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;, [</span><span class="s0">T</span><span class="s1">] </span><span class="s2">extends </span><span class="s1">[</span><span class="s0">Ref</span><span class="s1">] ? </span><span class="s0">T </span><span class="s1">: </span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;&gt;;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">toRef</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s2">extends </span><span class="s0">object</span><span class="s1">, </span><span class="s0">K </span><span class="s2">extends </span><span class="s0">keyof T</span><span class="s1">&gt;(</span><span class="s0">object</span><span class="s1">: </span><span class="s0">T</span><span class="s1">, </span><span class="s0">key</span><span class="s1">: </span><span class="s0">K</span><span class="s1">): </span><span class="s0">ToRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">[</span><span class="s0">K</span><span class="s1">]&gt;;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">toRef</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s2">extends </span><span class="s0">object</span><span class="s1">, </span><span class="s0">K </span><span class="s2">extends </span><span class="s0">keyof T</span><span class="s1">&gt;(</span><span class="s0">object</span><span class="s1">: </span><span class="s0">T</span><span class="s1">, </span><span class="s0">key</span><span class="s1">: </span><span class="s0">K</span><span class="s1">, </span><span class="s0">defaultValue</span><span class="s1">: </span><span class="s0">T</span><span class="s1">[</span><span class="s0">K</span><span class="s1">]): </span><span class="s0">ToRef</span><span class="s1">&lt;</span><span class="s0">Exclude</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">[</span><span class="s0">K</span><span class="s1">], </span><span class="s0">undefined</span><span class="s1">&gt;&gt;;</span>

<span class="s2">export </span><span class="s0">declare type ToRefs</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s1">= </span><span class="s0">any</span><span class="s1">&gt; = {</span>
    <span class="s1">[</span><span class="s0">K </span><span class="s2">in </span><span class="s0">keyof T</span><span class="s1">]: </span><span class="s0">ToRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">[</span><span class="s0">K</span><span class="s1">]&gt;;</span>
<span class="s1">};</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">toRefs</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s2">extends </span><span class="s0">object</span><span class="s1">&gt;(</span><span class="s0">object</span><span class="s1">: </span><span class="s0">T</span><span class="s1">): </span><span class="s0">ToRefs</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">const enum </span><span class="s0">TrackOpTypes </span><span class="s1">{</span>
    <span class="s0">GET </span><span class="s1">= </span><span class="s6">&quot;get&quot;</span><span class="s1">,</span>
    <span class="s0">TOUCH </span><span class="s1">= </span><span class="s6">&quot;touch&quot;</span>
<span class="s1">}</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">const enum </span><span class="s0">TriggerOpTypes </span><span class="s1">{</span>
    <span class="s0">SET </span><span class="s1">= </span><span class="s6">&quot;set&quot;</span><span class="s1">,</span>
    <span class="s0">ADD </span><span class="s1">= </span><span class="s6">&quot;add&quot;</span><span class="s1">,</span>
    <span class="s0">DELETE </span><span class="s1">= </span><span class="s6">&quot;delete&quot;</span><span class="s1">,</span>
    <span class="s0">ARRAY_MUTATION </span><span class="s1">= </span><span class="s6">&quot;array mutation&quot;</span>
<span class="s1">}</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">triggerRef</span><span class="s1">(</span><span class="s0">ref</span><span class="s1">: </span><span class="s0">Ref</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">unref</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;(</span><span class="s0">ref</span><span class="s1">: </span><span class="s0">T </span><span class="s1">| </span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;): </span><span class="s0">T</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare type UnwrapNestedRefs</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; = </span><span class="s0">T </span><span class="s2">extends </span><span class="s0">Ref </span><span class="s1">? </span><span class="s0">T </span><span class="s1">: </span><span class="s0">UnwrapRefSimple</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;;</span>

<span class="s2">export </span><span class="s0">declare type UnwrapRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; = </span><span class="s0">T </span><span class="s2">extends </span><span class="s0">ShallowRef</span><span class="s1">&lt;</span><span class="s0">infer V</span><span class="s1">&gt; ? </span><span class="s0">V </span><span class="s1">: </span><span class="s0">T </span><span class="s2">extends </span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">infer V</span><span class="s1">&gt; ? </span><span class="s0">UnwrapRefSimple</span><span class="s1">&lt;</span><span class="s0">V</span><span class="s1">&gt; : </span><span class="s0">UnwrapRefSimple</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;;</span>

<span class="s0">declare type UnwrapRefSimple</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; = </span><span class="s0">T </span><span class="s2">extends </span><span class="s0">Function </span><span class="s1">| </span><span class="s0">CollectionTypes </span><span class="s1">| </span><span class="s0">BaseTypes </span><span class="s1">| </span><span class="s0">Ref </span><span class="s1">| </span><span class="s0">RefUnwrapBailTypes</span><span class="s1">[</span><span class="s0">keyof RefUnwrapBailTypes</span><span class="s1">] | {</span>
    <span class="s1">[</span><span class="s0">RawSymbol</span><span class="s1">]?: </span><span class="s2">true</span><span class="s1">;</span>
<span class="s1">} ? </span><span class="s0">T </span><span class="s1">: </span><span class="s0">T </span><span class="s2">extends </span><span class="s0">Array</span><span class="s1">&lt;</span><span class="s0">any</span><span class="s1">&gt; ? {</span>
    <span class="s1">[</span><span class="s0">K </span><span class="s2">in </span><span class="s0">keyof T</span><span class="s1">]: </span><span class="s0">UnwrapRefSimple</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">[</span><span class="s0">K</span><span class="s1">]&gt;;</span>
<span class="s1">} : </span><span class="s0">T </span><span class="s2">extends </span><span class="s0">object </span><span class="s1">&amp; {</span>
    <span class="s1">[</span><span class="s0">ShallowReactiveMarker</span><span class="s1">]?: </span><span class="s0">never</span><span class="s1">;</span>
<span class="s1">} ? {</span>
    <span class="s1">[</span><span class="s0">P </span><span class="s2">in </span><span class="s0">keyof T</span><span class="s1">]: </span><span class="s0">P </span><span class="s2">extends </span><span class="s0">symbol </span><span class="s1">? </span><span class="s0">T</span><span class="s1">[</span><span class="s0">P</span><span class="s1">] : </span><span class="s0">UnwrapRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">[</span><span class="s0">P</span><span class="s1">]&gt;;</span>
<span class="s1">} : </span><span class="s0">T</span><span class="s1">;</span>

<span class="s3">/* Excluded from this release type: useAttrs */</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">useCssModule</span><span class="s1">(</span><span class="s0">name</span><span class="s1">?: </span><span class="s0">string</span><span class="s1">): </span><span class="s0">Record</span><span class="s1">&lt;</span><span class="s0">string</span><span class="s1">, </span><span class="s0">string</span><span class="s1">&gt;;</span>

<span class="s4">/**</span>
 <span class="s4">* Runtime helper for SFC's CSS variable injection feature.</span>
 <span class="s4">* </span><span class="s7">@private</span>
 <span class="s4">*/</span>
<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">useCssVars</span><span class="s1">(</span><span class="s0">getter</span><span class="s1">: (</span><span class="s0">vm</span><span class="s1">: </span><span class="s0">Record</span><span class="s1">&lt;</span><span class="s0">string</span><span class="s1">, </span><span class="s0">any</span><span class="s1">&gt;, </span><span class="s0">setupProxy</span><span class="s1">: </span><span class="s0">Record</span><span class="s1">&lt;</span><span class="s0">string</span><span class="s1">, </span><span class="s0">any</span><span class="s1">&gt;) =&gt; </span><span class="s0">Record</span><span class="s1">&lt;</span><span class="s0">string</span><span class="s1">, </span><span class="s0">string</span><span class="s1">&gt;): </span><span class="s2">void</span><span class="s1">;</span>

<span class="s3">/* Excluded from this release type: useListeners */</span>

<span class="s3">/* Excluded from this release type: useSlots */</span>

<span class="s4">/**</span>
 <span class="s4">* Note: also update dist/vue.runtime.mjs when adding new exports to this file.</span>
 <span class="s4">*/</span>
<span class="s2">export </span><span class="s0">declare </span><span class="s2">const </span><span class="s0">version</span><span class="s1">: </span><span class="s0">string</span><span class="s1">;</span>

<span class="s3">/* Excluded from this release type: VNode */</span>

<span class="s3">/* Excluded from this release type: VNodeChildren */</span>

<span class="s3">/* Excluded from this release type: VNodeComponentOptions */</span>

<span class="s3">/* Excluded from this release type: VNodeData */</span>

<span class="s3">/* Excluded from this release type: VNodeDirective */</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">watch</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s2">extends </span><span class="s0">MultiWatchSources</span><span class="s1">, </span><span class="s0">Immediate </span><span class="s2">extends </span><span class="s0">Readonly</span><span class="s1">&lt;</span><span class="s0">boolean</span><span class="s1">&gt; = </span><span class="s2">false</span><span class="s1">&gt;(</span><span class="s0">sources</span><span class="s1">: [</span><span class="s0">...T</span><span class="s1">], </span><span class="s0">cb</span><span class="s1">: </span><span class="s0">WatchCallback</span><span class="s1">&lt;</span><span class="s0">MapSources</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">, </span><span class="s2">false</span><span class="s1">&gt;, </span><span class="s0">MapSources</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">, </span><span class="s0">Immediate</span><span class="s1">&gt;&gt;, </span><span class="s0">options</span><span class="s1">?: </span><span class="s0">WatchOptions</span><span class="s1">&lt;</span><span class="s0">Immediate</span><span class="s1">&gt;): </span><span class="s0">WatchStopHandle</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">watch</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s2">extends </span><span class="s0">Readonly</span><span class="s1">&lt;</span><span class="s0">MultiWatchSources</span><span class="s1">&gt;, </span><span class="s0">Immediate </span><span class="s2">extends </span><span class="s0">Readonly</span><span class="s1">&lt;</span><span class="s0">boolean</span><span class="s1">&gt; = </span><span class="s2">false</span><span class="s1">&gt;(</span><span class="s0">source</span><span class="s1">: </span><span class="s0">T</span><span class="s1">, </span><span class="s0">cb</span><span class="s1">: </span><span class="s0">WatchCallback</span><span class="s1">&lt;</span><span class="s0">MapSources</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">, </span><span class="s2">false</span><span class="s1">&gt;, </span><span class="s0">MapSources</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">, </span><span class="s0">Immediate</span><span class="s1">&gt;&gt;, </span><span class="s0">options</span><span class="s1">?: </span><span class="s0">WatchOptions</span><span class="s1">&lt;</span><span class="s0">Immediate</span><span class="s1">&gt;): </span><span class="s0">WatchStopHandle</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">watch</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">, </span><span class="s0">Immediate </span><span class="s2">extends </span><span class="s0">Readonly</span><span class="s1">&lt;</span><span class="s0">boolean</span><span class="s1">&gt; = </span><span class="s2">false</span><span class="s1">&gt;(</span><span class="s0">source</span><span class="s1">: </span><span class="s0">WatchSource</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;, </span><span class="s0">cb</span><span class="s1">: </span><span class="s0">WatchCallback</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">, </span><span class="s0">Immediate </span><span class="s2">extends true </span><span class="s1">? </span><span class="s0">T </span><span class="s1">| </span><span class="s0">undefined </span><span class="s1">: </span><span class="s0">T</span><span class="s1">&gt;, </span><span class="s0">options</span><span class="s1">?: </span><span class="s0">WatchOptions</span><span class="s1">&lt;</span><span class="s0">Immediate</span><span class="s1">&gt;): </span><span class="s0">WatchStopHandle</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">watch</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s2">extends </span><span class="s0">object</span><span class="s1">, </span><span class="s0">Immediate </span><span class="s2">extends </span><span class="s0">Readonly</span><span class="s1">&lt;</span><span class="s0">boolean</span><span class="s1">&gt; = </span><span class="s2">false</span><span class="s1">&gt;(</span><span class="s0">source</span><span class="s1">: </span><span class="s0">T</span><span class="s1">, </span><span class="s0">cb</span><span class="s1">: </span><span class="s0">WatchCallback</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">, </span><span class="s0">Immediate </span><span class="s2">extends true </span><span class="s1">? </span><span class="s0">T </span><span class="s1">| </span><span class="s0">undefined </span><span class="s1">: </span><span class="s0">T</span><span class="s1">&gt;, </span><span class="s0">options</span><span class="s1">?: </span><span class="s0">WatchOptions</span><span class="s1">&lt;</span><span class="s0">Immediate</span><span class="s1">&gt;): </span><span class="s0">WatchStopHandle</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare type WatchCallback</span><span class="s1">&lt;</span><span class="s0">V </span><span class="s1">= </span><span class="s0">any</span><span class="s1">, </span><span class="s0">OV </span><span class="s1">= </span><span class="s0">any</span><span class="s1">&gt; = (</span><span class="s0">value</span><span class="s1">: </span><span class="s0">V</span><span class="s1">, </span><span class="s0">oldValue</span><span class="s1">: </span><span class="s0">OV</span><span class="s1">, </span><span class="s0">onCleanup</span><span class="s1">: </span><span class="s0">OnCleanup</span><span class="s1">) =&gt; </span><span class="s0">any</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare type WatchEffect </span><span class="s1">= (</span><span class="s0">onCleanup</span><span class="s1">: </span><span class="s0">OnCleanup</span><span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">watchEffect</span><span class="s1">(</span><span class="s0">effect</span><span class="s1">: </span><span class="s0">WatchEffect</span><span class="s1">, </span><span class="s0">options</span><span class="s1">?: </span><span class="s0">WatchOptionsBase</span><span class="s1">): </span><span class="s0">WatchStopHandle</span><span class="s1">;</span>

<span class="s3">/* Excluded from this release type: Watcher */</span>

<span class="s3">/* Excluded from this release type: WatcherOptions */</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">interface </span><span class="s0">WatchOptions</span><span class="s1">&lt;</span><span class="s0">Immediate </span><span class="s1">= </span><span class="s0">boolean</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s0">WatchOptionsBase </span><span class="s1">{</span>
    <span class="s0">immediate</span><span class="s1">?: </span><span class="s0">Immediate</span><span class="s1">;</span>
    <span class="s0">deep</span><span class="s1">?: </span><span class="s0">boolean</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">interface </span><span class="s0">WatchOptionsBase </span><span class="s2">extends </span><span class="s0">DebuggerOptions </span><span class="s1">{</span>
    <span class="s0">flush</span><span class="s1">?: </span><span class="s6">'pre' </span><span class="s1">| </span><span class="s6">'post' </span><span class="s1">| </span><span class="s6">'sync'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">watchPostEffect</span><span class="s1">(</span><span class="s0">effect</span><span class="s1">: </span><span class="s0">WatchEffect</span><span class="s1">, </span><span class="s0">options</span><span class="s1">?: </span><span class="s0">DebuggerOptions</span><span class="s1">): </span><span class="s0">WatchStopHandle</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare type WatchSource</span><span class="s1">&lt;</span><span class="s0">T </span><span class="s1">= </span><span class="s0">any</span><span class="s1">&gt; = </span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; | </span><span class="s0">ComputedRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; | (() =&gt; </span><span class="s0">T</span><span class="s1">);</span>

<span class="s2">export </span><span class="s0">declare type WatchStopHandle </span><span class="s1">= () =&gt; </span><span class="s2">void</span><span class="s1">;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">function </span><span class="s0">watchSyncEffect</span><span class="s1">(</span><span class="s0">effect</span><span class="s1">: </span><span class="s0">WatchEffect</span><span class="s1">, </span><span class="s0">options</span><span class="s1">?: </span><span class="s0">DebuggerOptions</span><span class="s1">): </span><span class="s0">WatchStopHandle</span><span class="s1">;</span>

<span class="s0">declare type WeakCollections </span><span class="s1">= </span><span class="s0">WeakMap</span><span class="s1">&lt;</span><span class="s0">any</span><span class="s1">, </span><span class="s0">any</span><span class="s1">&gt; | </span><span class="s0">WeakSet</span><span class="s1">&lt;</span><span class="s0">any</span><span class="s1">&gt;;</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">interface </span><span class="s0">WritableComputedOptions</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; {</span>
    <span class="s0">get</span><span class="s1">: </span><span class="s0">ComputedGetter</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;;</span>
    <span class="s0">set</span><span class="s1">: </span><span class="s0">ComputedSetter</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt;;</span>
<span class="s1">}</span>

<span class="s2">export </span><span class="s0">declare </span><span class="s2">interface </span><span class="s0">WritableComputedRef</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s0">Ref</span><span class="s1">&lt;</span><span class="s0">T</span><span class="s1">&gt; {</span>
    <span class="s0">readonly effect</span><span class="s1">: </span><span class="s0">any</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">export </span><span class="s1">{ }</span>
</pre>
</body>
</html>