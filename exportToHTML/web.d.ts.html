<html>
<head>
<title>web.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #cf8e6d;}
.s5 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
web.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">declare module </span><span class="s1">&quot;stream/web&quot; </span><span class="s2">{</span>
    <span class="s3">// stub module, pending copy&amp;paste from .d.ts or manual impl</span>
    <span class="s3">// copy from lib.dom.d.ts</span>
    <span class="s4">interface </span><span class="s0">ReadableWritablePair</span><span class="s2">&lt;</span><span class="s0">R </span><span class="s2">= </span><span class="s0">any</span><span class="s2">, </span><span class="s0">W </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt; {</span>
        <span class="s0">readable</span><span class="s2">: </span><span class="s0">ReadableStream</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt;;</span>
        <span class="s5">/**</span>
         <span class="s5">* Provides a convenient, chainable way of piping this readable stream</span>
         <span class="s5">* through a transform stream (or any other { writable, readable }</span>
         <span class="s5">* pair). It simply pipes the stream into the writable side of the</span>
         <span class="s5">* supplied pair, and returns the readable side for further use.</span>
         <span class="s5">*</span>
         <span class="s5">* Piping a stream will lock it for the duration of the pipe, preventing</span>
         <span class="s5">* any other consumer from acquiring a reader.</span>
         <span class="s5">*/</span>
        <span class="s0">writable</span><span class="s2">: </span><span class="s0">WritableStream</span><span class="s2">&lt;</span><span class="s0">W</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">StreamPipeOptions </span><span class="s2">{</span>
        <span class="s0">preventAbort</span><span class="s2">?: </span><span class="s0">boolean</span><span class="s2">;</span>
        <span class="s0">preventCancel</span><span class="s2">?: </span><span class="s0">boolean</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Pipes this readable stream to a given writable stream destination.</span>
         <span class="s5">* The way in which the piping process behaves under various error</span>
         <span class="s5">* conditions can be customized with a number of passed options. It</span>
         <span class="s5">* returns a promise that fulfills when the piping process completes</span>
         <span class="s5">* successfully, or rejects if any errors were encountered.</span>
         <span class="s5">*</span>
         <span class="s5">* Piping a stream will lock it for the duration of the pipe, preventing</span>
         <span class="s5">* any other consumer from acquiring a reader.</span>
         <span class="s5">*</span>
         <span class="s5">* Errors and closures of the source and destination streams propagate</span>
         <span class="s5">* as follows:</span>
         <span class="s5">*</span>
         <span class="s5">* An error in this source readable stream will abort destination,</span>
         <span class="s5">* unless preventAbort is truthy. The returned promise will be rejected</span>
         <span class="s5">* with the source's error, or with any error that occurs during</span>
         <span class="s5">* aborting the destination.</span>
         <span class="s5">*</span>
         <span class="s5">* An error in destination will cancel this source readable stream,</span>
         <span class="s5">* unless preventCancel is truthy. The returned promise will be rejected</span>
         <span class="s5">* with the destination's error, or with any error that occurs during</span>
         <span class="s5">* canceling the source.</span>
         <span class="s5">*</span>
         <span class="s5">* When this source readable stream closes, destination will be closed,</span>
         <span class="s5">* unless preventClose is truthy. The returned promise will be fulfilled</span>
         <span class="s5">* once this process completes, unless an error is encountered while</span>
         <span class="s5">* closing the destination, in which case it will be rejected with that</span>
         <span class="s5">* error.</span>
         <span class="s5">*</span>
         <span class="s5">* If destination starts out closed or closing, this source readable</span>
         <span class="s5">* stream will be canceled, unless preventCancel is true. The returned</span>
         <span class="s5">* promise will be rejected with an error indicating piping to a closed</span>
         <span class="s5">* stream failed, or with any error that occurs during canceling the</span>
         <span class="s5">* source.</span>
         <span class="s5">*</span>
         <span class="s5">* The signal option can be set to an AbortSignal to allow aborting an</span>
         <span class="s5">* ongoing pipe operation via the corresponding AbortController. In this</span>
         <span class="s5">* case, this source readable stream will be canceled, and destination</span>
         <span class="s5">* aborted, unless the respective options preventCancel or preventAbort</span>
         <span class="s5">* are set.</span>
         <span class="s5">*/</span>
        <span class="s0">preventClose</span><span class="s2">?: </span><span class="s0">boolean</span><span class="s2">;</span>
        <span class="s0">signal</span><span class="s2">?: </span><span class="s0">AbortSignal</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">ReadableStreamGenericReader </span><span class="s2">{</span>
        <span class="s0">readonly closed</span><span class="s2">: </span><span class="s0">Promise</span><span class="s2">&lt;</span><span class="s0">undefined</span><span class="s2">&gt;;</span>
        <span class="s0">cancel</span><span class="s2">(</span><span class="s0">reason</span><span class="s2">?: </span><span class="s0">any</span><span class="s2">): </span><span class="s0">Promise</span><span class="s2">&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">ReadableStreamDefaultReadValueResult</span><span class="s2">&lt;</span><span class="s0">T</span><span class="s2">&gt; {</span>
        <span class="s0">done</span><span class="s2">: </span><span class="s4">false</span><span class="s2">;</span>
        <span class="s0">value</span><span class="s2">: </span><span class="s0">T</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">ReadableStreamDefaultReadDoneResult </span><span class="s2">{</span>
        <span class="s0">done</span><span class="s2">: </span><span class="s4">true</span><span class="s2">;</span>
        <span class="s0">value</span><span class="s2">?: </span><span class="s0">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s0">type ReadableStreamController</span><span class="s2">&lt;</span><span class="s0">T</span><span class="s2">&gt; = </span><span class="s0">ReadableStreamDefaultController</span><span class="s2">&lt;</span><span class="s0">T</span><span class="s2">&gt;;</span>
    <span class="s0">type ReadableStreamDefaultReadResult</span><span class="s2">&lt;</span><span class="s0">T</span><span class="s2">&gt; =</span>
        <span class="s2">| </span><span class="s0">ReadableStreamDefaultReadValueResult</span><span class="s2">&lt;</span><span class="s0">T</span><span class="s2">&gt;</span>
        <span class="s2">| </span><span class="s0">ReadableStreamDefaultReadDoneResult</span><span class="s2">;</span>
    <span class="s4">interface </span><span class="s0">ReadableStreamReadValueResult</span><span class="s2">&lt;</span><span class="s0">T</span><span class="s2">&gt; {</span>
        <span class="s0">done</span><span class="s2">: </span><span class="s4">false</span><span class="s2">;</span>
        <span class="s0">value</span><span class="s2">: </span><span class="s0">T</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">ReadableStreamReadDoneResult</span><span class="s2">&lt;</span><span class="s0">T</span><span class="s2">&gt; {</span>
        <span class="s0">done</span><span class="s2">: </span><span class="s4">true</span><span class="s2">;</span>
        <span class="s0">value</span><span class="s2">?: </span><span class="s0">T</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s0">type ReadableStreamReadResult</span><span class="s2">&lt;</span><span class="s0">T</span><span class="s2">&gt; = </span><span class="s0">ReadableStreamReadValueResult</span><span class="s2">&lt;</span><span class="s0">T</span><span class="s2">&gt; | </span><span class="s0">ReadableStreamReadDoneResult</span><span class="s2">&lt;</span><span class="s0">T</span><span class="s2">&gt;;</span>
    <span class="s4">interface </span><span class="s0">ReadableByteStreamControllerCallback </span><span class="s2">{</span>
        <span class="s2">(</span><span class="s0">controller</span><span class="s2">: </span><span class="s0">ReadableByteStreamController</span><span class="s2">): </span><span class="s4">void </span><span class="s2">| </span><span class="s0">PromiseLike</span><span class="s2">&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">UnderlyingSinkAbortCallback </span><span class="s2">{</span>
        <span class="s2">(</span><span class="s0">reason</span><span class="s2">?: </span><span class="s0">any</span><span class="s2">): </span><span class="s4">void </span><span class="s2">| </span><span class="s0">PromiseLike</span><span class="s2">&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">UnderlyingSinkCloseCallback </span><span class="s2">{</span>
        <span class="s2">(): </span><span class="s4">void </span><span class="s2">| </span><span class="s0">PromiseLike</span><span class="s2">&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">UnderlyingSinkStartCallback </span><span class="s2">{</span>
        <span class="s2">(</span><span class="s0">controller</span><span class="s2">: </span><span class="s0">WritableStreamDefaultController</span><span class="s2">): </span><span class="s0">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">UnderlyingSinkWriteCallback</span><span class="s2">&lt;</span><span class="s0">W</span><span class="s2">&gt; {</span>
        <span class="s2">(</span><span class="s0">chunk</span><span class="s2">: </span><span class="s0">W</span><span class="s2">, </span><span class="s0">controller</span><span class="s2">: </span><span class="s0">WritableStreamDefaultController</span><span class="s2">): </span><span class="s4">void </span><span class="s2">| </span><span class="s0">PromiseLike</span><span class="s2">&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">UnderlyingSourceCancelCallback </span><span class="s2">{</span>
        <span class="s2">(</span><span class="s0">reason</span><span class="s2">?: </span><span class="s0">any</span><span class="s2">): </span><span class="s4">void </span><span class="s2">| </span><span class="s0">PromiseLike</span><span class="s2">&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">UnderlyingSourcePullCallback</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt; {</span>
        <span class="s2">(</span><span class="s0">controller</span><span class="s2">: </span><span class="s0">ReadableStreamController</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt;): </span><span class="s4">void </span><span class="s2">| </span><span class="s0">PromiseLike</span><span class="s2">&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">UnderlyingSourceStartCallback</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt; {</span>
        <span class="s2">(</span><span class="s0">controller</span><span class="s2">: </span><span class="s0">ReadableStreamController</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt;): </span><span class="s0">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">TransformerFlushCallback</span><span class="s2">&lt;</span><span class="s0">O</span><span class="s2">&gt; {</span>
        <span class="s2">(</span><span class="s0">controller</span><span class="s2">: </span><span class="s0">TransformStreamDefaultController</span><span class="s2">&lt;</span><span class="s0">O</span><span class="s2">&gt;): </span><span class="s4">void </span><span class="s2">| </span><span class="s0">PromiseLike</span><span class="s2">&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">TransformerStartCallback</span><span class="s2">&lt;</span><span class="s0">O</span><span class="s2">&gt; {</span>
        <span class="s2">(</span><span class="s0">controller</span><span class="s2">: </span><span class="s0">TransformStreamDefaultController</span><span class="s2">&lt;</span><span class="s0">O</span><span class="s2">&gt;): </span><span class="s0">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">TransformerTransformCallback</span><span class="s2">&lt;</span><span class="s0">I</span><span class="s2">, </span><span class="s0">O</span><span class="s2">&gt; {</span>
        <span class="s2">(</span><span class="s0">chunk</span><span class="s2">: </span><span class="s0">I</span><span class="s2">, </span><span class="s0">controller</span><span class="s2">: </span><span class="s0">TransformStreamDefaultController</span><span class="s2">&lt;</span><span class="s0">O</span><span class="s2">&gt;): </span><span class="s4">void </span><span class="s2">| </span><span class="s0">PromiseLike</span><span class="s2">&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">UnderlyingByteSource </span><span class="s2">{</span>
        <span class="s0">autoAllocateChunkSize</span><span class="s2">?: </span><span class="s0">number</span><span class="s2">;</span>
        <span class="s0">cancel</span><span class="s2">?: </span><span class="s0">ReadableStreamErrorCallback</span><span class="s2">;</span>
        <span class="s0">pull</span><span class="s2">?: </span><span class="s0">ReadableByteStreamControllerCallback</span><span class="s2">;</span>
        <span class="s0">start</span><span class="s2">?: </span><span class="s0">ReadableByteStreamControllerCallback</span><span class="s2">;</span>
        <span class="s0">type</span><span class="s2">: </span><span class="s1">&quot;bytes&quot;</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">UnderlyingSource</span><span class="s2">&lt;</span><span class="s0">R </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt; {</span>
        <span class="s0">cancel</span><span class="s2">?: </span><span class="s0">UnderlyingSourceCancelCallback</span><span class="s2">;</span>
        <span class="s0">pull</span><span class="s2">?: </span><span class="s0">UnderlyingSourcePullCallback</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt;;</span>
        <span class="s0">start</span><span class="s2">?: </span><span class="s0">UnderlyingSourceStartCallback</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt;;</span>
        <span class="s0">type</span><span class="s2">?: </span><span class="s0">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">UnderlyingSink</span><span class="s2">&lt;</span><span class="s0">W </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt; {</span>
        <span class="s0">abort</span><span class="s2">?: </span><span class="s0">UnderlyingSinkAbortCallback</span><span class="s2">;</span>
        <span class="s0">close</span><span class="s2">?: </span><span class="s0">UnderlyingSinkCloseCallback</span><span class="s2">;</span>
        <span class="s0">start</span><span class="s2">?: </span><span class="s0">UnderlyingSinkStartCallback</span><span class="s2">;</span>
        <span class="s0">type</span><span class="s2">?: </span><span class="s0">undefined</span><span class="s2">;</span>
        <span class="s0">write</span><span class="s2">?: </span><span class="s0">UnderlyingSinkWriteCallback</span><span class="s2">&lt;</span><span class="s0">W</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">ReadableStreamErrorCallback </span><span class="s2">{</span>
        <span class="s2">(</span><span class="s0">reason</span><span class="s2">: </span><span class="s0">any</span><span class="s2">): </span><span class="s4">void </span><span class="s2">| </span><span class="s0">PromiseLike</span><span class="s2">&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s5">/** This Streams API interface represents a readable stream of byte data. */</span>
    <span class="s4">interface </span><span class="s0">ReadableStream</span><span class="s2">&lt;</span><span class="s0">R </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt; {</span>
        <span class="s0">readonly locked</span><span class="s2">: </span><span class="s0">boolean</span><span class="s2">;</span>
        <span class="s0">cancel</span><span class="s2">(</span><span class="s0">reason</span><span class="s2">?: </span><span class="s0">any</span><span class="s2">): </span><span class="s0">Promise</span><span class="s2">&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s0">getReader</span><span class="s2">(): </span><span class="s0">ReadableStreamDefaultReader</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt;;</span>
        <span class="s0">getReader</span><span class="s2">(</span><span class="s0">options</span><span class="s2">: { </span><span class="s0">mode</span><span class="s2">: </span><span class="s1">&quot;byob&quot; </span><span class="s2">}): </span><span class="s0">ReadableStreamBYOBReader</span><span class="s2">;</span>
        <span class="s0">pipeThrough</span><span class="s2">&lt;</span><span class="s0">T</span><span class="s2">&gt;(</span><span class="s0">transform</span><span class="s2">: </span><span class="s0">ReadableWritablePair</span><span class="s2">&lt;</span><span class="s0">T</span><span class="s2">, </span><span class="s0">R</span><span class="s2">&gt;, </span><span class="s0">options</span><span class="s2">?: </span><span class="s0">StreamPipeOptions</span><span class="s2">): </span><span class="s0">ReadableStream</span><span class="s2">&lt;</span><span class="s0">T</span><span class="s2">&gt;;</span>
        <span class="s0">pipeTo</span><span class="s2">(</span><span class="s0">destination</span><span class="s2">: </span><span class="s0">WritableStream</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt;, </span><span class="s0">options</span><span class="s2">?: </span><span class="s0">StreamPipeOptions</span><span class="s2">): </span><span class="s0">Promise</span><span class="s2">&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s0">tee</span><span class="s2">(): [</span><span class="s0">ReadableStream</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt;, </span><span class="s0">ReadableStream</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt;];</span>
        <span class="s0">values</span><span class="s2">(</span><span class="s0">options</span><span class="s2">?: { </span><span class="s0">preventCancel</span><span class="s2">?: </span><span class="s0">boolean </span><span class="s2">}): </span><span class="s0">AsyncIterableIterator</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt;;</span>
        <span class="s2">[</span><span class="s0">Symbol</span><span class="s2">.</span><span class="s0">asyncIterator</span><span class="s2">](): </span><span class="s0">AsyncIterableIterator</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s4">const </span><span class="s0">ReadableStream</span><span class="s2">: {</span>
        <span class="s0">prototype</span><span class="s2">: </span><span class="s0">ReadableStream</span><span class="s2">;</span>
        <span class="s4">new</span><span class="s2">(</span><span class="s0">underlyingSource</span><span class="s2">: </span><span class="s0">UnderlyingByteSource</span><span class="s2">, </span><span class="s0">strategy</span><span class="s2">?: </span><span class="s0">QueuingStrategy</span><span class="s2">&lt;</span><span class="s0">Uint8Array</span><span class="s2">&gt;): </span><span class="s0">ReadableStream</span><span class="s2">&lt;</span><span class="s0">Uint8Array</span><span class="s2">&gt;;</span>
        <span class="s4">new</span><span class="s2">&lt;</span><span class="s0">R </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt;(</span><span class="s0">underlyingSource</span><span class="s2">?: </span><span class="s0">UnderlyingSource</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt;, </span><span class="s0">strategy</span><span class="s2">?: </span><span class="s0">QueuingStrategy</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt;): </span><span class="s0">ReadableStream</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt;;</span>
    <span class="s2">};</span>
    <span class="s4">interface </span><span class="s0">ReadableStreamDefaultReader</span><span class="s2">&lt;</span><span class="s0">R </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt; </span><span class="s4">extends </span><span class="s0">ReadableStreamGenericReader </span><span class="s2">{</span>
        <span class="s0">read</span><span class="s2">(): </span><span class="s0">Promise</span><span class="s2">&lt;</span><span class="s0">ReadableStreamDefaultReadResult</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt;&gt;;</span>
        <span class="s0">releaseLock</span><span class="s2">(): </span><span class="s4">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">ReadableStreamBYOBReader </span><span class="s4">extends </span><span class="s0">ReadableStreamGenericReader </span><span class="s2">{</span>
        <span class="s0">read</span><span class="s2">&lt;</span><span class="s0">T </span><span class="s4">extends </span><span class="s0">ArrayBufferView</span><span class="s2">&gt;(</span><span class="s0">view</span><span class="s2">: </span><span class="s0">T</span><span class="s2">): </span><span class="s0">Promise</span><span class="s2">&lt;</span><span class="s0">ReadableStreamReadResult</span><span class="s2">&lt;</span><span class="s0">T</span><span class="s2">&gt;&gt;;</span>
        <span class="s0">releaseLock</span><span class="s2">(): </span><span class="s4">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">const </span><span class="s0">ReadableStreamDefaultReader</span><span class="s2">: {</span>
        <span class="s0">prototype</span><span class="s2">: </span><span class="s0">ReadableStreamDefaultReader</span><span class="s2">;</span>
        <span class="s4">new</span><span class="s2">&lt;</span><span class="s0">R </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt;(</span><span class="s0">stream</span><span class="s2">: </span><span class="s0">ReadableStream</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt;): </span><span class="s0">ReadableStreamDefaultReader</span><span class="s2">&lt;</span><span class="s0">R</span><span class="s2">&gt;;</span>
    <span class="s2">};</span>
    <span class="s4">const </span><span class="s0">ReadableStreamBYOBReader</span><span class="s2">: </span><span class="s0">any</span><span class="s2">;</span>
    <span class="s4">const </span><span class="s0">ReadableStreamBYOBRequest</span><span class="s2">: </span><span class="s0">any</span><span class="s2">;</span>
    <span class="s4">interface </span><span class="s0">ReadableByteStreamController </span><span class="s2">{</span>
        <span class="s0">readonly byobRequest</span><span class="s2">: </span><span class="s0">undefined</span><span class="s2">;</span>
        <span class="s0">readonly desiredSize</span><span class="s2">: </span><span class="s0">number </span><span class="s2">| </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s0">close</span><span class="s2">(): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">enqueue</span><span class="s2">(</span><span class="s0">chunk</span><span class="s2">: </span><span class="s0">ArrayBufferView</span><span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">error</span><span class="s2">(</span><span class="s0">error</span><span class="s2">?: </span><span class="s0">any</span><span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">const </span><span class="s0">ReadableByteStreamController</span><span class="s2">: {</span>
        <span class="s0">prototype</span><span class="s2">: </span><span class="s0">ReadableByteStreamController</span><span class="s2">;</span>
        <span class="s4">new</span><span class="s2">(): </span><span class="s0">ReadableByteStreamController</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s4">interface </span><span class="s0">ReadableStreamDefaultController</span><span class="s2">&lt;</span><span class="s0">R </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt; {</span>
        <span class="s0">readonly desiredSize</span><span class="s2">: </span><span class="s0">number </span><span class="s2">| </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s0">close</span><span class="s2">(): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">enqueue</span><span class="s2">(</span><span class="s0">chunk</span><span class="s2">?: </span><span class="s0">R</span><span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">error</span><span class="s2">(</span><span class="s0">e</span><span class="s2">?: </span><span class="s0">any</span><span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">const </span><span class="s0">ReadableStreamDefaultController</span><span class="s2">: {</span>
        <span class="s0">prototype</span><span class="s2">: </span><span class="s0">ReadableStreamDefaultController</span><span class="s2">;</span>
        <span class="s4">new</span><span class="s2">(): </span><span class="s0">ReadableStreamDefaultController</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s4">interface </span><span class="s0">Transformer</span><span class="s2">&lt;</span><span class="s0">I </span><span class="s2">= </span><span class="s0">any</span><span class="s2">, </span><span class="s0">O </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt; {</span>
        <span class="s0">flush</span><span class="s2">?: </span><span class="s0">TransformerFlushCallback</span><span class="s2">&lt;</span><span class="s0">O</span><span class="s2">&gt;;</span>
        <span class="s0">readableType</span><span class="s2">?: </span><span class="s0">undefined</span><span class="s2">;</span>
        <span class="s0">start</span><span class="s2">?: </span><span class="s0">TransformerStartCallback</span><span class="s2">&lt;</span><span class="s0">O</span><span class="s2">&gt;;</span>
        <span class="s0">transform</span><span class="s2">?: </span><span class="s0">TransformerTransformCallback</span><span class="s2">&lt;</span><span class="s0">I</span><span class="s2">, </span><span class="s0">O</span><span class="s2">&gt;;</span>
        <span class="s0">writableType</span><span class="s2">?: </span><span class="s0">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">TransformStream</span><span class="s2">&lt;</span><span class="s0">I </span><span class="s2">= </span><span class="s0">any</span><span class="s2">, </span><span class="s0">O </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt; {</span>
        <span class="s0">readonly readable</span><span class="s2">: </span><span class="s0">ReadableStream</span><span class="s2">&lt;</span><span class="s0">O</span><span class="s2">&gt;;</span>
        <span class="s0">readonly writable</span><span class="s2">: </span><span class="s0">WritableStream</span><span class="s2">&lt;</span><span class="s0">I</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s4">const </span><span class="s0">TransformStream</span><span class="s2">: {</span>
        <span class="s0">prototype</span><span class="s2">: </span><span class="s0">TransformStream</span><span class="s2">;</span>
        <span class="s4">new</span><span class="s2">&lt;</span><span class="s0">I </span><span class="s2">= </span><span class="s0">any</span><span class="s2">, </span><span class="s0">O </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt;(</span>
            <span class="s0">transformer</span><span class="s2">?: </span><span class="s0">Transformer</span><span class="s2">&lt;</span><span class="s0">I</span><span class="s2">, </span><span class="s0">O</span><span class="s2">&gt;,</span>
            <span class="s0">writableStrategy</span><span class="s2">?: </span><span class="s0">QueuingStrategy</span><span class="s2">&lt;</span><span class="s0">I</span><span class="s2">&gt;,</span>
            <span class="s0">readableStrategy</span><span class="s2">?: </span><span class="s0">QueuingStrategy</span><span class="s2">&lt;</span><span class="s0">O</span><span class="s2">&gt;,</span>
        <span class="s2">): </span><span class="s0">TransformStream</span><span class="s2">&lt;</span><span class="s0">I</span><span class="s2">, </span><span class="s0">O</span><span class="s2">&gt;;</span>
    <span class="s2">};</span>
    <span class="s4">interface </span><span class="s0">TransformStreamDefaultController</span><span class="s2">&lt;</span><span class="s0">O </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt; {</span>
        <span class="s0">readonly desiredSize</span><span class="s2">: </span><span class="s0">number </span><span class="s2">| </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s0">enqueue</span><span class="s2">(</span><span class="s0">chunk</span><span class="s2">?: </span><span class="s0">O</span><span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">error</span><span class="s2">(</span><span class="s0">reason</span><span class="s2">?: </span><span class="s0">any</span><span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">terminate</span><span class="s2">(): </span><span class="s4">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">const </span><span class="s0">TransformStreamDefaultController</span><span class="s2">: {</span>
        <span class="s0">prototype</span><span class="s2">: </span><span class="s0">TransformStreamDefaultController</span><span class="s2">;</span>
        <span class="s4">new</span><span class="s2">(): </span><span class="s0">TransformStreamDefaultController</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/**</span>
     <span class="s5">* This Streams API interface provides a standard abstraction for writing</span>
     <span class="s5">* streaming data to a destination, known as a sink. This object comes with</span>
     <span class="s5">* built-in back pressure and queuing.</span>
     <span class="s5">*/</span>
    <span class="s4">interface </span><span class="s0">WritableStream</span><span class="s2">&lt;</span><span class="s0">W </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt; {</span>
        <span class="s0">readonly locked</span><span class="s2">: </span><span class="s0">boolean</span><span class="s2">;</span>
        <span class="s0">abort</span><span class="s2">(</span><span class="s0">reason</span><span class="s2">?: </span><span class="s0">any</span><span class="s2">): </span><span class="s0">Promise</span><span class="s2">&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s0">close</span><span class="s2">(): </span><span class="s0">Promise</span><span class="s2">&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s0">getWriter</span><span class="s2">(): </span><span class="s0">WritableStreamDefaultWriter</span><span class="s2">&lt;</span><span class="s0">W</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s4">const </span><span class="s0">WritableStream</span><span class="s2">: {</span>
        <span class="s0">prototype</span><span class="s2">: </span><span class="s0">WritableStream</span><span class="s2">;</span>
        <span class="s4">new</span><span class="s2">&lt;</span><span class="s0">W </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt;(</span><span class="s0">underlyingSink</span><span class="s2">?: </span><span class="s0">UnderlyingSink</span><span class="s2">&lt;</span><span class="s0">W</span><span class="s2">&gt;, </span><span class="s0">strategy</span><span class="s2">?: </span><span class="s0">QueuingStrategy</span><span class="s2">&lt;</span><span class="s0">W</span><span class="s2">&gt;): </span><span class="s0">WritableStream</span><span class="s2">&lt;</span><span class="s0">W</span><span class="s2">&gt;;</span>
    <span class="s2">};</span>
    <span class="s5">/**</span>
     <span class="s5">* This Streams API interface is the object returned by</span>
     <span class="s5">* WritableStream.getWriter() and once created locks the &lt; writer to the</span>
     <span class="s5">* WritableStream ensuring that no other streams can write to the underlying</span>
     <span class="s5">* sink.</span>
     <span class="s5">*/</span>
    <span class="s4">interface </span><span class="s0">WritableStreamDefaultWriter</span><span class="s2">&lt;</span><span class="s0">W </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt; {</span>
        <span class="s0">readonly closed</span><span class="s2">: </span><span class="s0">Promise</span><span class="s2">&lt;</span><span class="s0">undefined</span><span class="s2">&gt;;</span>
        <span class="s0">readonly desiredSize</span><span class="s2">: </span><span class="s0">number </span><span class="s2">| </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s0">readonly ready</span><span class="s2">: </span><span class="s0">Promise</span><span class="s2">&lt;</span><span class="s0">undefined</span><span class="s2">&gt;;</span>
        <span class="s0">abort</span><span class="s2">(</span><span class="s0">reason</span><span class="s2">?: </span><span class="s0">any</span><span class="s2">): </span><span class="s0">Promise</span><span class="s2">&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s0">close</span><span class="s2">(): </span><span class="s0">Promise</span><span class="s2">&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
        <span class="s0">releaseLock</span><span class="s2">(): </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">write</span><span class="s2">(</span><span class="s0">chunk</span><span class="s2">?: </span><span class="s0">W</span><span class="s2">): </span><span class="s0">Promise</span><span class="s2">&lt;</span><span class="s4">void</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s4">const </span><span class="s0">WritableStreamDefaultWriter</span><span class="s2">: {</span>
        <span class="s0">prototype</span><span class="s2">: </span><span class="s0">WritableStreamDefaultWriter</span><span class="s2">;</span>
        <span class="s4">new</span><span class="s2">&lt;</span><span class="s0">W </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt;(</span><span class="s0">stream</span><span class="s2">: </span><span class="s0">WritableStream</span><span class="s2">&lt;</span><span class="s0">W</span><span class="s2">&gt;): </span><span class="s0">WritableStreamDefaultWriter</span><span class="s2">&lt;</span><span class="s0">W</span><span class="s2">&gt;;</span>
    <span class="s2">};</span>
    <span class="s5">/**</span>
     <span class="s5">* This Streams API interface represents a controller allowing control of a</span>
     <span class="s5">* WritableStream's state. When constructing a WritableStream, the</span>
     <span class="s5">* underlying sink is given a corresponding WritableStreamDefaultController</span>
     <span class="s5">* instance to manipulate.</span>
     <span class="s5">*/</span>
    <span class="s4">interface </span><span class="s0">WritableStreamDefaultController </span><span class="s2">{</span>
        <span class="s0">error</span><span class="s2">(</span><span class="s0">e</span><span class="s2">?: </span><span class="s0">any</span><span class="s2">): </span><span class="s4">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">const </span><span class="s0">WritableStreamDefaultController</span><span class="s2">: {</span>
        <span class="s0">prototype</span><span class="s2">: </span><span class="s0">WritableStreamDefaultController</span><span class="s2">;</span>
        <span class="s4">new</span><span class="s2">(): </span><span class="s0">WritableStreamDefaultController</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s4">interface </span><span class="s0">QueuingStrategy</span><span class="s2">&lt;</span><span class="s0">T </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt; {</span>
        <span class="s0">highWaterMark</span><span class="s2">?: </span><span class="s0">number</span><span class="s2">;</span>
        <span class="s0">size</span><span class="s2">?: </span><span class="s0">QueuingStrategySize</span><span class="s2">&lt;</span><span class="s0">T</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">QueuingStrategySize</span><span class="s2">&lt;</span><span class="s0">T </span><span class="s2">= </span><span class="s0">any</span><span class="s2">&gt; {</span>
        <span class="s2">(</span><span class="s0">chunk</span><span class="s2">?: </span><span class="s0">T</span><span class="s2">): </span><span class="s0">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">interface </span><span class="s0">QueuingStrategyInit </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* Creates a new ByteLengthQueuingStrategy with the provided high water</span>
         <span class="s5">* mark.</span>
         <span class="s5">*</span>
         <span class="s5">* Note that the provided high water mark will not be validated ahead of</span>
         <span class="s5">* time. Instead, if it is negative, NaN, or not a number, the resulting</span>
         <span class="s5">* ByteLengthQueuingStrategy will cause the corresponding stream</span>
         <span class="s5">* constructor to throw.</span>
         <span class="s5">*/</span>
        <span class="s0">highWaterMark</span><span class="s2">: </span><span class="s0">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* This Streams API interface provides a built-in byte length queuing</span>
     <span class="s5">* strategy that can be used when constructing streams.</span>
     <span class="s5">*/</span>
    <span class="s4">interface </span><span class="s0">ByteLengthQueuingStrategy </span><span class="s4">extends </span><span class="s0">QueuingStrategy</span><span class="s2">&lt;</span><span class="s0">ArrayBufferView</span><span class="s2">&gt; {</span>
        <span class="s0">readonly highWaterMark</span><span class="s2">: </span><span class="s0">number</span><span class="s2">;</span>
        <span class="s0">readonly size</span><span class="s2">: </span><span class="s0">QueuingStrategySize</span><span class="s2">&lt;</span><span class="s0">ArrayBufferView</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s4">const </span><span class="s0">ByteLengthQueuingStrategy</span><span class="s2">: {</span>
        <span class="s0">prototype</span><span class="s2">: </span><span class="s0">ByteLengthQueuingStrategy</span><span class="s2">;</span>
        <span class="s4">new</span><span class="s2">(</span><span class="s0">init</span><span class="s2">: </span><span class="s0">QueuingStrategyInit</span><span class="s2">): </span><span class="s0">ByteLengthQueuingStrategy</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/**</span>
     <span class="s5">* This Streams API interface provides a built-in byte length queuing</span>
     <span class="s5">* strategy that can be used when constructing streams.</span>
     <span class="s5">*/</span>
    <span class="s4">interface </span><span class="s0">CountQueuingStrategy </span><span class="s4">extends </span><span class="s0">QueuingStrategy </span><span class="s2">{</span>
        <span class="s0">readonly highWaterMark</span><span class="s2">: </span><span class="s0">number</span><span class="s2">;</span>
        <span class="s0">readonly size</span><span class="s2">: </span><span class="s0">QueuingStrategySize</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">const </span><span class="s0">CountQueuingStrategy</span><span class="s2">: {</span>
        <span class="s0">prototype</span><span class="s2">: </span><span class="s0">CountQueuingStrategy</span><span class="s2">;</span>
        <span class="s4">new</span><span class="s2">(</span><span class="s0">init</span><span class="s2">: </span><span class="s0">QueuingStrategyInit</span><span class="s2">): </span><span class="s0">CountQueuingStrategy</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s4">interface </span><span class="s0">TextEncoderStream </span><span class="s2">{</span>
        <span class="s5">/** Returns &quot;utf-8&quot;. */</span>
        <span class="s0">readonly encoding</span><span class="s2">: </span><span class="s1">&quot;utf-8&quot;</span><span class="s2">;</span>
        <span class="s0">readonly readable</span><span class="s2">: </span><span class="s0">ReadableStream</span><span class="s2">&lt;</span><span class="s0">Uint8Array</span><span class="s2">&gt;;</span>
        <span class="s0">readonly writable</span><span class="s2">: </span><span class="s0">WritableStream</span><span class="s2">&lt;</span><span class="s0">string</span><span class="s2">&gt;;</span>
        <span class="s0">readonly </span><span class="s2">[</span><span class="s0">Symbol</span><span class="s2">.</span><span class="s0">toStringTag</span><span class="s2">]: </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">const </span><span class="s0">TextEncoderStream</span><span class="s2">: {</span>
        <span class="s0">prototype</span><span class="s2">: </span><span class="s0">TextEncoderStream</span><span class="s2">;</span>
        <span class="s4">new</span><span class="s2">(): </span><span class="s0">TextEncoderStream</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s4">interface </span><span class="s0">TextDecoderOptions </span><span class="s2">{</span>
        <span class="s0">fatal</span><span class="s2">?: </span><span class="s0">boolean</span><span class="s2">;</span>
        <span class="s0">ignoreBOM</span><span class="s2">?: </span><span class="s0">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s0">type BufferSource </span><span class="s2">= </span><span class="s0">ArrayBufferView </span><span class="s2">| </span><span class="s0">ArrayBuffer</span><span class="s2">;</span>
    <span class="s4">interface </span><span class="s0">TextDecoderStream </span><span class="s2">{</span>
        <span class="s5">/** Returns encoding's name, lower cased. */</span>
        <span class="s0">readonly encoding</span><span class="s2">: </span><span class="s0">string</span><span class="s2">;</span>
        <span class="s5">/** Returns `true` if error mode is &quot;fatal&quot;, and `false` otherwise. */</span>
        <span class="s0">readonly fatal</span><span class="s2">: </span><span class="s0">boolean</span><span class="s2">;</span>
        <span class="s5">/** Returns `true` if ignore BOM flag is set, and `false` otherwise. */</span>
        <span class="s0">readonly ignoreBOM</span><span class="s2">: </span><span class="s0">boolean</span><span class="s2">;</span>
        <span class="s0">readonly readable</span><span class="s2">: </span><span class="s0">ReadableStream</span><span class="s2">&lt;</span><span class="s0">string</span><span class="s2">&gt;;</span>
        <span class="s0">readonly writable</span><span class="s2">: </span><span class="s0">WritableStream</span><span class="s2">&lt;</span><span class="s0">BufferSource</span><span class="s2">&gt;;</span>
        <span class="s0">readonly </span><span class="s2">[</span><span class="s0">Symbol</span><span class="s2">.</span><span class="s0">toStringTag</span><span class="s2">]: </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">const </span><span class="s0">TextDecoderStream</span><span class="s2">: {</span>
        <span class="s0">prototype</span><span class="s2">: </span><span class="s0">TextDecoderStream</span><span class="s2">;</span>
        <span class="s4">new</span><span class="s2">(</span><span class="s0">label</span><span class="s2">?: </span><span class="s0">string</span><span class="s2">, </span><span class="s0">options</span><span class="s2">?: </span><span class="s0">TextDecoderOptions</span><span class="s2">): </span><span class="s0">TextDecoderStream</span><span class="s2">;</span>
    <span class="s2">};</span>
<span class="s2">}</span>
<span class="s0">declare module </span><span class="s1">&quot;node:stream/web&quot; </span><span class="s2">{</span>
    <span class="s4">export </span><span class="s2">* </span><span class="s0">from </span><span class="s1">&quot;stream/web&quot;</span><span class="s2">;</span>
<span class="s2">}</span>
</pre>
</body>
</html>