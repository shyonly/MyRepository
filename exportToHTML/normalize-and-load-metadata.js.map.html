<html>
<head>
<title>normalize-and-load-metadata.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
normalize-and-load-metadata.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_path&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperValidatorIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperSplitExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;hasExports&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;isSideEffectImport&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;imports&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;importsNamespace&quot;</span><span class="s0">,</span><span class="s1">&quot;reexports&quot;</span><span class="s0">,</span><span class="s1">&quot;reexportNamespace&quot;</span><span class="s0">,</span><span class="s1">&quot;reexportAll&quot;</span><span class="s0">,</span><span class="s1">&quot;validateImportInteropOption&quot;</span><span class="s0">,</span><span class="s1">&quot;importInterop&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveImportInterop&quot;</span><span class="s0">,</span><span class="s1">&quot;filename&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeModuleAndLoadMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;programPath&quot;</span><span class="s0">,</span><span class="s1">&quot;exportName&quot;</span><span class="s0">,</span><span class="s1">&quot;initializeReexports&quot;</span><span class="s0">,</span><span class="s1">&quot;getWrapperPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;esNamespaceOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;stringSpecifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;nameAnonymousExports&quot;</span><span class="s0">,</span><span class="s1">&quot;local&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">,</span><span class="s1">&quot;getModuleMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;removeImportExportDeclarations&quot;</span><span class="s0">,</span><span class="s1">&quot;nameOfnamespace&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedInterop&quot;</span><span class="s0">,</span><span class="s1">&quot;interop&quot;</span><span class="s0">,</span><span class="s1">&quot;exportNameListName&quot;</span><span class="s0">,</span><span class="s1">&quot;getExportSpecifierName&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;isStringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;stringValue&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifierName&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;assertExportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportNamespaceSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;localData&quot;</span><span class="s0">,</span><span class="s1">&quot;getLocalExportMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;importNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceData&quot;</span><span class="s0">,</span><span class="s1">&quot;getData&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceNode&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;basename&quot;</span><span class="s0">,</span><span class="s1">&quot;extname&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;wrap&quot;</span><span class="s0">,</span><span class="s1">&quot;lazy&quot;</span><span class="s0">,</span><span class="s1">&quot;referenced&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;child&quot;</span><span class="s0">,</span><span class="s1">&quot;isImportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;spec&quot;</span><span class="s0">,</span><span class="s1">&quot;isImportDefaultSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;localName&quot;</span><span class="s0">,</span><span class="s1">&quot;reexport&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">,</span><span class="s1">&quot;isImportNamespaceSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isImportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;importName&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportAllDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportNamedDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDefaultDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;needsDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;needsNamed&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingKindLookup&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;getOuterBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;localMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;getLocalMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;idPath&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;ids&quot;</span><span class="s0">,</span><span class="s1">&quot;getOuterBindingIdentifierPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;exported&quot;</span><span class="s0">,</span><span class="s1">&quot;splitExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;_blockHoist&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/normalize-and-load-metadata.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { basename, extname } from </span><span class="s3">\&quot;</span><span class="s1">path</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import { isIdentifierName } from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-validator-identifier</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import splitExportDeclaration from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-split-export-declaration</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export interface ModuleMetadata {</span><span class="s3">\n  </span><span class="s1">exportName: string;</span><span class="s3">\n  </span><span class="s1">// The name of the variable that will reference an object containing export names.</span><span class="s3">\n  </span><span class="s1">exportNameListName: null | string;</span><span class="s3">\n  </span><span class="s1">hasExports: boolean;</span><span class="s3">\n  </span><span class="s1">// Lookup from local binding to export information.</span><span class="s3">\n  </span><span class="s1">local: Map&lt;string, LocalExportMetadata&gt;;</span><span class="s3">\n  </span><span class="s1">// Lookup of source file to source file metadata.</span><span class="s3">\n  </span><span class="s1">source: Map&lt;string, SourceModuleMetadata&gt;;</span><span class="s3">\n  </span><span class="s1">// List of names that should only be printed as string literals.</span><span class="s3">\n  </span><span class="s1">// i.e. `import { </span><span class="s3">\&quot;</span><span class="s1">any unicode</span><span class="s3">\&quot; </span><span class="s1">as foo } from </span><span class="s3">\&quot;</span><span class="s1">some-module</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n  </span><span class="s1">// `stringSpecifiers` is Set(1) [</span><span class="s3">\&quot;</span><span class="s1">any unicode</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">// In most cases `stringSpecifiers` is an empty Set</span><span class="s3">\n  </span><span class="s1">stringSpecifiers: Set&lt;string&gt;;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type InteropType =</span><span class="s3">\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">// Babel interop for default-only imports</span><span class="s3">\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">namespace</span><span class="s3">\&quot; </span><span class="s1">// Babel interop for namespace or default+named imports</span><span class="s3">\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">node-default</span><span class="s3">\&quot; </span><span class="s1">// Node.js interop for default-only imports</span><span class="s3">\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">node-namespace</span><span class="s3">\&quot; </span><span class="s1">// Node.js interop for namespace or default+named imports</span><span class="s3">\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">; // No interop, or named-only imports</span><span class="s3">\n\n</span><span class="s1">export type ImportInterop =</span><span class="s3">\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">babel</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;\n  </span><span class="s1">| ((source: string, filename?: string) =&gt; </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">babel</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">export interface SourceModuleMetadata {</span><span class="s3">\n  </span><span class="s1">// A unique variable name to use for this namespace object. Centralized for simplicity.</span><span class="s3">\n  </span><span class="s1">name: string;</span><span class="s3">\n  </span><span class="s1">loc: t.SourceLocation | undefined | null;</span><span class="s3">\n  </span><span class="s1">interop: InteropType;</span><span class="s3">\n  </span><span class="s1">// Local binding to reference from this source namespace. Key: Local name, value: Import name</span><span class="s3">\n  </span><span class="s1">imports: Map&lt;string, string&gt;;</span><span class="s3">\n  </span><span class="s1">// Local names that reference namespace object.</span><span class="s3">\n  </span><span class="s1">importsNamespace: Set&lt;string&gt;;</span><span class="s3">\n  </span><span class="s1">// Reexports to create for namespace. Key: Export name, value: Import name</span><span class="s3">\n  </span><span class="s1">reexports: Map&lt;string, string&gt;;</span><span class="s3">\n  </span><span class="s1">// List of names to re-export namespace as.</span><span class="s3">\n  </span><span class="s1">reexportNamespace: Set&lt;string&gt;;</span><span class="s3">\n  </span><span class="s1">// Tracks if the source should be re-exported.</span><span class="s3">\n  </span><span class="s1">reexportAll: null | {</span><span class="s3">\n    </span><span class="s1">loc: t.SourceLocation | undefined | null;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">wrap?: unknown;</span><span class="s3">\n  </span><span class="s1">referenced: boolean;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface LocalExportMetadata {</span><span class="s3">\n  </span><span class="s1">names: Array&lt;string&gt;; // names of exports,</span><span class="s3">\n  </span><span class="s1">kind: </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">hoisted</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check if the module has any exports that need handling.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function hasExports(metadata: ModuleMetadata) {</span><span class="s3">\n  </span><span class="s1">return metadata.hasExports;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check if a given source is an anonymous import, e.g. </span><span class="s3">\&quot;</span><span class="s1">import 'foo';</span><span class="s3">\&quot;\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isSideEffectImport(source: SourceModuleMetadata) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">source.imports.size === 0 &amp;&amp;</span><span class="s3">\n    </span><span class="s1">source.importsNamespace.size === 0 &amp;&amp;</span><span class="s3">\n    </span><span class="s1">source.reexports.size === 0 &amp;&amp;</span><span class="s3">\n    </span><span class="s1">source.reexportNamespace.size === 0 &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!source.reexportAll</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function validateImportInteropOption(</span><span class="s3">\n  </span><span class="s1">importInterop: any,</span><span class="s3">\n</span><span class="s1">): importInterop is ImportInterop {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">typeof importInterop !== </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">importInterop !== </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">importInterop !== </span><span class="s3">\&quot;</span><span class="s1">babel</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">importInterop !== </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`.importInterop must be one of </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">babel</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">, or a function returning one of those values (received ${importInterop}).`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return importInterop;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function resolveImportInterop(</span><span class="s3">\n  </span><span class="s1">importInterop: ImportInterop,</span><span class="s3">\n  </span><span class="s1">source: string,</span><span class="s3">\n  </span><span class="s1">filename: string | undefined,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (typeof importInterop === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return validateImportInteropOption(importInterop(source, filename));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return importInterop;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Remove all imports and exports from the file, and return all metadata</span><span class="s3">\n </span><span class="s1">* needed to reconstruct the module's behavior.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function normalizeModuleAndLoadMetadata(</span><span class="s3">\n  </span><span class="s1">programPath: NodePath&lt;t.Program&gt;,</span><span class="s3">\n  </span><span class="s1">exportName: string,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">importInterop,</span><span class="s3">\n    </span><span class="s1">initializeReexports = false,</span><span class="s3">\n    </span><span class="s1">getWrapperPayload,</span><span class="s3">\n    </span><span class="s1">esNamespaceOnly = false,</span><span class="s3">\n    </span><span class="s1">filename,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">importInterop: ImportInterop;</span><span class="s3">\n    </span><span class="s1">initializeReexports: boolean | void;</span><span class="s3">\n    </span><span class="s1">getWrapperPayload?: (</span><span class="s3">\n      </span><span class="s1">source: string,</span><span class="s3">\n      </span><span class="s1">metadata: SourceModuleMetadata,</span><span class="s3">\n      </span><span class="s1">importNodes: t.Node[],</span><span class="s3">\n    </span><span class="s1">) =&gt; unknown;</span><span class="s3">\n    </span><span class="s1">esNamespaceOnly: boolean;</span><span class="s3">\n    </span><span class="s1">filename: string;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">): ModuleMetadata {</span><span class="s3">\n  </span><span class="s1">if (!exportName) {</span><span class="s3">\n    </span><span class="s1">exportName = programPath.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">exports</span><span class="s3">\&quot;</span><span class="s1">).name;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const stringSpecifiers = new Set&lt;string&gt;();</span><span class="s3">\n\n  </span><span class="s1">nameAnonymousExports(programPath);</span><span class="s3">\n\n  </span><span class="s1">const { local, sources, hasExports } = getModuleMetadata(</span><span class="s3">\n    </span><span class="s1">programPath,</span><span class="s3">\n    </span><span class="s1">{ initializeReexports, getWrapperPayload },</span><span class="s3">\n    </span><span class="s1">stringSpecifiers,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">removeImportExportDeclarations(programPath);</span><span class="s3">\n\n  </span><span class="s1">// Reuse the imported namespace name if there is one.</span><span class="s3">\n  </span><span class="s1">for (const [source, metadata] of sources) {</span><span class="s3">\n    </span><span class="s1">const { importsNamespace, imports } = metadata;</span><span class="s3">\n    </span><span class="s1">// If there is at least one namespace import and other imports, it may collipse with local ident, can be seen in issue 15879.</span><span class="s3">\n    </span><span class="s1">if (importsNamespace.size &gt; 0 &amp;&amp; imports.size === 0) {</span><span class="s3">\n      </span><span class="s1">const [nameOfnamespace] = importsNamespace;</span><span class="s3">\n      </span><span class="s1">metadata.name = nameOfnamespace;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const resolvedInterop = resolveImportInterop(</span><span class="s3">\n      </span><span class="s1">importInterop,</span><span class="s3">\n      </span><span class="s1">source,</span><span class="s3">\n      </span><span class="s1">filename,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (resolvedInterop === </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">metadata.interop = </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else if (resolvedInterop === </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; metadata.interop === </span><span class="s3">\&quot;</span><span class="s1">namespace</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">metadata.interop = </span><span class="s3">\&quot;</span><span class="s1">node-namespace</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else if (resolvedInterop === </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; metadata.interop === </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">metadata.interop = </span><span class="s3">\&quot;</span><span class="s1">node-default</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else if (esNamespaceOnly &amp;&amp; metadata.interop === </span><span class="s3">\&quot;</span><span class="s1">namespace</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Both the default and namespace interops pass through __esModule</span><span class="s3">\n      </span><span class="s1">// objects, but the namespace interop is used to enable Babel's</span><span class="s3">\n      </span><span class="s1">// destructuring-like interop behavior for normal CommonJS.</span><span class="s3">\n      </span><span class="s1">// Since some tooling has started to remove that behavior, we expose</span><span class="s3">\n      </span><span class="s1">// it as the `esNamespace` option.</span><span class="s3">\n      </span><span class="s1">metadata.interop = </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">exportName,</span><span class="s3">\n    </span><span class="s1">exportNameListName: null,</span><span class="s3">\n    </span><span class="s1">hasExports,</span><span class="s3">\n    </span><span class="s1">local,</span><span class="s3">\n    </span><span class="s1">source: sources,</span><span class="s3">\n    </span><span class="s1">stringSpecifiers,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getExportSpecifierName(</span><span class="s3">\n  </span><span class="s1">path: NodePath,</span><span class="s3">\n  </span><span class="s1">stringSpecifiers: Set&lt;string&gt;,</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">if (path.isIdentifier()) {</span><span class="s3">\n    </span><span class="s1">return path.node.name;</span><span class="s3">\n  </span><span class="s1">} else if (path.isStringLiteral()) {</span><span class="s3">\n    </span><span class="s1">const stringValue = path.node.value;</span><span class="s3">\n    </span><span class="s1">// add specifier value to `stringSpecifiers` only when it can not be converted to an identifier name</span><span class="s3">\n    </span><span class="s1">// i.e In `import { </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot; </span><span class="s1">as bar }`</span><span class="s3">\n    </span><span class="s1">// we do not consider `</span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">` to be a `stringSpecifier` because we can treat it as</span><span class="s3">\n    </span><span class="s1">// `import { foo as bar }`</span><span class="s3">\n    </span><span class="s1">// This helps minimize the size of `stringSpecifiers` and reduce overhead of checking valid identifier names</span><span class="s3">\n    </span><span class="s1">// when building transpiled code from metadata</span><span class="s3">\n    </span><span class="s1">if (!isIdentifierName(stringValue)) {</span><span class="s3">\n      </span><span class="s1">stringSpecifiers.add(stringValue);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return stringValue;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function assertExportSpecifier(</span><span class="s3">\n  </span><span class="s1">path: NodePath,</span><span class="s3">\n</span><span class="s1">): asserts path is NodePath&lt;t.ExportSpecifier&gt; {</span><span class="s3">\n  </span><span class="s1">if (path.isExportSpecifier()) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">} else if (path.isExportNamespaceSpecifier()) {</span><span class="s3">\n    </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n      \&quot;</span><span class="s1">Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\&quot;</span><span class="s1">Unexpected export specifier type</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get metadata about the imports and exports present in this module.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getModuleMetadata(</span><span class="s3">\n  </span><span class="s1">programPath: NodePath&lt;t.Program&gt;,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">getWrapperPayload,</span><span class="s3">\n    </span><span class="s1">initializeReexports,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">getWrapperPayload?: (</span><span class="s3">\n      </span><span class="s1">source: string,</span><span class="s3">\n      </span><span class="s1">metadata: SourceModuleMetadata,</span><span class="s3">\n      </span><span class="s1">importNodes: t.Node[],</span><span class="s3">\n    </span><span class="s1">) =&gt; unknown;</span><span class="s3">\n    </span><span class="s1">initializeReexports: boolean | void;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">stringSpecifiers: Set&lt;string&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const localData = getLocalExportMetadata(</span><span class="s3">\n    </span><span class="s1">programPath,</span><span class="s3">\n    </span><span class="s1">initializeReexports,</span><span class="s3">\n    </span><span class="s1">stringSpecifiers,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">const importNodes = new Map&lt;string, t.Node[]&gt;();</span><span class="s3">\n  </span><span class="s1">const sourceData = new Map&lt;string, SourceModuleMetadata&gt;();</span><span class="s3">\n  </span><span class="s1">const getData = (sourceNode: t.StringLiteral, node: t.Node) =&gt; {</span><span class="s3">\n    </span><span class="s1">const source = sourceNode.value;</span><span class="s3">\n\n    </span><span class="s1">let data = sourceData.get(source);</span><span class="s3">\n    </span><span class="s1">if (!data) {</span><span class="s3">\n      </span><span class="s1">data = {</span><span class="s3">\n        </span><span class="s1">name: programPath.scope.generateUidIdentifier(</span><span class="s3">\n          </span><span class="s1">basename(source, extname(source)),</span><span class="s3">\n        </span><span class="s1">).name,</span><span class="s3">\n\n        </span><span class="s1">interop: </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n        </span><span class="s1">loc: null,</span><span class="s3">\n\n        </span><span class="s1">// Data about the requested sources and names.</span><span class="s3">\n        </span><span class="s1">imports: new Map(),</span><span class="s3">\n        </span><span class="s1">importsNamespace: new Set(),</span><span class="s3">\n\n        </span><span class="s1">// Metadata about data that is passed directly from source to export.</span><span class="s3">\n        </span><span class="s1">reexports: new Map(),</span><span class="s3">\n        </span><span class="s1">reexportNamespace: new Set(),</span><span class="s3">\n        </span><span class="s1">reexportAll: null,</span><span class="s3">\n\n        </span><span class="s1">wrap: null,</span><span class="s3">\n\n        </span><span class="s1">// @ts-expect-error lazy is not listed in the type.</span><span class="s3">\n        </span><span class="s1">// This is needed for compatibility with older version of the commonjs</span><span class="s3">\n        </span><span class="s1">// plusing.</span><span class="s3">\n        </span><span class="s1">// TODO(Babel 8): Remove this</span><span class="s3">\n        </span><span class="s1">get lazy() {</span><span class="s3">\n          </span><span class="s1">return this.wrap === </span><span class="s3">\&quot;</span><span class="s1">lazy</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n\n        </span><span class="s1">referenced: false,</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">sourceData.set(source, data);</span><span class="s3">\n      </span><span class="s1">importNodes.set(source, [node]);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">importNodes.get(source).push(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return data;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">let hasExports = false;</span><span class="s3">\n  </span><span class="s1">programPath.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).forEach(child =&gt; {</span><span class="s3">\n    </span><span class="s1">if (child.isImportDeclaration()) {</span><span class="s3">\n      </span><span class="s1">const data = getData(child.node.source, child.node);</span><span class="s3">\n      </span><span class="s1">if (!data.loc) data.loc = child.node.loc;</span><span class="s3">\n\n      </span><span class="s1">child.get(</span><span class="s3">\&quot;</span><span class="s1">specifiers</span><span class="s3">\&quot;</span><span class="s1">).forEach(spec =&gt; {</span><span class="s3">\n        </span><span class="s1">if (spec.isImportDefaultSpecifier()) {</span><span class="s3">\n          </span><span class="s1">const localName = spec.get(</span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">).node.name;</span><span class="s3">\n\n          </span><span class="s1">data.imports.set(localName, </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n          </span><span class="s1">const reexport = localData.get(localName);</span><span class="s3">\n          </span><span class="s1">if (reexport) {</span><span class="s3">\n            </span><span class="s1">localData.delete(localName);</span><span class="s3">\n\n            </span><span class="s1">reexport.names.forEach(name =&gt; {</span><span class="s3">\n              </span><span class="s1">data.reexports.set(name, </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">data.referenced = true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (spec.isImportNamespaceSpecifier()) {</span><span class="s3">\n          </span><span class="s1">const localName = spec.get(</span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">).node.name;</span><span class="s3">\n\n          </span><span class="s1">data.importsNamespace.add(localName);</span><span class="s3">\n          </span><span class="s1">const reexport = localData.get(localName);</span><span class="s3">\n          </span><span class="s1">if (reexport) {</span><span class="s3">\n            </span><span class="s1">localData.delete(localName);</span><span class="s3">\n\n            </span><span class="s1">reexport.names.forEach(name =&gt; {</span><span class="s3">\n              </span><span class="s1">data.reexportNamespace.add(name);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">data.referenced = true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (spec.isImportSpecifier()) {</span><span class="s3">\n          </span><span class="s1">const importName = getExportSpecifierName(</span><span class="s3">\n            </span><span class="s1">spec.get(</span><span class="s3">\&quot;</span><span class="s1">imported</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">stringSpecifiers,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">const localName = spec.get(</span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">).node.name;</span><span class="s3">\n\n          </span><span class="s1">data.imports.set(localName, importName);</span><span class="s3">\n\n          </span><span class="s1">const reexport = localData.get(localName);</span><span class="s3">\n          </span><span class="s1">if (reexport) {</span><span class="s3">\n            </span><span class="s1">localData.delete(localName);</span><span class="s3">\n\n            </span><span class="s1">reexport.names.forEach(name =&gt; {</span><span class="s3">\n              </span><span class="s1">data.reexports.set(name, importName);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">data.referenced = true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else if (child.isExportAllDeclaration()) {</span><span class="s3">\n      </span><span class="s1">hasExports = true;</span><span class="s3">\n      </span><span class="s1">const data = getData(child.node.source, child.node);</span><span class="s3">\n      </span><span class="s1">if (!data.loc) data.loc = child.node.loc;</span><span class="s3">\n\n      </span><span class="s1">data.reexportAll = {</span><span class="s3">\n        </span><span class="s1">loc: child.node.loc,</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">data.referenced = true;</span><span class="s3">\n    </span><span class="s1">} else if (child.isExportNamedDeclaration() &amp;&amp; child.node.source) {</span><span class="s3">\n      </span><span class="s1">hasExports = true;</span><span class="s3">\n      </span><span class="s1">const data = getData(child.node.source, child.node);</span><span class="s3">\n      </span><span class="s1">if (!data.loc) data.loc = child.node.loc;</span><span class="s3">\n\n      </span><span class="s1">child.get(</span><span class="s3">\&quot;</span><span class="s1">specifiers</span><span class="s3">\&quot;</span><span class="s1">).forEach(spec =&gt; {</span><span class="s3">\n        </span><span class="s1">assertExportSpecifier(spec);</span><span class="s3">\n        </span><span class="s1">const importName = getExportSpecifierName(</span><span class="s3">\n          </span><span class="s1">spec.get(</span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">stringSpecifiers,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const exportName = getExportSpecifierName(</span><span class="s3">\n          </span><span class="s1">spec.get(</span><span class="s3">\&quot;</span><span class="s1">exported</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">stringSpecifiers,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">data.reexports.set(exportName, importName);</span><span class="s3">\n        </span><span class="s1">data.referenced = true;</span><span class="s3">\n\n        </span><span class="s1">if (exportName === </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">throw spec</span><span class="s3">\n            </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">exported</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">.buildCodeFrameError('Illegal export </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">.');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">child.isExportNamedDeclaration() ||</span><span class="s3">\n      </span><span class="s1">child.isExportDefaultDeclaration()</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">hasExports = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">for (const metadata of sourceData.values()) {</span><span class="s3">\n    </span><span class="s1">let needsDefault = false;</span><span class="s3">\n    </span><span class="s1">let needsNamed = false;</span><span class="s3">\n\n    </span><span class="s1">if (metadata.importsNamespace.size &gt; 0) {</span><span class="s3">\n      </span><span class="s1">needsDefault = true;</span><span class="s3">\n      </span><span class="s1">needsNamed = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (metadata.reexportAll) {</span><span class="s3">\n      </span><span class="s1">needsNamed = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const importName of metadata.imports.values()) {</span><span class="s3">\n      </span><span class="s1">if (importName === </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">) needsDefault = true;</span><span class="s3">\n      </span><span class="s1">else needsNamed = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (const importName of metadata.reexports.values()) {</span><span class="s3">\n      </span><span class="s1">if (importName === </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">) needsDefault = true;</span><span class="s3">\n      </span><span class="s1">else needsNamed = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (needsDefault &amp;&amp; needsNamed) {</span><span class="s3">\n      </span><span class="s1">// TODO(logan): Using the namespace interop here is unfortunate. Revisit.</span><span class="s3">\n      </span><span class="s1">metadata.interop = </span><span class="s3">\&quot;</span><span class="s1">namespace</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else if (needsDefault) {</span><span class="s3">\n      </span><span class="s1">metadata.interop = </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (getWrapperPayload) {</span><span class="s3">\n    </span><span class="s1">for (const [source, metadata] of sourceData) {</span><span class="s3">\n      </span><span class="s1">metadata.wrap = getWrapperPayload(</span><span class="s3">\n        </span><span class="s1">source,</span><span class="s3">\n        </span><span class="s1">metadata,</span><span class="s3">\n        </span><span class="s1">importNodes.get(source),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">hasExports,</span><span class="s3">\n    </span><span class="s1">local: localData,</span><span class="s3">\n    </span><span class="s1">sources: sourceData,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ModuleBindingKind = </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">hoisted</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get metadata about local variables that are exported.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getLocalExportMetadata(</span><span class="s3">\n  </span><span class="s1">programPath: NodePath&lt;t.Program&gt;,</span><span class="s3">\n  </span><span class="s1">initializeReexports: boolean | void,</span><span class="s3">\n  </span><span class="s1">stringSpecifiers: Set&lt;string&gt;,</span><span class="s3">\n</span><span class="s1">): Map&lt;string, LocalExportMetadata&gt; {</span><span class="s3">\n  </span><span class="s1">const bindingKindLookup = new Map();</span><span class="s3">\n\n  </span><span class="s1">programPath.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).forEach((child: NodePath) =&gt; {</span><span class="s3">\n    </span><span class="s1">let kind: ModuleBindingKind;</span><span class="s3">\n    </span><span class="s1">if (child.isImportDeclaration()) {</span><span class="s3">\n      </span><span class="s1">kind = </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (child.isExportDefaultDeclaration()) {</span><span class="s3">\n        </span><span class="s1">child = child.get(</span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (child.isExportNamedDeclaration()) {</span><span class="s3">\n        </span><span class="s1">if (child.node.declaration) {</span><span class="s3">\n          </span><span class="s1">child = child.get(</span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else if (</span><span class="s3">\n          </span><span class="s1">initializeReexports &amp;&amp;</span><span class="s3">\n          </span><span class="s1">child.node.source &amp;&amp;</span><span class="s3">\n          </span><span class="s1">child.get(</span><span class="s3">\&quot;</span><span class="s1">source</span><span class="s3">\&quot;</span><span class="s1">).isStringLiteral()</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">child.get(</span><span class="s3">\&quot;</span><span class="s1">specifiers</span><span class="s3">\&quot;</span><span class="s1">).forEach(spec =&gt; {</span><span class="s3">\n            </span><span class="s1">assertExportSpecifier(spec);</span><span class="s3">\n            </span><span class="s1">bindingKindLookup.set(spec.get(</span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">).node.name, </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (child.isFunctionDeclaration()) {</span><span class="s3">\n        </span><span class="s1">kind = </span><span class="s3">\&quot;</span><span class="s1">hoisted</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">} else if (child.isClassDeclaration()) {</span><span class="s3">\n        </span><span class="s1">kind = </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">} else if (child.isVariableDeclaration({ kind: </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot; </span><span class="s1">})) {</span><span class="s3">\n        </span><span class="s1">kind = </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">} else if (child.isVariableDeclaration()) {</span><span class="s3">\n        </span><span class="s1">kind = </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">Object.keys(child.getOuterBindingIdentifiers()).forEach(name =&gt; {</span><span class="s3">\n      </span><span class="s1">bindingKindLookup.set(name, kind);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">const localMetadata = new Map();</span><span class="s3">\n  </span><span class="s1">const getLocalMetadata = (idPath: NodePath&lt;t.Identifier&gt;) =&gt; {</span><span class="s3">\n    </span><span class="s1">const localName = idPath.node.name;</span><span class="s3">\n    </span><span class="s1">let metadata = localMetadata.get(localName);</span><span class="s3">\n\n    </span><span class="s1">if (!metadata) {</span><span class="s3">\n      </span><span class="s1">const kind = bindingKindLookup.get(localName);</span><span class="s3">\n\n      </span><span class="s1">if (kind === undefined) {</span><span class="s3">\n        </span><span class="s1">throw idPath.buildCodeFrameError(</span><span class="s3">\n          </span><span class="s1">`Exporting local </span><span class="s3">\&quot;</span><span class="s1">${localName}</span><span class="s3">\&quot;</span><span class="s1">, which is not declared.`,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">metadata = {</span><span class="s3">\n        </span><span class="s1">names: [],</span><span class="s3">\n        </span><span class="s1">kind,</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">localMetadata.set(localName, metadata);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return metadata;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">programPath.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).forEach(child =&gt; {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">child.isExportNamedDeclaration() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(initializeReexports || !child.node.source)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (child.node.declaration) {</span><span class="s3">\n        </span><span class="s1">const declaration = child.get(</span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const ids = declaration.getOuterBindingIdentifierPaths();</span><span class="s3">\n        </span><span class="s1">Object.keys(ids).forEach(name =&gt; {</span><span class="s3">\n          </span><span class="s1">if (name === </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">throw declaration.buildCodeFrameError(</span><span class="s3">\n              </span><span class="s1">'Illegal export </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">.',</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">getLocalMetadata(ids[name]).names.push(name);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">child.get(</span><span class="s3">\&quot;</span><span class="s1">specifiers</span><span class="s3">\&quot;</span><span class="s1">).forEach(spec =&gt; {</span><span class="s3">\n          </span><span class="s1">const local = spec.get(</span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">const exported = spec.get(</span><span class="s3">\&quot;</span><span class="s1">exported</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">const localMetadata = getLocalMetadata(local);</span><span class="s3">\n          </span><span class="s1">const exportName = getExportSpecifierName(exported, stringSpecifiers);</span><span class="s3">\n\n          </span><span class="s1">if (exportName === </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">throw exported.buildCodeFrameError('Illegal export </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">.');</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">localMetadata.names.push(exportName);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (child.isExportDefaultDeclaration()) {</span><span class="s3">\n      </span><span class="s1">const declaration = child.get(</span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">declaration.isFunctionDeclaration() ||</span><span class="s3">\n        </span><span class="s1">declaration.isClassDeclaration()</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): improve babel-types</span><span class="s3">\n        </span><span class="s1">getLocalMetadata(declaration.get(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">)).names.push(</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// These should have been removed by the nameAnonymousExports() call.</span><span class="s3">\n        </span><span class="s1">throw declaration.buildCodeFrameError(</span><span class="s3">\n          \&quot;</span><span class="s1">Unexpected default expression export.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return localMetadata;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Ensure that all exported values have local binding names.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function nameAnonymousExports(programPath: NodePath&lt;t.Program&gt;) {</span><span class="s3">\n  </span><span class="s1">// Name anonymous exported locals.</span><span class="s3">\n  </span><span class="s1">programPath.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).forEach(child =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!child.isExportDefaultDeclaration()) return;</span><span class="s3">\n    </span><span class="s1">splitExportDeclaration(child);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function removeImportExportDeclarations(programPath: NodePath&lt;t.Program&gt;) {</span><span class="s3">\n  </span><span class="s1">programPath.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).forEach(child =&gt; {</span><span class="s3">\n    </span><span class="s1">if (child.isImportDeclaration()) {</span><span class="s3">\n      </span><span class="s1">child.remove();</span><span class="s3">\n    </span><span class="s1">} else if (child.isExportNamedDeclaration()) {</span><span class="s3">\n      </span><span class="s1">if (child.node.declaration) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): avoid mutations</span><span class="s3">\n        </span><span class="s1">child.node.declaration._blockHoist = child.node._blockHoist;</span><span class="s3">\n        </span><span class="s1">child.replaceWith(child.node.declaration);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">child.remove();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (child.isExportDefaultDeclaration()) {</span><span class="s3">\n      </span><span class="s1">// export default foo;</span><span class="s3">\n      </span><span class="s1">const declaration = child.get(</span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">declaration.isFunctionDeclaration() ||</span><span class="s3">\n        </span><span class="s1">declaration.isClassDeclaration()</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): avoid mutations</span><span class="s3">\n        </span><span class="s1">declaration._blockHoist = child.node._blockHoist;</span><span class="s3">\n        </span><span class="s1">child.replaceWith(</span><span class="s3">\n          </span><span class="s1">declaration as NodePath&lt;t.FunctionDeclaration | t.ClassDeclaration&gt;,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// These should have been removed by the nameAnonymousExports() call.</span><span class="s3">\n        </span><span class="s1">throw declaration.buildCodeFrameError(</span><span class="s3">\n          \&quot;</span><span class="s1">Unexpected default expression export.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (child.isExportAllDeclaration()) {</span><span class="s3">\n      </span><span class="s1">child.remove();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AAGA,IAAAC,0BAAA,GAAAD,OAAA;AACA,IAAAE,6BAAA,GAAAF,OAAA;AA6DO,SAASG,UAAUA,CAACC,QAAwB,EAAE;EACnD,OAAOA,QAAQ,CAACD,UAAU;AAC5B;AAKO,SAASE,kBAAkBA,CAACC,MAA4B,EAAE;EAC/D,OACEA,MAAM,CAACC,OAAO,CAACC,IAAI,KAAK,CAAC,IACzBF,MAAM,CAACG,gBAAgB,CAACD,IAAI,KAAK,CAAC,IAClCF,MAAM,CAACI,SAAS,CAACF,IAAI,KAAK,CAAC,IAC3BF,MAAM,CAACK,iBAAiB,CAACH,IAAI,KAAK,CAAC,IACnC,CAACF,MAAM,CAACM,WAAW;AAEvB;AAEO,SAASC,2BAA2BA,CACzCC,aAAkB,EACc;EAChC,IACE,OAAOA,aAAa,KAAK,UAAU,IACnCA,aAAa,KAAK,MAAM,IACxBA,aAAa,KAAK,OAAO,IACzBA,aAAa,KAAK,MAAM,EACxB;IACA,MAAM,IAAIC,KAAK,CACZ,gHAA+GD,aAAc,IAChI,CAAC;EACH;EACA,OAAOA,aAAa;AACtB;AAEA,SAASE,oBAAoBA,CAC3BF,aAA4B,EAC5BR,MAAc,EACdW,QAA4B,EAC5B;EACA,IAAI,OAAOH,aAAa,KAAK,UAAU,EAAE;IACvC,OAAOD,2BAA2B,CAACC,aAAa,CAACR,MAAM,EAAEW,QAAQ,CAAC,CAAC;EACrE;EACA,OAAOH,aAAa;AACtB;AAMe,SAASI,8BAA8BA,CACpDC,WAAgC,EAChCC,UAAkB,EAClB;EACEN,aAAa;EACbO,mBAAmB,GAAG,KAAK;EAC3BC,iBAAiB;EACjBC,eAAe,GAAG,KAAK;EACvBN;AAWF,CAAC,EACe;EAChB,IAAI,CAACG,UAAU,EAAE;IACfA,UAAU,GAAGD,WAAW,CAACK,KAAK,CAACC,qBAAqB,CAAC,SAAS,CAAC,CAACC,IAAI;EACtE;EACA,MAAMC,gBAAgB,GAAG,IAAIC,GAAG,CAAS,CAAC;EAE1CC,oBAAoB,CAACV,WAAW,CAAC;EAEjC,MAAM;IAAEW,KAAK;IAAEC,OAAO;IAAE5B;EAAW,CAAC,GAAG6B,iBAAiB,CACtDb,WAAW,EACX;IAAEE,mBAAmB;IAAEC;EAAkB,CAAC,EAC1CK,gBACF,CAAC;EAEDM,8BAA8B,CAACd,WAAW,CAAC;EAG3C,KAAK,MAAM,CAACb,MAAM,EAAEF,QAAQ,CAAC,IAAI2B,OAAO,EAAE;IACxC,MAAM;MAAEtB,gBAAgB;MAAEF;IAAQ,CAAC,GAAGH,QAAQ;IAE9C,IAAIK,gBAAgB,CAACD,IAAI,GAAG,CAAC,IAAID,OAAO,CAACC,IAAI,KAAK,CAAC,EAAE;MACnD,MAAM,CAAC0B,eAAe,CAAC,GAAGzB,gBAAgB;MAC1CL,QAAQ,CAACsB,IAAI,GAAGQ,eAAe;IACjC;IAEA,MAAMC,eAAe,GAAGnB,oBAAoB,CAC1CF,aAAa,EACbR,MAAM,EACNW,QACF,CAAC;IAED,IAAIkB,eAAe,KAAK,MAAM,EAAE;MAC9B/B,QAAQ,CAACgC,OAAO,GAAG,MAAM;IAC3B,CAAC,MAAM,IAAID,eAAe,KAAK,MAAM,IAAI/B,QAAQ,CAACgC,OAAO,KAAK,WAAW,EAAE;MACzEhC,QAAQ,CAACgC,OAAO,GAAG,gBAAgB;IACrC,CAAC,MAAM,IAAID,eAAe,KAAK,MAAM,IAAI/B,QAAQ,CAACgC,OAAO,KAAK,SAAS,EAAE;MACvEhC,QAAQ,CAACgC,OAAO,GAAG,cAAc;IACnC,CAAC,MAAM,IAAIb,eAAe,IAAInB,QAAQ,CAACgC,OAAO,KAAK,WAAW,EAAE;MAM9DhC,QAAQ,CAACgC,OAAO,GAAG,SAAS;IAC9B;EACF;EAEA,OAAO;IACLhB,UAAU;IACViB,kBAAkB,EAAE,IAAI;IACxBlC,UAAU;IACV2B,KAAK;IACLxB,MAAM,EAAEyB,OAAO;IACfJ;EACF,CAAC;AACH;AAEA,SAASW,sBAAsBA,CAC7BC,IAAc,EACdZ,gBAA6B,EACrB;EACR,IAAIY,IAAI,CAACC,YAAY,CAAC,CAAC,EAAE;IACvB,OAAOD,IAAI,CAACE,IAAI,CAACf,IAAI;EACvB,CAAC,MAAM,IAAIa,IAAI,CAACG,eAAe,CAAC,CAAC,EAAE;IACjC,MAAMC,WAAW,GAAGJ,IAAI,CAACE,IAAI,CAACG,KAAK;IAOnC,IAAI,CAAC,IAAAC,2CAAgB,EAACF,WAAW,CAAC,EAAE;MAClChB,gBAAgB,CAACmB,GAAG,CAACH,WAAW,CAAC;IACnC;IACA,OAAOA,WAAW;EACpB,CAAC,MAAM;IACL,MAAM,IAAI5B,KAAK,CACZ,2EAA0EwB,IAAI,CAACE,IAAI,CAACM,IAAK,EAC5F,CAAC;EACH;AACF;AAEA,SAASC,qBAAqBA,CAC5BT,IAAc,EAC+B;EAC7C,IAAIA,IAAI,CAACU,iBAAiB,CAAC,CAAC,EAAE;IAC5B;EACF,CAAC,MAAM,IAAIV,IAAI,CAACW,0BAA0B,CAAC,CAAC,EAAE;IAC5C,MAAMX,IAAI,CAACY,mBAAmB,CAC5B,kGACF,CAAC;EACH,CAAC,MAAM;IACL,MAAMZ,IAAI,CAACY,mBAAmB,CAAC,kCAAkC,CAAC;EACpE;AACF;AAKA,SAASnB,iBAAiBA,CACxBb,WAAgC,EAChC;EACEG,iBAAiB;EACjBD;AAQF,CAAC,EACDM,gBAA6B,EAC7B;EACA,MAAMyB,SAAS,GAAGC,sBAAsB,CACtClC,WAAW,EACXE,mBAAmB,EACnBM,gBACF,CAAC;EAED,MAAM2B,WAAW,GAAG,IAAIC,GAAG,CAAmB,CAAC;EAC/C,MAAMC,UAAU,GAAG,IAAID,GAAG,CAA+B,CAAC;EAC1D,MAAME,OAAO,GAAGA,CAACC,UAA2B,EAAEjB,IAAY,KAAK;IAC7D,MAAMnC,MAAM,GAAGoD,UAAU,CAACd,KAAK;IAE/B,IAAIe,IAAI,GAAGH,UAAU,CAACI,GAAG,CAACtD,MAAM,CAAC;IACjC,IAAI,CAACqD,IAAI,EAAE;MACTA,IAAI,GAAG;QACLjC,IAAI,EAAEP,WAAW,CAACK,KAAK,CAACC,qBAAqB,CAC3C,IAAAoC,cAAQ,EAACvD,MAAM,EAAE,IAAAwD,aAAO,EAACxD,MAAM,CAAC,CAClC,CAAC,CAACoB,IAAI;QAENU,OAAO,EAAE,MAAM;QAEf2B,GAAG,EAAE,IAAI;QAGTxD,OAAO,EAAE,IAAIgD,GAAG,CAAC,CAAC;QAClB9C,gBAAgB,EAAE,IAAImB,GAAG,CAAC,CAAC;QAG3BlB,SAAS,EAAE,IAAI6C,GAAG,CAAC,CAAC;QACpB5C,iBAAiB,EAAE,IAAIiB,GAAG,CAAC,CAAC;QAC5BhB,WAAW,EAAE,IAAI;QAEjBoD,IAAI,EAAE,IAAI;QAMV,IAAIC,IAAIA,CAAA,EAAG;UACT,OAAO,IAAI,CAACD,IAAI,KAAK,MAAM;QAC7B,CAAC;QAEDE,UAAU,EAAE;MACd,CAAC;MACDV,UAAU,CAACW,GAAG,CAAC7D,MAAM,EAAEqD,IAAI,CAAC;MAC5BL,WAAW,CAACa,GAAG,CAAC7D,MAAM,EAAE,CAACmC,IAAI,CAAC,CAAC;IACjC,CAAC,MAAM;MACLa,WAAW,CAACM,GAAG,CAACtD,MAAM,CAAC,CAAC8D,IAAI,CAAC3B,IAAI,CAAC;IACpC;IACA,OAAOkB,IAAI;EACb,CAAC;EACD,IAAIxD,UAAU,GAAG,KAAK;EACtBgB,WAAW,CAACyC,GAAG,CAAC,MAAM,CAAC,CAACS,OAAO,CAACC,KAAK,IAAI;IACvC,IAAIA,KAAK,CAACC,mBAAmB,CAAC,CAAC,EAAE;MAC/B,MAAMZ,IAAI,GAAGF,OAAO,CAACa,KAAK,CAAC7B,IAAI,CAACnC,MAAM,EAAEgE,KAAK,CAAC7B,IAAI,CAAC;MACnD,IAAI,CAACkB,IAAI,CAACI,GAAG,EAAEJ,IAAI,CAACI,GAAG,GAAGO,KAAK,CAAC7B,IAAI,CAACsB,GAAG;MAExCO,KAAK,CAACV,GAAG,CAAC,YAAY,CAAC,CAACS,OAAO,CAACG,IAAI,IAAI;QACtC,IAAIA,IAAI,CAACC,wBAAwB,CAAC,CAAC,EAAE;UACnC,MAAMC,SAAS,GAAGF,IAAI,CAACZ,GAAG,CAAC,OAAO,CAAC,CAACnB,IAAI,CAACf,IAAI;UAE7CiC,IAAI,CAACpD,OAAO,CAAC4D,GAAG,CAACO,SAAS,EAAE,SAAS,CAAC;UAEtC,MAAMC,QAAQ,GAAGvB,SAAS,CAACQ,GAAG,CAACc,SAAS,CAAC;UACzC,IAAIC,QAAQ,EAAE;YACZvB,SAAS,CAACwB,MAAM,CAACF,SAAS,CAAC;YAE3BC,QAAQ,CAACE,KAAK,CAACR,OAAO,CAAC3C,IAAI,IAAI;cAC7BiC,IAAI,CAACjD,SAAS,CAACyD,GAAG,CAACzC,IAAI,EAAE,SAAS,CAAC;YACrC,CAAC,CAAC;YACFiC,IAAI,CAACO,UAAU,GAAG,IAAI;UACxB;QACF,CAAC,MAAM,IAAIM,IAAI,CAACM,0BAA0B,CAAC,CAAC,EAAE;UAC5C,MAAMJ,SAAS,GAAGF,IAAI,CAACZ,GAAG,CAAC,OAAO,CAAC,CAACnB,IAAI,CAACf,IAAI;UAE7CiC,IAAI,CAAClD,gBAAgB,CAACqC,GAAG,CAAC4B,SAAS,CAAC;UACpC,MAAMC,QAAQ,GAAGvB,SAAS,CAACQ,GAAG,CAACc,SAAS,CAAC;UACzC,IAAIC,QAAQ,EAAE;YACZvB,SAAS,CAACwB,MAAM,CAACF,SAAS,CAAC;YAE3BC,QAAQ,CAACE,KAAK,CAACR,OAAO,CAAC3C,IAAI,IAAI;cAC7BiC,IAAI,CAAChD,iBAAiB,CAACmC,GAAG,CAACpB,IAAI,CAAC;YAClC,CAAC,CAAC;YACFiC,IAAI,CAACO,UAAU,GAAG,IAAI;UACxB;QACF,CAAC,MAAM,IAAIM,IAAI,CAACO,iBAAiB,CAAC,CAAC,EAAE;UACnC,MAAMC,UAAU,GAAG1C,sBAAsB,CACvCkC,IAAI,CAACZ,GAAG,CAAC,UAAU,CAAC,EACpBjC,gBACF,CAAC;UACD,MAAM+C,SAAS,GAAGF,IAAI,CAACZ,GAAG,CAAC,OAAO,CAAC,CAACnB,IAAI,CAACf,IAAI;UAE7CiC,IAAI,CAACpD,OAAO,CAAC4D,GAAG,CAACO,SAAS,EAAEM,UAAU,CAAC;UAEvC,MAAML,QAAQ,GAAGvB,SAAS,CAACQ,GAAG,CAACc,SAAS,CAAC;UACzC,IAAIC,QAAQ,EAAE;YACZvB,SAAS,CAACwB,MAAM,CAACF,SAAS,CAAC;YAE3BC,QAAQ,CAACE,KAAK,CAACR,OAAO,CAAC3C,IAAI,IAAI;cAC7BiC,IAAI,CAACjD,SAAS,CAACyD,GAAG,CAACzC,IAAI,EAAEsD,UAAU,CAAC;YACtC,CAAC,CAAC;YACFrB,IAAI,CAACO,UAAU,GAAG,IAAI;UACxB;QACF;MACF,CAAC,CAAC;IACJ,CAAC,MAAM,IAAII,KAAK,CAACW,sBAAsB,CAAC,CAAC,EAAE;MACzC9E,UAAU,GAAG,IAAI;MACjB,MAAMwD,IAAI,GAAGF,OAAO,CAACa,KAAK,CAAC7B,IAAI,CAACnC,MAAM,EAAEgE,KAAK,CAAC7B,IAAI,CAAC;MACnD,IAAI,CAACkB,IAAI,CAACI,GAAG,EAAEJ,IAAI,CAACI,GAAG,GAAGO,KAAK,CAAC7B,IAAI,CAACsB,GAAG;MAExCJ,IAAI,CAAC/C,WAAW,GAAG;QACjBmD,GAAG,EAAEO,KAAK,CAAC7B,IAAI,CAACsB;MAClB,CAAC;MACDJ,IAAI,CAACO,UAAU,GAAG,IAAI;IACxB,CAAC,MAAM,IAAII,KAAK,CAACY,wBAAwB,CAAC,CAAC,IAAIZ,KAAK,CAAC7B,IAAI,CAACnC,MAAM,EAAE;MAChEH,UAAU,GAAG,IAAI;MACjB,MAAMwD,IAAI,GAAGF,OAAO,CAACa,KAAK,CAAC7B,IAAI,CAACnC,MAAM,EAAEgE,KAAK,CAAC7B,IAAI,CAAC;MACnD,IAAI,CAACkB,IAAI,CAACI,GAAG,EAAEJ,IAAI,CAACI,GAAG,GAAGO,KAAK,CAAC7B,IAAI,CAACsB,GAAG;MAExCO,KAAK,CAACV,GAAG,CAAC,YAAY,CAAC,CAACS,OAAO,CAACG,IAAI,IAAI;QACtCxB,qBAAqB,CAACwB,IAAI,CAAC;QAC3B,MAAMQ,UAAU,GAAG1C,sBAAsB,CACvCkC,IAAI,CAACZ,GAAG,CAAC,OAAO,CAAC,EACjBjC,gBACF,CAAC;QACD,MAAMP,UAAU,GAAGkB,sBAAsB,CACvCkC,IAAI,CAACZ,GAAG,CAAC,UAAU,CAAC,EACpBjC,gBACF,CAAC;QAEDgC,IAAI,CAACjD,SAAS,CAACyD,GAAG,CAAC/C,UAAU,EAAE4D,UAAU,CAAC;QAC1CrB,IAAI,CAACO,UAAU,GAAG,IAAI;QAEtB,IAAI9C,UAAU,KAAK,YAAY,EAAE;UAC/B,MAAMoD,IAAI,CACPZ,GAAG,CAAC,UAAU,CAAC,CACfT,mBAAmB,CAAC,8BAA8B,CAAC;QACxD;MACF,CAAC,CAAC;IACJ,CAAC,MAAM,IACLmB,KAAK,CAACY,wBAAwB,CAAC,CAAC,IAChCZ,KAAK,CAACa,0BAA0B,CAAC,CAAC,EAClC;MACAhF,UAAU,GAAG,IAAI;IACnB;EACF,CAAC,CAAC;EAEF,KAAK,MAAMC,QAAQ,IAAIoD,UAAU,CAAC4B,MAAM,CAAC,CAAC,EAAE;IAC1C,IAAIC,YAAY,GAAG,KAAK;IACxB,IAAIC,UAAU,GAAG,KAAK;IAEtB,IAAIlF,QAAQ,CAACK,gBAAgB,CAACD,IAAI,GAAG,CAAC,EAAE;MACtC6E,YAAY,GAAG,IAAI;MACnBC,UAAU,GAAG,IAAI;IACnB;IAEA,IAAIlF,QAAQ,CAACQ,WAAW,EAAE;MACxB0E,UAAU,GAAG,IAAI;IACnB;IAEA,KAAK,MAAMN,UAAU,IAAI5E,QAAQ,CAACG,OAAO,CAAC6E,MAAM,CAAC,CAAC,EAAE;MAClD,IAAIJ,UAAU,KAAK,SAAS,EAAEK,YAAY,GAAG,IAAI,CAAC,KAC7CC,UAAU,GAAG,IAAI;IACxB;IACA,KAAK,MAAMN,UAAU,IAAI5E,QAAQ,CAACM,SAAS,CAAC0E,MAAM,CAAC,CAAC,EAAE;MACpD,IAAIJ,UAAU,KAAK,SAAS,EAAEK,YAAY,GAAG,IAAI,CAAC,KAC7CC,UAAU,GAAG,IAAI;IACxB;IAEA,IAAID,YAAY,IAAIC,UAAU,EAAE;MAE9BlF,QAAQ,CAACgC,OAAO,GAAG,WAAW;IAChC,CAAC,MAAM,IAAIiD,YAAY,EAAE;MACvBjF,QAAQ,CAACgC,OAAO,GAAG,SAAS;IAC9B;EACF;EAEA,IAAId,iBAAiB,EAAE;IACrB,KAAK,MAAM,CAAChB,MAAM,EAAEF,QAAQ,CAAC,IAAIoD,UAAU,EAAE;MAC3CpD,QAAQ,CAAC4D,IAAI,GAAG1C,iBAAiB,CAC/BhB,MAAM,EACNF,QAAQ,EACRkD,WAAW,CAACM,GAAG,CAACtD,MAAM,CACxB,CAAC;IACH;EACF;EAEA,OAAO;IACLH,UAAU;IACV2B,KAAK,EAAEsB,SAAS;IAChBrB,OAAO,EAAEyB;EACX,CAAC;AACH;AAMA,SAASH,sBAAsBA,CAC7BlC,WAAgC,EAChCE,mBAAmC,EACnCM,gBAA6B,EACK;EAClC,MAAM4D,iBAAiB,GAAG,IAAIhC,GAAG,CAAC,CAAC;EAEnCpC,WAAW,CAACyC,GAAG,CAAC,MAAM,CAAC,CAACS,OAAO,CAAEC,KAAe,IAAK;IACnD,IAAIkB,IAAuB;IAC3B,IAAIlB,KAAK,CAACC,mBAAmB,CAAC,CAAC,EAAE;MAC/BiB,IAAI,GAAG,QAAQ;IACjB,CAAC,MAAM;MACL,IAAIlB,KAAK,CAACa,0BAA0B,CAAC,CAAC,EAAE;QACtCb,KAAK,GAAGA,KAAK,CAACV,GAAG,CAAC,aAAa,CAAC;MAClC;MACA,IAAIU,KAAK,CAACY,wBAAwB,CAAC,CAAC,EAAE;QACpC,IAAIZ,KAAK,CAAC7B,IAAI,CAACgD,WAAW,EAAE;UAC1BnB,KAAK,GAAGA,KAAK,CAACV,GAAG,CAAC,aAAa,CAAC;QAClC,CAAC,MAAM,IACLvC,mBAAmB,IACnBiD,KAAK,CAAC7B,IAAI,CAACnC,MAAM,IACjBgE,KAAK,CAACV,GAAG,CAAC,QAAQ,CAAC,CAAClB,eAAe,CAAC,CAAC,EACrC;UACA4B,KAAK,CAACV,GAAG,CAAC,YAAY,CAAC,CAACS,OAAO,CAACG,IAAI,IAAI;YACtCxB,qBAAqB,CAACwB,IAAI,CAAC;YAC3Be,iBAAiB,CAACpB,GAAG,CAACK,IAAI,CAACZ,GAAG,CAAC,OAAO,CAAC,CAACnB,IAAI,CAACf,IAAI,EAAE,OAAO,CAAC;UAC7D,CAAC,CAAC;UACF;QACF;MACF;MAEA,IAAI4C,KAAK,CAACoB,qBAAqB,CAAC,CAAC,EAAE;QACjCF,IAAI,GAAG,SAAS;MAClB,CAAC,MAAM,IAAIlB,KAAK,CAACqB,kBAAkB,CAAC,CAAC,EAAE;QACrCH,IAAI,GAAG,OAAO;MAChB,CAAC,MAAM,IAAIlB,KAAK,CAACsB,qBAAqB,CAAC;QAAEJ,IAAI,EAAE;MAAM,CAAC,CAAC,EAAE;QACvDA,IAAI,GAAG,KAAK;MACd,CAAC,MAAM,IAAIlB,KAAK,CAACsB,qBAAqB,CAAC,CAAC,EAAE;QACxCJ,IAAI,GAAG,OAAO;MAChB,CAAC,MAAM;QACL;MACF;IACF;IAEAK,MAAM,CAACC,IAAI,CAACxB,KAAK,CAACyB,0BAA0B,CAAC,CAAC,CAAC,CAAC1B,OAAO,CAAC3C,IAAI,IAAI;MAC9D6D,iBAAiB,CAACpB,GAAG,CAACzC,IAAI,EAAE8D,IAAI,CAAC;IACnC,CAAC,CAAC;EACJ,CAAC,CAAC;EAEF,MAAMQ,aAAa,GAAG,IAAIzC,GAAG,CAAC,CAAC;EAC/B,MAAM0C,gBAAgB,GAAIC,MAA8B,IAAK;IAC3D,MAAMxB,SAAS,GAAGwB,MAAM,CAACzD,IAAI,CAACf,IAAI;IAClC,IAAItB,QAAQ,GAAG4F,aAAa,CAACpC,GAAG,CAACc,SAAS,CAAC;IAE3C,IAAI,CAACtE,QAAQ,EAAE;MACb,MAAMoF,IAAI,GAAGD,iBAAiB,CAAC3B,GAAG,CAACc,SAAS,CAAC;MAE7C,IAAIc,IAAI,KAAKW,SAAS,EAAE;QACtB,MAAMD,MAAM,CAAC/C,mBAAmB,CAC7B,oBAAmBuB,SAAU,2BAChC,CAAC;MACH;MAEAtE,QAAQ,GAAG;QACTyE,KAAK,EAAE,EAAE;QACTW;MACF,CAAC;MACDQ,aAAa,CAAC7B,GAAG,CAACO,SAAS,EAAEtE,QAAQ,CAAC;IACxC;IACA,OAAOA,QAAQ;EACjB,CAAC;EAEDe,WAAW,CAACyC,GAAG,CAAC,MAAM,CAAC,CAACS,OAAO,CAACC,KAAK,IAAI;IACvC,IACEA,KAAK,CAACY,wBAAwB,CAAC,CAAC,KAC/B7D,mBAAmB,IAAI,CAACiD,KAAK,CAAC7B,IAAI,CAACnC,MAAM,CAAC,EAC3C;MACA,IAAIgE,KAAK,CAAC7B,IAAI,CAACgD,WAAW,EAAE;QAC1B,MAAMA,WAAW,GAAGnB,KAAK,CAACV,GAAG,CAAC,aAAa,CAAC;QAC5C,MAAMwC,GAAG,GAAGX,WAAW,CAACY,8BAA8B,CAAC,CAAC;QACxDR,MAAM,CAACC,IAAI,CAACM,GAAG,CAAC,CAAC/B,OAAO,CAAC3C,IAAI,IAAI;UAC/B,IAAIA,IAAI,KAAK,YAAY,EAAE;YACzB,MAAM+D,WAAW,CAACtC,mBAAmB,CACnC,8BACF,CAAC;UACH;UACA8C,gBAAgB,CAACG,GAAG,CAAC1E,IAAI,CAAC,CAAC,CAACmD,KAAK,CAACT,IAAI,CAAC1C,IAAI,CAAC;QAC9C,CAAC,CAAC;MACJ,CAAC,MAAM;QACL4C,KAAK,CAACV,GAAG,CAAC,YAAY,CAAC,CAACS,OAAO,CAACG,IAAI,IAAI;UACtC,MAAM1C,KAAK,GAAG0C,IAAI,CAACZ,GAAG,CAAC,OAAO,CAAC;UAC/B,MAAM0C,QAAQ,GAAG9B,IAAI,CAACZ,GAAG,CAAC,UAAU,CAAC;UACrC,MAAMoC,aAAa,GAAGC,gBAAgB,CAACnE,KAAK,CAAC;UAC7C,MAAMV,UAAU,GAAGkB,sBAAsB,CAACgE,QAAQ,EAAE3E,gBAAgB,CAAC;UAErE,IAAIP,UAAU,KAAK,YAAY,EAAE;YAC/B,MAAMkF,QAAQ,CAACnD,mBAAmB,CAAC,8BAA8B,CAAC;UACpE;UACA6C,aAAa,CAACnB,KAAK,CAACT,IAAI,CAAChD,UAAU,CAAC;QACtC,CAAC,CAAC;MACJ;IACF,CAAC,MAAM,IAAIkD,KAAK,CAACa,0BAA0B,CAAC,CAAC,EAAE;MAC7C,MAAMM,WAAW,GAAGnB,KAAK,CAACV,GAAG,CAAC,aAAa,CAAC;MAC5C,IACE6B,WAAW,CAACC,qBAAqB,CAAC,CAAC,IACnCD,WAAW,CAACE,kBAAkB,CAAC,CAAC,EAChC;QAEAM,gBAAgB,CAACR,WAAW,CAAC7B,GAAG,CAAC,IAAI,CAAC,CAAC,CAACiB,KAAK,CAACT,IAAI,CAAC,SAAS,CAAC;MAC/D,CAAC,MAAM;QAEL,MAAMqB,WAAW,CAACtC,mBAAmB,CACnC,uCACF,CAAC;MACH;IACF;EACF,CAAC,CAAC;EACF,OAAO6C,aAAa;AACtB;AAKA,SAASnE,oBAAoBA,CAACV,WAAgC,EAAE;EAE9DA,WAAW,CAACyC,GAAG,CAAC,MAAM,CAAC,CAACS,OAAO,CAACC,KAAK,IAAI;IACvC,IAAI,CAACA,KAAK,CAACa,0BAA0B,CAAC,CAAC,EAAE;IACzC,IAAAoB,qCAAsB,EAACjC,KAAK,CAAC;EAC/B,CAAC,CAAC;AACJ;AAEA,SAASrC,8BAA8BA,CAACd,WAAgC,EAAE;EACxEA,WAAW,CAACyC,GAAG,CAAC,MAAM,CAAC,CAACS,OAAO,CAACC,KAAK,IAAI;IACvC,IAAIA,KAAK,CAACC,mBAAmB,CAAC,CAAC,EAAE;MAC/BD,KAAK,CAACkC,MAAM,CAAC,CAAC;IAChB,CAAC,MAAM,IAAIlC,KAAK,CAACY,wBAAwB,CAAC,CAAC,EAAE;MAC3C,IAAIZ,KAAK,CAAC7B,IAAI,CAACgD,WAAW,EAAE;QAE1BnB,KAAK,CAAC7B,IAAI,CAACgD,WAAW,CAACgB,WAAW,GAAGnC,KAAK,CAAC7B,IAAI,CAACgE,WAAW;QAC3DnC,KAAK,CAACoC,WAAW,CAACpC,KAAK,CAAC7B,IAAI,CAACgD,WAAW,CAAC;MAC3C,CAAC,MAAM;QACLnB,KAAK,CAACkC,MAAM,CAAC,CAAC;MAChB;IACF,CAAC,MAAM,IAAIlC,KAAK,CAACa,0BAA0B,CAAC,CAAC,EAAE;MAE7C,MAAMM,WAAW,GAAGnB,KAAK,CAACV,GAAG,CAAC,aAAa,CAAC;MAC5C,IACE6B,WAAW,CAACC,qBAAqB,CAAC,CAAC,IACnCD,WAAW,CAACE,kBAAkB,CAAC,CAAC,EAChC;QAEAF,WAAW,CAACgB,WAAW,GAAGnC,KAAK,CAAC7B,IAAI,CAACgE,WAAW;QAChDnC,KAAK,CAACoC,WAAW,CACfjB,WACF,CAAC;MACH,CAAC,MAAM;QAEL,MAAMA,WAAW,CAACtC,mBAAmB,CACnC,uCACF,CAAC;MACH;IACF,CAAC,MAAM,IAAImB,KAAK,CAACW,sBAAsB,CAAC,CAAC,EAAE;MACzCX,KAAK,CAACkC,MAAM,CAAC,CAAC;IAChB;EACF,CAAC,CAAC;AACJ&quot;</span><span class="s0">}</span></pre>
</body>
</html>