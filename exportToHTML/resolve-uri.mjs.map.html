<html>
<head>
<title>resolve-uri.mjs.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
resolve-uri.mjs.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;resolve-uri.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/resolve-uri.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// Matches the scheme of a URL, eg </span><span class="s3">\&quot;</span><span class="s1">http://</span><span class="s3">\&quot;\n</span><span class="s1">const schemeRegex = /^[</span><span class="s3">\\</span><span class="s1">w+.-]+:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">//;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Matches the parts of a URL:</span><span class="s3">\n </span><span class="s1">* 1. Scheme, including </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">, guaranteed.</span><span class="s3">\n </span><span class="s1">* 2. User/password, including </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">, optional.</span><span class="s3">\n </span><span class="s1">* 3. Host, guaranteed.</span><span class="s3">\n </span><span class="s1">* 4. Port, including </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">, optional.</span><span class="s3">\n </span><span class="s1">* 5. Path, including </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">, optional.</span><span class="s3">\n </span><span class="s1">* 6. Query, including </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">, optional.</span><span class="s3">\n </span><span class="s1">* 7. Hash, including </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">, optional.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const urlRegex = /^([</span><span class="s3">\\</span><span class="s1">w+.-]+:)</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/([^@/#?]*@)?([^:/#?]*)(:</span><span class="s3">\\</span><span class="s1">d+)?(</span><span class="s3">\\</span><span class="s1">/[^#?]*)?(</span><span class="s3">\\</span><span class="s1">?[^#]*)?(#.*)?/;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start</span><span class="s3">\n </span><span class="s1">* with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* 1. Host, optional.</span><span class="s3">\n </span><span class="s1">* 2. Path, which may include </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">, guaranteed.</span><span class="s3">\n </span><span class="s1">* 3. Query, including </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">, optional.</span><span class="s3">\n </span><span class="s1">* 4. Hash, including </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">, optional.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const fileRegex = /^file:(?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/((?![a-z]:)[^/#?]*)?)?(</span><span class="s3">\\</span><span class="s1">/?[^#?]*)(</span><span class="s3">\\</span><span class="s1">?[^#]*)?(#.*)?/i;</span><span class="s3">\n\n</span><span class="s1">type Url = {</span><span class="s3">\n  </span><span class="s1">scheme: string;</span><span class="s3">\n  </span><span class="s1">user: string;</span><span class="s3">\n  </span><span class="s1">host: string;</span><span class="s3">\n  </span><span class="s1">port: string;</span><span class="s3">\n  </span><span class="s1">path: string;</span><span class="s3">\n  </span><span class="s1">query: string;</span><span class="s3">\n  </span><span class="s1">hash: string;</span><span class="s3">\n  </span><span class="s1">type: UrlType;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">enum UrlType {</span><span class="s3">\n  </span><span class="s1">Empty = 1,</span><span class="s3">\n  </span><span class="s1">Hash = 2,</span><span class="s3">\n  </span><span class="s1">Query = 3,</span><span class="s3">\n  </span><span class="s1">RelativePath = 4,</span><span class="s3">\n  </span><span class="s1">AbsolutePath = 5,</span><span class="s3">\n  </span><span class="s1">SchemeRelative = 6,</span><span class="s3">\n  </span><span class="s1">Absolute = 7,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isAbsoluteUrl(input: string): boolean {</span><span class="s3">\n  </span><span class="s1">return schemeRegex.test(input);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isSchemeRelativeUrl(input: string): boolean {</span><span class="s3">\n  </span><span class="s1">return input.startsWith('//');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isAbsolutePath(input: string): boolean {</span><span class="s3">\n  </span><span class="s1">return input.startsWith('/');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isFileUrl(input: string): boolean {</span><span class="s3">\n  </span><span class="s1">return input.startsWith('file:');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isRelative(input: string): boolean {</span><span class="s3">\n  </span><span class="s1">return /^[.?#]/.test(input);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function parseAbsoluteUrl(input: string): Url {</span><span class="s3">\n  </span><span class="s1">const match = urlRegex.exec(input)!;</span><span class="s3">\n  </span><span class="s1">return makeUrl(</span><span class="s3">\n    </span><span class="s1">match[1],</span><span class="s3">\n    </span><span class="s1">match[2] || '',</span><span class="s3">\n    </span><span class="s1">match[3],</span><span class="s3">\n    </span><span class="s1">match[4] || '',</span><span class="s3">\n    </span><span class="s1">match[5] || '/',</span><span class="s3">\n    </span><span class="s1">match[6] || '',</span><span class="s3">\n    </span><span class="s1">match[7] || '',</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function parseFileUrl(input: string): Url {</span><span class="s3">\n  </span><span class="s1">const match = fileRegex.exec(input)!;</span><span class="s3">\n  </span><span class="s1">const path = match[2];</span><span class="s3">\n  </span><span class="s1">return makeUrl(</span><span class="s3">\n    </span><span class="s1">'file:',</span><span class="s3">\n    </span><span class="s1">'',</span><span class="s3">\n    </span><span class="s1">match[1] || '',</span><span class="s3">\n    </span><span class="s1">'',</span><span class="s3">\n    </span><span class="s1">isAbsolutePath(path) ? path : '/' + path,</span><span class="s3">\n    </span><span class="s1">match[3] || '',</span><span class="s3">\n    </span><span class="s1">match[4] || '',</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function makeUrl(</span><span class="s3">\n  </span><span class="s1">scheme: string,</span><span class="s3">\n  </span><span class="s1">user: string,</span><span class="s3">\n  </span><span class="s1">host: string,</span><span class="s3">\n  </span><span class="s1">port: string,</span><span class="s3">\n  </span><span class="s1">path: string,</span><span class="s3">\n  </span><span class="s1">query: string,</span><span class="s3">\n  </span><span class="s1">hash: string,</span><span class="s3">\n</span><span class="s1">): Url {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">scheme,</span><span class="s3">\n    </span><span class="s1">user,</span><span class="s3">\n    </span><span class="s1">host,</span><span class="s3">\n    </span><span class="s1">port,</span><span class="s3">\n    </span><span class="s1">path,</span><span class="s3">\n    </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">hash,</span><span class="s3">\n    </span><span class="s1">type: UrlType.Absolute,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function parseUrl(input: string): Url {</span><span class="s3">\n  </span><span class="s1">if (isSchemeRelativeUrl(input)) {</span><span class="s3">\n    </span><span class="s1">const url = parseAbsoluteUrl('http:' + input);</span><span class="s3">\n    </span><span class="s1">url.scheme = '';</span><span class="s3">\n    </span><span class="s1">url.type = UrlType.SchemeRelative;</span><span class="s3">\n    </span><span class="s1">return url;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isAbsolutePath(input)) {</span><span class="s3">\n    </span><span class="s1">const url = parseAbsoluteUrl('http://foo.com' + input);</span><span class="s3">\n    </span><span class="s1">url.scheme = '';</span><span class="s3">\n    </span><span class="s1">url.host = '';</span><span class="s3">\n    </span><span class="s1">url.type = UrlType.AbsolutePath;</span><span class="s3">\n    </span><span class="s1">return url;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isFileUrl(input)) return parseFileUrl(input);</span><span class="s3">\n\n  </span><span class="s1">if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);</span><span class="s3">\n\n  </span><span class="s1">const url = parseAbsoluteUrl('http://foo.com/' + input);</span><span class="s3">\n  </span><span class="s1">url.scheme = '';</span><span class="s3">\n  </span><span class="s1">url.host = '';</span><span class="s3">\n  </span><span class="s1">url.type = input</span><span class="s3">\n    </span><span class="s1">? input.startsWith('?')</span><span class="s3">\n      </span><span class="s1">? UrlType.Query</span><span class="s3">\n      </span><span class="s1">: input.startsWith('#')</span><span class="s3">\n      </span><span class="s1">? UrlType.Hash</span><span class="s3">\n      </span><span class="s1">: UrlType.RelativePath</span><span class="s3">\n    </span><span class="s1">: UrlType.Empty;</span><span class="s3">\n  </span><span class="s1">return url;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function stripPathFilename(path: string): string {</span><span class="s3">\n  </span><span class="s1">// If a path ends with a parent directory </span><span class="s3">\&quot;</span><span class="s1">..</span><span class="s3">\&quot;</span><span class="s1">, then it's a relative path with excess parent</span><span class="s3">\n  </span><span class="s1">// paths. It's not a file, so we can't strip it.</span><span class="s3">\n  </span><span class="s1">if (path.endsWith('/..')) return path;</span><span class="s3">\n  </span><span class="s1">const index = path.lastIndexOf('/');</span><span class="s3">\n  </span><span class="s1">return path.slice(0, index + 1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function mergePaths(url: Url, base: Url) {</span><span class="s3">\n  </span><span class="s1">normalizePath(base, base.type);</span><span class="s3">\n\n  </span><span class="s1">// If the path is just a </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">, then it was an empty path to begin with (remember, we're a relative</span><span class="s3">\n  </span><span class="s1">// path).</span><span class="s3">\n  </span><span class="s1">if (url.path === '/') {</span><span class="s3">\n    </span><span class="s1">url.path = base.path;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// Resolution happens relative to the base path's directory, not the file.</span><span class="s3">\n    </span><span class="s1">url.path = stripPathFilename(base.path) + url.path;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The path can have empty directories </span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot;</span><span class="s1">, unneeded parents </span><span class="s3">\&quot;</span><span class="s1">foo/..</span><span class="s3">\&quot;</span><span class="s1">, or current directory</span><span class="s3">\n </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">foo/.</span><span class="s3">\&quot;</span><span class="s1">. We need to normalize to a standard representation.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function normalizePath(url: Url, type: UrlType) {</span><span class="s3">\n  </span><span class="s1">const rel = type &lt;= UrlType.RelativePath;</span><span class="s3">\n  </span><span class="s1">const pieces = url.path.split('/');</span><span class="s3">\n\n  </span><span class="s1">// We need to preserve the first piece always, so that we output a leading slash. The item at</span><span class="s3">\n  </span><span class="s1">// pieces[0] is an empty string.</span><span class="s3">\n  </span><span class="s1">let pointer = 1;</span><span class="s3">\n\n  </span><span class="s1">// Positive is the number of real directories we've output, used for popping a parent directory.</span><span class="s3">\n  </span><span class="s1">// Eg, </span><span class="s3">\&quot;</span><span class="s1">foo/bar/..</span><span class="s3">\&quot; </span><span class="s1">will have a positive 2, and we can decrement to be left with just </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n  </span><span class="s1">let positive = 0;</span><span class="s3">\n\n  </span><span class="s1">// We need to keep a trailing slash if we encounter an empty directory (eg, splitting </span><span class="s3">\&quot;</span><span class="s1">foo/</span><span class="s3">\&quot; </span><span class="s1">will</span><span class="s3">\n  </span><span class="s1">// generate `[</span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;\&quot;</span><span class="s1">]` pieces). And, if we pop a parent directory. But once we encounter a</span><span class="s3">\n  </span><span class="s1">// real directory, we won't need to append, unless the other conditions happen again.</span><span class="s3">\n  </span><span class="s1">let addTrailingSlash = false;</span><span class="s3">\n\n  </span><span class="s1">for (let i = 1; i &lt; pieces.length; i++) {</span><span class="s3">\n    </span><span class="s1">const piece = pieces[i];</span><span class="s3">\n\n    </span><span class="s1">// An empty directory, could be a trailing slash, or just a double </span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot; </span><span class="s1">in the path.</span><span class="s3">\n    </span><span class="s1">if (!piece) {</span><span class="s3">\n      </span><span class="s1">addTrailingSlash = true;</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If we encounter a real directory, then we don't need to append anymore.</span><span class="s3">\n    </span><span class="s1">addTrailingSlash = false;</span><span class="s3">\n\n    </span><span class="s1">// A current directory, which we can always drop.</span><span class="s3">\n    </span><span class="s1">if (piece === '.') continue;</span><span class="s3">\n\n    </span><span class="s1">// A parent directory, we need to see if there are any real directories we can pop. Else, we</span><span class="s3">\n    </span><span class="s1">// have an excess of parents, and we'll need to keep the </span><span class="s3">\&quot;</span><span class="s1">..</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n    </span><span class="s1">if (piece === '..') {</span><span class="s3">\n      </span><span class="s1">if (positive) {</span><span class="s3">\n        </span><span class="s1">addTrailingSlash = true;</span><span class="s3">\n        </span><span class="s1">positive--;</span><span class="s3">\n        </span><span class="s1">pointer--;</span><span class="s3">\n      </span><span class="s1">} else if (rel) {</span><span class="s3">\n        </span><span class="s1">// If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute</span><span class="s3">\n        </span><span class="s1">// URL, protocol relative URL, or an absolute path, we don't need to keep excess.</span><span class="s3">\n        </span><span class="s1">pieces[pointer++] = piece;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We've encountered a real directory. Move it to the next insertion pointer, which accounts for</span><span class="s3">\n    </span><span class="s1">// any popped or dropped directories.</span><span class="s3">\n    </span><span class="s1">pieces[pointer++] = piece;</span><span class="s3">\n    </span><span class="s1">positive++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let path = '';</span><span class="s3">\n  </span><span class="s1">for (let i = 1; i &lt; pointer; i++) {</span><span class="s3">\n    </span><span class="s1">path += '/' + pieces[i];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!path || (addTrailingSlash &amp;&amp; !path.endsWith('/..'))) {</span><span class="s3">\n    </span><span class="s1">path += '/';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">url.path = path;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Attempts to resolve `input` URL/path relative to `base`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function resolve(input: string, base: string | undefined): string {</span><span class="s3">\n  </span><span class="s1">if (!input &amp;&amp; !base) return '';</span><span class="s3">\n\n  </span><span class="s1">const url = parseUrl(input);</span><span class="s3">\n  </span><span class="s1">let inputType = url.type;</span><span class="s3">\n\n  </span><span class="s1">if (base &amp;&amp; inputType !== UrlType.Absolute) {</span><span class="s3">\n    </span><span class="s1">const baseUrl = parseUrl(base);</span><span class="s3">\n    </span><span class="s1">const baseType = baseUrl.type;</span><span class="s3">\n\n    </span><span class="s1">switch (inputType) {</span><span class="s3">\n      </span><span class="s1">case UrlType.Empty:</span><span class="s3">\n        </span><span class="s1">url.hash = baseUrl.hash;</span><span class="s3">\n      </span><span class="s1">// fall through</span><span class="s3">\n\n      </span><span class="s1">case UrlType.Hash:</span><span class="s3">\n        </span><span class="s1">url.query = baseUrl.query;</span><span class="s3">\n      </span><span class="s1">// fall through</span><span class="s3">\n\n      </span><span class="s1">case UrlType.Query:</span><span class="s3">\n      </span><span class="s1">case UrlType.RelativePath:</span><span class="s3">\n        </span><span class="s1">mergePaths(url, baseUrl);</span><span class="s3">\n      </span><span class="s1">// fall through</span><span class="s3">\n\n      </span><span class="s1">case UrlType.AbsolutePath:</span><span class="s3">\n        </span><span class="s1">// The host, user, and port are joined, you can't copy one without the others.</span><span class="s3">\n        </span><span class="s1">url.user = baseUrl.user;</span><span class="s3">\n        </span><span class="s1">url.host = baseUrl.host;</span><span class="s3">\n        </span><span class="s1">url.port = baseUrl.port;</span><span class="s3">\n      </span><span class="s1">// fall through</span><span class="s3">\n\n      </span><span class="s1">case UrlType.SchemeRelative:</span><span class="s3">\n        </span><span class="s1">// The input doesn't have a schema at least, so we need to copy at least that over.</span><span class="s3">\n        </span><span class="s1">url.scheme = baseUrl.scheme;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (baseType &gt; inputType) inputType = baseType;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">normalizePath(url, inputType);</span><span class="s3">\n\n  </span><span class="s1">const queryHash = url.query + url.hash;</span><span class="s3">\n  </span><span class="s1">switch (inputType) {</span><span class="s3">\n    </span><span class="s1">// This is impossible, because of the empty checks at the start of the function.</span><span class="s3">\n    </span><span class="s1">// case UrlType.Empty:</span><span class="s3">\n\n    </span><span class="s1">case UrlType.Hash:</span><span class="s3">\n    </span><span class="s1">case UrlType.Query:</span><span class="s3">\n      </span><span class="s1">return queryHash;</span><span class="s3">\n\n    </span><span class="s1">case UrlType.RelativePath: {</span><span class="s3">\n      </span><span class="s1">// The first char is always a </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">, and we need it to be relative.</span><span class="s3">\n      </span><span class="s1">const path = url.path.slice(1);</span><span class="s3">\n\n      </span><span class="s1">if (!path) return queryHash || '.';</span><span class="s3">\n\n      </span><span class="s1">if (isRelative(base || input) &amp;&amp; !isRelative(path)) {</span><span class="s3">\n        </span><span class="s1">// If base started with a leading </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">, or there is no base and input started with a </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">// then we need to ensure that the relative path starts with a </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">. We don't know if</span><span class="s3">\n        </span><span class="s1">// relative starts with a </span><span class="s3">\&quot;</span><span class="s1">..</span><span class="s3">\&quot;</span><span class="s1">, though, so check before prepending.</span><span class="s3">\n        </span><span class="s1">return './' + path + queryHash;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return path + queryHash;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">case UrlType.AbsolutePath:</span><span class="s3">\n      </span><span class="s1">return url.path + queryHash;</span><span class="s3">\n\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>