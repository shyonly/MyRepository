<html>
<head>
<title>babelUtils.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #42c3d4;}
.s7 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
babelUtils.ts</font>
</center></td></tr></table>
<pre><span class="s0">// https://github.com/vuejs/core/blob/main/packages/compiler-core/src/babelUtils.ts</span>

<span class="s0">// should only use types from @babel/types</span>
<span class="s0">// do not import runtime methods</span>
<span class="s2">import </span><span class="s1">type </span><span class="s3">{</span>
  <span class="s1">Identifier</span><span class="s3">,</span>
  <span class="s1">Node</span><span class="s3">,</span>
  <span class="s1">Function</span><span class="s3">,</span>
  <span class="s1">ObjectProperty</span><span class="s3">,</span>
  <span class="s1">BlockStatement</span><span class="s3">,</span>
  <span class="s1">Program</span>
<span class="s3">} </span><span class="s1">from </span><span class="s4">'@babel/types'</span>
<span class="s2">import </span><span class="s3">{ </span><span class="s1">walk </span><span class="s3">} </span><span class="s1">from </span><span class="s4">'estree-walker'</span>

<span class="s2">export function </span><span class="s1">walkIdentifiers</span><span class="s3">(</span>
  <span class="s1">root</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">,</span>
  <span class="s1">onIdentifier</span><span class="s3">: (</span>
    <span class="s1">node</span><span class="s3">: </span><span class="s1">Identifier</span><span class="s3">,</span>
    <span class="s1">parent</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">,</span>
    <span class="s1">parentStack</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">[],</span>
    <span class="s1">isReference</span><span class="s3">: </span><span class="s1">boolean</span><span class="s3">,</span>
    <span class="s1">isLocal</span><span class="s3">: </span><span class="s1">boolean</span>
  <span class="s3">) =&gt; </span><span class="s2">void</span><span class="s3">,</span>
  <span class="s1">onNode</span><span class="s3">?: (</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">) =&gt; </span><span class="s2">void</span>
<span class="s3">) {</span>
  <span class="s2">const </span><span class="s1">includeAll </span><span class="s3">= </span><span class="s2">false</span>
  <span class="s2">const </span><span class="s1">parentStack</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">[] = []</span>
  <span class="s2">const </span><span class="s1">knownIds</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">number</span><span class="s3">&gt; = </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s2">null</span><span class="s3">)</span>

  <span class="s2">const </span><span class="s1">rootExp </span><span class="s3">=</span>
    <span class="s1">root</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'Program' </span><span class="s3">&amp;&amp;</span>
    <span class="s1">root</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'ExpressionStatement' </span><span class="s3">&amp;&amp;</span>
    <span class="s1">root</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">expression</span>

  <span class="s3">;(</span><span class="s1">walk </span><span class="s3">as </span><span class="s1">any</span><span class="s3">)(</span><span class="s1">root</span><span class="s3">, {</span>
    <span class="s1">enter</span><span class="s3">(</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Node </span><span class="s3">&amp; { </span><span class="s1">scopeIds</span><span class="s3">?: </span><span class="s1">Set</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">&gt; }, </span><span class="s1">parent</span><span class="s3">: </span><span class="s1">Node </span><span class="s3">| </span><span class="s1">undefined</span><span class="s3">) {</span>
      <span class="s1">parent </span><span class="s3">&amp;&amp; </span><span class="s1">parentStack</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">)</span>
      <span class="s2">if </span><span class="s3">(</span>
        <span class="s1">parent </span><span class="s3">&amp;&amp;</span>
        <span class="s1">parent</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">startsWith</span><span class="s3">(</span><span class="s4">'TS'</span><span class="s3">) &amp;&amp;</span>
        <span class="s1">parent</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!== </span><span class="s4">'TSAsExpression' </span><span class="s3">&amp;&amp;</span>
        <span class="s1">parent</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!== </span><span class="s4">'TSNonNullExpression' </span><span class="s3">&amp;&amp;</span>
        <span class="s1">parent</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!== </span><span class="s4">'TSTypeAssertion'</span>
      <span class="s3">) {</span>
        <span class="s2">return this</span><span class="s3">.</span><span class="s1">skip</span><span class="s3">()</span>
      <span class="s3">}</span>

      <span class="s2">if </span><span class="s3">(</span><span class="s1">onNode</span><span class="s3">) </span><span class="s1">onNode</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>

      <span class="s2">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'Identifier'</span><span class="s3">) {</span>
        <span class="s2">const </span><span class="s1">isLocal </span><span class="s3">= !!</span><span class="s1">knownIds</span><span class="s3">[</span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
        <span class="s2">const </span><span class="s1">isRefed </span><span class="s3">= </span><span class="s1">isReferencedIdentifier</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">!, </span><span class="s1">parentStack</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">includeAll </span><span class="s3">|| (</span><span class="s1">isRefed </span><span class="s3">&amp;&amp; !</span><span class="s1">isLocal</span><span class="s3">)) {</span>
          <span class="s1">onIdentifier</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">!, </span><span class="s1">parentStack</span><span class="s3">, </span><span class="s1">isRefed</span><span class="s3">, </span><span class="s1">isLocal</span><span class="s3">)</span>
        <span class="s3">}</span>
      <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span>
        <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'ObjectProperty' </span><span class="s3">&amp;&amp;</span>
        <span class="s1">parent</span><span class="s3">!.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'ObjectPattern'</span>
      <span class="s3">) {</span>
        <span class="s0">// mark property in destructure pattern</span>
        <span class="s3">;(</span><span class="s1">node </span><span class="s3">as </span><span class="s1">any</span><span class="s3">).</span><span class="s1">inPattern </span><span class="s3">= </span><span class="s2">true</span>
      <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">isFunctionType</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)) {</span>
        <span class="s0">// walk function expressions and add its arguments to known identifiers</span>
        <span class="s0">// so that we don't prefix them</span>
        <span class="s1">walkFunctionParams</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">id </span><span class="s3">=&gt; </span><span class="s1">markScopeIdentifier</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">id</span><span class="s3">, </span><span class="s1">knownIds</span><span class="s3">))</span>
      <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'BlockStatement'</span><span class="s3">) {</span>
        <span class="s0">// #3445 record block-level local variables</span>
        <span class="s1">walkBlockDeclarations</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">id </span><span class="s3">=&gt;</span>
          <span class="s1">markScopeIdentifier</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">id</span><span class="s3">, </span><span class="s1">knownIds</span><span class="s3">)</span>
        <span class="s3">)</span>
      <span class="s3">}</span>
    <span class="s3">},</span>
    <span class="s1">leave</span><span class="s3">(</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Node </span><span class="s3">&amp; { </span><span class="s1">scopeIds</span><span class="s3">?: </span><span class="s1">Set</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">&gt; }, </span><span class="s1">parent</span><span class="s3">: </span><span class="s1">Node </span><span class="s3">| </span><span class="s1">undefined</span><span class="s3">) {</span>
      <span class="s1">parent </span><span class="s3">&amp;&amp; </span><span class="s1">parentStack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">node </span><span class="s3">!== </span><span class="s1">rootExp </span><span class="s3">&amp;&amp; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">scopeIds</span><span class="s3">) {</span>
        <span class="s2">for </span><span class="s3">(</span><span class="s2">const </span><span class="s1">id of node</span><span class="s3">.</span><span class="s1">scopeIds</span><span class="s3">) {</span>
          <span class="s1">knownIds</span><span class="s3">[</span><span class="s1">id</span><span class="s3">]--</span>
          <span class="s2">if </span><span class="s3">(</span><span class="s1">knownIds</span><span class="s3">[</span><span class="s1">id</span><span class="s3">] === </span><span class="s5">0</span><span class="s3">) {</span>
            <span class="s2">delete </span><span class="s1">knownIds</span><span class="s3">[</span><span class="s1">id</span><span class="s3">]</span>
          <span class="s3">}</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">})</span>
<span class="s3">}</span>

<span class="s2">export function </span><span class="s1">isReferencedIdentifier</span><span class="s3">(</span>
  <span class="s1">id</span><span class="s3">: </span><span class="s1">Identifier</span><span class="s3">,</span>
  <span class="s1">parent</span><span class="s3">: </span><span class="s1">Node </span><span class="s3">| </span><span class="s2">null</span><span class="s3">,</span>
  <span class="s1">parentStack</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">[]</span>
<span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">parent</span><span class="s3">) {</span>
    <span class="s2">return true</span>
  <span class="s3">}</span>

  <span class="s0">// is a special keyword but parsed as identifier</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">id</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=== </span><span class="s4">'arguments'</span><span class="s3">) {</span>
    <span class="s2">return false</span>
  <span class="s3">}</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">isReferenced</span><span class="s3">(</span><span class="s1">id</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">)) {</span>
    <span class="s2">return true</span>
  <span class="s3">}</span>

  <span class="s0">// babel's isReferenced check returns false for ids being assigned to, so we</span>
  <span class="s0">// need to cover those cases here</span>
  <span class="s2">switch </span><span class="s3">(</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">type</span><span class="s3">) {</span>
    <span class="s2">case </span><span class="s4">'AssignmentExpression'</span><span class="s3">:</span>
    <span class="s2">case </span><span class="s4">'AssignmentPattern'</span><span class="s3">:</span>
      <span class="s2">return true</span>
    <span class="s2">case </span><span class="s4">'ObjectPattern'</span><span class="s3">:</span>
    <span class="s2">case </span><span class="s4">'ArrayPattern'</span><span class="s3">:</span>
      <span class="s2">return </span><span class="s1">isInDestructureAssignment</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">, </span><span class="s1">parentStack</span><span class="s3">)</span>
  <span class="s3">}</span>

  <span class="s2">return false</span>
<span class="s3">}</span>

<span class="s2">export function </span><span class="s1">isInDestructureAssignment</span><span class="s3">(</span>
  <span class="s1">parent</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">,</span>
  <span class="s1">parentStack</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">[]</span>
<span class="s3">): </span><span class="s1">boolean </span><span class="s3">{</span>
  <span class="s2">if </span><span class="s3">(</span>
    <span class="s1">parent </span><span class="s3">&amp;&amp;</span>
    <span class="s3">(</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'ObjectProperty' </span><span class="s3">|| </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'ArrayPattern'</span><span class="s3">)</span>
  <span class="s3">) {</span>
    <span class="s2">let </span><span class="s1">i </span><span class="s3">= </span><span class="s1">parentStack</span><span class="s3">.</span><span class="s1">length</span>
    <span class="s2">while </span><span class="s3">(</span><span class="s1">i</span><span class="s3">--) {</span>
      <span class="s2">const </span><span class="s1">p </span><span class="s3">= </span><span class="s1">parentStack</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'AssignmentExpression'</span><span class="s3">) {</span>
        <span class="s2">return true</span>
      <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!== </span><span class="s4">'ObjectProperty' </span><span class="s3">&amp;&amp; !</span><span class="s1">p</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">endsWith</span><span class="s3">(</span><span class="s4">'Pattern'</span><span class="s3">)) {</span>
        <span class="s2">break</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
  <span class="s2">return false</span>
<span class="s3">}</span>

<span class="s2">export function </span><span class="s1">walkFunctionParams</span><span class="s3">(</span>
  <span class="s1">node</span><span class="s3">: </span><span class="s1">Function</span><span class="s3">,</span>
  <span class="s1">onIdent</span><span class="s3">: (</span><span class="s1">id</span><span class="s3">: </span><span class="s1">Identifier</span><span class="s3">) =&gt; </span><span class="s2">void</span>
<span class="s3">) {</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">const </span><span class="s1">p of node</span><span class="s3">.</span><span class="s1">params</span><span class="s3">) {</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s2">const </span><span class="s1">id of extractIdentifiers</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)) {</span>
      <span class="s1">onIdent</span><span class="s3">(</span><span class="s1">id</span><span class="s3">)</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s2">export function </span><span class="s1">walkBlockDeclarations</span><span class="s3">(</span>
  <span class="s1">block</span><span class="s3">: </span><span class="s1">BlockStatement </span><span class="s3">| </span><span class="s1">Program</span><span class="s3">,</span>
  <span class="s1">onIdent</span><span class="s3">: (</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Identifier</span><span class="s3">) =&gt; </span><span class="s2">void</span>
<span class="s3">) {</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">const </span><span class="s1">stmt of block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'VariableDeclaration'</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">declare</span><span class="s3">) </span><span class="s2">continue</span>
      <span class="s2">for </span><span class="s3">(</span><span class="s2">const </span><span class="s1">decl of stmt</span><span class="s3">.</span><span class="s1">declarations</span><span class="s3">) {</span>
        <span class="s2">for </span><span class="s3">(</span><span class="s2">const </span><span class="s1">id of extractIdentifiers</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">.</span><span class="s1">id</span><span class="s3">)) {</span>
          <span class="s1">onIdent</span><span class="s3">(</span><span class="s1">id</span><span class="s3">)</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span>
      <span class="s1">stmt</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'FunctionDeclaration' </span><span class="s3">||</span>
      <span class="s1">stmt</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'ClassDeclaration'</span>
    <span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">declare </span><span class="s3">|| !</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">id</span><span class="s3">) </span><span class="s2">continue</span>
      <span class="s1">onIdent</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">id</span><span class="s3">)</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s2">export function </span><span class="s1">extractIdentifiers</span><span class="s3">(</span>
  <span class="s1">param</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">,</span>
  <span class="s1">nodes</span><span class="s3">: </span><span class="s1">Identifier</span><span class="s3">[] = []</span>
<span class="s3">): </span><span class="s1">Identifier</span><span class="s3">[] {</span>
  <span class="s2">switch </span><span class="s3">(</span><span class="s1">param</span><span class="s3">.</span><span class="s1">type</span><span class="s3">) {</span>
    <span class="s2">case </span><span class="s4">'Identifier'</span><span class="s3">:</span>
      <span class="s1">nodes</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">param</span><span class="s3">)</span>
      <span class="s2">break</span>

    <span class="s2">case </span><span class="s4">'MemberExpression'</span><span class="s3">:</span>
      <span class="s2">let </span><span class="s1">object</span><span class="s3">: </span><span class="s1">any </span><span class="s3">= </span><span class="s1">param</span>
      <span class="s2">while </span><span class="s3">(</span><span class="s1">object</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'MemberExpression'</span><span class="s3">) {</span>
        <span class="s1">object </span><span class="s3">= </span><span class="s1">object</span><span class="s3">.</span><span class="s1">object</span>
      <span class="s3">}</span>
      <span class="s1">nodes</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">object</span><span class="s3">)</span>
      <span class="s2">break</span>

    <span class="s2">case </span><span class="s4">'ObjectPattern'</span><span class="s3">:</span>
      <span class="s2">for </span><span class="s3">(</span><span class="s2">const </span><span class="s1">prop of param</span><span class="s3">.</span><span class="s1">properties</span><span class="s3">) {</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">prop</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'RestElement'</span><span class="s3">) {</span>
          <span class="s1">extractIdentifiers</span><span class="s3">(</span><span class="s1">prop</span><span class="s3">.</span><span class="s1">argument</span><span class="s3">, </span><span class="s1">nodes</span><span class="s3">)</span>
        <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
          <span class="s1">extractIdentifiers</span><span class="s3">(</span><span class="s1">prop</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">nodes</span><span class="s3">)</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
      <span class="s2">break</span>

    <span class="s2">case </span><span class="s4">'ArrayPattern'</span><span class="s3">:</span>
      <span class="s1">param</span><span class="s3">.</span><span class="s1">elements</span><span class="s3">.</span><span class="s1">forEach</span><span class="s3">(</span><span class="s1">element </span><span class="s3">=&gt; {</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">element</span><span class="s3">) </span><span class="s1">extractIdentifiers</span><span class="s3">(</span><span class="s1">element</span><span class="s3">, </span><span class="s1">nodes</span><span class="s3">)</span>
      <span class="s3">})</span>
      <span class="s2">break</span>

    <span class="s2">case </span><span class="s4">'RestElement'</span><span class="s3">:</span>
      <span class="s1">extractIdentifiers</span><span class="s3">(</span><span class="s1">param</span><span class="s3">.</span><span class="s1">argument</span><span class="s3">, </span><span class="s1">nodes</span><span class="s3">)</span>
      <span class="s2">break</span>

    <span class="s2">case </span><span class="s4">'AssignmentPattern'</span><span class="s3">:</span>
      <span class="s1">extractIdentifiers</span><span class="s3">(</span><span class="s1">param</span><span class="s3">.</span><span class="s1">left</span><span class="s3">, </span><span class="s1">nodes</span><span class="s3">)</span>
      <span class="s2">break</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">nodes</span>
<span class="s3">}</span>

<span class="s2">function </span><span class="s1">markScopeIdentifier</span><span class="s3">(</span>
  <span class="s1">node</span><span class="s3">: </span><span class="s1">Node </span><span class="s3">&amp; { </span><span class="s1">scopeIds</span><span class="s3">?: </span><span class="s1">Set</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">&gt; },</span>
  <span class="s1">child</span><span class="s3">: </span><span class="s1">Identifier</span><span class="s3">,</span>
  <span class="s1">knownIds</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">number</span><span class="s3">&gt;</span>
<span class="s3">) {</span>
  <span class="s2">const </span><span class="s3">{ </span><span class="s1">name </span><span class="s3">} = </span><span class="s1">child</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">scopeIds </span><span class="s3">&amp;&amp; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">scopeIds</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)) {</span>
    <span class="s2">return</span>
  <span class="s3">}</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">name </span><span class="s2">in </span><span class="s1">knownIds</span><span class="s3">) {</span>
    <span class="s1">knownIds</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]++</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">knownIds</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s5">1</span>
  <span class="s3">}</span>
  <span class="s3">;(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">scopeIds </span><span class="s3">|| (</span><span class="s1">node</span><span class="s3">.</span><span class="s1">scopeIds </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Set</span><span class="s3">())).</span><span class="s1">add</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s2">export const </span><span class="s1">isFunctionType </span><span class="s3">= (</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">): </span><span class="s1">node </span><span class="s3">is </span><span class="s1">Function </span><span class="s3">=&gt; {</span>
  <span class="s2">return </span><span class="s6">/Function(?:Expression|Declaration)$|Method$/</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s2">export const </span><span class="s1">isStaticProperty </span><span class="s3">= (</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">): </span><span class="s1">node </span><span class="s3">is </span><span class="s1">ObjectProperty </span><span class="s3">=&gt;</span>
  <span class="s1">node </span><span class="s3">&amp;&amp;</span>
  <span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'ObjectProperty' </span><span class="s3">|| </span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'ObjectMethod'</span><span class="s3">) &amp;&amp;</span>
  <span class="s3">!</span><span class="s1">node</span><span class="s3">.</span><span class="s1">computed</span>

<span class="s2">export const </span><span class="s1">isStaticPropertyKey </span><span class="s3">= (</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">) =&gt;</span>
  <span class="s1">isStaticProperty</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">) &amp;&amp; </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">key </span><span class="s3">=== </span><span class="s1">node</span>

<span class="s7">/**</span>
 <span class="s7">* Copied from https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isReferenced.ts</span>
 <span class="s7">* To avoid runtime dependency on @babel/types (which includes process references)</span>
 <span class="s7">* This file should not change very often in babel but we may need to keep it</span>
 <span class="s7">* up-to-date from time to time.</span>
 <span class="s7">*</span>
 <span class="s7">* https://github.com/babel/babel/blob/main/LICENSE</span>
 <span class="s7">*</span>
 <span class="s7">*/</span>
<span class="s2">function </span><span class="s1">isReferenced</span><span class="s3">(</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">, </span><span class="s1">grandparent</span><span class="s3">?: </span><span class="s1">Node</span><span class="s3">): </span><span class="s1">boolean </span><span class="s3">{</span>
  <span class="s2">switch </span><span class="s3">(</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">type</span><span class="s3">) {</span>
    <span class="s0">// yes: PARENT[NODE]</span>
    <span class="s0">// yes: NODE.child</span>
    <span class="s0">// no: parent.NODE</span>
    <span class="s2">case </span><span class="s4">'MemberExpression'</span><span class="s3">:</span>
    <span class="s2">case </span><span class="s4">'OptionalMemberExpression'</span><span class="s3">:</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">property </span><span class="s3">=== </span><span class="s1">node</span><span class="s3">) {</span>
        <span class="s2">return </span><span class="s3">!!</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">computed</span>
      <span class="s3">}</span>
      <span class="s2">return </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">object </span><span class="s3">=== </span><span class="s1">node</span>

    <span class="s2">case </span><span class="s4">'JSXMemberExpression'</span><span class="s3">:</span>
      <span class="s2">return </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">object </span><span class="s3">=== </span><span class="s1">node</span>
    <span class="s0">// no: let NODE = init;</span>
    <span class="s0">// yes: let id = NODE;</span>
    <span class="s2">case </span><span class="s4">'VariableDeclarator'</span><span class="s3">:</span>
      <span class="s2">return </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">init </span><span class="s3">=== </span><span class="s1">node</span>

    <span class="s0">// yes: () =&gt; NODE</span>
    <span class="s0">// no: (NODE) =&gt; {}</span>
    <span class="s2">case </span><span class="s4">'ArrowFunctionExpression'</span><span class="s3">:</span>
      <span class="s2">return </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">body </span><span class="s3">=== </span><span class="s1">node</span>

    <span class="s0">// no: class { #NODE; }</span>
    <span class="s0">// no: class { get #NODE() {} }</span>
    <span class="s0">// no: class { #NODE() {} }</span>
    <span class="s0">// no: class { fn() { return this.#NODE; } }</span>
    <span class="s2">case </span><span class="s4">'PrivateName'</span><span class="s3">:</span>
      <span class="s2">return false</span>

    <span class="s0">// no: class { NODE() {} }</span>
    <span class="s0">// yes: class { [NODE]() {} }</span>
    <span class="s0">// no: class { foo(NODE) {} }</span>
    <span class="s2">case </span><span class="s4">'ClassMethod'</span><span class="s3">:</span>
    <span class="s2">case </span><span class="s4">'ClassPrivateMethod'</span><span class="s3">:</span>
    <span class="s2">case </span><span class="s4">'ObjectMethod'</span><span class="s3">:</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">key </span><span class="s3">=== </span><span class="s1">node</span><span class="s3">) {</span>
        <span class="s2">return </span><span class="s3">!!</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">computed</span>
      <span class="s3">}</span>
      <span class="s2">return false</span>

    <span class="s0">// yes: { [NODE]: &quot;&quot; }</span>
    <span class="s0">// no: { NODE: &quot;&quot; }</span>
    <span class="s0">// depends: { NODE }</span>
    <span class="s0">// depends: { key: NODE }</span>
    <span class="s2">case </span><span class="s4">'ObjectProperty'</span><span class="s3">:</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">key </span><span class="s3">=== </span><span class="s1">node</span><span class="s3">) {</span>
        <span class="s2">return </span><span class="s3">!!</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">computed</span>
      <span class="s3">}</span>
      <span class="s0">// parent.value === node</span>
      <span class="s2">return </span><span class="s3">!</span><span class="s1">grandparent </span><span class="s3">|| </span><span class="s1">grandparent</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!== </span><span class="s4">'ObjectPattern'</span>
    <span class="s0">// no: class { NODE = value; }</span>
    <span class="s0">// yes: class { [NODE] = value; }</span>
    <span class="s0">// yes: class { key = NODE; }</span>
    <span class="s2">case </span><span class="s4">'ClassProperty'</span><span class="s3">:</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">key </span><span class="s3">=== </span><span class="s1">node</span><span class="s3">) {</span>
        <span class="s2">return </span><span class="s3">!!</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">computed</span>
      <span class="s3">}</span>
      <span class="s2">return true</span>
    <span class="s2">case </span><span class="s4">'ClassPrivateProperty'</span><span class="s3">:</span>
      <span class="s2">return </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">key </span><span class="s3">!== </span><span class="s1">node</span>

    <span class="s0">// no: class NODE {}</span>
    <span class="s0">// yes: class Foo extends NODE {}</span>
    <span class="s2">case </span><span class="s4">'ClassDeclaration'</span><span class="s3">:</span>
    <span class="s2">case </span><span class="s4">'ClassExpression'</span><span class="s3">:</span>
      <span class="s2">return </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">superClass </span><span class="s3">=== </span><span class="s1">node</span>

    <span class="s0">// yes: left = NODE;</span>
    <span class="s0">// no: NODE = right;</span>
    <span class="s2">case </span><span class="s4">'AssignmentExpression'</span><span class="s3">:</span>
      <span class="s2">return </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">right </span><span class="s3">=== </span><span class="s1">node</span>

    <span class="s0">// no: [NODE = foo] = [];</span>
    <span class="s0">// yes: [foo = NODE] = [];</span>
    <span class="s2">case </span><span class="s4">'AssignmentPattern'</span><span class="s3">:</span>
      <span class="s2">return </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">right </span><span class="s3">=== </span><span class="s1">node</span>

    <span class="s0">// no: NODE: for (;;) {}</span>
    <span class="s2">case </span><span class="s4">'LabeledStatement'</span><span class="s3">:</span>
      <span class="s2">return false</span>

    <span class="s0">// no: try {} catch (NODE) {}</span>
    <span class="s2">case </span><span class="s4">'CatchClause'</span><span class="s3">:</span>
      <span class="s2">return false</span>

    <span class="s0">// no: function foo(...NODE) {}</span>
    <span class="s2">case </span><span class="s4">'RestElement'</span><span class="s3">:</span>
      <span class="s2">return false</span>

    <span class="s2">case </span><span class="s4">'BreakStatement'</span><span class="s3">:</span>
    <span class="s2">case </span><span class="s4">'ContinueStatement'</span><span class="s3">:</span>
      <span class="s2">return false</span>

    <span class="s0">// no: function NODE() {}</span>
    <span class="s0">// no: function foo(NODE) {}</span>
    <span class="s2">case </span><span class="s4">'FunctionDeclaration'</span><span class="s3">:</span>
    <span class="s2">case </span><span class="s4">'FunctionExpression'</span><span class="s3">:</span>
      <span class="s2">return false</span>

    <span class="s0">// no: export NODE from &quot;foo&quot;;</span>
    <span class="s0">// no: export * as NODE from &quot;foo&quot;;</span>
    <span class="s2">case </span><span class="s4">'ExportNamespaceSpecifier'</span><span class="s3">:</span>
    <span class="s2">case </span><span class="s4">'ExportDefaultSpecifier'</span><span class="s3">:</span>
      <span class="s2">return false</span>

    <span class="s0">// no: export { foo as NODE };</span>
    <span class="s0">// yes: export { NODE as foo };</span>
    <span class="s0">// no: export { NODE as foo } from &quot;foo&quot;;</span>
    <span class="s2">case </span><span class="s4">'ExportSpecifier'</span><span class="s3">:</span>
      <span class="s0">// @ts-expect-error</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">grandparent</span><span class="s3">?.</span><span class="s1">source</span><span class="s3">) {</span>
        <span class="s2">return false</span>
      <span class="s3">}</span>
      <span class="s2">return </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">local </span><span class="s3">=== </span><span class="s1">node</span>

    <span class="s0">// no: import NODE from &quot;foo&quot;;</span>
    <span class="s0">// no: import * as NODE from &quot;foo&quot;;</span>
    <span class="s0">// no: import { NODE as foo } from &quot;foo&quot;;</span>
    <span class="s0">// no: import { foo as NODE } from &quot;foo&quot;;</span>
    <span class="s0">// no: import NODE from &quot;bar&quot;;</span>
    <span class="s2">case </span><span class="s4">'ImportDefaultSpecifier'</span><span class="s3">:</span>
    <span class="s2">case </span><span class="s4">'ImportNamespaceSpecifier'</span><span class="s3">:</span>
    <span class="s2">case </span><span class="s4">'ImportSpecifier'</span><span class="s3">:</span>
      <span class="s2">return false</span>

    <span class="s0">// no: import &quot;foo&quot; assert { NODE: &quot;json&quot; }</span>
    <span class="s2">case </span><span class="s4">'ImportAttribute'</span><span class="s3">:</span>
      <span class="s2">return false</span>

    <span class="s0">// no: &lt;div NODE=&quot;foo&quot; /&gt;</span>
    <span class="s2">case </span><span class="s4">'JSXAttribute'</span><span class="s3">:</span>
      <span class="s2">return false</span>

    <span class="s0">// no: [NODE] = [];</span>
    <span class="s0">// no: ({ NODE }) = [];</span>
    <span class="s2">case </span><span class="s4">'ObjectPattern'</span><span class="s3">:</span>
    <span class="s2">case </span><span class="s4">'ArrayPattern'</span><span class="s3">:</span>
      <span class="s2">return false</span>

    <span class="s0">// no: new.NODE</span>
    <span class="s0">// no: NODE.target</span>
    <span class="s2">case </span><span class="s4">'MetaProperty'</span><span class="s3">:</span>
      <span class="s2">return false</span>

    <span class="s0">// yes: type X = { someProperty: NODE }</span>
    <span class="s0">// no: type X = { NODE: OtherType }</span>
    <span class="s2">case </span><span class="s4">'ObjectTypeProperty'</span><span class="s3">:</span>
      <span class="s2">return </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">key </span><span class="s3">!== </span><span class="s1">node</span>

    <span class="s0">// yes: enum X { Foo = NODE }</span>
    <span class="s0">// no: enum X { NODE }</span>
    <span class="s2">case </span><span class="s4">'TSEnumMember'</span><span class="s3">:</span>
      <span class="s2">return </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">id </span><span class="s3">!== </span><span class="s1">node</span>

    <span class="s0">// yes: { [NODE]: value }</span>
    <span class="s0">// no: { NODE: value }</span>
    <span class="s2">case </span><span class="s4">'TSPropertySignature'</span><span class="s3">:</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">key </span><span class="s3">=== </span><span class="s1">node</span><span class="s3">) {</span>
        <span class="s2">return </span><span class="s3">!!</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">computed</span>
      <span class="s3">}</span>

      <span class="s2">return true</span>
  <span class="s3">}</span>

  <span class="s2">return true</span>
<span class="s3">}</span>
</pre>
</body>
</html>