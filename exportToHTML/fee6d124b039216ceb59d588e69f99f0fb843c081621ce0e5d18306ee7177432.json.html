<html>
<head>
<title>fee6d124b039216ceb59d588e69f99f0fb843c081621ce0e5d18306ee7177432.json</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #cf8e6d;}
.s3 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fee6d124b039216ceb59d588e69f99f0fb843c081621ce0e5d18306ee7177432.json</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;ast&quot;</span><span class="s0">:</span><span class="s2">null</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">:</span><span class="s1">&quot;import </span><span class="s2">\&quot;</span><span class="s1">core-js/modules/es.array.push.js</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import </span><span class="s2">\&quot;</span><span class="s1">core-js/modules/web.immediate.js</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import </span><span class="s2">\&quot;</span><span class="s1">core-js/modules/es.array.unshift.js</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">/*!</span><span class="s2">\n </span><span class="s1">* Vue.js v2.7.14</span><span class="s2">\n </span><span class="s1">* (c) 2014-2022 Evan You</span><span class="s2">\n </span><span class="s1">* Released under the MIT License.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var emptyObject = Object.freeze({});</span><span class="s2">\n</span><span class="s1">var isArray = Array.isArray;</span><span class="s2">\n</span><span class="s1">// These helpers produce better VM code in JS engines due to their</span><span class="s2">\n</span><span class="s1">// explicitness and function inlining.</span><span class="s2">\n</span><span class="s1">function isUndef(v) {</span><span class="s2">\n  </span><span class="s1">return v === undefined || v === null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isDef(v) {</span><span class="s2">\n  </span><span class="s1">return v !== undefined &amp;&amp; v !== null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isTrue(v) {</span><span class="s2">\n  </span><span class="s1">return v === true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isFalse(v) {</span><span class="s2">\n  </span><span class="s1">return v === false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Check if value is primitive.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isPrimitive(value) {</span><span class="s2">\n  </span><span class="s1">return typeof value === 'string' || typeof value === 'number' ||</span><span class="s2">\n  </span><span class="s1">// $flow-disable-line</span><span class="s2">\n  </span><span class="s1">typeof value === 'symbol' || typeof value === 'boolean';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isFunction(value) {</span><span class="s2">\n  </span><span class="s1">return typeof value === 'function';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Quick object check - this is primarily used to tell</span><span class="s2">\n </span><span class="s1">* objects from primitive values when we know the value</span><span class="s2">\n </span><span class="s1">* is a JSON-compliant type.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isObject(obj) {</span><span class="s2">\n  </span><span class="s1">return obj !== null &amp;&amp; typeof obj === 'object';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Get the raw type string of a value, e.g., [object Object].</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var _toString = Object.prototype.toString;</span><span class="s2">\n</span><span class="s1">function toRawType(value) {</span><span class="s2">\n  </span><span class="s1">return _toString.call(value).slice(8, -1);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Strict object type check. Only returns true</span><span class="s2">\n </span><span class="s1">* for plain JavaScript objects.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isPlainObject(obj) {</span><span class="s2">\n  </span><span class="s1">return _toString.call(obj) === '[object Object]';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isRegExp(v) {</span><span class="s2">\n  </span><span class="s1">return _toString.call(v) === '[object RegExp]';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Check if val is a valid array index.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isValidArrayIndex(val) {</span><span class="s2">\n  </span><span class="s1">var n = parseFloat(String(val));</span><span class="s2">\n  </span><span class="s1">return n &gt;= 0 &amp;&amp; Math.floor(n) === n &amp;&amp; isFinite(val);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isPromise(val) {</span><span class="s2">\n  </span><span class="s1">return isDef(val) &amp;&amp; typeof val.then === 'function' &amp;&amp; typeof val.catch === 'function';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Convert a value to a string that is actually rendered.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function toString(val) {</span><span class="s2">\n  </span><span class="s1">return val == null ? '' : Array.isArray(val) || isPlainObject(val) &amp;&amp; val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Convert an input value to a number for persistence.</span><span class="s2">\n </span><span class="s1">* If the conversion fails, return original string.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function toNumber(val) {</span><span class="s2">\n  </span><span class="s1">var n = parseFloat(val);</span><span class="s2">\n  </span><span class="s1">return isNaN(n) ? val : n;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Make a map and return a function for checking if a key</span><span class="s2">\n </span><span class="s1">* is in that map.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function makeMap(str, expectsLowerCase) {</span><span class="s2">\n  </span><span class="s1">var map = Object.create(null);</span><span class="s2">\n  </span><span class="s1">var list = str.split(',');</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; list.length; i++) {</span><span class="s2">\n    </span><span class="s1">map[list[i]] = true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return expectsLowerCase ? function (val) {</span><span class="s2">\n    </span><span class="s1">return map[val.toLowerCase()];</span><span class="s2">\n  </span><span class="s1">} : function (val) {</span><span class="s2">\n    </span><span class="s1">return map[val];</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Check if a tag is a built-in tag.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var isBuiltInTag = makeMap('slot,component', true);</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Check if an attribute is a reserved attribute.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Remove an item from an array.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function remove$2(arr, item) {</span><span class="s2">\n  </span><span class="s1">var len = arr.length;</span><span class="s2">\n  </span><span class="s1">if (len) {</span><span class="s2">\n    </span><span class="s1">// fast path for the only / last item</span><span class="s2">\n    </span><span class="s1">if (item === arr[len - 1]) {</span><span class="s2">\n      </span><span class="s1">arr.length = len - 1;</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var index = arr.indexOf(item);</span><span class="s2">\n    </span><span class="s1">if (index &gt; -1) {</span><span class="s2">\n      </span><span class="s1">return arr.splice(index, 1);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Check whether an object has the property.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var hasOwnProperty = Object.prototype.hasOwnProperty;</span><span class="s2">\n</span><span class="s1">function hasOwn(obj, key) {</span><span class="s2">\n  </span><span class="s1">return hasOwnProperty.call(obj, key);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Create a cached version of a pure function.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function cached(fn) {</span><span class="s2">\n  </span><span class="s1">var cache = Object.create(null);</span><span class="s2">\n  </span><span class="s1">return function cachedFn(str) {</span><span class="s2">\n    </span><span class="s1">var hit = cache[str];</span><span class="s2">\n    </span><span class="s1">return hit || (cache[str] = fn(str));</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Camelize a hyphen-delimited string.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var camelizeRE = /-(</span><span class="s2">\\</span><span class="s1">w)/g;</span><span class="s2">\n</span><span class="s1">var camelize = cached(function (str) {</span><span class="s2">\n  </span><span class="s1">return str.replace(camelizeRE, function (_, c) {</span><span class="s2">\n    </span><span class="s1">return c ? c.toUpperCase() : '';</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Capitalize a string.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var capitalize = cached(function (str) {</span><span class="s2">\n  </span><span class="s1">return str.charAt(0).toUpperCase() + str.slice(1);</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Hyphenate a camelCase string.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var hyphenateRE = /</span><span class="s2">\\</span><span class="s1">B([A-Z])/g;</span><span class="s2">\n</span><span class="s1">var hyphenate = cached(function (str) {</span><span class="s2">\n  </span><span class="s1">return str.replace(hyphenateRE, '-$1').toLowerCase();</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Simple bind polyfill for environments that do not support it,</span><span class="s2">\n </span><span class="s1">* e.g., PhantomJS 1.x. Technically, we don't need this anymore</span><span class="s2">\n </span><span class="s1">* since native bind is now performant enough in most browsers.</span><span class="s2">\n </span><span class="s1">* But removing it would mean breaking code that was able to run in</span><span class="s2">\n </span><span class="s1">* PhantomJS 1.x, so this must be kept for backward compatibility.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n</span><span class="s1">function polyfillBind(fn, ctx) {</span><span class="s2">\n  </span><span class="s1">function boundFn(a) {</span><span class="s2">\n    </span><span class="s1">var l = arguments.length;</span><span class="s2">\n    </span><span class="s1">return l ? l &gt; 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">boundFn._length = fn.length;</span><span class="s2">\n  </span><span class="s1">return boundFn;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function nativeBind(fn, ctx) {</span><span class="s2">\n  </span><span class="s1">return fn.bind(ctx);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// @ts-expect-error bind cannot be `undefined`</span><span class="s2">\n</span><span class="s1">var bind = Function.prototype.bind ? nativeBind : polyfillBind;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Convert an Array-like object to a real Array.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function toArray(list, start) {</span><span class="s2">\n  </span><span class="s1">start = start || 0;</span><span class="s2">\n  </span><span class="s1">var i = list.length - start;</span><span class="s2">\n  </span><span class="s1">var ret = new Array(i);</span><span class="s2">\n  </span><span class="s1">while (i--) {</span><span class="s2">\n    </span><span class="s1">ret[i] = list[i + start];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return ret;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Mix properties into target object.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function extend(to, _from) {</span><span class="s2">\n  </span><span class="s1">for (var key in _from) {</span><span class="s2">\n    </span><span class="s1">to[key] = _from[key];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return to;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Merge an Array of Objects into a single Object.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function toObject(arr) {</span><span class="s2">\n  </span><span class="s1">var res = {};</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; arr.length; i++) {</span><span class="s2">\n    </span><span class="s1">if (arr[i]) {</span><span class="s2">\n      </span><span class="s1">extend(res, arr[i]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/* eslint-disable no-unused-vars */</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Perform no operation.</span><span class="s2">\n </span><span class="s1">* Stubbing args to make Flow happy without leaving useless transpiled code</span><span class="s2">\n </span><span class="s1">* with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function noop(a, b, c) {}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Always return false.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var no = function (a, b, c) {</span><span class="s2">\n  </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/* eslint-enable no-unused-vars */</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Return the same value.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var identity = function (_) {</span><span class="s2">\n  </span><span class="s1">return _;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Check if two values are loosely equal - that is,</span><span class="s2">\n </span><span class="s1">* if they are plain objects, do they have the same shape?</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function looseEqual(a, b) {</span><span class="s2">\n  </span><span class="s1">if (a === b) return true;</span><span class="s2">\n  </span><span class="s1">var isObjectA = isObject(a);</span><span class="s2">\n  </span><span class="s1">var isObjectB = isObject(b);</span><span class="s2">\n  </span><span class="s1">if (isObjectA &amp;&amp; isObjectB) {</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">var isArrayA = Array.isArray(a);</span><span class="s2">\n      </span><span class="s1">var isArrayB = Array.isArray(b);</span><span class="s2">\n      </span><span class="s1">if (isArrayA &amp;&amp; isArrayB) {</span><span class="s2">\n        </span><span class="s1">return a.length === b.length &amp;&amp; a.every(function (e, i) {</span><span class="s2">\n          </span><span class="s1">return looseEqual(e, b[i]);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} else if (a instanceof Date &amp;&amp; b instanceof Date) {</span><span class="s2">\n        </span><span class="s1">return a.getTime() === b.getTime();</span><span class="s2">\n      </span><span class="s1">} else if (!isArrayA &amp;&amp; !isArrayB) {</span><span class="s2">\n        </span><span class="s1">var keysA = Object.keys(a);</span><span class="s2">\n        </span><span class="s1">var keysB = Object.keys(b);</span><span class="s2">\n        </span><span class="s1">return keysA.length === keysB.length &amp;&amp; keysA.every(function (key) {</span><span class="s2">\n          </span><span class="s1">return looseEqual(a[key], b[key]);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (!isObjectA &amp;&amp; !isObjectB) {</span><span class="s2">\n    </span><span class="s1">return String(a) === String(b);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Return the first index at which a loosely equal value can be</span><span class="s2">\n </span><span class="s1">* found in the array (if value is a plain object, the array must</span><span class="s2">\n </span><span class="s1">* contain an object of the same shape), or -1 if it is not present.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function looseIndexOf(arr, val) {</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; arr.length; i++) {</span><span class="s2">\n    </span><span class="s1">if (looseEqual(arr[i], val)) return i;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return -1;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Ensure a function is called only once.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function once(fn) {</span><span class="s2">\n  </span><span class="s1">var called = false;</span><span class="s2">\n  </span><span class="s1">return function () {</span><span class="s2">\n    </span><span class="s1">if (!called) {</span><span class="s2">\n      </span><span class="s1">called = true;</span><span class="s2">\n      </span><span class="s1">fn.apply(this, arguments);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill</span><span class="s2">\n</span><span class="s1">function hasChanged(x, y) {</span><span class="s2">\n  </span><span class="s1">if (x === y) {</span><span class="s2">\n    </span><span class="s1">return x === 0 &amp;&amp; 1 / x !== 1 / y;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return x === x || y === y;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var SSR_ATTR = 'data-server-rendered';</span><span class="s2">\n</span><span class="s1">var ASSET_TYPES = ['component', 'directive', 'filter'];</span><span class="s2">\n</span><span class="s1">var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch', 'renderTracked', 'renderTriggered'];</span><span class="s2">\n</span><span class="s1">var config = {</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Option merge strategies (used in core/util/options)</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">// $flow-disable-line</span><span class="s2">\n  </span><span class="s1">optionMergeStrategies: Object.create(null),</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Whether to suppress warnings.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">silent: false,</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Show production mode tip message on boot?</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">productionTip: process.env.NODE_ENV !== 'production',</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Whether to enable devtools</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">devtools: process.env.NODE_ENV !== 'production',</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Whether to record perf</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">performance: false,</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Error handler for watcher errors</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">errorHandler: null,</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Warn handler for watcher warns</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">warnHandler: null,</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Ignore certain custom elements</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ignoredElements: [],</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Custom user key aliases for v-on</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">// $flow-disable-line</span><span class="s2">\n  </span><span class="s1">keyCodes: Object.create(null),</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Check if a tag is reserved so that it cannot be registered as a</span><span class="s2">\n   </span><span class="s1">* component. This is platform-dependent and may be overwritten.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">isReservedTag: no,</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Check if an attribute is reserved so that it cannot be used as a component</span><span class="s2">\n   </span><span class="s1">* prop. This is platform-dependent and may be overwritten.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">isReservedAttr: no,</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Check if a tag is an unknown element.</span><span class="s2">\n   </span><span class="s1">* Platform-dependent.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">isUnknownElement: no,</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Get the namespace of an element</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">getTagNamespace: noop,</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Parse the real tag name for the specific platform.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">parsePlatformTagName: identity,</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Check if an attribute must be bound using property, e.g. value</span><span class="s2">\n   </span><span class="s1">* Platform-dependent.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">mustUseProp: no,</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Perform updates asynchronously. Intended to be used by Vue Test Utils</span><span class="s2">\n   </span><span class="s1">* This will significantly reduce performance if set to false.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">async: true,</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Exposed for legacy reasons</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">_lifecycleHooks: LIFECYCLE_HOOKS</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* unicode letters used for parsing html tags, component names and property paths.</span><span class="s2">\n </span><span class="s1">* using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname</span><span class="s2">\n </span><span class="s1">* skipping </span><span class="s2">\\</span><span class="s1">u10000-</span><span class="s2">\\</span><span class="s1">uEFFFF due to it freezing up PhantomJS</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var unicodeRegExp = /a-zA-Z</span><span class="s2">\\</span><span class="s1">u00B7</span><span class="s2">\\</span><span class="s1">u00C0-</span><span class="s2">\\</span><span class="s1">u00D6</span><span class="s2">\\</span><span class="s1">u00D8-</span><span class="s2">\\</span><span class="s1">u00F6</span><span class="s2">\\</span><span class="s1">u00F8-</span><span class="s2">\\</span><span class="s1">u037D</span><span class="s2">\\</span><span class="s1">u037F-</span><span class="s2">\\</span><span class="s1">u1FFF</span><span class="s2">\\</span><span class="s1">u200C-</span><span class="s2">\\</span><span class="s1">u200D</span><span class="s2">\\</span><span class="s1">u203F-</span><span class="s2">\\</span><span class="s1">u2040</span><span class="s2">\\</span><span class="s1">u2070-</span><span class="s2">\\</span><span class="s1">u218F</span><span class="s2">\\</span><span class="s1">u2C00-</span><span class="s2">\\</span><span class="s1">u2FEF</span><span class="s2">\\</span><span class="s1">u3001-</span><span class="s2">\\</span><span class="s1">uD7FF</span><span class="s2">\\</span><span class="s1">uF900-</span><span class="s2">\\</span><span class="s1">uFDCF</span><span class="s2">\\</span><span class="s1">uFDF0-</span><span class="s2">\\</span><span class="s1">uFFFD/;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Check if a string starts with $ or _</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isReserved(str) {</span><span class="s2">\n  </span><span class="s1">var c = (str + '').charCodeAt(0);</span><span class="s2">\n  </span><span class="s1">return c === 0x24 || c === 0x5f;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Define a property.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function def(obj, key, val, enumerable) {</span><span class="s2">\n  </span><span class="s1">Object.defineProperty(obj, key, {</span><span class="s2">\n    </span><span class="s1">value: val,</span><span class="s2">\n    </span><span class="s1">enumerable: !!enumerable,</span><span class="s2">\n    </span><span class="s1">writable: true,</span><span class="s2">\n    </span><span class="s1">configurable: true</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Parse simple path.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var bailRE = new RegExp(</span><span class="s2">\&quot;</span><span class="s1">[^</span><span class="s2">\&quot;</span><span class="s1">.concat(unicodeRegExp.source, </span><span class="s2">\&quot;</span><span class="s1">.$_</span><span class="s2">\\\\</span><span class="s1">d]</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n</span><span class="s1">function parsePath(path) {</span><span class="s2">\n  </span><span class="s1">if (bailRE.test(path)) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var segments = path.split('.');</span><span class="s2">\n  </span><span class="s1">return function (obj) {</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; segments.length; i++) {</span><span class="s2">\n      </span><span class="s1">if (!obj) return;</span><span class="s2">\n      </span><span class="s1">obj = obj[segments[i]];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return obj;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// can we use __proto__?</span><span class="s2">\n</span><span class="s1">var hasProto = ('__proto__' in {});</span><span class="s2">\n</span><span class="s1">// Browser environment sniffing</span><span class="s2">\n</span><span class="s1">var inBrowser = typeof window !== 'undefined';</span><span class="s2">\n</span><span class="s1">var UA = inBrowser &amp;&amp; window.navigator.userAgent.toLowerCase();</span><span class="s2">\n</span><span class="s1">var isIE = UA &amp;&amp; /msie|trident/.test(UA);</span><span class="s2">\n</span><span class="s1">var isIE9 = UA &amp;&amp; UA.indexOf('msie 9.0') &gt; 0;</span><span class="s2">\n</span><span class="s1">var isEdge = UA &amp;&amp; UA.indexOf('edge/') &gt; 0;</span><span class="s2">\n</span><span class="s1">UA &amp;&amp; UA.indexOf('android') &gt; 0;</span><span class="s2">\n</span><span class="s1">var isIOS = UA &amp;&amp; /iphone|ipad|ipod|ios/.test(UA);</span><span class="s2">\n</span><span class="s1">UA &amp;&amp; /chrome</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">d+/.test(UA) &amp;&amp; !isEdge;</span><span class="s2">\n</span><span class="s1">UA &amp;&amp; /phantomjs/.test(UA);</span><span class="s2">\n</span><span class="s1">var isFF = UA &amp;&amp; UA.match(/firefox</span><span class="s2">\\</span><span class="s1">/(</span><span class="s2">\\</span><span class="s1">d+)/);</span><span class="s2">\n</span><span class="s1">// Firefox has a </span><span class="s2">\&quot;</span><span class="s1">watch</span><span class="s2">\&quot; </span><span class="s1">function on Object.prototype...</span><span class="s2">\n</span><span class="s1">// @ts-expect-error firebox support</span><span class="s2">\n</span><span class="s1">var nativeWatch = {}.watch;</span><span class="s2">\n</span><span class="s1">var supportsPassive = false;</span><span class="s2">\n</span><span class="s1">if (inBrowser) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">var opts = {};</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(opts, 'passive', {</span><span class="s2">\n      </span><span class="s1">get: function () {</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n        </span><span class="s1">supportsPassive = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}); // https://github.com/facebook/flow/issues/285</span><span class="s2">\n    </span><span class="s1">window.addEventListener('test-passive', null, opts);</span><span class="s2">\n  </span><span class="s1">} catch (e) {}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// this needs to be lazy-evaled because vue may be required before</span><span class="s2">\n</span><span class="s1">// vue-server-renderer can set VUE_ENV</span><span class="s2">\n</span><span class="s1">var _isServer;</span><span class="s2">\n</span><span class="s1">var isServerRendering = function () {</span><span class="s2">\n  </span><span class="s1">if (_isServer === undefined) {</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (!inBrowser &amp;&amp; typeof global !== 'undefined') {</span><span class="s2">\n      </span><span class="s1">// detect presence of vue-server-renderer and avoid</span><span class="s2">\n      </span><span class="s1">// Webpack shimming the process</span><span class="s2">\n      </span><span class="s1">_isServer = global['process'] &amp;&amp; global['process'].env.VUE_ENV === 'server';</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">_isServer = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return _isServer;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">// detect devtools</span><span class="s2">\n</span><span class="s1">var devtools = inBrowser &amp;&amp; window.__VUE_DEVTOOLS_GLOBAL_HOOK__;</span><span class="s2">\n</span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n</span><span class="s1">function isNative(Ctor) {</span><span class="s2">\n  </span><span class="s1">return typeof Ctor === 'function' &amp;&amp; /native code/.test(Ctor.toString());</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var hasSymbol = typeof Symbol !== 'undefined' &amp;&amp; isNative(Symbol) &amp;&amp; typeof Reflect !== 'undefined' &amp;&amp; isNative(Reflect.ownKeys);</span><span class="s2">\n</span><span class="s1">var _Set; // $flow-disable-line</span><span class="s2">\n</span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n</span><span class="s1">if (typeof Set !== 'undefined' &amp;&amp; isNative(Set)) {</span><span class="s2">\n  </span><span class="s1">// use native Set when available.</span><span class="s2">\n  </span><span class="s1">_Set = Set;</span><span class="s2">\n</span><span class="s1">} else {</span><span class="s2">\n  </span><span class="s1">// a non-standard Set polyfill that only works with primitive keys.</span><span class="s2">\n  </span><span class="s1">_Set = /** @class */function () {</span><span class="s2">\n    </span><span class="s1">function Set() {</span><span class="s2">\n      </span><span class="s1">this.set = Object.create(null);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">Set.prototype.has = function (key) {</span><span class="s2">\n      </span><span class="s1">return this.set[key] === true;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">Set.prototype.add = function (key) {</span><span class="s2">\n      </span><span class="s1">this.set[key] = true;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">Set.prototype.clear = function () {</span><span class="s2">\n      </span><span class="s1">this.set = Object.create(null);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return Set;</span><span class="s2">\n  </span><span class="s1">}();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var currentInstance = null;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* This is exposed for compatibility with v3 (e.g. some functions in VueUse</span><span class="s2">\n </span><span class="s1">* relies on it). Do not use this internally, just use `currentInstance`.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @internal this function needs manual type declaration because it relies</span><span class="s2">\n </span><span class="s1">* on previously manually authored types from Vue 2</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function getCurrentInstance() {</span><span class="s2">\n  </span><span class="s1">return currentInstance &amp;&amp; {</span><span class="s2">\n    </span><span class="s1">proxy: currentInstance</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function setCurrentInstance(vm) {</span><span class="s2">\n  </span><span class="s1">if (vm === void 0) {</span><span class="s2">\n    </span><span class="s1">vm = null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!vm) currentInstance &amp;&amp; currentInstance._scope.off();</span><span class="s2">\n  </span><span class="s1">currentInstance = vm;</span><span class="s2">\n  </span><span class="s1">vm &amp;&amp; vm._scope.on();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var VNode = /** @class */function () {</span><span class="s2">\n  </span><span class="s1">function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {</span><span class="s2">\n    </span><span class="s1">this.tag = tag;</span><span class="s2">\n    </span><span class="s1">this.data = data;</span><span class="s2">\n    </span><span class="s1">this.children = children;</span><span class="s2">\n    </span><span class="s1">this.text = text;</span><span class="s2">\n    </span><span class="s1">this.elm = elm;</span><span class="s2">\n    </span><span class="s1">this.ns = undefined;</span><span class="s2">\n    </span><span class="s1">this.context = context;</span><span class="s2">\n    </span><span class="s1">this.fnContext = undefined;</span><span class="s2">\n    </span><span class="s1">this.fnOptions = undefined;</span><span class="s2">\n    </span><span class="s1">this.fnScopeId = undefined;</span><span class="s2">\n    </span><span class="s1">this.key = data &amp;&amp; data.key;</span><span class="s2">\n    </span><span class="s1">this.componentOptions = componentOptions;</span><span class="s2">\n    </span><span class="s1">this.componentInstance = undefined;</span><span class="s2">\n    </span><span class="s1">this.parent = undefined;</span><span class="s2">\n    </span><span class="s1">this.raw = false;</span><span class="s2">\n    </span><span class="s1">this.isStatic = false;</span><span class="s2">\n    </span><span class="s1">this.isRootInsert = true;</span><span class="s2">\n    </span><span class="s1">this.isComment = false;</span><span class="s2">\n    </span><span class="s1">this.isCloned = false;</span><span class="s2">\n    </span><span class="s1">this.isOnce = false;</span><span class="s2">\n    </span><span class="s1">this.asyncFactory = asyncFactory;</span><span class="s2">\n    </span><span class="s1">this.asyncMeta = undefined;</span><span class="s2">\n    </span><span class="s1">this.isAsyncPlaceholder = false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">Object.defineProperty(VNode.prototype, </span><span class="s2">\&quot;</span><span class="s1">child</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">// DEPRECATED: alias for componentInstance for backwards compat.</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n    </span><span class="s1">get: function () {</span><span class="s2">\n      </span><span class="s1">return this.componentInstance;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">enumerable: false,</span><span class="s2">\n    </span><span class="s1">configurable: true</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return VNode;</span><span class="s2">\n</span><span class="s1">}();</span><span class="s2">\n</span><span class="s1">var createEmptyVNode = function (text) {</span><span class="s2">\n  </span><span class="s1">if (text === void 0) {</span><span class="s2">\n    </span><span class="s1">text = '';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var node = new VNode();</span><span class="s2">\n  </span><span class="s1">node.text = text;</span><span class="s2">\n  </span><span class="s1">node.isComment = true;</span><span class="s2">\n  </span><span class="s1">return node;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function createTextVNode(val) {</span><span class="s2">\n  </span><span class="s1">return new VNode(undefined, undefined, undefined, String(val));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// optimized shallow clone</span><span class="s2">\n</span><span class="s1">// used for static nodes and slot nodes because they may be reused across</span><span class="s2">\n</span><span class="s1">// multiple renders, cloning them avoids errors when DOM manipulations rely</span><span class="s2">\n</span><span class="s1">// on their elm reference.</span><span class="s2">\n</span><span class="s1">function cloneVNode(vnode) {</span><span class="s2">\n  </span><span class="s1">var cloned = new VNode(vnode.tag, vnode.data,</span><span class="s2">\n  </span><span class="s1">// #7975</span><span class="s2">\n  </span><span class="s1">// clone children array to avoid mutating original in case of cloning</span><span class="s2">\n  </span><span class="s1">// a child.</span><span class="s2">\n  </span><span class="s1">vnode.children &amp;&amp; vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);</span><span class="s2">\n  </span><span class="s1">cloned.ns = vnode.ns;</span><span class="s2">\n  </span><span class="s1">cloned.isStatic = vnode.isStatic;</span><span class="s2">\n  </span><span class="s1">cloned.key = vnode.key;</span><span class="s2">\n  </span><span class="s1">cloned.isComment = vnode.isComment;</span><span class="s2">\n  </span><span class="s1">cloned.fnContext = vnode.fnContext;</span><span class="s2">\n  </span><span class="s1">cloned.fnOptions = vnode.fnOptions;</span><span class="s2">\n  </span><span class="s1">cloned.fnScopeId = vnode.fnScopeId;</span><span class="s2">\n  </span><span class="s1">cloned.asyncMeta = vnode.asyncMeta;</span><span class="s2">\n  </span><span class="s1">cloned.isCloned = true;</span><span class="s2">\n  </span><span class="s1">return cloned;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/******************************************************************************</span><span class="s2">\r\n</span><span class="s1">Copyright (c) Microsoft Corporation.</span><span class="s2">\r\n\r\n</span><span class="s1">Permission to use, copy, modify, and/or distribute this software for any</span><span class="s2">\r\n</span><span class="s1">purpose with or without fee is hereby granted.</span><span class="s2">\r\n\r\n</span><span class="s1">THE SOFTWARE IS PROVIDED </span><span class="s2">\&quot;</span><span class="s1">AS IS</span><span class="s2">\&quot; </span><span class="s1">AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH</span><span class="s2">\r\n</span><span class="s1">REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY</span><span class="s2">\r\n</span><span class="s1">AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,</span><span class="s2">\r\n</span><span class="s1">INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM</span><span class="s2">\r\n</span><span class="s1">LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR</span><span class="s2">\r\n</span><span class="s1">OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR</span><span class="s2">\r\n</span><span class="s1">PERFORMANCE OF THIS SOFTWARE.</span><span class="s2">\r\n</span><span class="s1">***************************************************************************** */</span><span class="s2">\n\n</span><span class="s1">var __assign = function () {</span><span class="s2">\n  </span><span class="s1">__assign = Object.assign || function __assign(t) {</span><span class="s2">\n    </span><span class="s1">for (var s, i = 1, n = arguments.length; i &lt; n; i++) {</span><span class="s2">\n      </span><span class="s1">s = arguments[i];</span><span class="s2">\n      </span><span class="s1">for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return t;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return __assign.apply(this, arguments);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var uid$2 = 0;</span><span class="s2">\n</span><span class="s1">var pendingCleanupDeps = [];</span><span class="s2">\n</span><span class="s1">var cleanupDeps = function () {</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; pendingCleanupDeps.length; i++) {</span><span class="s2">\n    </span><span class="s1">var dep = pendingCleanupDeps[i];</span><span class="s2">\n    </span><span class="s1">dep.subs = dep.subs.filter(function (s) {</span><span class="s2">\n      </span><span class="s1">return s;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">dep._pending = false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">pendingCleanupDeps.length = 0;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* A dep is an observable that can have multiple</span><span class="s2">\n </span><span class="s1">* directives subscribing to it.</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var Dep = /** @class */function () {</span><span class="s2">\n  </span><span class="s1">function Dep() {</span><span class="s2">\n    </span><span class="s1">// pending subs cleanup</span><span class="s2">\n    </span><span class="s1">this._pending = false;</span><span class="s2">\n    </span><span class="s1">this.id = uid$2++;</span><span class="s2">\n    </span><span class="s1">this.subs = [];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">Dep.prototype.addSub = function (sub) {</span><span class="s2">\n    </span><span class="s1">this.subs.push(sub);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">Dep.prototype.removeSub = function (sub) {</span><span class="s2">\n    </span><span class="s1">// #12696 deps with massive amount of subscribers are extremely slow to</span><span class="s2">\n    </span><span class="s1">// clean up in Chromium</span><span class="s2">\n    </span><span class="s1">// to workaround this, we unset the sub for now, and clear them on</span><span class="s2">\n    </span><span class="s1">// next scheduler flush.</span><span class="s2">\n    </span><span class="s1">this.subs[this.subs.indexOf(sub)] = null;</span><span class="s2">\n    </span><span class="s1">if (!this._pending) {</span><span class="s2">\n      </span><span class="s1">this._pending = true;</span><span class="s2">\n      </span><span class="s1">pendingCleanupDeps.push(this);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">Dep.prototype.depend = function (info) {</span><span class="s2">\n    </span><span class="s1">if (Dep.target) {</span><span class="s2">\n      </span><span class="s1">Dep.target.addDep(this);</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; info &amp;&amp; Dep.target.onTrack) {</span><span class="s2">\n        </span><span class="s1">Dep.target.onTrack(__assign({</span><span class="s2">\n          </span><span class="s1">effect: Dep.target</span><span class="s2">\n        </span><span class="s1">}, info));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">Dep.prototype.notify = function (info) {</span><span class="s2">\n    </span><span class="s1">// stabilize the subscriber list first</span><span class="s2">\n    </span><span class="s1">var subs = this.subs.filter(function (s) {</span><span class="s2">\n      </span><span class="s1">return s;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) {</span><span class="s2">\n      </span><span class="s1">// subs aren't sorted in scheduler if not running async</span><span class="s2">\n      </span><span class="s1">// we need to sort them now to make sure they fire in correct</span><span class="s2">\n      </span><span class="s1">// order</span><span class="s2">\n      </span><span class="s1">subs.sort(function (a, b) {</span><span class="s2">\n        </span><span class="s1">return a.id - b.id;</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (var i = 0, l = subs.length; i &lt; l; i++) {</span><span class="s2">\n      </span><span class="s1">var sub = subs[i];</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; info) {</span><span class="s2">\n        </span><span class="s1">sub.onTrigger &amp;&amp; sub.onTrigger(__assign({</span><span class="s2">\n          </span><span class="s1">effect: subs[i]</span><span class="s2">\n        </span><span class="s1">}, info));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">sub.update();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return Dep;</span><span class="s2">\n</span><span class="s1">}();</span><span class="s2">\n</span><span class="s1">// The current target watcher being evaluated.</span><span class="s2">\n</span><span class="s1">// This is globally unique because only one watcher</span><span class="s2">\n</span><span class="s1">// can be evaluated at a time.</span><span class="s2">\n</span><span class="s1">Dep.target = null;</span><span class="s2">\n</span><span class="s1">var targetStack = [];</span><span class="s2">\n</span><span class="s1">function pushTarget(target) {</span><span class="s2">\n  </span><span class="s1">targetStack.push(target);</span><span class="s2">\n  </span><span class="s1">Dep.target = target;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function popTarget() {</span><span class="s2">\n  </span><span class="s1">targetStack.pop();</span><span class="s2">\n  </span><span class="s1">Dep.target = targetStack[targetStack.length - 1];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*</span><span class="s2">\n </span><span class="s1">* not type checking this file because flow doesn't play well with</span><span class="s2">\n </span><span class="s1">* dynamically accessing methods on Array prototype</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var arrayProto = Array.prototype;</span><span class="s2">\n</span><span class="s1">var arrayMethods = Object.create(arrayProto);</span><span class="s2">\n</span><span class="s1">var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Intercept mutating methods and emit events</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">methodsToPatch.forEach(function (method) {</span><span class="s2">\n  </span><span class="s1">// cache original method</span><span class="s2">\n  </span><span class="s1">var original = arrayProto[method];</span><span class="s2">\n  </span><span class="s1">def(arrayMethods, method, function mutator() {</span><span class="s2">\n    </span><span class="s1">var args = [];</span><span class="s2">\n    </span><span class="s1">for (var _i = 0; _i &lt; arguments.length; _i++) {</span><span class="s2">\n      </span><span class="s1">args[_i] = arguments[_i];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var result = original.apply(this, args);</span><span class="s2">\n    </span><span class="s1">var ob = this.__ob__;</span><span class="s2">\n    </span><span class="s1">var inserted;</span><span class="s2">\n    </span><span class="s1">switch (method) {</span><span class="s2">\n      </span><span class="s1">case 'push':</span><span class="s2">\n      </span><span class="s1">case 'unshift':</span><span class="s2">\n        </span><span class="s1">inserted = args;</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">case 'splice':</span><span class="s2">\n        </span><span class="s1">inserted = args.slice(2);</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (inserted) ob.observeArray(inserted);</span><span class="s2">\n    </span><span class="s1">// notify change</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">ob.dep.notify({</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">array mutation</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.ARRAY_MUTATION */,</span><span class="s2">\n        </span><span class="s1">target: this,</span><span class="s2">\n        </span><span class="s1">key: method</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">ob.dep.notify();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return result;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">var arrayKeys = Object.getOwnPropertyNames(arrayMethods);</span><span class="s2">\n</span><span class="s1">var NO_INIITIAL_VALUE = {};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* In some cases we may want to disable observation inside a component's</span><span class="s2">\n </span><span class="s1">* update computation.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var shouldObserve = true;</span><span class="s2">\n</span><span class="s1">function toggleObserving(value) {</span><span class="s2">\n  </span><span class="s1">shouldObserve = value;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// ssr mock dep</span><span class="s2">\n</span><span class="s1">var mockDep = {</span><span class="s2">\n  </span><span class="s1">notify: noop,</span><span class="s2">\n  </span><span class="s1">depend: noop,</span><span class="s2">\n  </span><span class="s1">addSub: noop,</span><span class="s2">\n  </span><span class="s1">removeSub: noop</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Observer class that is attached to each observed</span><span class="s2">\n </span><span class="s1">* object. Once attached, the observer converts the target</span><span class="s2">\n </span><span class="s1">* object's property keys into getter/setters that</span><span class="s2">\n </span><span class="s1">* collect dependencies and dispatch updates.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var Observer = /** @class */function () {</span><span class="s2">\n  </span><span class="s1">function Observer(value, shallow, mock) {</span><span class="s2">\n    </span><span class="s1">if (shallow === void 0) {</span><span class="s2">\n      </span><span class="s1">shallow = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (mock === void 0) {</span><span class="s2">\n      </span><span class="s1">mock = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.value = value;</span><span class="s2">\n    </span><span class="s1">this.shallow = shallow;</span><span class="s2">\n    </span><span class="s1">this.mock = mock;</span><span class="s2">\n    </span><span class="s1">// this.value = value</span><span class="s2">\n    </span><span class="s1">this.dep = mock ? mockDep : new Dep();</span><span class="s2">\n    </span><span class="s1">this.vmCount = 0;</span><span class="s2">\n    </span><span class="s1">def(value, '__ob__', this);</span><span class="s2">\n    </span><span class="s1">if (isArray(value)) {</span><span class="s2">\n      </span><span class="s1">if (!mock) {</span><span class="s2">\n        </span><span class="s1">if (hasProto) {</span><span class="s2">\n          </span><span class="s1">value.__proto__ = arrayMethods;</span><span class="s2">\n          </span><span class="s1">/* eslint-enable no-proto */</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">for (var i = 0, l = arrayKeys.length; i &lt; l; i++) {</span><span class="s2">\n            </span><span class="s1">var key = arrayKeys[i];</span><span class="s2">\n            </span><span class="s1">def(value, key, arrayMethods[key]);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (!shallow) {</span><span class="s2">\n        </span><span class="s1">this.observeArray(value);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">/**</span><span class="s2">\n       </span><span class="s1">* Walk through all properties and convert them into</span><span class="s2">\n       </span><span class="s1">* getter/setters. This method should only be called when</span><span class="s2">\n       </span><span class="s1">* value type is Object.</span><span class="s2">\n       </span><span class="s1">*/</span><span class="s2">\n      </span><span class="s1">var keys = Object.keys(value);</span><span class="s2">\n      </span><span class="s1">for (var i = 0; i &lt; keys.length; i++) {</span><span class="s2">\n        </span><span class="s1">var key = keys[i];</span><span class="s2">\n        </span><span class="s1">defineReactive(value, key, NO_INIITIAL_VALUE, undefined, shallow, mock);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Observe a list of Array items.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">Observer.prototype.observeArray = function (value) {</span><span class="s2">\n    </span><span class="s1">for (var i = 0, l = value.length; i &lt; l; i++) {</span><span class="s2">\n      </span><span class="s1">observe(value[i], false, this.mock);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return Observer;</span><span class="s2">\n</span><span class="s1">}();</span><span class="s2">\n</span><span class="s1">// helpers</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Attempt to create an observer instance for a value,</span><span class="s2">\n </span><span class="s1">* returns the new observer if successfully observed,</span><span class="s2">\n </span><span class="s1">* or the existing observer if the value already has one.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function observe(value, shallow, ssrMockReactivity) {</span><span class="s2">\n  </span><span class="s1">if (value &amp;&amp; hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) {</span><span class="s2">\n    </span><span class="s1">return value.__ob__;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (shouldObserve &amp;&amp; (ssrMockReactivity || !isServerRendering()) &amp;&amp; (isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value.__v_skip /* ReactiveFlags.SKIP */ &amp;&amp; !isRef(value) &amp;&amp; !(value instanceof VNode)) {</span><span class="s2">\n    </span><span class="s1">return new Observer(value, shallow, ssrMockReactivity);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Define a reactive property on an Object.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function defineReactive(obj, key, val, customSetter, shallow, mock) {</span><span class="s2">\n  </span><span class="s1">var dep = new Dep();</span><span class="s2">\n  </span><span class="s1">var property = Object.getOwnPropertyDescriptor(obj, key);</span><span class="s2">\n  </span><span class="s1">if (property &amp;&amp; property.configurable === false) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// cater for pre-defined getter/setters</span><span class="s2">\n  </span><span class="s1">var getter = property &amp;&amp; property.get;</span><span class="s2">\n  </span><span class="s1">var setter = property &amp;&amp; property.set;</span><span class="s2">\n  </span><span class="s1">if ((!getter || setter) &amp;&amp; (val === NO_INIITIAL_VALUE || arguments.length === 2)) {</span><span class="s2">\n    </span><span class="s1">val = obj[key];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var childOb = !shallow &amp;&amp; observe(val, false, mock);</span><span class="s2">\n  </span><span class="s1">Object.defineProperty(obj, key, {</span><span class="s2">\n    </span><span class="s1">enumerable: true,</span><span class="s2">\n    </span><span class="s1">configurable: true,</span><span class="s2">\n    </span><span class="s1">get: function reactiveGetter() {</span><span class="s2">\n      </span><span class="s1">var value = getter ? getter.call(obj) : val;</span><span class="s2">\n      </span><span class="s1">if (Dep.target) {</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n          </span><span class="s1">dep.depend({</span><span class="s2">\n            </span><span class="s1">target: obj,</span><span class="s2">\n            </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.GET */,</span><span class="s2">\n            </span><span class="s1">key: key</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">dep.depend();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (childOb) {</span><span class="s2">\n          </span><span class="s1">childOb.dep.depend();</span><span class="s2">\n          </span><span class="s1">if (isArray(value)) {</span><span class="s2">\n            </span><span class="s1">dependArray(value);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return isRef(value) &amp;&amp; !shallow ? value.value : value;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">set: function reactiveSetter(newVal) {</span><span class="s2">\n      </span><span class="s1">var value = getter ? getter.call(obj) : val;</span><span class="s2">\n      </span><span class="s1">if (!hasChanged(value, newVal)) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) {</span><span class="s2">\n        </span><span class="s1">customSetter();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (setter) {</span><span class="s2">\n        </span><span class="s1">setter.call(obj, newVal);</span><span class="s2">\n      </span><span class="s1">} else if (getter) {</span><span class="s2">\n        </span><span class="s1">// #7981: for accessor properties without setter</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">} else if (!shallow &amp;&amp; isRef(value) &amp;&amp; !isRef(newVal)) {</span><span class="s2">\n        </span><span class="s1">value.value = newVal;</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">val = newVal;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">childOb = !shallow &amp;&amp; observe(newVal, false, mock);</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">dep.notify({</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.SET */,</span><span class="s2">\n          </span><span class="s1">target: obj,</span><span class="s2">\n          </span><span class="s1">key: key,</span><span class="s2">\n          </span><span class="s1">newValue: newVal,</span><span class="s2">\n          </span><span class="s1">oldValue: value</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">dep.notify();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return dep;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function set(target, key, val) {</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; (isUndef(target) || isPrimitive(target))) {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Cannot set reactive property on undefined, null, or primitive value: </span><span class="s2">\&quot;</span><span class="s1">.concat(target));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isReadonly(target)) {</span><span class="s2">\n    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">Set operation on key </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">failed: target is readonly.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var ob = target.__ob__;</span><span class="s2">\n  </span><span class="s1">if (isArray(target) &amp;&amp; isValidArrayIndex(key)) {</span><span class="s2">\n    </span><span class="s1">target.length = Math.max(target.length, key);</span><span class="s2">\n    </span><span class="s1">target.splice(key, 1, val);</span><span class="s2">\n    </span><span class="s1">// when mocking for SSR, array methods are not hijacked</span><span class="s2">\n    </span><span class="s1">if (ob &amp;&amp; !ob.shallow &amp;&amp; ob.mock) {</span><span class="s2">\n      </span><span class="s1">observe(val, false, true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return val;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (key in target &amp;&amp; !(key in Object.prototype)) {</span><span class="s2">\n    </span><span class="s1">target[key] = val;</span><span class="s2">\n    </span><span class="s1">return val;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (target._isVue || ob &amp;&amp; ob.vmCount) {</span><span class="s2">\n    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');</span><span class="s2">\n    </span><span class="s1">return val;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!ob) {</span><span class="s2">\n    </span><span class="s1">target[key] = val;</span><span class="s2">\n    </span><span class="s1">return val;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">ob.dep.notify({</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">add</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.ADD */,</span><span class="s2">\n      </span><span class="s1">target: target,</span><span class="s2">\n      </span><span class="s1">key: key,</span><span class="s2">\n      </span><span class="s1">newValue: val,</span><span class="s2">\n      </span><span class="s1">oldValue: undefined</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">ob.dep.notify();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return val;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function del(target, key) {</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; (isUndef(target) || isPrimitive(target))) {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Cannot delete reactive property on undefined, null, or primitive value: </span><span class="s2">\&quot;</span><span class="s1">.concat(target));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isArray(target) &amp;&amp; isValidArrayIndex(key)) {</span><span class="s2">\n    </span><span class="s1">target.splice(key, 1);</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var ob = target.__ob__;</span><span class="s2">\n  </span><span class="s1">if (target._isVue || ob &amp;&amp; ob.vmCount) {</span><span class="s2">\n    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isReadonly(target)) {</span><span class="s2">\n    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">Delete operation on key </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">failed: target is readonly.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!hasOwn(target, key)) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">delete target[key];</span><span class="s2">\n  </span><span class="s1">if (!ob) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">ob.dep.notify({</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">delete</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.DELETE */,</span><span class="s2">\n      </span><span class="s1">target: target,</span><span class="s2">\n      </span><span class="s1">key: key</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">ob.dep.notify();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Collect dependencies on array elements when the array is touched, since</span><span class="s2">\n </span><span class="s1">* we cannot intercept array element access like property getters.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function dependArray(value) {</span><span class="s2">\n  </span><span class="s1">for (var e = void 0, i = 0, l = value.length; i &lt; l; i++) {</span><span class="s2">\n    </span><span class="s1">e = value[i];</span><span class="s2">\n    </span><span class="s1">if (e &amp;&amp; e.__ob__) {</span><span class="s2">\n      </span><span class="s1">e.__ob__.dep.depend();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isArray(e)) {</span><span class="s2">\n      </span><span class="s1">dependArray(e);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function reactive(target) {</span><span class="s2">\n  </span><span class="s1">makeReactive(target, false);</span><span class="s2">\n  </span><span class="s1">return target;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Return a shallowly-reactive copy of the original object, where only the root</span><span class="s2">\n </span><span class="s1">* level properties are reactive. It also does not auto-unwrap refs (even at the</span><span class="s2">\n </span><span class="s1">* root level).</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function shallowReactive(target) {</span><span class="s2">\n  </span><span class="s1">makeReactive(target, true);</span><span class="s2">\n  </span><span class="s1">def(target, </span><span class="s2">\&quot;</span><span class="s1">__v_isShallow</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_SHALLOW */, true);</span><span class="s2">\n  </span><span class="s1">return target;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function makeReactive(target, shallow) {</span><span class="s2">\n  </span><span class="s1">// if trying to observe a readonly proxy, return the readonly version.</span><span class="s2">\n  </span><span class="s1">if (!isReadonly(target)) {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">if (isArray(target)) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Avoid using Array as root value for </span><span class="s2">\&quot;</span><span class="s1">.concat(shallow ? </span><span class="s2">\&quot;</span><span class="s1">shallowReactive()</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">reactive()</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot; </span><span class="s1">as it cannot be tracked in watch() or watchEffect(). Use </span><span class="s2">\&quot;</span><span class="s1">).concat(shallow ? </span><span class="s2">\&quot;</span><span class="s1">shallowRef()</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">ref()</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot; </span><span class="s1">instead. This is a Vue-2-only limitation.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">var existingOb = target &amp;&amp; target.__ob__;</span><span class="s2">\n      </span><span class="s1">if (existingOb &amp;&amp; existingOb.shallow !== shallow) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Target is already a </span><span class="s2">\&quot;</span><span class="s1">.concat(existingOb.shallow ? </span><span class="s2">\&quot;\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">non-</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">shallow reactive object, and cannot be converted to </span><span class="s2">\&quot;</span><span class="s1">).concat(shallow ? </span><span class="s2">\&quot;\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">non-</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">shallow.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var ob = observe(target, shallow, isServerRendering() /* ssr mock reactivity */);</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !ob) {</span><span class="s2">\n      </span><span class="s1">if (target == null || isPrimitive(target)) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">value cannot be made reactive: </span><span class="s2">\&quot;</span><span class="s1">.concat(String(target)));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (isCollectionType(target)) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Vue 2 does not support reactive collection types such as Map or Set.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isReactive(value) {</span><span class="s2">\n  </span><span class="s1">if (isReadonly(value)) {</span><span class="s2">\n    </span><span class="s1">return isReactive(value[</span><span class="s2">\&quot;</span><span class="s1">__v_raw</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.RAW */]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return !!(value &amp;&amp; value.__ob__);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isShallow(value) {</span><span class="s2">\n  </span><span class="s1">return !!(value &amp;&amp; value.__v_isShallow);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isReadonly(value) {</span><span class="s2">\n  </span><span class="s1">return !!(value &amp;&amp; value.__v_isReadonly);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isProxy(value) {</span><span class="s2">\n  </span><span class="s1">return isReactive(value) || isReadonly(value);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function toRaw(observed) {</span><span class="s2">\n  </span><span class="s1">var raw = observed &amp;&amp; observed[</span><span class="s2">\&quot;</span><span class="s1">__v_raw</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.RAW */];</span><span class="s2">\n  </span><span class="s1">return raw ? toRaw(raw) : observed;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function markRaw(value) {</span><span class="s2">\n  </span><span class="s1">// non-extensible objects won't be observed anyway</span><span class="s2">\n  </span><span class="s1">if (Object.isExtensible(value)) {</span><span class="s2">\n    </span><span class="s1">def(value, </span><span class="s2">\&quot;</span><span class="s1">__v_skip</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.SKIP */, true);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return value;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isCollectionType(value) {</span><span class="s2">\n  </span><span class="s1">var type = toRawType(value);</span><span class="s2">\n  </span><span class="s1">return type === 'Map' || type === 'WeakMap' || type === 'Set' || type === 'WeakSet';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var RefFlag = </span><span class="s2">\&quot;</span><span class="s1">__v_isRef</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function isRef(r) {</span><span class="s2">\n  </span><span class="s1">return !!(r &amp;&amp; r.__v_isRef === true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function ref$1(value) {</span><span class="s2">\n  </span><span class="s1">return createRef(value, false);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function shallowRef(value) {</span><span class="s2">\n  </span><span class="s1">return createRef(value, true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createRef(rawValue, shallow) {</span><span class="s2">\n  </span><span class="s1">if (isRef(rawValue)) {</span><span class="s2">\n    </span><span class="s1">return rawValue;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var ref = {};</span><span class="s2">\n  </span><span class="s1">def(ref, RefFlag, true);</span><span class="s2">\n  </span><span class="s1">def(ref, </span><span class="s2">\&quot;</span><span class="s1">__v_isShallow</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_SHALLOW */, shallow);</span><span class="s2">\n  </span><span class="s1">def(ref, 'dep', defineReactive(ref, 'value', rawValue, null, shallow, isServerRendering()));</span><span class="s2">\n  </span><span class="s1">return ref;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function triggerRef(ref) {</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !ref.dep) {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">received object is not a triggerable ref.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">ref.dep &amp;&amp; ref.dep.notify({</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.SET */,</span><span class="s2">\n      </span><span class="s1">target: ref,</span><span class="s2">\n      </span><span class="s1">key: 'value'</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">ref.dep &amp;&amp; ref.dep.notify();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function unref(ref) {</span><span class="s2">\n  </span><span class="s1">return isRef(ref) ? ref.value : ref;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function proxyRefs(objectWithRefs) {</span><span class="s2">\n  </span><span class="s1">if (isReactive(objectWithRefs)) {</span><span class="s2">\n    </span><span class="s1">return objectWithRefs;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var proxy = {};</span><span class="s2">\n  </span><span class="s1">var keys = Object.keys(objectWithRefs);</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; keys.length; i++) {</span><span class="s2">\n    </span><span class="s1">proxyWithRefUnwrap(proxy, objectWithRefs, keys[i]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return proxy;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function proxyWithRefUnwrap(target, source, key) {</span><span class="s2">\n  </span><span class="s1">Object.defineProperty(target, key, {</span><span class="s2">\n    </span><span class="s1">enumerable: true,</span><span class="s2">\n    </span><span class="s1">configurable: true,</span><span class="s2">\n    </span><span class="s1">get: function () {</span><span class="s2">\n      </span><span class="s1">var val = source[key];</span><span class="s2">\n      </span><span class="s1">if (isRef(val)) {</span><span class="s2">\n        </span><span class="s1">return val.value;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">var ob = val &amp;&amp; val.__ob__;</span><span class="s2">\n        </span><span class="s1">if (ob) ob.dep.depend();</span><span class="s2">\n        </span><span class="s1">return val;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">set: function (value) {</span><span class="s2">\n      </span><span class="s1">var oldValue = source[key];</span><span class="s2">\n      </span><span class="s1">if (isRef(oldValue) &amp;&amp; !isRef(value)) {</span><span class="s2">\n        </span><span class="s1">oldValue.value = value;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">source[key] = value;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function customRef(factory) {</span><span class="s2">\n  </span><span class="s1">var dep = new Dep();</span><span class="s2">\n  </span><span class="s1">var _a = factory(function () {</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">dep.depend({</span><span class="s2">\n          </span><span class="s1">target: ref,</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.GET */,</span><span class="s2">\n          </span><span class="s1">key: 'value'</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">dep.depend();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}, function () {</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">dep.notify({</span><span class="s2">\n          </span><span class="s1">target: ref,</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.SET */,</span><span class="s2">\n          </span><span class="s1">key: 'value'</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">dep.notify();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}),</span><span class="s2">\n    </span><span class="s1">get = _a.get,</span><span class="s2">\n    </span><span class="s1">set = _a.set;</span><span class="s2">\n  </span><span class="s1">var ref = {</span><span class="s2">\n    </span><span class="s1">get value() {</span><span class="s2">\n      </span><span class="s1">return get();</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">set value(newVal) {</span><span class="s2">\n      </span><span class="s1">set(newVal);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">def(ref, RefFlag, true);</span><span class="s2">\n  </span><span class="s1">return ref;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function toRefs(object) {</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !isReactive(object)) {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">toRefs() expects a reactive object but received a plain one.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var ret = isArray(object) ? new Array(object.length) : {};</span><span class="s2">\n  </span><span class="s1">for (var key in object) {</span><span class="s2">\n    </span><span class="s1">ret[key] = toRef(object, key);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return ret;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function toRef(object, key, defaultValue) {</span><span class="s2">\n  </span><span class="s1">var val = object[key];</span><span class="s2">\n  </span><span class="s1">if (isRef(val)) {</span><span class="s2">\n    </span><span class="s1">return val;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var ref = {</span><span class="s2">\n    </span><span class="s1">get value() {</span><span class="s2">\n      </span><span class="s1">var val = object[key];</span><span class="s2">\n      </span><span class="s1">return val === undefined ? defaultValue : val;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">set value(newVal) {</span><span class="s2">\n      </span><span class="s1">object[key] = newVal;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">def(ref, RefFlag, true);</span><span class="s2">\n  </span><span class="s1">return ref;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var rawToReadonlyFlag = </span><span class="s2">\&quot;</span><span class="s1">__v_rawToReadonly</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var rawToShallowReadonlyFlag = </span><span class="s2">\&quot;</span><span class="s1">__v_rawToShallowReadonly</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function readonly(target) {</span><span class="s2">\n  </span><span class="s1">return createReadonly(target, false);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createReadonly(target, shallow) {</span><span class="s2">\n  </span><span class="s1">if (!isPlainObject(target)) {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">if (isArray(target)) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Vue 2 does not support readonly arrays.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else if (isCollectionType(target)) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Vue 2 does not support readonly collection types such as Map or Set.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">value cannot be made readonly: </span><span class="s2">\&quot;</span><span class="s1">.concat(typeof target));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return target;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !Object.isExtensible(target)) {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Vue 2 does not support creating readonly proxy for non-extensible object.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// already a readonly object</span><span class="s2">\n  </span><span class="s1">if (isReadonly(target)) {</span><span class="s2">\n    </span><span class="s1">return target;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// already has a readonly proxy</span><span class="s2">\n  </span><span class="s1">var existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;</span><span class="s2">\n  </span><span class="s1">var existingProxy = target[existingFlag];</span><span class="s2">\n  </span><span class="s1">if (existingProxy) {</span><span class="s2">\n    </span><span class="s1">return existingProxy;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var proxy = Object.create(Object.getPrototypeOf(target));</span><span class="s2">\n  </span><span class="s1">def(target, existingFlag, proxy);</span><span class="s2">\n  </span><span class="s1">def(proxy, </span><span class="s2">\&quot;</span><span class="s1">__v_isReadonly</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_READONLY */, true);</span><span class="s2">\n  </span><span class="s1">def(proxy, </span><span class="s2">\&quot;</span><span class="s1">__v_raw</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.RAW */, target);</span><span class="s2">\n  </span><span class="s1">if (isRef(target)) {</span><span class="s2">\n    </span><span class="s1">def(proxy, RefFlag, true);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (shallow || isShallow(target)) {</span><span class="s2">\n    </span><span class="s1">def(proxy, </span><span class="s2">\&quot;</span><span class="s1">__v_isShallow</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_SHALLOW */, true);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var keys = Object.keys(target);</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; keys.length; i++) {</span><span class="s2">\n    </span><span class="s1">defineReadonlyProperty(proxy, target, keys[i], shallow);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return proxy;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function defineReadonlyProperty(proxy, target, key, shallow) {</span><span class="s2">\n  </span><span class="s1">Object.defineProperty(proxy, key, {</span><span class="s2">\n    </span><span class="s1">enumerable: true,</span><span class="s2">\n    </span><span class="s1">configurable: true,</span><span class="s2">\n    </span><span class="s1">get: function () {</span><span class="s2">\n      </span><span class="s1">var val = target[key];</span><span class="s2">\n      </span><span class="s1">return shallow || !isPlainObject(val) ? val : readonly(val);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">set: function () {</span><span class="s2">\n      </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">Set operation on key </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">failed: target is readonly.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Returns a reactive-copy of the original object, where only the root level</span><span class="s2">\n </span><span class="s1">* properties are readonly, and does NOT unwrap refs nor recursively convert</span><span class="s2">\n </span><span class="s1">* returned properties.</span><span class="s2">\n </span><span class="s1">* This is used for creating the props proxy object for stateful components.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function shallowReadonly(target) {</span><span class="s2">\n  </span><span class="s1">return createReadonly(target, true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function computed(getterOrOptions, debugOptions) {</span><span class="s2">\n  </span><span class="s1">var getter;</span><span class="s2">\n  </span><span class="s1">var setter;</span><span class="s2">\n  </span><span class="s1">var onlyGetter = isFunction(getterOrOptions);</span><span class="s2">\n  </span><span class="s1">if (onlyGetter) {</span><span class="s2">\n    </span><span class="s1">getter = getterOrOptions;</span><span class="s2">\n    </span><span class="s1">setter = process.env.NODE_ENV !== 'production' ? function () {</span><span class="s2">\n      </span><span class="s1">warn('Write operation failed: computed value is readonly');</span><span class="s2">\n    </span><span class="s1">} : noop;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">getter = getterOrOptions.get;</span><span class="s2">\n    </span><span class="s1">setter = getterOrOptions.set;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var watcher = isServerRendering() ? null : new Watcher(currentInstance, getter, noop, {</span><span class="s2">\n    </span><span class="s1">lazy: true</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; watcher &amp;&amp; debugOptions) {</span><span class="s2">\n    </span><span class="s1">watcher.onTrack = debugOptions.onTrack;</span><span class="s2">\n    </span><span class="s1">watcher.onTrigger = debugOptions.onTrigger;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var ref = {</span><span class="s2">\n    </span><span class="s1">// some libs rely on the presence effect for checking computed refs</span><span class="s2">\n    </span><span class="s1">// from normal refs, but the implementation doesn't matter</span><span class="s2">\n    </span><span class="s1">effect: watcher,</span><span class="s2">\n    </span><span class="s1">get value() {</span><span class="s2">\n      </span><span class="s1">if (watcher) {</span><span class="s2">\n        </span><span class="s1">if (watcher.dirty) {</span><span class="s2">\n          </span><span class="s1">watcher.evaluate();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (Dep.target) {</span><span class="s2">\n          </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; Dep.target.onTrack) {</span><span class="s2">\n            </span><span class="s1">Dep.target.onTrack({</span><span class="s2">\n              </span><span class="s1">effect: Dep.target,</span><span class="s2">\n              </span><span class="s1">target: ref,</span><span class="s2">\n              </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.GET */,</span><span class="s2">\n              </span><span class="s1">key: 'value'</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">watcher.depend();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return watcher.value;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return getter();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">set value(newVal) {</span><span class="s2">\n      </span><span class="s1">setter(newVal);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">def(ref, RefFlag, true);</span><span class="s2">\n  </span><span class="s1">def(ref, </span><span class="s2">\&quot;</span><span class="s1">__v_isReadonly</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_READONLY */, onlyGetter);</span><span class="s2">\n  </span><span class="s1">return ref;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var WATCHER = </span><span class="s2">\&quot;</span><span class="s1">watcher</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var WATCHER_CB = </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(WATCHER, </span><span class="s2">\&quot; </span><span class="s1">callback</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">var WATCHER_GETTER = </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(WATCHER, </span><span class="s2">\&quot; </span><span class="s1">getter</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">var WATCHER_CLEANUP = </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(WATCHER, </span><span class="s2">\&quot; </span><span class="s1">cleanup</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">// Simple effect.</span><span class="s2">\n</span><span class="s1">function watchEffect(effect, options) {</span><span class="s2">\n  </span><span class="s1">return doWatch(effect, null, options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function watchPostEffect(effect, options) {</span><span class="s2">\n  </span><span class="s1">return doWatch(effect, null, process.env.NODE_ENV !== 'production' ? __assign(__assign({}, options), {</span><span class="s2">\n    </span><span class="s1">flush: 'post'</span><span class="s2">\n  </span><span class="s1">}) : {</span><span class="s2">\n    </span><span class="s1">flush: 'post'</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function watchSyncEffect(effect, options) {</span><span class="s2">\n  </span><span class="s1">return doWatch(effect, null, process.env.NODE_ENV !== 'production' ? __assign(__assign({}, options), {</span><span class="s2">\n    </span><span class="s1">flush: 'sync'</span><span class="s2">\n  </span><span class="s1">}) : {</span><span class="s2">\n    </span><span class="s1">flush: 'sync'</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// initial value for watchers to trigger on undefined initial values</span><span class="s2">\n</span><span class="s1">var INITIAL_WATCHER_VALUE = {};</span><span class="s2">\n</span><span class="s1">// implementation</span><span class="s2">\n</span><span class="s1">function watch(source, cb, options) {</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; typeof cb !== 'function') {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">`watch(fn, options?)` signature has been moved to a separate API. </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">Use `watchEffect(fn, options?)` instead. `watch` now only </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">supports `watch(source, cb, options?) signature.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return doWatch(source, cb, options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function doWatch(source, cb, _a) {</span><span class="s2">\n  </span><span class="s1">var _b = _a === void 0 ? emptyObject : _a,</span><span class="s2">\n    </span><span class="s1">immediate = _b.immediate,</span><span class="s2">\n    </span><span class="s1">deep = _b.deep,</span><span class="s2">\n    </span><span class="s1">_c = _b.flush,</span><span class="s2">\n    </span><span class="s1">flush = _c === void 0 ? 'pre' : _c,</span><span class="s2">\n    </span><span class="s1">onTrack = _b.onTrack,</span><span class="s2">\n    </span><span class="s1">onTrigger = _b.onTrigger;</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !cb) {</span><span class="s2">\n    </span><span class="s1">if (immediate !== undefined) {</span><span class="s2">\n      </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">watch() </span><span class="s2">\\\&quot;</span><span class="s1">immediate</span><span class="s2">\\\&quot; </span><span class="s1">option is only respected when using the </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">watch(source, callback, options?) signature.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (deep !== undefined) {</span><span class="s2">\n      </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">watch() </span><span class="s2">\\\&quot;</span><span class="s1">deep</span><span class="s2">\\\&quot; </span><span class="s1">option is only respected when using the </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">watch(source, callback, options?) signature.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var warnInvalidSource = function (s) {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Invalid watch source: </span><span class="s2">\&quot;</span><span class="s1">.concat(s, </span><span class="s2">\&quot;</span><span class="s1">. A watch source can only be a getter/effect </span><span class="s2">\&quot;</span><span class="s1">) + </span><span class="s2">\&quot;</span><span class="s1">function, a ref, a reactive object, or an array of these types.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">var instance = currentInstance;</span><span class="s2">\n  </span><span class="s1">var call = function (fn, type, args) {</span><span class="s2">\n    </span><span class="s1">if (args === void 0) {</span><span class="s2">\n      </span><span class="s1">args = null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return invokeWithErrorHandling(fn, null, args, instance, type);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">var getter;</span><span class="s2">\n  </span><span class="s1">var forceTrigger = false;</span><span class="s2">\n  </span><span class="s1">var isMultiSource = false;</span><span class="s2">\n  </span><span class="s1">if (isRef(source)) {</span><span class="s2">\n    </span><span class="s1">getter = function () {</span><span class="s2">\n      </span><span class="s1">return source.value;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">forceTrigger = isShallow(source);</span><span class="s2">\n  </span><span class="s1">} else if (isReactive(source)) {</span><span class="s2">\n    </span><span class="s1">getter = function () {</span><span class="s2">\n      </span><span class="s1">source.__ob__.dep.depend();</span><span class="s2">\n      </span><span class="s1">return source;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">deep = true;</span><span class="s2">\n  </span><span class="s1">} else if (isArray(source)) {</span><span class="s2">\n    </span><span class="s1">isMultiSource = true;</span><span class="s2">\n    </span><span class="s1">forceTrigger = source.some(function (s) {</span><span class="s2">\n      </span><span class="s1">return isReactive(s) || isShallow(s);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">getter = function () {</span><span class="s2">\n      </span><span class="s1">return source.map(function (s) {</span><span class="s2">\n        </span><span class="s1">if (isRef(s)) {</span><span class="s2">\n          </span><span class="s1">return s.value;</span><span class="s2">\n        </span><span class="s1">} else if (isReactive(s)) {</span><span class="s2">\n          </span><span class="s1">return traverse(s);</span><span class="s2">\n        </span><span class="s1">} else if (isFunction(s)) {</span><span class="s2">\n          </span><span class="s1">return call(s, WATCHER_GETTER);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warnInvalidSource(s);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">} else if (isFunction(source)) {</span><span class="s2">\n    </span><span class="s1">if (cb) {</span><span class="s2">\n      </span><span class="s1">// getter with cb</span><span class="s2">\n      </span><span class="s1">getter = function () {</span><span class="s2">\n        </span><span class="s1">return call(source, WATCHER_GETTER);</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">// no cb -&gt; simple effect</span><span class="s2">\n      </span><span class="s1">getter = function () {</span><span class="s2">\n        </span><span class="s1">if (instance &amp;&amp; instance._isDestroyed) {</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (cleanup) {</span><span class="s2">\n          </span><span class="s1">cleanup();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return call(source, WATCHER, [onCleanup]);</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">getter = noop;</span><span class="s2">\n    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warnInvalidSource(source);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (cb &amp;&amp; deep) {</span><span class="s2">\n    </span><span class="s1">var baseGetter_1 = getter;</span><span class="s2">\n    </span><span class="s1">getter = function () {</span><span class="s2">\n      </span><span class="s1">return traverse(baseGetter_1());</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var cleanup;</span><span class="s2">\n  </span><span class="s1">var onCleanup = function (fn) {</span><span class="s2">\n    </span><span class="s1">cleanup = watcher.onStop = function () {</span><span class="s2">\n      </span><span class="s1">call(fn, WATCHER_CLEANUP);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">// in SSR there is no need to setup an actual effect, and it should be noop</span><span class="s2">\n  </span><span class="s1">// unless it's eager</span><span class="s2">\n  </span><span class="s1">if (isServerRendering()) {</span><span class="s2">\n    </span><span class="s1">// we will also not call the invalidate callback (+ runner is not set up)</span><span class="s2">\n    </span><span class="s1">onCleanup = noop;</span><span class="s2">\n    </span><span class="s1">if (!cb) {</span><span class="s2">\n      </span><span class="s1">getter();</span><span class="s2">\n    </span><span class="s1">} else if (immediate) {</span><span class="s2">\n      </span><span class="s1">call(cb, WATCHER_CB, [getter(), isMultiSource ? [] : undefined, onCleanup]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return noop;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var watcher = new Watcher(currentInstance, getter, noop, {</span><span class="s2">\n    </span><span class="s1">lazy: true</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">watcher.noRecurse = !cb;</span><span class="s2">\n  </span><span class="s1">var oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;</span><span class="s2">\n  </span><span class="s1">// overwrite default run</span><span class="s2">\n  </span><span class="s1">watcher.run = function () {</span><span class="s2">\n    </span><span class="s1">if (!watcher.active) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (cb) {</span><span class="s2">\n      </span><span class="s1">// watch(source, cb)</span><span class="s2">\n      </span><span class="s1">var newValue = watcher.get();</span><span class="s2">\n      </span><span class="s1">if (deep || forceTrigger || (isMultiSource ? newValue.some(function (v, i) {</span><span class="s2">\n        </span><span class="s1">return hasChanged(v, oldValue[i]);</span><span class="s2">\n      </span><span class="s1">}) : hasChanged(newValue, oldValue))) {</span><span class="s2">\n        </span><span class="s1">// cleanup before running cb again</span><span class="s2">\n        </span><span class="s1">if (cleanup) {</span><span class="s2">\n          </span><span class="s1">cleanup();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">call(cb, WATCHER_CB, [newValue,</span><span class="s2">\n        </span><span class="s1">// pass undefined as the old value when it's changed for the first time</span><span class="s2">\n        </span><span class="s1">oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue, onCleanup]);</span><span class="s2">\n        </span><span class="s1">oldValue = newValue;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">// watchEffect</span><span class="s2">\n      </span><span class="s1">watcher.get();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (flush === 'sync') {</span><span class="s2">\n    </span><span class="s1">watcher.update = watcher.run;</span><span class="s2">\n  </span><span class="s1">} else if (flush === 'post') {</span><span class="s2">\n    </span><span class="s1">watcher.post = true;</span><span class="s2">\n    </span><span class="s1">watcher.update = function () {</span><span class="s2">\n      </span><span class="s1">return queueWatcher(watcher);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">// pre</span><span class="s2">\n    </span><span class="s1">watcher.update = function () {</span><span class="s2">\n      </span><span class="s1">if (instance &amp;&amp; instance === currentInstance &amp;&amp; !instance._isMounted) {</span><span class="s2">\n        </span><span class="s1">// pre-watcher triggered before</span><span class="s2">\n        </span><span class="s1">var buffer = instance._preWatchers || (instance._preWatchers = []);</span><span class="s2">\n        </span><span class="s1">if (buffer.indexOf(watcher) &lt; 0) buffer.push(watcher);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">queueWatcher(watcher);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">watcher.onTrack = onTrack;</span><span class="s2">\n    </span><span class="s1">watcher.onTrigger = onTrigger;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// initial run</span><span class="s2">\n  </span><span class="s1">if (cb) {</span><span class="s2">\n    </span><span class="s1">if (immediate) {</span><span class="s2">\n      </span><span class="s1">watcher.run();</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">oldValue = watcher.get();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (flush === 'post' &amp;&amp; instance) {</span><span class="s2">\n    </span><span class="s1">instance.$once('hook:mounted', function () {</span><span class="s2">\n      </span><span class="s1">return watcher.get();</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">watcher.get();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return function () {</span><span class="s2">\n    </span><span class="s1">watcher.teardown();</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var activeEffectScope;</span><span class="s2">\n</span><span class="s1">var EffectScope = /** @class */function () {</span><span class="s2">\n  </span><span class="s1">function EffectScope(detached) {</span><span class="s2">\n    </span><span class="s1">if (detached === void 0) {</span><span class="s2">\n      </span><span class="s1">detached = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.detached = detached;</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* @internal</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">this.active = true;</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* @internal</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">this.effects = [];</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* @internal</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">this.cleanups = [];</span><span class="s2">\n    </span><span class="s1">this.parent = activeEffectScope;</span><span class="s2">\n    </span><span class="s1">if (!detached &amp;&amp; activeEffectScope) {</span><span class="s2">\n      </span><span class="s1">this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">EffectScope.prototype.run = function (fn) {</span><span class="s2">\n    </span><span class="s1">if (this.active) {</span><span class="s2">\n      </span><span class="s1">var currentEffectScope = activeEffectScope;</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">activeEffectScope = this;</span><span class="s2">\n        </span><span class="s1">return fn();</span><span class="s2">\n      </span><span class="s1">} finally {</span><span class="s2">\n        </span><span class="s1">activeEffectScope = currentEffectScope;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">cannot run an inactive effect scope.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* This should only be called on non-detached scopes</span><span class="s2">\n   </span><span class="s1">* @internal</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">EffectScope.prototype.on = function () {</span><span class="s2">\n    </span><span class="s1">activeEffectScope = this;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* This should only be called on non-detached scopes</span><span class="s2">\n   </span><span class="s1">* @internal</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">EffectScope.prototype.off = function () {</span><span class="s2">\n    </span><span class="s1">activeEffectScope = this.parent;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">EffectScope.prototype.stop = function (fromParent) {</span><span class="s2">\n    </span><span class="s1">if (this.active) {</span><span class="s2">\n      </span><span class="s1">var i = void 0,</span><span class="s2">\n        </span><span class="s1">l = void 0;</span><span class="s2">\n      </span><span class="s1">for (i = 0, l = this.effects.length; i &lt; l; i++) {</span><span class="s2">\n        </span><span class="s1">this.effects[i].teardown();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">for (i = 0, l = this.cleanups.length; i &lt; l; i++) {</span><span class="s2">\n        </span><span class="s1">this.cleanups[i]();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (this.scopes) {</span><span class="s2">\n        </span><span class="s1">for (i = 0, l = this.scopes.length; i &lt; l; i++) {</span><span class="s2">\n          </span><span class="s1">this.scopes[i].stop(true);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">// nested scope, dereference from parent to avoid memory leaks</span><span class="s2">\n      </span><span class="s1">if (!this.detached &amp;&amp; this.parent &amp;&amp; !fromParent) {</span><span class="s2">\n        </span><span class="s1">// optimized O(1) removal</span><span class="s2">\n        </span><span class="s1">var last = this.parent.scopes.pop();</span><span class="s2">\n        </span><span class="s1">if (last &amp;&amp; last !== this) {</span><span class="s2">\n          </span><span class="s1">this.parent.scopes[this.index] = last;</span><span class="s2">\n          </span><span class="s1">last.index = this.index;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.parent = undefined;</span><span class="s2">\n      </span><span class="s1">this.active = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return EffectScope;</span><span class="s2">\n</span><span class="s1">}();</span><span class="s2">\n</span><span class="s1">function effectScope(detached) {</span><span class="s2">\n  </span><span class="s1">return new EffectScope(detached);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function recordEffectScope(effect, scope) {</span><span class="s2">\n  </span><span class="s1">if (scope === void 0) {</span><span class="s2">\n    </span><span class="s1">scope = activeEffectScope;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (scope &amp;&amp; scope.active) {</span><span class="s2">\n    </span><span class="s1">scope.effects.push(effect);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getCurrentScope() {</span><span class="s2">\n  </span><span class="s1">return activeEffectScope;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function onScopeDispose(fn) {</span><span class="s2">\n  </span><span class="s1">if (activeEffectScope) {</span><span class="s2">\n    </span><span class="s1">activeEffectScope.cleanups.push(fn);</span><span class="s2">\n  </span><span class="s1">} else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">onScopeDispose() is called when there is no active effect scope</span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot; </span><span class="s1">to be associated with.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function provide(key, value) {</span><span class="s2">\n  </span><span class="s1">if (!currentInstance) {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">provide() can only be used inside setup().</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">// TS doesn't allow symbol as index type</span><span class="s2">\n    </span><span class="s1">resolveProvided(currentInstance)[key] = value;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveProvided(vm) {</span><span class="s2">\n  </span><span class="s1">// by default an instance inherits its parent's provides object</span><span class="s2">\n  </span><span class="s1">// but when it needs to provide values of its own, it creates its</span><span class="s2">\n  </span><span class="s1">// own provides object using parent provides object as prototype.</span><span class="s2">\n  </span><span class="s1">// this way in `inject` we can simply look up injections from direct</span><span class="s2">\n  </span><span class="s1">// parent and let the prototype chain do the work.</span><span class="s2">\n  </span><span class="s1">var existing = vm._provided;</span><span class="s2">\n  </span><span class="s1">var parentProvides = vm.$parent &amp;&amp; vm.$parent._provided;</span><span class="s2">\n  </span><span class="s1">if (parentProvides === existing) {</span><span class="s2">\n    </span><span class="s1">return vm._provided = Object.create(parentProvides);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return existing;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function inject(key, defaultValue, treatDefaultAsFactory) {</span><span class="s2">\n  </span><span class="s1">if (treatDefaultAsFactory === void 0) {</span><span class="s2">\n    </span><span class="s1">treatDefaultAsFactory = false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// fallback to `currentRenderingInstance` so that this can be called in</span><span class="s2">\n  </span><span class="s1">// a functional component</span><span class="s2">\n  </span><span class="s1">var instance = currentInstance;</span><span class="s2">\n  </span><span class="s1">if (instance) {</span><span class="s2">\n    </span><span class="s1">// #2400</span><span class="s2">\n    </span><span class="s1">// to support `app.use` plugins,</span><span class="s2">\n    </span><span class="s1">// fallback to appContext's `provides` if the instance is at root</span><span class="s2">\n    </span><span class="s1">var provides = instance.$parent &amp;&amp; instance.$parent._provided;</span><span class="s2">\n    </span><span class="s1">if (provides &amp;&amp; key in provides) {</span><span class="s2">\n      </span><span class="s1">// TS doesn't allow symbol as index type</span><span class="s2">\n      </span><span class="s1">return provides[key];</span><span class="s2">\n    </span><span class="s1">} else if (arguments.length &gt; 1) {</span><span class="s2">\n      </span><span class="s1">return treatDefaultAsFactory &amp;&amp; isFunction(defaultValue) ? defaultValue.call(instance) : defaultValue;</span><span class="s2">\n    </span><span class="s1">} else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">injection </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(String(key), </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">not found.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">inject() can only be used inside setup() or functional components.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var normalizeEvent = cached(function (name) {</span><span class="s2">\n  </span><span class="s1">var passive = name.charAt(0) === '&amp;';</span><span class="s2">\n  </span><span class="s1">name = passive ? name.slice(1) : name;</span><span class="s2">\n  </span><span class="s1">var once = name.charAt(0) === '~'; // Prefixed last, checked first</span><span class="s2">\n  </span><span class="s1">name = once ? name.slice(1) : name;</span><span class="s2">\n  </span><span class="s1">var capture = name.charAt(0) === '!';</span><span class="s2">\n  </span><span class="s1">name = capture ? name.slice(1) : name;</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">name: name,</span><span class="s2">\n    </span><span class="s1">once: once,</span><span class="s2">\n    </span><span class="s1">capture: capture,</span><span class="s2">\n    </span><span class="s1">passive: passive</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">function createFnInvoker(fns, vm) {</span><span class="s2">\n  </span><span class="s1">function invoker() {</span><span class="s2">\n    </span><span class="s1">var fns = invoker.fns;</span><span class="s2">\n    </span><span class="s1">if (isArray(fns)) {</span><span class="s2">\n      </span><span class="s1">var cloned = fns.slice();</span><span class="s2">\n      </span><span class="s1">for (var i = 0; i &lt; cloned.length; i++) {</span><span class="s2">\n        </span><span class="s1">invokeWithErrorHandling(cloned[i], null, arguments, vm, </span><span class="s2">\&quot;</span><span class="s1">v-on handler</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">// return handler return value for single handlers</span><span class="s2">\n      </span><span class="s1">return invokeWithErrorHandling(fns, null, arguments, vm, </span><span class="s2">\&quot;</span><span class="s1">v-on handler</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">invoker.fns = fns;</span><span class="s2">\n  </span><span class="s1">return invoker;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {</span><span class="s2">\n  </span><span class="s1">var name, cur, old, event;</span><span class="s2">\n  </span><span class="s1">for (name in on) {</span><span class="s2">\n    </span><span class="s1">cur = on[name];</span><span class="s2">\n    </span><span class="s1">old = oldOn[name];</span><span class="s2">\n    </span><span class="s1">event = normalizeEvent(name);</span><span class="s2">\n    </span><span class="s1">if (isUndef(cur)) {</span><span class="s2">\n      </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">Invalid handler for event </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(event.name, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">: got </span><span class="s2">\&quot;</span><span class="s1">) + String(cur), vm);</span><span class="s2">\n    </span><span class="s1">} else if (isUndef(old)) {</span><span class="s2">\n      </span><span class="s1">if (isUndef(cur.fns)) {</span><span class="s2">\n        </span><span class="s1">cur = on[name] = createFnInvoker(cur, vm);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (isTrue(event.once)) {</span><span class="s2">\n        </span><span class="s1">cur = on[name] = createOnceHandler(event.name, cur, event.capture);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">add(event.name, cur, event.capture, event.passive, event.params);</span><span class="s2">\n    </span><span class="s1">} else if (cur !== old) {</span><span class="s2">\n      </span><span class="s1">old.fns = cur;</span><span class="s2">\n      </span><span class="s1">on[name] = old;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">for (name in oldOn) {</span><span class="s2">\n    </span><span class="s1">if (isUndef(on[name])) {</span><span class="s2">\n      </span><span class="s1">event = normalizeEvent(name);</span><span class="s2">\n      </span><span class="s1">remove(event.name, oldOn[name], event.capture);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mergeVNodeHook(def, hookKey, hook) {</span><span class="s2">\n  </span><span class="s1">if (def instanceof VNode) {</span><span class="s2">\n    </span><span class="s1">def = def.data.hook || (def.data.hook = {});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var invoker;</span><span class="s2">\n  </span><span class="s1">var oldHook = def[hookKey];</span><span class="s2">\n  </span><span class="s1">function wrappedHook() {</span><span class="s2">\n    </span><span class="s1">hook.apply(this, arguments);</span><span class="s2">\n    </span><span class="s1">// important: remove merged hook to ensure it's called only once</span><span class="s2">\n    </span><span class="s1">// and prevent memory leak</span><span class="s2">\n    </span><span class="s1">remove$2(invoker.fns, wrappedHook);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isUndef(oldHook)) {</span><span class="s2">\n    </span><span class="s1">// no existing hook</span><span class="s2">\n    </span><span class="s1">invoker = createFnInvoker([wrappedHook]);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (isDef(oldHook.fns) &amp;&amp; isTrue(oldHook.merged)) {</span><span class="s2">\n      </span><span class="s1">// already a merged invoker</span><span class="s2">\n      </span><span class="s1">invoker = oldHook;</span><span class="s2">\n      </span><span class="s1">invoker.fns.push(wrappedHook);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">// existing plain hook</span><span class="s2">\n      </span><span class="s1">invoker = createFnInvoker([oldHook, wrappedHook]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">invoker.merged = true;</span><span class="s2">\n  </span><span class="s1">def[hookKey] = invoker;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function extractPropsFromVNodeData(data, Ctor, tag) {</span><span class="s2">\n  </span><span class="s1">// we are only extracting raw values here.</span><span class="s2">\n  </span><span class="s1">// validation and default values are handled in the child</span><span class="s2">\n  </span><span class="s1">// component itself.</span><span class="s2">\n  </span><span class="s1">var propOptions = Ctor.options.props;</span><span class="s2">\n  </span><span class="s1">if (isUndef(propOptions)) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var res = {};</span><span class="s2">\n  </span><span class="s1">var attrs = data.attrs,</span><span class="s2">\n    </span><span class="s1">props = data.props;</span><span class="s2">\n  </span><span class="s1">if (isDef(attrs) || isDef(props)) {</span><span class="s2">\n    </span><span class="s1">for (var key in propOptions) {</span><span class="s2">\n      </span><span class="s1">var altKey = hyphenate(key);</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">var keyInLowerCase = key.toLowerCase();</span><span class="s2">\n        </span><span class="s1">if (key !== keyInLowerCase &amp;&amp; attrs &amp;&amp; hasOwn(attrs, keyInLowerCase)) {</span><span class="s2">\n          </span><span class="s1">tip(</span><span class="s2">\&quot;</span><span class="s1">Prop </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(keyInLowerCase, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is passed to component </span><span class="s2">\&quot;</span><span class="s1">) + </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(formatComponentName(</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error tag is string</span><span class="s2">\n          </span><span class="s1">tag || Ctor), </span><span class="s2">\&quot;</span><span class="s1">, but the declared prop name is</span><span class="s2">\&quot;</span><span class="s1">) + </span><span class="s2">\&quot; \\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">. </span><span class="s2">\&quot;</span><span class="s1">) + </span><span class="s2">\&quot;</span><span class="s1">Note that HTML attributes are case-insensitive and camelCased </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">props need to use their kebab-case equivalents when using in-DOM </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">templates. You should probably use </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(altKey, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">instead of </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">).concat(key, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function checkProp(res, hash, key, altKey, preserve) {</span><span class="s2">\n  </span><span class="s1">if (isDef(hash)) {</span><span class="s2">\n    </span><span class="s1">if (hasOwn(hash, key)) {</span><span class="s2">\n      </span><span class="s1">res[key] = hash[key];</span><span class="s2">\n      </span><span class="s1">if (!preserve) {</span><span class="s2">\n        </span><span class="s1">delete hash[key];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">} else if (hasOwn(hash, altKey)) {</span><span class="s2">\n      </span><span class="s1">res[key] = hash[altKey];</span><span class="s2">\n      </span><span class="s1">if (!preserve) {</span><span class="s2">\n        </span><span class="s1">delete hash[altKey];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// The template compiler attempts to minimize the need for normalization by</span><span class="s2">\n</span><span class="s1">// statically analyzing the template at compile time.</span><span class="s2">\n</span><span class="s1">//</span><span class="s2">\n</span><span class="s1">// For plain HTML markup, normalization can be completely skipped because the</span><span class="s2">\n</span><span class="s1">// generated render function is guaranteed to return Array&lt;VNode&gt;. There are</span><span class="s2">\n</span><span class="s1">// two cases where extra normalization is needed:</span><span class="s2">\n</span><span class="s1">// 1. When the children contains components - because a functional component</span><span class="s2">\n</span><span class="s1">// may return an Array instead of a single root. In this case, just a simple</span><span class="s2">\n</span><span class="s1">// normalization is needed - if any child is an Array, we flatten the whole</span><span class="s2">\n</span><span class="s1">// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep</span><span class="s2">\n</span><span class="s1">// because functional components already normalize their own children.</span><span class="s2">\n</span><span class="s1">function simpleNormalizeChildren(children) {</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; children.length; i++) {</span><span class="s2">\n    </span><span class="s1">if (isArray(children[i])) {</span><span class="s2">\n      </span><span class="s1">return Array.prototype.concat.apply([], children);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return children;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// 2. When the children contains constructs that always generated nested Arrays,</span><span class="s2">\n</span><span class="s1">// e.g. &lt;template&gt;, &lt;slot&gt;, v-for, or when the children is provided by user</span><span class="s2">\n</span><span class="s1">// with hand-written render functions / JSX. In such cases a full normalization</span><span class="s2">\n</span><span class="s1">// is needed to cater to all possible types of children values.</span><span class="s2">\n</span><span class="s1">function normalizeChildren(children) {</span><span class="s2">\n  </span><span class="s1">return isPrimitive(children) ? [createTextVNode(children)] : isArray(children) ? normalizeArrayChildren(children) : undefined;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isTextNode(node) {</span><span class="s2">\n  </span><span class="s1">return isDef(node) &amp;&amp; isDef(node.text) &amp;&amp; isFalse(node.isComment);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeArrayChildren(children, nestedIndex) {</span><span class="s2">\n  </span><span class="s1">var res = [];</span><span class="s2">\n  </span><span class="s1">var i, c, lastIndex, last;</span><span class="s2">\n  </span><span class="s1">for (i = 0; i &lt; children.length; i++) {</span><span class="s2">\n    </span><span class="s1">c = children[i];</span><span class="s2">\n    </span><span class="s1">if (isUndef(c) || typeof c === 'boolean') continue;</span><span class="s2">\n    </span><span class="s1">lastIndex = res.length - 1;</span><span class="s2">\n    </span><span class="s1">last = res[lastIndex];</span><span class="s2">\n    </span><span class="s1">//  nested</span><span class="s2">\n    </span><span class="s1">if (isArray(c)) {</span><span class="s2">\n      </span><span class="s1">if (c.length &gt; 0) {</span><span class="s2">\n        </span><span class="s1">c = normalizeArrayChildren(c, </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(nestedIndex || '', </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot;</span><span class="s1">).concat(i));</span><span class="s2">\n        </span><span class="s1">// merge adjacent text nodes</span><span class="s2">\n        </span><span class="s1">if (isTextNode(c[0]) &amp;&amp; isTextNode(last)) {</span><span class="s2">\n          </span><span class="s1">res[lastIndex] = createTextVNode(last.text + c[0].text);</span><span class="s2">\n          </span><span class="s1">c.shift();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">res.push.apply(res, c);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (isPrimitive(c)) {</span><span class="s2">\n      </span><span class="s1">if (isTextNode(last)) {</span><span class="s2">\n        </span><span class="s1">// merge adjacent text nodes</span><span class="s2">\n        </span><span class="s1">// this is necessary for SSR hydration because text nodes are</span><span class="s2">\n        </span><span class="s1">// essentially merged when rendered to HTML strings</span><span class="s2">\n        </span><span class="s1">res[lastIndex] = createTextVNode(last.text + c);</span><span class="s2">\n      </span><span class="s1">} else if (c !== '') {</span><span class="s2">\n        </span><span class="s1">// convert primitive to vnode</span><span class="s2">\n        </span><span class="s1">res.push(createTextVNode(c));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">if (isTextNode(c) &amp;&amp; isTextNode(last)) {</span><span class="s2">\n        </span><span class="s1">// merge adjacent text nodes</span><span class="s2">\n        </span><span class="s1">res[lastIndex] = createTextVNode(last.text + c.text);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">// default key for nested array children (likely generated by v-for)</span><span class="s2">\n        </span><span class="s1">if (isTrue(children._isVList) &amp;&amp; isDef(c.tag) &amp;&amp; isUndef(c.key) &amp;&amp; isDef(nestedIndex)) {</span><span class="s2">\n          </span><span class="s1">c.key = </span><span class="s2">\&quot;</span><span class="s1">__vlist</span><span class="s2">\&quot;</span><span class="s1">.concat(nestedIndex, </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot;</span><span class="s1">).concat(i, </span><span class="s2">\&quot;</span><span class="s1">__</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">res.push(c);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for rendering v-for lists.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function renderList(val, render) {</span><span class="s2">\n  </span><span class="s1">var ret = null,</span><span class="s2">\n    </span><span class="s1">i,</span><span class="s2">\n    </span><span class="s1">l,</span><span class="s2">\n    </span><span class="s1">keys,</span><span class="s2">\n    </span><span class="s1">key;</span><span class="s2">\n  </span><span class="s1">if (isArray(val) || typeof val === 'string') {</span><span class="s2">\n    </span><span class="s1">ret = new Array(val.length);</span><span class="s2">\n    </span><span class="s1">for (i = 0, l = val.length; i &lt; l; i++) {</span><span class="s2">\n      </span><span class="s1">ret[i] = render(val[i], i);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (typeof val === 'number') {</span><span class="s2">\n    </span><span class="s1">ret = new Array(val);</span><span class="s2">\n    </span><span class="s1">for (i = 0; i &lt; val; i++) {</span><span class="s2">\n      </span><span class="s1">ret[i] = render(i + 1, i);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (isObject(val)) {</span><span class="s2">\n    </span><span class="s1">if (hasSymbol &amp;&amp; val[Symbol.iterator]) {</span><span class="s2">\n      </span><span class="s1">ret = [];</span><span class="s2">\n      </span><span class="s1">var iterator = val[Symbol.iterator]();</span><span class="s2">\n      </span><span class="s1">var result = iterator.next();</span><span class="s2">\n      </span><span class="s1">while (!result.done) {</span><span class="s2">\n        </span><span class="s1">ret.push(render(result.value, ret.length));</span><span class="s2">\n        </span><span class="s1">result = iterator.next();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">keys = Object.keys(val);</span><span class="s2">\n      </span><span class="s1">ret = new Array(keys.length);</span><span class="s2">\n      </span><span class="s1">for (i = 0, l = keys.length; i &lt; l; i++) {</span><span class="s2">\n        </span><span class="s1">key = keys[i];</span><span class="s2">\n        </span><span class="s1">ret[i] = render(val[key], key, i);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!isDef(ret)) {</span><span class="s2">\n    </span><span class="s1">ret = [];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">ret._isVList = true;</span><span class="s2">\n  </span><span class="s1">return ret;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for rendering &lt;slot&gt;</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function renderSlot(name, fallbackRender, props, bindObject) {</span><span class="s2">\n  </span><span class="s1">var scopedSlotFn = this.$scopedSlots[name];</span><span class="s2">\n  </span><span class="s1">var nodes;</span><span class="s2">\n  </span><span class="s1">if (scopedSlotFn) {</span><span class="s2">\n    </span><span class="s1">// scoped slot</span><span class="s2">\n    </span><span class="s1">props = props || {};</span><span class="s2">\n    </span><span class="s1">if (bindObject) {</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !isObject(bindObject)) {</span><span class="s2">\n        </span><span class="s1">warn('slot v-bind without argument expects an Object', this);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">props = extend(extend({}, bindObject), props);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">nodes = scopedSlotFn(props) || (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">nodes = this.$slots[name] || (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var target = props &amp;&amp; props.slot;</span><span class="s2">\n  </span><span class="s1">if (target) {</span><span class="s2">\n    </span><span class="s1">return this.$createElement('template', {</span><span class="s2">\n      </span><span class="s1">slot: target</span><span class="s2">\n    </span><span class="s1">}, nodes);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return nodes;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for resolving filters</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function resolveFilter(id) {</span><span class="s2">\n  </span><span class="s1">return resolveAsset(this.$options, 'filters', id, true) || identity;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isKeyNotMatch(expect, actual) {</span><span class="s2">\n  </span><span class="s1">if (isArray(expect)) {</span><span class="s2">\n    </span><span class="s1">return expect.indexOf(actual) === -1;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return expect !== actual;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for checking keyCodes from config.</span><span class="s2">\n </span><span class="s1">* exposed as Vue.prototype._k</span><span class="s2">\n </span><span class="s1">* passing in eventKeyName as last argument separately for backwards compat</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {</span><span class="s2">\n  </span><span class="s1">var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;</span><span class="s2">\n  </span><span class="s1">if (builtInKeyName &amp;&amp; eventKeyName &amp;&amp; !config.keyCodes[key]) {</span><span class="s2">\n    </span><span class="s1">return isKeyNotMatch(builtInKeyName, eventKeyName);</span><span class="s2">\n  </span><span class="s1">} else if (mappedKeyCode) {</span><span class="s2">\n    </span><span class="s1">return isKeyNotMatch(mappedKeyCode, eventKeyCode);</span><span class="s2">\n  </span><span class="s1">} else if (eventKeyName) {</span><span class="s2">\n    </span><span class="s1">return hyphenate(eventKeyName) !== key;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return eventKeyCode === undefined;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for merging v-bind=</span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">into a VNode's data.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function bindObjectProps(data, tag, value, asProp, isSync) {</span><span class="s2">\n  </span><span class="s1">if (value) {</span><span class="s2">\n    </span><span class="s1">if (!isObject(value)) {</span><span class="s2">\n      </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn('v-bind without argument expects an Object or Array value', this);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">if (isArray(value)) {</span><span class="s2">\n        </span><span class="s1">value = toObject(value);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">var hash = void 0;</span><span class="s2">\n      </span><span class="s1">var _loop_1 = function (key) {</span><span class="s2">\n        </span><span class="s1">if (key === 'class' || key === 'style' || isReservedAttribute(key)) {</span><span class="s2">\n          </span><span class="s1">hash = data;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">var type = data.attrs &amp;&amp; data.attrs.type;</span><span class="s2">\n          </span><span class="s1">hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var camelizedKey = camelize(key);</span><span class="s2">\n        </span><span class="s1">var hyphenatedKey = hyphenate(key);</span><span class="s2">\n        </span><span class="s1">if (!(camelizedKey in hash) &amp;&amp; !(hyphenatedKey in hash)) {</span><span class="s2">\n          </span><span class="s1">hash[key] = value[key];</span><span class="s2">\n          </span><span class="s1">if (isSync) {</span><span class="s2">\n            </span><span class="s1">var on = data.on || (data.on = {});</span><span class="s2">\n            </span><span class="s1">on[</span><span class="s2">\&quot;</span><span class="s1">update:</span><span class="s2">\&quot;</span><span class="s1">.concat(key)] = function ($event) {</span><span class="s2">\n              </span><span class="s1">value[key] = $event;</span><span class="s2">\n            </span><span class="s1">};</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">for (var key in value) {</span><span class="s2">\n        </span><span class="s1">_loop_1(key);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return data;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for rendering static trees.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function renderStatic(index, isInFor) {</span><span class="s2">\n  </span><span class="s1">var cached = this._staticTrees || (this._staticTrees = []);</span><span class="s2">\n  </span><span class="s1">var tree = cached[index];</span><span class="s2">\n  </span><span class="s1">// if has already-rendered static tree and not inside v-for,</span><span class="s2">\n  </span><span class="s1">// we can reuse the same tree.</span><span class="s2">\n  </span><span class="s1">if (tree &amp;&amp; !isInFor) {</span><span class="s2">\n    </span><span class="s1">return tree;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// otherwise, render a fresh tree.</span><span class="s2">\n  </span><span class="s1">tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, this._c, this // for render fns generated for functional component templates</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n\n  </span><span class="s1">markStatic(tree, </span><span class="s2">\&quot;</span><span class="s1">__static__</span><span class="s2">\&quot;</span><span class="s1">.concat(index), false);</span><span class="s2">\n  </span><span class="s1">return tree;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for v-once.</span><span class="s2">\n </span><span class="s1">* Effectively it means marking the node as static with a unique key.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function markOnce(tree, index, key) {</span><span class="s2">\n  </span><span class="s1">markStatic(tree, </span><span class="s2">\&quot;</span><span class="s1">__once__</span><span class="s2">\&quot;</span><span class="s1">.concat(index).concat(key ? </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot;</span><span class="s1">.concat(key) : </span><span class="s2">\&quot;\&quot;</span><span class="s1">), true);</span><span class="s2">\n  </span><span class="s1">return tree;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function markStatic(tree, key, isOnce) {</span><span class="s2">\n  </span><span class="s1">if (isArray(tree)) {</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; tree.length; i++) {</span><span class="s2">\n      </span><span class="s1">if (tree[i] &amp;&amp; typeof tree[i] !== 'string') {</span><span class="s2">\n        </span><span class="s1">markStaticNode(tree[i], </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot;</span><span class="s1">).concat(i), isOnce);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">markStaticNode(tree, key, isOnce);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function markStaticNode(node, key, isOnce) {</span><span class="s2">\n  </span><span class="s1">node.isStatic = true;</span><span class="s2">\n  </span><span class="s1">node.key = key;</span><span class="s2">\n  </span><span class="s1">node.isOnce = isOnce;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function bindObjectListeners(data, value) {</span><span class="s2">\n  </span><span class="s1">if (value) {</span><span class="s2">\n    </span><span class="s1">if (!isPlainObject(value)) {</span><span class="s2">\n      </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn('v-on without argument expects an Object value', this);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">var on = data.on = data.on ? extend({}, data.on) : {};</span><span class="s2">\n      </span><span class="s1">for (var key in value) {</span><span class="s2">\n        </span><span class="s1">var existing = on[key];</span><span class="s2">\n        </span><span class="s1">var ours = value[key];</span><span class="s2">\n        </span><span class="s1">on[key] = existing ? [].concat(existing, ours) : ours;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return data;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveScopedSlots(fns, res,</span><span class="s2">\n</span><span class="s1">// the following are added in 2.6</span><span class="s2">\n</span><span class="s1">hasDynamicKeys, contentHashKey) {</span><span class="s2">\n  </span><span class="s1">res = res || {</span><span class="s2">\n    </span><span class="s1">$stable: !hasDynamicKeys</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; fns.length; i++) {</span><span class="s2">\n    </span><span class="s1">var slot = fns[i];</span><span class="s2">\n    </span><span class="s1">if (isArray(slot)) {</span><span class="s2">\n      </span><span class="s1">resolveScopedSlots(slot, res, hasDynamicKeys);</span><span class="s2">\n    </span><span class="s1">} else if (slot) {</span><span class="s2">\n      </span><span class="s1">// marker for reverse proxying v-slot without scope on this.$slots</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error</span><span class="s2">\n      </span><span class="s1">if (slot.proxy) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error</span><span class="s2">\n        </span><span class="s1">slot.fn.proxy = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">res[slot.key] = slot.fn;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (contentHashKey) {</span><span class="s2">\n    </span><span class="s1">res.$key = contentHashKey;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// helper to process dynamic keys for dynamic arguments in v-bind and v-on.</span><span class="s2">\n</span><span class="s1">function bindDynamicKeys(baseObj, values) {</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; values.length; i += 2) {</span><span class="s2">\n    </span><span class="s1">var key = values[i];</span><span class="s2">\n    </span><span class="s1">if (typeof key === 'string' &amp;&amp; key) {</span><span class="s2">\n      </span><span class="s1">baseObj[values[i]] = values[i + 1];</span><span class="s2">\n    </span><span class="s1">} else if (process.env.NODE_ENV !== 'production' &amp;&amp; key !== '' &amp;&amp; key !== null) {</span><span class="s2">\n      </span><span class="s1">// null is a special value for explicitly removing a binding</span><span class="s2">\n      </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Invalid value for dynamic directive argument (expected string or null): </span><span class="s2">\&quot;</span><span class="s1">.concat(key), this);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return baseObj;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// helper to dynamically append modifier runtime markers to event names.</span><span class="s2">\n</span><span class="s1">// ensure only append when value is already string, otherwise it will be cast</span><span class="s2">\n</span><span class="s1">// to string and cause the type check to miss.</span><span class="s2">\n</span><span class="s1">function prependModifier(value, symbol) {</span><span class="s2">\n  </span><span class="s1">return typeof value === 'string' ? symbol + value : value;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function installRenderHelpers(target) {</span><span class="s2">\n  </span><span class="s1">target._o = markOnce;</span><span class="s2">\n  </span><span class="s1">target._n = toNumber;</span><span class="s2">\n  </span><span class="s1">target._s = toString;</span><span class="s2">\n  </span><span class="s1">target._l = renderList;</span><span class="s2">\n  </span><span class="s1">target._t = renderSlot;</span><span class="s2">\n  </span><span class="s1">target._q = looseEqual;</span><span class="s2">\n  </span><span class="s1">target._i = looseIndexOf;</span><span class="s2">\n  </span><span class="s1">target._m = renderStatic;</span><span class="s2">\n  </span><span class="s1">target._f = resolveFilter;</span><span class="s2">\n  </span><span class="s1">target._k = checkKeyCodes;</span><span class="s2">\n  </span><span class="s1">target._b = bindObjectProps;</span><span class="s2">\n  </span><span class="s1">target._v = createTextVNode;</span><span class="s2">\n  </span><span class="s1">target._e = createEmptyVNode;</span><span class="s2">\n  </span><span class="s1">target._u = resolveScopedSlots;</span><span class="s2">\n  </span><span class="s1">target._g = bindObjectListeners;</span><span class="s2">\n  </span><span class="s1">target._d = bindDynamicKeys;</span><span class="s2">\n  </span><span class="s1">target._p = prependModifier;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for resolving raw children VNodes into a slot object.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function resolveSlots(children, context) {</span><span class="s2">\n  </span><span class="s1">if (!children || !children.length) {</span><span class="s2">\n    </span><span class="s1">return {};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var slots = {};</span><span class="s2">\n  </span><span class="s1">for (var i = 0, l = children.length; i &lt; l; i++) {</span><span class="s2">\n    </span><span class="s1">var child = children[i];</span><span class="s2">\n    </span><span class="s1">var data = child.data;</span><span class="s2">\n    </span><span class="s1">// remove slot attribute if the node is resolved as a Vue slot node</span><span class="s2">\n    </span><span class="s1">if (data &amp;&amp; data.attrs &amp;&amp; data.attrs.slot) {</span><span class="s2">\n      </span><span class="s1">delete data.attrs.slot;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// named slots should only be respected if the vnode was rendered in the</span><span class="s2">\n    </span><span class="s1">// same context.</span><span class="s2">\n    </span><span class="s1">if ((child.context === context || child.fnContext === context) &amp;&amp; data &amp;&amp; data.slot != null) {</span><span class="s2">\n      </span><span class="s1">var name_1 = data.slot;</span><span class="s2">\n      </span><span class="s1">var slot = slots[name_1] || (slots[name_1] = []);</span><span class="s2">\n      </span><span class="s1">if (child.tag === 'template') {</span><span class="s2">\n        </span><span class="s1">slot.push.apply(slot, child.children || []);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">slot.push(child);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">(slots.default || (slots.default = [])).push(child);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// ignore slots that contains only whitespace</span><span class="s2">\n  </span><span class="s1">for (var name_2 in slots) {</span><span class="s2">\n    </span><span class="s1">if (slots[name_2].every(isWhitespace)) {</span><span class="s2">\n      </span><span class="s1">delete slots[name_2];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return slots;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isWhitespace(node) {</span><span class="s2">\n  </span><span class="s1">return node.isComment &amp;&amp; !node.asyncFactory || node.text === ' ';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isAsyncPlaceholder(node) {</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error not really boolean type</span><span class="s2">\n  </span><span class="s1">return node.isComment &amp;&amp; node.asyncFactory;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {</span><span class="s2">\n  </span><span class="s1">var res;</span><span class="s2">\n  </span><span class="s1">var hasNormalSlots = Object.keys(normalSlots).length &gt; 0;</span><span class="s2">\n  </span><span class="s1">var isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;</span><span class="s2">\n  </span><span class="s1">var key = scopedSlots &amp;&amp; scopedSlots.$key;</span><span class="s2">\n  </span><span class="s1">if (!scopedSlots) {</span><span class="s2">\n    </span><span class="s1">res = {};</span><span class="s2">\n  </span><span class="s1">} else if (scopedSlots._normalized) {</span><span class="s2">\n    </span><span class="s1">// fast path 1: child component re-render only, parent did not change</span><span class="s2">\n    </span><span class="s1">return scopedSlots._normalized;</span><span class="s2">\n  </span><span class="s1">} else if (isStable &amp;&amp; prevScopedSlots &amp;&amp; prevScopedSlots !== emptyObject &amp;&amp; key === prevScopedSlots.$key &amp;&amp; !hasNormalSlots &amp;&amp; !prevScopedSlots.$hasNormal) {</span><span class="s2">\n    </span><span class="s1">// fast path 2: stable scoped slots w/ no normal slots to proxy,</span><span class="s2">\n    </span><span class="s1">// only need to normalize once</span><span class="s2">\n    </span><span class="s1">return prevScopedSlots;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">res = {};</span><span class="s2">\n    </span><span class="s1">for (var key_1 in scopedSlots) {</span><span class="s2">\n      </span><span class="s1">if (scopedSlots[key_1] &amp;&amp; key_1[0] !== '$') {</span><span class="s2">\n        </span><span class="s1">res[key_1] = normalizeScopedSlot(ownerVm, normalSlots, key_1, scopedSlots[key_1]);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// expose normal slots on scopedSlots</span><span class="s2">\n  </span><span class="s1">for (var key_2 in normalSlots) {</span><span class="s2">\n    </span><span class="s1">if (!(key_2 in res)) {</span><span class="s2">\n      </span><span class="s1">res[key_2] = proxyNormalSlot(normalSlots, key_2);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// avoriaz seems to mock a non-extensible $scopedSlots object</span><span class="s2">\n  </span><span class="s1">// and when that is passed down this would cause an error</span><span class="s2">\n  </span><span class="s1">if (scopedSlots &amp;&amp; Object.isExtensible(scopedSlots)) {</span><span class="s2">\n    </span><span class="s1">scopedSlots._normalized = res;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">def(res, '$stable', isStable);</span><span class="s2">\n  </span><span class="s1">def(res, '$key', key);</span><span class="s2">\n  </span><span class="s1">def(res, '$hasNormal', hasNormalSlots);</span><span class="s2">\n  </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeScopedSlot(vm, normalSlots, key, fn) {</span><span class="s2">\n  </span><span class="s1">var normalized = function () {</span><span class="s2">\n    </span><span class="s1">var cur = currentInstance;</span><span class="s2">\n    </span><span class="s1">setCurrentInstance(vm);</span><span class="s2">\n    </span><span class="s1">var res = arguments.length ? fn.apply(null, arguments) : fn({});</span><span class="s2">\n    </span><span class="s1">res = res &amp;&amp; typeof res === 'object' &amp;&amp; !isArray(res) ? [res] // single vnode</span><span class="s2">\n    </span><span class="s1">: normalizeChildren(res);</span><span class="s2">\n    </span><span class="s1">var vnode = res &amp;&amp; res[0];</span><span class="s2">\n    </span><span class="s1">setCurrentInstance(cur);</span><span class="s2">\n    </span><span class="s1">return res &amp;&amp; (!vnode || res.length === 1 &amp;&amp; vnode.isComment &amp;&amp; !isAsyncPlaceholder(vnode)) // #9658, #10391</span><span class="s2">\n    </span><span class="s1">? undefined : res;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">// this is a slot using the new v-slot syntax without scope. although it is</span><span class="s2">\n  </span><span class="s1">// compiled as a scoped slot, render fn users would expect it to be present</span><span class="s2">\n  </span><span class="s1">// on this.$slots because the usage is semantically a normal slot.</span><span class="s2">\n  </span><span class="s1">if (fn.proxy) {</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(normalSlots, key, {</span><span class="s2">\n      </span><span class="s1">get: normalized,</span><span class="s2">\n      </span><span class="s1">enumerable: true,</span><span class="s2">\n      </span><span class="s1">configurable: true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return normalized;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function proxyNormalSlot(slots, key) {</span><span class="s2">\n  </span><span class="s1">return function () {</span><span class="s2">\n    </span><span class="s1">return slots[key];</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initSetup(vm) {</span><span class="s2">\n  </span><span class="s1">var options = vm.$options;</span><span class="s2">\n  </span><span class="s1">var setup = options.setup;</span><span class="s2">\n  </span><span class="s1">if (setup) {</span><span class="s2">\n    </span><span class="s1">var ctx = vm._setupContext = createSetupContext(vm);</span><span class="s2">\n    </span><span class="s1">setCurrentInstance(vm);</span><span class="s2">\n    </span><span class="s1">pushTarget();</span><span class="s2">\n    </span><span class="s1">var setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, </span><span class="s2">\&quot;</span><span class="s1">setup</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">popTarget();</span><span class="s2">\n    </span><span class="s1">setCurrentInstance();</span><span class="s2">\n    </span><span class="s1">if (isFunction(setupResult)) {</span><span class="s2">\n      </span><span class="s1">// render function</span><span class="s2">\n      </span><span class="s1">// @ts-ignore</span><span class="s2">\n      </span><span class="s1">options.render = setupResult;</span><span class="s2">\n    </span><span class="s1">} else if (isObject(setupResult)) {</span><span class="s2">\n      </span><span class="s1">// bindings</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; setupResult instanceof VNode) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">setup() should not return VNodes directly - </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">return a render function instead.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">vm._setupState = setupResult;</span><span class="s2">\n      </span><span class="s1">// __sfc indicates compiled bindings from &lt;script setup&gt;</span><span class="s2">\n      </span><span class="s1">if (!setupResult.__sfc) {</span><span class="s2">\n        </span><span class="s1">for (var key in setupResult) {</span><span class="s2">\n          </span><span class="s1">if (!isReserved(key)) {</span><span class="s2">\n            </span><span class="s1">proxyWithRefUnwrap(vm, setupResult, key);</span><span class="s2">\n          </span><span class="s1">} else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Avoid using variables that start with _ or $ in setup().</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">// exposed for compiled render fn</span><span class="s2">\n        </span><span class="s1">var proxy = vm._setupProxy = {};</span><span class="s2">\n        </span><span class="s1">for (var key in setupResult) {</span><span class="s2">\n          </span><span class="s1">if (key !== '__sfc') {</span><span class="s2">\n            </span><span class="s1">proxyWithRefUnwrap(proxy, setupResult, key);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (process.env.NODE_ENV !== 'production' &amp;&amp; setupResult !== undefined) {</span><span class="s2">\n      </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">setup() should return an object. Received: </span><span class="s2">\&quot;</span><span class="s1">.concat(setupResult === null ? 'null' : typeof setupResult));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createSetupContext(vm) {</span><span class="s2">\n  </span><span class="s1">var exposeCalled = false;</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">get attrs() {</span><span class="s2">\n      </span><span class="s1">if (!vm._attrsProxy) {</span><span class="s2">\n        </span><span class="s1">var proxy = vm._attrsProxy = {};</span><span class="s2">\n        </span><span class="s1">def(proxy, '_v_attr_proxy', true);</span><span class="s2">\n        </span><span class="s1">syncSetupProxy(proxy, vm.$attrs, emptyObject, vm, '$attrs');</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return vm._attrsProxy;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get listeners() {</span><span class="s2">\n      </span><span class="s1">if (!vm._listenersProxy) {</span><span class="s2">\n        </span><span class="s1">var proxy = vm._listenersProxy = {};</span><span class="s2">\n        </span><span class="s1">syncSetupProxy(proxy, vm.$listeners, emptyObject, vm, '$listeners');</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return vm._listenersProxy;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get slots() {</span><span class="s2">\n      </span><span class="s1">return initSlotsProxy(vm);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">emit: bind(vm.$emit, vm),</span><span class="s2">\n    </span><span class="s1">expose: function (exposed) {</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">if (exposeCalled) {</span><span class="s2">\n          </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">expose() should be called only once per setup().</span><span class="s2">\&quot;</span><span class="s1">, vm);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">exposeCalled = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (exposed) {</span><span class="s2">\n        </span><span class="s1">Object.keys(exposed).forEach(function (key) {</span><span class="s2">\n          </span><span class="s1">return proxyWithRefUnwrap(vm, exposed, key);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function syncSetupProxy(to, from, prev, instance, type) {</span><span class="s2">\n  </span><span class="s1">var changed = false;</span><span class="s2">\n  </span><span class="s1">for (var key in from) {</span><span class="s2">\n    </span><span class="s1">if (!(key in to)) {</span><span class="s2">\n      </span><span class="s1">changed = true;</span><span class="s2">\n      </span><span class="s1">defineProxyAttr(to, key, instance, type);</span><span class="s2">\n    </span><span class="s1">} else if (from[key] !== prev[key]) {</span><span class="s2">\n      </span><span class="s1">changed = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">for (var key in to) {</span><span class="s2">\n    </span><span class="s1">if (!(key in from)) {</span><span class="s2">\n      </span><span class="s1">changed = true;</span><span class="s2">\n      </span><span class="s1">delete to[key];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return changed;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function defineProxyAttr(proxy, key, instance, type) {</span><span class="s2">\n  </span><span class="s1">Object.defineProperty(proxy, key, {</span><span class="s2">\n    </span><span class="s1">enumerable: true,</span><span class="s2">\n    </span><span class="s1">configurable: true,</span><span class="s2">\n    </span><span class="s1">get: function () {</span><span class="s2">\n      </span><span class="s1">return instance[type][key];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initSlotsProxy(vm) {</span><span class="s2">\n  </span><span class="s1">if (!vm._slotsProxy) {</span><span class="s2">\n    </span><span class="s1">syncSetupSlots(vm._slotsProxy = {}, vm.$scopedSlots);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return vm._slotsProxy;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function syncSetupSlots(to, from) {</span><span class="s2">\n  </span><span class="s1">for (var key in from) {</span><span class="s2">\n    </span><span class="s1">to[key] = from[key];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">for (var key in to) {</span><span class="s2">\n    </span><span class="s1">if (!(key in from)) {</span><span class="s2">\n      </span><span class="s1">delete to[key];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal use manual type def because public setup context type relies on</span><span class="s2">\n </span><span class="s1">* legacy VNode types</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function useSlots() {</span><span class="s2">\n  </span><span class="s1">return getContext().slots;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal use manual type def because public setup context type relies on</span><span class="s2">\n </span><span class="s1">* legacy VNode types</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function useAttrs() {</span><span class="s2">\n  </span><span class="s1">return getContext().attrs;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Vue 2 only</span><span class="s2">\n </span><span class="s1">* @internal use manual type def because public setup context type relies on</span><span class="s2">\n </span><span class="s1">* legacy VNode types</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function useListeners() {</span><span class="s2">\n  </span><span class="s1">return getContext().listeners;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getContext() {</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !currentInstance) {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">useContext() called without active instance.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var vm = currentInstance;</span><span class="s2">\n  </span><span class="s1">return vm._setupContext || (vm._setupContext = createSetupContext(vm));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for merging default declarations. Imported by compiled code</span><span class="s2">\n </span><span class="s1">* only.</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function mergeDefaults(raw, defaults) {</span><span class="s2">\n  </span><span class="s1">var props = isArray(raw) ? raw.reduce(function (normalized, p) {</span><span class="s2">\n    </span><span class="s1">return normalized[p] = {}, normalized;</span><span class="s2">\n  </span><span class="s1">}, {}) : raw;</span><span class="s2">\n  </span><span class="s1">for (var key in defaults) {</span><span class="s2">\n    </span><span class="s1">var opt = props[key];</span><span class="s2">\n    </span><span class="s1">if (opt) {</span><span class="s2">\n      </span><span class="s1">if (isArray(opt) || isFunction(opt)) {</span><span class="s2">\n        </span><span class="s1">props[key] = {</span><span class="s2">\n          </span><span class="s1">type: opt,</span><span class="s2">\n          </span><span class="s1">default: defaults[key]</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">opt.default = defaults[key];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (opt === null) {</span><span class="s2">\n      </span><span class="s1">props[key] = {</span><span class="s2">\n        </span><span class="s1">default: defaults[key]</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">props default key </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">has no corresponding declaration.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return props;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initRender(vm) {</span><span class="s2">\n  </span><span class="s1">vm._vnode = null; // the root of the child tree</span><span class="s2">\n  </span><span class="s1">vm._staticTrees = null; // v-once cached trees</span><span class="s2">\n  </span><span class="s1">var options = vm.$options;</span><span class="s2">\n  </span><span class="s1">var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree</span><span class="s2">\n  </span><span class="s1">var renderContext = parentVnode &amp;&amp; parentVnode.context;</span><span class="s2">\n  </span><span class="s1">vm.$slots = resolveSlots(options._renderChildren, renderContext);</span><span class="s2">\n  </span><span class="s1">vm.$scopedSlots = parentVnode ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots) : emptyObject;</span><span class="s2">\n  </span><span class="s1">// bind the createElement fn to this instance</span><span class="s2">\n  </span><span class="s1">// so that we get proper render context inside it.</span><span class="s2">\n  </span><span class="s1">// args order: tag, data, children, normalizationType, alwaysNormalize</span><span class="s2">\n  </span><span class="s1">// internal version is used by render functions compiled from templates</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error</span><span class="s2">\n  </span><span class="s1">vm._c = function (a, b, c, d) {</span><span class="s2">\n    </span><span class="s1">return createElement$1(vm, a, b, c, d, false);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">// normalization is always applied for the public version, used in</span><span class="s2">\n  </span><span class="s1">// user-written render functions.</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error</span><span class="s2">\n  </span><span class="s1">vm.$createElement = function (a, b, c, d) {</span><span class="s2">\n    </span><span class="s1">return createElement$1(vm, a, b, c, d, true);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">// $attrs &amp; $listeners are exposed for easier HOC creation.</span><span class="s2">\n  </span><span class="s1">// they need to be reactive so that HOCs using them are always updated</span><span class="s2">\n  </span><span class="s1">var parentData = parentVnode &amp;&amp; parentVnode.data;</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">defineReactive(vm, '$attrs', parentData &amp;&amp; parentData.attrs || emptyObject, function () {</span><span class="s2">\n      </span><span class="s1">!isUpdatingChildComponent &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">$attrs is readonly.</span><span class="s2">\&quot;</span><span class="s1">, vm);</span><span class="s2">\n    </span><span class="s1">}, true);</span><span class="s2">\n    </span><span class="s1">defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {</span><span class="s2">\n      </span><span class="s1">!isUpdatingChildComponent &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">$listeners is readonly.</span><span class="s2">\&quot;</span><span class="s1">, vm);</span><span class="s2">\n    </span><span class="s1">}, true);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">defineReactive(vm, '$attrs', parentData &amp;&amp; parentData.attrs || emptyObject, null, true);</span><span class="s2">\n    </span><span class="s1">defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var currentRenderingInstance = null;</span><span class="s2">\n</span><span class="s1">function renderMixin(Vue) {</span><span class="s2">\n  </span><span class="s1">// install runtime convenience helpers</span><span class="s2">\n  </span><span class="s1">installRenderHelpers(Vue.prototype);</span><span class="s2">\n  </span><span class="s1">Vue.prototype.$nextTick = function (fn) {</span><span class="s2">\n    </span><span class="s1">return nextTick(fn, this);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">Vue.prototype._render = function () {</span><span class="s2">\n    </span><span class="s1">var vm = this;</span><span class="s2">\n    </span><span class="s1">var _a = vm.$options,</span><span class="s2">\n      </span><span class="s1">render = _a.render,</span><span class="s2">\n      </span><span class="s1">_parentVnode = _a._parentVnode;</span><span class="s2">\n    </span><span class="s1">if (_parentVnode &amp;&amp; vm._isMounted) {</span><span class="s2">\n      </span><span class="s1">vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);</span><span class="s2">\n      </span><span class="s1">if (vm._slotsProxy) {</span><span class="s2">\n        </span><span class="s1">syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// set parent vnode. this allows render functions to have access</span><span class="s2">\n    </span><span class="s1">// to the data on the placeholder node.</span><span class="s2">\n    </span><span class="s1">vm.$vnode = _parentVnode;</span><span class="s2">\n    </span><span class="s1">// render self</span><span class="s2">\n    </span><span class="s1">var vnode;</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">// There's no need to maintain a stack because all render fns are called</span><span class="s2">\n      </span><span class="s1">// separately from one another. Nested component's render fns are called</span><span class="s2">\n      </span><span class="s1">// when parent component is patched.</span><span class="s2">\n      </span><span class="s1">setCurrentInstance(vm);</span><span class="s2">\n      </span><span class="s1">currentRenderingInstance = vm;</span><span class="s2">\n      </span><span class="s1">vnode = render.call(vm._renderProxy, vm.$createElement);</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">handleError(e, vm, </span><span class="s2">\&quot;</span><span class="s1">render</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">// return error render result,</span><span class="s2">\n      </span><span class="s1">// or previous vnode to prevent render error causing blank component</span><span class="s2">\n      </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; vm.$options.renderError) {</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n          </span><span class="s1">vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);</span><span class="s2">\n        </span><span class="s1">} catch (e) {</span><span class="s2">\n          </span><span class="s1">handleError(e, vm, </span><span class="s2">\&quot;</span><span class="s1">renderError</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">vnode = vm._vnode;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">vnode = vm._vnode;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} finally {</span><span class="s2">\n      </span><span class="s1">currentRenderingInstance = null;</span><span class="s2">\n      </span><span class="s1">setCurrentInstance();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// if the returned array contains only a single node, allow it</span><span class="s2">\n    </span><span class="s1">if (isArray(vnode) &amp;&amp; vnode.length === 1) {</span><span class="s2">\n      </span><span class="s1">vnode = vnode[0];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// return empty vnode in case the render function errored out</span><span class="s2">\n    </span><span class="s1">if (!(vnode instanceof VNode)) {</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; isArray(vnode)) {</span><span class="s2">\n        </span><span class="s1">warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">vnode = createEmptyVNode();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// set parent</span><span class="s2">\n    </span><span class="s1">vnode.parent = _parentVnode;</span><span class="s2">\n    </span><span class="s1">return vnode;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function ensureCtor(comp, base) {</span><span class="s2">\n  </span><span class="s1">if (comp.__esModule || hasSymbol &amp;&amp; comp[Symbol.toStringTag] === 'Module') {</span><span class="s2">\n    </span><span class="s1">comp = comp.default;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return isObject(comp) ? base.extend(comp) : comp;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createAsyncPlaceholder(factory, data, context, children, tag) {</span><span class="s2">\n  </span><span class="s1">var node = createEmptyVNode();</span><span class="s2">\n  </span><span class="s1">node.asyncFactory = factory;</span><span class="s2">\n  </span><span class="s1">node.asyncMeta = {</span><span class="s2">\n    </span><span class="s1">data: data,</span><span class="s2">\n    </span><span class="s1">context: context,</span><span class="s2">\n    </span><span class="s1">children: children,</span><span class="s2">\n    </span><span class="s1">tag: tag</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return node;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveAsyncComponent(factory, baseCtor) {</span><span class="s2">\n  </span><span class="s1">if (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) {</span><span class="s2">\n    </span><span class="s1">return factory.errorComp;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isDef(factory.resolved)) {</span><span class="s2">\n    </span><span class="s1">return factory.resolved;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var owner = currentRenderingInstance;</span><span class="s2">\n  </span><span class="s1">if (owner &amp;&amp; isDef(factory.owners) &amp;&amp; factory.owners.indexOf(owner) === -1) {</span><span class="s2">\n    </span><span class="s1">// already pending</span><span class="s2">\n    </span><span class="s1">factory.owners.push(owner);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isTrue(factory.loading) &amp;&amp; isDef(factory.loadingComp)) {</span><span class="s2">\n    </span><span class="s1">return factory.loadingComp;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (owner &amp;&amp; !isDef(factory.owners)) {</span><span class="s2">\n    </span><span class="s1">var owners_1 = factory.owners = [owner];</span><span class="s2">\n    </span><span class="s1">var sync_1 = true;</span><span class="s2">\n    </span><span class="s1">var timerLoading_1 = null;</span><span class="s2">\n    </span><span class="s1">var timerTimeout_1 = null;</span><span class="s2">\n    </span><span class="s1">owner.$on('hook:destroyed', function () {</span><span class="s2">\n      </span><span class="s1">return remove$2(owners_1, owner);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">var forceRender_1 = function (renderCompleted) {</span><span class="s2">\n      </span><span class="s1">for (var i = 0, l = owners_1.length; i &lt; l; i++) {</span><span class="s2">\n        </span><span class="s1">owners_1[i].$forceUpdate();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (renderCompleted) {</span><span class="s2">\n        </span><span class="s1">owners_1.length = 0;</span><span class="s2">\n        </span><span class="s1">if (timerLoading_1 !== null) {</span><span class="s2">\n          </span><span class="s1">clearTimeout(timerLoading_1);</span><span class="s2">\n          </span><span class="s1">timerLoading_1 = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (timerTimeout_1 !== null) {</span><span class="s2">\n          </span><span class="s1">clearTimeout(timerTimeout_1);</span><span class="s2">\n          </span><span class="s1">timerTimeout_1 = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var resolve = once(function (res) {</span><span class="s2">\n      </span><span class="s1">// cache resolved</span><span class="s2">\n      </span><span class="s1">factory.resolved = ensureCtor(res, baseCtor);</span><span class="s2">\n      </span><span class="s1">// invoke callbacks only if this is not a synchronous resolve</span><span class="s2">\n      </span><span class="s1">// (async resolves are shimmed as synchronous during SSR)</span><span class="s2">\n      </span><span class="s1">if (!sync_1) {</span><span class="s2">\n        </span><span class="s1">forceRender_1(true);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">owners_1.length = 0;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">var reject_1 = once(function (reason) {</span><span class="s2">\n      </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">Failed to resolve async component: </span><span class="s2">\&quot;</span><span class="s1">.concat(String(factory)) + (reason ? </span><span class="s2">\&quot;\\</span><span class="s1">nReason: </span><span class="s2">\&quot;</span><span class="s1">.concat(reason) : ''));</span><span class="s2">\n      </span><span class="s1">if (isDef(factory.errorComp)) {</span><span class="s2">\n        </span><span class="s1">factory.error = true;</span><span class="s2">\n        </span><span class="s1">forceRender_1(true);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">var res_1 = factory(resolve, reject_1);</span><span class="s2">\n    </span><span class="s1">if (isObject(res_1)) {</span><span class="s2">\n      </span><span class="s1">if (isPromise(res_1)) {</span><span class="s2">\n        </span><span class="s1">// () =&gt; Promise</span><span class="s2">\n        </span><span class="s1">if (isUndef(factory.resolved)) {</span><span class="s2">\n          </span><span class="s1">res_1.then(resolve, reject_1);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else if (isPromise(res_1.component)) {</span><span class="s2">\n        </span><span class="s1">res_1.component.then(resolve, reject_1);</span><span class="s2">\n        </span><span class="s1">if (isDef(res_1.error)) {</span><span class="s2">\n          </span><span class="s1">factory.errorComp = ensureCtor(res_1.error, baseCtor);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isDef(res_1.loading)) {</span><span class="s2">\n          </span><span class="s1">factory.loadingComp = ensureCtor(res_1.loading, baseCtor);</span><span class="s2">\n          </span><span class="s1">if (res_1.delay === 0) {</span><span class="s2">\n            </span><span class="s1">factory.loading = true;</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error NodeJS timeout type</span><span class="s2">\n            </span><span class="s1">timerLoading_1 = setTimeout(function () {</span><span class="s2">\n              </span><span class="s1">timerLoading_1 = null;</span><span class="s2">\n              </span><span class="s1">if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) {</span><span class="s2">\n                </span><span class="s1">factory.loading = true;</span><span class="s2">\n                </span><span class="s1">forceRender_1(false);</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}, res_1.delay || 200);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isDef(res_1.timeout)) {</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error NodeJS timeout type</span><span class="s2">\n          </span><span class="s1">timerTimeout_1 = setTimeout(function () {</span><span class="s2">\n            </span><span class="s1">timerTimeout_1 = null;</span><span class="s2">\n            </span><span class="s1">if (isUndef(factory.resolved)) {</span><span class="s2">\n              </span><span class="s1">reject_1(process.env.NODE_ENV !== 'production' ? </span><span class="s2">\&quot;</span><span class="s1">timeout (</span><span class="s2">\&quot;</span><span class="s1">.concat(res_1.timeout, </span><span class="s2">\&quot;</span><span class="s1">ms)</span><span class="s2">\&quot;</span><span class="s1">) : null);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}, res_1.timeout);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">sync_1 = false;</span><span class="s2">\n    </span><span class="s1">// return in case resolved synchronously</span><span class="s2">\n    </span><span class="s1">return factory.loading ? factory.loadingComp : factory.resolved;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getFirstComponentChild(children) {</span><span class="s2">\n  </span><span class="s1">if (isArray(children)) {</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; children.length; i++) {</span><span class="s2">\n      </span><span class="s1">var c = children[i];</span><span class="s2">\n      </span><span class="s1">if (isDef(c) &amp;&amp; (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {</span><span class="s2">\n        </span><span class="s1">return c;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var SIMPLE_NORMALIZE = 1;</span><span class="s2">\n</span><span class="s1">var ALWAYS_NORMALIZE = 2;</span><span class="s2">\n</span><span class="s1">// wrapper function for providing a more flexible interface</span><span class="s2">\n</span><span class="s1">// without getting yelled at by flow</span><span class="s2">\n</span><span class="s1">function createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {</span><span class="s2">\n  </span><span class="s1">if (isArray(data) || isPrimitive(data)) {</span><span class="s2">\n    </span><span class="s1">normalizationType = children;</span><span class="s2">\n    </span><span class="s1">children = data;</span><span class="s2">\n    </span><span class="s1">data = undefined;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isTrue(alwaysNormalize)) {</span><span class="s2">\n    </span><span class="s1">normalizationType = ALWAYS_NORMALIZE;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return _createElement(context, tag, data, children, normalizationType);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function _createElement(context, tag, data, children, normalizationType) {</span><span class="s2">\n  </span><span class="s1">if (isDef(data) &amp;&amp; isDef(data.__ob__)) {</span><span class="s2">\n    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">Avoid using observed data object as vnode data: </span><span class="s2">\&quot;</span><span class="s1">.concat(JSON.stringify(data), </span><span class="s2">\&quot;\\</span><span class="s1">n</span><span class="s2">\&quot;</span><span class="s1">) + 'Always create fresh vnode data objects in each render!', context);</span><span class="s2">\n    </span><span class="s1">return createEmptyVNode();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// object syntax in v-bind</span><span class="s2">\n  </span><span class="s1">if (isDef(data) &amp;&amp; isDef(data.is)) {</span><span class="s2">\n    </span><span class="s1">tag = data.is;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!tag) {</span><span class="s2">\n    </span><span class="s1">// in case of component :is set to falsy value</span><span class="s2">\n    </span><span class="s1">return createEmptyVNode();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// warn against non-primitive key</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key)) {</span><span class="s2">\n    </span><span class="s1">warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// support single function children as default scoped slot</span><span class="s2">\n  </span><span class="s1">if (isArray(children) &amp;&amp; isFunction(children[0])) {</span><span class="s2">\n    </span><span class="s1">data = data || {};</span><span class="s2">\n    </span><span class="s1">data.scopedSlots = {</span><span class="s2">\n      </span><span class="s1">default: children[0]</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">children.length = 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (normalizationType === ALWAYS_NORMALIZE) {</span><span class="s2">\n    </span><span class="s1">children = normalizeChildren(children);</span><span class="s2">\n  </span><span class="s1">} else if (normalizationType === SIMPLE_NORMALIZE) {</span><span class="s2">\n    </span><span class="s1">children = simpleNormalizeChildren(children);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var vnode, ns;</span><span class="s2">\n  </span><span class="s1">if (typeof tag === 'string') {</span><span class="s2">\n    </span><span class="s1">var Ctor = void 0;</span><span class="s2">\n    </span><span class="s1">ns = context.$vnode &amp;&amp; context.$vnode.ns || config.getTagNamespace(tag);</span><span class="s2">\n    </span><span class="s1">if (config.isReservedTag(tag)) {</span><span class="s2">\n      </span><span class="s1">// platform built-in elements</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; isDef(data) &amp;&amp; isDef(data.nativeOn) &amp;&amp; data.tag !== 'component') {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">The .native modifier for v-on is only valid on components but it was used on &lt;</span><span class="s2">\&quot;</span><span class="s1">.concat(tag, </span><span class="s2">\&quot;</span><span class="s1">&gt;.</span><span class="s2">\&quot;</span><span class="s1">), context);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);</span><span class="s2">\n    </span><span class="s1">} else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {</span><span class="s2">\n      </span><span class="s1">// component</span><span class="s2">\n      </span><span class="s1">vnode = createComponent(Ctor, data, context, children, tag);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">// unknown or unlisted namespaced elements</span><span class="s2">\n      </span><span class="s1">// check at runtime because it may get assigned a namespace when its</span><span class="s2">\n      </span><span class="s1">// parent normalizes children</span><span class="s2">\n      </span><span class="s1">vnode = new VNode(tag, data, children, undefined, undefined, context);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">// direct component options / constructor</span><span class="s2">\n    </span><span class="s1">vnode = createComponent(tag, data, context, children);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isArray(vnode)) {</span><span class="s2">\n    </span><span class="s1">return vnode;</span><span class="s2">\n  </span><span class="s1">} else if (isDef(vnode)) {</span><span class="s2">\n    </span><span class="s1">if (isDef(ns)) applyNS(vnode, ns);</span><span class="s2">\n    </span><span class="s1">if (isDef(data)) registerDeepBindings(data);</span><span class="s2">\n    </span><span class="s1">return vnode;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return createEmptyVNode();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function applyNS(vnode, ns, force) {</span><span class="s2">\n  </span><span class="s1">vnode.ns = ns;</span><span class="s2">\n  </span><span class="s1">if (vnode.tag === 'foreignObject') {</span><span class="s2">\n    </span><span class="s1">// use default namespace inside foreignObject</span><span class="s2">\n    </span><span class="s1">ns = undefined;</span><span class="s2">\n    </span><span class="s1">force = true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isDef(vnode.children)) {</span><span class="s2">\n    </span><span class="s1">for (var i = 0, l = vnode.children.length; i &lt; l; i++) {</span><span class="s2">\n      </span><span class="s1">var child = vnode.children[i];</span><span class="s2">\n      </span><span class="s1">if (isDef(child.tag) &amp;&amp; (isUndef(child.ns) || isTrue(force) &amp;&amp; child.tag !== 'svg')) {</span><span class="s2">\n        </span><span class="s1">applyNS(child, ns, force);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// ref #5318</span><span class="s2">\n</span><span class="s1">// necessary to ensure parent re-render when deep bindings like :style and</span><span class="s2">\n</span><span class="s1">// :class are used on slot nodes</span><span class="s2">\n</span><span class="s1">function registerDeepBindings(data) {</span><span class="s2">\n  </span><span class="s1">if (isObject(data.style)) {</span><span class="s2">\n    </span><span class="s1">traverse(data.style);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isObject(data.class)) {</span><span class="s2">\n    </span><span class="s1">traverse(data.class);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal this function needs manual public type declaration because it relies</span><span class="s2">\n </span><span class="s1">* on previously manually authored types from Vue 2</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function h(type, props, children) {</span><span class="s2">\n  </span><span class="s1">if (!currentInstance) {</span><span class="s2">\n    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">globally imported h() can only be invoked when there is an active </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">component instance, e.g. synchronously in a component's render or setup function.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return createElement$1(currentInstance, type, props, children, 2, true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function handleError(err, vm, info) {</span><span class="s2">\n  </span><span class="s1">// Deactivate deps tracking while processing error handler to avoid possible infinite rendering.</span><span class="s2">\n  </span><span class="s1">// See: https://github.com/vuejs/vuex/issues/1505</span><span class="s2">\n  </span><span class="s1">pushTarget();</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">if (vm) {</span><span class="s2">\n      </span><span class="s1">var cur = vm;</span><span class="s2">\n      </span><span class="s1">while (cur = cur.$parent) {</span><span class="s2">\n        </span><span class="s1">var hooks = cur.$options.errorCaptured;</span><span class="s2">\n        </span><span class="s1">if (hooks) {</span><span class="s2">\n          </span><span class="s1">for (var i = 0; i &lt; hooks.length; i++) {</span><span class="s2">\n            </span><span class="s1">try {</span><span class="s2">\n              </span><span class="s1">var capture = hooks[i].call(cur, err, vm, info) === false;</span><span class="s2">\n              </span><span class="s1">if (capture) return;</span><span class="s2">\n            </span><span class="s1">} catch (e) {</span><span class="s2">\n              </span><span class="s1">globalHandleError(e, cur, 'errorCaptured hook');</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">globalHandleError(err, vm, info);</span><span class="s2">\n  </span><span class="s1">} finally {</span><span class="s2">\n    </span><span class="s1">popTarget();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function invokeWithErrorHandling(handler, context, args, vm, info) {</span><span class="s2">\n  </span><span class="s1">var res;</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">res = args ? handler.apply(context, args) : handler.call(context);</span><span class="s2">\n    </span><span class="s1">if (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) {</span><span class="s2">\n      </span><span class="s1">res.catch(function (e) {</span><span class="s2">\n        </span><span class="s1">return handleError(e, vm, info + </span><span class="s2">\&quot; </span><span class="s1">(Promise/async)</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">res._handled = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">handleError(e, vm, info);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function globalHandleError(err, vm, info) {</span><span class="s2">\n  </span><span class="s1">if (config.errorHandler) {</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">return config.errorHandler.call(null, err, vm, info);</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">// if the user intentionally throws the original error in the handler,</span><span class="s2">\n      </span><span class="s1">// do not log it twice</span><span class="s2">\n      </span><span class="s1">if (e !== err) {</span><span class="s2">\n        </span><span class="s1">logError(e, null, 'config.errorHandler');</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">logError(err, vm, info);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function logError(err, vm, info) {</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Error in </span><span class="s2">\&quot;</span><span class="s1">.concat(info, </span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">).concat(err.toString(), </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">), vm);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n  </span><span class="s1">if (inBrowser &amp;&amp; typeof console !== 'undefined') {</span><span class="s2">\n    </span><span class="s1">console.error(err);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">throw err;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/* globals MutationObserver */</span><span class="s2">\n</span><span class="s1">var isUsingMicroTask = false;</span><span class="s2">\n</span><span class="s1">var callbacks = [];</span><span class="s2">\n</span><span class="s1">var pending = false;</span><span class="s2">\n</span><span class="s1">function flushCallbacks() {</span><span class="s2">\n  </span><span class="s1">pending = false;</span><span class="s2">\n  </span><span class="s1">var copies = callbacks.slice(0);</span><span class="s2">\n  </span><span class="s1">callbacks.length = 0;</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; copies.length; i++) {</span><span class="s2">\n    </span><span class="s1">copies[i]();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// Here we have async deferring wrappers using microtasks.</span><span class="s2">\n</span><span class="s1">// In 2.5 we used (macro) tasks (in combination with microtasks).</span><span class="s2">\n</span><span class="s1">// However, it has subtle problems when state is changed right before repaint</span><span class="s2">\n</span><span class="s1">// (e.g. #6813, out-in transitions).</span><span class="s2">\n</span><span class="s1">// Also, using (macro) tasks in event handler would cause some weird behaviors</span><span class="s2">\n</span><span class="s1">// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).</span><span class="s2">\n</span><span class="s1">// So we now use microtasks everywhere, again.</span><span class="s2">\n</span><span class="s1">// A major drawback of this tradeoff is that there are some scenarios</span><span class="s2">\n</span><span class="s1">// where microtasks have too high a priority and fire in between supposedly</span><span class="s2">\n</span><span class="s1">// sequential events (e.g. #4521, #6690, which have workarounds)</span><span class="s2">\n</span><span class="s1">// or even between bubbling of the same event (#6566).</span><span class="s2">\n</span><span class="s1">var timerFunc;</span><span class="s2">\n</span><span class="s1">// The nextTick behavior leverages the microtask queue, which can be accessed</span><span class="s2">\n</span><span class="s1">// via either native Promise.then or MutationObserver.</span><span class="s2">\n</span><span class="s1">// MutationObserver has wider support, however it is seriously bugged in</span><span class="s2">\n</span><span class="s1">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span><span class="s2">\n</span><span class="s1">// completely stops working after triggering a few times... so, if native</span><span class="s2">\n</span><span class="s1">// Promise is available, we will use it:</span><span class="s2">\n</span><span class="s1">/* istanbul ignore next, $flow-disable-line */</span><span class="s2">\n</span><span class="s1">if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) {</span><span class="s2">\n  </span><span class="s1">var p_1 = Promise.resolve();</span><span class="s2">\n  </span><span class="s1">timerFunc = function () {</span><span class="s2">\n    </span><span class="s1">p_1.then(flushCallbacks);</span><span class="s2">\n    </span><span class="s1">// In problematic UIWebViews, Promise.then doesn't completely break, but</span><span class="s2">\n    </span><span class="s1">// it can get stuck in a weird state where callbacks are pushed into the</span><span class="s2">\n    </span><span class="s1">// microtask queue but the queue isn't being flushed, until the browser</span><span class="s2">\n    </span><span class="s1">// needs to do some other work, e.g. handle a timer. Therefore we can</span><span class="s2">\n    </span><span class="s1">// </span><span class="s2">\&quot;</span><span class="s1">force</span><span class="s2">\&quot; </span><span class="s1">the microtask queue to be flushed by adding an empty timer.</span><span class="s2">\n    </span><span class="s1">if (isIOS) setTimeout(noop);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">isUsingMicroTask = true;</span><span class="s2">\n</span><span class="s1">} else if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; (isNative(MutationObserver) ||</span><span class="s2">\n</span><span class="s1">// PhantomJS and iOS 7.x</span><span class="s2">\n</span><span class="s1">MutationObserver.toString() === '[object MutationObserverConstructor]')) {</span><span class="s2">\n  </span><span class="s1">// Use MutationObserver where native Promise is not available,</span><span class="s2">\n  </span><span class="s1">// e.g. PhantomJS, iOS7, Android 4.4</span><span class="s2">\n  </span><span class="s1">// (#6466 MutationObserver is unreliable in IE11)</span><span class="s2">\n  </span><span class="s1">var counter_1 = 1;</span><span class="s2">\n  </span><span class="s1">var observer = new MutationObserver(flushCallbacks);</span><span class="s2">\n  </span><span class="s1">var textNode_1 = document.createTextNode(String(counter_1));</span><span class="s2">\n  </span><span class="s1">observer.observe(textNode_1, {</span><span class="s2">\n    </span><span class="s1">characterData: true</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">timerFunc = function () {</span><span class="s2">\n    </span><span class="s1">counter_1 = (counter_1 + 1) % 2;</span><span class="s2">\n    </span><span class="s1">textNode_1.data = String(counter_1);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">isUsingMicroTask = true;</span><span class="s2">\n</span><span class="s1">} else if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) {</span><span class="s2">\n  </span><span class="s1">// Fallback to setImmediate.</span><span class="s2">\n  </span><span class="s1">// Technically it leverages the (macro) task queue,</span><span class="s2">\n  </span><span class="s1">// but it is still a better choice than setTimeout.</span><span class="s2">\n  </span><span class="s1">timerFunc = function () {</span><span class="s2">\n    </span><span class="s1">setImmediate(flushCallbacks);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">} else {</span><span class="s2">\n  </span><span class="s1">// Fallback to setTimeout.</span><span class="s2">\n  </span><span class="s1">timerFunc = function () {</span><span class="s2">\n    </span><span class="s1">setTimeout(flushCallbacks, 0);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function nextTick(cb, ctx) {</span><span class="s2">\n  </span><span class="s1">var _resolve;</span><span class="s2">\n  </span><span class="s1">callbacks.push(function () {</span><span class="s2">\n    </span><span class="s1">if (cb) {</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">cb.call(ctx);</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n        </span><span class="s1">handleError(e, ctx, 'nextTick');</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (_resolve) {</span><span class="s2">\n      </span><span class="s1">_resolve(ctx);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">if (!pending) {</span><span class="s2">\n    </span><span class="s1">pending = true;</span><span class="s2">\n    </span><span class="s1">timerFunc();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// $flow-disable-line</span><span class="s2">\n  </span><span class="s1">if (!cb &amp;&amp; typeof Promise !== 'undefined') {</span><span class="s2">\n    </span><span class="s1">return new Promise(function (resolve) {</span><span class="s2">\n      </span><span class="s1">_resolve = resolve;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useCssModule(name) {</span><span class="s2">\n  </span><span class="s1">if (name === void 0) {</span><span class="s2">\n    </span><span class="s1">name = '$style';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n  </span><span class="s1">{</span><span class="s2">\n    </span><span class="s1">if (!currentInstance) {</span><span class="s2">\n      </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">useCssModule must be called inside setup()</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return emptyObject;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var mod = currentInstance[name];</span><span class="s2">\n    </span><span class="s1">if (!mod) {</span><span class="s2">\n      </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">Current instance does not have CSS module named </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n      </span><span class="s1">return emptyObject;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return mod;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for SFC's CSS variable injection feature.</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function useCssVars(getter) {</span><span class="s2">\n  </span><span class="s1">if (!inBrowser &amp;&amp; !false) return;</span><span class="s2">\n  </span><span class="s1">var instance = currentInstance;</span><span class="s2">\n  </span><span class="s1">if (!instance) {</span><span class="s2">\n    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">useCssVars is called without current active component instance.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">watchPostEffect(function () {</span><span class="s2">\n    </span><span class="s1">var el = instance.$el;</span><span class="s2">\n    </span><span class="s1">var vars = getter(instance, instance._setupProxy);</span><span class="s2">\n    </span><span class="s1">if (el &amp;&amp; el.nodeType === 1) {</span><span class="s2">\n      </span><span class="s1">var style = el.style;</span><span class="s2">\n      </span><span class="s1">for (var key in vars) {</span><span class="s2">\n        </span><span class="s1">style.setProperty(</span><span class="s2">\&quot;</span><span class="s1">--</span><span class="s2">\&quot;</span><span class="s1">.concat(key), vars[key]);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* v3-compatible async component API.</span><span class="s2">\n </span><span class="s1">* @internal the type is manually declared in &lt;root&gt;/types/v3-define-async-component.d.ts</span><span class="s2">\n </span><span class="s1">* because it relies on existing manual types</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function defineAsyncComponent(source) {</span><span class="s2">\n  </span><span class="s1">if (isFunction(source)) {</span><span class="s2">\n    </span><span class="s1">source = {</span><span class="s2">\n      </span><span class="s1">loader: source</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var loader = source.loader,</span><span class="s2">\n    </span><span class="s1">loadingComponent = source.loadingComponent,</span><span class="s2">\n    </span><span class="s1">errorComponent = source.errorComponent,</span><span class="s2">\n    </span><span class="s1">_a = source.delay,</span><span class="s2">\n    </span><span class="s1">delay = _a === void 0 ? 200 : _a,</span><span class="s2">\n    </span><span class="s1">timeout = source.timeout,</span><span class="s2">\n    </span><span class="s1">// undefined = never times out</span><span class="s2">\n    </span><span class="s1">_b = source.suspensible,</span><span class="s2">\n    </span><span class="s1">// undefined = never times out</span><span class="s2">\n    </span><span class="s1">suspensible = _b === void 0 ? false : _b,</span><span class="s2">\n    </span><span class="s1">// in Vue 3 default is true</span><span class="s2">\n    </span><span class="s1">userOnError = source.onError;</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; suspensible) {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">The suspensiblbe option for async components is not supported in Vue2. It is ignored.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var pendingRequest = null;</span><span class="s2">\n  </span><span class="s1">var retries = 0;</span><span class="s2">\n  </span><span class="s1">var retry = function () {</span><span class="s2">\n    </span><span class="s1">retries++;</span><span class="s2">\n    </span><span class="s1">pendingRequest = null;</span><span class="s2">\n    </span><span class="s1">return load();</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">var load = function () {</span><span class="s2">\n    </span><span class="s1">var thisRequest;</span><span class="s2">\n    </span><span class="s1">return pendingRequest || (thisRequest = pendingRequest = loader().catch(function (err) {</span><span class="s2">\n      </span><span class="s1">err = err instanceof Error ? err : new Error(String(err));</span><span class="s2">\n      </span><span class="s1">if (userOnError) {</span><span class="s2">\n        </span><span class="s1">return new Promise(function (resolve, reject) {</span><span class="s2">\n          </span><span class="s1">var userRetry = function () {</span><span class="s2">\n            </span><span class="s1">return resolve(retry());</span><span class="s2">\n          </span><span class="s1">};</span><span class="s2">\n          </span><span class="s1">var userFail = function () {</span><span class="s2">\n            </span><span class="s1">return reject(err);</span><span class="s2">\n          </span><span class="s1">};</span><span class="s2">\n          </span><span class="s1">userOnError(err, userRetry, userFail, retries + 1);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">throw err;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}).then(function (comp) {</span><span class="s2">\n      </span><span class="s1">if (thisRequest !== pendingRequest &amp;&amp; pendingRequest) {</span><span class="s2">\n        </span><span class="s1">return pendingRequest;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !comp) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Async component loader resolved to undefined. </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">If you are using retry(), make sure to return its return value.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">// interop module default</span><span class="s2">\n      </span><span class="s1">if (comp &amp;&amp; (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {</span><span class="s2">\n        </span><span class="s1">comp = comp.default;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; comp &amp;&amp; !isObject(comp) &amp;&amp; !isFunction(comp)) {</span><span class="s2">\n        </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">Invalid async component load result: </span><span class="s2">\&quot;</span><span class="s1">.concat(comp));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return comp;</span><span class="s2">\n    </span><span class="s1">}));</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return function () {</span><span class="s2">\n    </span><span class="s1">var component = load();</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">component: component,</span><span class="s2">\n      </span><span class="s1">delay: delay,</span><span class="s2">\n      </span><span class="s1">timeout: timeout,</span><span class="s2">\n      </span><span class="s1">error: errorComponent,</span><span class="s2">\n      </span><span class="s1">loading: loadingComponent</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createLifeCycle(hookName) {</span><span class="s2">\n  </span><span class="s1">return function (fn, target) {</span><span class="s2">\n    </span><span class="s1">if (target === void 0) {</span><span class="s2">\n      </span><span class="s1">target = currentInstance;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!target) {</span><span class="s2">\n      </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(</span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(formatName(hookName), </span><span class="s2">\&quot; </span><span class="s1">is called when there is no active component instance to be </span><span class="s2">\&quot;</span><span class="s1">) + </span><span class="s2">\&quot;</span><span class="s1">associated with. </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">Lifecycle injection APIs can only be used during execution of setup().</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return injectHook(target, hookName, fn);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function formatName(name) {</span><span class="s2">\n  </span><span class="s1">if (name === 'beforeDestroy') {</span><span class="s2">\n    </span><span class="s1">name = 'beforeUnmount';</span><span class="s2">\n  </span><span class="s1">} else if (name === 'destroyed') {</span><span class="s2">\n    </span><span class="s1">name = 'unmounted';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return </span><span class="s2">\&quot;</span><span class="s1">on</span><span class="s2">\&quot;</span><span class="s1">.concat(name[0].toUpperCase() + name.slice(1));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function injectHook(instance, hookName, fn) {</span><span class="s2">\n  </span><span class="s1">var options = instance.$options;</span><span class="s2">\n  </span><span class="s1">options[hookName] = mergeLifecycleHook(options[hookName], fn);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var onBeforeMount = createLifeCycle('beforeMount');</span><span class="s2">\n</span><span class="s1">var onMounted = createLifeCycle('mounted');</span><span class="s2">\n</span><span class="s1">var onBeforeUpdate = createLifeCycle('beforeUpdate');</span><span class="s2">\n</span><span class="s1">var onUpdated = createLifeCycle('updated');</span><span class="s2">\n</span><span class="s1">var onBeforeUnmount = createLifeCycle('beforeDestroy');</span><span class="s2">\n</span><span class="s1">var onUnmounted = createLifeCycle('destroyed');</span><span class="s2">\n</span><span class="s1">var onActivated = createLifeCycle('activated');</span><span class="s2">\n</span><span class="s1">var onDeactivated = createLifeCycle('deactivated');</span><span class="s2">\n</span><span class="s1">var onServerPrefetch = createLifeCycle('serverPrefetch');</span><span class="s2">\n</span><span class="s1">var onRenderTracked = createLifeCycle('renderTracked');</span><span class="s2">\n</span><span class="s1">var onRenderTriggered = createLifeCycle('renderTriggered');</span><span class="s2">\n</span><span class="s1">var injectErrorCapturedHook = createLifeCycle('errorCaptured');</span><span class="s2">\n</span><span class="s1">function onErrorCaptured(hook, target) {</span><span class="s2">\n  </span><span class="s1">if (target === void 0) {</span><span class="s2">\n    </span><span class="s1">target = currentInstance;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">injectErrorCapturedHook(hook, target);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Note: also update dist/vue.runtime.mjs when adding new exports to this file.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var version = '2.7.14';</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal type is manually declared in &lt;root&gt;/types/v3-define-component.d.ts</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function defineComponent(options) {</span><span class="s2">\n  </span><span class="s1">return options;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var seenObjects = new _Set();</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Recursively traverse an object to evoke all converted</span><span class="s2">\n </span><span class="s1">* getters, so that every nested property inside the object</span><span class="s2">\n </span><span class="s1">* is collected as a </span><span class="s2">\&quot;</span><span class="s1">deep</span><span class="s2">\&quot; </span><span class="s1">dependency.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function traverse(val) {</span><span class="s2">\n  </span><span class="s1">_traverse(val, seenObjects);</span><span class="s2">\n  </span><span class="s1">seenObjects.clear();</span><span class="s2">\n  </span><span class="s1">return val;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function _traverse(val, seen) {</span><span class="s2">\n  </span><span class="s1">var i, keys;</span><span class="s2">\n  </span><span class="s1">var isA = isArray(val);</span><span class="s2">\n  </span><span class="s1">if (!isA &amp;&amp; !isObject(val) || val.__v_skip /* ReactiveFlags.SKIP */ || Object.isFrozen(val) || val instanceof VNode) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (val.__ob__) {</span><span class="s2">\n    </span><span class="s1">var depId = val.__ob__.dep.id;</span><span class="s2">\n    </span><span class="s1">if (seen.has(depId)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">seen.add(depId);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isA) {</span><span class="s2">\n    </span><span class="s1">i = val.length;</span><span class="s2">\n    </span><span class="s1">while (i--) _traverse(val[i], seen);</span><span class="s2">\n  </span><span class="s1">} else if (isRef(val)) {</span><span class="s2">\n    </span><span class="s1">_traverse(val.value, seen);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">keys = Object.keys(val);</span><span class="s2">\n    </span><span class="s1">i = keys.length;</span><span class="s2">\n    </span><span class="s1">while (i--) _traverse(val[keys[i]], seen);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var uid$1 = 0;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* A watcher parses an expression, collects dependencies,</span><span class="s2">\n </span><span class="s1">* and fires callback when the expression value changes.</span><span class="s2">\n </span><span class="s1">* This is used for both the $watch() api and directives.</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var Watcher = /** @class */function () {</span><span class="s2">\n  </span><span class="s1">function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {</span><span class="s2">\n    </span><span class="s1">recordEffectScope(this,</span><span class="s2">\n    </span><span class="s1">// if the active effect scope is manually created (not a component scope),</span><span class="s2">\n    </span><span class="s1">// prioritize it</span><span class="s2">\n    </span><span class="s1">activeEffectScope &amp;&amp; !activeEffectScope._vm ? activeEffectScope : vm ? vm._scope : undefined);</span><span class="s2">\n    </span><span class="s1">if ((this.vm = vm) &amp;&amp; isRenderWatcher) {</span><span class="s2">\n      </span><span class="s1">vm._watcher = this;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// options</span><span class="s2">\n    </span><span class="s1">if (options) {</span><span class="s2">\n      </span><span class="s1">this.deep = !!options.deep;</span><span class="s2">\n      </span><span class="s1">this.user = !!options.user;</span><span class="s2">\n      </span><span class="s1">this.lazy = !!options.lazy;</span><span class="s2">\n      </span><span class="s1">this.sync = !!options.sync;</span><span class="s2">\n      </span><span class="s1">this.before = options.before;</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">this.onTrack = options.onTrack;</span><span class="s2">\n        </span><span class="s1">this.onTrigger = options.onTrigger;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">this.deep = this.user = this.lazy = this.sync = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.cb = cb;</span><span class="s2">\n    </span><span class="s1">this.id = ++uid$1; // uid for batching</span><span class="s2">\n    </span><span class="s1">this.active = true;</span><span class="s2">\n    </span><span class="s1">this.post = false;</span><span class="s2">\n    </span><span class="s1">this.dirty = this.lazy; // for lazy watchers</span><span class="s2">\n    </span><span class="s1">this.deps = [];</span><span class="s2">\n    </span><span class="s1">this.newDeps = [];</span><span class="s2">\n    </span><span class="s1">this.depIds = new _Set();</span><span class="s2">\n    </span><span class="s1">this.newDepIds = new _Set();</span><span class="s2">\n    </span><span class="s1">this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';</span><span class="s2">\n    </span><span class="s1">// parse expression for getter</span><span class="s2">\n    </span><span class="s1">if (isFunction(expOrFn)) {</span><span class="s2">\n      </span><span class="s1">this.getter = expOrFn;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">this.getter = parsePath(expOrFn);</span><span class="s2">\n      </span><span class="s1">if (!this.getter) {</span><span class="s2">\n        </span><span class="s1">this.getter = noop;</span><span class="s2">\n        </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">Failed watching path: </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(expOrFn, </span><span class="s2">\&quot;\\\&quot; \&quot;</span><span class="s1">) + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.value = this.lazy ? undefined : this.get();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Evaluate the getter, and re-collect dependencies.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">Watcher.prototype.get = function () {</span><span class="s2">\n    </span><span class="s1">pushTarget(this);</span><span class="s2">\n    </span><span class="s1">var value;</span><span class="s2">\n    </span><span class="s1">var vm = this.vm;</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">value = this.getter.call(vm, vm);</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">if (this.user) {</span><span class="s2">\n        </span><span class="s1">handleError(e, vm, </span><span class="s2">\&quot;</span><span class="s1">getter for watcher </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(this.expression, </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">));</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">throw e;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} finally {</span><span class="s2">\n      </span><span class="s1">// </span><span class="s2">\&quot;</span><span class="s1">touch</span><span class="s2">\&quot; </span><span class="s1">every property so they are all tracked as</span><span class="s2">\n      </span><span class="s1">// dependencies for deep watching</span><span class="s2">\n      </span><span class="s1">if (this.deep) {</span><span class="s2">\n        </span><span class="s1">traverse(value);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">popTarget();</span><span class="s2">\n      </span><span class="s1">this.cleanupDeps();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return value;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Add a dependency to this directive.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">Watcher.prototype.addDep = function (dep) {</span><span class="s2">\n    </span><span class="s1">var id = dep.id;</span><span class="s2">\n    </span><span class="s1">if (!this.newDepIds.has(id)) {</span><span class="s2">\n      </span><span class="s1">this.newDepIds.add(id);</span><span class="s2">\n      </span><span class="s1">this.newDeps.push(dep);</span><span class="s2">\n      </span><span class="s1">if (!this.depIds.has(id)) {</span><span class="s2">\n        </span><span class="s1">dep.addSub(this);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Clean up for dependency collection.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">Watcher.prototype.cleanupDeps = function () {</span><span class="s2">\n    </span><span class="s1">var i = this.deps.length;</span><span class="s2">\n    </span><span class="s1">while (i--) {</span><span class="s2">\n      </span><span class="s1">var dep = this.deps[i];</span><span class="s2">\n      </span><span class="s1">if (!this.newDepIds.has(dep.id)) {</span><span class="s2">\n        </span><span class="s1">dep.removeSub(this);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var tmp = this.depIds;</span><span class="s2">\n    </span><span class="s1">this.depIds = this.newDepIds;</span><span class="s2">\n    </span><span class="s1">this.newDepIds = tmp;</span><span class="s2">\n    </span><span class="s1">this.newDepIds.clear();</span><span class="s2">\n    </span><span class="s1">tmp = this.deps;</span><span class="s2">\n    </span><span class="s1">this.deps = this.newDeps;</span><span class="s2">\n    </span><span class="s1">this.newDeps = tmp;</span><span class="s2">\n    </span><span class="s1">this.newDeps.length = 0;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Subscriber interface.</span><span class="s2">\n   </span><span class="s1">* Will be called when a dependency changes.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">Watcher.prototype.update = function () {</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n    </span><span class="s1">if (this.lazy) {</span><span class="s2">\n      </span><span class="s1">this.dirty = true;</span><span class="s2">\n    </span><span class="s1">} else if (this.sync) {</span><span class="s2">\n      </span><span class="s1">this.run();</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">queueWatcher(this);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Scheduler job interface.</span><span class="s2">\n   </span><span class="s1">* Will be called by the scheduler.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">Watcher.prototype.run = function () {</span><span class="s2">\n    </span><span class="s1">if (this.active) {</span><span class="s2">\n      </span><span class="s1">var value = this.get();</span><span class="s2">\n      </span><span class="s1">if (value !== this.value ||</span><span class="s2">\n      </span><span class="s1">// Deep watchers and watchers on Object/Arrays should fire even</span><span class="s2">\n      </span><span class="s1">// when the value is the same, because the value may</span><span class="s2">\n      </span><span class="s1">// have mutated.</span><span class="s2">\n      </span><span class="s1">isObject(value) || this.deep) {</span><span class="s2">\n        </span><span class="s1">// set new value</span><span class="s2">\n        </span><span class="s1">var oldValue = this.value;</span><span class="s2">\n        </span><span class="s1">this.value = value;</span><span class="s2">\n        </span><span class="s1">if (this.user) {</span><span class="s2">\n          </span><span class="s1">var info = </span><span class="s2">\&quot;</span><span class="s1">callback for watcher </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(this.expression, </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">this.cb.call(this.vm, value, oldValue);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Evaluate the value of the watcher.</span><span class="s2">\n   </span><span class="s1">* This only gets called for lazy watchers.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">Watcher.prototype.evaluate = function () {</span><span class="s2">\n    </span><span class="s1">this.value = this.get();</span><span class="s2">\n    </span><span class="s1">this.dirty = false;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Depend on all deps collected by this watcher.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">Watcher.prototype.depend = function () {</span><span class="s2">\n    </span><span class="s1">var i = this.deps.length;</span><span class="s2">\n    </span><span class="s1">while (i--) {</span><span class="s2">\n      </span><span class="s1">this.deps[i].depend();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Remove self from all dependencies' subscriber list.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">Watcher.prototype.teardown = function () {</span><span class="s2">\n    </span><span class="s1">if (this.vm &amp;&amp; !this.vm._isBeingDestroyed) {</span><span class="s2">\n      </span><span class="s1">remove$2(this.vm._scope.effects, this);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (this.active) {</span><span class="s2">\n      </span><span class="s1">var i = this.deps.length;</span><span class="s2">\n      </span><span class="s1">while (i--) {</span><span class="s2">\n        </span><span class="s1">this.deps[i].removeSub(this);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.active = false;</span><span class="s2">\n      </span><span class="s1">if (this.onStop) {</span><span class="s2">\n        </span><span class="s1">this.onStop();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return Watcher;</span><span class="s2">\n</span><span class="s1">}();</span><span class="s2">\n</span><span class="s1">var mark;</span><span class="s2">\n</span><span class="s1">var measure;</span><span class="s2">\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n  </span><span class="s1">var perf_1 = inBrowser &amp;&amp; window.performance;</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (perf_1 &amp;&amp;</span><span class="s2">\n  </span><span class="s1">// @ts-ignore</span><span class="s2">\n  </span><span class="s1">perf_1.mark &amp;&amp;</span><span class="s2">\n  </span><span class="s1">// @ts-ignore</span><span class="s2">\n  </span><span class="s1">perf_1.measure &amp;&amp;</span><span class="s2">\n  </span><span class="s1">// @ts-ignore</span><span class="s2">\n  </span><span class="s1">perf_1.clearMarks &amp;&amp;</span><span class="s2">\n  </span><span class="s1">// @ts-ignore</span><span class="s2">\n  </span><span class="s1">perf_1.clearMeasures) {</span><span class="s2">\n    </span><span class="s1">mark = function (tag) {</span><span class="s2">\n      </span><span class="s1">return perf_1.mark(tag);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">measure = function (name, startTag, endTag) {</span><span class="s2">\n      </span><span class="s1">perf_1.measure(name, startTag, endTag);</span><span class="s2">\n      </span><span class="s1">perf_1.clearMarks(startTag);</span><span class="s2">\n      </span><span class="s1">perf_1.clearMarks(endTag);</span><span class="s2">\n      </span><span class="s1">// perf.clearMeasures(name)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function initEvents(vm) {</span><span class="s2">\n  </span><span class="s1">vm._events = Object.create(null);</span><span class="s2">\n  </span><span class="s1">vm._hasHookEvent = false;</span><span class="s2">\n  </span><span class="s1">// init parent attached events</span><span class="s2">\n  </span><span class="s1">var listeners = vm.$options._parentListeners;</span><span class="s2">\n  </span><span class="s1">if (listeners) {</span><span class="s2">\n    </span><span class="s1">updateComponentListeners(vm, listeners);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var target$1;</span><span class="s2">\n</span><span class="s1">function add$1(event, fn) {</span><span class="s2">\n  </span><span class="s1">target$1.$on(event, fn);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function remove$1(event, fn) {</span><span class="s2">\n  </span><span class="s1">target$1.$off(event, fn);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createOnceHandler$1(event, fn) {</span><span class="s2">\n  </span><span class="s1">var _target = target$1;</span><span class="s2">\n  </span><span class="s1">return function onceHandler() {</span><span class="s2">\n    </span><span class="s1">var res = fn.apply(null, arguments);</span><span class="s2">\n    </span><span class="s1">if (res !== null) {</span><span class="s2">\n      </span><span class="s1">_target.$off(event, onceHandler);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function updateComponentListeners(vm, listeners, oldListeners) {</span><span class="s2">\n  </span><span class="s1">target$1 = vm;</span><span class="s2">\n  </span><span class="s1">updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);</span><span class="s2">\n  </span><span class="s1">target$1 = undefined;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function eventsMixin(Vue) {</span><span class="s2">\n  </span><span class="s1">var hookRE = /^hook:/;</span><span class="s2">\n  </span><span class="s1">Vue.prototype.$on = function (event, fn) {</span><span class="s2">\n    </span><span class="s1">var vm = this;</span><span class="s2">\n    </span><span class="s1">if (isArray(event)) {</span><span class="s2">\n      </span><span class="s1">for (var i = 0, l = event.length; i &lt; l; i++) {</span><span class="s2">\n        </span><span class="s1">vm.$on(event[i], fn);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">(vm._events[event] || (vm._events[event] = [])).push(fn);</span><span class="s2">\n      </span><span class="s1">// optimize hook:event cost by using a boolean flag marked at registration</span><span class="s2">\n      </span><span class="s1">// instead of a hash lookup</span><span class="s2">\n      </span><span class="s1">if (hookRE.test(event)) {</span><span class="s2">\n        </span><span class="s1">vm._hasHookEvent = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return vm;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">Vue.prototype.$once = function (event, fn) {</span><span class="s2">\n    </span><span class="s1">var vm = this;</span><span class="s2">\n    </span><span class="s1">function on() {</span><span class="s2">\n      </span><span class="s1">vm.$off(event, on);</span><span class="s2">\n      </span><span class="s1">fn.apply(vm, arguments);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">on.fn = fn;</span><span class="s2">\n    </span><span class="s1">vm.$on(event, on);</span><span class="s2">\n    </span><span class="s1">return vm;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">Vue.prototype.$off = function (event, fn) {</span><span class="s2">\n    </span><span class="s1">var vm = this;</span><span class="s2">\n    </span><span class="s1">// all</span><span class="s2">\n    </span><span class="s1">if (!arguments.length) {</span><span class="s2">\n      </span><span class="s1">vm._events = Object.create(null);</span><span class="s2">\n      </span><span class="s1">return vm;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// array of events</span><span class="s2">\n    </span><span class="s1">if (isArray(event)) {</span><span class="s2">\n      </span><span class="s1">for (var i_1 = 0, l = event.length; i_1 &lt; l; i_1++) {</span><span class="s2">\n        </span><span class="s1">vm.$off(event[i_1], fn);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return vm;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// specific event</span><span class="s2">\n    </span><span class="s1">var cbs = vm._events[event];</span><span class="s2">\n    </span><span class="s1">if (!cbs) {</span><span class="s2">\n      </span><span class="s1">return vm;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!fn) {</span><span class="s2">\n      </span><span class="s1">vm._events[event] = null;</span><span class="s2">\n      </span><span class="s1">return vm;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// specific handler</span><span class="s2">\n    </span><span class="s1">var cb;</span><span class="s2">\n    </span><span class="s1">var i = cbs.length;</span><span class="s2">\n    </span><span class="s1">while (i--) {</span><span class="s2">\n      </span><span class="s1">cb = cbs[i];</span><span class="s2">\n      </span><span class="s1">if (cb === fn || cb.fn === fn) {</span><span class="s2">\n        </span><span class="s1">cbs.splice(i, 1);</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return vm;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">Vue.prototype.$emit = function (event) {</span><span class="s2">\n    </span><span class="s1">var vm = this;</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">var lowerCaseEvent = event.toLowerCase();</span><span class="s2">\n      </span><span class="s1">if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) {</span><span class="s2">\n        </span><span class="s1">tip(</span><span class="s2">\&quot;</span><span class="s1">Event </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(lowerCaseEvent, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is emitted in component </span><span class="s2">\&quot;</span><span class="s1">) + </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(formatComponentName(vm), </span><span class="s2">\&quot; </span><span class="s1">but the handler is registered for </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">).concat(event, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">. </span><span class="s2">\&quot;</span><span class="s1">) + </span><span class="s2">\&quot;</span><span class="s1">Note that HTML attributes are case-insensitive and you cannot use </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">v-on to listen to camelCase events when using in-DOM templates. </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">You should probably use </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(hyphenate(event), </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">instead of </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">).concat(event, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var cbs = vm._events[event];</span><span class="s2">\n    </span><span class="s1">if (cbs) {</span><span class="s2">\n      </span><span class="s1">cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs;</span><span class="s2">\n      </span><span class="s1">var args = toArray(arguments, 1);</span><span class="s2">\n      </span><span class="s1">var info = </span><span class="s2">\&quot;</span><span class="s1">event handler for </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(event, </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">for (var i = 0, l = cbs.length; i &lt; l; i++) {</span><span class="s2">\n        </span><span class="s1">invokeWithErrorHandling(cbs[i], vm, args, vm, info);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return vm;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var activeInstance = null;</span><span class="s2">\n</span><span class="s1">var isUpdatingChildComponent = false;</span><span class="s2">\n</span><span class="s1">function setActiveInstance(vm) {</span><span class="s2">\n  </span><span class="s1">var prevActiveInstance = activeInstance;</span><span class="s2">\n  </span><span class="s1">activeInstance = vm;</span><span class="s2">\n  </span><span class="s1">return function () {</span><span class="s2">\n    </span><span class="s1">activeInstance = prevActiveInstance;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initLifecycle(vm) {</span><span class="s2">\n  </span><span class="s1">var options = vm.$options;</span><span class="s2">\n  </span><span class="s1">// locate first non-abstract parent</span><span class="s2">\n  </span><span class="s1">var parent = options.parent;</span><span class="s2">\n  </span><span class="s1">if (parent &amp;&amp; !options.abstract) {</span><span class="s2">\n    </span><span class="s1">while (parent.$options.abstract &amp;&amp; parent.$parent) {</span><span class="s2">\n      </span><span class="s1">parent = parent.$parent;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">parent.$children.push(vm);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">vm.$parent = parent;</span><span class="s2">\n  </span><span class="s1">vm.$root = parent ? parent.$root : vm;</span><span class="s2">\n  </span><span class="s1">vm.$children = [];</span><span class="s2">\n  </span><span class="s1">vm.$refs = {};</span><span class="s2">\n  </span><span class="s1">vm._provided = parent ? parent._provided : Object.create(null);</span><span class="s2">\n  </span><span class="s1">vm._watcher = null;</span><span class="s2">\n  </span><span class="s1">vm._inactive = null;</span><span class="s2">\n  </span><span class="s1">vm._directInactive = false;</span><span class="s2">\n  </span><span class="s1">vm._isMounted = false;</span><span class="s2">\n  </span><span class="s1">vm._isDestroyed = false;</span><span class="s2">\n  </span><span class="s1">vm._isBeingDestroyed = false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function lifecycleMixin(Vue) {</span><span class="s2">\n  </span><span class="s1">Vue.prototype._update = function (vnode, hydrating) {</span><span class="s2">\n    </span><span class="s1">var vm = this;</span><span class="s2">\n    </span><span class="s1">var prevEl = vm.$el;</span><span class="s2">\n    </span><span class="s1">var prevVnode = vm._vnode;</span><span class="s2">\n    </span><span class="s1">var restoreActiveInstance = setActiveInstance(vm);</span><span class="s2">\n    </span><span class="s1">vm._vnode = vnode;</span><span class="s2">\n    </span><span class="s1">// Vue.prototype.__patch__ is injected in entry points</span><span class="s2">\n    </span><span class="s1">// based on the rendering backend used.</span><span class="s2">\n    </span><span class="s1">if (!prevVnode) {</span><span class="s2">\n      </span><span class="s1">// initial render</span><span class="s2">\n      </span><span class="s1">vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">// updates</span><span class="s2">\n      </span><span class="s1">vm.$el = vm.__patch__(prevVnode, vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">restoreActiveInstance();</span><span class="s2">\n    </span><span class="s1">// update __vue__ reference</span><span class="s2">\n    </span><span class="s1">if (prevEl) {</span><span class="s2">\n      </span><span class="s1">prevEl.__vue__ = null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (vm.$el) {</span><span class="s2">\n      </span><span class="s1">vm.$el.__vue__ = vm;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// if parent is an HOC, update its $el as well</span><span class="s2">\n    </span><span class="s1">var wrapper = vm;</span><span class="s2">\n    </span><span class="s1">while (wrapper &amp;&amp; wrapper.$vnode &amp;&amp; wrapper.$parent &amp;&amp; wrapper.$vnode === wrapper.$parent._vnode) {</span><span class="s2">\n      </span><span class="s1">wrapper.$parent.$el = wrapper.$el;</span><span class="s2">\n      </span><span class="s1">wrapper = wrapper.$parent;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// updated hook is called by the scheduler to ensure that children are</span><span class="s2">\n    </span><span class="s1">// updated in a parent's updated hook.</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">Vue.prototype.$forceUpdate = function () {</span><span class="s2">\n    </span><span class="s1">var vm = this;</span><span class="s2">\n    </span><span class="s1">if (vm._watcher) {</span><span class="s2">\n      </span><span class="s1">vm._watcher.update();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">Vue.prototype.$destroy = function () {</span><span class="s2">\n    </span><span class="s1">var vm = this;</span><span class="s2">\n    </span><span class="s1">if (vm._isBeingDestroyed) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">callHook$1(vm, 'beforeDestroy');</span><span class="s2">\n    </span><span class="s1">vm._isBeingDestroyed = true;</span><span class="s2">\n    </span><span class="s1">// remove self from parent</span><span class="s2">\n    </span><span class="s1">var parent = vm.$parent;</span><span class="s2">\n    </span><span class="s1">if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) {</span><span class="s2">\n      </span><span class="s1">remove$2(parent.$children, vm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// teardown scope. this includes both the render watcher and other</span><span class="s2">\n    </span><span class="s1">// watchers created</span><span class="s2">\n    </span><span class="s1">vm._scope.stop();</span><span class="s2">\n    </span><span class="s1">// remove reference from data ob</span><span class="s2">\n    </span><span class="s1">// frozen object may not have observer.</span><span class="s2">\n    </span><span class="s1">if (vm._data.__ob__) {</span><span class="s2">\n      </span><span class="s1">vm._data.__ob__.vmCount--;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// call the last hook...</span><span class="s2">\n    </span><span class="s1">vm._isDestroyed = true;</span><span class="s2">\n    </span><span class="s1">// invoke destroy hooks on current rendered tree</span><span class="s2">\n    </span><span class="s1">vm.__patch__(vm._vnode, null);</span><span class="s2">\n    </span><span class="s1">// fire destroyed hook</span><span class="s2">\n    </span><span class="s1">callHook$1(vm, 'destroyed');</span><span class="s2">\n    </span><span class="s1">// turn off all instance listeners.</span><span class="s2">\n    </span><span class="s1">vm.$off();</span><span class="s2">\n    </span><span class="s1">// remove __vue__ reference</span><span class="s2">\n    </span><span class="s1">if (vm.$el) {</span><span class="s2">\n      </span><span class="s1">vm.$el.__vue__ = null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// release circular reference (#6759)</span><span class="s2">\n    </span><span class="s1">if (vm.$vnode) {</span><span class="s2">\n      </span><span class="s1">vm.$vnode.parent = null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mountComponent(vm, el, hydrating) {</span><span class="s2">\n  </span><span class="s1">vm.$el = el;</span><span class="s2">\n  </span><span class="s1">if (!vm.$options.render) {</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error invalid type</span><span class="s2">\n    </span><span class="s1">vm.$options.render = createEmptyVNode;</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n      </span><span class="s1">if (vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {</span><span class="s2">\n        </span><span class="s1">warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">warn('Failed to mount component: template or render function not defined.', vm);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">callHook$1(vm, 'beforeMount');</span><span class="s2">\n  </span><span class="s1">var updateComponent;</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {</span><span class="s2">\n    </span><span class="s1">updateComponent = function () {</span><span class="s2">\n      </span><span class="s1">var name = vm._name;</span><span class="s2">\n      </span><span class="s1">var id = vm._uid;</span><span class="s2">\n      </span><span class="s1">var startTag = </span><span class="s2">\&quot;</span><span class="s1">vue-perf-start:</span><span class="s2">\&quot;</span><span class="s1">.concat(id);</span><span class="s2">\n      </span><span class="s1">var endTag = </span><span class="s2">\&quot;</span><span class="s1">vue-perf-end:</span><span class="s2">\&quot;</span><span class="s1">.concat(id);</span><span class="s2">\n      </span><span class="s1">mark(startTag);</span><span class="s2">\n      </span><span class="s1">var vnode = vm._render();</span><span class="s2">\n      </span><span class="s1">mark(endTag);</span><span class="s2">\n      </span><span class="s1">measure(</span><span class="s2">\&quot;</span><span class="s1">vue </span><span class="s2">\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot; </span><span class="s1">render</span><span class="s2">\&quot;</span><span class="s1">), startTag, endTag);</span><span class="s2">\n      </span><span class="s1">mark(startTag);</span><span class="s2">\n      </span><span class="s1">vm._update(vnode, hydrating);</span><span class="s2">\n      </span><span class="s1">mark(endTag);</span><span class="s2">\n      </span><span class="s1">measure(</span><span class="s2">\&quot;</span><span class="s1">vue </span><span class="s2">\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot; </span><span class="s1">patch</span><span class="s2">\&quot;</span><span class="s1">), startTag, endTag);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">updateComponent = function () {</span><span class="s2">\n      </span><span class="s1">vm._update(vm._render(), hydrating);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var watcherOptions = {</span><span class="s2">\n    </span><span class="s1">before: function () {</span><span class="s2">\n      </span><span class="s1">if (vm._isMounted &amp;&amp; !vm._isDestroyed) {</span><span class="s2">\n        </span><span class="s1">callHook$1(vm, 'beforeUpdate');</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">watcherOptions.onTrack = function (e) {</span><span class="s2">\n      </span><span class="s1">return callHook$1(vm, 'renderTracked', [e]);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">watcherOptions.onTrigger = function (e) {</span><span class="s2">\n      </span><span class="s1">return callHook$1(vm, 'renderTriggered', [e]);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// we set this to vm._watcher inside the watcher's constructor</span><span class="s2">\n  </span><span class="s1">// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span><span class="s2">\n  </span><span class="s1">// component's mounted hook), which relies on vm._watcher being already defined</span><span class="s2">\n  </span><span class="s1">new Watcher(vm, updateComponent, noop, watcherOptions, true /* isRenderWatcher */);</span><span class="s2">\n  </span><span class="s1">hydrating = false;</span><span class="s2">\n  </span><span class="s1">// flush buffer for flush: </span><span class="s2">\&quot;</span><span class="s1">pre</span><span class="s2">\&quot; </span><span class="s1">watchers queued in setup()</span><span class="s2">\n  </span><span class="s1">var preWatchers = vm._preWatchers;</span><span class="s2">\n  </span><span class="s1">if (preWatchers) {</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; preWatchers.length; i++) {</span><span class="s2">\n      </span><span class="s1">preWatchers[i].run();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// manually mounted instance, call mounted on self</span><span class="s2">\n  </span><span class="s1">// mounted is called for render-created child components in its inserted hook</span><span class="s2">\n  </span><span class="s1">if (vm.$vnode == null) {</span><span class="s2">\n    </span><span class="s1">vm._isMounted = true;</span><span class="s2">\n    </span><span class="s1">callHook$1(vm, 'mounted');</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return vm;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">isUpdatingChildComponent = true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// determine whether component has slot children</span><span class="s2">\n  </span><span class="s1">// we need to do this before overwriting $options._renderChildren.</span><span class="s2">\n  </span><span class="s1">// check if there are dynamic scopedSlots (hand-written or compiled but with</span><span class="s2">\n  </span><span class="s1">// dynamic slot names). Static scoped slots compiled from template has the</span><span class="s2">\n  </span><span class="s1">// </span><span class="s2">\&quot;</span><span class="s1">$stable</span><span class="s2">\&quot; </span><span class="s1">marker.</span><span class="s2">\n  </span><span class="s1">var newScopedSlots = parentVnode.data.scopedSlots;</span><span class="s2">\n  </span><span class="s1">var oldScopedSlots = vm.$scopedSlots;</span><span class="s2">\n  </span><span class="s1">var hasDynamicScopedSlot = !!(newScopedSlots &amp;&amp; !newScopedSlots.$stable || oldScopedSlots !== emptyObject &amp;&amp; !oldScopedSlots.$stable || newScopedSlots &amp;&amp; vm.$scopedSlots.$key !== newScopedSlots.$key || !newScopedSlots &amp;&amp; vm.$scopedSlots.$key);</span><span class="s2">\n  </span><span class="s1">// Any static slot children from the parent may have changed during parent's</span><span class="s2">\n  </span><span class="s1">// update. Dynamic scoped slots may also have changed. In such cases, a forced</span><span class="s2">\n  </span><span class="s1">// update is necessary to ensure correctness.</span><span class="s2">\n  </span><span class="s1">var needsForceUpdate = !!(renderChildren ||</span><span class="s2">\n  </span><span class="s1">// has new static slots</span><span class="s2">\n  </span><span class="s1">vm.$options._renderChildren ||</span><span class="s2">\n  </span><span class="s1">// has old static slots</span><span class="s2">\n  </span><span class="s1">hasDynamicScopedSlot);</span><span class="s2">\n  </span><span class="s1">var prevVNode = vm.$vnode;</span><span class="s2">\n  </span><span class="s1">vm.$options._parentVnode = parentVnode;</span><span class="s2">\n  </span><span class="s1">vm.$vnode = parentVnode; // update vm's placeholder node without re-render</span><span class="s2">\n  </span><span class="s1">if (vm._vnode) {</span><span class="s2">\n    </span><span class="s1">// update child tree's parent</span><span class="s2">\n    </span><span class="s1">vm._vnode.parent = parentVnode;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">vm.$options._renderChildren = renderChildren;</span><span class="s2">\n  </span><span class="s1">// update $attrs and $listeners hash</span><span class="s2">\n  </span><span class="s1">// these are also reactive so they may trigger child update if the child</span><span class="s2">\n  </span><span class="s1">// used them during render</span><span class="s2">\n  </span><span class="s1">var attrs = parentVnode.data.attrs || emptyObject;</span><span class="s2">\n  </span><span class="s1">if (vm._attrsProxy) {</span><span class="s2">\n    </span><span class="s1">// force update if attrs are accessed and has changed since it may be</span><span class="s2">\n    </span><span class="s1">// passed to a child component.</span><span class="s2">\n    </span><span class="s1">if (syncSetupProxy(vm._attrsProxy, attrs, prevVNode.data &amp;&amp; prevVNode.data.attrs || emptyObject, vm, '$attrs')) {</span><span class="s2">\n      </span><span class="s1">needsForceUpdate = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">vm.$attrs = attrs;</span><span class="s2">\n  </span><span class="s1">// update listeners</span><span class="s2">\n  </span><span class="s1">listeners = listeners || emptyObject;</span><span class="s2">\n  </span><span class="s1">var prevListeners = vm.$options._parentListeners;</span><span class="s2">\n  </span><span class="s1">if (vm._listenersProxy) {</span><span class="s2">\n    </span><span class="s1">syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, '$listeners');</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">vm.$listeners = vm.$options._parentListeners = listeners;</span><span class="s2">\n  </span><span class="s1">updateComponentListeners(vm, listeners, prevListeners);</span><span class="s2">\n  </span><span class="s1">// update props</span><span class="s2">\n  </span><span class="s1">if (propsData &amp;&amp; vm.$options.props) {</span><span class="s2">\n    </span><span class="s1">toggleObserving(false);</span><span class="s2">\n    </span><span class="s1">var props = vm._props;</span><span class="s2">\n    </span><span class="s1">var propKeys = vm.$options._propKeys || [];</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; propKeys.length; i++) {</span><span class="s2">\n      </span><span class="s1">var key = propKeys[i];</span><span class="s2">\n      </span><span class="s1">var propOptions = vm.$options.props; // wtf flow?</span><span class="s2">\n      </span><span class="s1">props[key] = validateProp(key, propOptions, propsData, vm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">toggleObserving(true);</span><span class="s2">\n    </span><span class="s1">// keep a copy of raw propsData</span><span class="s2">\n    </span><span class="s1">vm.$options.propsData = propsData;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// resolve slots + force update if has children</span><span class="s2">\n  </span><span class="s1">if (needsForceUpdate) {</span><span class="s2">\n    </span><span class="s1">vm.$slots = resolveSlots(renderChildren, parentVnode.context);</span><span class="s2">\n    </span><span class="s1">vm.$forceUpdate();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">isUpdatingChildComponent = false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isInInactiveTree(vm) {</span><span class="s2">\n  </span><span class="s1">while (vm &amp;&amp; (vm = vm.$parent)) {</span><span class="s2">\n    </span><span class="s1">if (vm._inactive) return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function activateChildComponent(vm, direct) {</span><span class="s2">\n  </span><span class="s1">if (direct) {</span><span class="s2">\n    </span><span class="s1">vm._directInactive = false;</span><span class="s2">\n    </span><span class="s1">if (isInInactiveTree(vm)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (vm._directInactive) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (vm._inactive || vm._inactive === null) {</span><span class="s2">\n    </span><span class="s1">vm._inactive = false;</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; vm.$children.length; i++) {</span><span class="s2">\n      </span><span class="s1">activateChildComponent(vm.$children[i]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">callHook$1(vm, 'activated');</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function deactivateChildComponent(vm, direct) {</span><span class="s2">\n  </span><span class="s1">if (direct) {</span><span class="s2">\n    </span><span class="s1">vm._directInactive = true;</span><span class="s2">\n    </span><span class="s1">if (isInInactiveTree(vm)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!vm._inactive) {</span><span class="s2">\n    </span><span class="s1">vm._inactive = true;</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; vm.$children.length; i++) {</span><span class="s2">\n      </span><span class="s1">deactivateChildComponent(vm.$children[i]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">callHook$1(vm, 'deactivated');</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function callHook$1(vm, hook, args, setContext) {</span><span class="s2">\n  </span><span class="s1">if (setContext === void 0) {</span><span class="s2">\n    </span><span class="s1">setContext = true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// #7573 disable dep collection when invoking lifecycle hooks</span><span class="s2">\n  </span><span class="s1">pushTarget();</span><span class="s2">\n  </span><span class="s1">var prev = currentInstance;</span><span class="s2">\n  </span><span class="s1">setContext &amp;&amp; setCurrentInstance(vm);</span><span class="s2">\n  </span><span class="s1">var handlers = vm.$options[hook];</span><span class="s2">\n  </span><span class="s1">var info = </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(hook, </span><span class="s2">\&quot; </span><span class="s1">hook</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (handlers) {</span><span class="s2">\n    </span><span class="s1">for (var i = 0, j = handlers.length; i &lt; j; i++) {</span><span class="s2">\n      </span><span class="s1">invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (vm._hasHookEvent) {</span><span class="s2">\n    </span><span class="s1">vm.$emit('hook:' + hook);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">setContext &amp;&amp; setCurrentInstance(prev);</span><span class="s2">\n  </span><span class="s1">popTarget();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var MAX_UPDATE_COUNT = 100;</span><span class="s2">\n</span><span class="s1">var queue = [];</span><span class="s2">\n</span><span class="s1">var activatedChildren = [];</span><span class="s2">\n</span><span class="s1">var has = {};</span><span class="s2">\n</span><span class="s1">var circular = {};</span><span class="s2">\n</span><span class="s1">var waiting = false;</span><span class="s2">\n</span><span class="s1">var flushing = false;</span><span class="s2">\n</span><span class="s1">var index = 0;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Reset the scheduler's state.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function resetSchedulerState() {</span><span class="s2">\n  </span><span class="s1">index = queue.length = activatedChildren.length = 0;</span><span class="s2">\n  </span><span class="s1">has = {};</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">circular = {};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">waiting = flushing = false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// Async edge case #6566 requires saving the timestamp when event listeners are</span><span class="s2">\n</span><span class="s1">// attached. However, calling performance.now() has a perf overhead especially</span><span class="s2">\n</span><span class="s1">// if the page has thousands of event listeners. Instead, we take a timestamp</span><span class="s2">\n</span><span class="s1">// every time the scheduler flushes and use that for all event listeners</span><span class="s2">\n</span><span class="s1">// attached during that flush.</span><span class="s2">\n</span><span class="s1">var currentFlushTimestamp = 0;</span><span class="s2">\n</span><span class="s1">// Async edge case fix requires storing an event listener's attach timestamp.</span><span class="s2">\n</span><span class="s1">var getNow = Date.now;</span><span class="s2">\n</span><span class="s1">// Determine what event timestamp the browser is using. Annoyingly, the</span><span class="s2">\n</span><span class="s1">// timestamp can either be hi-res (relative to page load) or low-res</span><span class="s2">\n</span><span class="s1">// (relative to UNIX epoch), so in order to compare time we have to use the</span><span class="s2">\n</span><span class="s1">// same timestamp type when saving the flush timestamp.</span><span class="s2">\n</span><span class="s1">// All IE versions use low-res event timestamps, and have problematic clock</span><span class="s2">\n</span><span class="s1">// implementations (#9632)</span><span class="s2">\n</span><span class="s1">if (inBrowser &amp;&amp; !isIE) {</span><span class="s2">\n  </span><span class="s1">var performance_1 = window.performance;</span><span class="s2">\n  </span><span class="s1">if (performance_1 &amp;&amp; typeof performance_1.now === 'function' &amp;&amp; getNow() &gt; document.createEvent('Event').timeStamp) {</span><span class="s2">\n    </span><span class="s1">// if the event timestamp, although evaluated AFTER the Date.now(), is</span><span class="s2">\n    </span><span class="s1">// smaller than it, it means the event is using a hi-res timestamp,</span><span class="s2">\n    </span><span class="s1">// and we need to use the hi-res version for event listener timestamps as</span><span class="s2">\n    </span><span class="s1">// well.</span><span class="s2">\n    </span><span class="s1">getNow = function () {</span><span class="s2">\n      </span><span class="s1">return performance_1.now();</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var sortCompareFn = function (a, b) {</span><span class="s2">\n  </span><span class="s1">if (a.post) {</span><span class="s2">\n    </span><span class="s1">if (!b.post) return 1;</span><span class="s2">\n  </span><span class="s1">} else if (b.post) {</span><span class="s2">\n    </span><span class="s1">return -1;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return a.id - b.id;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Flush both queues and run the watchers.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function flushSchedulerQueue() {</span><span class="s2">\n  </span><span class="s1">currentFlushTimestamp = getNow();</span><span class="s2">\n  </span><span class="s1">flushing = true;</span><span class="s2">\n  </span><span class="s1">var watcher, id;</span><span class="s2">\n  </span><span class="s1">// Sort queue before flush.</span><span class="s2">\n  </span><span class="s1">// This ensures that:</span><span class="s2">\n  </span><span class="s1">// 1. Components are updated from parent to child. (because parent is always</span><span class="s2">\n  </span><span class="s1">//    created before the child)</span><span class="s2">\n  </span><span class="s1">// 2. A component's user watchers are run before its render watcher (because</span><span class="s2">\n  </span><span class="s1">//    user watchers are created before the render watcher)</span><span class="s2">\n  </span><span class="s1">// 3. If a component is destroyed during a parent component's watcher run,</span><span class="s2">\n  </span><span class="s1">//    its watchers can be skipped.</span><span class="s2">\n  </span><span class="s1">queue.sort(sortCompareFn);</span><span class="s2">\n  </span><span class="s1">// do not cache length because more watchers might be pushed</span><span class="s2">\n  </span><span class="s1">// as we run existing watchers</span><span class="s2">\n  </span><span class="s1">for (index = 0; index &lt; queue.length; index++) {</span><span class="s2">\n    </span><span class="s1">watcher = queue[index];</span><span class="s2">\n    </span><span class="s1">if (watcher.before) {</span><span class="s2">\n      </span><span class="s1">watcher.before();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">id = watcher.id;</span><span class="s2">\n    </span><span class="s1">has[id] = null;</span><span class="s2">\n    </span><span class="s1">watcher.run();</span><span class="s2">\n    </span><span class="s1">// in dev build, check and stop circular updates.</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; has[id] != null) {</span><span class="s2">\n      </span><span class="s1">circular[id] = (circular[id] || 0) + 1;</span><span class="s2">\n      </span><span class="s1">if (circular[id] &gt; MAX_UPDATE_COUNT) {</span><span class="s2">\n        </span><span class="s1">warn('You may have an infinite update loop ' + (watcher.user ? </span><span class="s2">\&quot;</span><span class="s1">in watcher with expression </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(watcher.expression, </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">) : </span><span class="s2">\&quot;</span><span class="s1">in a component render function.</span><span class="s2">\&quot;</span><span class="s1">), watcher.vm);</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// keep copies of post queues before resetting state</span><span class="s2">\n  </span><span class="s1">var activatedQueue = activatedChildren.slice();</span><span class="s2">\n  </span><span class="s1">var updatedQueue = queue.slice();</span><span class="s2">\n  </span><span class="s1">resetSchedulerState();</span><span class="s2">\n  </span><span class="s1">// call component updated and activated hooks</span><span class="s2">\n  </span><span class="s1">callActivatedHooks(activatedQueue);</span><span class="s2">\n  </span><span class="s1">callUpdatedHooks(updatedQueue);</span><span class="s2">\n  </span><span class="s1">cleanupDeps();</span><span class="s2">\n  </span><span class="s1">// devtool hook</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (devtools &amp;&amp; config.devtools) {</span><span class="s2">\n    </span><span class="s1">devtools.emit('flush');</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function callUpdatedHooks(queue) {</span><span class="s2">\n  </span><span class="s1">var i = queue.length;</span><span class="s2">\n  </span><span class="s1">while (i--) {</span><span class="s2">\n    </span><span class="s1">var watcher = queue[i];</span><span class="s2">\n    </span><span class="s1">var vm = watcher.vm;</span><span class="s2">\n    </span><span class="s1">if (vm &amp;&amp; vm._watcher === watcher &amp;&amp; vm._isMounted &amp;&amp; !vm._isDestroyed) {</span><span class="s2">\n      </span><span class="s1">callHook$1(vm, 'updated');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Queue a kept-alive component that was activated during patch.</span><span class="s2">\n </span><span class="s1">* The queue will be processed after the entire tree has been patched.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function queueActivatedComponent(vm) {</span><span class="s2">\n  </span><span class="s1">// setting _inactive to false here so that a render function can</span><span class="s2">\n  </span><span class="s1">// rely on checking whether it's in an inactive tree (e.g. router-view)</span><span class="s2">\n  </span><span class="s1">vm._inactive = false;</span><span class="s2">\n  </span><span class="s1">activatedChildren.push(vm);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function callActivatedHooks(queue) {</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; queue.length; i++) {</span><span class="s2">\n    </span><span class="s1">queue[i]._inactive = true;</span><span class="s2">\n    </span><span class="s1">activateChildComponent(queue[i], true /* true */);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Push a watcher into the watcher queue.</span><span class="s2">\n </span><span class="s1">* Jobs with duplicate IDs will be skipped unless it's</span><span class="s2">\n </span><span class="s1">* pushed when the queue is being flushed.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function queueWatcher(watcher) {</span><span class="s2">\n  </span><span class="s1">var id = watcher.id;</span><span class="s2">\n  </span><span class="s1">if (has[id] != null) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (watcher === Dep.target &amp;&amp; watcher.noRecurse) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">has[id] = true;</span><span class="s2">\n  </span><span class="s1">if (!flushing) {</span><span class="s2">\n    </span><span class="s1">queue.push(watcher);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">// if already flushing, splice the watcher based on its id</span><span class="s2">\n    </span><span class="s1">// if already past its id, it will be run next immediately.</span><span class="s2">\n    </span><span class="s1">var i = queue.length - 1;</span><span class="s2">\n    </span><span class="s1">while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) {</span><span class="s2">\n      </span><span class="s1">i--;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">queue.splice(i + 1, 0, watcher);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// queue the flush</span><span class="s2">\n  </span><span class="s1">if (!waiting) {</span><span class="s2">\n    </span><span class="s1">waiting = true;</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) {</span><span class="s2">\n      </span><span class="s1">flushSchedulerQueue();</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">nextTick(flushSchedulerQueue);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initProvide(vm) {</span><span class="s2">\n  </span><span class="s1">var provideOption = vm.$options.provide;</span><span class="s2">\n  </span><span class="s1">if (provideOption) {</span><span class="s2">\n    </span><span class="s1">var provided = isFunction(provideOption) ? provideOption.call(vm) : provideOption;</span><span class="s2">\n    </span><span class="s1">if (!isObject(provided)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var source = resolveProvided(vm);</span><span class="s2">\n    </span><span class="s1">// IE9 doesn't support Object.getOwnPropertyDescriptors so we have to</span><span class="s2">\n    </span><span class="s1">// iterate the keys ourselves.</span><span class="s2">\n    </span><span class="s1">var keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; keys.length; i++) {</span><span class="s2">\n      </span><span class="s1">var key = keys[i];</span><span class="s2">\n      </span><span class="s1">Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initInjections(vm) {</span><span class="s2">\n  </span><span class="s1">var result = resolveInject(vm.$options.inject, vm);</span><span class="s2">\n  </span><span class="s1">if (result) {</span><span class="s2">\n    </span><span class="s1">toggleObserving(false);</span><span class="s2">\n    </span><span class="s1">Object.keys(result).forEach(function (key) {</span><span class="s2">\n      </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">defineReactive(vm, key, result[key], function () {</span><span class="s2">\n          </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Avoid mutating an injected value directly since the changes will be </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">overwritten whenever the provided component re-renders. </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">injection being mutated: </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">), vm);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">defineReactive(vm, key, result[key]);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">toggleObserving(true);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveInject(inject, vm) {</span><span class="s2">\n  </span><span class="s1">if (inject) {</span><span class="s2">\n    </span><span class="s1">// inject is :any because flow is not smart enough to figure out cached</span><span class="s2">\n    </span><span class="s1">var result = Object.create(null);</span><span class="s2">\n    </span><span class="s1">var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; keys.length; i++) {</span><span class="s2">\n      </span><span class="s1">var key = keys[i];</span><span class="s2">\n      </span><span class="s1">// #6574 in case the inject object is observed...</span><span class="s2">\n      </span><span class="s1">if (key === '__ob__') continue;</span><span class="s2">\n      </span><span class="s1">var provideKey = inject[key].from;</span><span class="s2">\n      </span><span class="s1">if (provideKey in vm._provided) {</span><span class="s2">\n        </span><span class="s1">result[key] = vm._provided[provideKey];</span><span class="s2">\n      </span><span class="s1">} else if ('default' in inject[key]) {</span><span class="s2">\n        </span><span class="s1">var provideDefault = inject[key].default;</span><span class="s2">\n        </span><span class="s1">result[key] = isFunction(provideDefault) ? provideDefault.call(vm) : provideDefault;</span><span class="s2">\n      </span><span class="s1">} else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Injection </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">not found</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return result;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function FunctionalRenderContext(data, props, children, parent, Ctor) {</span><span class="s2">\n  </span><span class="s1">var _this = this;</span><span class="s2">\n  </span><span class="s1">var options = Ctor.options;</span><span class="s2">\n  </span><span class="s1">// ensure the createElement function in functional components</span><span class="s2">\n  </span><span class="s1">// gets a unique context - this is necessary for correct named slot check</span><span class="s2">\n  </span><span class="s1">var contextVm;</span><span class="s2">\n  </span><span class="s1">if (hasOwn(parent, '_uid')) {</span><span class="s2">\n    </span><span class="s1">contextVm = Object.create(parent);</span><span class="s2">\n    </span><span class="s1">contextVm._original = parent;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">// the context vm passed in is a functional context as well.</span><span class="s2">\n    </span><span class="s1">// in this case we want to make sure we are able to get a hold to the</span><span class="s2">\n    </span><span class="s1">// real context instance.</span><span class="s2">\n    </span><span class="s1">contextVm = parent;</span><span class="s2">\n    </span><span class="s1">// @ts-ignore</span><span class="s2">\n    </span><span class="s1">parent = parent._original;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var isCompiled = isTrue(options._compiled);</span><span class="s2">\n  </span><span class="s1">var needNormalization = !isCompiled;</span><span class="s2">\n  </span><span class="s1">this.data = data;</span><span class="s2">\n  </span><span class="s1">this.props = props;</span><span class="s2">\n  </span><span class="s1">this.children = children;</span><span class="s2">\n  </span><span class="s1">this.parent = parent;</span><span class="s2">\n  </span><span class="s1">this.listeners = data.on || emptyObject;</span><span class="s2">\n  </span><span class="s1">this.injections = resolveInject(options.inject, parent);</span><span class="s2">\n  </span><span class="s1">this.slots = function () {</span><span class="s2">\n    </span><span class="s1">if (!_this.$slots) {</span><span class="s2">\n      </span><span class="s1">normalizeScopedSlots(parent, data.scopedSlots, _this.$slots = resolveSlots(children, parent));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return _this.$slots;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">Object.defineProperty(this, 'scopedSlots', {</span><span class="s2">\n    </span><span class="s1">enumerable: true,</span><span class="s2">\n    </span><span class="s1">get: function () {</span><span class="s2">\n      </span><span class="s1">return normalizeScopedSlots(parent, data.scopedSlots, this.slots());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">// support for compiled functional template</span><span class="s2">\n  </span><span class="s1">if (isCompiled) {</span><span class="s2">\n    </span><span class="s1">// exposing $options for renderStatic()</span><span class="s2">\n    </span><span class="s1">this.$options = options;</span><span class="s2">\n    </span><span class="s1">// pre-resolve slots for renderSlot()</span><span class="s2">\n    </span><span class="s1">this.$slots = this.slots();</span><span class="s2">\n    </span><span class="s1">this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (options._scopeId) {</span><span class="s2">\n    </span><span class="s1">this._c = function (a, b, c, d) {</span><span class="s2">\n      </span><span class="s1">var vnode = createElement$1(contextVm, a, b, c, d, needNormalization);</span><span class="s2">\n      </span><span class="s1">if (vnode &amp;&amp; !isArray(vnode)) {</span><span class="s2">\n        </span><span class="s1">vnode.fnScopeId = options._scopeId;</span><span class="s2">\n        </span><span class="s1">vnode.fnContext = parent;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return vnode;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">this._c = function (a, b, c, d) {</span><span class="s2">\n      </span><span class="s1">return createElement$1(contextVm, a, b, c, d, needNormalization);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">installRenderHelpers(FunctionalRenderContext.prototype);</span><span class="s2">\n</span><span class="s1">function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {</span><span class="s2">\n  </span><span class="s1">var options = Ctor.options;</span><span class="s2">\n  </span><span class="s1">var props = {};</span><span class="s2">\n  </span><span class="s1">var propOptions = options.props;</span><span class="s2">\n  </span><span class="s1">if (isDef(propOptions)) {</span><span class="s2">\n    </span><span class="s1">for (var key in propOptions) {</span><span class="s2">\n      </span><span class="s1">props[key] = validateProp(key, propOptions, propsData || emptyObject);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">if (isDef(data.attrs)) mergeProps(props, data.attrs);</span><span class="s2">\n    </span><span class="s1">if (isDef(data.props)) mergeProps(props, data.props);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);</span><span class="s2">\n  </span><span class="s1">var vnode = options.render.call(null, renderContext._c, renderContext);</span><span class="s2">\n  </span><span class="s1">if (vnode instanceof VNode) {</span><span class="s2">\n    </span><span class="s1">return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);</span><span class="s2">\n  </span><span class="s1">} else if (isArray(vnode)) {</span><span class="s2">\n    </span><span class="s1">var vnodes = normalizeChildren(vnode) || [];</span><span class="s2">\n    </span><span class="s1">var res = new Array(vnodes.length);</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; vnodes.length; i++) {</span><span class="s2">\n      </span><span class="s1">res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {</span><span class="s2">\n  </span><span class="s1">// #7817 clone node before setting fnContext, otherwise if the node is reused</span><span class="s2">\n  </span><span class="s1">// (e.g. it was from a cached normal slot) the fnContext causes named slots</span><span class="s2">\n  </span><span class="s1">// that should not be matched to match.</span><span class="s2">\n  </span><span class="s1">var clone = cloneVNode(vnode);</span><span class="s2">\n  </span><span class="s1">clone.fnContext = contextVm;</span><span class="s2">\n  </span><span class="s1">clone.fnOptions = options;</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">(clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (data.slot) {</span><span class="s2">\n    </span><span class="s1">(clone.data || (clone.data = {})).slot = data.slot;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return clone;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mergeProps(to, from) {</span><span class="s2">\n  </span><span class="s1">for (var key in from) {</span><span class="s2">\n    </span><span class="s1">to[camelize(key)] = from[key];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getComponentName(options) {</span><span class="s2">\n  </span><span class="s1">return options.name || options.__name || options._componentTag;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// inline hooks to be invoked on component VNodes during patch</span><span class="s2">\n</span><span class="s1">var componentVNodeHooks = {</span><span class="s2">\n  </span><span class="s1">init: function (vnode, hydrating) {</span><span class="s2">\n    </span><span class="s1">if (vnode.componentInstance &amp;&amp; !vnode.componentInstance._isDestroyed &amp;&amp; vnode.data.keepAlive) {</span><span class="s2">\n      </span><span class="s1">// kept-alive components, treat as a patch</span><span class="s2">\n      </span><span class="s1">var mountedNode = vnode; // work around flow</span><span class="s2">\n      </span><span class="s1">componentVNodeHooks.prepatch(mountedNode, mountedNode);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);</span><span class="s2">\n      </span><span class="s1">child.$mount(hydrating ? vnode.elm : undefined, hydrating);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">prepatch: function (oldVnode, vnode) {</span><span class="s2">\n    </span><span class="s1">var options = vnode.componentOptions;</span><span class="s2">\n    </span><span class="s1">var child = vnode.componentInstance = oldVnode.componentInstance;</span><span class="s2">\n    </span><span class="s1">updateChildComponent(child, options.propsData,</span><span class="s2">\n    </span><span class="s1">// updated props</span><span class="s2">\n    </span><span class="s1">options.listeners,</span><span class="s2">\n    </span><span class="s1">// updated listeners</span><span class="s2">\n    </span><span class="s1">vnode,</span><span class="s2">\n    </span><span class="s1">// new parent vnode</span><span class="s2">\n    </span><span class="s1">options.children // new children</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n\n  </span><span class="s1">insert: function (vnode) {</span><span class="s2">\n    </span><span class="s1">var context = vnode.context,</span><span class="s2">\n      </span><span class="s1">componentInstance = vnode.componentInstance;</span><span class="s2">\n    </span><span class="s1">if (!componentInstance._isMounted) {</span><span class="s2">\n      </span><span class="s1">componentInstance._isMounted = true;</span><span class="s2">\n      </span><span class="s1">callHook$1(componentInstance, 'mounted');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (vnode.data.keepAlive) {</span><span class="s2">\n      </span><span class="s1">if (context._isMounted) {</span><span class="s2">\n        </span><span class="s1">// vue-router#1212</span><span class="s2">\n        </span><span class="s1">// During updates, a kept-alive component's child components may</span><span class="s2">\n        </span><span class="s1">// change, so directly walking the tree here may call activated hooks</span><span class="s2">\n        </span><span class="s1">// on incorrect children. Instead we push them into a queue which will</span><span class="s2">\n        </span><span class="s1">// be processed after the whole patch process ended.</span><span class="s2">\n        </span><span class="s1">queueActivatedComponent(componentInstance);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">activateChildComponent(componentInstance, true /* direct */);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n\n  </span><span class="s1">destroy: function (vnode) {</span><span class="s2">\n    </span><span class="s1">var componentInstance = vnode.componentInstance;</span><span class="s2">\n    </span><span class="s1">if (!componentInstance._isDestroyed) {</span><span class="s2">\n      </span><span class="s1">if (!vnode.data.keepAlive) {</span><span class="s2">\n        </span><span class="s1">componentInstance.$destroy();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">deactivateChildComponent(componentInstance, true /* direct */);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">var hooksToMerge = Object.keys(componentVNodeHooks);</span><span class="s2">\n</span><span class="s1">function createComponent(Ctor, data, context, children, tag) {</span><span class="s2">\n  </span><span class="s1">if (isUndef(Ctor)) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var baseCtor = context.$options._base;</span><span class="s2">\n  </span><span class="s1">// plain options object: turn it into a constructor</span><span class="s2">\n  </span><span class="s1">if (isObject(Ctor)) {</span><span class="s2">\n    </span><span class="s1">Ctor = baseCtor.extend(Ctor);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// if at this stage it's not a constructor or an async component factory,</span><span class="s2">\n  </span><span class="s1">// reject.</span><span class="s2">\n  </span><span class="s1">if (typeof Ctor !== 'function') {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Invalid Component definition: </span><span class="s2">\&quot;</span><span class="s1">.concat(String(Ctor)), context);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// async component</span><span class="s2">\n  </span><span class="s1">var asyncFactory;</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error</span><span class="s2">\n  </span><span class="s1">if (isUndef(Ctor.cid)) {</span><span class="s2">\n    </span><span class="s1">asyncFactory = Ctor;</span><span class="s2">\n    </span><span class="s1">Ctor = resolveAsyncComponent(asyncFactory, baseCtor);</span><span class="s2">\n    </span><span class="s1">if (Ctor === undefined) {</span><span class="s2">\n      </span><span class="s1">// return a placeholder node for async component, which is rendered</span><span class="s2">\n      </span><span class="s1">// as a comment node but preserves all the raw information for the node.</span><span class="s2">\n      </span><span class="s1">// the information will be used for async server-rendering and hydration.</span><span class="s2">\n      </span><span class="s1">return createAsyncPlaceholder(asyncFactory, data, context, children, tag);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">data = data || {};</span><span class="s2">\n  </span><span class="s1">// resolve constructor options in case global mixins are applied after</span><span class="s2">\n  </span><span class="s1">// component constructor creation</span><span class="s2">\n  </span><span class="s1">resolveConstructorOptions(Ctor);</span><span class="s2">\n  </span><span class="s1">// transform component v-model data into props &amp; events</span><span class="s2">\n  </span><span class="s1">if (isDef(data.model)) {</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">transformModel(Ctor.options, data);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// extract props</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error</span><span class="s2">\n  </span><span class="s1">var propsData = extractPropsFromVNodeData(data, Ctor, tag);</span><span class="s2">\n  </span><span class="s1">// functional component</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error</span><span class="s2">\n  </span><span class="s1">if (isTrue(Ctor.options.functional)) {</span><span class="s2">\n    </span><span class="s1">return createFunctionalComponent(Ctor, propsData, data, context, children);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// extract listeners, since these needs to be treated as</span><span class="s2">\n  </span><span class="s1">// child component listeners instead of DOM listeners</span><span class="s2">\n  </span><span class="s1">var listeners = data.on;</span><span class="s2">\n  </span><span class="s1">// replace with listeners with .native modifier</span><span class="s2">\n  </span><span class="s1">// so it gets processed during parent component patch.</span><span class="s2">\n  </span><span class="s1">data.on = data.nativeOn;</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error</span><span class="s2">\n  </span><span class="s1">if (isTrue(Ctor.options.abstract)) {</span><span class="s2">\n    </span><span class="s1">// abstract components do not keep anything</span><span class="s2">\n    </span><span class="s1">// other than props &amp; listeners &amp; slot</span><span class="s2">\n    </span><span class="s1">// work around flow</span><span class="s2">\n    </span><span class="s1">var slot = data.slot;</span><span class="s2">\n    </span><span class="s1">data = {};</span><span class="s2">\n    </span><span class="s1">if (slot) {</span><span class="s2">\n      </span><span class="s1">data.slot = slot;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// install component management hooks onto the placeholder node</span><span class="s2">\n  </span><span class="s1">installComponentHooks(data);</span><span class="s2">\n  </span><span class="s1">// return a placeholder vnode</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error</span><span class="s2">\n  </span><span class="s1">var name = getComponentName(Ctor.options) || tag;</span><span class="s2">\n  </span><span class="s1">var vnode = new VNode(</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error</span><span class="s2">\n  \&quot;</span><span class="s1">vue-component-</span><span class="s2">\&quot;</span><span class="s1">.concat(Ctor.cid).concat(name ? </span><span class="s2">\&quot;</span><span class="s1">-</span><span class="s2">\&quot;</span><span class="s1">.concat(name) : ''), data, undefined, undefined, undefined, context,</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error</span><span class="s2">\n  </span><span class="s1">{</span><span class="s2">\n    </span><span class="s1">Ctor: Ctor,</span><span class="s2">\n    </span><span class="s1">propsData: propsData,</span><span class="s2">\n    </span><span class="s1">listeners: listeners,</span><span class="s2">\n    </span><span class="s1">tag: tag,</span><span class="s2">\n    </span><span class="s1">children: children</span><span class="s2">\n  </span><span class="s1">}, asyncFactory);</span><span class="s2">\n  </span><span class="s1">return vnode;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createComponentInstanceForVnode(</span><span class="s2">\n</span><span class="s1">// we know it's MountedComponentVNode but flow doesn't</span><span class="s2">\n</span><span class="s1">vnode,</span><span class="s2">\n</span><span class="s1">// activeInstance in lifecycle state</span><span class="s2">\n</span><span class="s1">parent) {</span><span class="s2">\n  </span><span class="s1">var options = {</span><span class="s2">\n    </span><span class="s1">_isComponent: true,</span><span class="s2">\n    </span><span class="s1">_parentVnode: vnode,</span><span class="s2">\n    </span><span class="s1">parent: parent</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">// check inline-template render functions</span><span class="s2">\n  </span><span class="s1">var inlineTemplate = vnode.data.inlineTemplate;</span><span class="s2">\n  </span><span class="s1">if (isDef(inlineTemplate)) {</span><span class="s2">\n    </span><span class="s1">options.render = inlineTemplate.render;</span><span class="s2">\n    </span><span class="s1">options.staticRenderFns = inlineTemplate.staticRenderFns;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return new vnode.componentOptions.Ctor(options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function installComponentHooks(data) {</span><span class="s2">\n  </span><span class="s1">var hooks = data.hook || (data.hook = {});</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; hooksToMerge.length; i++) {</span><span class="s2">\n    </span><span class="s1">var key = hooksToMerge[i];</span><span class="s2">\n    </span><span class="s1">var existing = hooks[key];</span><span class="s2">\n    </span><span class="s1">var toMerge = componentVNodeHooks[key];</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">if (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) {</span><span class="s2">\n      </span><span class="s1">hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mergeHook(f1, f2) {</span><span class="s2">\n  </span><span class="s1">var merged = function (a, b) {</span><span class="s2">\n    </span><span class="s1">// flow complains about extra args which is why we use any</span><span class="s2">\n    </span><span class="s1">f1(a, b);</span><span class="s2">\n    </span><span class="s1">f2(a, b);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">merged._merged = true;</span><span class="s2">\n  </span><span class="s1">return merged;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// transform component v-model info (value and callback) into</span><span class="s2">\n</span><span class="s1">// prop and event handler respectively.</span><span class="s2">\n</span><span class="s1">function transformModel(options, data) {</span><span class="s2">\n  </span><span class="s1">var prop = options.model &amp;&amp; options.model.prop || 'value';</span><span class="s2">\n  </span><span class="s1">var event = options.model &amp;&amp; options.model.event || 'input';</span><span class="s2">\n  </span><span class="s1">(data.attrs || (data.attrs = {}))[prop] = data.model.value;</span><span class="s2">\n  </span><span class="s1">var on = data.on || (data.on = {});</span><span class="s2">\n  </span><span class="s1">var existing = on[event];</span><span class="s2">\n  </span><span class="s1">var callback = data.model.callback;</span><span class="s2">\n  </span><span class="s1">if (isDef(existing)) {</span><span class="s2">\n    </span><span class="s1">if (isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {</span><span class="s2">\n      </span><span class="s1">on[event] = [callback].concat(existing);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">on[event] = callback;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var warn = noop;</span><span class="s2">\n</span><span class="s1">var tip = noop;</span><span class="s2">\n</span><span class="s1">var generateComponentTrace; // work around flow check</span><span class="s2">\n</span><span class="s1">var formatComponentName;</span><span class="s2">\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n  </span><span class="s1">var hasConsole_1 = typeof console !== 'undefined';</span><span class="s2">\n  </span><span class="s1">var classifyRE_1 = /(?:^|[-_])(</span><span class="s2">\\</span><span class="s1">w)/g;</span><span class="s2">\n  </span><span class="s1">var classify_1 = function (str) {</span><span class="s2">\n    </span><span class="s1">return str.replace(classifyRE_1, function (c) {</span><span class="s2">\n      </span><span class="s1">return c.toUpperCase();</span><span class="s2">\n    </span><span class="s1">}).replace(/[-_]/g, '');</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">warn = function (msg, vm) {</span><span class="s2">\n    </span><span class="s1">if (vm === void 0) {</span><span class="s2">\n      </span><span class="s1">vm = currentInstance;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var trace = vm ? generateComponentTrace(vm) : '';</span><span class="s2">\n    </span><span class="s1">if (config.warnHandler) {</span><span class="s2">\n      </span><span class="s1">config.warnHandler.call(null, msg, vm, trace);</span><span class="s2">\n    </span><span class="s1">} else if (hasConsole_1 &amp;&amp; !config.silent) {</span><span class="s2">\n      </span><span class="s1">console.error(</span><span class="s2">\&quot;</span><span class="s1">[Vue warn]: </span><span class="s2">\&quot;</span><span class="s1">.concat(msg).concat(trace));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">tip = function (msg, vm) {</span><span class="s2">\n    </span><span class="s1">if (hasConsole_1 &amp;&amp; !config.silent) {</span><span class="s2">\n      </span><span class="s1">console.warn(</span><span class="s2">\&quot;</span><span class="s1">[Vue tip]: </span><span class="s2">\&quot;</span><span class="s1">.concat(msg) + (vm ? generateComponentTrace(vm) : ''));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">formatComponentName = function (vm, includeFile) {</span><span class="s2">\n    </span><span class="s1">if (vm.$root === vm) {</span><span class="s2">\n      </span><span class="s1">return '&lt;Root&gt;';</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var options = isFunction(vm) &amp;&amp; vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;</span><span class="s2">\n    </span><span class="s1">var name = getComponentName(options);</span><span class="s2">\n    </span><span class="s1">var file = options.__file;</span><span class="s2">\n    </span><span class="s1">if (!name &amp;&amp; file) {</span><span class="s2">\n      </span><span class="s1">var match = file.match(/([^/</span><span class="s2">\\\\</span><span class="s1">]+)</span><span class="s2">\\</span><span class="s1">.vue$/);</span><span class="s2">\n      </span><span class="s1">name = match &amp;&amp; match[1];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return (name ? </span><span class="s2">\&quot;</span><span class="s1">&lt;</span><span class="s2">\&quot;</span><span class="s1">.concat(classify_1(name), </span><span class="s2">\&quot;</span><span class="s1">&gt;</span><span class="s2">\&quot;</span><span class="s1">) : </span><span class="s2">\&quot;</span><span class="s1">&lt;Anonymous&gt;</span><span class="s2">\&quot;</span><span class="s1">) + (file &amp;&amp; includeFile !== false ? </span><span class="s2">\&quot; </span><span class="s1">at </span><span class="s2">\&quot;</span><span class="s1">.concat(file) : '');</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">var repeat_1 = function (str, n) {</span><span class="s2">\n    </span><span class="s1">var res = '';</span><span class="s2">\n    </span><span class="s1">while (n) {</span><span class="s2">\n      </span><span class="s1">if (n % 2 === 1) res += str;</span><span class="s2">\n      </span><span class="s1">if (n &gt; 1) str += str;</span><span class="s2">\n      </span><span class="s1">n &gt;&gt;= 1;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">generateComponentTrace = function (vm) {</span><span class="s2">\n    </span><span class="s1">if (vm._isVue &amp;&amp; vm.$parent) {</span><span class="s2">\n      </span><span class="s1">var tree = [];</span><span class="s2">\n      </span><span class="s1">var currentRecursiveSequence = 0;</span><span class="s2">\n      </span><span class="s1">while (vm) {</span><span class="s2">\n        </span><span class="s1">if (tree.length &gt; 0) {</span><span class="s2">\n          </span><span class="s1">var last = tree[tree.length - 1];</span><span class="s2">\n          </span><span class="s1">if (last.constructor === vm.constructor) {</span><span class="s2">\n            </span><span class="s1">currentRecursiveSequence++;</span><span class="s2">\n            </span><span class="s1">vm = vm.$parent;</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">} else if (currentRecursiveSequence &gt; 0) {</span><span class="s2">\n            </span><span class="s1">tree[tree.length - 1] = [last, currentRecursiveSequence];</span><span class="s2">\n            </span><span class="s1">currentRecursiveSequence = 0;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">tree.push(vm);</span><span class="s2">\n        </span><span class="s1">vm = vm.$parent;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return '</span><span class="s2">\\</span><span class="s1">n</span><span class="s2">\\</span><span class="s1">nfound in</span><span class="s2">\\</span><span class="s1">n</span><span class="s2">\\</span><span class="s1">n' + tree.map(function (vm, i) {</span><span class="s2">\n        </span><span class="s1">return </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(i === 0 ? '---&gt; ' : repeat_1(' ', 5 + i * 2)).concat(isArray(vm) ? </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(formatComponentName(vm[0]), </span><span class="s2">\&quot;</span><span class="s1">... (</span><span class="s2">\&quot;</span><span class="s1">).concat(vm[1], </span><span class="s2">\&quot; </span><span class="s1">recursive calls)</span><span class="s2">\&quot;</span><span class="s1">) : formatComponentName(vm));</span><span class="s2">\n      </span><span class="s1">}).join('</span><span class="s2">\\</span><span class="s1">n');</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">return </span><span class="s2">\&quot;\\</span><span class="s1">n</span><span class="s2">\\</span><span class="s1">n(found in </span><span class="s2">\&quot;</span><span class="s1">.concat(formatComponentName(vm), </span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Option overwriting strategies are functions that handle</span><span class="s2">\n </span><span class="s1">* how to merge a parent option value and a child option</span><span class="s2">\n </span><span class="s1">* value into the final value.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var strats = config.optionMergeStrategies;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Options with restrictions</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n  </span><span class="s1">strats.el = strats.propsData = function (parent, child, vm, key) {</span><span class="s2">\n    </span><span class="s1">if (!vm) {</span><span class="s2">\n      </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">option </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">can only be used during instance </span><span class="s2">\&quot;</span><span class="s1">) + 'creation with the `new` keyword.');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return defaultStrat(parent, child);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Helper that recursively merges two data objects together.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function mergeData(to, from, recursive) {</span><span class="s2">\n  </span><span class="s1">if (recursive === void 0) {</span><span class="s2">\n    </span><span class="s1">recursive = true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!from) return to;</span><span class="s2">\n  </span><span class="s1">var key, toVal, fromVal;</span><span class="s2">\n  </span><span class="s1">var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; keys.length; i++) {</span><span class="s2">\n    </span><span class="s1">key = keys[i];</span><span class="s2">\n    </span><span class="s1">// in case the object is already observed...</span><span class="s2">\n    </span><span class="s1">if (key === '__ob__') continue;</span><span class="s2">\n    </span><span class="s1">toVal = to[key];</span><span class="s2">\n    </span><span class="s1">fromVal = from[key];</span><span class="s2">\n    </span><span class="s1">if (!recursive || !hasOwn(to, key)) {</span><span class="s2">\n      </span><span class="s1">set(to, key, fromVal);</span><span class="s2">\n    </span><span class="s1">} else if (toVal !== fromVal &amp;&amp; isPlainObject(toVal) &amp;&amp; isPlainObject(fromVal)) {</span><span class="s2">\n      </span><span class="s1">mergeData(toVal, fromVal);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return to;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Data</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function mergeDataOrFn(parentVal, childVal, vm) {</span><span class="s2">\n  </span><span class="s1">if (!vm) {</span><span class="s2">\n    </span><span class="s1">// in a Vue.extend merge, both should be functions</span><span class="s2">\n    </span><span class="s1">if (!childVal) {</span><span class="s2">\n      </span><span class="s1">return parentVal;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!parentVal) {</span><span class="s2">\n      </span><span class="s1">return childVal;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// when parentVal &amp; childVal are both present,</span><span class="s2">\n    </span><span class="s1">// we need to return a function that returns the</span><span class="s2">\n    </span><span class="s1">// merged result of both functions... no need to</span><span class="s2">\n    </span><span class="s1">// check if parentVal is a function here because</span><span class="s2">\n    </span><span class="s1">// it has to be a function to pass previous merges.</span><span class="s2">\n    </span><span class="s1">return function mergedDataFn() {</span><span class="s2">\n      </span><span class="s1">return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return function mergedInstanceDataFn() {</span><span class="s2">\n      </span><span class="s1">// instance merge</span><span class="s2">\n      </span><span class="s1">var instanceData = isFunction(childVal) ? childVal.call(vm, vm) : childVal;</span><span class="s2">\n      </span><span class="s1">var defaultData = isFunction(parentVal) ? parentVal.call(vm, vm) : parentVal;</span><span class="s2">\n      </span><span class="s1">if (instanceData) {</span><span class="s2">\n        </span><span class="s1">return mergeData(instanceData, defaultData);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return defaultData;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">strats.data = function (parentVal, childVal, vm) {</span><span class="s2">\n  </span><span class="s1">if (!vm) {</span><span class="s2">\n    </span><span class="s1">if (childVal &amp;&amp; typeof childVal !== 'function') {</span><span class="s2">\n      </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn('The </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);</span><span class="s2">\n      </span><span class="s1">return parentVal;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return mergeDataOrFn(parentVal, childVal);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return mergeDataOrFn(parentVal, childVal, vm);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Hooks and props are merged as arrays.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function mergeLifecycleHook(parentVal, childVal) {</span><span class="s2">\n  </span><span class="s1">var res = childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;</span><span class="s2">\n  </span><span class="s1">return res ? dedupeHooks(res) : res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function dedupeHooks(hooks) {</span><span class="s2">\n  </span><span class="s1">var res = [];</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; hooks.length; i++) {</span><span class="s2">\n    </span><span class="s1">if (res.indexOf(hooks[i]) === -1) {</span><span class="s2">\n      </span><span class="s1">res.push(hooks[i]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">LIFECYCLE_HOOKS.forEach(function (hook) {</span><span class="s2">\n  </span><span class="s1">strats[hook] = mergeLifecycleHook;</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Assets</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* When a vm is present (instance creation), we need to do</span><span class="s2">\n </span><span class="s1">* a three-way merge between constructor options, instance</span><span class="s2">\n </span><span class="s1">* options and parent options.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function mergeAssets(parentVal, childVal, vm, key) {</span><span class="s2">\n  </span><span class="s1">var res = Object.create(parentVal || null);</span><span class="s2">\n  </span><span class="s1">if (childVal) {</span><span class="s2">\n    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; assertObjectType(key, childVal, vm);</span><span class="s2">\n    </span><span class="s1">return extend(res, childVal);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">ASSET_TYPES.forEach(function (type) {</span><span class="s2">\n  </span><span class="s1">strats[type + 's'] = mergeAssets;</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Watchers.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Watchers hashes should not overwrite one</span><span class="s2">\n </span><span class="s1">* another, so we merge them as arrays.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">strats.watch = function (parentVal, childVal, vm, key) {</span><span class="s2">\n  </span><span class="s1">// work around Firefox's Object.prototype.watch...</span><span class="s2">\n  </span><span class="s1">//@ts-expect-error work around</span><span class="s2">\n  </span><span class="s1">if (parentVal === nativeWatch) parentVal = undefined;</span><span class="s2">\n  </span><span class="s1">//@ts-expect-error work around</span><span class="s2">\n  </span><span class="s1">if (childVal === nativeWatch) childVal = undefined;</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (!childVal) return Object.create(parentVal || null);</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">assertObjectType(key, childVal, vm);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!parentVal) return childVal;</span><span class="s2">\n  </span><span class="s1">var ret = {};</span><span class="s2">\n  </span><span class="s1">extend(ret, parentVal);</span><span class="s2">\n  </span><span class="s1">for (var key_1 in childVal) {</span><span class="s2">\n    </span><span class="s1">var parent_1 = ret[key_1];</span><span class="s2">\n    </span><span class="s1">var child = childVal[key_1];</span><span class="s2">\n    </span><span class="s1">if (parent_1 &amp;&amp; !isArray(parent_1)) {</span><span class="s2">\n      </span><span class="s1">parent_1 = [parent_1];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">ret[key_1] = parent_1 ? parent_1.concat(child) : isArray(child) ? child : [child];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return ret;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Other object hashes.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {</span><span class="s2">\n  </span><span class="s1">if (childVal &amp;&amp; process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">assertObjectType(key, childVal, vm);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!parentVal) return childVal;</span><span class="s2">\n  </span><span class="s1">var ret = Object.create(null);</span><span class="s2">\n  </span><span class="s1">extend(ret, parentVal);</span><span class="s2">\n  </span><span class="s1">if (childVal) extend(ret, childVal);</span><span class="s2">\n  </span><span class="s1">return ret;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">strats.provide = function (parentVal, childVal) {</span><span class="s2">\n  </span><span class="s1">if (!parentVal) return childVal;</span><span class="s2">\n  </span><span class="s1">return function () {</span><span class="s2">\n    </span><span class="s1">var ret = Object.create(null);</span><span class="s2">\n    </span><span class="s1">mergeData(ret, isFunction(parentVal) ? parentVal.call(this) : parentVal);</span><span class="s2">\n    </span><span class="s1">if (childVal) {</span><span class="s2">\n      </span><span class="s1">mergeData(ret, isFunction(childVal) ? childVal.call(this) : childVal, false // non-recursive</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return ret;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Default strategy.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var defaultStrat = function (parentVal, childVal) {</span><span class="s2">\n  </span><span class="s1">return childVal === undefined ? parentVal : childVal;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Validate component names</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function checkComponents(options) {</span><span class="s2">\n  </span><span class="s1">for (var key in options.components) {</span><span class="s2">\n    </span><span class="s1">validateComponentName(key);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function validateComponentName(name) {</span><span class="s2">\n  </span><span class="s1">if (!new RegExp(</span><span class="s2">\&quot;</span><span class="s1">^[a-zA-Z][</span><span class="s2">\\\\</span><span class="s1">-</span><span class="s2">\\\\</span><span class="s1">.0-9_</span><span class="s2">\&quot;</span><span class="s1">.concat(unicodeRegExp.source, </span><span class="s2">\&quot;</span><span class="s1">]*$</span><span class="s2">\&quot;</span><span class="s1">)).test(name)) {</span><span class="s2">\n    </span><span class="s1">warn('Invalid component name: </span><span class="s2">\&quot;</span><span class="s1">' + name + '</span><span class="s2">\&quot;</span><span class="s1">. Component names ' + 'should conform to valid custom element name in html5 specification.');</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isBuiltInTag(name) || config.isReservedTag(name)) {</span><span class="s2">\n    </span><span class="s1">warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Ensure all props option syntax are normalized into the</span><span class="s2">\n </span><span class="s1">* Object-based format.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function normalizeProps(options, vm) {</span><span class="s2">\n  </span><span class="s1">var props = options.props;</span><span class="s2">\n  </span><span class="s1">if (!props) return;</span><span class="s2">\n  </span><span class="s1">var res = {};</span><span class="s2">\n  </span><span class="s1">var i, val, name;</span><span class="s2">\n  </span><span class="s1">if (isArray(props)) {</span><span class="s2">\n    </span><span class="s1">i = props.length;</span><span class="s2">\n    </span><span class="s1">while (i--) {</span><span class="s2">\n      </span><span class="s1">val = props[i];</span><span class="s2">\n      </span><span class="s1">if (typeof val === 'string') {</span><span class="s2">\n        </span><span class="s1">name = camelize(val);</span><span class="s2">\n        </span><span class="s1">res[name] = {</span><span class="s2">\n          </span><span class="s1">type: null</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">warn('props must be strings when using array syntax.');</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (isPlainObject(props)) {</span><span class="s2">\n    </span><span class="s1">for (var key in props) {</span><span class="s2">\n      </span><span class="s1">val = props[key];</span><span class="s2">\n      </span><span class="s1">name = camelize(key);</span><span class="s2">\n      </span><span class="s1">res[name] = isPlainObject(val) ? val : {</span><span class="s2">\n        </span><span class="s1">type: val</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Invalid value for option </span><span class="s2">\\\&quot;</span><span class="s1">props</span><span class="s2">\\\&quot;</span><span class="s1">: expected an Array or an Object, </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">but got </span><span class="s2">\&quot;</span><span class="s1">.concat(toRawType(props), </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">options.props = res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Normalize all injections into Object-based format</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function normalizeInject(options, vm) {</span><span class="s2">\n  </span><span class="s1">var inject = options.inject;</span><span class="s2">\n  </span><span class="s1">if (!inject) return;</span><span class="s2">\n  </span><span class="s1">var normalized = options.inject = {};</span><span class="s2">\n  </span><span class="s1">if (isArray(inject)) {</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; inject.length; i++) {</span><span class="s2">\n      </span><span class="s1">normalized[inject[i]] = {</span><span class="s2">\n        </span><span class="s1">from: inject[i]</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (isPlainObject(inject)) {</span><span class="s2">\n    </span><span class="s1">for (var key in inject) {</span><span class="s2">\n      </span><span class="s1">var val = inject[key];</span><span class="s2">\n      </span><span class="s1">normalized[key] = isPlainObject(val) ? extend({</span><span class="s2">\n        </span><span class="s1">from: key</span><span class="s2">\n      </span><span class="s1">}, val) : {</span><span class="s2">\n        </span><span class="s1">from: val</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Invalid value for option </span><span class="s2">\\\&quot;</span><span class="s1">inject</span><span class="s2">\\\&quot;</span><span class="s1">: expected an Array or an Object, </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">but got </span><span class="s2">\&quot;</span><span class="s1">.concat(toRawType(inject), </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Normalize raw function directives into object format.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function normalizeDirectives$1(options) {</span><span class="s2">\n  </span><span class="s1">var dirs = options.directives;</span><span class="s2">\n  </span><span class="s1">if (dirs) {</span><span class="s2">\n    </span><span class="s1">for (var key in dirs) {</span><span class="s2">\n      </span><span class="s1">var def = dirs[key];</span><span class="s2">\n      </span><span class="s1">if (isFunction(def)) {</span><span class="s2">\n        </span><span class="s1">dirs[key] = {</span><span class="s2">\n          </span><span class="s1">bind: def,</span><span class="s2">\n          </span><span class="s1">update: def</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function assertObjectType(name, value, vm) {</span><span class="s2">\n  </span><span class="s1">if (!isPlainObject(value)) {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Invalid value for option </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">: expected an Object, </span><span class="s2">\&quot;</span><span class="s1">) + </span><span class="s2">\&quot;</span><span class="s1">but got </span><span class="s2">\&quot;</span><span class="s1">.concat(toRawType(value), </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Merge two option objects into a new one.</span><span class="s2">\n </span><span class="s1">* Core utility used in both instantiation and inheritance.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function mergeOptions(parent, child, vm) {</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">checkComponents(child);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isFunction(child)) {</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">child = child.options;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">normalizeProps(child, vm);</span><span class="s2">\n  </span><span class="s1">normalizeInject(child, vm);</span><span class="s2">\n  </span><span class="s1">normalizeDirectives$1(child);</span><span class="s2">\n  </span><span class="s1">// Apply extends and mixins on the child options,</span><span class="s2">\n  </span><span class="s1">// but only if it is a raw options object that isn't</span><span class="s2">\n  </span><span class="s1">// the result of another mergeOptions call.</span><span class="s2">\n  </span><span class="s1">// Only merged options has the _base property.</span><span class="s2">\n  </span><span class="s1">if (!child._base) {</span><span class="s2">\n    </span><span class="s1">if (child.extends) {</span><span class="s2">\n      </span><span class="s1">parent = mergeOptions(parent, child.extends, vm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (child.mixins) {</span><span class="s2">\n      </span><span class="s1">for (var i = 0, l = child.mixins.length; i &lt; l; i++) {</span><span class="s2">\n        </span><span class="s1">parent = mergeOptions(parent, child.mixins[i], vm);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var options = {};</span><span class="s2">\n  </span><span class="s1">var key;</span><span class="s2">\n  </span><span class="s1">for (key in parent) {</span><span class="s2">\n    </span><span class="s1">mergeField(key);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">for (key in child) {</span><span class="s2">\n    </span><span class="s1">if (!hasOwn(parent, key)) {</span><span class="s2">\n      </span><span class="s1">mergeField(key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function mergeField(key) {</span><span class="s2">\n    </span><span class="s1">var strat = strats[key] || defaultStrat;</span><span class="s2">\n    </span><span class="s1">options[key] = strat(parent[key], child[key], vm, key);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return options;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Resolve an asset.</span><span class="s2">\n </span><span class="s1">* This function is used because child instances need access</span><span class="s2">\n </span><span class="s1">* to assets defined in its ancestor chain.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function resolveAsset(options, type, id, warnMissing) {</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (typeof id !== 'string') {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var assets = options[type];</span><span class="s2">\n  </span><span class="s1">// check local registration variations first</span><span class="s2">\n  </span><span class="s1">if (hasOwn(assets, id)) return assets[id];</span><span class="s2">\n  </span><span class="s1">var camelizedId = camelize(id);</span><span class="s2">\n  </span><span class="s1">if (hasOwn(assets, camelizedId)) return assets[camelizedId];</span><span class="s2">\n  </span><span class="s1">var PascalCaseId = capitalize(camelizedId);</span><span class="s2">\n  </span><span class="s1">if (hasOwn(assets, PascalCaseId)) return assets[PascalCaseId];</span><span class="s2">\n  </span><span class="s1">// fallback to prototype chain</span><span class="s2">\n  </span><span class="s1">var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; warnMissing &amp;&amp; !res) {</span><span class="s2">\n    </span><span class="s1">warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function validateProp(key, propOptions, propsData, vm) {</span><span class="s2">\n  </span><span class="s1">var prop = propOptions[key];</span><span class="s2">\n  </span><span class="s1">var absent = !hasOwn(propsData, key);</span><span class="s2">\n  </span><span class="s1">var value = propsData[key];</span><span class="s2">\n  </span><span class="s1">// boolean casting</span><span class="s2">\n  </span><span class="s1">var booleanIndex = getTypeIndex(Boolean, prop.type);</span><span class="s2">\n  </span><span class="s1">if (booleanIndex &gt; -1) {</span><span class="s2">\n    </span><span class="s1">if (absent &amp;&amp; !hasOwn(prop, 'default')) {</span><span class="s2">\n      </span><span class="s1">value = false;</span><span class="s2">\n    </span><span class="s1">} else if (value === '' || value === hyphenate(key)) {</span><span class="s2">\n      </span><span class="s1">// only cast empty string / same name to boolean if</span><span class="s2">\n      </span><span class="s1">// boolean has higher priority</span><span class="s2">\n      </span><span class="s1">var stringIndex = getTypeIndex(String, prop.type);</span><span class="s2">\n      </span><span class="s1">if (stringIndex &lt; 0 || booleanIndex &lt; stringIndex) {</span><span class="s2">\n        </span><span class="s1">value = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// check default value</span><span class="s2">\n  </span><span class="s1">if (value === undefined) {</span><span class="s2">\n    </span><span class="s1">value = getPropDefaultValue(vm, prop, key);</span><span class="s2">\n    </span><span class="s1">// since the default value is a fresh copy,</span><span class="s2">\n    </span><span class="s1">// make sure to observe it.</span><span class="s2">\n    </span><span class="s1">var prevShouldObserve = shouldObserve;</span><span class="s2">\n    </span><span class="s1">toggleObserving(true);</span><span class="s2">\n    </span><span class="s1">observe(value);</span><span class="s2">\n    </span><span class="s1">toggleObserving(prevShouldObserve);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">assertProp(prop, key, value, vm, absent);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return value;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Get the default value of a prop.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function getPropDefaultValue(vm, prop, key) {</span><span class="s2">\n  </span><span class="s1">// no default, return undefined</span><span class="s2">\n  </span><span class="s1">if (!hasOwn(prop, 'default')) {</span><span class="s2">\n    </span><span class="s1">return undefined;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var def = prop.default;</span><span class="s2">\n  </span><span class="s1">// warn against non-factory defaults for Object &amp; Array</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; isObject(def)) {</span><span class="s2">\n    </span><span class="s1">warn('Invalid default value for prop </span><span class="s2">\&quot;</span><span class="s1">' + key + '</span><span class="s2">\&quot;</span><span class="s1">: ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// the raw prop value was also undefined from previous render,</span><span class="s2">\n  </span><span class="s1">// return previous default value to avoid unnecessary watcher trigger</span><span class="s2">\n  </span><span class="s1">if (vm &amp;&amp; vm.$options.propsData &amp;&amp; vm.$options.propsData[key] === undefined &amp;&amp; vm._props[key] !== undefined) {</span><span class="s2">\n    </span><span class="s1">return vm._props[key];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// call factory function for non-Function types</span><span class="s2">\n  </span><span class="s1">// a value is Function if its prototype is function even across different execution context</span><span class="s2">\n  </span><span class="s1">return isFunction(def) &amp;&amp; getType(prop.type) !== 'Function' ? def.call(vm) : def;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Assert whether a prop is valid.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function assertProp(prop, name, value, vm, absent) {</span><span class="s2">\n  </span><span class="s1">if (prop.required &amp;&amp; absent) {</span><span class="s2">\n    </span><span class="s1">warn('Missing required prop: </span><span class="s2">\&quot;</span><span class="s1">' + name + '</span><span class="s2">\&quot;</span><span class="s1">', vm);</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (value == null &amp;&amp; !prop.required) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var type = prop.type;</span><span class="s2">\n  </span><span class="s1">var valid = !type || type === true;</span><span class="s2">\n  </span><span class="s1">var expectedTypes = [];</span><span class="s2">\n  </span><span class="s1">if (type) {</span><span class="s2">\n    </span><span class="s1">if (!isArray(type)) {</span><span class="s2">\n      </span><span class="s1">type = [type];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; type.length &amp;&amp; !valid; i++) {</span><span class="s2">\n      </span><span class="s1">var assertedType = assertType(value, type[i], vm);</span><span class="s2">\n      </span><span class="s1">expectedTypes.push(assertedType.expectedType || '');</span><span class="s2">\n      </span><span class="s1">valid = assertedType.valid;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var haveExpectedTypes = expectedTypes.some(function (t) {</span><span class="s2">\n    </span><span class="s1">return t;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">if (!valid &amp;&amp; haveExpectedTypes) {</span><span class="s2">\n    </span><span class="s1">warn(getInvalidTypeMessage(name, value, expectedTypes), vm);</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var validator = prop.validator;</span><span class="s2">\n  </span><span class="s1">if (validator) {</span><span class="s2">\n    </span><span class="s1">if (!validator(value)) {</span><span class="s2">\n      </span><span class="s1">warn('Invalid prop: custom validator check failed for prop </span><span class="s2">\&quot;</span><span class="s1">' + name + '</span><span class="s2">\&quot;</span><span class="s1">.', vm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;</span><span class="s2">\n</span><span class="s1">function assertType(value, type, vm) {</span><span class="s2">\n  </span><span class="s1">var valid;</span><span class="s2">\n  </span><span class="s1">var expectedType = getType(type);</span><span class="s2">\n  </span><span class="s1">if (simpleCheckRE.test(expectedType)) {</span><span class="s2">\n    </span><span class="s1">var t = typeof value;</span><span class="s2">\n    </span><span class="s1">valid = t === expectedType.toLowerCase();</span><span class="s2">\n    </span><span class="s1">// for primitive wrapper objects</span><span class="s2">\n    </span><span class="s1">if (!valid &amp;&amp; t === 'object') {</span><span class="s2">\n      </span><span class="s1">valid = value instanceof type;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (expectedType === 'Object') {</span><span class="s2">\n    </span><span class="s1">valid = isPlainObject(value);</span><span class="s2">\n  </span><span class="s1">} else if (expectedType === 'Array') {</span><span class="s2">\n    </span><span class="s1">valid = isArray(value);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">valid = value instanceof type;</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">warn('Invalid prop type: </span><span class="s2">\&quot;</span><span class="s1">' + String(type) + '</span><span class="s2">\&quot; </span><span class="s1">is not a constructor', vm);</span><span class="s2">\n      </span><span class="s1">valid = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">valid: valid,</span><span class="s2">\n    </span><span class="s1">expectedType: expectedType</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var functionTypeCheckRE = /^</span><span class="s2">\\</span><span class="s1">s*function (</span><span class="s2">\\</span><span class="s1">w+)/;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Use function string name to check built-in types,</span><span class="s2">\n </span><span class="s1">* because a simple equality check will fail when running</span><span class="s2">\n </span><span class="s1">* across different vms / iframes.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function getType(fn) {</span><span class="s2">\n  </span><span class="s1">var match = fn &amp;&amp; fn.toString().match(functionTypeCheckRE);</span><span class="s2">\n  </span><span class="s1">return match ? match[1] : '';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isSameType(a, b) {</span><span class="s2">\n  </span><span class="s1">return getType(a) === getType(b);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getTypeIndex(type, expectedTypes) {</span><span class="s2">\n  </span><span class="s1">if (!isArray(expectedTypes)) {</span><span class="s2">\n    </span><span class="s1">return isSameType(expectedTypes, type) ? 0 : -1;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">for (var i = 0, len = expectedTypes.length; i &lt; len; i++) {</span><span class="s2">\n    </span><span class="s1">if (isSameType(expectedTypes[i], type)) {</span><span class="s2">\n      </span><span class="s1">return i;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return -1;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getInvalidTypeMessage(name, value, expectedTypes) {</span><span class="s2">\n  </span><span class="s1">var message = </span><span class="s2">\&quot;</span><span class="s1">Invalid prop: type check failed for prop </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">) + </span><span class="s2">\&quot; </span><span class="s1">Expected </span><span class="s2">\&quot;</span><span class="s1">.concat(expectedTypes.map(capitalize).join(', '));</span><span class="s2">\n  </span><span class="s1">var expectedType = expectedTypes[0];</span><span class="s2">\n  </span><span class="s1">var receivedType = toRawType(value);</span><span class="s2">\n  </span><span class="s1">// check if we need to specify expected value</span><span class="s2">\n  </span><span class="s1">if (expectedTypes.length === 1 &amp;&amp; isExplicable(expectedType) &amp;&amp; isExplicable(typeof value) &amp;&amp; !isBoolean(expectedType, receivedType)) {</span><span class="s2">\n    </span><span class="s1">message += </span><span class="s2">\&quot; </span><span class="s1">with value </span><span class="s2">\&quot;</span><span class="s1">.concat(styleValue(value, expectedType));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">message += </span><span class="s2">\&quot;</span><span class="s1">, got </span><span class="s2">\&quot;</span><span class="s1">.concat(receivedType, </span><span class="s2">\&quot; \&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">// check if we need to specify received value</span><span class="s2">\n  </span><span class="s1">if (isExplicable(receivedType)) {</span><span class="s2">\n    </span><span class="s1">message += </span><span class="s2">\&quot;</span><span class="s1">with value </span><span class="s2">\&quot;</span><span class="s1">.concat(styleValue(value, receivedType), </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return message;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function styleValue(value, type) {</span><span class="s2">\n  </span><span class="s1">if (type === 'String') {</span><span class="s2">\n    </span><span class="s1">return </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">.concat(value, </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">} else if (type === 'Number') {</span><span class="s2">\n    </span><span class="s1">return </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(Number(value));</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(value);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];</span><span class="s2">\n</span><span class="s1">function isExplicable(value) {</span><span class="s2">\n  </span><span class="s1">return EXPLICABLE_TYPES.some(function (elem) {</span><span class="s2">\n    </span><span class="s1">return value.toLowerCase() === elem;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isBoolean() {</span><span class="s2">\n  </span><span class="s1">var args = [];</span><span class="s2">\n  </span><span class="s1">for (var _i = 0; _i &lt; arguments.length; _i++) {</span><span class="s2">\n    </span><span class="s1">args[_i] = arguments[_i];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return args.some(function (elem) {</span><span class="s2">\n    </span><span class="s1">return elem.toLowerCase() === 'boolean';</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/* not type checking this file because flow doesn't play well with Proxy */</span><span class="s2">\n</span><span class="s1">var initProxy;</span><span class="s2">\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n  </span><span class="s1">var allowedGlobals_1 = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' + 'require' // for Webpack/Browserify</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n\n  </span><span class="s1">var warnNonPresent_1 = function (target, key) {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Property or method </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is not defined on the instance but </span><span class="s2">\&quot;</span><span class="s1">) + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://v2.vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">var warnReservedPrefix_1 = function (target, key) {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Property </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">must be accessed with </span><span class="s2">\\\&quot;</span><span class="s1">$data.</span><span class="s2">\&quot;</span><span class="s1">).concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">because </span><span class="s2">\&quot;</span><span class="s1">) + 'properties starting with </span><span class="s2">\&quot;</span><span class="s1">$</span><span class="s2">\&quot; </span><span class="s1">or </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot; </span><span class="s1">are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals. ' + 'See: https://v2.vuejs.org/v2/api/#data', target);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">var hasProxy_1 = typeof Proxy !== 'undefined' &amp;&amp; isNative(Proxy);</span><span class="s2">\n  </span><span class="s1">if (hasProxy_1) {</span><span class="s2">\n    </span><span class="s1">var isBuiltInModifier_1 = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');</span><span class="s2">\n    </span><span class="s1">config.keyCodes = new Proxy(config.keyCodes, {</span><span class="s2">\n      </span><span class="s1">set: function (target, key, value) {</span><span class="s2">\n        </span><span class="s1">if (isBuiltInModifier_1(key)) {</span><span class="s2">\n          </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Avoid overwriting built-in modifier in config.keyCodes: .</span><span class="s2">\&quot;</span><span class="s1">.concat(key));</span><span class="s2">\n          </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">target[key] = value;</span><span class="s2">\n          </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var hasHandler_1 = {</span><span class="s2">\n    </span><span class="s1">has: function (target, key) {</span><span class="s2">\n      </span><span class="s1">var has = (key in target);</span><span class="s2">\n      </span><span class="s1">var isAllowed = allowedGlobals_1(key) || typeof key === 'string' &amp;&amp; key.charAt(0) === '_' &amp;&amp; !(key in target.$data);</span><span class="s2">\n      </span><span class="s1">if (!has &amp;&amp; !isAllowed) {</span><span class="s2">\n        </span><span class="s1">if (key in target.$data) warnReservedPrefix_1(target, key);else warnNonPresent_1(target, key);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return has || !isAllowed;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">var getHandler_1 = {</span><span class="s2">\n    </span><span class="s1">get: function (target, key) {</span><span class="s2">\n      </span><span class="s1">if (typeof key === 'string' &amp;&amp; !(key in target)) {</span><span class="s2">\n        </span><span class="s1">if (key in target.$data) warnReservedPrefix_1(target, key);else warnNonPresent_1(target, key);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return target[key];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">initProxy = function initProxy(vm) {</span><span class="s2">\n    </span><span class="s1">if (hasProxy_1) {</span><span class="s2">\n      </span><span class="s1">// determine which proxy handler to use</span><span class="s2">\n      </span><span class="s1">var options = vm.$options;</span><span class="s2">\n      </span><span class="s1">var handlers = options.render &amp;&amp; options.render._withStripped ? getHandler_1 : hasHandler_1;</span><span class="s2">\n      </span><span class="s1">vm._renderProxy = new Proxy(vm, handlers);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">vm._renderProxy = vm;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var sharedPropertyDefinition = {</span><span class="s2">\n  </span><span class="s1">enumerable: true,</span><span class="s2">\n  </span><span class="s1">configurable: true,</span><span class="s2">\n  </span><span class="s1">get: noop,</span><span class="s2">\n  </span><span class="s1">set: noop</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function proxy(target, sourceKey, key) {</span><span class="s2">\n  </span><span class="s1">sharedPropertyDefinition.get = function proxyGetter() {</span><span class="s2">\n    </span><span class="s1">return this[sourceKey][key];</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">sharedPropertyDefinition.set = function proxySetter(val) {</span><span class="s2">\n    </span><span class="s1">this[sourceKey][key] = val;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">Object.defineProperty(target, key, sharedPropertyDefinition);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initState(vm) {</span><span class="s2">\n  </span><span class="s1">var opts = vm.$options;</span><span class="s2">\n  </span><span class="s1">if (opts.props) initProps$1(vm, opts.props);</span><span class="s2">\n  </span><span class="s1">// Composition API</span><span class="s2">\n  </span><span class="s1">initSetup(vm);</span><span class="s2">\n  </span><span class="s1">if (opts.methods) initMethods(vm, opts.methods);</span><span class="s2">\n  </span><span class="s1">if (opts.data) {</span><span class="s2">\n    </span><span class="s1">initData(vm);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">var ob = observe(vm._data = {});</span><span class="s2">\n    </span><span class="s1">ob &amp;&amp; ob.vmCount++;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (opts.computed) initComputed$1(vm, opts.computed);</span><span class="s2">\n  </span><span class="s1">if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {</span><span class="s2">\n    </span><span class="s1">initWatch(vm, opts.watch);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initProps$1(vm, propsOptions) {</span><span class="s2">\n  </span><span class="s1">var propsData = vm.$options.propsData || {};</span><span class="s2">\n  </span><span class="s1">var props = vm._props = shallowReactive({});</span><span class="s2">\n  </span><span class="s1">// cache prop keys so that future props updates can iterate using Array</span><span class="s2">\n  </span><span class="s1">// instead of dynamic object key enumeration.</span><span class="s2">\n  </span><span class="s1">var keys = vm.$options._propKeys = [];</span><span class="s2">\n  </span><span class="s1">var isRoot = !vm.$parent;</span><span class="s2">\n  </span><span class="s1">// root instance props should be converted</span><span class="s2">\n  </span><span class="s1">if (!isRoot) {</span><span class="s2">\n    </span><span class="s1">toggleObserving(false);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var _loop_1 = function (key) {</span><span class="s2">\n    </span><span class="s1">keys.push(key);</span><span class="s2">\n    </span><span class="s1">var value = validateProp(key, propsOptions, propsData, vm);</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">var hyphenatedKey = hyphenate(key);</span><span class="s2">\n      </span><span class="s1">if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">.concat(hyphenatedKey, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is a reserved attribute and cannot be used as component prop.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">defineReactive(props, key, value, function () {</span><span class="s2">\n        </span><span class="s1">if (!isRoot &amp;&amp; !isUpdatingChildComponent) {</span><span class="s2">\n          </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Avoid mutating a prop directly since the value will be </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">overwritten whenever the parent component re-renders. </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">Instead, use a data or computed property based on the prop's </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">value. Prop being mutated: </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">), vm);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">defineReactive(props, key, value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// static props are already proxied on the component's prototype</span><span class="s2">\n    </span><span class="s1">// during Vue.extend(). We only need to proxy props defined at</span><span class="s2">\n    </span><span class="s1">// instantiation here.</span><span class="s2">\n    </span><span class="s1">if (!(key in vm)) {</span><span class="s2">\n      </span><span class="s1">proxy(vm, </span><span class="s2">\&quot;</span><span class="s1">_props</span><span class="s2">\&quot;</span><span class="s1">, key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">for (var key in propsOptions) {</span><span class="s2">\n    </span><span class="s1">_loop_1(key);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">toggleObserving(true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initData(vm) {</span><span class="s2">\n  </span><span class="s1">var data = vm.$options.data;</span><span class="s2">\n  </span><span class="s1">data = vm._data = isFunction(data) ? getData(data, vm) : data || {};</span><span class="s2">\n  </span><span class="s1">if (!isPlainObject(data)) {</span><span class="s2">\n    </span><span class="s1">data = {};</span><span class="s2">\n    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn('data functions should return an object:</span><span class="s2">\\</span><span class="s1">n' + 'https://v2.vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// proxy data on instance</span><span class="s2">\n  </span><span class="s1">var keys = Object.keys(data);</span><span class="s2">\n  </span><span class="s1">var props = vm.$options.props;</span><span class="s2">\n  </span><span class="s1">var methods = vm.$options.methods;</span><span class="s2">\n  </span><span class="s1">var i = keys.length;</span><span class="s2">\n  </span><span class="s1">while (i--) {</span><span class="s2">\n    </span><span class="s1">var key = keys[i];</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">if (methods &amp;&amp; hasOwn(methods, key)) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Method </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">has already been defined as a data property.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (props &amp;&amp; hasOwn(props, key)) {</span><span class="s2">\n      </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">The data property </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is already declared as a prop. </span><span class="s2">\&quot;</span><span class="s1">) + </span><span class="s2">\&quot;</span><span class="s1">Use prop default value instead.</span><span class="s2">\&quot;</span><span class="s1">, vm);</span><span class="s2">\n    </span><span class="s1">} else if (!isReserved(key)) {</span><span class="s2">\n      </span><span class="s1">proxy(vm, </span><span class="s2">\&quot;</span><span class="s1">_data</span><span class="s2">\&quot;</span><span class="s1">, key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// observe data</span><span class="s2">\n  </span><span class="s1">var ob = observe(data);</span><span class="s2">\n  </span><span class="s1">ob &amp;&amp; ob.vmCount++;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getData(data, vm) {</span><span class="s2">\n  </span><span class="s1">// #7573 disable dep collection when invoking data getters</span><span class="s2">\n  </span><span class="s1">pushTarget();</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">return data.call(vm, vm);</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">handleError(e, vm, </span><span class="s2">\&quot;</span><span class="s1">data()</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">return {};</span><span class="s2">\n  </span><span class="s1">} finally {</span><span class="s2">\n    </span><span class="s1">popTarget();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var computedWatcherOptions = {</span><span class="s2">\n  </span><span class="s1">lazy: true</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function initComputed$1(vm, computed) {</span><span class="s2">\n  </span><span class="s1">// $flow-disable-line</span><span class="s2">\n  </span><span class="s1">var watchers = vm._computedWatchers = Object.create(null);</span><span class="s2">\n  </span><span class="s1">// computed properties are just getters during SSR</span><span class="s2">\n  </span><span class="s1">var isSSR = isServerRendering();</span><span class="s2">\n  </span><span class="s1">for (var key in computed) {</span><span class="s2">\n    </span><span class="s1">var userDef = computed[key];</span><span class="s2">\n    </span><span class="s1">var getter = isFunction(userDef) ? userDef : userDef.get;</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; getter == null) {</span><span class="s2">\n      </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Getter is missing for computed property </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!isSSR) {</span><span class="s2">\n      </span><span class="s1">// create internal watcher for the computed property.</span><span class="s2">\n      </span><span class="s1">watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// component-defined computed properties are already defined on the</span><span class="s2">\n    </span><span class="s1">// component prototype. We only need to define computed properties defined</span><span class="s2">\n    </span><span class="s1">// at instantiation here.</span><span class="s2">\n    </span><span class="s1">if (!(key in vm)) {</span><span class="s2">\n      </span><span class="s1">defineComputed(vm, key, userDef);</span><span class="s2">\n    </span><span class="s1">} else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">if (key in vm.$data) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">The computed property </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is already defined in data.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n      </span><span class="s1">} else if (vm.$options.props &amp;&amp; key in vm.$options.props) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">The computed property </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is already defined as a prop.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n      </span><span class="s1">} else if (vm.$options.methods &amp;&amp; key in vm.$options.methods) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">The computed property </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is already defined as a method.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function defineComputed(target, key, userDef) {</span><span class="s2">\n  </span><span class="s1">var shouldCache = !isServerRendering();</span><span class="s2">\n  </span><span class="s1">if (isFunction(userDef)) {</span><span class="s2">\n    </span><span class="s1">sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);</span><span class="s2">\n    </span><span class="s1">sharedPropertyDefinition.set = noop;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">sharedPropertyDefinition.get = userDef.get ? shouldCache &amp;&amp; userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;</span><span class="s2">\n    </span><span class="s1">sharedPropertyDefinition.set = userDef.set || noop;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; sharedPropertyDefinition.set === noop) {</span><span class="s2">\n    </span><span class="s1">sharedPropertyDefinition.set = function () {</span><span class="s2">\n      </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Computed property </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">was assigned to but it has no setter.</span><span class="s2">\&quot;</span><span class="s1">), this);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">Object.defineProperty(target, key, sharedPropertyDefinition);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createComputedGetter(key) {</span><span class="s2">\n  </span><span class="s1">return function computedGetter() {</span><span class="s2">\n    </span><span class="s1">var watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key];</span><span class="s2">\n    </span><span class="s1">if (watcher) {</span><span class="s2">\n      </span><span class="s1">if (watcher.dirty) {</span><span class="s2">\n        </span><span class="s1">watcher.evaluate();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (Dep.target) {</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; Dep.target.onTrack) {</span><span class="s2">\n          </span><span class="s1">Dep.target.onTrack({</span><span class="s2">\n            </span><span class="s1">effect: Dep.target,</span><span class="s2">\n            </span><span class="s1">target: this,</span><span class="s2">\n            </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.GET */,</span><span class="s2">\n            </span><span class="s1">key: key</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">watcher.depend();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return watcher.value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createGetterInvoker(fn) {</span><span class="s2">\n  </span><span class="s1">return function computedGetter() {</span><span class="s2">\n    </span><span class="s1">return fn.call(this, this);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initMethods(vm, methods) {</span><span class="s2">\n  </span><span class="s1">var props = vm.$options.props;</span><span class="s2">\n  </span><span class="s1">for (var key in methods) {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">if (typeof methods[key] !== 'function') {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Method </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">has type </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">).concat(typeof methods[key], </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">in the component definition. </span><span class="s2">\&quot;</span><span class="s1">) + </span><span class="s2">\&quot;</span><span class="s1">Did you reference the function correctly?</span><span class="s2">\&quot;</span><span class="s1">, vm);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (props &amp;&amp; hasOwn(props, key)) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Method </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">has already been defined as a prop.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (key in vm &amp;&amp; isReserved(key)) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Method </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">conflicts with an existing Vue instance method. </span><span class="s2">\&quot;</span><span class="s1">) + </span><span class="s2">\&quot;</span><span class="s1">Avoid defining component methods that start with _ or $.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initWatch(vm, watch) {</span><span class="s2">\n  </span><span class="s1">for (var key in watch) {</span><span class="s2">\n    </span><span class="s1">var handler = watch[key];</span><span class="s2">\n    </span><span class="s1">if (isArray(handler)) {</span><span class="s2">\n      </span><span class="s1">for (var i = 0; i &lt; handler.length; i++) {</span><span class="s2">\n        </span><span class="s1">createWatcher(vm, key, handler[i]);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">createWatcher(vm, key, handler);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createWatcher(vm, expOrFn, handler, options) {</span><span class="s2">\n  </span><span class="s1">if (isPlainObject(handler)) {</span><span class="s2">\n    </span><span class="s1">options = handler;</span><span class="s2">\n    </span><span class="s1">handler = handler.handler;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (typeof handler === 'string') {</span><span class="s2">\n    </span><span class="s1">handler = vm[handler];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return vm.$watch(expOrFn, handler, options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stateMixin(Vue) {</span><span class="s2">\n  </span><span class="s1">// flow somehow has problems with directly declared definition object</span><span class="s2">\n  </span><span class="s1">// when using Object.defineProperty, so we have to procedurally build up</span><span class="s2">\n  </span><span class="s1">// the object here.</span><span class="s2">\n  </span><span class="s1">var dataDef = {};</span><span class="s2">\n  </span><span class="s1">dataDef.get = function () {</span><span class="s2">\n    </span><span class="s1">return this._data;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">var propsDef = {};</span><span class="s2">\n  </span><span class="s1">propsDef.get = function () {</span><span class="s2">\n    </span><span class="s1">return this._props;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">dataDef.set = function () {</span><span class="s2">\n      </span><span class="s1">warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">propsDef.set = function () {</span><span class="s2">\n      </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">$props is readonly.</span><span class="s2">\&quot;</span><span class="s1">, this);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">Object.defineProperty(Vue.prototype, '$data', dataDef);</span><span class="s2">\n  </span><span class="s1">Object.defineProperty(Vue.prototype, '$props', propsDef);</span><span class="s2">\n  </span><span class="s1">Vue.prototype.$set = set;</span><span class="s2">\n  </span><span class="s1">Vue.prototype.$delete = del;</span><span class="s2">\n  </span><span class="s1">Vue.prototype.$watch = function (expOrFn, cb, options) {</span><span class="s2">\n    </span><span class="s1">var vm = this;</span><span class="s2">\n    </span><span class="s1">if (isPlainObject(cb)) {</span><span class="s2">\n      </span><span class="s1">return createWatcher(vm, expOrFn, cb, options);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">options = options || {};</span><span class="s2">\n    </span><span class="s1">options.user = true;</span><span class="s2">\n    </span><span class="s1">var watcher = new Watcher(vm, expOrFn, cb, options);</span><span class="s2">\n    </span><span class="s1">if (options.immediate) {</span><span class="s2">\n      </span><span class="s1">var info = </span><span class="s2">\&quot;</span><span class="s1">callback for immediate watcher </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(watcher.expression, </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">pushTarget();</span><span class="s2">\n      </span><span class="s1">invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);</span><span class="s2">\n      </span><span class="s1">popTarget();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return function unwatchFn() {</span><span class="s2">\n      </span><span class="s1">watcher.teardown();</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var uid = 0;</span><span class="s2">\n</span><span class="s1">function initMixin$1(Vue) {</span><span class="s2">\n  </span><span class="s1">Vue.prototype._init = function (options) {</span><span class="s2">\n    </span><span class="s1">var vm = this;</span><span class="s2">\n    </span><span class="s1">// a uid</span><span class="s2">\n    </span><span class="s1">vm._uid = uid++;</span><span class="s2">\n    </span><span class="s1">var startTag, endTag;</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {</span><span class="s2">\n      </span><span class="s1">startTag = </span><span class="s2">\&quot;</span><span class="s1">vue-perf-start:</span><span class="s2">\&quot;</span><span class="s1">.concat(vm._uid);</span><span class="s2">\n      </span><span class="s1">endTag = </span><span class="s2">\&quot;</span><span class="s1">vue-perf-end:</span><span class="s2">\&quot;</span><span class="s1">.concat(vm._uid);</span><span class="s2">\n      </span><span class="s1">mark(startTag);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// a flag to mark this as a Vue instance without having to do instanceof</span><span class="s2">\n    </span><span class="s1">// check</span><span class="s2">\n    </span><span class="s1">vm._isVue = true;</span><span class="s2">\n    </span><span class="s1">// avoid instances from being observed</span><span class="s2">\n    </span><span class="s1">vm.__v_skip = true;</span><span class="s2">\n    </span><span class="s1">// effect scope</span><span class="s2">\n    </span><span class="s1">vm._scope = new EffectScope(true /* detached */);</span><span class="s2">\n    </span><span class="s1">vm._scope._vm = true;</span><span class="s2">\n    </span><span class="s1">// merge options</span><span class="s2">\n    </span><span class="s1">if (options &amp;&amp; options._isComponent) {</span><span class="s2">\n      </span><span class="s1">// optimize internal component instantiation</span><span class="s2">\n      </span><span class="s1">// since dynamic options merging is pretty slow, and none of the</span><span class="s2">\n      </span><span class="s1">// internal component options needs special treatment.</span><span class="s2">\n      </span><span class="s1">initInternalComponent(vm, options);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">initProxy(vm);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">vm._renderProxy = vm;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// expose real self</span><span class="s2">\n    </span><span class="s1">vm._self = vm;</span><span class="s2">\n    </span><span class="s1">initLifecycle(vm);</span><span class="s2">\n    </span><span class="s1">initEvents(vm);</span><span class="s2">\n    </span><span class="s1">initRender(vm);</span><span class="s2">\n    </span><span class="s1">callHook$1(vm, 'beforeCreate', undefined, false /* setContext */);</span><span class="s2">\n    </span><span class="s1">initInjections(vm); // resolve injections before data/props</span><span class="s2">\n    </span><span class="s1">initState(vm);</span><span class="s2">\n    </span><span class="s1">initProvide(vm); // resolve provide after data/props</span><span class="s2">\n    </span><span class="s1">callHook$1(vm, 'created');</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {</span><span class="s2">\n      </span><span class="s1">vm._name = formatComponentName(vm, false);</span><span class="s2">\n      </span><span class="s1">mark(endTag);</span><span class="s2">\n      </span><span class="s1">measure(</span><span class="s2">\&quot;</span><span class="s1">vue </span><span class="s2">\&quot;</span><span class="s1">.concat(vm._name, </span><span class="s2">\&quot; </span><span class="s1">init</span><span class="s2">\&quot;</span><span class="s1">), startTag, endTag);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (vm.$options.el) {</span><span class="s2">\n      </span><span class="s1">vm.$mount(vm.$options.el);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initInternalComponent(vm, options) {</span><span class="s2">\n  </span><span class="s1">var opts = vm.$options = Object.create(vm.constructor.options);</span><span class="s2">\n  </span><span class="s1">// doing this because it's faster than dynamic enumeration.</span><span class="s2">\n  </span><span class="s1">var parentVnode = options._parentVnode;</span><span class="s2">\n  </span><span class="s1">opts.parent = options.parent;</span><span class="s2">\n  </span><span class="s1">opts._parentVnode = parentVnode;</span><span class="s2">\n  </span><span class="s1">var vnodeComponentOptions = parentVnode.componentOptions;</span><span class="s2">\n  </span><span class="s1">opts.propsData = vnodeComponentOptions.propsData;</span><span class="s2">\n  </span><span class="s1">opts._parentListeners = vnodeComponentOptions.listeners;</span><span class="s2">\n  </span><span class="s1">opts._renderChildren = vnodeComponentOptions.children;</span><span class="s2">\n  </span><span class="s1">opts._componentTag = vnodeComponentOptions.tag;</span><span class="s2">\n  </span><span class="s1">if (options.render) {</span><span class="s2">\n    </span><span class="s1">opts.render = options.render;</span><span class="s2">\n    </span><span class="s1">opts.staticRenderFns = options.staticRenderFns;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveConstructorOptions(Ctor) {</span><span class="s2">\n  </span><span class="s1">var options = Ctor.options;</span><span class="s2">\n  </span><span class="s1">if (Ctor.super) {</span><span class="s2">\n    </span><span class="s1">var superOptions = resolveConstructorOptions(Ctor.super);</span><span class="s2">\n    </span><span class="s1">var cachedSuperOptions = Ctor.superOptions;</span><span class="s2">\n    </span><span class="s1">if (superOptions !== cachedSuperOptions) {</span><span class="s2">\n      </span><span class="s1">// super option changed,</span><span class="s2">\n      </span><span class="s1">// need to resolve new options.</span><span class="s2">\n      </span><span class="s1">Ctor.superOptions = superOptions;</span><span class="s2">\n      </span><span class="s1">// check if there are any late-modified/attached options (#4976)</span><span class="s2">\n      </span><span class="s1">var modifiedOptions = resolveModifiedOptions(Ctor);</span><span class="s2">\n      </span><span class="s1">// update base extend options</span><span class="s2">\n      </span><span class="s1">if (modifiedOptions) {</span><span class="s2">\n        </span><span class="s1">extend(Ctor.extendOptions, modifiedOptions);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);</span><span class="s2">\n      </span><span class="s1">if (options.name) {</span><span class="s2">\n        </span><span class="s1">options.components[options.name] = Ctor;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return options;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveModifiedOptions(Ctor) {</span><span class="s2">\n  </span><span class="s1">var modified;</span><span class="s2">\n  </span><span class="s1">var latest = Ctor.options;</span><span class="s2">\n  </span><span class="s1">var sealed = Ctor.sealedOptions;</span><span class="s2">\n  </span><span class="s1">for (var key in latest) {</span><span class="s2">\n    </span><span class="s1">if (latest[key] !== sealed[key]) {</span><span class="s2">\n      </span><span class="s1">if (!modified) modified = {};</span><span class="s2">\n      </span><span class="s1">modified[key] = latest[key];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return modified;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function Vue(options) {</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue)) {</span><span class="s2">\n    </span><span class="s1">warn('Vue is a constructor and should be called with the `new` keyword');</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">this._init(options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">//@ts-expect-error Vue has function type</span><span class="s2">\n</span><span class="s1">initMixin$1(Vue);</span><span class="s2">\n</span><span class="s1">//@ts-expect-error Vue has function type</span><span class="s2">\n</span><span class="s1">stateMixin(Vue);</span><span class="s2">\n</span><span class="s1">//@ts-expect-error Vue has function type</span><span class="s2">\n</span><span class="s1">eventsMixin(Vue);</span><span class="s2">\n</span><span class="s1">//@ts-expect-error Vue has function type</span><span class="s2">\n</span><span class="s1">lifecycleMixin(Vue);</span><span class="s2">\n</span><span class="s1">//@ts-expect-error Vue has function type</span><span class="s2">\n</span><span class="s1">renderMixin(Vue);</span><span class="s2">\n</span><span class="s1">function initUse(Vue) {</span><span class="s2">\n  </span><span class="s1">Vue.use = function (plugin) {</span><span class="s2">\n    </span><span class="s1">var installedPlugins = this._installedPlugins || (this._installedPlugins = []);</span><span class="s2">\n    </span><span class="s1">if (installedPlugins.indexOf(plugin) &gt; -1) {</span><span class="s2">\n      </span><span class="s1">return this;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// additional parameters</span><span class="s2">\n    </span><span class="s1">var args = toArray(arguments, 1);</span><span class="s2">\n    </span><span class="s1">args.unshift(this);</span><span class="s2">\n    </span><span class="s1">if (isFunction(plugin.install)) {</span><span class="s2">\n      </span><span class="s1">plugin.install.apply(plugin, args);</span><span class="s2">\n    </span><span class="s1">} else if (isFunction(plugin)) {</span><span class="s2">\n      </span><span class="s1">plugin.apply(null, args);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">installedPlugins.push(plugin);</span><span class="s2">\n    </span><span class="s1">return this;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initMixin(Vue) {</span><span class="s2">\n  </span><span class="s1">Vue.mixin = function (mixin) {</span><span class="s2">\n    </span><span class="s1">this.options = mergeOptions(this.options, mixin);</span><span class="s2">\n    </span><span class="s1">return this;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initExtend(Vue) {</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Each instance constructor, including Vue, has a unique</span><span class="s2">\n   </span><span class="s1">* cid. This enables us to create wrapped </span><span class="s2">\&quot;</span><span class="s1">child</span><span class="s2">\n   </span><span class="s1">* constructors</span><span class="s2">\&quot; </span><span class="s1">for prototypal inheritance and cache them.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">Vue.cid = 0;</span><span class="s2">\n  </span><span class="s1">var cid = 1;</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Class inheritance</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">Vue.extend = function (extendOptions) {</span><span class="s2">\n    </span><span class="s1">extendOptions = extendOptions || {};</span><span class="s2">\n    </span><span class="s1">var Super = this;</span><span class="s2">\n    </span><span class="s1">var SuperId = Super.cid;</span><span class="s2">\n    </span><span class="s1">var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});</span><span class="s2">\n    </span><span class="s1">if (cachedCtors[SuperId]) {</span><span class="s2">\n      </span><span class="s1">return cachedCtors[SuperId];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var name = getComponentName(extendOptions) || getComponentName(Super.options);</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; name) {</span><span class="s2">\n      </span><span class="s1">validateComponentName(name);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var Sub = function VueComponent(options) {</span><span class="s2">\n      </span><span class="s1">this._init(options);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">Sub.prototype = Object.create(Super.prototype);</span><span class="s2">\n    </span><span class="s1">Sub.prototype.constructor = Sub;</span><span class="s2">\n    </span><span class="s1">Sub.cid = cid++;</span><span class="s2">\n    </span><span class="s1">Sub.options = mergeOptions(Super.options, extendOptions);</span><span class="s2">\n    </span><span class="s1">Sub['super'] = Super;</span><span class="s2">\n    </span><span class="s1">// For props and computed properties, we define the proxy getters on</span><span class="s2">\n    </span><span class="s1">// the Vue instances at extension time, on the extended prototype. This</span><span class="s2">\n    </span><span class="s1">// avoids Object.defineProperty calls for each instance created.</span><span class="s2">\n    </span><span class="s1">if (Sub.options.props) {</span><span class="s2">\n      </span><span class="s1">initProps(Sub);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (Sub.options.computed) {</span><span class="s2">\n      </span><span class="s1">initComputed(Sub);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// allow further extension/mixin/plugin usage</span><span class="s2">\n    </span><span class="s1">Sub.extend = Super.extend;</span><span class="s2">\n    </span><span class="s1">Sub.mixin = Super.mixin;</span><span class="s2">\n    </span><span class="s1">Sub.use = Super.use;</span><span class="s2">\n    </span><span class="s1">// create asset registers, so extended classes</span><span class="s2">\n    </span><span class="s1">// can have their private assets too.</span><span class="s2">\n    </span><span class="s1">ASSET_TYPES.forEach(function (type) {</span><span class="s2">\n      </span><span class="s1">Sub[type] = Super[type];</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">// enable recursive self-lookup</span><span class="s2">\n    </span><span class="s1">if (name) {</span><span class="s2">\n      </span><span class="s1">Sub.options.components[name] = Sub;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// keep a reference to the super options at extension time.</span><span class="s2">\n    </span><span class="s1">// later at instantiation we can check if Super's options have</span><span class="s2">\n    </span><span class="s1">// been updated.</span><span class="s2">\n    </span><span class="s1">Sub.superOptions = Super.options;</span><span class="s2">\n    </span><span class="s1">Sub.extendOptions = extendOptions;</span><span class="s2">\n    </span><span class="s1">Sub.sealedOptions = extend({}, Sub.options);</span><span class="s2">\n    </span><span class="s1">// cache constructor</span><span class="s2">\n    </span><span class="s1">cachedCtors[SuperId] = Sub;</span><span class="s2">\n    </span><span class="s1">return Sub;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initProps(Comp) {</span><span class="s2">\n  </span><span class="s1">var props = Comp.options.props;</span><span class="s2">\n  </span><span class="s1">for (var key in props) {</span><span class="s2">\n    </span><span class="s1">proxy(Comp.prototype, </span><span class="s2">\&quot;</span><span class="s1">_props</span><span class="s2">\&quot;</span><span class="s1">, key);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initComputed(Comp) {</span><span class="s2">\n  </span><span class="s1">var computed = Comp.options.computed;</span><span class="s2">\n  </span><span class="s1">for (var key in computed) {</span><span class="s2">\n    </span><span class="s1">defineComputed(Comp.prototype, key, computed[key]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initAssetRegisters(Vue) {</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Create asset registration methods.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ASSET_TYPES.forEach(function (type) {</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error function is not exact same type</span><span class="s2">\n    </span><span class="s1">Vue[type] = function (id, definition) {</span><span class="s2">\n      </span><span class="s1">if (!definition) {</span><span class="s2">\n        </span><span class="s1">return this.options[type + 's'][id];</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; type === 'component') {</span><span class="s2">\n          </span><span class="s1">validateComponentName(id);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (type === 'component' &amp;&amp; isPlainObject(definition)) {</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error</span><span class="s2">\n          </span><span class="s1">definition.name = definition.name || id;</span><span class="s2">\n          </span><span class="s1">definition = this.options._base.extend(definition);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (type === 'directive' &amp;&amp; isFunction(definition)) {</span><span class="s2">\n          </span><span class="s1">definition = {</span><span class="s2">\n            </span><span class="s1">bind: definition,</span><span class="s2">\n            </span><span class="s1">update: definition</span><span class="s2">\n          </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.options[type + 's'][id] = definition;</span><span class="s2">\n        </span><span class="s1">return definition;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function _getComponentName(opts) {</span><span class="s2">\n  </span><span class="s1">return opts &amp;&amp; (getComponentName(opts.Ctor.options) || opts.tag);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function matches(pattern, name) {</span><span class="s2">\n  </span><span class="s1">if (isArray(pattern)) {</span><span class="s2">\n    </span><span class="s1">return pattern.indexOf(name) &gt; -1;</span><span class="s2">\n  </span><span class="s1">} else if (typeof pattern === 'string') {</span><span class="s2">\n    </span><span class="s1">return pattern.split(',').indexOf(name) &gt; -1;</span><span class="s2">\n  </span><span class="s1">} else if (isRegExp(pattern)) {</span><span class="s2">\n    </span><span class="s1">return pattern.test(name);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n  </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function pruneCache(keepAliveInstance, filter) {</span><span class="s2">\n  </span><span class="s1">var cache = keepAliveInstance.cache,</span><span class="s2">\n    </span><span class="s1">keys = keepAliveInstance.keys,</span><span class="s2">\n    </span><span class="s1">_vnode = keepAliveInstance._vnode;</span><span class="s2">\n  </span><span class="s1">for (var key in cache) {</span><span class="s2">\n    </span><span class="s1">var entry = cache[key];</span><span class="s2">\n    </span><span class="s1">if (entry) {</span><span class="s2">\n      </span><span class="s1">var name_1 = entry.name;</span><span class="s2">\n      </span><span class="s1">if (name_1 &amp;&amp; !filter(name_1)) {</span><span class="s2">\n        </span><span class="s1">pruneCacheEntry(cache, key, keys, _vnode);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function pruneCacheEntry(cache, key, keys, current) {</span><span class="s2">\n  </span><span class="s1">var entry = cache[key];</span><span class="s2">\n  </span><span class="s1">if (entry &amp;&amp; (!current || entry.tag !== current.tag)) {</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error can be undefined</span><span class="s2">\n    </span><span class="s1">entry.componentInstance.$destroy();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">cache[key] = null;</span><span class="s2">\n  </span><span class="s1">remove$2(keys, key);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var patternTypes = [String, RegExp, Array];</span><span class="s2">\n</span><span class="s1">// TODO defineComponent</span><span class="s2">\n</span><span class="s1">var KeepAlive = {</span><span class="s2">\n  </span><span class="s1">name: 'keep-alive',</span><span class="s2">\n  </span><span class="s1">abstract: true,</span><span class="s2">\n  </span><span class="s1">props: {</span><span class="s2">\n    </span><span class="s1">include: patternTypes,</span><span class="s2">\n    </span><span class="s1">exclude: patternTypes,</span><span class="s2">\n    </span><span class="s1">max: [String, Number]</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">methods: {</span><span class="s2">\n    </span><span class="s1">cacheVNode: function () {</span><span class="s2">\n      </span><span class="s1">var _a = this,</span><span class="s2">\n        </span><span class="s1">cache = _a.cache,</span><span class="s2">\n        </span><span class="s1">keys = _a.keys,</span><span class="s2">\n        </span><span class="s1">vnodeToCache = _a.vnodeToCache,</span><span class="s2">\n        </span><span class="s1">keyToCache = _a.keyToCache;</span><span class="s2">\n      </span><span class="s1">if (vnodeToCache) {</span><span class="s2">\n        </span><span class="s1">var tag = vnodeToCache.tag,</span><span class="s2">\n          </span><span class="s1">componentInstance = vnodeToCache.componentInstance,</span><span class="s2">\n          </span><span class="s1">componentOptions = vnodeToCache.componentOptions;</span><span class="s2">\n        </span><span class="s1">cache[keyToCache] = {</span><span class="s2">\n          </span><span class="s1">name: _getComponentName(componentOptions),</span><span class="s2">\n          </span><span class="s1">tag: tag,</span><span class="s2">\n          </span><span class="s1">componentInstance: componentInstance</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">keys.push(keyToCache);</span><span class="s2">\n        </span><span class="s1">// prune oldest entry</span><span class="s2">\n        </span><span class="s1">if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) {</span><span class="s2">\n          </span><span class="s1">pruneCacheEntry(cache, keys[0], keys, this._vnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.vnodeToCache = null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">created: function () {</span><span class="s2">\n    </span><span class="s1">this.cache = Object.create(null);</span><span class="s2">\n    </span><span class="s1">this.keys = [];</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">destroyed: function () {</span><span class="s2">\n    </span><span class="s1">for (var key in this.cache) {</span><span class="s2">\n      </span><span class="s1">pruneCacheEntry(this.cache, key, this.keys);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">mounted: function () {</span><span class="s2">\n    </span><span class="s1">var _this = this;</span><span class="s2">\n    </span><span class="s1">this.cacheVNode();</span><span class="s2">\n    </span><span class="s1">this.$watch('include', function (val) {</span><span class="s2">\n      </span><span class="s1">pruneCache(_this, function (name) {</span><span class="s2">\n        </span><span class="s1">return matches(val, name);</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">this.$watch('exclude', function (val) {</span><span class="s2">\n      </span><span class="s1">pruneCache(_this, function (name) {</span><span class="s2">\n        </span><span class="s1">return !matches(val, name);</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">updated: function () {</span><span class="s2">\n    </span><span class="s1">this.cacheVNode();</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">render: function () {</span><span class="s2">\n    </span><span class="s1">var slot = this.$slots.default;</span><span class="s2">\n    </span><span class="s1">var vnode = getFirstComponentChild(slot);</span><span class="s2">\n    </span><span class="s1">var componentOptions = vnode &amp;&amp; vnode.componentOptions;</span><span class="s2">\n    </span><span class="s1">if (componentOptions) {</span><span class="s2">\n      </span><span class="s1">// check pattern</span><span class="s2">\n      </span><span class="s1">var name_2 = _getComponentName(componentOptions);</span><span class="s2">\n      </span><span class="s1">var _a = this,</span><span class="s2">\n        </span><span class="s1">include = _a.include,</span><span class="s2">\n        </span><span class="s1">exclude = _a.exclude;</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">// not included</span><span class="s2">\n      </span><span class="s1">include &amp;&amp; (!name_2 || !matches(include, name_2)) ||</span><span class="s2">\n      </span><span class="s1">// excluded</span><span class="s2">\n      </span><span class="s1">exclude &amp;&amp; name_2 &amp;&amp; matches(exclude, name_2)) {</span><span class="s2">\n        </span><span class="s1">return vnode;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">var _b = this,</span><span class="s2">\n        </span><span class="s1">cache = _b.cache,</span><span class="s2">\n        </span><span class="s1">keys = _b.keys;</span><span class="s2">\n      </span><span class="s1">var key = vnode.key == null ?</span><span class="s2">\n      </span><span class="s1">// same constructor may get registered as different local components</span><span class="s2">\n      </span><span class="s1">// so cid alone is not enough (#3269)</span><span class="s2">\n      </span><span class="s1">componentOptions.Ctor.cid + (componentOptions.tag ? </span><span class="s2">\&quot;</span><span class="s1">::</span><span class="s2">\&quot;</span><span class="s1">.concat(componentOptions.tag) : '') : vnode.key;</span><span class="s2">\n      </span><span class="s1">if (cache[key]) {</span><span class="s2">\n        </span><span class="s1">vnode.componentInstance = cache[key].componentInstance;</span><span class="s2">\n        </span><span class="s1">// make current key freshest</span><span class="s2">\n        </span><span class="s1">remove$2(keys, key);</span><span class="s2">\n        </span><span class="s1">keys.push(key);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">// delay setting the cache until update</span><span class="s2">\n        </span><span class="s1">this.vnodeToCache = vnode;</span><span class="s2">\n        </span><span class="s1">this.keyToCache = key;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error can vnode.data can be undefined</span><span class="s2">\n      </span><span class="s1">vnode.data.keepAlive = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return vnode || slot &amp;&amp; slot[0];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var builtInComponents = {</span><span class="s2">\n  </span><span class="s1">KeepAlive: KeepAlive</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function initGlobalAPI(Vue) {</span><span class="s2">\n  </span><span class="s1">// config</span><span class="s2">\n  </span><span class="s1">var configDef = {};</span><span class="s2">\n  </span><span class="s1">configDef.get = function () {</span><span class="s2">\n    </span><span class="s1">return config;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">configDef.set = function () {</span><span class="s2">\n      </span><span class="s1">warn('Do not replace the Vue.config object, set individual fields instead.');</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">Object.defineProperty(Vue, 'config', configDef);</span><span class="s2">\n  </span><span class="s1">// exposed util methods.</span><span class="s2">\n  </span><span class="s1">// NOTE: these are not considered part of the public API - avoid relying on</span><span class="s2">\n  </span><span class="s1">// them unless you are aware of the risk.</span><span class="s2">\n  </span><span class="s1">Vue.util = {</span><span class="s2">\n    </span><span class="s1">warn: warn,</span><span class="s2">\n    </span><span class="s1">extend: extend,</span><span class="s2">\n    </span><span class="s1">mergeOptions: mergeOptions,</span><span class="s2">\n    </span><span class="s1">defineReactive: defineReactive</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">Vue.set = set;</span><span class="s2">\n  </span><span class="s1">Vue.delete = del;</span><span class="s2">\n  </span><span class="s1">Vue.nextTick = nextTick;</span><span class="s2">\n  </span><span class="s1">// 2.6 explicit observable API</span><span class="s2">\n  </span><span class="s1">Vue.observable = function (obj) {</span><span class="s2">\n    </span><span class="s1">observe(obj);</span><span class="s2">\n    </span><span class="s1">return obj;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">Vue.options = Object.create(null);</span><span class="s2">\n  </span><span class="s1">ASSET_TYPES.forEach(function (type) {</span><span class="s2">\n    </span><span class="s1">Vue.options[type + 's'] = Object.create(null);</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">// this is used to identify the </span><span class="s2">\&quot;</span><span class="s1">base</span><span class="s2">\&quot; </span><span class="s1">constructor to extend all plain-object</span><span class="s2">\n  </span><span class="s1">// components with in Weex's multi-instance scenarios.</span><span class="s2">\n  </span><span class="s1">Vue.options._base = Vue;</span><span class="s2">\n  </span><span class="s1">extend(Vue.options.components, builtInComponents);</span><span class="s2">\n  </span><span class="s1">initUse(Vue);</span><span class="s2">\n  </span><span class="s1">initMixin(Vue);</span><span class="s2">\n  </span><span class="s1">initExtend(Vue);</span><span class="s2">\n  </span><span class="s1">initAssetRegisters(Vue);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">initGlobalAPI(Vue);</span><span class="s2">\n</span><span class="s1">Object.defineProperty(Vue.prototype, '$isServer', {</span><span class="s2">\n  </span><span class="s1">get: isServerRendering</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">Object.defineProperty(Vue.prototype, '$ssrContext', {</span><span class="s2">\n  </span><span class="s1">get: function () {</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n    </span><span class="s1">return this.$vnode &amp;&amp; this.$vnode.ssrContext;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">// expose FunctionalRenderContext for ssr runtime helper installation</span><span class="s2">\n</span><span class="s1">Object.defineProperty(Vue, 'FunctionalRenderContext', {</span><span class="s2">\n  </span><span class="s1">value: FunctionalRenderContext</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">Vue.version = version;</span><span class="s2">\n\n</span><span class="s1">// these are reserved for web because they are directly compiled away</span><span class="s2">\n</span><span class="s1">// during template compilation</span><span class="s2">\n</span><span class="s1">var isReservedAttr = makeMap('style,class');</span><span class="s2">\n</span><span class="s1">// attributes that should be using props for binding</span><span class="s2">\n</span><span class="s1">var acceptValue = makeMap('input,textarea,option,select,progress');</span><span class="s2">\n</span><span class="s1">var mustUseProp = function (tag, type, attr) {</span><span class="s2">\n  </span><span class="s1">return attr === 'value' &amp;&amp; acceptValue(tag) &amp;&amp; type !== 'button' || attr === 'selected' &amp;&amp; tag === 'option' || attr === 'checked' &amp;&amp; tag === 'input' || attr === 'muted' &amp;&amp; tag === 'video';</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');</span><span class="s2">\n</span><span class="s1">var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');</span><span class="s2">\n</span><span class="s1">var convertEnumeratedValue = function (key, value) {</span><span class="s2">\n  </span><span class="s1">return isFalsyAttrValue(value) || value === 'false' ? 'false' :</span><span class="s2">\n  </span><span class="s1">// allow arbitrary string value for contenteditable</span><span class="s2">\n  </span><span class="s1">key === 'contenteditable' &amp;&amp; isValidContentEditableValue(value) ? value : 'true';</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,' + 'truespeed,typemustmatch,visible');</span><span class="s2">\n</span><span class="s1">var xlinkNS = 'http://www.w3.org/1999/xlink';</span><span class="s2">\n</span><span class="s1">var isXlink = function (name) {</span><span class="s2">\n  </span><span class="s1">return name.charAt(5) === ':' &amp;&amp; name.slice(0, 5) === 'xlink';</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var getXlinkProp = function (name) {</span><span class="s2">\n  </span><span class="s1">return isXlink(name) ? name.slice(6, name.length) : '';</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var isFalsyAttrValue = function (val) {</span><span class="s2">\n  </span><span class="s1">return val == null || val === false;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function genClassForVnode(vnode) {</span><span class="s2">\n  </span><span class="s1">var data = vnode.data;</span><span class="s2">\n  </span><span class="s1">var parentNode = vnode;</span><span class="s2">\n  </span><span class="s1">var childNode = vnode;</span><span class="s2">\n  </span><span class="s1">while (isDef(childNode.componentInstance)) {</span><span class="s2">\n    </span><span class="s1">childNode = childNode.componentInstance._vnode;</span><span class="s2">\n    </span><span class="s1">if (childNode &amp;&amp; childNode.data) {</span><span class="s2">\n      </span><span class="s1">data = mergeClassData(childNode.data, data);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error parentNode.parent not VNodeWithData</span><span class="s2">\n  </span><span class="s1">while (isDef(parentNode = parentNode.parent)) {</span><span class="s2">\n    </span><span class="s1">if (parentNode &amp;&amp; parentNode.data) {</span><span class="s2">\n      </span><span class="s1">data = mergeClassData(data, parentNode.data);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return renderClass(data.staticClass, data.class);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mergeClassData(child, parent) {</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">staticClass: concat(child.staticClass, parent.staticClass),</span><span class="s2">\n    </span><span class="s1">class: isDef(child.class) ? [child.class, parent.class] : parent.class</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function renderClass(staticClass, dynamicClass) {</span><span class="s2">\n  </span><span class="s1">if (isDef(staticClass) || isDef(dynamicClass)) {</span><span class="s2">\n    </span><span class="s1">return concat(staticClass, stringifyClass(dynamicClass));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n  </span><span class="s1">return '';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function concat(a, b) {</span><span class="s2">\n  </span><span class="s1">return a ? b ? a + ' ' + b : a : b || '';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stringifyClass(value) {</span><span class="s2">\n  </span><span class="s1">if (Array.isArray(value)) {</span><span class="s2">\n    </span><span class="s1">return stringifyArray(value);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isObject(value)) {</span><span class="s2">\n    </span><span class="s1">return stringifyObject(value);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (typeof value === 'string') {</span><span class="s2">\n    </span><span class="s1">return value;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n  </span><span class="s1">return '';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stringifyArray(value) {</span><span class="s2">\n  </span><span class="s1">var res = '';</span><span class="s2">\n  </span><span class="s1">var stringified;</span><span class="s2">\n  </span><span class="s1">for (var i = 0, l = value.length; i &lt; l; i++) {</span><span class="s2">\n    </span><span class="s1">if (isDef(stringified = stringifyClass(value[i])) &amp;&amp; stringified !== '') {</span><span class="s2">\n      </span><span class="s1">if (res) res += ' ';</span><span class="s2">\n      </span><span class="s1">res += stringified;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stringifyObject(value) {</span><span class="s2">\n  </span><span class="s1">var res = '';</span><span class="s2">\n  </span><span class="s1">for (var key in value) {</span><span class="s2">\n    </span><span class="s1">if (value[key]) {</span><span class="s2">\n      </span><span class="s1">if (res) res += ' ';</span><span class="s2">\n      </span><span class="s1">res += key;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var namespaceMap = {</span><span class="s2">\n  </span><span class="s1">svg: 'http://www.w3.org/2000/svg',</span><span class="s2">\n  </span><span class="s1">math: 'http://www.w3.org/1998/Math/MathML'</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');</span><span class="s2">\n</span><span class="s1">// this map is intentionally selective, only covering SVG elements that may</span><span class="s2">\n</span><span class="s1">// contain child elements.</span><span class="s2">\n</span><span class="s1">var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);</span><span class="s2">\n</span><span class="s1">var isReservedTag = function (tag) {</span><span class="s2">\n  </span><span class="s1">return isHTMLTag(tag) || isSVG(tag);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function getTagNamespace(tag) {</span><span class="s2">\n  </span><span class="s1">if (isSVG(tag)) {</span><span class="s2">\n    </span><span class="s1">return 'svg';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// basic support for MathML</span><span class="s2">\n  </span><span class="s1">// note it doesn't support other MathML elements being component roots</span><span class="s2">\n  </span><span class="s1">if (tag === 'math') {</span><span class="s2">\n    </span><span class="s1">return 'math';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var unknownElementCache = Object.create(null);</span><span class="s2">\n</span><span class="s1">function isUnknownElement(tag) {</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (!inBrowser) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isReservedTag(tag)) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">tag = tag.toLowerCase();</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (unknownElementCache[tag] != null) {</span><span class="s2">\n    </span><span class="s1">return unknownElementCache[tag];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var el = document.createElement(tag);</span><span class="s2">\n  </span><span class="s1">if (tag.indexOf('-') &gt; -1) {</span><span class="s2">\n    </span><span class="s1">// http://stackoverflow.com/a/28210364/1070244</span><span class="s2">\n    </span><span class="s1">return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var isTextInputType = makeMap('text,number,password,search,email,tel,url');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Query an element selector if it's not an element already.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function query(el) {</span><span class="s2">\n  </span><span class="s1">if (typeof el === 'string') {</span><span class="s2">\n    </span><span class="s1">var selected = document.querySelector(el);</span><span class="s2">\n    </span><span class="s1">if (!selected) {</span><span class="s2">\n      </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn('Cannot find element: ' + el);</span><span class="s2">\n      </span><span class="s1">return document.createElement('div');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return selected;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return el;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createElement(tagName, vnode) {</span><span class="s2">\n  </span><span class="s1">var elm = document.createElement(tagName);</span><span class="s2">\n  </span><span class="s1">if (tagName !== 'select') {</span><span class="s2">\n    </span><span class="s1">return elm;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// false or null will remove the attribute but undefined will not</span><span class="s2">\n  </span><span class="s1">if (vnode.data &amp;&amp; vnode.data.attrs &amp;&amp; vnode.data.attrs.multiple !== undefined) {</span><span class="s2">\n    </span><span class="s1">elm.setAttribute('multiple', 'multiple');</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return elm;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createElementNS(namespace, tagName) {</span><span class="s2">\n  </span><span class="s1">return document.createElementNS(namespaceMap[namespace], tagName);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createTextNode(text) {</span><span class="s2">\n  </span><span class="s1">return document.createTextNode(text);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createComment(text) {</span><span class="s2">\n  </span><span class="s1">return document.createComment(text);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function insertBefore(parentNode, newNode, referenceNode) {</span><span class="s2">\n  </span><span class="s1">parentNode.insertBefore(newNode, referenceNode);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function removeChild(node, child) {</span><span class="s2">\n  </span><span class="s1">node.removeChild(child);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function appendChild(node, child) {</span><span class="s2">\n  </span><span class="s1">node.appendChild(child);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function parentNode(node) {</span><span class="s2">\n  </span><span class="s1">return node.parentNode;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function nextSibling(node) {</span><span class="s2">\n  </span><span class="s1">return node.nextSibling;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function tagName(node) {</span><span class="s2">\n  </span><span class="s1">return node.tagName;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setTextContent(node, text) {</span><span class="s2">\n  </span><span class="s1">node.textContent = text;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setStyleScope(node, scopeId) {</span><span class="s2">\n  </span><span class="s1">node.setAttribute(scopeId, '');</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var nodeOps = /*#__PURE__*/Object.freeze({</span><span class="s2">\n  </span><span class="s1">__proto__: null,</span><span class="s2">\n  </span><span class="s1">createElement: createElement,</span><span class="s2">\n  </span><span class="s1">createElementNS: createElementNS,</span><span class="s2">\n  </span><span class="s1">createTextNode: createTextNode,</span><span class="s2">\n  </span><span class="s1">createComment: createComment,</span><span class="s2">\n  </span><span class="s1">insertBefore: insertBefore,</span><span class="s2">\n  </span><span class="s1">removeChild: removeChild,</span><span class="s2">\n  </span><span class="s1">appendChild: appendChild,</span><span class="s2">\n  </span><span class="s1">parentNode: parentNode,</span><span class="s2">\n  </span><span class="s1">nextSibling: nextSibling,</span><span class="s2">\n  </span><span class="s1">tagName: tagName,</span><span class="s2">\n  </span><span class="s1">setTextContent: setTextContent,</span><span class="s2">\n  </span><span class="s1">setStyleScope: setStyleScope</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">var ref = {</span><span class="s2">\n  </span><span class="s1">create: function (_, vnode) {</span><span class="s2">\n    </span><span class="s1">registerRef(vnode);</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">update: function (oldVnode, vnode) {</span><span class="s2">\n    </span><span class="s1">if (oldVnode.data.ref !== vnode.data.ref) {</span><span class="s2">\n      </span><span class="s1">registerRef(oldVnode, true);</span><span class="s2">\n      </span><span class="s1">registerRef(vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">destroy: function (vnode) {</span><span class="s2">\n    </span><span class="s1">registerRef(vnode, true);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function registerRef(vnode, isRemoval) {</span><span class="s2">\n  </span><span class="s1">var ref = vnode.data.ref;</span><span class="s2">\n  </span><span class="s1">if (!isDef(ref)) return;</span><span class="s2">\n  </span><span class="s1">var vm = vnode.context;</span><span class="s2">\n  </span><span class="s1">var refValue = vnode.componentInstance || vnode.elm;</span><span class="s2">\n  </span><span class="s1">var value = isRemoval ? null : refValue;</span><span class="s2">\n  </span><span class="s1">var $refsValue = isRemoval ? undefined : refValue;</span><span class="s2">\n  </span><span class="s1">if (isFunction(ref)) {</span><span class="s2">\n    </span><span class="s1">invokeWithErrorHandling(ref, vm, [value], vm, </span><span class="s2">\&quot;</span><span class="s1">template ref function</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var isFor = vnode.data.refInFor;</span><span class="s2">\n  </span><span class="s1">var _isString = typeof ref === 'string' || typeof ref === 'number';</span><span class="s2">\n  </span><span class="s1">var _isRef = isRef(ref);</span><span class="s2">\n  </span><span class="s1">var refs = vm.$refs;</span><span class="s2">\n  </span><span class="s1">if (_isString || _isRef) {</span><span class="s2">\n    </span><span class="s1">if (isFor) {</span><span class="s2">\n      </span><span class="s1">var existing = _isString ? refs[ref] : ref.value;</span><span class="s2">\n      </span><span class="s1">if (isRemoval) {</span><span class="s2">\n        </span><span class="s1">isArray(existing) &amp;&amp; remove$2(existing, refValue);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">if (!isArray(existing)) {</span><span class="s2">\n          </span><span class="s1">if (_isString) {</span><span class="s2">\n            </span><span class="s1">refs[ref] = [refValue];</span><span class="s2">\n            </span><span class="s1">setSetupRef(vm, ref, refs[ref]);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">ref.value = [refValue];</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} else if (!existing.includes(refValue)) {</span><span class="s2">\n          </span><span class="s1">existing.push(refValue);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (_isString) {</span><span class="s2">\n      </span><span class="s1">if (isRemoval &amp;&amp; refs[ref] !== refValue) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">refs[ref] = $refsValue;</span><span class="s2">\n      </span><span class="s1">setSetupRef(vm, ref, value);</span><span class="s2">\n    </span><span class="s1">} else if (_isRef) {</span><span class="s2">\n      </span><span class="s1">if (isRemoval &amp;&amp; ref.value !== refValue) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">ref.value = value;</span><span class="s2">\n    </span><span class="s1">} else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Invalid template ref type: </span><span class="s2">\&quot;</span><span class="s1">.concat(typeof ref));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setSetupRef(_a, key, val) {</span><span class="s2">\n  </span><span class="s1">var _setupState = _a._setupState;</span><span class="s2">\n  </span><span class="s1">if (_setupState &amp;&amp; hasOwn(_setupState, key)) {</span><span class="s2">\n    </span><span class="s1">if (isRef(_setupState[key])) {</span><span class="s2">\n      </span><span class="s1">_setupState[key].value = val;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">_setupState[key] = val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Virtual DOM patching algorithm based on Snabbdom by</span><span class="s2">\n </span><span class="s1">* Simon Friis Vindum (@paldepind)</span><span class="s2">\n </span><span class="s1">* Licensed under the MIT License</span><span class="s2">\n </span><span class="s1">* https://github.com/paldepind/snabbdom/blob/master/LICENSE</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* modified by Evan You (@yyx990803)</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Not type-checking this because this file is perf-critical and the cost</span><span class="s2">\n </span><span class="s1">* of making flow understand it is not worth it.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var emptyNode = new VNode('', {}, []);</span><span class="s2">\n</span><span class="s1">var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];</span><span class="s2">\n</span><span class="s1">function sameVnode(a, b) {</span><span class="s2">\n  </span><span class="s1">return a.key === b.key &amp;&amp; a.asyncFactory === b.asyncFactory &amp;&amp; (a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) &amp;&amp; isUndef(b.asyncFactory.error));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function sameInputType(a, b) {</span><span class="s2">\n  </span><span class="s1">if (a.tag !== 'input') return true;</span><span class="s2">\n  </span><span class="s1">var i;</span><span class="s2">\n  </span><span class="s1">var typeA = isDef(i = a.data) &amp;&amp; isDef(i = i.attrs) &amp;&amp; i.type;</span><span class="s2">\n  </span><span class="s1">var typeB = isDef(i = b.data) &amp;&amp; isDef(i = i.attrs) &amp;&amp; i.type;</span><span class="s2">\n  </span><span class="s1">return typeA === typeB || isTextInputType(typeA) &amp;&amp; isTextInputType(typeB);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createKeyToOldIdx(children, beginIdx, endIdx) {</span><span class="s2">\n  </span><span class="s1">var i, key;</span><span class="s2">\n  </span><span class="s1">var map = {};</span><span class="s2">\n  </span><span class="s1">for (i = beginIdx; i &lt;= endIdx; ++i) {</span><span class="s2">\n    </span><span class="s1">key = children[i].key;</span><span class="s2">\n    </span><span class="s1">if (isDef(key)) map[key] = i;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return map;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createPatchFunction(backend) {</span><span class="s2">\n  </span><span class="s1">var i, j;</span><span class="s2">\n  </span><span class="s1">var cbs = {};</span><span class="s2">\n  </span><span class="s1">var modules = backend.modules,</span><span class="s2">\n    </span><span class="s1">nodeOps = backend.nodeOps;</span><span class="s2">\n  </span><span class="s1">for (i = 0; i &lt; hooks.length; ++i) {</span><span class="s2">\n    </span><span class="s1">cbs[hooks[i]] = [];</span><span class="s2">\n    </span><span class="s1">for (j = 0; j &lt; modules.length; ++j) {</span><span class="s2">\n      </span><span class="s1">if (isDef(modules[j][hooks[i]])) {</span><span class="s2">\n        </span><span class="s1">cbs[hooks[i]].push(modules[j][hooks[i]]);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function emptyNodeAt(elm) {</span><span class="s2">\n    </span><span class="s1">return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function createRmCb(childElm, listeners) {</span><span class="s2">\n    </span><span class="s1">function remove() {</span><span class="s2">\n      </span><span class="s1">if (--remove.listeners === 0) {</span><span class="s2">\n        </span><span class="s1">removeNode(childElm);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">remove.listeners = listeners;</span><span class="s2">\n    </span><span class="s1">return remove;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function removeNode(el) {</span><span class="s2">\n    </span><span class="s1">var parent = nodeOps.parentNode(el);</span><span class="s2">\n    </span><span class="s1">// element may have already been removed due to v-html / v-text</span><span class="s2">\n    </span><span class="s1">if (isDef(parent)) {</span><span class="s2">\n      </span><span class="s1">nodeOps.removeChild(parent, el);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function isUnknownElement(vnode, inVPre) {</span><span class="s2">\n    </span><span class="s1">return !inVPre &amp;&amp; !vnode.ns &amp;&amp; !(config.ignoredElements.length &amp;&amp; config.ignoredElements.some(function (ignore) {</span><span class="s2">\n      </span><span class="s1">return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;</span><span class="s2">\n    </span><span class="s1">})) &amp;&amp; config.isUnknownElement(vnode.tag);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var creatingElmInVPre = 0;</span><span class="s2">\n  </span><span class="s1">function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {</span><span class="s2">\n    </span><span class="s1">if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) {</span><span class="s2">\n      </span><span class="s1">// This vnode was used in a previous render!</span><span class="s2">\n      </span><span class="s1">// now it's used as a new node, overwriting its elm would cause</span><span class="s2">\n      </span><span class="s1">// potential patch errors down the road when it's used as an insertion</span><span class="s2">\n      </span><span class="s1">// reference node. Instead, we clone the node on-demand before creating</span><span class="s2">\n      </span><span class="s1">// associated DOM element for it.</span><span class="s2">\n      </span><span class="s1">vnode = ownerArray[index] = cloneVNode(vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">vnode.isRootInsert = !nested; // for transition enter check</span><span class="s2">\n    </span><span class="s1">if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var data = vnode.data;</span><span class="s2">\n    </span><span class="s1">var children = vnode.children;</span><span class="s2">\n    </span><span class="s1">var tag = vnode.tag;</span><span class="s2">\n    </span><span class="s1">if (isDef(tag)) {</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">if (data &amp;&amp; data.pre) {</span><span class="s2">\n          </span><span class="s1">creatingElmInVPre++;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isUnknownElement(vnode, creatingElmInVPre)) {</span><span class="s2">\n          </span><span class="s1">warn('Unknown custom element: &lt;' + tag + '&gt; - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the </span><span class="s2">\&quot;</span><span class="s1">name</span><span class="s2">\&quot; </span><span class="s1">option.', vnode.context);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);</span><span class="s2">\n      </span><span class="s1">setScope(vnode);</span><span class="s2">\n      </span><span class="s1">createChildren(vnode, children, insertedVnodeQueue);</span><span class="s2">\n      </span><span class="s1">if (isDef(data)) {</span><span class="s2">\n        </span><span class="s1">invokeCreateHooks(vnode, insertedVnodeQueue);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">insert(parentElm, vnode.elm, refElm);</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; data &amp;&amp; data.pre) {</span><span class="s2">\n        </span><span class="s1">creatingElmInVPre--;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (isTrue(vnode.isComment)) {</span><span class="s2">\n      </span><span class="s1">vnode.elm = nodeOps.createComment(vnode.text);</span><span class="s2">\n      </span><span class="s1">insert(parentElm, vnode.elm, refElm);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">vnode.elm = nodeOps.createTextNode(vnode.text);</span><span class="s2">\n      </span><span class="s1">insert(parentElm, vnode.elm, refElm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {</span><span class="s2">\n    </span><span class="s1">var i = vnode.data;</span><span class="s2">\n    </span><span class="s1">if (isDef(i)) {</span><span class="s2">\n      </span><span class="s1">var isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive;</span><span class="s2">\n      </span><span class="s1">if (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) {</span><span class="s2">\n        </span><span class="s1">i(vnode, false /* hydrating */);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">// after calling the init hook, if the vnode is a child component</span><span class="s2">\n      </span><span class="s1">// it should've created a child instance and mounted it. the child</span><span class="s2">\n      </span><span class="s1">// component also has set the placeholder vnode's elm.</span><span class="s2">\n      </span><span class="s1">// in that case we can just return the element and be done.</span><span class="s2">\n      </span><span class="s1">if (isDef(vnode.componentInstance)) {</span><span class="s2">\n        </span><span class="s1">initComponent(vnode, insertedVnodeQueue);</span><span class="s2">\n        </span><span class="s1">insert(parentElm, vnode.elm, refElm);</span><span class="s2">\n        </span><span class="s1">if (isTrue(isReactivated)) {</span><span class="s2">\n          </span><span class="s1">reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function initComponent(vnode, insertedVnodeQueue) {</span><span class="s2">\n    </span><span class="s1">if (isDef(vnode.data.pendingInsert)) {</span><span class="s2">\n      </span><span class="s1">insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);</span><span class="s2">\n      </span><span class="s1">vnode.data.pendingInsert = null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">vnode.elm = vnode.componentInstance.$el;</span><span class="s2">\n    </span><span class="s1">if (isPatchable(vnode)) {</span><span class="s2">\n      </span><span class="s1">invokeCreateHooks(vnode, insertedVnodeQueue);</span><span class="s2">\n      </span><span class="s1">setScope(vnode);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">// empty component root.</span><span class="s2">\n      </span><span class="s1">// skip all element-related modules except for ref (#3455)</span><span class="s2">\n      </span><span class="s1">registerRef(vnode);</span><span class="s2">\n      </span><span class="s1">// make sure to invoke the insert hook</span><span class="s2">\n      </span><span class="s1">insertedVnodeQueue.push(vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {</span><span class="s2">\n    </span><span class="s1">var i;</span><span class="s2">\n    </span><span class="s1">// hack for #4339: a reactivated component with inner transition</span><span class="s2">\n    </span><span class="s1">// does not trigger because the inner node's created hooks are not called</span><span class="s2">\n    </span><span class="s1">// again. It's not ideal to involve module-specific logic in here but</span><span class="s2">\n    </span><span class="s1">// there doesn't seem to be a better way to do it.</span><span class="s2">\n    </span><span class="s1">var innerNode = vnode;</span><span class="s2">\n    </span><span class="s1">while (innerNode.componentInstance) {</span><span class="s2">\n      </span><span class="s1">innerNode = innerNode.componentInstance._vnode;</span><span class="s2">\n      </span><span class="s1">if (isDef(i = innerNode.data) &amp;&amp; isDef(i = i.transition)) {</span><span class="s2">\n        </span><span class="s1">for (i = 0; i &lt; cbs.activate.length; ++i) {</span><span class="s2">\n          </span><span class="s1">cbs.activate[i](emptyNode, innerNode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">insertedVnodeQueue.push(innerNode);</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// unlike a newly created component,</span><span class="s2">\n    </span><span class="s1">// a reactivated keep-alive component doesn't insert itself</span><span class="s2">\n    </span><span class="s1">insert(parentElm, vnode.elm, refElm);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function insert(parent, elm, ref) {</span><span class="s2">\n    </span><span class="s1">if (isDef(parent)) {</span><span class="s2">\n      </span><span class="s1">if (isDef(ref)) {</span><span class="s2">\n        </span><span class="s1">if (nodeOps.parentNode(ref) === parent) {</span><span class="s2">\n          </span><span class="s1">nodeOps.insertBefore(parent, elm, ref);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">nodeOps.appendChild(parent, elm);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function createChildren(vnode, children, insertedVnodeQueue) {</span><span class="s2">\n    </span><span class="s1">if (isArray(children)) {</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">checkDuplicateKeys(children);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">for (var i_1 = 0; i_1 &lt; children.length; ++i_1) {</span><span class="s2">\n        </span><span class="s1">createElm(children[i_1], insertedVnodeQueue, vnode.elm, null, true, children, i_1);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (isPrimitive(vnode.text)) {</span><span class="s2">\n      </span><span class="s1">nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function isPatchable(vnode) {</span><span class="s2">\n    </span><span class="s1">while (vnode.componentInstance) {</span><span class="s2">\n      </span><span class="s1">vnode = vnode.componentInstance._vnode;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return isDef(vnode.tag);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function invokeCreateHooks(vnode, insertedVnodeQueue) {</span><span class="s2">\n    </span><span class="s1">for (var i_2 = 0; i_2 &lt; cbs.create.length; ++i_2) {</span><span class="s2">\n      </span><span class="s1">cbs.create[i_2](emptyNode, vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">i = vnode.data.hook; // Reuse variable</span><span class="s2">\n    </span><span class="s1">if (isDef(i)) {</span><span class="s2">\n      </span><span class="s1">if (isDef(i.create)) i.create(emptyNode, vnode);</span><span class="s2">\n      </span><span class="s1">if (isDef(i.insert)) insertedVnodeQueue.push(vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// set scope id attribute for scoped CSS.</span><span class="s2">\n  </span><span class="s1">// this is implemented as a special case to avoid the overhead</span><span class="s2">\n  </span><span class="s1">// of going through the normal attribute patching process.</span><span class="s2">\n  </span><span class="s1">function setScope(vnode) {</span><span class="s2">\n    </span><span class="s1">var i;</span><span class="s2">\n    </span><span class="s1">if (isDef(i = vnode.fnScopeId)) {</span><span class="s2">\n      </span><span class="s1">nodeOps.setStyleScope(vnode.elm, i);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">var ancestor = vnode;</span><span class="s2">\n      </span><span class="s1">while (ancestor) {</span><span class="s2">\n        </span><span class="s1">if (isDef(i = ancestor.context) &amp;&amp; isDef(i = i.$options._scopeId)) {</span><span class="s2">\n          </span><span class="s1">nodeOps.setStyleScope(vnode.elm, i);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">ancestor = ancestor.parent;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// for slot content they should also get the scopeId from the host instance.</span><span class="s2">\n    </span><span class="s1">if (isDef(i = activeInstance) &amp;&amp; i !== vnode.context &amp;&amp; i !== vnode.fnContext &amp;&amp; isDef(i = i.$options._scopeId)) {</span><span class="s2">\n      </span><span class="s1">nodeOps.setStyleScope(vnode.elm, i);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {</span><span class="s2">\n    </span><span class="s1">for (; startIdx &lt;= endIdx; ++startIdx) {</span><span class="s2">\n      </span><span class="s1">createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function invokeDestroyHook(vnode) {</span><span class="s2">\n    </span><span class="s1">var i, j;</span><span class="s2">\n    </span><span class="s1">var data = vnode.data;</span><span class="s2">\n    </span><span class="s1">if (isDef(data)) {</span><span class="s2">\n      </span><span class="s1">if (isDef(i = data.hook) &amp;&amp; isDef(i = i.destroy)) i(vnode);</span><span class="s2">\n      </span><span class="s1">for (i = 0; i &lt; cbs.destroy.length; ++i) cbs.destroy[i](vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isDef(i = vnode.children)) {</span><span class="s2">\n      </span><span class="s1">for (j = 0; j &lt; vnode.children.length; ++j) {</span><span class="s2">\n        </span><span class="s1">invokeDestroyHook(vnode.children[j]);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function removeVnodes(vnodes, startIdx, endIdx) {</span><span class="s2">\n    </span><span class="s1">for (; startIdx &lt;= endIdx; ++startIdx) {</span><span class="s2">\n      </span><span class="s1">var ch = vnodes[startIdx];</span><span class="s2">\n      </span><span class="s1">if (isDef(ch)) {</span><span class="s2">\n        </span><span class="s1">if (isDef(ch.tag)) {</span><span class="s2">\n          </span><span class="s1">removeAndInvokeRemoveHook(ch);</span><span class="s2">\n          </span><span class="s1">invokeDestroyHook(ch);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">// Text node</span><span class="s2">\n          </span><span class="s1">removeNode(ch.elm);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function removeAndInvokeRemoveHook(vnode, rm) {</span><span class="s2">\n    </span><span class="s1">if (isDef(rm) || isDef(vnode.data)) {</span><span class="s2">\n      </span><span class="s1">var i_3;</span><span class="s2">\n      </span><span class="s1">var listeners = cbs.remove.length + 1;</span><span class="s2">\n      </span><span class="s1">if (isDef(rm)) {</span><span class="s2">\n        </span><span class="s1">// we have a recursively passed down rm callback</span><span class="s2">\n        </span><span class="s1">// increase the listeners count</span><span class="s2">\n        </span><span class="s1">rm.listeners += listeners;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">// directly removing</span><span class="s2">\n        </span><span class="s1">rm = createRmCb(vnode.elm, listeners);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">// recursively invoke hooks on child component root node</span><span class="s2">\n      </span><span class="s1">if (isDef(i_3 = vnode.componentInstance) &amp;&amp; isDef(i_3 = i_3._vnode) &amp;&amp; isDef(i_3.data)) {</span><span class="s2">\n        </span><span class="s1">removeAndInvokeRemoveHook(i_3, rm);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">for (i_3 = 0; i_3 &lt; cbs.remove.length; ++i_3) {</span><span class="s2">\n        </span><span class="s1">cbs.remove[i_3](vnode, rm);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (isDef(i_3 = vnode.data.hook) &amp;&amp; isDef(i_3 = i_3.remove)) {</span><span class="s2">\n        </span><span class="s1">i_3(vnode, rm);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">rm();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">removeNode(vnode.elm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {</span><span class="s2">\n    </span><span class="s1">var oldStartIdx = 0;</span><span class="s2">\n    </span><span class="s1">var newStartIdx = 0;</span><span class="s2">\n    </span><span class="s1">var oldEndIdx = oldCh.length - 1;</span><span class="s2">\n    </span><span class="s1">var oldStartVnode = oldCh[0];</span><span class="s2">\n    </span><span class="s1">var oldEndVnode = oldCh[oldEndIdx];</span><span class="s2">\n    </span><span class="s1">var newEndIdx = newCh.length - 1;</span><span class="s2">\n    </span><span class="s1">var newStartVnode = newCh[0];</span><span class="s2">\n    </span><span class="s1">var newEndVnode = newCh[newEndIdx];</span><span class="s2">\n    </span><span class="s1">var oldKeyToIdx, idxInOld, vnodeToMove, refElm;</span><span class="s2">\n    </span><span class="s1">// removeOnly is a special flag used only by &lt;transition-group&gt;</span><span class="s2">\n    </span><span class="s1">// to ensure removed elements stay in correct relative positions</span><span class="s2">\n    </span><span class="s1">// during leaving transitions</span><span class="s2">\n    </span><span class="s1">var canMove = !removeOnly;</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">checkDuplicateKeys(newCh);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {</span><span class="s2">\n      </span><span class="s1">if (isUndef(oldStartVnode)) {</span><span class="s2">\n        </span><span class="s1">oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left</span><span class="s2">\n      </span><span class="s1">} else if (isUndef(oldEndVnode)) {</span><span class="s2">\n        </span><span class="s1">oldEndVnode = oldCh[--oldEndIdx];</span><span class="s2">\n      </span><span class="s1">} else if (sameVnode(oldStartVnode, newStartVnode)) {</span><span class="s2">\n        </span><span class="s1">patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><span class="s2">\n        </span><span class="s1">oldStartVnode = oldCh[++oldStartIdx];</span><span class="s2">\n        </span><span class="s1">newStartVnode = newCh[++newStartIdx];</span><span class="s2">\n      </span><span class="s1">} else if (sameVnode(oldEndVnode, newEndVnode)) {</span><span class="s2">\n        </span><span class="s1">patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);</span><span class="s2">\n        </span><span class="s1">oldEndVnode = oldCh[--oldEndIdx];</span><span class="s2">\n        </span><span class="s1">newEndVnode = newCh[--newEndIdx];</span><span class="s2">\n      </span><span class="s1">} else if (sameVnode(oldStartVnode, newEndVnode)) {</span><span class="s2">\n        </span><span class="s1">// Vnode moved right</span><span class="s2">\n        </span><span class="s1">patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);</span><span class="s2">\n        </span><span class="s1">canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));</span><span class="s2">\n        </span><span class="s1">oldStartVnode = oldCh[++oldStartIdx];</span><span class="s2">\n        </span><span class="s1">newEndVnode = newCh[--newEndIdx];</span><span class="s2">\n      </span><span class="s1">} else if (sameVnode(oldEndVnode, newStartVnode)) {</span><span class="s2">\n        </span><span class="s1">// Vnode moved left</span><span class="s2">\n        </span><span class="s1">patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><span class="s2">\n        </span><span class="s1">canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);</span><span class="s2">\n        </span><span class="s1">oldEndVnode = oldCh[--oldEndIdx];</span><span class="s2">\n        </span><span class="s1">newStartVnode = newCh[++newStartIdx];</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);</span><span class="s2">\n        </span><span class="s1">idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><span class="s2">\n        </span><span class="s1">if (isUndef(idxInOld)) {</span><span class="s2">\n          </span><span class="s1">// New element</span><span class="s2">\n          </span><span class="s1">createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">vnodeToMove = oldCh[idxInOld];</span><span class="s2">\n          </span><span class="s1">if (sameVnode(vnodeToMove, newStartVnode)) {</span><span class="s2">\n            </span><span class="s1">patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><span class="s2">\n            </span><span class="s1">oldCh[idxInOld] = undefined;</span><span class="s2">\n            </span><span class="s1">canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">// same key but different element. treat as new element</span><span class="s2">\n            </span><span class="s1">createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">newStartVnode = newCh[++newStartIdx];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (oldStartIdx &gt; oldEndIdx) {</span><span class="s2">\n      </span><span class="s1">refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;</span><span class="s2">\n      </span><span class="s1">addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);</span><span class="s2">\n    </span><span class="s1">} else if (newStartIdx &gt; newEndIdx) {</span><span class="s2">\n      </span><span class="s1">removeVnodes(oldCh, oldStartIdx, oldEndIdx);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function checkDuplicateKeys(children) {</span><span class="s2">\n    </span><span class="s1">var seenKeys = {};</span><span class="s2">\n    </span><span class="s1">for (var i_4 = 0; i_4 &lt; children.length; i_4++) {</span><span class="s2">\n      </span><span class="s1">var vnode = children[i_4];</span><span class="s2">\n      </span><span class="s1">var key = vnode.key;</span><span class="s2">\n      </span><span class="s1">if (isDef(key)) {</span><span class="s2">\n        </span><span class="s1">if (seenKeys[key]) {</span><span class="s2">\n          </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Duplicate keys detected: '</span><span class="s2">\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;</span><span class="s1">'. This may cause an update error.</span><span class="s2">\&quot;</span><span class="s1">), vnode.context);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">seenKeys[key] = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function findIdxInOld(node, oldCh, start, end) {</span><span class="s2">\n    </span><span class="s1">for (var i_5 = start; i_5 &lt; end; i_5++) {</span><span class="s2">\n      </span><span class="s1">var c = oldCh[i_5];</span><span class="s2">\n      </span><span class="s1">if (isDef(c) &amp;&amp; sameVnode(node, c)) return i_5;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {</span><span class="s2">\n    </span><span class="s1">if (oldVnode === vnode) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) {</span><span class="s2">\n      </span><span class="s1">// clone reused vnode</span><span class="s2">\n      </span><span class="s1">vnode = ownerArray[index] = cloneVNode(vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var elm = vnode.elm = oldVnode.elm;</span><span class="s2">\n    </span><span class="s1">if (isTrue(oldVnode.isAsyncPlaceholder)) {</span><span class="s2">\n      </span><span class="s1">if (isDef(vnode.asyncFactory.resolved)) {</span><span class="s2">\n        </span><span class="s1">hydrate(oldVnode.elm, vnode, insertedVnodeQueue);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">vnode.isAsyncPlaceholder = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// reuse element for static trees.</span><span class="s2">\n    </span><span class="s1">// note we only do this if the vnode is cloned -</span><span class="s2">\n    </span><span class="s1">// if the new node is not cloned it means the render functions have been</span><span class="s2">\n    </span><span class="s1">// reset by the hot-reload-api and we need to do a proper re-render.</span><span class="s2">\n    </span><span class="s1">if (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {</span><span class="s2">\n      </span><span class="s1">vnode.componentInstance = oldVnode.componentInstance;</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var i;</span><span class="s2">\n    </span><span class="s1">var data = vnode.data;</span><span class="s2">\n    </span><span class="s1">if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) {</span><span class="s2">\n      </span><span class="s1">i(oldVnode, vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var oldCh = oldVnode.children;</span><span class="s2">\n    </span><span class="s1">var ch = vnode.children;</span><span class="s2">\n    </span><span class="s1">if (isDef(data) &amp;&amp; isPatchable(vnode)) {</span><span class="s2">\n      </span><span class="s1">for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);</span><span class="s2">\n      </span><span class="s1">if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isUndef(vnode.text)) {</span><span class="s2">\n      </span><span class="s1">if (isDef(oldCh) &amp;&amp; isDef(ch)) {</span><span class="s2">\n        </span><span class="s1">if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);</span><span class="s2">\n      </span><span class="s1">} else if (isDef(ch)) {</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n          </span><span class="s1">checkDuplicateKeys(ch);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '');</span><span class="s2">\n        </span><span class="s1">addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);</span><span class="s2">\n      </span><span class="s1">} else if (isDef(oldCh)) {</span><span class="s2">\n        </span><span class="s1">removeVnodes(oldCh, 0, oldCh.length - 1);</span><span class="s2">\n      </span><span class="s1">} else if (isDef(oldVnode.text)) {</span><span class="s2">\n        </span><span class="s1">nodeOps.setTextContent(elm, '');</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (oldVnode.text !== vnode.text) {</span><span class="s2">\n      </span><span class="s1">nodeOps.setTextContent(elm, vnode.text);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isDef(data)) {</span><span class="s2">\n      </span><span class="s1">if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function invokeInsertHook(vnode, queue, initial) {</span><span class="s2">\n    </span><span class="s1">// delay insert hooks for component root nodes, invoke them after the</span><span class="s2">\n    </span><span class="s1">// element is really inserted</span><span class="s2">\n    </span><span class="s1">if (isTrue(initial) &amp;&amp; isDef(vnode.parent)) {</span><span class="s2">\n      </span><span class="s1">vnode.parent.data.pendingInsert = queue;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">for (var i_6 = 0; i_6 &lt; queue.length; ++i_6) {</span><span class="s2">\n        </span><span class="s1">queue[i_6].data.hook.insert(queue[i_6]);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var hydrationBailed = false;</span><span class="s2">\n  </span><span class="s1">// list of modules that can skip create hook during hydration because they</span><span class="s2">\n  </span><span class="s1">// are already rendered on the client or has no need for initialization</span><span class="s2">\n  </span><span class="s1">// Note: style is excluded because it relies on initial clone for future</span><span class="s2">\n  </span><span class="s1">// deep updates (#7063).</span><span class="s2">\n  </span><span class="s1">var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');</span><span class="s2">\n  </span><span class="s1">// Note: this is a browser-only function so we can assume elms are DOM nodes.</span><span class="s2">\n  </span><span class="s1">function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {</span><span class="s2">\n    </span><span class="s1">var i;</span><span class="s2">\n    </span><span class="s1">var tag = vnode.tag,</span><span class="s2">\n      </span><span class="s1">data = vnode.data,</span><span class="s2">\n      </span><span class="s1">children = vnode.children;</span><span class="s2">\n    </span><span class="s1">inVPre = inVPre || data &amp;&amp; data.pre;</span><span class="s2">\n    </span><span class="s1">vnode.elm = elm;</span><span class="s2">\n    </span><span class="s1">if (isTrue(vnode.isComment) &amp;&amp; isDef(vnode.asyncFactory)) {</span><span class="s2">\n      </span><span class="s1">vnode.isAsyncPlaceholder = true;</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// assert node match</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">if (!assertNodeMatch(elm, vnode, inVPre)) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isDef(data)) {</span><span class="s2">\n      </span><span class="s1">if (isDef(i = data.hook) &amp;&amp; isDef(i = i.init)) i(vnode, true /* hydrating */);</span><span class="s2">\n      </span><span class="s1">if (isDef(i = vnode.componentInstance)) {</span><span class="s2">\n        </span><span class="s1">// child component. it should have hydrated its own tree.</span><span class="s2">\n        </span><span class="s1">initComponent(vnode, insertedVnodeQueue);</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isDef(tag)) {</span><span class="s2">\n      </span><span class="s1">if (isDef(children)) {</span><span class="s2">\n        </span><span class="s1">// empty element, allow client to pick up and populate children</span><span class="s2">\n        </span><span class="s1">if (!elm.hasChildNodes()) {</span><span class="s2">\n          </span><span class="s1">createChildren(vnode, children, insertedVnodeQueue);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">// v-html and domProps: innerHTML</span><span class="s2">\n          </span><span class="s1">if (isDef(i = data) &amp;&amp; isDef(i = i.domProps) &amp;&amp; isDef(i = i.innerHTML)) {</span><span class="s2">\n            </span><span class="s1">if (i !== elm.innerHTML) {</span><span class="s2">\n              </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n              </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; typeof console !== 'undefined' &amp;&amp; !hydrationBailed) {</span><span class="s2">\n                </span><span class="s1">hydrationBailed = true;</span><span class="s2">\n                </span><span class="s1">console.warn('Parent: ', elm);</span><span class="s2">\n                </span><span class="s1">console.warn('server innerHTML: ', i);</span><span class="s2">\n                </span><span class="s1">console.warn('client innerHTML: ', elm.innerHTML);</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">return false;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">// iterate and compare children lists</span><span class="s2">\n            </span><span class="s1">var childrenMatch = true;</span><span class="s2">\n            </span><span class="s1">var childNode = elm.firstChild;</span><span class="s2">\n            </span><span class="s1">for (var i_7 = 0; i_7 &lt; children.length; i_7++) {</span><span class="s2">\n              </span><span class="s1">if (!childNode || !hydrate(childNode, children[i_7], insertedVnodeQueue, inVPre)) {</span><span class="s2">\n                </span><span class="s1">childrenMatch = false;</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">childNode = childNode.nextSibling;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// if childNode is not null, it means the actual childNodes list is</span><span class="s2">\n            </span><span class="s1">// longer than the virtual children list.</span><span class="s2">\n            </span><span class="s1">if (!childrenMatch || childNode) {</span><span class="s2">\n              </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n              </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; typeof console !== 'undefined' &amp;&amp; !hydrationBailed) {</span><span class="s2">\n                </span><span class="s1">hydrationBailed = true;</span><span class="s2">\n                </span><span class="s1">console.warn('Parent: ', elm);</span><span class="s2">\n                </span><span class="s1">console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">return false;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (isDef(data)) {</span><span class="s2">\n        </span><span class="s1">var fullInvoke = false;</span><span class="s2">\n        </span><span class="s1">for (var key in data) {</span><span class="s2">\n          </span><span class="s1">if (!isRenderedModule(key)) {</span><span class="s2">\n            </span><span class="s1">fullInvoke = true;</span><span class="s2">\n            </span><span class="s1">invokeCreateHooks(vnode, insertedVnodeQueue);</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (!fullInvoke &amp;&amp; data['class']) {</span><span class="s2">\n          </span><span class="s1">// ensure collecting deps for deep class bindings for future updates</span><span class="s2">\n          </span><span class="s1">traverse(data['class']);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (elm.data !== vnode.text) {</span><span class="s2">\n      </span><span class="s1">elm.data = vnode.text;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function assertNodeMatch(node, vnode, inVPre) {</span><span class="s2">\n    </span><span class="s1">if (isDef(vnode.tag)) {</span><span class="s2">\n      </span><span class="s1">return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement(vnode, inVPre) &amp;&amp; vnode.tag.toLowerCase() === (node.tagName &amp;&amp; node.tagName.toLowerCase());</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">return node.nodeType === (vnode.isComment ? 8 : 3);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return function patch(oldVnode, vnode, hydrating, removeOnly) {</span><span class="s2">\n    </span><span class="s1">if (isUndef(vnode)) {</span><span class="s2">\n      </span><span class="s1">if (isDef(oldVnode)) invokeDestroyHook(oldVnode);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var isInitialPatch = false;</span><span class="s2">\n    </span><span class="s1">var insertedVnodeQueue = [];</span><span class="s2">\n    </span><span class="s1">if (isUndef(oldVnode)) {</span><span class="s2">\n      </span><span class="s1">// empty mount (likely as component), create new root element</span><span class="s2">\n      </span><span class="s1">isInitialPatch = true;</span><span class="s2">\n      </span><span class="s1">createElm(vnode, insertedVnodeQueue);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">var isRealElement = isDef(oldVnode.nodeType);</span><span class="s2">\n      </span><span class="s1">if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) {</span><span class="s2">\n        </span><span class="s1">// patch existing root node</span><span class="s2">\n        </span><span class="s1">patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">if (isRealElement) {</span><span class="s2">\n          </span><span class="s1">// mounting to a real element</span><span class="s2">\n          </span><span class="s1">// check if this is server-rendered content and if we can perform</span><span class="s2">\n          </span><span class="s1">// a successful hydration.</span><span class="s2">\n          </span><span class="s1">if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) {</span><span class="s2">\n            </span><span class="s1">oldVnode.removeAttribute(SSR_ATTR);</span><span class="s2">\n            </span><span class="s1">hydrating = true;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">if (isTrue(hydrating)) {</span><span class="s2">\n            </span><span class="s1">if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {</span><span class="s2">\n              </span><span class="s1">invokeInsertHook(vnode, insertedVnodeQueue, true);</span><span class="s2">\n              </span><span class="s1">return oldVnode;</span><span class="s2">\n            </span><span class="s1">} else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n              </span><span class="s1">warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing ' + 'full client-side render.');</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">// either not server-rendered, or hydration failed.</span><span class="s2">\n          </span><span class="s1">// create an empty node and replace it</span><span class="s2">\n          </span><span class="s1">oldVnode = emptyNodeAt(oldVnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// replacing existing element</span><span class="s2">\n        </span><span class="s1">var oldElm = oldVnode.elm;</span><span class="s2">\n        </span><span class="s1">var parentElm = nodeOps.parentNode(oldElm);</span><span class="s2">\n        </span><span class="s1">// create new node</span><span class="s2">\n        </span><span class="s1">createElm(vnode, insertedVnodeQueue,</span><span class="s2">\n        </span><span class="s1">// extremely rare edge case: do not insert if old element is in a</span><span class="s2">\n        </span><span class="s1">// leaving transition. Only happens when combining transition +</span><span class="s2">\n        </span><span class="s1">// keep-alive + HOCs. (#4590)</span><span class="s2">\n        </span><span class="s1">oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));</span><span class="s2">\n        </span><span class="s1">// update parent placeholder node element, recursively</span><span class="s2">\n        </span><span class="s1">if (isDef(vnode.parent)) {</span><span class="s2">\n          </span><span class="s1">var ancestor = vnode.parent;</span><span class="s2">\n          </span><span class="s1">var patchable = isPatchable(vnode);</span><span class="s2">\n          </span><span class="s1">while (ancestor) {</span><span class="s2">\n            </span><span class="s1">for (var i_8 = 0; i_8 &lt; cbs.destroy.length; ++i_8) {</span><span class="s2">\n              </span><span class="s1">cbs.destroy[i_8](ancestor);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">ancestor.elm = vnode.elm;</span><span class="s2">\n            </span><span class="s1">if (patchable) {</span><span class="s2">\n              </span><span class="s1">for (var i_9 = 0; i_9 &lt; cbs.create.length; ++i_9) {</span><span class="s2">\n                </span><span class="s1">cbs.create[i_9](emptyNode, ancestor);</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">// #6513</span><span class="s2">\n              </span><span class="s1">// invoke insert hooks that may have been merged by create hooks.</span><span class="s2">\n              </span><span class="s1">// e.g. for directives that uses the </span><span class="s2">\&quot;</span><span class="s1">inserted</span><span class="s2">\&quot; </span><span class="s1">hook.</span><span class="s2">\n              </span><span class="s1">var insert_1 = ancestor.data.hook.insert;</span><span class="s2">\n              </span><span class="s1">if (insert_1.merged) {</span><span class="s2">\n                </span><span class="s1">// start at index 1 to avoid re-invoking component mounted hook</span><span class="s2">\n                </span><span class="s1">for (var i_10 = 1; i_10 &lt; insert_1.fns.length; i_10++) {</span><span class="s2">\n                  </span><span class="s1">insert_1.fns[i_10]();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">registerRef(ancestor);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">ancestor = ancestor.parent;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// destroy old node</span><span class="s2">\n        </span><span class="s1">if (isDef(parentElm)) {</span><span class="s2">\n          </span><span class="s1">removeVnodes([oldVnode], 0, 0);</span><span class="s2">\n        </span><span class="s1">} else if (isDef(oldVnode.tag)) {</span><span class="s2">\n          </span><span class="s1">invokeDestroyHook(oldVnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);</span><span class="s2">\n    </span><span class="s1">return vnode.elm;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var directives = {</span><span class="s2">\n  </span><span class="s1">create: updateDirectives,</span><span class="s2">\n  </span><span class="s1">update: updateDirectives,</span><span class="s2">\n  </span><span class="s1">destroy: function unbindDirectives(vnode) {</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error emptyNode is not VNodeWithData</span><span class="s2">\n    </span><span class="s1">updateDirectives(vnode, emptyNode);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function updateDirectives(oldVnode, vnode) {</span><span class="s2">\n  </span><span class="s1">if (oldVnode.data.directives || vnode.data.directives) {</span><span class="s2">\n    </span><span class="s1">_update(oldVnode, vnode);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function _update(oldVnode, vnode) {</span><span class="s2">\n  </span><span class="s1">var isCreate = oldVnode === emptyNode;</span><span class="s2">\n  </span><span class="s1">var isDestroy = vnode === emptyNode;</span><span class="s2">\n  </span><span class="s1">var oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);</span><span class="s2">\n  </span><span class="s1">var newDirs = normalizeDirectives(vnode.data.directives, vnode.context);</span><span class="s2">\n  </span><span class="s1">var dirsWithInsert = [];</span><span class="s2">\n  </span><span class="s1">var dirsWithPostpatch = [];</span><span class="s2">\n  </span><span class="s1">var key, oldDir, dir;</span><span class="s2">\n  </span><span class="s1">for (key in newDirs) {</span><span class="s2">\n    </span><span class="s1">oldDir = oldDirs[key];</span><span class="s2">\n    </span><span class="s1">dir = newDirs[key];</span><span class="s2">\n    </span><span class="s1">if (!oldDir) {</span><span class="s2">\n      </span><span class="s1">// new directive, bind</span><span class="s2">\n      </span><span class="s1">callHook(dir, 'bind', vnode, oldVnode);</span><span class="s2">\n      </span><span class="s1">if (dir.def &amp;&amp; dir.def.inserted) {</span><span class="s2">\n        </span><span class="s1">dirsWithInsert.push(dir);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">// existing directive, update</span><span class="s2">\n      </span><span class="s1">dir.oldValue = oldDir.value;</span><span class="s2">\n      </span><span class="s1">dir.oldArg = oldDir.arg;</span><span class="s2">\n      </span><span class="s1">callHook(dir, 'update', vnode, oldVnode);</span><span class="s2">\n      </span><span class="s1">if (dir.def &amp;&amp; dir.def.componentUpdated) {</span><span class="s2">\n        </span><span class="s1">dirsWithPostpatch.push(dir);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (dirsWithInsert.length) {</span><span class="s2">\n    </span><span class="s1">var callInsert = function () {</span><span class="s2">\n      </span><span class="s1">for (var i = 0; i &lt; dirsWithInsert.length; i++) {</span><span class="s2">\n        </span><span class="s1">callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (isCreate) {</span><span class="s2">\n      </span><span class="s1">mergeVNodeHook(vnode, 'insert', callInsert);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">callInsert();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (dirsWithPostpatch.length) {</span><span class="s2">\n    </span><span class="s1">mergeVNodeHook(vnode, 'postpatch', function () {</span><span class="s2">\n      </span><span class="s1">for (var i = 0; i &lt; dirsWithPostpatch.length; i++) {</span><span class="s2">\n        </span><span class="s1">callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!isCreate) {</span><span class="s2">\n    </span><span class="s1">for (key in oldDirs) {</span><span class="s2">\n      </span><span class="s1">if (!newDirs[key]) {</span><span class="s2">\n        </span><span class="s1">// no longer present, unbind</span><span class="s2">\n        </span><span class="s1">callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var emptyModifiers = Object.create(null);</span><span class="s2">\n</span><span class="s1">function normalizeDirectives(dirs, vm) {</span><span class="s2">\n  </span><span class="s1">var res = Object.create(null);</span><span class="s2">\n  </span><span class="s1">if (!dirs) {</span><span class="s2">\n    </span><span class="s1">// $flow-disable-line</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var i, dir;</span><span class="s2">\n  </span><span class="s1">for (i = 0; i &lt; dirs.length; i++) {</span><span class="s2">\n    </span><span class="s1">dir = dirs[i];</span><span class="s2">\n    </span><span class="s1">if (!dir.modifiers) {</span><span class="s2">\n      </span><span class="s1">// $flow-disable-line</span><span class="s2">\n      </span><span class="s1">dir.modifiers = emptyModifiers;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">res[getRawDirName(dir)] = dir;</span><span class="s2">\n    </span><span class="s1">if (vm._setupState &amp;&amp; vm._setupState.__sfc) {</span><span class="s2">\n      </span><span class="s1">var setupDef = dir.def || resolveAsset(vm, '_setupState', 'v-' + dir.name);</span><span class="s2">\n      </span><span class="s1">if (typeof setupDef === 'function') {</span><span class="s2">\n        </span><span class="s1">dir.def = {</span><span class="s2">\n          </span><span class="s1">bind: setupDef,</span><span class="s2">\n          </span><span class="s1">update: setupDef</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">dir.def = setupDef;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">dir.def = dir.def || resolveAsset(vm.$options, 'directives', dir.name, true);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// $flow-disable-line</span><span class="s2">\n  </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getRawDirName(dir) {</span><span class="s2">\n  </span><span class="s1">return dir.rawName || </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(dir.name, </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">).concat(Object.keys(dir.modifiers || {}).join('.'));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function callHook(dir, hook, vnode, oldVnode, isDestroy) {</span><span class="s2">\n  </span><span class="s1">var fn = dir.def &amp;&amp; dir.def[hook];</span><span class="s2">\n  </span><span class="s1">if (fn) {</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">fn(vnode.elm, dir, vnode, oldVnode, isDestroy);</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">handleError(e, vnode.context, </span><span class="s2">\&quot;</span><span class="s1">directive </span><span class="s2">\&quot;</span><span class="s1">.concat(dir.name, </span><span class="s2">\&quot; \&quot;</span><span class="s1">).concat(hook, </span><span class="s2">\&quot; </span><span class="s1">hook</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var baseModules = [ref, directives];</span><span class="s2">\n</span><span class="s1">function updateAttrs(oldVnode, vnode) {</span><span class="s2">\n  </span><span class="s1">var opts = vnode.componentOptions;</span><span class="s2">\n  </span><span class="s1">if (isDef(opts) &amp;&amp; opts.Ctor.options.inheritAttrs === false) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isUndef(oldVnode.data.attrs) &amp;&amp; isUndef(vnode.data.attrs)) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var key, cur, old;</span><span class="s2">\n  </span><span class="s1">var elm = vnode.elm;</span><span class="s2">\n  </span><span class="s1">var oldAttrs = oldVnode.data.attrs || {};</span><span class="s2">\n  </span><span class="s1">var attrs = vnode.data.attrs || {};</span><span class="s2">\n  </span><span class="s1">// clone observed objects, as the user probably wants to mutate it</span><span class="s2">\n  </span><span class="s1">if (isDef(attrs.__ob__) || isTrue(attrs._v_attr_proxy)) {</span><span class="s2">\n    </span><span class="s1">attrs = vnode.data.attrs = extend({}, attrs);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">for (key in attrs) {</span><span class="s2">\n    </span><span class="s1">cur = attrs[key];</span><span class="s2">\n    </span><span class="s1">old = oldAttrs[key];</span><span class="s2">\n    </span><span class="s1">if (old !== cur) {</span><span class="s2">\n      </span><span class="s1">setAttr(elm, key, cur, vnode.data.pre);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// #4391: in IE9, setting type can reset value for input[type=radio]</span><span class="s2">\n  </span><span class="s1">// #6666: IE/Edge forces progress value down to 1 before setting a max</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if ((isIE || isEdge) &amp;&amp; attrs.value !== oldAttrs.value) {</span><span class="s2">\n    </span><span class="s1">setAttr(elm, 'value', attrs.value);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">for (key in oldAttrs) {</span><span class="s2">\n    </span><span class="s1">if (isUndef(attrs[key])) {</span><span class="s2">\n      </span><span class="s1">if (isXlink(key)) {</span><span class="s2">\n        </span><span class="s1">elm.removeAttributeNS(xlinkNS, getXlinkProp(key));</span><span class="s2">\n      </span><span class="s1">} else if (!isEnumeratedAttr(key)) {</span><span class="s2">\n        </span><span class="s1">elm.removeAttribute(key);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setAttr(el, key, value, isInPre) {</span><span class="s2">\n  </span><span class="s1">if (isInPre || el.tagName.indexOf('-') &gt; -1) {</span><span class="s2">\n    </span><span class="s1">baseSetAttr(el, key, value);</span><span class="s2">\n  </span><span class="s1">} else if (isBooleanAttr(key)) {</span><span class="s2">\n    </span><span class="s1">// set attribute for blank value</span><span class="s2">\n    </span><span class="s1">// e.g. &lt;option disabled&gt;Select one&lt;/option&gt;</span><span class="s2">\n    </span><span class="s1">if (isFalsyAttrValue(value)) {</span><span class="s2">\n      </span><span class="s1">el.removeAttribute(key);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">// technically allowfullscreen is a boolean attribute for &lt;iframe&gt;,</span><span class="s2">\n      </span><span class="s1">// but Flash expects a value of </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot; </span><span class="s1">when used on &lt;embed&gt; tag</span><span class="s2">\n      </span><span class="s1">value = key === 'allowfullscreen' &amp;&amp; el.tagName === 'EMBED' ? 'true' : key;</span><span class="s2">\n      </span><span class="s1">el.setAttribute(key, value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (isEnumeratedAttr(key)) {</span><span class="s2">\n    </span><span class="s1">el.setAttribute(key, convertEnumeratedValue(key, value));</span><span class="s2">\n  </span><span class="s1">} else if (isXlink(key)) {</span><span class="s2">\n    </span><span class="s1">if (isFalsyAttrValue(value)) {</span><span class="s2">\n      </span><span class="s1">el.removeAttributeNS(xlinkNS, getXlinkProp(key));</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">el.setAttributeNS(xlinkNS, key, value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">baseSetAttr(el, key, value);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function baseSetAttr(el, key, value) {</span><span class="s2">\n  </span><span class="s1">if (isFalsyAttrValue(value)) {</span><span class="s2">\n    </span><span class="s1">el.removeAttribute(key);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">// #7138: IE10 &amp; 11 fires input event when setting placeholder on</span><span class="s2">\n    </span><span class="s1">// &lt;textarea&gt;... block the first input event and remove the blocker</span><span class="s2">\n    </span><span class="s1">// immediately.</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (isIE &amp;&amp; !isIE9 &amp;&amp; el.tagName === 'TEXTAREA' &amp;&amp; key === 'placeholder' &amp;&amp; value !== '' &amp;&amp; !el.__ieph) {</span><span class="s2">\n      </span><span class="s1">var blocker_1 = function (e) {</span><span class="s2">\n        </span><span class="s1">e.stopImmediatePropagation();</span><span class="s2">\n        </span><span class="s1">el.removeEventListener('input', blocker_1);</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">el.addEventListener('input', blocker_1);</span><span class="s2">\n      </span><span class="s1">// $flow-disable-line</span><span class="s2">\n      </span><span class="s1">el.__ieph = true; /* IE placeholder patched */</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">el.setAttribute(key, value);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var attrs = {</span><span class="s2">\n  </span><span class="s1">create: updateAttrs,</span><span class="s2">\n  </span><span class="s1">update: updateAttrs</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function updateClass(oldVnode, vnode) {</span><span class="s2">\n  </span><span class="s1">var el = vnode.elm;</span><span class="s2">\n  </span><span class="s1">var data = vnode.data;</span><span class="s2">\n  </span><span class="s1">var oldData = oldVnode.data;</span><span class="s2">\n  </span><span class="s1">if (isUndef(data.staticClass) &amp;&amp; isUndef(data.class) &amp;&amp; (isUndef(oldData) || isUndef(oldData.staticClass) &amp;&amp; isUndef(oldData.class))) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var cls = genClassForVnode(vnode);</span><span class="s2">\n  </span><span class="s1">// handle transition classes</span><span class="s2">\n  </span><span class="s1">var transitionClass = el._transitionClasses;</span><span class="s2">\n  </span><span class="s1">if (isDef(transitionClass)) {</span><span class="s2">\n    </span><span class="s1">cls = concat(cls, stringifyClass(transitionClass));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// set the class</span><span class="s2">\n  </span><span class="s1">if (cls !== el._prevClass) {</span><span class="s2">\n    </span><span class="s1">el.setAttribute('class', cls);</span><span class="s2">\n    </span><span class="s1">el._prevClass = cls;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var klass = {</span><span class="s2">\n  </span><span class="s1">create: updateClass,</span><span class="s2">\n  </span><span class="s1">update: updateClass</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// in some cases, the event used has to be determined at runtime</span><span class="s2">\n</span><span class="s1">// so we used some reserved tokens during compile.</span><span class="s2">\n</span><span class="s1">var RANGE_TOKEN = '__r';</span><span class="s2">\n</span><span class="s1">var CHECKBOX_RADIO_TOKEN = '__c';</span><span class="s2">\n\n</span><span class="s1">// normalize v-model event tokens that can only be determined at runtime.</span><span class="s2">\n</span><span class="s1">// it's important to place the event as the first in the array because</span><span class="s2">\n</span><span class="s1">// the whole point is ensuring the v-model callback gets called before</span><span class="s2">\n</span><span class="s1">// user-attached handlers.</span><span class="s2">\n</span><span class="s1">function normalizeEvents(on) {</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (isDef(on[RANGE_TOKEN])) {</span><span class="s2">\n    </span><span class="s1">// IE input[type=range] only supports `change` event</span><span class="s2">\n    </span><span class="s1">var event_1 = isIE ? 'change' : 'input';</span><span class="s2">\n    </span><span class="s1">on[event_1] = [].concat(on[RANGE_TOKEN], on[event_1] || []);</span><span class="s2">\n    </span><span class="s1">delete on[RANGE_TOKEN];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// This was originally intended to fix #4521 but no longer necessary</span><span class="s2">\n  </span><span class="s1">// after 2.5. Keeping it for backwards compat with generated code from &lt; 2.4</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (isDef(on[CHECKBOX_RADIO_TOKEN])) {</span><span class="s2">\n    </span><span class="s1">on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);</span><span class="s2">\n    </span><span class="s1">delete on[CHECKBOX_RADIO_TOKEN];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var target;</span><span class="s2">\n</span><span class="s1">function createOnceHandler(event, handler, capture) {</span><span class="s2">\n  </span><span class="s1">var _target = target; // save current target element in closure</span><span class="s2">\n  </span><span class="s1">return function onceHandler() {</span><span class="s2">\n    </span><span class="s1">var res = handler.apply(null, arguments);</span><span class="s2">\n    </span><span class="s1">if (res !== null) {</span><span class="s2">\n      </span><span class="s1">remove(event, onceHandler, capture, _target);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// #9446: Firefox &lt;= 53 (in particular, ESR 52) has incorrect Event.timeStamp</span><span class="s2">\n</span><span class="s1">// implementation and does not fire microtasks in between event propagation, so</span><span class="s2">\n</span><span class="s1">// safe to exclude.</span><span class="s2">\n</span><span class="s1">var useMicrotaskFix = isUsingMicroTask &amp;&amp; !(isFF &amp;&amp; Number(isFF[1]) &lt;= 53);</span><span class="s2">\n</span><span class="s1">function add(name, handler, capture, passive) {</span><span class="s2">\n  </span><span class="s1">// async edge case #6566: inner click event triggers patch, event handler</span><span class="s2">\n  </span><span class="s1">// attached to outer element during patch, and triggered again. This</span><span class="s2">\n  </span><span class="s1">// happens because browsers fire microtask ticks between event propagation.</span><span class="s2">\n  </span><span class="s1">// the solution is simple: we save the timestamp when a handler is attached,</span><span class="s2">\n  </span><span class="s1">// and the handler would only fire if the event passed to it was fired</span><span class="s2">\n  </span><span class="s1">// AFTER it was attached.</span><span class="s2">\n  </span><span class="s1">if (useMicrotaskFix) {</span><span class="s2">\n    </span><span class="s1">var attachedTimestamp_1 = currentFlushTimestamp;</span><span class="s2">\n    </span><span class="s1">var original_1 = handler;</span><span class="s2">\n    </span><span class="s1">//@ts-expect-error</span><span class="s2">\n    </span><span class="s1">handler = original_1._wrapper = function (e) {</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">// no bubbling, should always fire.</span><span class="s2">\n      </span><span class="s1">// this is just a safety net in case event.timeStamp is unreliable in</span><span class="s2">\n      </span><span class="s1">// certain weird environments...</span><span class="s2">\n      </span><span class="s1">e.target === e.currentTarget ||</span><span class="s2">\n      </span><span class="s1">// event is fired after handler attachment</span><span class="s2">\n      </span><span class="s1">e.timeStamp &gt;= attachedTimestamp_1 ||</span><span class="s2">\n      </span><span class="s1">// bail for environments that have buggy event.timeStamp implementations</span><span class="s2">\n      </span><span class="s1">// #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState</span><span class="s2">\n      </span><span class="s1">// #9681 QtWebEngine event.timeStamp is negative value</span><span class="s2">\n      </span><span class="s1">e.timeStamp &lt;= 0 ||</span><span class="s2">\n      </span><span class="s1">// #9448 bail if event is fired in another document in a multi-page</span><span class="s2">\n      </span><span class="s1">// electron/nw.js app, since event.timeStamp will be using a different</span><span class="s2">\n      </span><span class="s1">// starting reference</span><span class="s2">\n      </span><span class="s1">e.target.ownerDocument !== document) {</span><span class="s2">\n        </span><span class="s1">return original_1.apply(this, arguments);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">target.addEventListener(name, handler, supportsPassive ? {</span><span class="s2">\n    </span><span class="s1">capture: capture,</span><span class="s2">\n    </span><span class="s1">passive: passive</span><span class="s2">\n  </span><span class="s1">} : capture);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function remove(name, handler, capture, _target) {</span><span class="s2">\n  </span><span class="s1">(_target || target).removeEventListener(name,</span><span class="s2">\n  </span><span class="s1">//@ts-expect-error</span><span class="s2">\n  </span><span class="s1">handler._wrapper || handler, capture);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function updateDOMListeners(oldVnode, vnode) {</span><span class="s2">\n  </span><span class="s1">if (isUndef(oldVnode.data.on) &amp;&amp; isUndef(vnode.data.on)) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var on = vnode.data.on || {};</span><span class="s2">\n  </span><span class="s1">var oldOn = oldVnode.data.on || {};</span><span class="s2">\n  </span><span class="s1">// vnode is empty when removing all listeners,</span><span class="s2">\n  </span><span class="s1">// and use old vnode dom element</span><span class="s2">\n  </span><span class="s1">target = vnode.elm || oldVnode.elm;</span><span class="s2">\n  </span><span class="s1">normalizeEvents(on);</span><span class="s2">\n  </span><span class="s1">updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);</span><span class="s2">\n  </span><span class="s1">target = undefined;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var events = {</span><span class="s2">\n  </span><span class="s1">create: updateDOMListeners,</span><span class="s2">\n  </span><span class="s1">update: updateDOMListeners,</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error emptyNode has actually data</span><span class="s2">\n  </span><span class="s1">destroy: function (vnode) {</span><span class="s2">\n    </span><span class="s1">return updateDOMListeners(vnode, emptyNode);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var svgContainer;</span><span class="s2">\n</span><span class="s1">function updateDOMProps(oldVnode, vnode) {</span><span class="s2">\n  </span><span class="s1">if (isUndef(oldVnode.data.domProps) &amp;&amp; isUndef(vnode.data.domProps)) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var key, cur;</span><span class="s2">\n  </span><span class="s1">var elm = vnode.elm;</span><span class="s2">\n  </span><span class="s1">var oldProps = oldVnode.data.domProps || {};</span><span class="s2">\n  </span><span class="s1">var props = vnode.data.domProps || {};</span><span class="s2">\n  </span><span class="s1">// clone observed objects, as the user probably wants to mutate it</span><span class="s2">\n  </span><span class="s1">if (isDef(props.__ob__) || isTrue(props._v_attr_proxy)) {</span><span class="s2">\n    </span><span class="s1">props = vnode.data.domProps = extend({}, props);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">for (key in oldProps) {</span><span class="s2">\n    </span><span class="s1">if (!(key in props)) {</span><span class="s2">\n      </span><span class="s1">elm[key] = '';</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">for (key in props) {</span><span class="s2">\n    </span><span class="s1">cur = props[key];</span><span class="s2">\n    </span><span class="s1">// ignore children if the node has textContent or innerHTML,</span><span class="s2">\n    </span><span class="s1">// as these will throw away existing DOM nodes and cause removal errors</span><span class="s2">\n    </span><span class="s1">// on subsequent patches (#3360)</span><span class="s2">\n    </span><span class="s1">if (key === 'textContent' || key === 'innerHTML') {</span><span class="s2">\n      </span><span class="s1">if (vnode.children) vnode.children.length = 0;</span><span class="s2">\n      </span><span class="s1">if (cur === oldProps[key]) continue;</span><span class="s2">\n      </span><span class="s1">// #6601 work around Chrome version &lt;= 55 bug where single textNode</span><span class="s2">\n      </span><span class="s1">// replaced by innerHTML/textContent retains its parentNode property</span><span class="s2">\n      </span><span class="s1">if (elm.childNodes.length === 1) {</span><span class="s2">\n        </span><span class="s1">elm.removeChild(elm.childNodes[0]);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (key === 'value' &amp;&amp; elm.tagName !== 'PROGRESS') {</span><span class="s2">\n      </span><span class="s1">// store value as _value as well since</span><span class="s2">\n      </span><span class="s1">// non-string values will be stringified</span><span class="s2">\n      </span><span class="s1">elm._value = cur;</span><span class="s2">\n      </span><span class="s1">// avoid resetting cursor position when value is the same</span><span class="s2">\n      </span><span class="s1">var strCur = isUndef(cur) ? '' : String(cur);</span><span class="s2">\n      </span><span class="s1">if (shouldUpdateValue(elm, strCur)) {</span><span class="s2">\n        </span><span class="s1">elm.value = strCur;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (key === 'innerHTML' &amp;&amp; isSVG(elm.tagName) &amp;&amp; isUndef(elm.innerHTML)) {</span><span class="s2">\n      </span><span class="s1">// IE doesn't support innerHTML for SVG elements</span><span class="s2">\n      </span><span class="s1">svgContainer = svgContainer || document.createElement('div');</span><span class="s2">\n      </span><span class="s1">svgContainer.innerHTML = </span><span class="s2">\&quot;</span><span class="s1">&lt;svg&gt;</span><span class="s2">\&quot;</span><span class="s1">.concat(cur, </span><span class="s2">\&quot;</span><span class="s1">&lt;/svg&gt;</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">var svg = svgContainer.firstChild;</span><span class="s2">\n      </span><span class="s1">while (elm.firstChild) {</span><span class="s2">\n        </span><span class="s1">elm.removeChild(elm.firstChild);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">while (svg.firstChild) {</span><span class="s2">\n        </span><span class="s1">elm.appendChild(svg.firstChild);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (</span><span class="s2">\n    </span><span class="s1">// skip the update if old and new VDOM state is the same.</span><span class="s2">\n    </span><span class="s1">// `value` is handled separately because the DOM value may be temporarily</span><span class="s2">\n    </span><span class="s1">// out of sync with VDOM state due to focus, composition and modifiers.</span><span class="s2">\n    </span><span class="s1">// This  #4521 by skipping the unnecessary `checked` update.</span><span class="s2">\n    </span><span class="s1">cur !== oldProps[key]) {</span><span class="s2">\n      </span><span class="s1">// some property updates can throw</span><span class="s2">\n      </span><span class="s1">// e.g. `value` on &lt;progress&gt; w/ non-finite value</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">elm[key] = cur;</span><span class="s2">\n      </span><span class="s1">} catch (e) {}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function shouldUpdateValue(elm, checkVal) {</span><span class="s2">\n  </span><span class="s1">return (</span><span class="s2">\n    </span><span class="s1">//@ts-expect-error</span><span class="s2">\n    </span><span class="s1">!elm.composing &amp;&amp; (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal))</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isNotInFocusAndDirty(elm, checkVal) {</span><span class="s2">\n  </span><span class="s1">// return true when textbox (.number and .trim) loses focus and its value is</span><span class="s2">\n  </span><span class="s1">// not equal to the updated value</span><span class="s2">\n  </span><span class="s1">var notInFocus = true;</span><span class="s2">\n  </span><span class="s1">// #6157</span><span class="s2">\n  </span><span class="s1">// work around IE bug when accessing document.activeElement in an iframe</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">notInFocus = document.activeElement !== elm;</span><span class="s2">\n  </span><span class="s1">} catch (e) {}</span><span class="s2">\n  </span><span class="s1">return notInFocus &amp;&amp; elm.value !== checkVal;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isDirtyWithModifiers(elm, newVal) {</span><span class="s2">\n  </span><span class="s1">var value = elm.value;</span><span class="s2">\n  </span><span class="s1">var modifiers = elm._vModifiers; // injected by v-model runtime</span><span class="s2">\n  </span><span class="s1">if (isDef(modifiers)) {</span><span class="s2">\n    </span><span class="s1">if (modifiers.number) {</span><span class="s2">\n      </span><span class="s1">return toNumber(value) !== toNumber(newVal);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (modifiers.trim) {</span><span class="s2">\n      </span><span class="s1">return value.trim() !== newVal.trim();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return value !== newVal;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var domProps = {</span><span class="s2">\n  </span><span class="s1">create: updateDOMProps,</span><span class="s2">\n  </span><span class="s1">update: updateDOMProps</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var parseStyleText = cached(function (cssText) {</span><span class="s2">\n  </span><span class="s1">var res = {};</span><span class="s2">\n  </span><span class="s1">var listDelimiter = /;(?![^(]*</span><span class="s2">\\</span><span class="s1">))/g;</span><span class="s2">\n  </span><span class="s1">var propertyDelimiter = /:(.+)/;</span><span class="s2">\n  </span><span class="s1">cssText.split(listDelimiter).forEach(function (item) {</span><span class="s2">\n    </span><span class="s1">if (item) {</span><span class="s2">\n      </span><span class="s1">var tmp = item.split(propertyDelimiter);</span><span class="s2">\n      </span><span class="s1">tmp.length &gt; 1 &amp;&amp; (res[tmp[0].trim()] = tmp[1].trim());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">// merge static and dynamic style data on the same vnode</span><span class="s2">\n</span><span class="s1">function normalizeStyleData(data) {</span><span class="s2">\n  </span><span class="s1">var style = normalizeStyleBinding(data.style);</span><span class="s2">\n  </span><span class="s1">// static style is pre-processed into an object during compilation</span><span class="s2">\n  </span><span class="s1">// and is always a fresh object, so it's safe to merge into it</span><span class="s2">\n  </span><span class="s1">return data.staticStyle ? extend(data.staticStyle, style) : style;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// normalize possible array / string values into Object</span><span class="s2">\n</span><span class="s1">function normalizeStyleBinding(bindingStyle) {</span><span class="s2">\n  </span><span class="s1">if (Array.isArray(bindingStyle)) {</span><span class="s2">\n    </span><span class="s1">return toObject(bindingStyle);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (typeof bindingStyle === 'string') {</span><span class="s2">\n    </span><span class="s1">return parseStyleText(bindingStyle);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return bindingStyle;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* parent component style should be after child's</span><span class="s2">\n </span><span class="s1">* so that parent component's style could override it</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function getStyle(vnode, checkChild) {</span><span class="s2">\n  </span><span class="s1">var res = {};</span><span class="s2">\n  </span><span class="s1">var styleData;</span><span class="s2">\n  </span><span class="s1">if (checkChild) {</span><span class="s2">\n    </span><span class="s1">var childNode = vnode;</span><span class="s2">\n    </span><span class="s1">while (childNode.componentInstance) {</span><span class="s2">\n      </span><span class="s1">childNode = childNode.componentInstance._vnode;</span><span class="s2">\n      </span><span class="s1">if (childNode &amp;&amp; childNode.data &amp;&amp; (styleData = normalizeStyleData(childNode.data))) {</span><span class="s2">\n        </span><span class="s1">extend(res, styleData);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (styleData = normalizeStyleData(vnode.data)) {</span><span class="s2">\n    </span><span class="s1">extend(res, styleData);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var parentNode = vnode;</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error parentNode.parent not VNodeWithData</span><span class="s2">\n  </span><span class="s1">while (parentNode = parentNode.parent) {</span><span class="s2">\n    </span><span class="s1">if (parentNode.data &amp;&amp; (styleData = normalizeStyleData(parentNode.data))) {</span><span class="s2">\n      </span><span class="s1">extend(res, styleData);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var cssVarRE = /^--/;</span><span class="s2">\n</span><span class="s1">var importantRE = /</span><span class="s2">\\</span><span class="s1">s*!important$/;</span><span class="s2">\n</span><span class="s1">var setProp = function (el, name, val) {</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (cssVarRE.test(name)) {</span><span class="s2">\n    </span><span class="s1">el.style.setProperty(name, val);</span><span class="s2">\n  </span><span class="s1">} else if (importantRE.test(val)) {</span><span class="s2">\n    </span><span class="s1">el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">var normalizedName = normalize(name);</span><span class="s2">\n    </span><span class="s1">if (Array.isArray(val)) {</span><span class="s2">\n      </span><span class="s1">// Support values array created by autoprefixer, e.g.</span><span class="s2">\n      </span><span class="s1">// {display: [</span><span class="s2">\&quot;</span><span class="s1">-webkit-box</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">-ms-flexbox</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">flex</span><span class="s2">\&quot;</span><span class="s1">]}</span><span class="s2">\n      </span><span class="s1">// Set them one by one, and the browser will only set those it can recognize</span><span class="s2">\n      </span><span class="s1">for (var i = 0, len = val.length; i &lt; len; i++) {</span><span class="s2">\n        </span><span class="s1">el.style[normalizedName] = val[i];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">el.style[normalizedName] = val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var vendorNames = ['Webkit', 'Moz', 'ms'];</span><span class="s2">\n</span><span class="s1">var emptyStyle;</span><span class="s2">\n</span><span class="s1">var normalize = cached(function (prop) {</span><span class="s2">\n  </span><span class="s1">emptyStyle = emptyStyle || document.createElement('div').style;</span><span class="s2">\n  </span><span class="s1">prop = camelize(prop);</span><span class="s2">\n  </span><span class="s1">if (prop !== 'filter' &amp;&amp; prop in emptyStyle) {</span><span class="s2">\n    </span><span class="s1">return prop;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var capName = prop.charAt(0).toUpperCase() + prop.slice(1);</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; vendorNames.length; i++) {</span><span class="s2">\n    </span><span class="s1">var name_1 = vendorNames[i] + capName;</span><span class="s2">\n    </span><span class="s1">if (name_1 in emptyStyle) {</span><span class="s2">\n      </span><span class="s1">return name_1;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">function updateStyle(oldVnode, vnode) {</span><span class="s2">\n  </span><span class="s1">var data = vnode.data;</span><span class="s2">\n  </span><span class="s1">var oldData = oldVnode.data;</span><span class="s2">\n  </span><span class="s1">if (isUndef(data.staticStyle) &amp;&amp; isUndef(data.style) &amp;&amp; isUndef(oldData.staticStyle) &amp;&amp; isUndef(oldData.style)) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var cur, name;</span><span class="s2">\n  </span><span class="s1">var el = vnode.elm;</span><span class="s2">\n  </span><span class="s1">var oldStaticStyle = oldData.staticStyle;</span><span class="s2">\n  </span><span class="s1">var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};</span><span class="s2">\n  </span><span class="s1">// if static style exists, stylebinding already merged into it when doing normalizeStyleData</span><span class="s2">\n  </span><span class="s1">var oldStyle = oldStaticStyle || oldStyleBinding;</span><span class="s2">\n  </span><span class="s1">var style = normalizeStyleBinding(vnode.data.style) || {};</span><span class="s2">\n  </span><span class="s1">// store normalized style under a different key for next diff</span><span class="s2">\n  </span><span class="s1">// make sure to clone it if it's reactive, since the user likely wants</span><span class="s2">\n  </span><span class="s1">// to mutate it.</span><span class="s2">\n  </span><span class="s1">vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;</span><span class="s2">\n  </span><span class="s1">var newStyle = getStyle(vnode, true);</span><span class="s2">\n  </span><span class="s1">for (name in oldStyle) {</span><span class="s2">\n    </span><span class="s1">if (isUndef(newStyle[name])) {</span><span class="s2">\n      </span><span class="s1">setProp(el, name, '');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">for (name in newStyle) {</span><span class="s2">\n    </span><span class="s1">cur = newStyle[name];</span><span class="s2">\n    </span><span class="s1">if (cur !== oldStyle[name]) {</span><span class="s2">\n      </span><span class="s1">// ie9 setting to null has no effect, must use empty string</span><span class="s2">\n      </span><span class="s1">setProp(el, name, cur == null ? '' : cur);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var style = {</span><span class="s2">\n  </span><span class="s1">create: updateStyle,</span><span class="s2">\n  </span><span class="s1">update: updateStyle</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var whitespaceRE = /</span><span class="s2">\\</span><span class="s1">s+/;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Add class with compatibility for SVG since classList is not supported on</span><span class="s2">\n </span><span class="s1">* SVG elements in IE</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function addClass(el, cls) {</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (!cls || !(cls = cls.trim())) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n  </span><span class="s1">if (el.classList) {</span><span class="s2">\n    </span><span class="s1">if (cls.indexOf(' ') &gt; -1) {</span><span class="s2">\n      </span><span class="s1">cls.split(whitespaceRE).forEach(function (c) {</span><span class="s2">\n        </span><span class="s1">return el.classList.add(c);</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">el.classList.add(cls);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">var cur = </span><span class="s2">\&quot; \&quot;</span><span class="s1">.concat(el.getAttribute('class') || '', </span><span class="s2">\&quot; \&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (cur.indexOf(' ' + cls + ' ') &lt; 0) {</span><span class="s2">\n      </span><span class="s1">el.setAttribute('class', (cur + cls).trim());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Remove class with compatibility for SVG since classList is not supported on</span><span class="s2">\n </span><span class="s1">* SVG elements in IE</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function removeClass(el, cls) {</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (!cls || !(cls = cls.trim())) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n  </span><span class="s1">if (el.classList) {</span><span class="s2">\n    </span><span class="s1">if (cls.indexOf(' ') &gt; -1) {</span><span class="s2">\n      </span><span class="s1">cls.split(whitespaceRE).forEach(function (c) {</span><span class="s2">\n        </span><span class="s1">return el.classList.remove(c);</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">el.classList.remove(cls);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!el.classList.length) {</span><span class="s2">\n      </span><span class="s1">el.removeAttribute('class');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">var cur = </span><span class="s2">\&quot; \&quot;</span><span class="s1">.concat(el.getAttribute('class') || '', </span><span class="s2">\&quot; \&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">var tar = ' ' + cls + ' ';</span><span class="s2">\n    </span><span class="s1">while (cur.indexOf(tar) &gt;= 0) {</span><span class="s2">\n      </span><span class="s1">cur = cur.replace(tar, ' ');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">cur = cur.trim();</span><span class="s2">\n    </span><span class="s1">if (cur) {</span><span class="s2">\n      </span><span class="s1">el.setAttribute('class', cur);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">el.removeAttribute('class');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveTransition(def) {</span><span class="s2">\n  </span><span class="s1">if (!def) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n  </span><span class="s1">if (typeof def === 'object') {</span><span class="s2">\n    </span><span class="s1">var res = {};</span><span class="s2">\n    </span><span class="s1">if (def.css !== false) {</span><span class="s2">\n      </span><span class="s1">extend(res, autoCssTransition(def.name || 'v'));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">extend(res, def);</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n  </span><span class="s1">} else if (typeof def === 'string') {</span><span class="s2">\n    </span><span class="s1">return autoCssTransition(def);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var autoCssTransition = cached(function (name) {</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">enterClass: </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;</span><span class="s1">-enter</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">enterToClass: </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;</span><span class="s1">-enter-to</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">enterActiveClass: </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;</span><span class="s1">-enter-active</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">leaveClass: </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;</span><span class="s1">-leave</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">leaveToClass: </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;</span><span class="s1">-leave-to</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">leaveActiveClass: </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;</span><span class="s1">-leave-active</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">var hasTransition = inBrowser &amp;&amp; !isIE9;</span><span class="s2">\n</span><span class="s1">var TRANSITION = 'transition';</span><span class="s2">\n</span><span class="s1">var ANIMATION = 'animation';</span><span class="s2">\n</span><span class="s1">// Transition property/event sniffing</span><span class="s2">\n</span><span class="s1">var transitionProp = 'transition';</span><span class="s2">\n</span><span class="s1">var transitionEndEvent = 'transitionend';</span><span class="s2">\n</span><span class="s1">var animationProp = 'animation';</span><span class="s2">\n</span><span class="s1">var animationEndEvent = 'animationend';</span><span class="s2">\n</span><span class="s1">if (hasTransition) {</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (window.ontransitionend === undefined &amp;&amp; window.onwebkittransitionend !== undefined) {</span><span class="s2">\n    </span><span class="s1">transitionProp = 'WebkitTransition';</span><span class="s2">\n    </span><span class="s1">transitionEndEvent = 'webkitTransitionEnd';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (window.onanimationend === undefined &amp;&amp; window.onwebkitanimationend !== undefined) {</span><span class="s2">\n    </span><span class="s1">animationProp = 'WebkitAnimation';</span><span class="s2">\n    </span><span class="s1">animationEndEvent = 'webkitAnimationEnd';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// binding to window is necessary to make hot reload work in IE in strict mode</span><span class="s2">\n</span><span class="s1">var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : /* istanbul ignore next */function ( /* istanbul ignore next */fn) {</span><span class="s2">\n  </span><span class="s1">return fn();</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function nextFrame(fn) {</span><span class="s2">\n  </span><span class="s1">raf(function () {</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">raf(fn);</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function addTransitionClass(el, cls) {</span><span class="s2">\n  </span><span class="s1">var transitionClasses = el._transitionClasses || (el._transitionClasses = []);</span><span class="s2">\n  </span><span class="s1">if (transitionClasses.indexOf(cls) &lt; 0) {</span><span class="s2">\n    </span><span class="s1">transitionClasses.push(cls);</span><span class="s2">\n    </span><span class="s1">addClass(el, cls);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function removeTransitionClass(el, cls) {</span><span class="s2">\n  </span><span class="s1">if (el._transitionClasses) {</span><span class="s2">\n    </span><span class="s1">remove$2(el._transitionClasses, cls);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">removeClass(el, cls);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function whenTransitionEnds(el, expectedType, cb) {</span><span class="s2">\n  </span><span class="s1">var _a = getTransitionInfo(el, expectedType),</span><span class="s2">\n    </span><span class="s1">type = _a.type,</span><span class="s2">\n    </span><span class="s1">timeout = _a.timeout,</span><span class="s2">\n    </span><span class="s1">propCount = _a.propCount;</span><span class="s2">\n  </span><span class="s1">if (!type) return cb();</span><span class="s2">\n  </span><span class="s1">var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;</span><span class="s2">\n  </span><span class="s1">var ended = 0;</span><span class="s2">\n  </span><span class="s1">var end = function () {</span><span class="s2">\n    </span><span class="s1">el.removeEventListener(event, onEnd);</span><span class="s2">\n    </span><span class="s1">cb();</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">var onEnd = function (e) {</span><span class="s2">\n    </span><span class="s1">if (e.target === el) {</span><span class="s2">\n      </span><span class="s1">if (++ended &gt;= propCount) {</span><span class="s2">\n        </span><span class="s1">end();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">setTimeout(function () {</span><span class="s2">\n    </span><span class="s1">if (ended &lt; propCount) {</span><span class="s2">\n      </span><span class="s1">end();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, timeout + 1);</span><span class="s2">\n  </span><span class="s1">el.addEventListener(event, onEnd);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var transformRE = /</span><span class="s2">\\</span><span class="s1">b(transform|all)(,|$)/;</span><span class="s2">\n</span><span class="s1">function getTransitionInfo(el, expectedType) {</span><span class="s2">\n  </span><span class="s1">var styles = window.getComputedStyle(el);</span><span class="s2">\n  </span><span class="s1">// JSDOM may return undefined for transition properties</span><span class="s2">\n  </span><span class="s1">var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');</span><span class="s2">\n  </span><span class="s1">var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');</span><span class="s2">\n  </span><span class="s1">var transitionTimeout = getTimeout(transitionDelays, transitionDurations);</span><span class="s2">\n  </span><span class="s1">var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');</span><span class="s2">\n  </span><span class="s1">var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');</span><span class="s2">\n  </span><span class="s1">var animationTimeout = getTimeout(animationDelays, animationDurations);</span><span class="s2">\n  </span><span class="s1">var type;</span><span class="s2">\n  </span><span class="s1">var timeout = 0;</span><span class="s2">\n  </span><span class="s1">var propCount = 0;</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (expectedType === TRANSITION) {</span><span class="s2">\n    </span><span class="s1">if (transitionTimeout &gt; 0) {</span><span class="s2">\n      </span><span class="s1">type = TRANSITION;</span><span class="s2">\n      </span><span class="s1">timeout = transitionTimeout;</span><span class="s2">\n      </span><span class="s1">propCount = transitionDurations.length;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (expectedType === ANIMATION) {</span><span class="s2">\n    </span><span class="s1">if (animationTimeout &gt; 0) {</span><span class="s2">\n      </span><span class="s1">type = ANIMATION;</span><span class="s2">\n      </span><span class="s1">timeout = animationTimeout;</span><span class="s2">\n      </span><span class="s1">propCount = animationDurations.length;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">timeout = Math.max(transitionTimeout, animationTimeout);</span><span class="s2">\n    </span><span class="s1">type = timeout &gt; 0 ? transitionTimeout &gt; animationTimeout ? TRANSITION : ANIMATION : null;</span><span class="s2">\n    </span><span class="s1">propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var hasTransform = type === TRANSITION &amp;&amp; transformRE.test(styles[transitionProp + 'Property']);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">type: type,</span><span class="s2">\n    </span><span class="s1">timeout: timeout,</span><span class="s2">\n    </span><span class="s1">propCount: propCount,</span><span class="s2">\n    </span><span class="s1">hasTransform: hasTransform</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getTimeout(delays, durations) {</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n  </span><span class="s1">while (delays.length &lt; durations.length) {</span><span class="s2">\n    </span><span class="s1">delays = delays.concat(delays);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return Math.max.apply(null, durations.map(function (d, i) {</span><span class="s2">\n    </span><span class="s1">return toMs(d) + toMs(delays[i]);</span><span class="s2">\n  </span><span class="s1">}));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers</span><span class="s2">\n</span><span class="s1">// in a locale-dependent way, using a comma instead of a dot.</span><span class="s2">\n</span><span class="s1">// If comma is not replaced with a dot, the input will be rounded down (i.e. acting</span><span class="s2">\n</span><span class="s1">// as a floor function) causing unexpected behaviors</span><span class="s2">\n</span><span class="s1">function toMs(s) {</span><span class="s2">\n  </span><span class="s1">return Number(s.slice(0, -1).replace(',', '.')) * 1000;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function enter(vnode, toggleDisplay) {</span><span class="s2">\n  </span><span class="s1">var el = vnode.elm;</span><span class="s2">\n  </span><span class="s1">// call leave callback now</span><span class="s2">\n  </span><span class="s1">if (isDef(el._leaveCb)) {</span><span class="s2">\n    </span><span class="s1">el._leaveCb.cancelled = true;</span><span class="s2">\n    </span><span class="s1">el._leaveCb();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var data = resolveTransition(vnode.data.transition);</span><span class="s2">\n  </span><span class="s1">if (isUndef(data)) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (isDef(el._enterCb) || el.nodeType !== 1) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var css = data.css,</span><span class="s2">\n    </span><span class="s1">type = data.type,</span><span class="s2">\n    </span><span class="s1">enterClass = data.enterClass,</span><span class="s2">\n    </span><span class="s1">enterToClass = data.enterToClass,</span><span class="s2">\n    </span><span class="s1">enterActiveClass = data.enterActiveClass,</span><span class="s2">\n    </span><span class="s1">appearClass = data.appearClass,</span><span class="s2">\n    </span><span class="s1">appearToClass = data.appearToClass,</span><span class="s2">\n    </span><span class="s1">appearActiveClass = data.appearActiveClass,</span><span class="s2">\n    </span><span class="s1">beforeEnter = data.beforeEnter,</span><span class="s2">\n    </span><span class="s1">enter = data.enter,</span><span class="s2">\n    </span><span class="s1">afterEnter = data.afterEnter,</span><span class="s2">\n    </span><span class="s1">enterCancelled = data.enterCancelled,</span><span class="s2">\n    </span><span class="s1">beforeAppear = data.beforeAppear,</span><span class="s2">\n    </span><span class="s1">appear = data.appear,</span><span class="s2">\n    </span><span class="s1">afterAppear = data.afterAppear,</span><span class="s2">\n    </span><span class="s1">appearCancelled = data.appearCancelled,</span><span class="s2">\n    </span><span class="s1">duration = data.duration;</span><span class="s2">\n  </span><span class="s1">// activeInstance will always be the &lt;transition&gt; component managing this</span><span class="s2">\n  </span><span class="s1">// transition. One edge case to check is when the &lt;transition&gt; is placed</span><span class="s2">\n  </span><span class="s1">// as the root node of a child component. In that case we need to check</span><span class="s2">\n  </span><span class="s1">// &lt;transition&gt;'s parent for appear check.</span><span class="s2">\n  </span><span class="s1">var context = activeInstance;</span><span class="s2">\n  </span><span class="s1">var transitionNode = activeInstance.$vnode;</span><span class="s2">\n  </span><span class="s1">while (transitionNode &amp;&amp; transitionNode.parent) {</span><span class="s2">\n    </span><span class="s1">context = transitionNode.context;</span><span class="s2">\n    </span><span class="s1">transitionNode = transitionNode.parent;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var isAppear = !context._isMounted || !vnode.isRootInsert;</span><span class="s2">\n  </span><span class="s1">if (isAppear &amp;&amp; !appear &amp;&amp; appear !== '') {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var startClass = isAppear &amp;&amp; appearClass ? appearClass : enterClass;</span><span class="s2">\n  </span><span class="s1">var activeClass = isAppear &amp;&amp; appearActiveClass ? appearActiveClass : enterActiveClass;</span><span class="s2">\n  </span><span class="s1">var toClass = isAppear &amp;&amp; appearToClass ? appearToClass : enterToClass;</span><span class="s2">\n  </span><span class="s1">var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;</span><span class="s2">\n  </span><span class="s1">var enterHook = isAppear ? isFunction(appear) ? appear : enter : enter;</span><span class="s2">\n  </span><span class="s1">var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;</span><span class="s2">\n  </span><span class="s1">var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;</span><span class="s2">\n  </span><span class="s1">var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; explicitEnterDuration != null) {</span><span class="s2">\n    </span><span class="s1">checkDuration(explicitEnterDuration, 'enter', vnode);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var expectsCSS = css !== false &amp;&amp; !isIE9;</span><span class="s2">\n  </span><span class="s1">var userWantsControl = getHookArgumentsLength(enterHook);</span><span class="s2">\n  </span><span class="s1">var cb = el._enterCb = once(function () {</span><span class="s2">\n    </span><span class="s1">if (expectsCSS) {</span><span class="s2">\n      </span><span class="s1">removeTransitionClass(el, toClass);</span><span class="s2">\n      </span><span class="s1">removeTransitionClass(el, activeClass);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">if (cb.cancelled) {</span><span class="s2">\n      </span><span class="s1">if (expectsCSS) {</span><span class="s2">\n        </span><span class="s1">removeTransitionClass(el, startClass);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">enterCancelledHook &amp;&amp; enterCancelledHook(el);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">afterEnterHook &amp;&amp; afterEnterHook(el);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">el._enterCb = null;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">if (!vnode.data.show) {</span><span class="s2">\n    </span><span class="s1">// remove pending leave element on enter by injecting an insert hook</span><span class="s2">\n    </span><span class="s1">mergeVNodeHook(vnode, 'insert', function () {</span><span class="s2">\n      </span><span class="s1">var parent = el.parentNode;</span><span class="s2">\n      </span><span class="s1">var pendingNode = parent &amp;&amp; parent._pending &amp;&amp; parent._pending[vnode.key];</span><span class="s2">\n      </span><span class="s1">if (pendingNode &amp;&amp; pendingNode.tag === vnode.tag &amp;&amp; pendingNode.elm._leaveCb) {</span><span class="s2">\n        </span><span class="s1">pendingNode.elm._leaveCb();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">enterHook &amp;&amp; enterHook(el, cb);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// start enter transition</span><span class="s2">\n  </span><span class="s1">beforeEnterHook &amp;&amp; beforeEnterHook(el);</span><span class="s2">\n  </span><span class="s1">if (expectsCSS) {</span><span class="s2">\n    </span><span class="s1">addTransitionClass(el, startClass);</span><span class="s2">\n    </span><span class="s1">addTransitionClass(el, activeClass);</span><span class="s2">\n    </span><span class="s1">nextFrame(function () {</span><span class="s2">\n      </span><span class="s1">removeTransitionClass(el, startClass);</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error</span><span class="s2">\n      </span><span class="s1">if (!cb.cancelled) {</span><span class="s2">\n        </span><span class="s1">addTransitionClass(el, toClass);</span><span class="s2">\n        </span><span class="s1">if (!userWantsControl) {</span><span class="s2">\n          </span><span class="s1">if (isValidDuration(explicitEnterDuration)) {</span><span class="s2">\n            </span><span class="s1">setTimeout(cb, explicitEnterDuration);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">whenTransitionEnds(el, type, cb);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (vnode.data.show) {</span><span class="s2">\n    </span><span class="s1">toggleDisplay &amp;&amp; toggleDisplay();</span><span class="s2">\n    </span><span class="s1">enterHook &amp;&amp; enterHook(el, cb);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!expectsCSS &amp;&amp; !userWantsControl) {</span><span class="s2">\n    </span><span class="s1">cb();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function leave(vnode, rm) {</span><span class="s2">\n  </span><span class="s1">var el = vnode.elm;</span><span class="s2">\n  </span><span class="s1">// call enter callback now</span><span class="s2">\n  </span><span class="s1">if (isDef(el._enterCb)) {</span><span class="s2">\n    </span><span class="s1">el._enterCb.cancelled = true;</span><span class="s2">\n    </span><span class="s1">el._enterCb();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var data = resolveTransition(vnode.data.transition);</span><span class="s2">\n  </span><span class="s1">if (isUndef(data) || el.nodeType !== 1) {</span><span class="s2">\n    </span><span class="s1">return rm();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (isDef(el._leaveCb)) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var css = data.css,</span><span class="s2">\n    </span><span class="s1">type = data.type,</span><span class="s2">\n    </span><span class="s1">leaveClass = data.leaveClass,</span><span class="s2">\n    </span><span class="s1">leaveToClass = data.leaveToClass,</span><span class="s2">\n    </span><span class="s1">leaveActiveClass = data.leaveActiveClass,</span><span class="s2">\n    </span><span class="s1">beforeLeave = data.beforeLeave,</span><span class="s2">\n    </span><span class="s1">leave = data.leave,</span><span class="s2">\n    </span><span class="s1">afterLeave = data.afterLeave,</span><span class="s2">\n    </span><span class="s1">leaveCancelled = data.leaveCancelled,</span><span class="s2">\n    </span><span class="s1">delayLeave = data.delayLeave,</span><span class="s2">\n    </span><span class="s1">duration = data.duration;</span><span class="s2">\n  </span><span class="s1">var expectsCSS = css !== false &amp;&amp; !isIE9;</span><span class="s2">\n  </span><span class="s1">var userWantsControl = getHookArgumentsLength(leave);</span><span class="s2">\n  </span><span class="s1">var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; isDef(explicitLeaveDuration)) {</span><span class="s2">\n    </span><span class="s1">checkDuration(explicitLeaveDuration, 'leave', vnode);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var cb = el._leaveCb = once(function () {</span><span class="s2">\n    </span><span class="s1">if (el.parentNode &amp;&amp; el.parentNode._pending) {</span><span class="s2">\n      </span><span class="s1">el.parentNode._pending[vnode.key] = null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (expectsCSS) {</span><span class="s2">\n      </span><span class="s1">removeTransitionClass(el, leaveToClass);</span><span class="s2">\n      </span><span class="s1">removeTransitionClass(el, leaveActiveClass);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">if (cb.cancelled) {</span><span class="s2">\n      </span><span class="s1">if (expectsCSS) {</span><span class="s2">\n        </span><span class="s1">removeTransitionClass(el, leaveClass);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">leaveCancelled &amp;&amp; leaveCancelled(el);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">rm();</span><span class="s2">\n      </span><span class="s1">afterLeave &amp;&amp; afterLeave(el);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">el._leaveCb = null;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">if (delayLeave) {</span><span class="s2">\n    </span><span class="s1">delayLeave(performLeave);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">performLeave();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function performLeave() {</span><span class="s2">\n    </span><span class="s1">// the delayed leave may have already been cancelled</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">if (cb.cancelled) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// record leaving element</span><span class="s2">\n    </span><span class="s1">if (!vnode.data.show &amp;&amp; el.parentNode) {</span><span class="s2">\n      </span><span class="s1">(el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">beforeLeave &amp;&amp; beforeLeave(el);</span><span class="s2">\n    </span><span class="s1">if (expectsCSS) {</span><span class="s2">\n      </span><span class="s1">addTransitionClass(el, leaveClass);</span><span class="s2">\n      </span><span class="s1">addTransitionClass(el, leaveActiveClass);</span><span class="s2">\n      </span><span class="s1">nextFrame(function () {</span><span class="s2">\n        </span><span class="s1">removeTransitionClass(el, leaveClass);</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error</span><span class="s2">\n        </span><span class="s1">if (!cb.cancelled) {</span><span class="s2">\n          </span><span class="s1">addTransitionClass(el, leaveToClass);</span><span class="s2">\n          </span><span class="s1">if (!userWantsControl) {</span><span class="s2">\n            </span><span class="s1">if (isValidDuration(explicitLeaveDuration)) {</span><span class="s2">\n              </span><span class="s1">setTimeout(cb, explicitLeaveDuration);</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">whenTransitionEnds(el, type, cb);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">leave &amp;&amp; leave(el, cb);</span><span class="s2">\n    </span><span class="s1">if (!expectsCSS &amp;&amp; !userWantsControl) {</span><span class="s2">\n      </span><span class="s1">cb();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// only used in dev mode</span><span class="s2">\n</span><span class="s1">function checkDuration(val, name, vnode) {</span><span class="s2">\n  </span><span class="s1">if (typeof val !== 'number') {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">&lt;transition&gt; explicit </span><span class="s2">\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot; </span><span class="s1">duration is not a valid number - </span><span class="s2">\&quot;</span><span class="s1">) + </span><span class="s2">\&quot;</span><span class="s1">got </span><span class="s2">\&quot;</span><span class="s1">.concat(JSON.stringify(val), </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">), vnode.context);</span><span class="s2">\n  </span><span class="s1">} else if (isNaN(val)) {</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">&lt;transition&gt; explicit </span><span class="s2">\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot; </span><span class="s1">duration is NaN - </span><span class="s2">\&quot;</span><span class="s1">) + 'the duration expression might be incorrect.', vnode.context);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isValidDuration(val) {</span><span class="s2">\n  </span><span class="s1">return typeof val === 'number' &amp;&amp; !isNaN(val);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Normalize a transition hook's argument length. The hook may be:</span><span class="s2">\n </span><span class="s1">* - a merged hook (invoker) with the original in .fns</span><span class="s2">\n </span><span class="s1">* - a wrapped component method (check ._length)</span><span class="s2">\n </span><span class="s1">* - a plain function (.length)</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function getHookArgumentsLength(fn) {</span><span class="s2">\n  </span><span class="s1">if (isUndef(fn)) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error</span><span class="s2">\n  </span><span class="s1">var invokerFns = fn.fns;</span><span class="s2">\n  </span><span class="s1">if (isDef(invokerFns)) {</span><span class="s2">\n    </span><span class="s1">// invoker</span><span class="s2">\n    </span><span class="s1">return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">return (fn._length || fn.length) &gt; 1;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function _enter(_, vnode) {</span><span class="s2">\n  </span><span class="s1">if (vnode.data.show !== true) {</span><span class="s2">\n    </span><span class="s1">enter(vnode);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var transition = inBrowser ? {</span><span class="s2">\n  </span><span class="s1">create: _enter,</span><span class="s2">\n  </span><span class="s1">activate: _enter,</span><span class="s2">\n  </span><span class="s1">remove: function (vnode, rm) {</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n    </span><span class="s1">if (vnode.data.show !== true) {</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error</span><span class="s2">\n      </span><span class="s1">leave(vnode, rm);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">rm();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">} : {};</span><span class="s2">\n</span><span class="s1">var platformModules = [attrs, klass, events, domProps, style, transition];</span><span class="s2">\n\n</span><span class="s1">// the directive module should be applied last, after all</span><span class="s2">\n</span><span class="s1">// built-in modules have been applied.</span><span class="s2">\n</span><span class="s1">var modules = platformModules.concat(baseModules);</span><span class="s2">\n</span><span class="s1">var patch = createPatchFunction({</span><span class="s2">\n  </span><span class="s1">nodeOps: nodeOps,</span><span class="s2">\n  </span><span class="s1">modules: modules</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Not type checking this file because flow doesn't like attaching</span><span class="s2">\n </span><span class="s1">* properties to Elements.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n</span><span class="s1">if (isIE9) {</span><span class="s2">\n  </span><span class="s1">// http://www.matts411.com/post/internet-explorer-9-oninput/</span><span class="s2">\n  </span><span class="s1">document.addEventListener('selectionchange', function () {</span><span class="s2">\n    </span><span class="s1">var el = document.activeElement;</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">if (el &amp;&amp; el.vmodel) {</span><span class="s2">\n      </span><span class="s1">trigger(el, 'input');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var directive = {</span><span class="s2">\n  </span><span class="s1">inserted: function (el, binding, vnode, oldVnode) {</span><span class="s2">\n    </span><span class="s1">if (vnode.tag === 'select') {</span><span class="s2">\n      </span><span class="s1">// #6903</span><span class="s2">\n      </span><span class="s1">if (oldVnode.elm &amp;&amp; !oldVnode.elm._vOptions) {</span><span class="s2">\n        </span><span class="s1">mergeVNodeHook(vnode, 'postpatch', function () {</span><span class="s2">\n          </span><span class="s1">directive.componentUpdated(el, binding, vnode);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">setSelected(el, binding, vnode.context);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">el._vOptions = [].map.call(el.options, getValue);</span><span class="s2">\n    </span><span class="s1">} else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {</span><span class="s2">\n      </span><span class="s1">el._vModifiers = binding.modifiers;</span><span class="s2">\n      </span><span class="s1">if (!binding.modifiers.lazy) {</span><span class="s2">\n        </span><span class="s1">el.addEventListener('compositionstart', onCompositionStart);</span><span class="s2">\n        </span><span class="s1">el.addEventListener('compositionend', onCompositionEnd);</span><span class="s2">\n        </span><span class="s1">// Safari &lt; 10.2 &amp; UIWebView doesn't fire compositionend when</span><span class="s2">\n        </span><span class="s1">// switching focus before confirming composition choice</span><span class="s2">\n        </span><span class="s1">// this also fixes the issue where some browsers e.g. iOS Chrome</span><span class="s2">\n        </span><span class="s1">// fires </span><span class="s2">\&quot;</span><span class="s1">change</span><span class="s2">\&quot; </span><span class="s1">instead of </span><span class="s2">\&quot;</span><span class="s1">input</span><span class="s2">\&quot; </span><span class="s1">on autocomplete.</span><span class="s2">\n        </span><span class="s1">el.addEventListener('change', onCompositionEnd);</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n        </span><span class="s1">if (isIE9) {</span><span class="s2">\n          </span><span class="s1">el.vmodel = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">componentUpdated: function (el, binding, vnode) {</span><span class="s2">\n    </span><span class="s1">if (vnode.tag === 'select') {</span><span class="s2">\n      </span><span class="s1">setSelected(el, binding, vnode.context);</span><span class="s2">\n      </span><span class="s1">// in case the options rendered by v-for have changed,</span><span class="s2">\n      </span><span class="s1">// it's possible that the value is out-of-sync with the rendered options.</span><span class="s2">\n      </span><span class="s1">// detect such cases and filter out values that no longer has a matching</span><span class="s2">\n      </span><span class="s1">// option in the DOM.</span><span class="s2">\n      </span><span class="s1">var prevOptions_1 = el._vOptions;</span><span class="s2">\n      </span><span class="s1">var curOptions_1 = el._vOptions = [].map.call(el.options, getValue);</span><span class="s2">\n      </span><span class="s1">if (curOptions_1.some(function (o, i) {</span><span class="s2">\n        </span><span class="s1">return !looseEqual(o, prevOptions_1[i]);</span><span class="s2">\n      </span><span class="s1">})) {</span><span class="s2">\n        </span><span class="s1">// trigger change event if</span><span class="s2">\n        </span><span class="s1">// no matching option found for at least one value</span><span class="s2">\n        </span><span class="s1">var needReset = el.multiple ? binding.value.some(function (v) {</span><span class="s2">\n          </span><span class="s1">return hasNoMatchingOption(v, curOptions_1);</span><span class="s2">\n        </span><span class="s1">}) : binding.value !== binding.oldValue &amp;&amp; hasNoMatchingOption(binding.value, curOptions_1);</span><span class="s2">\n        </span><span class="s1">if (needReset) {</span><span class="s2">\n          </span><span class="s1">trigger(el, 'change');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function setSelected(el, binding, vm) {</span><span class="s2">\n  </span><span class="s1">actuallySetSelected(el, binding, vm);</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (isIE || isEdge) {</span><span class="s2">\n    </span><span class="s1">setTimeout(function () {</span><span class="s2">\n      </span><span class="s1">actuallySetSelected(el, binding, vm);</span><span class="s2">\n    </span><span class="s1">}, 0);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function actuallySetSelected(el, binding, vm) {</span><span class="s2">\n  </span><span class="s1">var value = binding.value;</span><span class="s2">\n  </span><span class="s1">var isMultiple = el.multiple;</span><span class="s2">\n  </span><span class="s1">if (isMultiple &amp;&amp; !Array.isArray(value)) {</span><span class="s2">\n    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">&lt;select multiple v-model=</span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(binding.expression, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">&gt; </span><span class="s2">\&quot;</span><span class="s1">) + </span><span class="s2">\&quot;</span><span class="s1">expects an Array value for its binding, but got </span><span class="s2">\&quot;</span><span class="s1">.concat(Object.prototype.toString.call(value).slice(8, -1)), vm);</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var selected, option;</span><span class="s2">\n  </span><span class="s1">for (var i = 0, l = el.options.length; i &lt; l; i++) {</span><span class="s2">\n    </span><span class="s1">option = el.options[i];</span><span class="s2">\n    </span><span class="s1">if (isMultiple) {</span><span class="s2">\n      </span><span class="s1">selected = looseIndexOf(value, getValue(option)) &gt; -1;</span><span class="s2">\n      </span><span class="s1">if (option.selected !== selected) {</span><span class="s2">\n        </span><span class="s1">option.selected = selected;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">if (looseEqual(getValue(option), value)) {</span><span class="s2">\n        </span><span class="s1">if (el.selectedIndex !== i) {</span><span class="s2">\n          </span><span class="s1">el.selectedIndex = i;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!isMultiple) {</span><span class="s2">\n    </span><span class="s1">el.selectedIndex = -1;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function hasNoMatchingOption(value, options) {</span><span class="s2">\n  </span><span class="s1">return options.every(function (o) {</span><span class="s2">\n    </span><span class="s1">return !looseEqual(o, value);</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getValue(option) {</span><span class="s2">\n  </span><span class="s1">return '_value' in option ? option._value : option.value;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function onCompositionStart(e) {</span><span class="s2">\n  </span><span class="s1">e.target.composing = true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function onCompositionEnd(e) {</span><span class="s2">\n  </span><span class="s1">// prevent triggering an input event for no reason</span><span class="s2">\n  </span><span class="s1">if (!e.target.composing) return;</span><span class="s2">\n  </span><span class="s1">e.target.composing = false;</span><span class="s2">\n  </span><span class="s1">trigger(e.target, 'input');</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function trigger(el, type) {</span><span class="s2">\n  </span><span class="s1">var e = document.createEvent('HTMLEvents');</span><span class="s2">\n  </span><span class="s1">e.initEvent(type, true, true);</span><span class="s2">\n  </span><span class="s1">el.dispatchEvent(e);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// recursively search for possible transition defined inside the component root</span><span class="s2">\n</span><span class="s1">function locateNode(vnode) {</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error</span><span class="s2">\n  </span><span class="s1">return vnode.componentInstance &amp;&amp; (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var show = {</span><span class="s2">\n  </span><span class="s1">bind: function (el, _a, vnode) {</span><span class="s2">\n    </span><span class="s1">var value = _a.value;</span><span class="s2">\n    </span><span class="s1">vnode = locateNode(vnode);</span><span class="s2">\n    </span><span class="s1">var transition = vnode.data &amp;&amp; vnode.data.transition;</span><span class="s2">\n    </span><span class="s1">var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;</span><span class="s2">\n    </span><span class="s1">if (value &amp;&amp; transition) {</span><span class="s2">\n      </span><span class="s1">vnode.data.show = true;</span><span class="s2">\n      </span><span class="s1">enter(vnode, function () {</span><span class="s2">\n        </span><span class="s1">el.style.display = originalDisplay;</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">el.style.display = value ? originalDisplay : 'none';</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">update: function (el, _a, vnode) {</span><span class="s2">\n    </span><span class="s1">var value = _a.value,</span><span class="s2">\n      </span><span class="s1">oldValue = _a.oldValue;</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (!value === !oldValue) return;</span><span class="s2">\n    </span><span class="s1">vnode = locateNode(vnode);</span><span class="s2">\n    </span><span class="s1">var transition = vnode.data &amp;&amp; vnode.data.transition;</span><span class="s2">\n    </span><span class="s1">if (transition) {</span><span class="s2">\n      </span><span class="s1">vnode.data.show = true;</span><span class="s2">\n      </span><span class="s1">if (value) {</span><span class="s2">\n        </span><span class="s1">enter(vnode, function () {</span><span class="s2">\n          </span><span class="s1">el.style.display = el.__vOriginalDisplay;</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">leave(vnode, function () {</span><span class="s2">\n          </span><span class="s1">el.style.display = 'none';</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">el.style.display = value ? el.__vOriginalDisplay : 'none';</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">unbind: function (el, binding, vnode, oldVnode, isDestroy) {</span><span class="s2">\n    </span><span class="s1">if (!isDestroy) {</span><span class="s2">\n      </span><span class="s1">el.style.display = el.__vOriginalDisplay;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var platformDirectives = {</span><span class="s2">\n  </span><span class="s1">model: directive,</span><span class="s2">\n  </span><span class="s1">show: show</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// Provides transition support for a single element/component.</span><span class="s2">\n</span><span class="s1">var transitionProps = {</span><span class="s2">\n  </span><span class="s1">name: String,</span><span class="s2">\n  </span><span class="s1">appear: Boolean,</span><span class="s2">\n  </span><span class="s1">css: Boolean,</span><span class="s2">\n  </span><span class="s1">mode: String,</span><span class="s2">\n  </span><span class="s1">type: String,</span><span class="s2">\n  </span><span class="s1">enterClass: String,</span><span class="s2">\n  </span><span class="s1">leaveClass: String,</span><span class="s2">\n  </span><span class="s1">enterToClass: String,</span><span class="s2">\n  </span><span class="s1">leaveToClass: String,</span><span class="s2">\n  </span><span class="s1">enterActiveClass: String,</span><span class="s2">\n  </span><span class="s1">leaveActiveClass: String,</span><span class="s2">\n  </span><span class="s1">appearClass: String,</span><span class="s2">\n  </span><span class="s1">appearActiveClass: String,</span><span class="s2">\n  </span><span class="s1">appearToClass: String,</span><span class="s2">\n  </span><span class="s1">duration: [Number, String, Object]</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">// in case the child is also an abstract component, e.g. &lt;keep-alive&gt;</span><span class="s2">\n</span><span class="s1">// we want to recursively retrieve the real component to be rendered</span><span class="s2">\n</span><span class="s1">function getRealChild(vnode) {</span><span class="s2">\n  </span><span class="s1">var compOptions = vnode &amp;&amp; vnode.componentOptions;</span><span class="s2">\n  </span><span class="s1">if (compOptions &amp;&amp; compOptions.Ctor.options.abstract) {</span><span class="s2">\n    </span><span class="s1">return getRealChild(getFirstComponentChild(compOptions.children));</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return vnode;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function extractTransitionData(comp) {</span><span class="s2">\n  </span><span class="s1">var data = {};</span><span class="s2">\n  </span><span class="s1">var options = comp.$options;</span><span class="s2">\n  </span><span class="s1">// props</span><span class="s2">\n  </span><span class="s1">for (var key in options.propsData) {</span><span class="s2">\n    </span><span class="s1">data[key] = comp[key];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// events.</span><span class="s2">\n  </span><span class="s1">// extract listeners and pass them directly to the transition methods</span><span class="s2">\n  </span><span class="s1">var listeners = options._parentListeners;</span><span class="s2">\n  </span><span class="s1">for (var key in listeners) {</span><span class="s2">\n    </span><span class="s1">data[camelize(key)] = listeners[key];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return data;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function placeholder(h, rawChild) {</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error</span><span class="s2">\n  </span><span class="s1">if (/</span><span class="s2">\\</span><span class="s1">d-keep-alive$/.test(rawChild.tag)) {</span><span class="s2">\n    </span><span class="s1">return h('keep-alive', {</span><span class="s2">\n      </span><span class="s1">props: rawChild.componentOptions.propsData</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function hasParentTransition(vnode) {</span><span class="s2">\n  </span><span class="s1">while (vnode = vnode.parent) {</span><span class="s2">\n    </span><span class="s1">if (vnode.data.transition) {</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isSameChild(child, oldChild) {</span><span class="s2">\n  </span><span class="s1">return oldChild.key === child.key &amp;&amp; oldChild.tag === child.tag;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var isNotTextNode = function (c) {</span><span class="s2">\n  </span><span class="s1">return c.tag || isAsyncPlaceholder(c);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var isVShowDirective = function (d) {</span><span class="s2">\n  </span><span class="s1">return d.name === 'show';</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var Transition = {</span><span class="s2">\n  </span><span class="s1">name: 'transition',</span><span class="s2">\n  </span><span class="s1">props: transitionProps,</span><span class="s2">\n  </span><span class="s1">abstract: true,</span><span class="s2">\n  </span><span class="s1">render: function (h) {</span><span class="s2">\n    </span><span class="s1">var _this = this;</span><span class="s2">\n    </span><span class="s1">var children = this.$slots.default;</span><span class="s2">\n    </span><span class="s1">if (!children) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// filter out text nodes (possible whitespaces)</span><span class="s2">\n    </span><span class="s1">children = children.filter(isNotTextNode);</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (!children.length) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// warn multiple elements</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; children.length &gt; 1) {</span><span class="s2">\n      </span><span class="s1">warn('&lt;transition&gt; can only be used on a single element. Use ' + '&lt;transition-group&gt; for lists.', this.$parent);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var mode = this.mode;</span><span class="s2">\n    </span><span class="s1">// warn invalid mode</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; mode &amp;&amp; mode !== 'in-out' &amp;&amp; mode !== 'out-in') {</span><span class="s2">\n      </span><span class="s1">warn('invalid &lt;transition&gt; mode: ' + mode, this.$parent);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var rawChild = children[0];</span><span class="s2">\n    </span><span class="s1">// if this is a component root node and the component's</span><span class="s2">\n    </span><span class="s1">// parent container node also has transition, skip.</span><span class="s2">\n    </span><span class="s1">if (hasParentTransition(this.$vnode)) {</span><span class="s2">\n      </span><span class="s1">return rawChild;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// apply transition data to child</span><span class="s2">\n    </span><span class="s1">// use getRealChild() to ignore abstract components e.g. keep-alive</span><span class="s2">\n    </span><span class="s1">var child = getRealChild(rawChild);</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (!child) {</span><span class="s2">\n      </span><span class="s1">return rawChild;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (this._leaving) {</span><span class="s2">\n      </span><span class="s1">return placeholder(h, rawChild);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// ensure a key that is unique to the vnode type and to this transition</span><span class="s2">\n    </span><span class="s1">// component instance. This key will be used to remove pending leaving nodes</span><span class="s2">\n    </span><span class="s1">// during entering.</span><span class="s2">\n    </span><span class="s1">var id = </span><span class="s2">\&quot;</span><span class="s1">__transition-</span><span class="s2">\&quot;</span><span class="s1">.concat(this._uid, </span><span class="s2">\&quot;</span><span class="s1">-</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;</span><span class="s2">\n    </span><span class="s1">var data = (child.data || (child.data = {})).transition = extractTransitionData(this);</span><span class="s2">\n    </span><span class="s1">var oldRawChild = this._vnode;</span><span class="s2">\n    </span><span class="s1">var oldChild = getRealChild(oldRawChild);</span><span class="s2">\n    </span><span class="s1">// mark v-show</span><span class="s2">\n    </span><span class="s1">// so that the transition module can hand over the control to the directive</span><span class="s2">\n    </span><span class="s1">if (child.data.directives &amp;&amp; child.data.directives.some(isVShowDirective)) {</span><span class="s2">\n      </span><span class="s1">child.data.show = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (oldChild &amp;&amp; oldChild.data &amp;&amp; !isSameChild(child, oldChild) &amp;&amp; !isAsyncPlaceholder(oldChild) &amp;&amp;</span><span class="s2">\n    </span><span class="s1">// #6687 component root is a comment node</span><span class="s2">\n    </span><span class="s1">!(oldChild.componentInstance &amp;&amp; oldChild.componentInstance._vnode.isComment)) {</span><span class="s2">\n      </span><span class="s1">// replace old child transition data with fresh one</span><span class="s2">\n      </span><span class="s1">// important for dynamic transitions!</span><span class="s2">\n      </span><span class="s1">var oldData = oldChild.data.transition = extend({}, data);</span><span class="s2">\n      </span><span class="s1">// handle transition mode</span><span class="s2">\n      </span><span class="s1">if (mode === 'out-in') {</span><span class="s2">\n        </span><span class="s1">// return placeholder node and queue update when leave finishes</span><span class="s2">\n        </span><span class="s1">this._leaving = true;</span><span class="s2">\n        </span><span class="s1">mergeVNodeHook(oldData, 'afterLeave', function () {</span><span class="s2">\n          </span><span class="s1">_this._leaving = false;</span><span class="s2">\n          </span><span class="s1">_this.$forceUpdate();</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">return placeholder(h, rawChild);</span><span class="s2">\n      </span><span class="s1">} else if (mode === 'in-out') {</span><span class="s2">\n        </span><span class="s1">if (isAsyncPlaceholder(child)) {</span><span class="s2">\n          </span><span class="s1">return oldRawChild;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var delayedLeave_1;</span><span class="s2">\n        </span><span class="s1">var performLeave = function () {</span><span class="s2">\n          </span><span class="s1">delayedLeave_1();</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">mergeVNodeHook(data, 'afterEnter', performLeave);</span><span class="s2">\n        </span><span class="s1">mergeVNodeHook(data, 'enterCancelled', performLeave);</span><span class="s2">\n        </span><span class="s1">mergeVNodeHook(oldData, 'delayLeave', function (leave) {</span><span class="s2">\n          </span><span class="s1">delayedLeave_1 = leave;</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return rawChild;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// Provides transition support for list items.</span><span class="s2">\n</span><span class="s1">var props = extend({</span><span class="s2">\n  </span><span class="s1">tag: String,</span><span class="s2">\n  </span><span class="s1">moveClass: String</span><span class="s2">\n</span><span class="s1">}, transitionProps);</span><span class="s2">\n</span><span class="s1">delete props.mode;</span><span class="s2">\n</span><span class="s1">var TransitionGroup = {</span><span class="s2">\n  </span><span class="s1">props: props,</span><span class="s2">\n  </span><span class="s1">beforeMount: function () {</span><span class="s2">\n    </span><span class="s1">var _this = this;</span><span class="s2">\n    </span><span class="s1">var update = this._update;</span><span class="s2">\n    </span><span class="s1">this._update = function (vnode, hydrating) {</span><span class="s2">\n      </span><span class="s1">var restoreActiveInstance = setActiveInstance(_this);</span><span class="s2">\n      </span><span class="s1">// force removing pass</span><span class="s2">\n      </span><span class="s1">_this.__patch__(_this._vnode, _this.kept, false,</span><span class="s2">\n      </span><span class="s1">// hydrating</span><span class="s2">\n      </span><span class="s1">true // removeOnly (!important, avoids unnecessary moves)</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">_this._vnode = _this.kept;</span><span class="s2">\n      </span><span class="s1">restoreActiveInstance();</span><span class="s2">\n      </span><span class="s1">update.call(_this, vnode, hydrating);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">render: function (h) {</span><span class="s2">\n    </span><span class="s1">var tag = this.tag || this.$vnode.data.tag || 'span';</span><span class="s2">\n    </span><span class="s1">var map = Object.create(null);</span><span class="s2">\n    </span><span class="s1">var prevChildren = this.prevChildren = this.children;</span><span class="s2">\n    </span><span class="s1">var rawChildren = this.$slots.default || [];</span><span class="s2">\n    </span><span class="s1">var children = this.children = [];</span><span class="s2">\n    </span><span class="s1">var transitionData = extractTransitionData(this);</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; rawChildren.length; i++) {</span><span class="s2">\n      </span><span class="s1">var c = rawChildren[i];</span><span class="s2">\n      </span><span class="s1">if (c.tag) {</span><span class="s2">\n        </span><span class="s1">if (c.key != null &amp;&amp; String(c.key).indexOf('__vlist') !== 0) {</span><span class="s2">\n          </span><span class="s1">children.push(c);</span><span class="s2">\n          </span><span class="s1">map[c.key] = c;</span><span class="s2">\n          </span><span class="s1">(c.data || (c.data = {})).transition = transitionData;</span><span class="s2">\n        </span><span class="s1">} else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n          </span><span class="s1">var opts = c.componentOptions;</span><span class="s2">\n          </span><span class="s1">var name_1 = opts ? getComponentName(opts.Ctor.options) || opts.tag || '' : c.tag;</span><span class="s2">\n          </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">&lt;transition-group&gt; children must be keyed: &lt;</span><span class="s2">\&quot;</span><span class="s1">.concat(name_1, </span><span class="s2">\&quot;</span><span class="s1">&gt;</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (prevChildren) {</span><span class="s2">\n      </span><span class="s1">var kept = [];</span><span class="s2">\n      </span><span class="s1">var removed = [];</span><span class="s2">\n      </span><span class="s1">for (var i = 0; i &lt; prevChildren.length; i++) {</span><span class="s2">\n        </span><span class="s1">var c = prevChildren[i];</span><span class="s2">\n        </span><span class="s1">c.data.transition = transitionData;</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error .getBoundingClientRect is not typed in Node</span><span class="s2">\n        </span><span class="s1">c.data.pos = c.elm.getBoundingClientRect();</span><span class="s2">\n        </span><span class="s1">if (map[c.key]) {</span><span class="s2">\n          </span><span class="s1">kept.push(c);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">removed.push(c);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.kept = h(tag, null, kept);</span><span class="s2">\n      </span><span class="s1">this.removed = removed;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return h(tag, null, children);</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">updated: function () {</span><span class="s2">\n    </span><span class="s1">var children = this.prevChildren;</span><span class="s2">\n    </span><span class="s1">var moveClass = this.moveClass || (this.name || 'v') + '-move';</span><span class="s2">\n    </span><span class="s1">if (!children.length || !this.hasMove(children[0].elm, moveClass)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// we divide the work into three loops to avoid mixing DOM reads and writes</span><span class="s2">\n    </span><span class="s1">// in each iteration - which helps prevent layout thrashing.</span><span class="s2">\n    </span><span class="s1">children.forEach(callPendingCbs);</span><span class="s2">\n    </span><span class="s1">children.forEach(recordPosition);</span><span class="s2">\n    </span><span class="s1">children.forEach(applyTranslation);</span><span class="s2">\n    </span><span class="s1">// force reflow to put everything in position</span><span class="s2">\n    </span><span class="s1">// assign to this to avoid being removed in tree-shaking</span><span class="s2">\n    </span><span class="s1">// $flow-disable-line</span><span class="s2">\n    </span><span class="s1">this._reflow = document.body.offsetHeight;</span><span class="s2">\n    </span><span class="s1">children.forEach(function (c) {</span><span class="s2">\n      </span><span class="s1">if (c.data.moved) {</span><span class="s2">\n        </span><span class="s1">var el_1 = c.elm;</span><span class="s2">\n        </span><span class="s1">var s = el_1.style;</span><span class="s2">\n        </span><span class="s1">addTransitionClass(el_1, moveClass);</span><span class="s2">\n        </span><span class="s1">s.transform = s.WebkitTransform = s.transitionDuration = '';</span><span class="s2">\n        </span><span class="s1">el_1.addEventListener(transitionEndEvent, el_1._moveCb = function cb(e) {</span><span class="s2">\n          </span><span class="s1">if (e &amp;&amp; e.target !== el_1) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">if (!e || /transform$/.test(e.propertyName)) {</span><span class="s2">\n            </span><span class="s1">el_1.removeEventListener(transitionEndEvent, cb);</span><span class="s2">\n            </span><span class="s1">el_1._moveCb = null;</span><span class="s2">\n            </span><span class="s1">removeTransitionClass(el_1, moveClass);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">methods: {</span><span class="s2">\n    </span><span class="s1">hasMove: function (el, moveClass) {</span><span class="s2">\n      </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n      </span><span class="s1">if (!hasTransition) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n      </span><span class="s1">if (this._hasMove) {</span><span class="s2">\n        </span><span class="s1">return this._hasMove;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">// Detect whether an element with the move class applied has</span><span class="s2">\n      </span><span class="s1">// CSS transitions. Since the element may be inside an entering</span><span class="s2">\n      </span><span class="s1">// transition at this very moment, we make a clone of it and remove</span><span class="s2">\n      </span><span class="s1">// all other transition classes applied to ensure only the move class</span><span class="s2">\n      </span><span class="s1">// is applied.</span><span class="s2">\n      </span><span class="s1">var clone = el.cloneNode();</span><span class="s2">\n      </span><span class="s1">if (el._transitionClasses) {</span><span class="s2">\n        </span><span class="s1">el._transitionClasses.forEach(function (cls) {</span><span class="s2">\n          </span><span class="s1">removeClass(clone, cls);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">addClass(clone, moveClass);</span><span class="s2">\n      </span><span class="s1">clone.style.display = 'none';</span><span class="s2">\n      </span><span class="s1">this.$el.appendChild(clone);</span><span class="s2">\n      </span><span class="s1">var info = getTransitionInfo(clone);</span><span class="s2">\n      </span><span class="s1">this.$el.removeChild(clone);</span><span class="s2">\n      </span><span class="s1">return this._hasMove = info.hasTransform;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function callPendingCbs(c) {</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (c.elm._moveCb) {</span><span class="s2">\n    </span><span class="s1">c.elm._moveCb();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n  </span><span class="s1">if (c.elm._enterCb) {</span><span class="s2">\n    </span><span class="s1">c.elm._enterCb();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function recordPosition(c) {</span><span class="s2">\n  </span><span class="s1">c.data.newPos = c.elm.getBoundingClientRect();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function applyTranslation(c) {</span><span class="s2">\n  </span><span class="s1">var oldPos = c.data.pos;</span><span class="s2">\n  </span><span class="s1">var newPos = c.data.newPos;</span><span class="s2">\n  </span><span class="s1">var dx = oldPos.left - newPos.left;</span><span class="s2">\n  </span><span class="s1">var dy = oldPos.top - newPos.top;</span><span class="s2">\n  </span><span class="s1">if (dx || dy) {</span><span class="s2">\n    </span><span class="s1">c.data.moved = true;</span><span class="s2">\n    </span><span class="s1">var s = c.elm.style;</span><span class="s2">\n    </span><span class="s1">s.transform = s.WebkitTransform = </span><span class="s2">\&quot;</span><span class="s1">translate(</span><span class="s2">\&quot;</span><span class="s1">.concat(dx, </span><span class="s2">\&quot;</span><span class="s1">px,</span><span class="s2">\&quot;</span><span class="s1">).concat(dy, </span><span class="s2">\&quot;</span><span class="s1">px)</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">s.transitionDuration = '0s';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var platformComponents = {</span><span class="s2">\n  </span><span class="s1">Transition: Transition,</span><span class="s2">\n  </span><span class="s1">TransitionGroup: TransitionGroup</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// install platform specific utils</span><span class="s2">\n</span><span class="s1">Vue.config.mustUseProp = mustUseProp;</span><span class="s2">\n</span><span class="s1">Vue.config.isReservedTag = isReservedTag;</span><span class="s2">\n</span><span class="s1">Vue.config.isReservedAttr = isReservedAttr;</span><span class="s2">\n</span><span class="s1">Vue.config.getTagNamespace = getTagNamespace;</span><span class="s2">\n</span><span class="s1">Vue.config.isUnknownElement = isUnknownElement;</span><span class="s2">\n</span><span class="s1">// install platform runtime directives &amp; components</span><span class="s2">\n</span><span class="s1">extend(Vue.options.directives, platformDirectives);</span><span class="s2">\n</span><span class="s1">extend(Vue.options.components, platformComponents);</span><span class="s2">\n</span><span class="s1">// install platform patch function</span><span class="s2">\n</span><span class="s1">Vue.prototype.__patch__ = inBrowser ? patch : noop;</span><span class="s2">\n</span><span class="s1">// public mount method</span><span class="s2">\n</span><span class="s1">Vue.prototype.$mount = function (el, hydrating) {</span><span class="s2">\n  </span><span class="s1">el = el &amp;&amp; inBrowser ? query(el) : undefined;</span><span class="s2">\n  </span><span class="s1">return mountComponent(this, el, hydrating);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">// devtools global hook</span><span class="s2">\n</span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n</span><span class="s1">if (inBrowser) {</span><span class="s2">\n  </span><span class="s1">setTimeout(function () {</span><span class="s2">\n    </span><span class="s1">if (config.devtools) {</span><span class="s2">\n      </span><span class="s1">if (devtools) {</span><span class="s2">\n        </span><span class="s1">devtools.emit('init', Vue);</span><span class="s2">\n      </span><span class="s1">} else if (process.env.NODE_ENV !== 'production' &amp;&amp; process.env.NODE_ENV !== 'test') {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error</span><span class="s2">\n        </span><span class="s1">console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:</span><span class="s2">\\</span><span class="s1">n' + 'https://github.com/vuejs/vue-devtools');</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; process.env.NODE_ENV !== 'test' &amp;&amp; config.productionTip !== false &amp;&amp; typeof console !== 'undefined') {</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error</span><span class="s2">\n      </span><span class="s1">console[console.info ? 'info' : 'log'](</span><span class="s2">\&quot;</span><span class="s1">You are running Vue in development mode.</span><span class="s2">\\</span><span class="s1">n</span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">Make sure to turn on production mode when deploying for production.</span><span class="s2">\\</span><span class="s1">n</span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">See more tips at https://vuejs.org/guide/deployment.html</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, 0);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">export { EffectScope, computed, customRef, Vue as default, defineAsyncComponent, defineComponent, del, effectScope, getCurrentInstance, getCurrentScope, h, inject, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, mergeDefaults, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onScopeDispose, onServerPrefetch, onUnmounted, onUpdated, provide, proxyRefs, reactive, readonly, ref$1 as ref, set, shallowReactive, shallowReadonly, shallowRef, toRaw, toRef, toRefs, triggerRef, unref, useAttrs, useCssModule, useCssVars, useListeners, useSlots, version, watch, watchEffect, watchPostEffect, watchSyncEffect };&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">:{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s3">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;emptyObject&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;freeze&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isUndef&quot;</span><span class="s0">,</span><span class="s1">&quot;v&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;isDef&quot;</span><span class="s0">,</span><span class="s1">&quot;isTrue&quot;</span><span class="s0">,</span><span class="s1">&quot;isFalse&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrimitive&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;isObject&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;_toString&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;toRawType&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;isPlainObject&quot;</span><span class="s0">,</span><span class="s1">&quot;isRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidArrayIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;parseFloat&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;floor&quot;</span><span class="s0">,</span><span class="s1">&quot;isFinite&quot;</span><span class="s0">,</span><span class="s1">&quot;isPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;toNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;isNaN&quot;</span><span class="s0">,</span><span class="s1">&quot;makeMap&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;expectsLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;create&quot;</span><span class="s0">,</span><span class="s1">&quot;list&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;isBuiltInTag&quot;</span><span class="s0">,</span><span class="s1">&quot;isReservedAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;remove$2&quot;</span><span class="s0">,</span><span class="s1">&quot;arr&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;len&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwn&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;cached&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedFn&quot;</span><span class="s0">,</span><span class="s1">&quot;hit&quot;</span><span class="s0">,</span><span class="s1">&quot;camelizeRE&quot;</span><span class="s0">,</span><span class="s1">&quot;camelize&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;c&quot;</span><span class="s0">,</span><span class="s1">&quot;toUpperCase&quot;</span><span class="s0">,</span><span class="s1">&quot;capitalize&quot;</span><span class="s0">,</span><span class="s1">&quot;charAt&quot;</span><span class="s0">,</span><span class="s1">&quot;hyphenateRE&quot;</span><span class="s0">,</span><span class="s1">&quot;hyphenate&quot;</span><span class="s0">,</span><span class="s1">&quot;polyfillBind&quot;</span><span class="s0">,</span><span class="s1">&quot;ctx&quot;</span><span class="s0">,</span><span class="s1">&quot;boundFn&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;l&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;_length&quot;</span><span class="s0">,</span><span class="s1">&quot;nativeBind&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;Function&quot;</span><span class="s0">,</span><span class="s1">&quot;toArray&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;ret&quot;</span><span class="s0">,</span><span class="s1">&quot;extend&quot;</span><span class="s0">,</span><span class="s1">&quot;to&quot;</span><span class="s0">,</span><span class="s1">&quot;_from&quot;</span><span class="s0">,</span><span class="s1">&quot;toObject&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;noop&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;no&quot;</span><span class="s0">,</span><span class="s1">&quot;identity&quot;</span><span class="s0">,</span><span class="s1">&quot;looseEqual&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectA&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectB&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrayA&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrayB&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;getTime&quot;</span><span class="s0">,</span><span class="s1">&quot;keysA&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;keysB&quot;</span><span class="s0">,</span><span class="s1">&quot;looseIndexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;once&quot;</span><span class="s0">,</span><span class="s1">&quot;called&quot;</span><span class="s0">,</span><span class="s1">&quot;hasChanged&quot;</span><span class="s0">,</span><span class="s1">&quot;x&quot;</span><span class="s0">,</span><span class="s1">&quot;y&quot;</span><span class="s0">,</span><span class="s1">&quot;SSR_ATTR&quot;</span><span class="s0">,</span><span class="s1">&quot;ASSET_TYPES&quot;</span><span class="s0">,</span><span class="s1">&quot;LIFECYCLE_HOOKS&quot;</span><span class="s0">,</span><span class="s1">&quot;config&quot;</span><span class="s0">,</span><span class="s1">&quot;optionMergeStrategies&quot;</span><span class="s0">,</span><span class="s1">&quot;silent&quot;</span><span class="s0">,</span><span class="s1">&quot;productionTip&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;devtools&quot;</span><span class="s0">,</span><span class="s1">&quot;performance&quot;</span><span class="s0">,</span><span class="s1">&quot;errorHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;warnHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoredElements&quot;</span><span class="s0">,</span><span class="s1">&quot;keyCodes&quot;</span><span class="s0">,</span><span class="s1">&quot;isReservedTag&quot;</span><span class="s0">,</span><span class="s1">&quot;isReservedAttr&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnknownElement&quot;</span><span class="s0">,</span><span class="s1">&quot;getTagNamespace&quot;</span><span class="s0">,</span><span class="s1">&quot;parsePlatformTagName&quot;</span><span class="s0">,</span><span class="s1">&quot;mustUseProp&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;_lifecycleHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;unicodeRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;isReserved&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;def&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;writable&quot;</span><span class="s0">,</span><span class="s1">&quot;configurable&quot;</span><span class="s0">,</span><span class="s1">&quot;bailRE&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;parsePath&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;segments&quot;</span><span class="s0">,</span><span class="s1">&quot;hasProto&quot;</span><span class="s0">,</span><span class="s1">&quot;inBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;UA&quot;</span><span class="s0">,</span><span class="s1">&quot;navigator&quot;</span><span class="s0">,</span><span class="s1">&quot;userAgent&quot;</span><span class="s0">,</span><span class="s1">&quot;isIE&quot;</span><span class="s0">,</span><span class="s1">&quot;isIE9&quot;</span><span class="s0">,</span><span class="s1">&quot;isEdge&quot;</span><span class="s0">,</span><span class="s1">&quot;isIOS&quot;</span><span class="s0">,</span><span class="s1">&quot;isFF&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;nativeWatch&quot;</span><span class="s0">,</span><span class="s1">&quot;watch&quot;</span><span class="s0">,</span><span class="s1">&quot;supportsPassive&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;addEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;_isServer&quot;</span><span class="s0">,</span><span class="s1">&quot;isServerRendering&quot;</span><span class="s0">,</span><span class="s1">&quot;global&quot;</span><span class="s0">,</span><span class="s1">&quot;VUE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;__VUE_DEVTOOLS_GLOBAL_HOOK__&quot;</span><span class="s0">,</span><span class="s1">&quot;isNative&quot;</span><span class="s0">,</span><span class="s1">&quot;Ctor&quot;</span><span class="s0">,</span><span class="s1">&quot;hasSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;Reflect&quot;</span><span class="s0">,</span><span class="s1">&quot;ownKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;_Set&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;clear&quot;</span><span class="s0">,</span><span class="s1">&quot;currentInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;proxy&quot;</span><span class="s0">,</span><span class="s1">&quot;setCurrentInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;vm&quot;</span><span class="s0">,</span><span class="s1">&quot;_scope&quot;</span><span class="s0">,</span><span class="s1">&quot;off&quot;</span><span class="s0">,</span><span class="s1">&quot;on&quot;</span><span class="s0">,</span><span class="s1">&quot;VNode&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;text&quot;</span><span class="s0">,</span><span class="s1">&quot;elm&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;componentOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;asyncFactory&quot;</span><span class="s0">,</span><span class="s1">&quot;ns&quot;</span><span class="s0">,</span><span class="s1">&quot;fnContext&quot;</span><span class="s0">,</span><span class="s1">&quot;fnOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;fnScopeId&quot;</span><span class="s0">,</span><span class="s1">&quot;componentInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;raw&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootInsert&quot;</span><span class="s0">,</span><span class="s1">&quot;isComment&quot;</span><span class="s0">,</span><span class="s1">&quot;isCloned&quot;</span><span class="s0">,</span><span class="s1">&quot;isOnce&quot;</span><span class="s0">,</span><span class="s1">&quot;asyncMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;isAsyncPlaceholder&quot;</span><span class="s0">,</span><span class="s1">&quot;createEmptyVNode&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;createTextVNode&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneVNode&quot;</span><span class="s0">,</span><span class="s1">&quot;vnode&quot;</span><span class="s0">,</span><span class="s1">&quot;cloned&quot;</span><span class="s0">,</span><span class="s1">&quot;__assign&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;s&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;uid$2&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingCleanupDeps&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanupDeps&quot;</span><span class="s0">,</span><span class="s1">&quot;dep&quot;</span><span class="s0">,</span><span class="s1">&quot;subs&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;_pending&quot;</span><span class="s0">,</span><span class="s1">&quot;Dep&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;addSub&quot;</span><span class="s0">,</span><span class="s1">&quot;sub&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;removeSub&quot;</span><span class="s0">,</span><span class="s1">&quot;depend&quot;</span><span class="s0">,</span><span class="s1">&quot;info&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;addDep&quot;</span><span class="s0">,</span><span class="s1">&quot;onTrack&quot;</span><span class="s0">,</span><span class="s1">&quot;effect&quot;</span><span class="s0">,</span><span class="s1">&quot;notify&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">,</span><span class="s1">&quot;onTrigger&quot;</span><span class="s0">,</span><span class="s1">&quot;update&quot;</span><span class="s0">,</span><span class="s1">&quot;targetStack&quot;</span><span class="s0">,</span><span class="s1">&quot;pushTarget&quot;</span><span class="s0">,</span><span class="s1">&quot;popTarget&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayProto&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayMethods&quot;</span><span class="s0">,</span><span class="s1">&quot;methodsToPatch&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;original&quot;</span><span class="s0">,</span><span class="s1">&quot;mutator&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;_i&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;ob&quot;</span><span class="s0">,</span><span class="s1">&quot;__ob__&quot;</span><span class="s0">,</span><span class="s1">&quot;inserted&quot;</span><span class="s0">,</span><span class="s1">&quot;observeArray&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;getOwnPropertyNames&quot;</span><span class="s0">,</span><span class="s1">&quot;NO_INIITIAL_VALUE&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldObserve&quot;</span><span class="s0">,</span><span class="s1">&quot;toggleObserving&quot;</span><span class="s0">,</span><span class="s1">&quot;mockDep&quot;</span><span class="s0">,</span><span class="s1">&quot;Observer&quot;</span><span class="s0">,</span><span class="s1">&quot;shallow&quot;</span><span class="s0">,</span><span class="s1">&quot;mock&quot;</span><span class="s0">,</span><span class="s1">&quot;vmCount&quot;</span><span class="s0">,</span><span class="s1">&quot;__proto__&quot;</span><span class="s0">,</span><span class="s1">&quot;defineReactive&quot;</span><span class="s0">,</span><span class="s1">&quot;observe&quot;</span><span class="s0">,</span><span class="s1">&quot;ssrMockReactivity&quot;</span><span class="s0">,</span><span class="s1">&quot;isExtensible&quot;</span><span class="s0">,</span><span class="s1">&quot;__v_skip&quot;</span><span class="s0">,</span><span class="s1">&quot;isRef&quot;</span><span class="s0">,</span><span class="s1">&quot;customSetter&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;getOwnPropertyDescriptor&quot;</span><span class="s0">,</span><span class="s1">&quot;getter&quot;</span><span class="s0">,</span><span class="s1">&quot;setter&quot;</span><span class="s0">,</span><span class="s1">&quot;childOb&quot;</span><span class="s0">,</span><span class="s1">&quot;reactiveGetter&quot;</span><span class="s0">,</span><span class="s1">&quot;dependArray&quot;</span><span class="s0">,</span><span class="s1">&quot;reactiveSetter&quot;</span><span class="s0">,</span><span class="s1">&quot;newVal&quot;</span><span class="s0">,</span><span class="s1">&quot;newValue&quot;</span><span class="s0">,</span><span class="s1">&quot;oldValue&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;isReadonly&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;_isVue&quot;</span><span class="s0">,</span><span class="s1">&quot;del&quot;</span><span class="s0">,</span><span class="s1">&quot;reactive&quot;</span><span class="s0">,</span><span class="s1">&quot;makeReactive&quot;</span><span class="s0">,</span><span class="s1">&quot;shallowReactive&quot;</span><span class="s0">,</span><span class="s1">&quot;existingOb&quot;</span><span class="s0">,</span><span class="s1">&quot;isCollectionType&quot;</span><span class="s0">,</span><span class="s1">&quot;isReactive&quot;</span><span class="s0">,</span><span class="s1">&quot;isShallow&quot;</span><span class="s0">,</span><span class="s1">&quot;__v_isShallow&quot;</span><span class="s0">,</span><span class="s1">&quot;__v_isReadonly&quot;</span><span class="s0">,</span><span class="s1">&quot;isProxy&quot;</span><span class="s0">,</span><span class="s1">&quot;toRaw&quot;</span><span class="s0">,</span><span class="s1">&quot;observed&quot;</span><span class="s0">,</span><span class="s1">&quot;markRaw&quot;</span><span class="s0">,</span><span class="s1">&quot;RefFlag&quot;</span><span class="s0">,</span><span class="s1">&quot;r&quot;</span><span class="s0">,</span><span class="s1">&quot;__v_isRef&quot;</span><span class="s0">,</span><span class="s1">&quot;ref$1&quot;</span><span class="s0">,</span><span class="s1">&quot;createRef&quot;</span><span class="s0">,</span><span class="s1">&quot;shallowRef&quot;</span><span class="s0">,</span><span class="s1">&quot;rawValue&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;triggerRef&quot;</span><span class="s0">,</span><span class="s1">&quot;unref&quot;</span><span class="s0">,</span><span class="s1">&quot;proxyRefs&quot;</span><span class="s0">,</span><span class="s1">&quot;objectWithRefs&quot;</span><span class="s0">,</span><span class="s1">&quot;proxyWithRefUnwrap&quot;</span><span class="s0">,</span><span class="s1">&quot;customRef&quot;</span><span class="s0">,</span><span class="s1">&quot;factory&quot;</span><span class="s0">,</span><span class="s1">&quot;_a&quot;</span><span class="s0">,</span><span class="s1">&quot;toRefs&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;toRef&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultValue&quot;</span><span class="s0">,</span><span class="s1">&quot;rawToReadonlyFlag&quot;</span><span class="s0">,</span><span class="s1">&quot;rawToShallowReadonlyFlag&quot;</span><span class="s0">,</span><span class="s1">&quot;readonly&quot;</span><span class="s0">,</span><span class="s1">&quot;createReadonly&quot;</span><span class="s0">,</span><span class="s1">&quot;existingFlag&quot;</span><span class="s0">,</span><span class="s1">&quot;existingProxy&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrototypeOf&quot;</span><span class="s0">,</span><span class="s1">&quot;defineReadonlyProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;shallowReadonly&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;getterOrOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;debugOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;onlyGetter&quot;</span><span class="s0">,</span><span class="s1">&quot;watcher&quot;</span><span class="s0">,</span><span class="s1">&quot;Watcher&quot;</span><span class="s0">,</span><span class="s1">&quot;lazy&quot;</span><span class="s0">,</span><span class="s1">&quot;dirty&quot;</span><span class="s0">,</span><span class="s1">&quot;evaluate&quot;</span><span class="s0">,</span><span class="s1">&quot;WATCHER&quot;</span><span class="s0">,</span><span class="s1">&quot;WATCHER_CB&quot;</span><span class="s0">,</span><span class="s1">&quot;WATCHER_GETTER&quot;</span><span class="s0">,</span><span class="s1">&quot;WATCHER_CLEANUP&quot;</span><span class="s0">,</span><span class="s1">&quot;watchEffect&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;doWatch&quot;</span><span class="s0">,</span><span class="s1">&quot;watchPostEffect&quot;</span><span class="s0">,</span><span class="s1">&quot;flush&quot;</span><span class="s0">,</span><span class="s1">&quot;watchSyncEffect&quot;</span><span class="s0">,</span><span class="s1">&quot;INITIAL_WATCHER_VALUE&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;_b&quot;</span><span class="s0">,</span><span class="s1">&quot;immediate&quot;</span><span class="s0">,</span><span class="s1">&quot;deep&quot;</span><span class="s0">,</span><span class="s1">&quot;_c&quot;</span><span class="s0">,</span><span class="s1">&quot;warnInvalidSource&quot;</span><span class="s0">,</span><span class="s1">&quot;instance&quot;</span><span class="s0">,</span><span class="s1">&quot;invokeWithErrorHandling&quot;</span><span class="s0">,</span><span class="s1">&quot;forceTrigger&quot;</span><span class="s0">,</span><span class="s1">&quot;isMultiSource&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;_isDestroyed&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanup&quot;</span><span class="s0">,</span><span class="s1">&quot;onCleanup&quot;</span><span class="s0">,</span><span class="s1">&quot;baseGetter_1&quot;</span><span class="s0">,</span><span class="s1">&quot;onStop&quot;</span><span class="s0">,</span><span class="s1">&quot;noRecurse&quot;</span><span class="s0">,</span><span class="s1">&quot;run&quot;</span><span class="s0">,</span><span class="s1">&quot;active&quot;</span><span class="s0">,</span><span class="s1">&quot;post&quot;</span><span class="s0">,</span><span class="s1">&quot;queueWatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;_isMounted&quot;</span><span class="s0">,</span><span class="s1">&quot;buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;_preWatchers&quot;</span><span class="s0">,</span><span class="s1">&quot;$once&quot;</span><span class="s0">,</span><span class="s1">&quot;teardown&quot;</span><span class="s0">,</span><span class="s1">&quot;activeEffectScope&quot;</span><span class="s0">,</span><span class="s1">&quot;EffectScope&quot;</span><span class="s0">,</span><span class="s1">&quot;detached&quot;</span><span class="s0">,</span><span class="s1">&quot;effects&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanups&quot;</span><span class="s0">,</span><span class="s1">&quot;scopes&quot;</span><span class="s0">,</span><span class="s1">&quot;currentEffectScope&quot;</span><span class="s0">,</span><span class="s1">&quot;stop&quot;</span><span class="s0">,</span><span class="s1">&quot;fromParent&quot;</span><span class="s0">,</span><span class="s1">&quot;last&quot;</span><span class="s0">,</span><span class="s1">&quot;effectScope&quot;</span><span class="s0">,</span><span class="s1">&quot;recordEffectScope&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentScope&quot;</span><span class="s0">,</span><span class="s1">&quot;onScopeDispose&quot;</span><span class="s0">,</span><span class="s1">&quot;provide&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveProvided&quot;</span><span class="s0">,</span><span class="s1">&quot;existing&quot;</span><span class="s0">,</span><span class="s1">&quot;_provided&quot;</span><span class="s0">,</span><span class="s1">&quot;parentProvides&quot;</span><span class="s0">,</span><span class="s1">&quot;$parent&quot;</span><span class="s0">,</span><span class="s1">&quot;inject&quot;</span><span class="s0">,</span><span class="s1">&quot;treatDefaultAsFactory&quot;</span><span class="s0">,</span><span class="s1">&quot;provides&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;passive&quot;</span><span class="s0">,</span><span class="s1">&quot;capture&quot;</span><span class="s0">,</span><span class="s1">&quot;createFnInvoker&quot;</span><span class="s0">,</span><span class="s1">&quot;fns&quot;</span><span class="s0">,</span><span class="s1">&quot;invoker&quot;</span><span class="s0">,</span><span class="s1">&quot;updateListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;oldOn&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;createOnceHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;cur&quot;</span><span class="s0">,</span><span class="s1">&quot;old&quot;</span><span class="s0">,</span><span class="s1">&quot;event&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;mergeVNodeHook&quot;</span><span class="s0">,</span><span class="s1">&quot;hookKey&quot;</span><span class="s0">,</span><span class="s1">&quot;hook&quot;</span><span class="s0">,</span><span class="s1">&quot;oldHook&quot;</span><span class="s0">,</span><span class="s1">&quot;wrappedHook&quot;</span><span class="s0">,</span><span class="s1">&quot;merged&quot;</span><span class="s0">,</span><span class="s1">&quot;extractPropsFromVNodeData&quot;</span><span class="s0">,</span><span class="s1">&quot;propOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;attrs&quot;</span><span class="s0">,</span><span class="s1">&quot;altKey&quot;</span><span class="s0">,</span><span class="s1">&quot;keyInLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;tip&quot;</span><span class="s0">,</span><span class="s1">&quot;formatComponentName&quot;</span><span class="s0">,</span><span class="s1">&quot;checkProp&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;preserve&quot;</span><span class="s0">,</span><span class="s1">&quot;simpleNormalizeChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeArrayChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;isTextNode&quot;</span><span class="s0">,</span><span class="s1">&quot;nestedIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;lastIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;shift&quot;</span><span class="s0">,</span><span class="s1">&quot;_isVList&quot;</span><span class="s0">,</span><span class="s1">&quot;renderList&quot;</span><span class="s0">,</span><span class="s1">&quot;render&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;renderSlot&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackRender&quot;</span><span class="s0">,</span><span class="s1">&quot;bindObject&quot;</span><span class="s0">,</span><span class="s1">&quot;scopedSlotFn&quot;</span><span class="s0">,</span><span class="s1">&quot;$scopedSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;nodes&quot;</span><span class="s0">,</span><span class="s1">&quot;$slots&quot;</span><span class="s0">,</span><span class="s1">&quot;slot&quot;</span><span class="s0">,</span><span class="s1">&quot;$createElement&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveFilter&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveAsset&quot;</span><span class="s0">,</span><span class="s1">&quot;$options&quot;</span><span class="s0">,</span><span class="s1">&quot;isKeyNotMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;expect&quot;</span><span class="s0">,</span><span class="s1">&quot;actual&quot;</span><span class="s0">,</span><span class="s1">&quot;checkKeyCodes&quot;</span><span class="s0">,</span><span class="s1">&quot;eventKeyCode&quot;</span><span class="s0">,</span><span class="s1">&quot;builtInKeyCode&quot;</span><span class="s0">,</span><span class="s1">&quot;eventKeyName&quot;</span><span class="s0">,</span><span class="s1">&quot;builtInKeyName&quot;</span><span class="s0">,</span><span class="s1">&quot;mappedKeyCode&quot;</span><span class="s0">,</span><span class="s1">&quot;bindObjectProps&quot;</span><span class="s0">,</span><span class="s1">&quot;asProp&quot;</span><span class="s0">,</span><span class="s1">&quot;isSync&quot;</span><span class="s0">,</span><span class="s1">&quot;_loop_1&quot;</span><span class="s0">,</span><span class="s1">&quot;domProps&quot;</span><span class="s0">,</span><span class="s1">&quot;camelizedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;hyphenatedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;$event&quot;</span><span class="s0">,</span><span class="s1">&quot;renderStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;isInFor&quot;</span><span class="s0">,</span><span class="s1">&quot;_staticTrees&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;staticRenderFns&quot;</span><span class="s0">,</span><span class="s1">&quot;_renderProxy&quot;</span><span class="s0">,</span><span class="s1">&quot;markStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;markOnce&quot;</span><span class="s0">,</span><span class="s1">&quot;markStaticNode&quot;</span><span class="s0">,</span><span class="s1">&quot;bindObjectListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;ours&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveScopedSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;hasDynamicKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;contentHashKey&quot;</span><span class="s0">,</span><span class="s1">&quot;$stable&quot;</span><span class="s0">,</span><span class="s1">&quot;$key&quot;</span><span class="s0">,</span><span class="s1">&quot;bindDynamicKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;baseObj&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;prependModifier&quot;</span><span class="s0">,</span><span class="s1">&quot;symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;installRenderHelpers&quot;</span><span class="s0">,</span><span class="s1">&quot;_o&quot;</span><span class="s0">,</span><span class="s1">&quot;_n&quot;</span><span class="s0">,</span><span class="s1">&quot;_s&quot;</span><span class="s0">,</span><span class="s1">&quot;_l&quot;</span><span class="s0">,</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;_q&quot;</span><span class="s0">,</span><span class="s1">&quot;_m&quot;</span><span class="s0">,</span><span class="s1">&quot;_f&quot;</span><span class="s0">,</span><span class="s1">&quot;_k&quot;</span><span class="s0">,</span><span class="s1">&quot;_v&quot;</span><span class="s0">,</span><span class="s1">&quot;_e&quot;</span><span class="s0">,</span><span class="s1">&quot;_u&quot;</span><span class="s0">,</span><span class="s1">&quot;_g&quot;</span><span class="s0">,</span><span class="s1">&quot;_d&quot;</span><span class="s0">,</span><span class="s1">&quot;_p&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;slots&quot;</span><span class="s0">,</span><span class="s1">&quot;child&quot;</span><span class="s0">,</span><span class="s1">&quot;name_1&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">,</span><span class="s1">&quot;name_2&quot;</span><span class="s0">,</span><span class="s1">&quot;isWhitespace&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeScopedSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;ownerVm&quot;</span><span class="s0">,</span><span class="s1">&quot;scopedSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;normalSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;prevScopedSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;hasNormalSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;isStable&quot;</span><span class="s0">,</span><span class="s1">&quot;_normalized&quot;</span><span class="s0">,</span><span class="s1">&quot;$hasNormal&quot;</span><span class="s0">,</span><span class="s1">&quot;key_1&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeScopedSlot&quot;</span><span class="s0">,</span><span class="s1">&quot;key_2&quot;</span><span class="s0">,</span><span class="s1">&quot;proxyNormalSlot&quot;</span><span class="s0">,</span><span class="s1">&quot;normalized&quot;</span><span class="s0">,</span><span class="s1">&quot;initSetup&quot;</span><span class="s0">,</span><span class="s1">&quot;setup&quot;</span><span class="s0">,</span><span class="s1">&quot;_setupContext&quot;</span><span class="s0">,</span><span class="s1">&quot;createSetupContext&quot;</span><span class="s0">,</span><span class="s1">&quot;setupResult&quot;</span><span class="s0">,</span><span class="s1">&quot;_props&quot;</span><span class="s0">,</span><span class="s1">&quot;_setupState&quot;</span><span class="s0">,</span><span class="s1">&quot;__sfc&quot;</span><span class="s0">,</span><span class="s1">&quot;_setupProxy&quot;</span><span class="s0">,</span><span class="s1">&quot;exposeCalled&quot;</span><span class="s0">,</span><span class="s1">&quot;_attrsProxy&quot;</span><span class="s0">,</span><span class="s1">&quot;syncSetupProxy&quot;</span><span class="s0">,</span><span class="s1">&quot;$attrs&quot;</span><span class="s0">,</span><span class="s1">&quot;listeners&quot;</span><span class="s0">,</span><span class="s1">&quot;_listenersProxy&quot;</span><span class="s0">,</span><span class="s1">&quot;$listeners&quot;</span><span class="s0">,</span><span class="s1">&quot;initSlotsProxy&quot;</span><span class="s0">,</span><span class="s1">&quot;emit&quot;</span><span class="s0">,</span><span class="s1">&quot;$emit&quot;</span><span class="s0">,</span><span class="s1">&quot;expose&quot;</span><span class="s0">,</span><span class="s1">&quot;exposed&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;prev&quot;</span><span class="s0">,</span><span class="s1">&quot;changed&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProxyAttr&quot;</span><span class="s0">,</span><span class="s1">&quot;_slotsProxy&quot;</span><span class="s0">,</span><span class="s1">&quot;syncSetupSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;useSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;getContext&quot;</span><span class="s0">,</span><span class="s1">&quot;useAttrs&quot;</span><span class="s0">,</span><span class="s1">&quot;useListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;mergeDefaults&quot;</span><span class="s0">,</span><span class="s1">&quot;defaults&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;opt&quot;</span><span class="s0">,</span><span class="s1">&quot;initRender&quot;</span><span class="s0">,</span><span class="s1">&quot;_vnode&quot;</span><span class="s0">,</span><span class="s1">&quot;parentVnode&quot;</span><span class="s0">,</span><span class="s1">&quot;$vnode&quot;</span><span class="s0">,</span><span class="s1">&quot;_parentVnode&quot;</span><span class="s0">,</span><span class="s1">&quot;renderContext&quot;</span><span class="s0">,</span><span class="s1">&quot;_renderChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;d&quot;</span><span class="s0">,</span><span class="s1">&quot;createElement$1&quot;</span><span class="s0">,</span><span class="s1">&quot;parentData&quot;</span><span class="s0">,</span><span class="s1">&quot;isUpdatingChildComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;_parentListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;currentRenderingInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;renderMixin&quot;</span><span class="s0">,</span><span class="s1">&quot;Vue&quot;</span><span class="s0">,</span><span class="s1">&quot;$nextTick&quot;</span><span class="s0">,</span><span class="s1">&quot;nextTick&quot;</span><span class="s0">,</span><span class="s1">&quot;_render&quot;</span><span class="s0">,</span><span class="s1">&quot;handleError&quot;</span><span class="s0">,</span><span class="s1">&quot;renderError&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureCtor&quot;</span><span class="s0">,</span><span class="s1">&quot;comp&quot;</span><span class="s0">,</span><span class="s1">&quot;base&quot;</span><span class="s0">,</span><span class="s1">&quot;__esModule&quot;</span><span class="s0">,</span><span class="s1">&quot;toStringTag&quot;</span><span class="s0">,</span><span class="s1">&quot;createAsyncPlaceholder&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveAsyncComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;baseCtor&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;errorComp&quot;</span><span class="s0">,</span><span class="s1">&quot;resolved&quot;</span><span class="s0">,</span><span class="s1">&quot;owner&quot;</span><span class="s0">,</span><span class="s1">&quot;owners&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;loadingComp&quot;</span><span class="s0">,</span><span class="s1">&quot;owners_1&quot;</span><span class="s0">,</span><span class="s1">&quot;sync_1&quot;</span><span class="s0">,</span><span class="s1">&quot;timerLoading_1&quot;</span><span class="s0">,</span><span class="s1">&quot;timerTimeout_1&quot;</span><span class="s0">,</span><span class="s1">&quot;$on&quot;</span><span class="s0">,</span><span class="s1">&quot;forceRender_1&quot;</span><span class="s0">,</span><span class="s1">&quot;renderCompleted&quot;</span><span class="s0">,</span><span class="s1">&quot;$forceUpdate&quot;</span><span class="s0">,</span><span class="s1">&quot;clearTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;reject_1&quot;</span><span class="s0">,</span><span class="s1">&quot;reason&quot;</span><span class="s0">,</span><span class="s1">&quot;res_1&quot;</span><span class="s0">,</span><span class="s1">&quot;component&quot;</span><span class="s0">,</span><span class="s1">&quot;delay&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;timeout&quot;</span><span class="s0">,</span><span class="s1">&quot;getFirstComponentChild&quot;</span><span class="s0">,</span><span class="s1">&quot;SIMPLE_NORMALIZE&quot;</span><span class="s0">,</span><span class="s1">&quot;ALWAYS_NORMALIZE&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizationType&quot;</span><span class="s0">,</span><span class="s1">&quot;alwaysNormalize&quot;</span><span class="s0">,</span><span class="s1">&quot;_createElement&quot;</span><span class="s0">,</span><span class="s1">&quot;is&quot;</span><span class="s0">,</span><span class="s1">&quot;nativeOn&quot;</span><span class="s0">,</span><span class="s1">&quot;pre&quot;</span><span class="s0">,</span><span class="s1">&quot;createComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;applyNS&quot;</span><span class="s0">,</span><span class="s1">&quot;registerDeepBindings&quot;</span><span class="s0">,</span><span class="s1">&quot;force&quot;</span><span class="s0">,</span><span class="s1">&quot;style&quot;</span><span class="s0">,</span><span class="s1">&quot;class&quot;</span><span class="s0">,</span><span class="s1">&quot;h&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;hooks&quot;</span><span class="s0">,</span><span class="s1">&quot;errorCaptured&quot;</span><span class="s0">,</span><span class="s1">&quot;globalHandleError&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;_handled&quot;</span><span class="s0">,</span><span class="s1">&quot;logError&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;isUsingMicroTask&quot;</span><span class="s0">,</span><span class="s1">&quot;callbacks&quot;</span><span class="s0">,</span><span class="s1">&quot;pending&quot;</span><span class="s0">,</span><span class="s1">&quot;flushCallbacks&quot;</span><span class="s0">,</span><span class="s1">&quot;copies&quot;</span><span class="s0">,</span><span class="s1">&quot;timerFunc&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;p_1&quot;</span><span class="s0">,</span><span class="s1">&quot;MutationObserver&quot;</span><span class="s0">,</span><span class="s1">&quot;counter_1&quot;</span><span class="s0">,</span><span class="s1">&quot;observer&quot;</span><span class="s0">,</span><span class="s1">&quot;textNode_1&quot;</span><span class="s0">,</span><span class="s1">&quot;document&quot;</span><span class="s0">,</span><span class="s1">&quot;createTextNode&quot;</span><span class="s0">,</span><span class="s1">&quot;characterData&quot;</span><span class="s0">,</span><span class="s1">&quot;setImmediate&quot;</span><span class="s0">,</span><span class="s1">&quot;_resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;useCssModule&quot;</span><span class="s0">,</span><span class="s1">&quot;mod&quot;</span><span class="s0">,</span><span class="s1">&quot;useCssVars&quot;</span><span class="s0">,</span><span class="s1">&quot;el&quot;</span><span class="s0">,</span><span class="s1">&quot;$el&quot;</span><span class="s0">,</span><span class="s1">&quot;vars&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeType&quot;</span><span class="s0">,</span><span class="s1">&quot;setProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;defineAsyncComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;loader&quot;</span><span class="s0">,</span><span class="s1">&quot;loadingComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;errorComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;suspensible&quot;</span><span class="s0">,</span><span class="s1">&quot;userOnError&quot;</span><span class="s0">,</span><span class="s1">&quot;onError&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;retries&quot;</span><span class="s0">,</span><span class="s1">&quot;retry&quot;</span><span class="s0">,</span><span class="s1">&quot;load&quot;</span><span class="s0">,</span><span class="s1">&quot;thisRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;userRetry&quot;</span><span class="s0">,</span><span class="s1">&quot;userFail&quot;</span><span class="s0">,</span><span class="s1">&quot;createLifeCycle&quot;</span><span class="s0">,</span><span class="s1">&quot;hookName&quot;</span><span class="s0">,</span><span class="s1">&quot;formatName&quot;</span><span class="s0">,</span><span class="s1">&quot;injectHook&quot;</span><span class="s0">,</span><span class="s1">&quot;mergeLifecycleHook&quot;</span><span class="s0">,</span><span class="s1">&quot;onBeforeMount&quot;</span><span class="s0">,</span><span class="s1">&quot;onMounted&quot;</span><span class="s0">,</span><span class="s1">&quot;onBeforeUpdate&quot;</span><span class="s0">,</span><span class="s1">&quot;onUpdated&quot;</span><span class="s0">,</span><span class="s1">&quot;onBeforeUnmount&quot;</span><span class="s0">,</span><span class="s1">&quot;onUnmounted&quot;</span><span class="s0">,</span><span class="s1">&quot;onActivated&quot;</span><span class="s0">,</span><span class="s1">&quot;onDeactivated&quot;</span><span class="s0">,</span><span class="s1">&quot;onServerPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;onRenderTracked&quot;</span><span class="s0">,</span><span class="s1">&quot;onRenderTriggered&quot;</span><span class="s0">,</span><span class="s1">&quot;injectErrorCapturedHook&quot;</span><span class="s0">,</span><span class="s1">&quot;onErrorCaptured&quot;</span><span class="s0">,</span><span class="s1">&quot;version&quot;</span><span class="s0">,</span><span class="s1">&quot;defineComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;seenObjects&quot;</span><span class="s0">,</span><span class="s1">&quot;_traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;seen&quot;</span><span class="s0">,</span><span class="s1">&quot;isA&quot;</span><span class="s0">,</span><span class="s1">&quot;isFrozen&quot;</span><span class="s0">,</span><span class="s1">&quot;depId&quot;</span><span class="s0">,</span><span class="s1">&quot;uid$1&quot;</span><span class="s0">,</span><span class="s1">&quot;expOrFn&quot;</span><span class="s0">,</span><span class="s1">&quot;isRenderWatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;_vm&quot;</span><span class="s0">,</span><span class="s1">&quot;_watcher&quot;</span><span class="s0">,</span><span class="s1">&quot;user&quot;</span><span class="s0">,</span><span class="s1">&quot;sync&quot;</span><span class="s0">,</span><span class="s1">&quot;before&quot;</span><span class="s0">,</span><span class="s1">&quot;deps&quot;</span><span class="s0">,</span><span class="s1">&quot;newDeps&quot;</span><span class="s0">,</span><span class="s1">&quot;depIds&quot;</span><span class="s0">,</span><span class="s1">&quot;newDepIds&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;tmp&quot;</span><span class="s0">,</span><span class="s1">&quot;_isBeingDestroyed&quot;</span><span class="s0">,</span><span class="s1">&quot;mark&quot;</span><span class="s0">,</span><span class="s1">&quot;measure&quot;</span><span class="s0">,</span><span class="s1">&quot;perf_1&quot;</span><span class="s0">,</span><span class="s1">&quot;clearMarks&quot;</span><span class="s0">,</span><span class="s1">&quot;clearMeasures&quot;</span><span class="s0">,</span><span class="s1">&quot;startTag&quot;</span><span class="s0">,</span><span class="s1">&quot;endTag&quot;</span><span class="s0">,</span><span class="s1">&quot;initEvents&quot;</span><span class="s0">,</span><span class="s1">&quot;_events&quot;</span><span class="s0">,</span><span class="s1">&quot;_hasHookEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;updateComponentListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;target$1&quot;</span><span class="s0">,</span><span class="s1">&quot;add$1&quot;</span><span class="s0">,</span><span class="s1">&quot;remove$1&quot;</span><span class="s0">,</span><span class="s1">&quot;$off&quot;</span><span class="s0">,</span><span class="s1">&quot;createOnceHandler$1&quot;</span><span class="s0">,</span><span class="s1">&quot;_target&quot;</span><span class="s0">,</span><span class="s1">&quot;onceHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;oldListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;eventsMixin&quot;</span><span class="s0">,</span><span class="s1">&quot;hookRE&quot;</span><span class="s0">,</span><span class="s1">&quot;i_1&quot;</span><span class="s0">,</span><span class="s1">&quot;cbs&quot;</span><span class="s0">,</span><span class="s1">&quot;lowerCaseEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;activeInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;setActiveInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;prevActiveInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;initLifecycle&quot;</span><span class="s0">,</span><span class="s1">&quot;abstract&quot;</span><span class="s0">,</span><span class="s1">&quot;$children&quot;</span><span class="s0">,</span><span class="s1">&quot;$root&quot;</span><span class="s0">,</span><span class="s1">&quot;$refs&quot;</span><span class="s0">,</span><span class="s1">&quot;_inactive&quot;</span><span class="s0">,</span><span class="s1">&quot;_directInactive&quot;</span><span class="s0">,</span><span class="s1">&quot;lifecycleMixin&quot;</span><span class="s0">,</span><span class="s1">&quot;_update&quot;</span><span class="s0">,</span><span class="s1">&quot;hydrating&quot;</span><span class="s0">,</span><span class="s1">&quot;prevEl&quot;</span><span class="s0">,</span><span class="s1">&quot;prevVnode&quot;</span><span class="s0">,</span><span class="s1">&quot;restoreActiveInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;__patch__&quot;</span><span class="s0">,</span><span class="s1">&quot;__vue__&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapper&quot;</span><span class="s0">,</span><span class="s1">&quot;$destroy&quot;</span><span class="s0">,</span><span class="s1">&quot;callHook$1&quot;</span><span class="s0">,</span><span class="s1">&quot;_data&quot;</span><span class="s0">,</span><span class="s1">&quot;mountComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;updateComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;_name&quot;</span><span class="s0">,</span><span class="s1">&quot;_uid&quot;</span><span class="s0">,</span><span class="s1">&quot;watcherOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;preWatchers&quot;</span><span class="s0">,</span><span class="s1">&quot;updateChildComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;propsData&quot;</span><span class="s0">,</span><span class="s1">&quot;renderChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;newScopedSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;oldScopedSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;hasDynamicScopedSlot&quot;</span><span class="s0">,</span><span class="s1">&quot;needsForceUpdate&quot;</span><span class="s0">,</span><span class="s1">&quot;prevVNode&quot;</span><span class="s0">,</span><span class="s1">&quot;prevListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;propKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;_propKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;validateProp&quot;</span><span class="s0">,</span><span class="s1">&quot;isInInactiveTree&quot;</span><span class="s0">,</span><span class="s1">&quot;activateChildComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;direct&quot;</span><span class="s0">,</span><span class="s1">&quot;deactivateChildComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;setContext&quot;</span><span class="s0">,</span><span class="s1">&quot;handlers&quot;</span><span class="s0">,</span><span class="s1">&quot;j&quot;</span><span class="s0">,</span><span class="s1">&quot;MAX_UPDATE_COUNT&quot;</span><span class="s0">,</span><span class="s1">&quot;queue&quot;</span><span class="s0">,</span><span class="s1">&quot;activatedChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;circular&quot;</span><span class="s0">,</span><span class="s1">&quot;waiting&quot;</span><span class="s0">,</span><span class="s1">&quot;flushing&quot;</span><span class="s0">,</span><span class="s1">&quot;resetSchedulerState&quot;</span><span class="s0">,</span><span class="s1">&quot;currentFlushTimestamp&quot;</span><span class="s0">,</span><span class="s1">&quot;getNow&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;performance_1&quot;</span><span class="s0">,</span><span class="s1">&quot;createEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;timeStamp&quot;</span><span class="s0">,</span><span class="s1">&quot;sortCompareFn&quot;</span><span class="s0">,</span><span class="s1">&quot;flushSchedulerQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;activatedQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;callActivatedHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;callUpdatedHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;queueActivatedComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;initProvide&quot;</span><span class="s0">,</span><span class="s1">&quot;provideOption&quot;</span><span class="s0">,</span><span class="s1">&quot;provided&quot;</span><span class="s0">,</span><span class="s1">&quot;initInjections&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveInject&quot;</span><span class="s0">,</span><span class="s1">&quot;provideKey&quot;</span><span class="s0">,</span><span class="s1">&quot;provideDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;FunctionalRenderContext&quot;</span><span class="s0">,</span><span class="s1">&quot;_this&quot;</span><span class="s0">,</span><span class="s1">&quot;contextVm&quot;</span><span class="s0">,</span><span class="s1">&quot;_original&quot;</span><span class="s0">,</span><span class="s1">&quot;isCompiled&quot;</span><span class="s0">,</span><span class="s1">&quot;_compiled&quot;</span><span class="s0">,</span><span class="s1">&quot;needNormalization&quot;</span><span class="s0">,</span><span class="s1">&quot;injections&quot;</span><span class="s0">,</span><span class="s1">&quot;_scopeId&quot;</span><span class="s0">,</span><span class="s1">&quot;createFunctionalComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;mergeProps&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneAndMarkFunctionalResult&quot;</span><span class="s0">,</span><span class="s1">&quot;vnodes&quot;</span><span class="s0">,</span><span class="s1">&quot;clone&quot;</span><span class="s0">,</span><span class="s1">&quot;devtoolsMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;getComponentName&quot;</span><span class="s0">,</span><span class="s1">&quot;__name&quot;</span><span class="s0">,</span><span class="s1">&quot;_componentTag&quot;</span><span class="s0">,</span><span class="s1">&quot;componentVNodeHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;keepAlive&quot;</span><span class="s0">,</span><span class="s1">&quot;mountedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;prepatch&quot;</span><span class="s0">,</span><span class="s1">&quot;createComponentInstanceForVnode&quot;</span><span class="s0">,</span><span class="s1">&quot;$mount&quot;</span><span class="s0">,</span><span class="s1">&quot;oldVnode&quot;</span><span class="s0">,</span><span class="s1">&quot;insert&quot;</span><span class="s0">,</span><span class="s1">&quot;destroy&quot;</span><span class="s0">,</span><span class="s1">&quot;hooksToMerge&quot;</span><span class="s0">,</span><span class="s1">&quot;_base&quot;</span><span class="s0">,</span><span class="s1">&quot;cid&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveConstructorOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;model&quot;</span><span class="s0">,</span><span class="s1">&quot;transformModel&quot;</span><span class="s0">,</span><span class="s1">&quot;functional&quot;</span><span class="s0">,</span><span class="s1">&quot;installComponentHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;_isComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;inlineTemplate&quot;</span><span class="s0">,</span><span class="s1">&quot;toMerge&quot;</span><span class="s0">,</span><span class="s1">&quot;_merged&quot;</span><span class="s0">,</span><span class="s1">&quot;mergeHook&quot;</span><span class="s0">,</span><span class="s1">&quot;f1&quot;</span><span class="s0">,</span><span class="s1">&quot;f2&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;callback&quot;</span><span class="s0">,</span><span class="s1">&quot;generateComponentTrace&quot;</span><span class="s0">,</span><span class="s1">&quot;hasConsole_1&quot;</span><span class="s0">,</span><span class="s1">&quot;classifyRE_1&quot;</span><span class="s0">,</span><span class="s1">&quot;classify_1&quot;</span><span class="s0">,</span><span class="s1">&quot;msg&quot;</span><span class="s0">,</span><span class="s1">&quot;trace&quot;</span><span class="s0">,</span><span class="s1">&quot;includeFile&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;__file&quot;</span><span class="s0">,</span><span class="s1">&quot;repeat_1&quot;</span><span class="s0">,</span><span class="s1">&quot;currentRecursiveSequence&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;strats&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultStrat&quot;</span><span class="s0">,</span><span class="s1">&quot;mergeData&quot;</span><span class="s0">,</span><span class="s1">&quot;recursive&quot;</span><span class="s0">,</span><span class="s1">&quot;toVal&quot;</span><span class="s0">,</span><span class="s1">&quot;fromVal&quot;</span><span class="s0">,</span><span class="s1">&quot;mergeDataOrFn&quot;</span><span class="s0">,</span><span class="s1">&quot;parentVal&quot;</span><span class="s0">,</span><span class="s1">&quot;childVal&quot;</span><span class="s0">,</span><span class="s1">&quot;mergedDataFn&quot;</span><span class="s0">,</span><span class="s1">&quot;mergedInstanceDataFn&quot;</span><span class="s0">,</span><span class="s1">&quot;instanceData&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultData&quot;</span><span class="s0">,</span><span class="s1">&quot;dedupeHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;mergeAssets&quot;</span><span class="s0">,</span><span class="s1">&quot;assertObjectType&quot;</span><span class="s0">,</span><span class="s1">&quot;parent_1&quot;</span><span class="s0">,</span><span class="s1">&quot;methods&quot;</span><span class="s0">,</span><span class="s1">&quot;checkComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;components&quot;</span><span class="s0">,</span><span class="s1">&quot;validateComponentName&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeProps&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeInject&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeDirectives$1&quot;</span><span class="s0">,</span><span class="s1">&quot;dirs&quot;</span><span class="s0">,</span><span class="s1">&quot;directives&quot;</span><span class="s0">,</span><span class="s1">&quot;mergeOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;extends&quot;</span><span class="s0">,</span><span class="s1">&quot;mixins&quot;</span><span class="s0">,</span><span class="s1">&quot;mergeField&quot;</span><span class="s0">,</span><span class="s1">&quot;strat&quot;</span><span class="s0">,</span><span class="s1">&quot;warnMissing&quot;</span><span class="s0">,</span><span class="s1">&quot;assets&quot;</span><span class="s0">,</span><span class="s1">&quot;camelizedId&quot;</span><span class="s0">,</span><span class="s1">&quot;PascalCaseId&quot;</span><span class="s0">,</span><span class="s1">&quot;absent&quot;</span><span class="s0">,</span><span class="s1">&quot;booleanIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;getTypeIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;stringIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;getPropDefaultValue&quot;</span><span class="s0">,</span><span class="s1">&quot;prevShouldObserve&quot;</span><span class="s0">,</span><span class="s1">&quot;assertProp&quot;</span><span class="s0">,</span><span class="s1">&quot;getType&quot;</span><span class="s0">,</span><span class="s1">&quot;required&quot;</span><span class="s0">,</span><span class="s1">&quot;valid&quot;</span><span class="s0">,</span><span class="s1">&quot;expectedTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;assertedType&quot;</span><span class="s0">,</span><span class="s1">&quot;assertType&quot;</span><span class="s0">,</span><span class="s1">&quot;expectedType&quot;</span><span class="s0">,</span><span class="s1">&quot;haveExpectedTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;getInvalidTypeMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;validator&quot;</span><span class="s0">,</span><span class="s1">&quot;simpleCheckRE&quot;</span><span class="s0">,</span><span class="s1">&quot;functionTypeCheckRE&quot;</span><span class="s0">,</span><span class="s1">&quot;isSameType&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;receivedType&quot;</span><span class="s0">,</span><span class="s1">&quot;isExplicable&quot;</span><span class="s0">,</span><span class="s1">&quot;isBoolean&quot;</span><span class="s0">,</span><span class="s1">&quot;styleValue&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;EXPLICABLE_TYPES&quot;</span><span class="s0">,</span><span class="s1">&quot;elem&quot;</span><span class="s0">,</span><span class="s1">&quot;initProxy&quot;</span><span class="s0">,</span><span class="s1">&quot;allowedGlobals_1&quot;</span><span class="s0">,</span><span class="s1">&quot;warnNonPresent_1&quot;</span><span class="s0">,</span><span class="s1">&quot;warnReservedPrefix_1&quot;</span><span class="s0">,</span><span class="s1">&quot;hasProxy_1&quot;</span><span class="s0">,</span><span class="s1">&quot;Proxy&quot;</span><span class="s0">,</span><span class="s1">&quot;isBuiltInModifier_1&quot;</span><span class="s0">,</span><span class="s1">&quot;hasHandler_1&quot;</span><span class="s0">,</span><span class="s1">&quot;isAllowed&quot;</span><span class="s0">,</span><span class="s1">&quot;$data&quot;</span><span class="s0">,</span><span class="s1">&quot;getHandler_1&quot;</span><span class="s0">,</span><span class="s1">&quot;_withStripped&quot;</span><span class="s0">,</span><span class="s1">&quot;sharedPropertyDefinition&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceKey&quot;</span><span class="s0">,</span><span class="s1">&quot;proxyGetter&quot;</span><span class="s0">,</span><span class="s1">&quot;proxySetter&quot;</span><span class="s0">,</span><span class="s1">&quot;initState&quot;</span><span class="s0">,</span><span class="s1">&quot;initProps$1&quot;</span><span class="s0">,</span><span class="s1">&quot;initMethods&quot;</span><span class="s0">,</span><span class="s1">&quot;initData&quot;</span><span class="s0">,</span><span class="s1">&quot;initComputed$1&quot;</span><span class="s0">,</span><span class="s1">&quot;initWatch&quot;</span><span class="s0">,</span><span class="s1">&quot;propsOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;isRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;getData&quot;</span><span class="s0">,</span><span class="s1">&quot;computedWatcherOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;watchers&quot;</span><span class="s0">,</span><span class="s1">&quot;_computedWatchers&quot;</span><span class="s0">,</span><span class="s1">&quot;isSSR&quot;</span><span class="s0">,</span><span class="s1">&quot;userDef&quot;</span><span class="s0">,</span><span class="s1">&quot;defineComputed&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldCache&quot;</span><span class="s0">,</span><span class="s1">&quot;createComputedGetter&quot;</span><span class="s0">,</span><span class="s1">&quot;createGetterInvoker&quot;</span><span class="s0">,</span><span class="s1">&quot;computedGetter&quot;</span><span class="s0">,</span><span class="s1">&quot;createWatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;$watch&quot;</span><span class="s0">,</span><span class="s1">&quot;stateMixin&quot;</span><span class="s0">,</span><span class="s1">&quot;dataDef&quot;</span><span class="s0">,</span><span class="s1">&quot;propsDef&quot;</span><span class="s0">,</span><span class="s1">&quot;$set&quot;</span><span class="s0">,</span><span class="s1">&quot;$delete&quot;</span><span class="s0">,</span><span class="s1">&quot;unwatchFn&quot;</span><span class="s0">,</span><span class="s1">&quot;uid&quot;</span><span class="s0">,</span><span class="s1">&quot;initMixin$1&quot;</span><span class="s0">,</span><span class="s1">&quot;_init&quot;</span><span class="s0">,</span><span class="s1">&quot;initInternalComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;_self&quot;</span><span class="s0">,</span><span class="s1">&quot;vnodeComponentOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;super&quot;</span><span class="s0">,</span><span class="s1">&quot;superOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedSuperOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;modifiedOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveModifiedOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;extendOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;modified&quot;</span><span class="s0">,</span><span class="s1">&quot;latest&quot;</span><span class="s0">,</span><span class="s1">&quot;sealed&quot;</span><span class="s0">,</span><span class="s1">&quot;sealedOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;initUse&quot;</span><span class="s0">,</span><span class="s1">&quot;use&quot;</span><span class="s0">,</span><span class="s1">&quot;plugin&quot;</span><span class="s0">,</span><span class="s1">&quot;installedPlugins&quot;</span><span class="s0">,</span><span class="s1">&quot;_installedPlugins&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;install&quot;</span><span class="s0">,</span><span class="s1">&quot;initMixin&quot;</span><span class="s0">,</span><span class="s1">&quot;mixin&quot;</span><span class="s0">,</span><span class="s1">&quot;initExtend&quot;</span><span class="s0">,</span><span class="s1">&quot;Super&quot;</span><span class="s0">,</span><span class="s1">&quot;SuperId&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedCtors&quot;</span><span class="s0">,</span><span class="s1">&quot;_Ctor&quot;</span><span class="s0">,</span><span class="s1">&quot;Sub&quot;</span><span class="s0">,</span><span class="s1">&quot;VueComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;initProps&quot;</span><span class="s0">,</span><span class="s1">&quot;initComputed&quot;</span><span class="s0">,</span><span class="s1">&quot;Comp&quot;</span><span class="s0">,</span><span class="s1">&quot;initAssetRegisters&quot;</span><span class="s0">,</span><span class="s1">&quot;definition&quot;</span><span class="s0">,</span><span class="s1">&quot;_getComponentName&quot;</span><span class="s0">,</span><span class="s1">&quot;matches&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;pruneCache&quot;</span><span class="s0">,</span><span class="s1">&quot;keepAliveInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;pruneCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;patternTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;KeepAlive&quot;</span><span class="s0">,</span><span class="s1">&quot;include&quot;</span><span class="s0">,</span><span class="s1">&quot;exclude&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheVNode&quot;</span><span class="s0">,</span><span class="s1">&quot;vnodeToCache&quot;</span><span class="s0">,</span><span class="s1">&quot;keyToCache&quot;</span><span class="s0">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s0">,</span><span class="s1">&quot;created&quot;</span><span class="s0">,</span><span class="s1">&quot;destroyed&quot;</span><span class="s0">,</span><span class="s1">&quot;mounted&quot;</span><span class="s0">,</span><span class="s1">&quot;updated&quot;</span><span class="s0">,</span><span class="s1">&quot;builtInComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;initGlobalAPI&quot;</span><span class="s0">,</span><span class="s1">&quot;configDef&quot;</span><span class="s0">,</span><span class="s1">&quot;util&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;observable&quot;</span><span class="s0">,</span><span class="s1">&quot;ssrContext&quot;</span><span class="s0">,</span><span class="s1">&quot;acceptValue&quot;</span><span class="s0">,</span><span class="s1">&quot;attr&quot;</span><span class="s0">,</span><span class="s1">&quot;isEnumeratedAttr&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidContentEditableValue&quot;</span><span class="s0">,</span><span class="s1">&quot;convertEnumeratedValue&quot;</span><span class="s0">,</span><span class="s1">&quot;isFalsyAttrValue&quot;</span><span class="s0">,</span><span class="s1">&quot;isBooleanAttr&quot;</span><span class="s0">,</span><span class="s1">&quot;xlinkNS&quot;</span><span class="s0">,</span><span class="s1">&quot;isXlink&quot;</span><span class="s0">,</span><span class="s1">&quot;getXlinkProp&quot;</span><span class="s0">,</span><span class="s1">&quot;genClassForVnode&quot;</span><span class="s0">,</span><span class="s1">&quot;parentNode&quot;</span><span class="s0">,</span><span class="s1">&quot;childNode&quot;</span><span class="s0">,</span><span class="s1">&quot;mergeClassData&quot;</span><span class="s0">,</span><span class="s1">&quot;renderClass&quot;</span><span class="s0">,</span><span class="s1">&quot;staticClass&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicClass&quot;</span><span class="s0">,</span><span class="s1">&quot;stringifyClass&quot;</span><span class="s0">,</span><span class="s1">&quot;stringifyArray&quot;</span><span class="s0">,</span><span class="s1">&quot;stringifyObject&quot;</span><span class="s0">,</span><span class="s1">&quot;stringified&quot;</span><span class="s0">,</span><span class="s1">&quot;namespaceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;svg&quot;</span><span class="s0">,</span><span class="s1">&quot;math&quot;</span><span class="s0">,</span><span class="s1">&quot;isHTMLTag&quot;</span><span class="s0">,</span><span class="s1">&quot;isSVG&quot;</span><span class="s0">,</span><span class="s1">&quot;unknownElementCache&quot;</span><span class="s0">,</span><span class="s1">&quot;createElement&quot;</span><span class="s0">,</span><span class="s1">&quot;HTMLUnknownElement&quot;</span><span class="s0">,</span><span class="s1">&quot;HTMLElement&quot;</span><span class="s0">,</span><span class="s1">&quot;isTextInputType&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;selected&quot;</span><span class="s0">,</span><span class="s1">&quot;querySelector&quot;</span><span class="s0">,</span><span class="s1">&quot;tagName&quot;</span><span class="s0">,</span><span class="s1">&quot;multiple&quot;</span><span class="s0">,</span><span class="s1">&quot;setAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;createElementNS&quot;</span><span class="s0">,</span><span class="s1">&quot;namespace&quot;</span><span class="s0">,</span><span class="s1">&quot;createComment&quot;</span><span class="s0">,</span><span class="s1">&quot;insertBefore&quot;</span><span class="s0">,</span><span class="s1">&quot;newNode&quot;</span><span class="s0">,</span><span class="s1">&quot;referenceNode&quot;</span><span class="s0">,</span><span class="s1">&quot;removeChild&quot;</span><span class="s0">,</span><span class="s1">&quot;appendChild&quot;</span><span class="s0">,</span><span class="s1">&quot;nextSibling&quot;</span><span class="s0">,</span><span class="s1">&quot;setTextContent&quot;</span><span class="s0">,</span><span class="s1">&quot;textContent&quot;</span><span class="s0">,</span><span class="s1">&quot;setStyleScope&quot;</span><span class="s0">,</span><span class="s1">&quot;scopeId&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeOps&quot;</span><span class="s0">,</span><span class="s1">&quot;registerRef&quot;</span><span class="s0">,</span><span class="s1">&quot;isRemoval&quot;</span><span class="s0">,</span><span class="s1">&quot;refValue&quot;</span><span class="s0">,</span><span class="s1">&quot;$refsValue&quot;</span><span class="s0">,</span><span class="s1">&quot;isFor&quot;</span><span class="s0">,</span><span class="s1">&quot;refInFor&quot;</span><span class="s0">,</span><span class="s1">&quot;_isString&quot;</span><span class="s0">,</span><span class="s1">&quot;_isRef&quot;</span><span class="s0">,</span><span class="s1">&quot;refs&quot;</span><span class="s0">,</span><span class="s1">&quot;setSetupRef&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;emptyNode&quot;</span><span class="s0">,</span><span class="s1">&quot;sameVnode&quot;</span><span class="s0">,</span><span class="s1">&quot;sameInputType&quot;</span><span class="s0">,</span><span class="s1">&quot;typeA&quot;</span><span class="s0">,</span><span class="s1">&quot;typeB&quot;</span><span class="s0">,</span><span class="s1">&quot;createKeyToOldIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;beginIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;endIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;createPatchFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;backend&quot;</span><span class="s0">,</span><span class="s1">&quot;modules&quot;</span><span class="s0">,</span><span class="s1">&quot;emptyNodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;createRmCb&quot;</span><span class="s0">,</span><span class="s1">&quot;childElm&quot;</span><span class="s0">,</span><span class="s1">&quot;removeNode&quot;</span><span class="s0">,</span><span class="s1">&quot;inVPre&quot;</span><span class="s0">,</span><span class="s1">&quot;ignore&quot;</span><span class="s0">,</span><span class="s1">&quot;creatingElmInVPre&quot;</span><span class="s0">,</span><span class="s1">&quot;createElm&quot;</span><span class="s0">,</span><span class="s1">&quot;insertedVnodeQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;parentElm&quot;</span><span class="s0">,</span><span class="s1">&quot;refElm&quot;</span><span class="s0">,</span><span class="s1">&quot;nested&quot;</span><span class="s0">,</span><span class="s1">&quot;ownerArray&quot;</span><span class="s0">,</span><span class="s1">&quot;setScope&quot;</span><span class="s0">,</span><span class="s1">&quot;createChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;invokeCreateHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;isReactivated&quot;</span><span class="s0">,</span><span class="s1">&quot;initComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;reactivateComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingInsert&quot;</span><span class="s0">,</span><span class="s1">&quot;isPatchable&quot;</span><span class="s0">,</span><span class="s1">&quot;innerNode&quot;</span><span class="s0">,</span><span class="s1">&quot;transition&quot;</span><span class="s0">,</span><span class="s1">&quot;activate&quot;</span><span class="s0">,</span><span class="s1">&quot;checkDuplicateKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;i_2&quot;</span><span class="s0">,</span><span class="s1">&quot;ancestor&quot;</span><span class="s0">,</span><span class="s1">&quot;addVnodes&quot;</span><span class="s0">,</span><span class="s1">&quot;startIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;invokeDestroyHook&quot;</span><span class="s0">,</span><span class="s1">&quot;removeVnodes&quot;</span><span class="s0">,</span><span class="s1">&quot;ch&quot;</span><span class="s0">,</span><span class="s1">&quot;removeAndInvokeRemoveHook&quot;</span><span class="s0">,</span><span class="s1">&quot;rm&quot;</span><span class="s0">,</span><span class="s1">&quot;i_3&quot;</span><span class="s0">,</span><span class="s1">&quot;updateChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;oldCh&quot;</span><span class="s0">,</span><span class="s1">&quot;newCh&quot;</span><span class="s0">,</span><span class="s1">&quot;removeOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;oldStartIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;newStartIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;oldEndIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;oldStartVnode&quot;</span><span class="s0">,</span><span class="s1">&quot;oldEndVnode&quot;</span><span class="s0">,</span><span class="s1">&quot;newEndIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;newStartVnode&quot;</span><span class="s0">,</span><span class="s1">&quot;newEndVnode&quot;</span><span class="s0">,</span><span class="s1">&quot;oldKeyToIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;idxInOld&quot;</span><span class="s0">,</span><span class="s1">&quot;vnodeToMove&quot;</span><span class="s0">,</span><span class="s1">&quot;canMove&quot;</span><span class="s0">,</span><span class="s1">&quot;patchVnode&quot;</span><span class="s0">,</span><span class="s1">&quot;findIdxInOld&quot;</span><span class="s0">,</span><span class="s1">&quot;seenKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;i_4&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;i_5&quot;</span><span class="s0">,</span><span class="s1">&quot;hydrate&quot;</span><span class="s0">,</span><span class="s1">&quot;postpatch&quot;</span><span class="s0">,</span><span class="s1">&quot;invokeInsertHook&quot;</span><span class="s0">,</span><span class="s1">&quot;initial&quot;</span><span class="s0">,</span><span class="s1">&quot;i_6&quot;</span><span class="s0">,</span><span class="s1">&quot;hydrationBailed&quot;</span><span class="s0">,</span><span class="s1">&quot;isRenderedModule&quot;</span><span class="s0">,</span><span class="s1">&quot;assertNodeMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;hasChildNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;innerHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;childrenMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;firstChild&quot;</span><span class="s0">,</span><span class="s1">&quot;i_7&quot;</span><span class="s0">,</span><span class="s1">&quot;childNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;fullInvoke&quot;</span><span class="s0">,</span><span class="s1">&quot;patch&quot;</span><span class="s0">,</span><span class="s1">&quot;isInitialPatch&quot;</span><span class="s0">,</span><span class="s1">&quot;isRealElement&quot;</span><span class="s0">,</span><span class="s1">&quot;hasAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;removeAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;oldElm&quot;</span><span class="s0">,</span><span class="s1">&quot;_leaveCb&quot;</span><span class="s0">,</span><span class="s1">&quot;patchable&quot;</span><span class="s0">,</span><span class="s1">&quot;i_8&quot;</span><span class="s0">,</span><span class="s1">&quot;i_9&quot;</span><span class="s0">,</span><span class="s1">&quot;insert_1&quot;</span><span class="s0">,</span><span class="s1">&quot;i_10&quot;</span><span class="s0">,</span><span class="s1">&quot;updateDirectives&quot;</span><span class="s0">,</span><span class="s1">&quot;unbindDirectives&quot;</span><span class="s0">,</span><span class="s1">&quot;isCreate&quot;</span><span class="s0">,</span><span class="s1">&quot;isDestroy&quot;</span><span class="s0">,</span><span class="s1">&quot;oldDirs&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeDirectives&quot;</span><span class="s0">,</span><span class="s1">&quot;newDirs&quot;</span><span class="s0">,</span><span class="s1">&quot;dirsWithInsert&quot;</span><span class="s0">,</span><span class="s1">&quot;dirsWithPostpatch&quot;</span><span class="s0">,</span><span class="s1">&quot;oldDir&quot;</span><span class="s0">,</span><span class="s1">&quot;dir&quot;</span><span class="s0">,</span><span class="s1">&quot;callHook&quot;</span><span class="s0">,</span><span class="s1">&quot;oldArg&quot;</span><span class="s0">,</span><span class="s1">&quot;arg&quot;</span><span class="s0">,</span><span class="s1">&quot;componentUpdated&quot;</span><span class="s0">,</span><span class="s1">&quot;callInsert&quot;</span><span class="s0">,</span><span class="s1">&quot;emptyModifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;modifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;getRawDirName&quot;</span><span class="s0">,</span><span class="s1">&quot;setupDef&quot;</span><span class="s0">,</span><span class="s1">&quot;rawName&quot;</span><span class="s0">,</span><span class="s1">&quot;baseModules&quot;</span><span class="s0">,</span><span class="s1">&quot;updateAttrs&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritAttrs&quot;</span><span class="s0">,</span><span class="s1">&quot;oldAttrs&quot;</span><span class="s0">,</span><span class="s1">&quot;_v_attr_proxy&quot;</span><span class="s0">,</span><span class="s1">&quot;setAttr&quot;</span><span class="s0">,</span><span class="s1">&quot;removeAttributeNS&quot;</span><span class="s0">,</span><span class="s1">&quot;isInPre&quot;</span><span class="s0">,</span><span class="s1">&quot;baseSetAttr&quot;</span><span class="s0">,</span><span class="s1">&quot;setAttributeNS&quot;</span><span class="s0">,</span><span class="s1">&quot;__ieph&quot;</span><span class="s0">,</span><span class="s1">&quot;blocker_1&quot;</span><span class="s0">,</span><span class="s1">&quot;stopImmediatePropagation&quot;</span><span class="s0">,</span><span class="s1">&quot;removeEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;updateClass&quot;</span><span class="s0">,</span><span class="s1">&quot;oldData&quot;</span><span class="s0">,</span><span class="s1">&quot;cls&quot;</span><span class="s0">,</span><span class="s1">&quot;transitionClass&quot;</span><span class="s0">,</span><span class="s1">&quot;_transitionClasses&quot;</span><span class="s0">,</span><span class="s1">&quot;_prevClass&quot;</span><span class="s0">,</span><span class="s1">&quot;klass&quot;</span><span class="s0">,</span><span class="s1">&quot;RANGE_TOKEN&quot;</span><span class="s0">,</span><span class="s1">&quot;CHECKBOX_RADIO_TOKEN&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeEvents&quot;</span><span class="s0">,</span><span class="s1">&quot;event_1&quot;</span><span class="s0">,</span><span class="s1">&quot;change&quot;</span><span class="s0">,</span><span class="s1">&quot;useMicrotaskFix&quot;</span><span class="s0">,</span><span class="s1">&quot;attachedTimestamp_1&quot;</span><span class="s0">,</span><span class="s1">&quot;original_1&quot;</span><span class="s0">,</span><span class="s1">&quot;_wrapper&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTarget&quot;</span><span class="s0">,</span><span class="s1">&quot;ownerDocument&quot;</span><span class="s0">,</span><span class="s1">&quot;updateDOMListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;events&quot;</span><span class="s0">,</span><span class="s1">&quot;svgContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;updateDOMProps&quot;</span><span class="s0">,</span><span class="s1">&quot;oldProps&quot;</span><span class="s0">,</span><span class="s1">&quot;_value&quot;</span><span class="s0">,</span><span class="s1">&quot;strCur&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldUpdateValue&quot;</span><span class="s0">,</span><span class="s1">&quot;checkVal&quot;</span><span class="s0">,</span><span class="s1">&quot;composing&quot;</span><span class="s0">,</span><span class="s1">&quot;isNotInFocusAndDirty&quot;</span><span class="s0">,</span><span class="s1">&quot;isDirtyWithModifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;notInFocus&quot;</span><span class="s0">,</span><span class="s1">&quot;activeElement&quot;</span><span class="s0">,</span><span class="s1">&quot;_vModifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;number&quot;</span><span class="s0">,</span><span class="s1">&quot;trim&quot;</span><span class="s0">,</span><span class="s1">&quot;parseStyleText&quot;</span><span class="s0">,</span><span class="s1">&quot;cssText&quot;</span><span class="s0">,</span><span class="s1">&quot;listDelimiter&quot;</span><span class="s0">,</span><span class="s1">&quot;propertyDelimiter&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeStyleData&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeStyleBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;staticStyle&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingStyle&quot;</span><span class="s0">,</span><span class="s1">&quot;getStyle&quot;</span><span class="s0">,</span><span class="s1">&quot;checkChild&quot;</span><span class="s0">,</span><span class="s1">&quot;styleData&quot;</span><span class="s0">,</span><span class="s1">&quot;cssVarRE&quot;</span><span class="s0">,</span><span class="s1">&quot;importantRE&quot;</span><span class="s0">,</span><span class="s1">&quot;setProp&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedName&quot;</span><span class="s0">,</span><span class="s1">&quot;normalize&quot;</span><span class="s0">,</span><span class="s1">&quot;vendorNames&quot;</span><span class="s0">,</span><span class="s1">&quot;emptyStyle&quot;</span><span class="s0">,</span><span class="s1">&quot;capName&quot;</span><span class="s0">,</span><span class="s1">&quot;updateStyle&quot;</span><span class="s0">,</span><span class="s1">&quot;oldStaticStyle&quot;</span><span class="s0">,</span><span class="s1">&quot;oldStyleBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedStyle&quot;</span><span class="s0">,</span><span class="s1">&quot;oldStyle&quot;</span><span class="s0">,</span><span class="s1">&quot;newStyle&quot;</span><span class="s0">,</span><span class="s1">&quot;whitespaceRE&quot;</span><span class="s0">,</span><span class="s1">&quot;addClass&quot;</span><span class="s0">,</span><span class="s1">&quot;classList&quot;</span><span class="s0">,</span><span class="s1">&quot;getAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;removeClass&quot;</span><span class="s0">,</span><span class="s1">&quot;tar&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;css&quot;</span><span class="s0">,</span><span class="s1">&quot;autoCssTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;enterClass&quot;</span><span class="s0">,</span><span class="s1">&quot;enterToClass&quot;</span><span class="s0">,</span><span class="s1">&quot;enterActiveClass&quot;</span><span class="s0">,</span><span class="s1">&quot;leaveClass&quot;</span><span class="s0">,</span><span class="s1">&quot;leaveToClass&quot;</span><span class="s0">,</span><span class="s1">&quot;leaveActiveClass&quot;</span><span class="s0">,</span><span class="s1">&quot;hasTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;TRANSITION&quot;</span><span class="s0">,</span><span class="s1">&quot;ANIMATION&quot;</span><span class="s0">,</span><span class="s1">&quot;transitionProp&quot;</span><span class="s0">,</span><span class="s1">&quot;transitionEndEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;animationProp&quot;</span><span class="s0">,</span><span class="s1">&quot;animationEndEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;ontransitionend&quot;</span><span class="s0">,</span><span class="s1">&quot;onwebkittransitionend&quot;</span><span class="s0">,</span><span class="s1">&quot;onanimationend&quot;</span><span class="s0">,</span><span class="s1">&quot;onwebkitanimationend&quot;</span><span class="s0">,</span><span class="s1">&quot;raf&quot;</span><span class="s0">,</span><span class="s1">&quot;requestAnimationFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;nextFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;addTransitionClass&quot;</span><span class="s0">,</span><span class="s1">&quot;transitionClasses&quot;</span><span class="s0">,</span><span class="s1">&quot;removeTransitionClass&quot;</span><span class="s0">,</span><span class="s1">&quot;whenTransitionEnds&quot;</span><span class="s0">,</span><span class="s1">&quot;getTransitionInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;propCount&quot;</span><span class="s0">,</span><span class="s1">&quot;ended&quot;</span><span class="s0">,</span><span class="s1">&quot;onEnd&quot;</span><span class="s0">,</span><span class="s1">&quot;transformRE&quot;</span><span class="s0">,</span><span class="s1">&quot;styles&quot;</span><span class="s0">,</span><span class="s1">&quot;getComputedStyle&quot;</span><span class="s0">,</span><span class="s1">&quot;transitionDelays&quot;</span><span class="s0">,</span><span class="s1">&quot;transitionDurations&quot;</span><span class="s0">,</span><span class="s1">&quot;transitionTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;getTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;animationDelays&quot;</span><span class="s0">,</span><span class="s1">&quot;animationDurations&quot;</span><span class="s0">,</span><span class="s1">&quot;animationTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;hasTransform&quot;</span><span class="s0">,</span><span class="s1">&quot;delays&quot;</span><span class="s0">,</span><span class="s1">&quot;durations&quot;</span><span class="s0">,</span><span class="s1">&quot;toMs&quot;</span><span class="s0">,</span><span class="s1">&quot;enter&quot;</span><span class="s0">,</span><span class="s1">&quot;toggleDisplay&quot;</span><span class="s0">,</span><span class="s1">&quot;cancelled&quot;</span><span class="s0">,</span><span class="s1">&quot;_enterCb&quot;</span><span class="s0">,</span><span class="s1">&quot;appearClass&quot;</span><span class="s0">,</span><span class="s1">&quot;appearToClass&quot;</span><span class="s0">,</span><span class="s1">&quot;appearActiveClass&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeEnter&quot;</span><span class="s0">,</span><span class="s1">&quot;afterEnter&quot;</span><span class="s0">,</span><span class="s1">&quot;enterCancelled&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeAppear&quot;</span><span class="s0">,</span><span class="s1">&quot;appear&quot;</span><span class="s0">,</span><span class="s1">&quot;afterAppear&quot;</span><span class="s0">,</span><span class="s1">&quot;appearCancelled&quot;</span><span class="s0">,</span><span class="s1">&quot;duration&quot;</span><span class="s0">,</span><span class="s1">&quot;transitionNode&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppear&quot;</span><span class="s0">,</span><span class="s1">&quot;startClass&quot;</span><span class="s0">,</span><span class="s1">&quot;activeClass&quot;</span><span class="s0">,</span><span class="s1">&quot;toClass&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeEnterHook&quot;</span><span class="s0">,</span><span class="s1">&quot;enterHook&quot;</span><span class="s0">,</span><span class="s1">&quot;afterEnterHook&quot;</span><span class="s0">,</span><span class="s1">&quot;enterCancelledHook&quot;</span><span class="s0">,</span><span class="s1">&quot;explicitEnterDuration&quot;</span><span class="s0">,</span><span class="s1">&quot;checkDuration&quot;</span><span class="s0">,</span><span class="s1">&quot;expectsCSS&quot;</span><span class="s0">,</span><span class="s1">&quot;userWantsControl&quot;</span><span class="s0">,</span><span class="s1">&quot;getHookArgumentsLength&quot;</span><span class="s0">,</span><span class="s1">&quot;show&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingNode&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidDuration&quot;</span><span class="s0">,</span><span class="s1">&quot;leave&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeLeave&quot;</span><span class="s0">,</span><span class="s1">&quot;afterLeave&quot;</span><span class="s0">,</span><span class="s1">&quot;leaveCancelled&quot;</span><span class="s0">,</span><span class="s1">&quot;delayLeave&quot;</span><span class="s0">,</span><span class="s1">&quot;explicitLeaveDuration&quot;</span><span class="s0">,</span><span class="s1">&quot;performLeave&quot;</span><span class="s0">,</span><span class="s1">&quot;invokerFns&quot;</span><span class="s0">,</span><span class="s1">&quot;_enter&quot;</span><span class="s0">,</span><span class="s1">&quot;platformModules&quot;</span><span class="s0">,</span><span class="s1">&quot;vmodel&quot;</span><span class="s0">,</span><span class="s1">&quot;trigger&quot;</span><span class="s0">,</span><span class="s1">&quot;directive&quot;</span><span class="s0">,</span><span class="s1">&quot;binding&quot;</span><span class="s0">,</span><span class="s1">&quot;_vOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;setSelected&quot;</span><span class="s0">,</span><span class="s1">&quot;getValue&quot;</span><span class="s0">,</span><span class="s1">&quot;onCompositionStart&quot;</span><span class="s0">,</span><span class="s1">&quot;onCompositionEnd&quot;</span><span class="s0">,</span><span class="s1">&quot;prevOptions_1&quot;</span><span class="s0">,</span><span class="s1">&quot;curOptions_1&quot;</span><span class="s0">,</span><span class="s1">&quot;o&quot;</span><span class="s0">,</span><span class="s1">&quot;needReset&quot;</span><span class="s0">,</span><span class="s1">&quot;hasNoMatchingOption&quot;</span><span class="s0">,</span><span class="s1">&quot;actuallySetSelected&quot;</span><span class="s0">,</span><span class="s1">&quot;isMultiple&quot;</span><span class="s0">,</span><span class="s1">&quot;option&quot;</span><span class="s0">,</span><span class="s1">&quot;selectedIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;initEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatchEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;locateNode&quot;</span><span class="s0">,</span><span class="s1">&quot;originalDisplay&quot;</span><span class="s0">,</span><span class="s1">&quot;__vOriginalDisplay&quot;</span><span class="s0">,</span><span class="s1">&quot;display&quot;</span><span class="s0">,</span><span class="s1">&quot;unbind&quot;</span><span class="s0">,</span><span class="s1">&quot;platformDirectives&quot;</span><span class="s0">,</span><span class="s1">&quot;transitionProps&quot;</span><span class="s0">,</span><span class="s1">&quot;mode&quot;</span><span class="s0">,</span><span class="s1">&quot;getRealChild&quot;</span><span class="s0">,</span><span class="s1">&quot;compOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;extractTransitionData&quot;</span><span class="s0">,</span><span class="s1">&quot;placeholder&quot;</span><span class="s0">,</span><span class="s1">&quot;rawChild&quot;</span><span class="s0">,</span><span class="s1">&quot;hasParentTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;isSameChild&quot;</span><span class="s0">,</span><span class="s1">&quot;oldChild&quot;</span><span class="s0">,</span><span class="s1">&quot;isNotTextNode&quot;</span><span class="s0">,</span><span class="s1">&quot;isVShowDirective&quot;</span><span class="s0">,</span><span class="s1">&quot;Transition&quot;</span><span class="s0">,</span><span class="s1">&quot;_leaving&quot;</span><span class="s0">,</span><span class="s1">&quot;oldRawChild&quot;</span><span class="s0">,</span><span class="s1">&quot;delayedLeave_1&quot;</span><span class="s0">,</span><span class="s1">&quot;moveClass&quot;</span><span class="s0">,</span><span class="s1">&quot;TransitionGroup&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeMount&quot;</span><span class="s0">,</span><span class="s1">&quot;kept&quot;</span><span class="s0">,</span><span class="s1">&quot;prevChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;rawChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;transitionData&quot;</span><span class="s0">,</span><span class="s1">&quot;removed&quot;</span><span class="s0">,</span><span class="s1">&quot;pos&quot;</span><span class="s0">,</span><span class="s1">&quot;getBoundingClientRect&quot;</span><span class="s0">,</span><span class="s1">&quot;hasMove&quot;</span><span class="s0">,</span><span class="s1">&quot;callPendingCbs&quot;</span><span class="s0">,</span><span class="s1">&quot;recordPosition&quot;</span><span class="s0">,</span><span class="s1">&quot;applyTranslation&quot;</span><span class="s0">,</span><span class="s1">&quot;_reflow&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;offsetHeight&quot;</span><span class="s0">,</span><span class="s1">&quot;moved&quot;</span><span class="s0">,</span><span class="s1">&quot;el_1&quot;</span><span class="s0">,</span><span class="s1">&quot;transform&quot;</span><span class="s0">,</span><span class="s1">&quot;WebkitTransform&quot;</span><span class="s0">,</span><span class="s1">&quot;transitionDuration&quot;</span><span class="s0">,</span><span class="s1">&quot;_moveCb&quot;</span><span class="s0">,</span><span class="s1">&quot;propertyName&quot;</span><span class="s0">,</span><span class="s1">&quot;_hasMove&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;newPos&quot;</span><span class="s0">,</span><span class="s1">&quot;oldPos&quot;</span><span class="s0">,</span><span class="s1">&quot;dx&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;dy&quot;</span><span class="s0">,</span><span class="s1">&quot;top&quot;</span><span class="s0">,</span><span class="s1">&quot;platformComponents&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;E:/work/project/manager/vue/node_modules/vue/dist/vue.runtime.esm.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/*!</span><span class="s2">\n </span><span class="s1">* Vue.js v2.7.14</span><span class="s2">\n </span><span class="s1">* (c) 2014-2022 Evan You</span><span class="s2">\n </span><span class="s1">* Released under the MIT License.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var emptyObject = Object.freeze({});</span><span class="s2">\n</span><span class="s1">var isArray = Array.isArray;</span><span class="s2">\n</span><span class="s1">// These helpers produce better VM code in JS engines due to their</span><span class="s2">\n</span><span class="s1">// explicitness and function inlining.</span><span class="s2">\n</span><span class="s1">function isUndef(v) {</span><span class="s2">\n    </span><span class="s1">return v === undefined || v === null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isDef(v) {</span><span class="s2">\n    </span><span class="s1">return v !== undefined &amp;&amp; v !== null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isTrue(v) {</span><span class="s2">\n    </span><span class="s1">return v === true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isFalse(v) {</span><span class="s2">\n    </span><span class="s1">return v === false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Check if value is primitive.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isPrimitive(value) {</span><span class="s2">\n    </span><span class="s1">return (typeof value === 'string' ||</span><span class="s2">\n        </span><span class="s1">typeof value === 'number' ||</span><span class="s2">\n        </span><span class="s1">// $flow-disable-line</span><span class="s2">\n        </span><span class="s1">typeof value === 'symbol' ||</span><span class="s2">\n        </span><span class="s1">typeof value === 'boolean');</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isFunction(value) {</span><span class="s2">\n    </span><span class="s1">return typeof value === 'function';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Quick object check - this is primarily used to tell</span><span class="s2">\n </span><span class="s1">* objects from primitive values when we know the value</span><span class="s2">\n </span><span class="s1">* is a JSON-compliant type.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isObject(obj) {</span><span class="s2">\n    </span><span class="s1">return obj !== null &amp;&amp; typeof obj === 'object';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Get the raw type string of a value, e.g., [object Object].</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var _toString = Object.prototype.toString;</span><span class="s2">\n</span><span class="s1">function toRawType(value) {</span><span class="s2">\n    </span><span class="s1">return _toString.call(value).slice(8, -1);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Strict object type check. Only returns true</span><span class="s2">\n </span><span class="s1">* for plain JavaScript objects.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isPlainObject(obj) {</span><span class="s2">\n    </span><span class="s1">return _toString.call(obj) === '[object Object]';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isRegExp(v) {</span><span class="s2">\n    </span><span class="s1">return _toString.call(v) === '[object RegExp]';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Check if val is a valid array index.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isValidArrayIndex(val) {</span><span class="s2">\n    </span><span class="s1">var n = parseFloat(String(val));</span><span class="s2">\n    </span><span class="s1">return n &gt;= 0 &amp;&amp; Math.floor(n) === n &amp;&amp; isFinite(val);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isPromise(val) {</span><span class="s2">\n    </span><span class="s1">return (isDef(val) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">typeof val.then === 'function' &amp;&amp;</span><span class="s2">\n        </span><span class="s1">typeof val.catch === 'function');</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Convert a value to a string that is actually rendered.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function toString(val) {</span><span class="s2">\n    </span><span class="s1">return val == null</span><span class="s2">\n        </span><span class="s1">? ''</span><span class="s2">\n        </span><span class="s1">: Array.isArray(val) || (isPlainObject(val) &amp;&amp; val.toString === _toString)</span><span class="s2">\n            </span><span class="s1">? JSON.stringify(val, null, 2)</span><span class="s2">\n            </span><span class="s1">: String(val);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Convert an input value to a number for persistence.</span><span class="s2">\n </span><span class="s1">* If the conversion fails, return original string.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function toNumber(val) {</span><span class="s2">\n    </span><span class="s1">var n = parseFloat(val);</span><span class="s2">\n    </span><span class="s1">return isNaN(n) ? val : n;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Make a map and return a function for checking if a key</span><span class="s2">\n </span><span class="s1">* is in that map.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function makeMap(str, expectsLowerCase) {</span><span class="s2">\n    </span><span class="s1">var map = Object.create(null);</span><span class="s2">\n    </span><span class="s1">var list = str.split(',');</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; list.length; i++) {</span><span class="s2">\n        </span><span class="s1">map[list[i]] = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return expectsLowerCase ? function (val) { return map[val.toLowerCase()]; } : function (val) { return map[val]; };</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Check if a tag is a built-in tag.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var isBuiltInTag = makeMap('slot,component', true);</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Check if an attribute is a reserved attribute.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Remove an item from an array.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function remove$2(arr, item) {</span><span class="s2">\n    </span><span class="s1">var len = arr.length;</span><span class="s2">\n    </span><span class="s1">if (len) {</span><span class="s2">\n        </span><span class="s1">// fast path for the only / last item</span><span class="s2">\n        </span><span class="s1">if (item === arr[len - 1]) {</span><span class="s2">\n            </span><span class="s1">arr.length = len - 1;</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var index = arr.indexOf(item);</span><span class="s2">\n        </span><span class="s1">if (index &gt; -1) {</span><span class="s2">\n            </span><span class="s1">return arr.splice(index, 1);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Check whether an object has the property.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var hasOwnProperty = Object.prototype.hasOwnProperty;</span><span class="s2">\n</span><span class="s1">function hasOwn(obj, key) {</span><span class="s2">\n    </span><span class="s1">return hasOwnProperty.call(obj, key);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Create a cached version of a pure function.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function cached(fn) {</span><span class="s2">\n    </span><span class="s1">var cache = Object.create(null);</span><span class="s2">\n    </span><span class="s1">return function cachedFn(str) {</span><span class="s2">\n        </span><span class="s1">var hit = cache[str];</span><span class="s2">\n        </span><span class="s1">return hit || (cache[str] = fn(str));</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Camelize a hyphen-delimited string.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var camelizeRE = /-(</span><span class="s2">\\</span><span class="s1">w)/g;</span><span class="s2">\n</span><span class="s1">var camelize = cached(function (str) {</span><span class="s2">\n    </span><span class="s1">return str.replace(camelizeRE, function (_, c) { return (c ? c.toUpperCase() : ''); });</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Capitalize a string.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var capitalize = cached(function (str) {</span><span class="s2">\n    </span><span class="s1">return str.charAt(0).toUpperCase() + str.slice(1);</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Hyphenate a camelCase string.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var hyphenateRE = /</span><span class="s2">\\</span><span class="s1">B([A-Z])/g;</span><span class="s2">\n</span><span class="s1">var hyphenate = cached(function (str) {</span><span class="s2">\n    </span><span class="s1">return str.replace(hyphenateRE, '-$1').toLowerCase();</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Simple bind polyfill for environments that do not support it,</span><span class="s2">\n </span><span class="s1">* e.g., PhantomJS 1.x. Technically, we don't need this anymore</span><span class="s2">\n </span><span class="s1">* since native bind is now performant enough in most browsers.</span><span class="s2">\n </span><span class="s1">* But removing it would mean breaking code that was able to run in</span><span class="s2">\n </span><span class="s1">* PhantomJS 1.x, so this must be kept for backward compatibility.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n</span><span class="s1">function polyfillBind(fn, ctx) {</span><span class="s2">\n    </span><span class="s1">function boundFn(a) {</span><span class="s2">\n        </span><span class="s1">var l = arguments.length;</span><span class="s2">\n        </span><span class="s1">return l</span><span class="s2">\n            </span><span class="s1">? l &gt; 1</span><span class="s2">\n                </span><span class="s1">? fn.apply(ctx, arguments)</span><span class="s2">\n                </span><span class="s1">: fn.call(ctx, a)</span><span class="s2">\n            </span><span class="s1">: fn.call(ctx);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">boundFn._length = fn.length;</span><span class="s2">\n    </span><span class="s1">return boundFn;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function nativeBind(fn, ctx) {</span><span class="s2">\n    </span><span class="s1">return fn.bind(ctx);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// @ts-expect-error bind cannot be `undefined`</span><span class="s2">\n</span><span class="s1">var bind = Function.prototype.bind ? nativeBind : polyfillBind;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Convert an Array-like object to a real Array.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function toArray(list, start) {</span><span class="s2">\n    </span><span class="s1">start = start || 0;</span><span class="s2">\n    </span><span class="s1">var i = list.length - start;</span><span class="s2">\n    </span><span class="s1">var ret = new Array(i);</span><span class="s2">\n    </span><span class="s1">while (i--) {</span><span class="s2">\n        </span><span class="s1">ret[i] = list[i + start];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return ret;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Mix properties into target object.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function extend(to, _from) {</span><span class="s2">\n    </span><span class="s1">for (var key in _from) {</span><span class="s2">\n        </span><span class="s1">to[key] = _from[key];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return to;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Merge an Array of Objects into a single Object.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function toObject(arr) {</span><span class="s2">\n    </span><span class="s1">var res = {};</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; arr.length; i++) {</span><span class="s2">\n        </span><span class="s1">if (arr[i]) {</span><span class="s2">\n            </span><span class="s1">extend(res, arr[i]);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/* eslint-disable no-unused-vars */</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Perform no operation.</span><span class="s2">\n </span><span class="s1">* Stubbing args to make Flow happy without leaving useless transpiled code</span><span class="s2">\n </span><span class="s1">* with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function noop(a, b, c) { }</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Always return false.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var no = function (a, b, c) { return false; };</span><span class="s2">\n</span><span class="s1">/* eslint-enable no-unused-vars */</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Return the same value.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var identity = function (_) { return _; };</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Check if two values are loosely equal - that is,</span><span class="s2">\n </span><span class="s1">* if they are plain objects, do they have the same shape?</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function looseEqual(a, b) {</span><span class="s2">\n    </span><span class="s1">if (a === b)</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">var isObjectA = isObject(a);</span><span class="s2">\n    </span><span class="s1">var isObjectB = isObject(b);</span><span class="s2">\n    </span><span class="s1">if (isObjectA &amp;&amp; isObjectB) {</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">var isArrayA = Array.isArray(a);</span><span class="s2">\n            </span><span class="s1">var isArrayB = Array.isArray(b);</span><span class="s2">\n            </span><span class="s1">if (isArrayA &amp;&amp; isArrayB) {</span><span class="s2">\n                </span><span class="s1">return (a.length === b.length &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">a.every(function (e, i) {</span><span class="s2">\n                        </span><span class="s1">return looseEqual(e, b[i]);</span><span class="s2">\n                    </span><span class="s1">}));</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (a instanceof Date &amp;&amp; b instanceof Date) {</span><span class="s2">\n                </span><span class="s1">return a.getTime() === b.getTime();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (!isArrayA &amp;&amp; !isArrayB) {</span><span class="s2">\n                </span><span class="s1">var keysA = Object.keys(a);</span><span class="s2">\n                </span><span class="s1">var keysB = Object.keys(b);</span><span class="s2">\n                </span><span class="s1">return (keysA.length === keysB.length &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">keysA.every(function (key) {</span><span class="s2">\n                        </span><span class="s1">return looseEqual(a[key], b[key]);</span><span class="s2">\n                    </span><span class="s1">}));</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n                </span><span class="s1">return false;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">catch (e) {</span><span class="s2">\n            </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n            </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (!isObjectA &amp;&amp; !isObjectB) {</span><span class="s2">\n        </span><span class="s1">return String(a) === String(b);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Return the first index at which a loosely equal value can be</span><span class="s2">\n </span><span class="s1">* found in the array (if value is a plain object, the array must</span><span class="s2">\n </span><span class="s1">* contain an object of the same shape), or -1 if it is not present.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function looseIndexOf(arr, val) {</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; arr.length; i++) {</span><span class="s2">\n        </span><span class="s1">if (looseEqual(arr[i], val))</span><span class="s2">\n            </span><span class="s1">return i;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return -1;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Ensure a function is called only once.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function once(fn) {</span><span class="s2">\n    </span><span class="s1">var called = false;</span><span class="s2">\n    </span><span class="s1">return function () {</span><span class="s2">\n        </span><span class="s1">if (!called) {</span><span class="s2">\n            </span><span class="s1">called = true;</span><span class="s2">\n            </span><span class="s1">fn.apply(this, arguments);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill</span><span class="s2">\n</span><span class="s1">function hasChanged(x, y) {</span><span class="s2">\n    </span><span class="s1">if (x === y) {</span><span class="s2">\n        </span><span class="s1">return x === 0 &amp;&amp; 1 / x !== 1 / y;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">return x === x || y === y;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var SSR_ATTR = 'data-server-rendered';</span><span class="s2">\n</span><span class="s1">var ASSET_TYPES = ['component', 'directive', 'filter'];</span><span class="s2">\n</span><span class="s1">var LIFECYCLE_HOOKS = [</span><span class="s2">\n    </span><span class="s1">'beforeCreate',</span><span class="s2">\n    </span><span class="s1">'created',</span><span class="s2">\n    </span><span class="s1">'beforeMount',</span><span class="s2">\n    </span><span class="s1">'mounted',</span><span class="s2">\n    </span><span class="s1">'beforeUpdate',</span><span class="s2">\n    </span><span class="s1">'updated',</span><span class="s2">\n    </span><span class="s1">'beforeDestroy',</span><span class="s2">\n    </span><span class="s1">'destroyed',</span><span class="s2">\n    </span><span class="s1">'activated',</span><span class="s2">\n    </span><span class="s1">'deactivated',</span><span class="s2">\n    </span><span class="s1">'errorCaptured',</span><span class="s2">\n    </span><span class="s1">'serverPrefetch',</span><span class="s2">\n    </span><span class="s1">'renderTracked',</span><span class="s2">\n    </span><span class="s1">'renderTriggered'</span><span class="s2">\n</span><span class="s1">];</span><span class="s2">\n\n</span><span class="s1">var config = {</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Option merge strategies (used in core/util/options)</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">// $flow-disable-line</span><span class="s2">\n    </span><span class="s1">optionMergeStrategies: Object.create(null),</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Whether to suppress warnings.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">silent: false,</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Show production mode tip message on boot?</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">productionTip: process.env.NODE_ENV !== 'production',</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Whether to enable devtools</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">devtools: process.env.NODE_ENV !== 'production',</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Whether to record perf</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">performance: false,</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Error handler for watcher errors</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">errorHandler: null,</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Warn handler for watcher warns</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">warnHandler: null,</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Ignore certain custom elements</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">ignoredElements: [],</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Custom user key aliases for v-on</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">// $flow-disable-line</span><span class="s2">\n    </span><span class="s1">keyCodes: Object.create(null),</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Check if a tag is reserved so that it cannot be registered as a</span><span class="s2">\n     </span><span class="s1">* component. This is platform-dependent and may be overwritten.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">isReservedTag: no,</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Check if an attribute is reserved so that it cannot be used as a component</span><span class="s2">\n     </span><span class="s1">* prop. This is platform-dependent and may be overwritten.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">isReservedAttr: no,</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Check if a tag is an unknown element.</span><span class="s2">\n     </span><span class="s1">* Platform-dependent.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">isUnknownElement: no,</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Get the namespace of an element</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">getTagNamespace: noop,</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Parse the real tag name for the specific platform.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">parsePlatformTagName: identity,</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Check if an attribute must be bound using property, e.g. value</span><span class="s2">\n     </span><span class="s1">* Platform-dependent.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">mustUseProp: no,</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Perform updates asynchronously. Intended to be used by Vue Test Utils</span><span class="s2">\n     </span><span class="s1">* This will significantly reduce performance if set to false.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">async: true,</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Exposed for legacy reasons</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">_lifecycleHooks: LIFECYCLE_HOOKS</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* unicode letters used for parsing html tags, component names and property paths.</span><span class="s2">\n </span><span class="s1">* using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname</span><span class="s2">\n </span><span class="s1">* skipping </span><span class="s2">\\</span><span class="s1">u10000-</span><span class="s2">\\</span><span class="s1">uEFFFF due to it freezing up PhantomJS</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var unicodeRegExp = /a-zA-Z</span><span class="s2">\\</span><span class="s1">u00B7</span><span class="s2">\\</span><span class="s1">u00C0-</span><span class="s2">\\</span><span class="s1">u00D6</span><span class="s2">\\</span><span class="s1">u00D8-</span><span class="s2">\\</span><span class="s1">u00F6</span><span class="s2">\\</span><span class="s1">u00F8-</span><span class="s2">\\</span><span class="s1">u037D</span><span class="s2">\\</span><span class="s1">u037F-</span><span class="s2">\\</span><span class="s1">u1FFF</span><span class="s2">\\</span><span class="s1">u200C-</span><span class="s2">\\</span><span class="s1">u200D</span><span class="s2">\\</span><span class="s1">u203F-</span><span class="s2">\\</span><span class="s1">u2040</span><span class="s2">\\</span><span class="s1">u2070-</span><span class="s2">\\</span><span class="s1">u218F</span><span class="s2">\\</span><span class="s1">u2C00-</span><span class="s2">\\</span><span class="s1">u2FEF</span><span class="s2">\\</span><span class="s1">u3001-</span><span class="s2">\\</span><span class="s1">uD7FF</span><span class="s2">\\</span><span class="s1">uF900-</span><span class="s2">\\</span><span class="s1">uFDCF</span><span class="s2">\\</span><span class="s1">uFDF0-</span><span class="s2">\\</span><span class="s1">uFFFD/;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Check if a string starts with $ or _</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isReserved(str) {</span><span class="s2">\n    </span><span class="s1">var c = (str + '').charCodeAt(0);</span><span class="s2">\n    </span><span class="s1">return c === 0x24 || c === 0x5f;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Define a property.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function def(obj, key, val, enumerable) {</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(obj, key, {</span><span class="s2">\n        </span><span class="s1">value: val,</span><span class="s2">\n        </span><span class="s1">enumerable: !!enumerable,</span><span class="s2">\n        </span><span class="s1">writable: true,</span><span class="s2">\n        </span><span class="s1">configurable: true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Parse simple path.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var bailRE = new RegExp(</span><span class="s2">\&quot;</span><span class="s1">[^</span><span class="s2">\&quot;</span><span class="s1">.concat(unicodeRegExp.source, </span><span class="s2">\&quot;</span><span class="s1">.$_</span><span class="s2">\\\\</span><span class="s1">d]</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n</span><span class="s1">function parsePath(path) {</span><span class="s2">\n    </span><span class="s1">if (bailRE.test(path)) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var segments = path.split('.');</span><span class="s2">\n    </span><span class="s1">return function (obj) {</span><span class="s2">\n        </span><span class="s1">for (var i = 0; i &lt; segments.length; i++) {</span><span class="s2">\n            </span><span class="s1">if (!obj)</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">obj = obj[segments[i]];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return obj;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// can we use __proto__?</span><span class="s2">\n</span><span class="s1">var hasProto = '__proto__' in {};</span><span class="s2">\n</span><span class="s1">// Browser environment sniffing</span><span class="s2">\n</span><span class="s1">var inBrowser = typeof window !== 'undefined';</span><span class="s2">\n</span><span class="s1">var UA = inBrowser &amp;&amp; window.navigator.userAgent.toLowerCase();</span><span class="s2">\n</span><span class="s1">var isIE = UA &amp;&amp; /msie|trident/.test(UA);</span><span class="s2">\n</span><span class="s1">var isIE9 = UA &amp;&amp; UA.indexOf('msie 9.0') &gt; 0;</span><span class="s2">\n</span><span class="s1">var isEdge = UA &amp;&amp; UA.indexOf('edge/') &gt; 0;</span><span class="s2">\n</span><span class="s1">UA &amp;&amp; UA.indexOf('android') &gt; 0;</span><span class="s2">\n</span><span class="s1">var isIOS = UA &amp;&amp; /iphone|ipad|ipod|ios/.test(UA);</span><span class="s2">\n</span><span class="s1">UA &amp;&amp; /chrome</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">d+/.test(UA) &amp;&amp; !isEdge;</span><span class="s2">\n</span><span class="s1">UA &amp;&amp; /phantomjs/.test(UA);</span><span class="s2">\n</span><span class="s1">var isFF = UA &amp;&amp; UA.match(/firefox</span><span class="s2">\\</span><span class="s1">/(</span><span class="s2">\\</span><span class="s1">d+)/);</span><span class="s2">\n</span><span class="s1">// Firefox has a </span><span class="s2">\&quot;</span><span class="s1">watch</span><span class="s2">\&quot; </span><span class="s1">function on Object.prototype...</span><span class="s2">\n</span><span class="s1">// @ts-expect-error firebox support</span><span class="s2">\n</span><span class="s1">var nativeWatch = {}.watch;</span><span class="s2">\n</span><span class="s1">var supportsPassive = false;</span><span class="s2">\n</span><span class="s1">if (inBrowser) {</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">var opts = {};</span><span class="s2">\n        </span><span class="s1">Object.defineProperty(opts, 'passive', {</span><span class="s2">\n            </span><span class="s1">get: function () {</span><span class="s2">\n                </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n                </span><span class="s1">supportsPassive = true;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}); // https://github.com/facebook/flow/issues/285</span><span class="s2">\n        </span><span class="s1">window.addEventListener('test-passive', null, opts);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">catch (e) { }</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// this needs to be lazy-evaled because vue may be required before</span><span class="s2">\n</span><span class="s1">// vue-server-renderer can set VUE_ENV</span><span class="s2">\n</span><span class="s1">var _isServer;</span><span class="s2">\n</span><span class="s1">var isServerRendering = function () {</span><span class="s2">\n    </span><span class="s1">if (_isServer === undefined) {</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n        </span><span class="s1">if (!inBrowser &amp;&amp; typeof global !== 'undefined') {</span><span class="s2">\n            </span><span class="s1">// detect presence of vue-server-renderer and avoid</span><span class="s2">\n            </span><span class="s1">// Webpack shimming the process</span><span class="s2">\n            </span><span class="s1">_isServer =</span><span class="s2">\n                </span><span class="s1">global['process'] &amp;&amp; global['process'].env.VUE_ENV === 'server';</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">_isServer = false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return _isServer;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">// detect devtools</span><span class="s2">\n</span><span class="s1">var devtools = inBrowser &amp;&amp; window.__VUE_DEVTOOLS_GLOBAL_HOOK__;</span><span class="s2">\n</span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n</span><span class="s1">function isNative(Ctor) {</span><span class="s2">\n    </span><span class="s1">return typeof Ctor === 'function' &amp;&amp; /native code/.test(Ctor.toString());</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var hasSymbol = typeof Symbol !== 'undefined' &amp;&amp;</span><span class="s2">\n    </span><span class="s1">isNative(Symbol) &amp;&amp;</span><span class="s2">\n    </span><span class="s1">typeof Reflect !== 'undefined' &amp;&amp;</span><span class="s2">\n    </span><span class="s1">isNative(Reflect.ownKeys);</span><span class="s2">\n</span><span class="s1">var _Set; // $flow-disable-line</span><span class="s2">\n</span><span class="s1">/* istanbul ignore if */ if (typeof Set !== 'undefined' &amp;&amp; isNative(Set)) {</span><span class="s2">\n    </span><span class="s1">// use native Set when available.</span><span class="s2">\n    </span><span class="s1">_Set = Set;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">else {</span><span class="s2">\n    </span><span class="s1">// a non-standard Set polyfill that only works with primitive keys.</span><span class="s2">\n    </span><span class="s1">_Set = /** @class */ (function () {</span><span class="s2">\n        </span><span class="s1">function Set() {</span><span class="s2">\n            </span><span class="s1">this.set = Object.create(null);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">Set.prototype.has = function (key) {</span><span class="s2">\n            </span><span class="s1">return this.set[key] === true;</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">Set.prototype.add = function (key) {</span><span class="s2">\n            </span><span class="s1">this.set[key] = true;</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">Set.prototype.clear = function () {</span><span class="s2">\n            </span><span class="s1">this.set = Object.create(null);</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">return Set;</span><span class="s2">\n    </span><span class="s1">}());</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var currentInstance = null;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* This is exposed for compatibility with v3 (e.g. some functions in VueUse</span><span class="s2">\n </span><span class="s1">* relies on it). Do not use this internally, just use `currentInstance`.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @internal this function needs manual type declaration because it relies</span><span class="s2">\n </span><span class="s1">* on previously manually authored types from Vue 2</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function getCurrentInstance() {</span><span class="s2">\n    </span><span class="s1">return currentInstance &amp;&amp; { proxy: currentInstance };</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function setCurrentInstance(vm) {</span><span class="s2">\n    </span><span class="s1">if (vm === void 0) { vm = null; }</span><span class="s2">\n    </span><span class="s1">if (!vm)</span><span class="s2">\n        </span><span class="s1">currentInstance &amp;&amp; currentInstance._scope.off();</span><span class="s2">\n    </span><span class="s1">currentInstance = vm;</span><span class="s2">\n    </span><span class="s1">vm &amp;&amp; vm._scope.on();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var VNode = /** @class */ (function () {</span><span class="s2">\n    </span><span class="s1">function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {</span><span class="s2">\n        </span><span class="s1">this.tag = tag;</span><span class="s2">\n        </span><span class="s1">this.data = data;</span><span class="s2">\n        </span><span class="s1">this.children = children;</span><span class="s2">\n        </span><span class="s1">this.text = text;</span><span class="s2">\n        </span><span class="s1">this.elm = elm;</span><span class="s2">\n        </span><span class="s1">this.ns = undefined;</span><span class="s2">\n        </span><span class="s1">this.context = context;</span><span class="s2">\n        </span><span class="s1">this.fnContext = undefined;</span><span class="s2">\n        </span><span class="s1">this.fnOptions = undefined;</span><span class="s2">\n        </span><span class="s1">this.fnScopeId = undefined;</span><span class="s2">\n        </span><span class="s1">this.key = data &amp;&amp; data.key;</span><span class="s2">\n        </span><span class="s1">this.componentOptions = componentOptions;</span><span class="s2">\n        </span><span class="s1">this.componentInstance = undefined;</span><span class="s2">\n        </span><span class="s1">this.parent = undefined;</span><span class="s2">\n        </span><span class="s1">this.raw = false;</span><span class="s2">\n        </span><span class="s1">this.isStatic = false;</span><span class="s2">\n        </span><span class="s1">this.isRootInsert = true;</span><span class="s2">\n        </span><span class="s1">this.isComment = false;</span><span class="s2">\n        </span><span class="s1">this.isCloned = false;</span><span class="s2">\n        </span><span class="s1">this.isOnce = false;</span><span class="s2">\n        </span><span class="s1">this.asyncFactory = asyncFactory;</span><span class="s2">\n        </span><span class="s1">this.asyncMeta = undefined;</span><span class="s2">\n        </span><span class="s1">this.isAsyncPlaceholder = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(VNode.prototype, </span><span class="s2">\&quot;</span><span class="s1">child</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n        </span><span class="s1">// DEPRECATED: alias for componentInstance for backwards compat.</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n        </span><span class="s1">get: function () {</span><span class="s2">\n            </span><span class="s1">return this.componentInstance;</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">enumerable: false,</span><span class="s2">\n        </span><span class="s1">configurable: true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return VNode;</span><span class="s2">\n</span><span class="s1">}());</span><span class="s2">\n</span><span class="s1">var createEmptyVNode = function (text) {</span><span class="s2">\n    </span><span class="s1">if (text === void 0) { text = ''; }</span><span class="s2">\n    </span><span class="s1">var node = new VNode();</span><span class="s2">\n    </span><span class="s1">node.text = text;</span><span class="s2">\n    </span><span class="s1">node.isComment = true;</span><span class="s2">\n    </span><span class="s1">return node;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function createTextVNode(val) {</span><span class="s2">\n    </span><span class="s1">return new VNode(undefined, undefined, undefined, String(val));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// optimized shallow clone</span><span class="s2">\n</span><span class="s1">// used for static nodes and slot nodes because they may be reused across</span><span class="s2">\n</span><span class="s1">// multiple renders, cloning them avoids errors when DOM manipulations rely</span><span class="s2">\n</span><span class="s1">// on their elm reference.</span><span class="s2">\n</span><span class="s1">function cloneVNode(vnode) {</span><span class="s2">\n    </span><span class="s1">var cloned = new VNode(vnode.tag, vnode.data, </span><span class="s2">\n    </span><span class="s1">// #7975</span><span class="s2">\n    </span><span class="s1">// clone children array to avoid mutating original in case of cloning</span><span class="s2">\n    </span><span class="s1">// a child.</span><span class="s2">\n    </span><span class="s1">vnode.children &amp;&amp; vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);</span><span class="s2">\n    </span><span class="s1">cloned.ns = vnode.ns;</span><span class="s2">\n    </span><span class="s1">cloned.isStatic = vnode.isStatic;</span><span class="s2">\n    </span><span class="s1">cloned.key = vnode.key;</span><span class="s2">\n    </span><span class="s1">cloned.isComment = vnode.isComment;</span><span class="s2">\n    </span><span class="s1">cloned.fnContext = vnode.fnContext;</span><span class="s2">\n    </span><span class="s1">cloned.fnOptions = vnode.fnOptions;</span><span class="s2">\n    </span><span class="s1">cloned.fnScopeId = vnode.fnScopeId;</span><span class="s2">\n    </span><span class="s1">cloned.asyncMeta = vnode.asyncMeta;</span><span class="s2">\n    </span><span class="s1">cloned.isCloned = true;</span><span class="s2">\n    </span><span class="s1">return cloned;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/******************************************************************************</span><span class="s2">\r\n</span><span class="s1">Copyright (c) Microsoft Corporation.</span><span class="s2">\r\n\r\n</span><span class="s1">Permission to use, copy, modify, and/or distribute this software for any</span><span class="s2">\r\n</span><span class="s1">purpose with or without fee is hereby granted.</span><span class="s2">\r\n\r\n</span><span class="s1">THE SOFTWARE IS PROVIDED </span><span class="s2">\&quot;</span><span class="s1">AS IS</span><span class="s2">\&quot; </span><span class="s1">AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH</span><span class="s2">\r\n</span><span class="s1">REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY</span><span class="s2">\r\n</span><span class="s1">AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,</span><span class="s2">\r\n</span><span class="s1">INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM</span><span class="s2">\r\n</span><span class="s1">LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR</span><span class="s2">\r\n</span><span class="s1">OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR</span><span class="s2">\r\n</span><span class="s1">PERFORMANCE OF THIS SOFTWARE.</span><span class="s2">\r\n</span><span class="s1">***************************************************************************** */</span><span class="s2">\r\n\r\n</span><span class="s1">var __assign = function() {</span><span class="s2">\r\n    </span><span class="s1">__assign = Object.assign || function __assign(t) {</span><span class="s2">\r\n        </span><span class="s1">for (var s, i = 1, n = arguments.length; i &lt; n; i++) {</span><span class="s2">\r\n            </span><span class="s1">s = arguments[i];</span><span class="s2">\r\n            </span><span class="s1">for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">return t;</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">return __assign.apply(this, arguments);</span><span class="s2">\r\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">var uid$2 = 0;</span><span class="s2">\n</span><span class="s1">var pendingCleanupDeps = [];</span><span class="s2">\n</span><span class="s1">var cleanupDeps = function () {</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; pendingCleanupDeps.length; i++) {</span><span class="s2">\n        </span><span class="s1">var dep = pendingCleanupDeps[i];</span><span class="s2">\n        </span><span class="s1">dep.subs = dep.subs.filter(function (s) { return s; });</span><span class="s2">\n        </span><span class="s1">dep._pending = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">pendingCleanupDeps.length = 0;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* A dep is an observable that can have multiple</span><span class="s2">\n </span><span class="s1">* directives subscribing to it.</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var Dep = /** @class */ (function () {</span><span class="s2">\n    </span><span class="s1">function Dep() {</span><span class="s2">\n        </span><span class="s1">// pending subs cleanup</span><span class="s2">\n        </span><span class="s1">this._pending = false;</span><span class="s2">\n        </span><span class="s1">this.id = uid$2++;</span><span class="s2">\n        </span><span class="s1">this.subs = [];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">Dep.prototype.addSub = function (sub) {</span><span class="s2">\n        </span><span class="s1">this.subs.push(sub);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">Dep.prototype.removeSub = function (sub) {</span><span class="s2">\n        </span><span class="s1">// #12696 deps with massive amount of subscribers are extremely slow to</span><span class="s2">\n        </span><span class="s1">// clean up in Chromium</span><span class="s2">\n        </span><span class="s1">// to workaround this, we unset the sub for now, and clear them on</span><span class="s2">\n        </span><span class="s1">// next scheduler flush.</span><span class="s2">\n        </span><span class="s1">this.subs[this.subs.indexOf(sub)] = null;</span><span class="s2">\n        </span><span class="s1">if (!this._pending) {</span><span class="s2">\n            </span><span class="s1">this._pending = true;</span><span class="s2">\n            </span><span class="s1">pendingCleanupDeps.push(this);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">Dep.prototype.depend = function (info) {</span><span class="s2">\n        </span><span class="s1">if (Dep.target) {</span><span class="s2">\n            </span><span class="s1">Dep.target.addDep(this);</span><span class="s2">\n            </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; info &amp;&amp; Dep.target.onTrack) {</span><span class="s2">\n                </span><span class="s1">Dep.target.onTrack(__assign({ effect: Dep.target }, info));</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">Dep.prototype.notify = function (info) {</span><span class="s2">\n        </span><span class="s1">// stabilize the subscriber list first</span><span class="s2">\n        </span><span class="s1">var subs = this.subs.filter(function (s) { return s; });</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) {</span><span class="s2">\n            </span><span class="s1">// subs aren't sorted in scheduler if not running async</span><span class="s2">\n            </span><span class="s1">// we need to sort them now to make sure they fire in correct</span><span class="s2">\n            </span><span class="s1">// order</span><span class="s2">\n            </span><span class="s1">subs.sort(function (a, b) { return a.id - b.id; });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">for (var i = 0, l = subs.length; i &lt; l; i++) {</span><span class="s2">\n            </span><span class="s1">var sub = subs[i];</span><span class="s2">\n            </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; info) {</span><span class="s2">\n                </span><span class="s1">sub.onTrigger &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">sub.onTrigger(__assign({ effect: subs[i] }, info));</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">sub.update();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return Dep;</span><span class="s2">\n</span><span class="s1">}());</span><span class="s2">\n</span><span class="s1">// The current target watcher being evaluated.</span><span class="s2">\n</span><span class="s1">// This is globally unique because only one watcher</span><span class="s2">\n</span><span class="s1">// can be evaluated at a time.</span><span class="s2">\n</span><span class="s1">Dep.target = null;</span><span class="s2">\n</span><span class="s1">var targetStack = [];</span><span class="s2">\n</span><span class="s1">function pushTarget(target) {</span><span class="s2">\n    </span><span class="s1">targetStack.push(target);</span><span class="s2">\n    </span><span class="s1">Dep.target = target;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function popTarget() {</span><span class="s2">\n    </span><span class="s1">targetStack.pop();</span><span class="s2">\n    </span><span class="s1">Dep.target = targetStack[targetStack.length - 1];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*</span><span class="s2">\n </span><span class="s1">* not type checking this file because flow doesn't play well with</span><span class="s2">\n </span><span class="s1">* dynamically accessing methods on Array prototype</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var arrayProto = Array.prototype;</span><span class="s2">\n</span><span class="s1">var arrayMethods = Object.create(arrayProto);</span><span class="s2">\n</span><span class="s1">var methodsToPatch = [</span><span class="s2">\n    </span><span class="s1">'push',</span><span class="s2">\n    </span><span class="s1">'pop',</span><span class="s2">\n    </span><span class="s1">'shift',</span><span class="s2">\n    </span><span class="s1">'unshift',</span><span class="s2">\n    </span><span class="s1">'splice',</span><span class="s2">\n    </span><span class="s1">'sort',</span><span class="s2">\n    </span><span class="s1">'reverse'</span><span class="s2">\n</span><span class="s1">];</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Intercept mutating methods and emit events</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">methodsToPatch.forEach(function (method) {</span><span class="s2">\n    </span><span class="s1">// cache original method</span><span class="s2">\n    </span><span class="s1">var original = arrayProto[method];</span><span class="s2">\n    </span><span class="s1">def(arrayMethods, method, function mutator() {</span><span class="s2">\n        </span><span class="s1">var args = [];</span><span class="s2">\n        </span><span class="s1">for (var _i = 0; _i &lt; arguments.length; _i++) {</span><span class="s2">\n            </span><span class="s1">args[_i] = arguments[_i];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var result = original.apply(this, args);</span><span class="s2">\n        </span><span class="s1">var ob = this.__ob__;</span><span class="s2">\n        </span><span class="s1">var inserted;</span><span class="s2">\n        </span><span class="s1">switch (method) {</span><span class="s2">\n            </span><span class="s1">case 'push':</span><span class="s2">\n            </span><span class="s1">case 'unshift':</span><span class="s2">\n                </span><span class="s1">inserted = args;</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">case 'splice':</span><span class="s2">\n                </span><span class="s1">inserted = args.slice(2);</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (inserted)</span><span class="s2">\n            </span><span class="s1">ob.observeArray(inserted);</span><span class="s2">\n        </span><span class="s1">// notify change</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">ob.dep.notify({</span><span class="s2">\n                </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">array mutation</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.ARRAY_MUTATION */,</span><span class="s2">\n                </span><span class="s1">target: this,</span><span class="s2">\n                </span><span class="s1">key: method</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">ob.dep.notify();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return result;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n\n</span><span class="s1">var arrayKeys = Object.getOwnPropertyNames(arrayMethods);</span><span class="s2">\n</span><span class="s1">var NO_INIITIAL_VALUE = {};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* In some cases we may want to disable observation inside a component's</span><span class="s2">\n </span><span class="s1">* update computation.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var shouldObserve = true;</span><span class="s2">\n</span><span class="s1">function toggleObserving(value) {</span><span class="s2">\n    </span><span class="s1">shouldObserve = value;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// ssr mock dep</span><span class="s2">\n</span><span class="s1">var mockDep = {</span><span class="s2">\n    </span><span class="s1">notify: noop,</span><span class="s2">\n    </span><span class="s1">depend: noop,</span><span class="s2">\n    </span><span class="s1">addSub: noop,</span><span class="s2">\n    </span><span class="s1">removeSub: noop</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Observer class that is attached to each observed</span><span class="s2">\n </span><span class="s1">* object. Once attached, the observer converts the target</span><span class="s2">\n </span><span class="s1">* object's property keys into getter/setters that</span><span class="s2">\n </span><span class="s1">* collect dependencies and dispatch updates.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var Observer = /** @class */ (function () {</span><span class="s2">\n    </span><span class="s1">function Observer(value, shallow, mock) {</span><span class="s2">\n        </span><span class="s1">if (shallow === void 0) { shallow = false; }</span><span class="s2">\n        </span><span class="s1">if (mock === void 0) { mock = false; }</span><span class="s2">\n        </span><span class="s1">this.value = value;</span><span class="s2">\n        </span><span class="s1">this.shallow = shallow;</span><span class="s2">\n        </span><span class="s1">this.mock = mock;</span><span class="s2">\n        </span><span class="s1">// this.value = value</span><span class="s2">\n        </span><span class="s1">this.dep = mock ? mockDep : new Dep();</span><span class="s2">\n        </span><span class="s1">this.vmCount = 0;</span><span class="s2">\n        </span><span class="s1">def(value, '__ob__', this);</span><span class="s2">\n        </span><span class="s1">if (isArray(value)) {</span><span class="s2">\n            </span><span class="s1">if (!mock) {</span><span class="s2">\n                </span><span class="s1">if (hasProto) {</span><span class="s2">\n                    </span><span class="s1">value.__proto__ = arrayMethods;</span><span class="s2">\n                    </span><span class="s1">/* eslint-enable no-proto */</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">for (var i = 0, l = arrayKeys.length; i &lt; l; i++) {</span><span class="s2">\n                        </span><span class="s1">var key = arrayKeys[i];</span><span class="s2">\n                        </span><span class="s1">def(value, key, arrayMethods[key]);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (!shallow) {</span><span class="s2">\n                </span><span class="s1">this.observeArray(value);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">/**</span><span class="s2">\n             </span><span class="s1">* Walk through all properties and convert them into</span><span class="s2">\n             </span><span class="s1">* getter/setters. This method should only be called when</span><span class="s2">\n             </span><span class="s1">* value type is Object.</span><span class="s2">\n             </span><span class="s1">*/</span><span class="s2">\n            </span><span class="s1">var keys = Object.keys(value);</span><span class="s2">\n            </span><span class="s1">for (var i = 0; i &lt; keys.length; i++) {</span><span class="s2">\n                </span><span class="s1">var key = keys[i];</span><span class="s2">\n                </span><span class="s1">defineReactive(value, key, NO_INIITIAL_VALUE, undefined, shallow, mock);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Observe a list of Array items.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">Observer.prototype.observeArray = function (value) {</span><span class="s2">\n        </span><span class="s1">for (var i = 0, l = value.length; i &lt; l; i++) {</span><span class="s2">\n            </span><span class="s1">observe(value[i], false, this.mock);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return Observer;</span><span class="s2">\n</span><span class="s1">}());</span><span class="s2">\n</span><span class="s1">// helpers</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Attempt to create an observer instance for a value,</span><span class="s2">\n </span><span class="s1">* returns the new observer if successfully observed,</span><span class="s2">\n </span><span class="s1">* or the existing observer if the value already has one.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function observe(value, shallow, ssrMockReactivity) {</span><span class="s2">\n    </span><span class="s1">if (value &amp;&amp; hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) {</span><span class="s2">\n        </span><span class="s1">return value.__ob__;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (shouldObserve &amp;&amp;</span><span class="s2">\n        </span><span class="s1">(ssrMockReactivity || !isServerRendering()) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">(isArray(value) || isPlainObject(value)) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">Object.isExtensible(value) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!value.__v_skip /* ReactiveFlags.SKIP */ &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!isRef(value) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!(value instanceof VNode)) {</span><span class="s2">\n        </span><span class="s1">return new Observer(value, shallow, ssrMockReactivity);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Define a reactive property on an Object.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function defineReactive(obj, key, val, customSetter, shallow, mock) {</span><span class="s2">\n    </span><span class="s1">var dep = new Dep();</span><span class="s2">\n    </span><span class="s1">var property = Object.getOwnPropertyDescriptor(obj, key);</span><span class="s2">\n    </span><span class="s1">if (property &amp;&amp; property.configurable === false) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// cater for pre-defined getter/setters</span><span class="s2">\n    </span><span class="s1">var getter = property &amp;&amp; property.get;</span><span class="s2">\n    </span><span class="s1">var setter = property &amp;&amp; property.set;</span><span class="s2">\n    </span><span class="s1">if ((!getter || setter) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">(val === NO_INIITIAL_VALUE || arguments.length === 2)) {</span><span class="s2">\n        </span><span class="s1">val = obj[key];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var childOb = !shallow &amp;&amp; observe(val, false, mock);</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(obj, key, {</span><span class="s2">\n        </span><span class="s1">enumerable: true,</span><span class="s2">\n        </span><span class="s1">configurable: true,</span><span class="s2">\n        </span><span class="s1">get: function reactiveGetter() {</span><span class="s2">\n            </span><span class="s1">var value = getter ? getter.call(obj) : val;</span><span class="s2">\n            </span><span class="s1">if (Dep.target) {</span><span class="s2">\n                </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n                    </span><span class="s1">dep.depend({</span><span class="s2">\n                        </span><span class="s1">target: obj,</span><span class="s2">\n                        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.GET */,</span><span class="s2">\n                        </span><span class="s1">key: key</span><span class="s2">\n                    </span><span class="s1">});</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">dep.depend();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (childOb) {</span><span class="s2">\n                    </span><span class="s1">childOb.dep.depend();</span><span class="s2">\n                    </span><span class="s1">if (isArray(value)) {</span><span class="s2">\n                        </span><span class="s1">dependArray(value);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return isRef(value) &amp;&amp; !shallow ? value.value : value;</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">set: function reactiveSetter(newVal) {</span><span class="s2">\n            </span><span class="s1">var value = getter ? getter.call(obj) : val;</span><span class="s2">\n            </span><span class="s1">if (!hasChanged(value, newVal)) {</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) {</span><span class="s2">\n                </span><span class="s1">customSetter();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (setter) {</span><span class="s2">\n                </span><span class="s1">setter.call(obj, newVal);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (getter) {</span><span class="s2">\n                </span><span class="s1">// #7981: for accessor properties without setter</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (!shallow &amp;&amp; isRef(value) &amp;&amp; !isRef(newVal)) {</span><span class="s2">\n                </span><span class="s1">value.value = newVal;</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">val = newVal;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">childOb = !shallow &amp;&amp; observe(newVal, false, mock);</span><span class="s2">\n            </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n                </span><span class="s1">dep.notify({</span><span class="s2">\n                    </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.SET */,</span><span class="s2">\n                    </span><span class="s1">target: obj,</span><span class="s2">\n                    </span><span class="s1">key: key,</span><span class="s2">\n                    </span><span class="s1">newValue: newVal,</span><span class="s2">\n                    </span><span class="s1">oldValue: value</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">dep.notify();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return dep;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function set(target, key, val) {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; (isUndef(target) || isPrimitive(target))) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Cannot set reactive property on undefined, null, or primitive value: </span><span class="s2">\&quot;</span><span class="s1">.concat(target));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isReadonly(target)) {</span><span class="s2">\n        </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">Set operation on key </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">failed: target is readonly.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var ob = target.__ob__;</span><span class="s2">\n    </span><span class="s1">if (isArray(target) &amp;&amp; isValidArrayIndex(key)) {</span><span class="s2">\n        </span><span class="s1">target.length = Math.max(target.length, key);</span><span class="s2">\n        </span><span class="s1">target.splice(key, 1, val);</span><span class="s2">\n        </span><span class="s1">// when mocking for SSR, array methods are not hijacked</span><span class="s2">\n        </span><span class="s1">if (ob &amp;&amp; !ob.shallow &amp;&amp; ob.mock) {</span><span class="s2">\n            </span><span class="s1">observe(val, false, true);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (key in target &amp;&amp; !(key in Object.prototype)) {</span><span class="s2">\n        </span><span class="s1">target[key] = val;</span><span class="s2">\n        </span><span class="s1">return val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (target._isVue || (ob &amp;&amp; ob.vmCount)) {</span><span class="s2">\n        </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n            </span><span class="s1">warn('Avoid adding reactive properties to a Vue instance or its root $data ' +</span><span class="s2">\n                </span><span class="s1">'at runtime - declare it upfront in the data option.');</span><span class="s2">\n        </span><span class="s1">return val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!ob) {</span><span class="s2">\n        </span><span class="s1">target[key] = val;</span><span class="s2">\n        </span><span class="s1">return val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">ob.dep.notify({</span><span class="s2">\n            </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">add</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.ADD */,</span><span class="s2">\n            </span><span class="s1">target: target,</span><span class="s2">\n            </span><span class="s1">key: key,</span><span class="s2">\n            </span><span class="s1">newValue: val,</span><span class="s2">\n            </span><span class="s1">oldValue: undefined</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">ob.dep.notify();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return val;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function del(target, key) {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; (isUndef(target) || isPrimitive(target))) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Cannot delete reactive property on undefined, null, or primitive value: </span><span class="s2">\&quot;</span><span class="s1">.concat(target));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isArray(target) &amp;&amp; isValidArrayIndex(key)) {</span><span class="s2">\n        </span><span class="s1">target.splice(key, 1);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var ob = target.__ob__;</span><span class="s2">\n    </span><span class="s1">if (target._isVue || (ob &amp;&amp; ob.vmCount)) {</span><span class="s2">\n        </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n            </span><span class="s1">warn('Avoid deleting properties on a Vue instance or its root $data ' +</span><span class="s2">\n                </span><span class="s1">'- just set it to null.');</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isReadonly(target)) {</span><span class="s2">\n        </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Delete operation on key </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">failed: target is readonly.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!hasOwn(target, key)) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">delete target[key];</span><span class="s2">\n    </span><span class="s1">if (!ob) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">ob.dep.notify({</span><span class="s2">\n            </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">delete</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.DELETE */,</span><span class="s2">\n            </span><span class="s1">target: target,</span><span class="s2">\n            </span><span class="s1">key: key</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">ob.dep.notify();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Collect dependencies on array elements when the array is touched, since</span><span class="s2">\n </span><span class="s1">* we cannot intercept array element access like property getters.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function dependArray(value) {</span><span class="s2">\n    </span><span class="s1">for (var e = void 0, i = 0, l = value.length; i &lt; l; i++) {</span><span class="s2">\n        </span><span class="s1">e = value[i];</span><span class="s2">\n        </span><span class="s1">if (e &amp;&amp; e.__ob__) {</span><span class="s2">\n            </span><span class="s1">e.__ob__.dep.depend();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isArray(e)) {</span><span class="s2">\n            </span><span class="s1">dependArray(e);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function reactive(target) {</span><span class="s2">\n    </span><span class="s1">makeReactive(target, false);</span><span class="s2">\n    </span><span class="s1">return target;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Return a shallowly-reactive copy of the original object, where only the root</span><span class="s2">\n </span><span class="s1">* level properties are reactive. It also does not auto-unwrap refs (even at the</span><span class="s2">\n </span><span class="s1">* root level).</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function shallowReactive(target) {</span><span class="s2">\n    </span><span class="s1">makeReactive(target, true);</span><span class="s2">\n    </span><span class="s1">def(target, </span><span class="s2">\&quot;</span><span class="s1">__v_isShallow</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_SHALLOW */, true);</span><span class="s2">\n    </span><span class="s1">return target;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function makeReactive(target, shallow) {</span><span class="s2">\n    </span><span class="s1">// if trying to observe a readonly proxy, return the readonly version.</span><span class="s2">\n    </span><span class="s1">if (!isReadonly(target)) {</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">if (isArray(target)) {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Avoid using Array as root value for </span><span class="s2">\&quot;</span><span class="s1">.concat(shallow ? </span><span class="s2">\&quot;</span><span class="s1">shallowReactive()</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">reactive()</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot; </span><span class="s1">as it cannot be tracked in watch() or watchEffect(). Use </span><span class="s2">\&quot;</span><span class="s1">).concat(shallow ? </span><span class="s2">\&quot;</span><span class="s1">shallowRef()</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">ref()</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot; </span><span class="s1">instead. This is a Vue-2-only limitation.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">var existingOb = target &amp;&amp; target.__ob__;</span><span class="s2">\n            </span><span class="s1">if (existingOb &amp;&amp; existingOb.shallow !== shallow) {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Target is already a </span><span class="s2">\&quot;</span><span class="s1">.concat(existingOb.shallow ? </span><span class="s2">\&quot;\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">non-</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">shallow reactive object, and cannot be converted to </span><span class="s2">\&quot;</span><span class="s1">).concat(shallow ? </span><span class="s2">\&quot;\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">non-</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">shallow.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var ob = observe(target, shallow, isServerRendering() /* ssr mock reactivity */);</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !ob) {</span><span class="s2">\n            </span><span class="s1">if (target == null || isPrimitive(target)) {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">value cannot be made reactive: </span><span class="s2">\&quot;</span><span class="s1">.concat(String(target)));</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (isCollectionType(target)) {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Vue 2 does not support reactive collection types such as Map or Set.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isReactive(value) {</span><span class="s2">\n    </span><span class="s1">if (isReadonly(value)) {</span><span class="s2">\n        </span><span class="s1">return isReactive(value[</span><span class="s2">\&quot;</span><span class="s1">__v_raw</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.RAW */]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return !!(value &amp;&amp; value.__ob__);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isShallow(value) {</span><span class="s2">\n    </span><span class="s1">return !!(value &amp;&amp; value.__v_isShallow);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isReadonly(value) {</span><span class="s2">\n    </span><span class="s1">return !!(value &amp;&amp; value.__v_isReadonly);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isProxy(value) {</span><span class="s2">\n    </span><span class="s1">return isReactive(value) || isReadonly(value);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function toRaw(observed) {</span><span class="s2">\n    </span><span class="s1">var raw = observed &amp;&amp; observed[</span><span class="s2">\&quot;</span><span class="s1">__v_raw</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.RAW */];</span><span class="s2">\n    </span><span class="s1">return raw ? toRaw(raw) : observed;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function markRaw(value) {</span><span class="s2">\n    </span><span class="s1">// non-extensible objects won't be observed anyway</span><span class="s2">\n    </span><span class="s1">if (Object.isExtensible(value)) {</span><span class="s2">\n        </span><span class="s1">def(value, </span><span class="s2">\&quot;</span><span class="s1">__v_skip</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.SKIP */, true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return value;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isCollectionType(value) {</span><span class="s2">\n    </span><span class="s1">var type = toRawType(value);</span><span class="s2">\n    </span><span class="s1">return (type === 'Map' || type === 'WeakMap' || type === 'Set' || type === 'WeakSet');</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var RefFlag = </span><span class="s2">\&quot;</span><span class="s1">__v_isRef</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function isRef(r) {</span><span class="s2">\n    </span><span class="s1">return !!(r &amp;&amp; r.__v_isRef === true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function ref$1(value) {</span><span class="s2">\n    </span><span class="s1">return createRef(value, false);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function shallowRef(value) {</span><span class="s2">\n    </span><span class="s1">return createRef(value, true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createRef(rawValue, shallow) {</span><span class="s2">\n    </span><span class="s1">if (isRef(rawValue)) {</span><span class="s2">\n        </span><span class="s1">return rawValue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var ref = {};</span><span class="s2">\n    </span><span class="s1">def(ref, RefFlag, true);</span><span class="s2">\n    </span><span class="s1">def(ref, </span><span class="s2">\&quot;</span><span class="s1">__v_isShallow</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_SHALLOW */, shallow);</span><span class="s2">\n    </span><span class="s1">def(ref, 'dep', defineReactive(ref, 'value', rawValue, null, shallow, isServerRendering()));</span><span class="s2">\n    </span><span class="s1">return ref;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function triggerRef(ref) {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !ref.dep) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">received object is not a triggerable ref.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">ref.dep &amp;&amp;</span><span class="s2">\n            </span><span class="s1">ref.dep.notify({</span><span class="s2">\n                </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.SET */,</span><span class="s2">\n                </span><span class="s1">target: ref,</span><span class="s2">\n                </span><span class="s1">key: 'value'</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">ref.dep &amp;&amp; ref.dep.notify();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function unref(ref) {</span><span class="s2">\n    </span><span class="s1">return isRef(ref) ? ref.value : ref;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function proxyRefs(objectWithRefs) {</span><span class="s2">\n    </span><span class="s1">if (isReactive(objectWithRefs)) {</span><span class="s2">\n        </span><span class="s1">return objectWithRefs;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var proxy = {};</span><span class="s2">\n    </span><span class="s1">var keys = Object.keys(objectWithRefs);</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; keys.length; i++) {</span><span class="s2">\n        </span><span class="s1">proxyWithRefUnwrap(proxy, objectWithRefs, keys[i]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return proxy;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function proxyWithRefUnwrap(target, source, key) {</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(target, key, {</span><span class="s2">\n        </span><span class="s1">enumerable: true,</span><span class="s2">\n        </span><span class="s1">configurable: true,</span><span class="s2">\n        </span><span class="s1">get: function () {</span><span class="s2">\n            </span><span class="s1">var val = source[key];</span><span class="s2">\n            </span><span class="s1">if (isRef(val)) {</span><span class="s2">\n                </span><span class="s1">return val.value;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">var ob = val &amp;&amp; val.__ob__;</span><span class="s2">\n                </span><span class="s1">if (ob)</span><span class="s2">\n                    </span><span class="s1">ob.dep.depend();</span><span class="s2">\n                </span><span class="s1">return val;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">set: function (value) {</span><span class="s2">\n            </span><span class="s1">var oldValue = source[key];</span><span class="s2">\n            </span><span class="s1">if (isRef(oldValue) &amp;&amp; !isRef(value)) {</span><span class="s2">\n                </span><span class="s1">oldValue.value = value;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">source[key] = value;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function customRef(factory) {</span><span class="s2">\n    </span><span class="s1">var dep = new Dep();</span><span class="s2">\n    </span><span class="s1">var _a = factory(function () {</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">dep.depend({</span><span class="s2">\n                </span><span class="s1">target: ref,</span><span class="s2">\n                </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.GET */,</span><span class="s2">\n                </span><span class="s1">key: 'value'</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">dep.depend();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}, function () {</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">dep.notify({</span><span class="s2">\n                </span><span class="s1">target: ref,</span><span class="s2">\n                </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.SET */,</span><span class="s2">\n                </span><span class="s1">key: 'value'</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">dep.notify();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}), get = _a.get, set = _a.set;</span><span class="s2">\n    </span><span class="s1">var ref = {</span><span class="s2">\n        </span><span class="s1">get value() {</span><span class="s2">\n            </span><span class="s1">return get();</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">set value(newVal) {</span><span class="s2">\n            </span><span class="s1">set(newVal);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">def(ref, RefFlag, true);</span><span class="s2">\n    </span><span class="s1">return ref;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function toRefs(object) {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !isReactive(object)) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">toRefs() expects a reactive object but received a plain one.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var ret = isArray(object) ? new Array(object.length) : {};</span><span class="s2">\n    </span><span class="s1">for (var key in object) {</span><span class="s2">\n        </span><span class="s1">ret[key] = toRef(object, key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return ret;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function toRef(object, key, defaultValue) {</span><span class="s2">\n    </span><span class="s1">var val = object[key];</span><span class="s2">\n    </span><span class="s1">if (isRef(val)) {</span><span class="s2">\n        </span><span class="s1">return val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var ref = {</span><span class="s2">\n        </span><span class="s1">get value() {</span><span class="s2">\n            </span><span class="s1">var val = object[key];</span><span class="s2">\n            </span><span class="s1">return val === undefined ? defaultValue : val;</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">set value(newVal) {</span><span class="s2">\n            </span><span class="s1">object[key] = newVal;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">def(ref, RefFlag, true);</span><span class="s2">\n    </span><span class="s1">return ref;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var rawToReadonlyFlag = </span><span class="s2">\&quot;</span><span class="s1">__v_rawToReadonly</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var rawToShallowReadonlyFlag = </span><span class="s2">\&quot;</span><span class="s1">__v_rawToShallowReadonly</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function readonly(target) {</span><span class="s2">\n    </span><span class="s1">return createReadonly(target, false);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createReadonly(target, shallow) {</span><span class="s2">\n    </span><span class="s1">if (!isPlainObject(target)) {</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">if (isArray(target)) {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Vue 2 does not support readonly arrays.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (isCollectionType(target)) {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Vue 2 does not support readonly collection types such as Map or Set.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">value cannot be made readonly: </span><span class="s2">\&quot;</span><span class="s1">.concat(typeof target));</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return target;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !Object.isExtensible(target)) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Vue 2 does not support creating readonly proxy for non-extensible object.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// already a readonly object</span><span class="s2">\n    </span><span class="s1">if (isReadonly(target)) {</span><span class="s2">\n        </span><span class="s1">return target;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// already has a readonly proxy</span><span class="s2">\n    </span><span class="s1">var existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;</span><span class="s2">\n    </span><span class="s1">var existingProxy = target[existingFlag];</span><span class="s2">\n    </span><span class="s1">if (existingProxy) {</span><span class="s2">\n        </span><span class="s1">return existingProxy;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var proxy = Object.create(Object.getPrototypeOf(target));</span><span class="s2">\n    </span><span class="s1">def(target, existingFlag, proxy);</span><span class="s2">\n    </span><span class="s1">def(proxy, </span><span class="s2">\&quot;</span><span class="s1">__v_isReadonly</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_READONLY */, true);</span><span class="s2">\n    </span><span class="s1">def(proxy, </span><span class="s2">\&quot;</span><span class="s1">__v_raw</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.RAW */, target);</span><span class="s2">\n    </span><span class="s1">if (isRef(target)) {</span><span class="s2">\n        </span><span class="s1">def(proxy, RefFlag, true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (shallow || isShallow(target)) {</span><span class="s2">\n        </span><span class="s1">def(proxy, </span><span class="s2">\&quot;</span><span class="s1">__v_isShallow</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_SHALLOW */, true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var keys = Object.keys(target);</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; keys.length; i++) {</span><span class="s2">\n        </span><span class="s1">defineReadonlyProperty(proxy, target, keys[i], shallow);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return proxy;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function defineReadonlyProperty(proxy, target, key, shallow) {</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(proxy, key, {</span><span class="s2">\n        </span><span class="s1">enumerable: true,</span><span class="s2">\n        </span><span class="s1">configurable: true,</span><span class="s2">\n        </span><span class="s1">get: function () {</span><span class="s2">\n            </span><span class="s1">var val = target[key];</span><span class="s2">\n            </span><span class="s1">return shallow || !isPlainObject(val) ? val : readonly(val);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">set: function () {</span><span class="s2">\n            </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Set operation on key </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">failed: target is readonly.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Returns a reactive-copy of the original object, where only the root level</span><span class="s2">\n </span><span class="s1">* properties are readonly, and does NOT unwrap refs nor recursively convert</span><span class="s2">\n </span><span class="s1">* returned properties.</span><span class="s2">\n </span><span class="s1">* This is used for creating the props proxy object for stateful components.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function shallowReadonly(target) {</span><span class="s2">\n    </span><span class="s1">return createReadonly(target, true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function computed(getterOrOptions, debugOptions) {</span><span class="s2">\n    </span><span class="s1">var getter;</span><span class="s2">\n    </span><span class="s1">var setter;</span><span class="s2">\n    </span><span class="s1">var onlyGetter = isFunction(getterOrOptions);</span><span class="s2">\n    </span><span class="s1">if (onlyGetter) {</span><span class="s2">\n        </span><span class="s1">getter = getterOrOptions;</span><span class="s2">\n        </span><span class="s1">setter = process.env.NODE_ENV !== 'production'</span><span class="s2">\n            </span><span class="s1">? function () {</span><span class="s2">\n                </span><span class="s1">warn('Write operation failed: computed value is readonly');</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">: noop;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">getter = getterOrOptions.get;</span><span class="s2">\n        </span><span class="s1">setter = getterOrOptions.set;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var watcher = isServerRendering()</span><span class="s2">\n        </span><span class="s1">? null</span><span class="s2">\n        </span><span class="s1">: new Watcher(currentInstance, getter, noop, { lazy: true });</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; watcher &amp;&amp; debugOptions) {</span><span class="s2">\n        </span><span class="s1">watcher.onTrack = debugOptions.onTrack;</span><span class="s2">\n        </span><span class="s1">watcher.onTrigger = debugOptions.onTrigger;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var ref = {</span><span class="s2">\n        </span><span class="s1">// some libs rely on the presence effect for checking computed refs</span><span class="s2">\n        </span><span class="s1">// from normal refs, but the implementation doesn't matter</span><span class="s2">\n        </span><span class="s1">effect: watcher,</span><span class="s2">\n        </span><span class="s1">get value() {</span><span class="s2">\n            </span><span class="s1">if (watcher) {</span><span class="s2">\n                </span><span class="s1">if (watcher.dirty) {</span><span class="s2">\n                    </span><span class="s1">watcher.evaluate();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (Dep.target) {</span><span class="s2">\n                    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; Dep.target.onTrack) {</span><span class="s2">\n                        </span><span class="s1">Dep.target.onTrack({</span><span class="s2">\n                            </span><span class="s1">effect: Dep.target,</span><span class="s2">\n                            </span><span class="s1">target: ref,</span><span class="s2">\n                            </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.GET */,</span><span class="s2">\n                            </span><span class="s1">key: 'value'</span><span class="s2">\n                        </span><span class="s1">});</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">watcher.depend();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">return watcher.value;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">return getter();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">set value(newVal) {</span><span class="s2">\n            </span><span class="s1">setter(newVal);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">def(ref, RefFlag, true);</span><span class="s2">\n    </span><span class="s1">def(ref, </span><span class="s2">\&quot;</span><span class="s1">__v_isReadonly</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_READONLY */, onlyGetter);</span><span class="s2">\n    </span><span class="s1">return ref;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var WATCHER = </span><span class="s2">\&quot;</span><span class="s1">watcher</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var WATCHER_CB = </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(WATCHER, </span><span class="s2">\&quot; </span><span class="s1">callback</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">var WATCHER_GETTER = </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(WATCHER, </span><span class="s2">\&quot; </span><span class="s1">getter</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">var WATCHER_CLEANUP = </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(WATCHER, </span><span class="s2">\&quot; </span><span class="s1">cleanup</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">// Simple effect.</span><span class="s2">\n</span><span class="s1">function watchEffect(effect, options) {</span><span class="s2">\n    </span><span class="s1">return doWatch(effect, null, options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function watchPostEffect(effect, options) {</span><span class="s2">\n    </span><span class="s1">return doWatch(effect, null, (process.env.NODE_ENV !== 'production'</span><span class="s2">\n        </span><span class="s1">? __assign(__assign({}, options), { flush: 'post' }) : { flush: 'post' }));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function watchSyncEffect(effect, options) {</span><span class="s2">\n    </span><span class="s1">return doWatch(effect, null, (process.env.NODE_ENV !== 'production'</span><span class="s2">\n        </span><span class="s1">? __assign(__assign({}, options), { flush: 'sync' }) : { flush: 'sync' }));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// initial value for watchers to trigger on undefined initial values</span><span class="s2">\n</span><span class="s1">var INITIAL_WATCHER_VALUE = {};</span><span class="s2">\n</span><span class="s1">// implementation</span><span class="s2">\n</span><span class="s1">function watch(source, cb, options) {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; typeof cb !== 'function') {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">`watch(fn, options?)` signature has been moved to a separate API. </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n            \&quot;</span><span class="s1">Use `watchEffect(fn, options?)` instead. `watch` now only </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n            \&quot;</span><span class="s1">supports `watch(source, cb, options?) signature.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return doWatch(source, cb, options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function doWatch(source, cb, _a) {</span><span class="s2">\n    </span><span class="s1">var _b = _a === void 0 ? emptyObject : _a, immediate = _b.immediate, deep = _b.deep, _c = _b.flush, flush = _c === void 0 ? 'pre' : _c, onTrack = _b.onTrack, onTrigger = _b.onTrigger;</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !cb) {</span><span class="s2">\n        </span><span class="s1">if (immediate !== undefined) {</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">watch() </span><span class="s2">\\\&quot;</span><span class="s1">immediate</span><span class="s2">\\\&quot; </span><span class="s1">option is only respected when using the </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                \&quot;</span><span class="s1">watch(source, callback, options?) signature.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (deep !== undefined) {</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">watch() </span><span class="s2">\\\&quot;</span><span class="s1">deep</span><span class="s2">\\\&quot; </span><span class="s1">option is only respected when using the </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                \&quot;</span><span class="s1">watch(source, callback, options?) signature.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var warnInvalidSource = function (s) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Invalid watch source: </span><span class="s2">\&quot;</span><span class="s1">.concat(s, </span><span class="s2">\&quot;</span><span class="s1">. A watch source can only be a getter/effect </span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n            \&quot;</span><span class="s1">function, a ref, a reactive object, or an array of these types.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var instance = currentInstance;</span><span class="s2">\n    </span><span class="s1">var call = function (fn, type, args) {</span><span class="s2">\n        </span><span class="s1">if (args === void 0) { args = null; }</span><span class="s2">\n        </span><span class="s1">return invokeWithErrorHandling(fn, null, args, instance, type);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var getter;</span><span class="s2">\n    </span><span class="s1">var forceTrigger = false;</span><span class="s2">\n    </span><span class="s1">var isMultiSource = false;</span><span class="s2">\n    </span><span class="s1">if (isRef(source)) {</span><span class="s2">\n        </span><span class="s1">getter = function () { return source.value; };</span><span class="s2">\n        </span><span class="s1">forceTrigger = isShallow(source);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isReactive(source)) {</span><span class="s2">\n        </span><span class="s1">getter = function () {</span><span class="s2">\n            </span><span class="s1">source.__ob__.dep.depend();</span><span class="s2">\n            </span><span class="s1">return source;</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">deep = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isArray(source)) {</span><span class="s2">\n        </span><span class="s1">isMultiSource = true;</span><span class="s2">\n        </span><span class="s1">forceTrigger = source.some(function (s) { return isReactive(s) || isShallow(s); });</span><span class="s2">\n        </span><span class="s1">getter = function () {</span><span class="s2">\n            </span><span class="s1">return source.map(function (s) {</span><span class="s2">\n                </span><span class="s1">if (isRef(s)) {</span><span class="s2">\n                    </span><span class="s1">return s.value;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (isReactive(s)) {</span><span class="s2">\n                    </span><span class="s1">return traverse(s);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (isFunction(s)) {</span><span class="s2">\n                    </span><span class="s1">return call(s, WATCHER_GETTER);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warnInvalidSource(s);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isFunction(source)) {</span><span class="s2">\n        </span><span class="s1">if (cb) {</span><span class="s2">\n            </span><span class="s1">// getter with cb</span><span class="s2">\n            </span><span class="s1">getter = function () { return call(source, WATCHER_GETTER); };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// no cb -&gt; simple effect</span><span class="s2">\n            </span><span class="s1">getter = function () {</span><span class="s2">\n                </span><span class="s1">if (instance &amp;&amp; instance._isDestroyed) {</span><span class="s2">\n                    </span><span class="s1">return;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (cleanup) {</span><span class="s2">\n                    </span><span class="s1">cleanup();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">return call(source, WATCHER, [onCleanup]);</span><span class="s2">\n            </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">getter = noop;</span><span class="s2">\n        </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warnInvalidSource(source);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (cb &amp;&amp; deep) {</span><span class="s2">\n        </span><span class="s1">var baseGetter_1 = getter;</span><span class="s2">\n        </span><span class="s1">getter = function () { return traverse(baseGetter_1()); };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var cleanup;</span><span class="s2">\n    </span><span class="s1">var onCleanup = function (fn) {</span><span class="s2">\n        </span><span class="s1">cleanup = watcher.onStop = function () {</span><span class="s2">\n            </span><span class="s1">call(fn, WATCHER_CLEANUP);</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">// in SSR there is no need to setup an actual effect, and it should be noop</span><span class="s2">\n    </span><span class="s1">// unless it's eager</span><span class="s2">\n    </span><span class="s1">if (isServerRendering()) {</span><span class="s2">\n        </span><span class="s1">// we will also not call the invalidate callback (+ runner is not set up)</span><span class="s2">\n        </span><span class="s1">onCleanup = noop;</span><span class="s2">\n        </span><span class="s1">if (!cb) {</span><span class="s2">\n            </span><span class="s1">getter();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (immediate) {</span><span class="s2">\n            </span><span class="s1">call(cb, WATCHER_CB, [</span><span class="s2">\n                </span><span class="s1">getter(),</span><span class="s2">\n                </span><span class="s1">isMultiSource ? [] : undefined,</span><span class="s2">\n                </span><span class="s1">onCleanup</span><span class="s2">\n            </span><span class="s1">]);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return noop;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var watcher = new Watcher(currentInstance, getter, noop, {</span><span class="s2">\n        </span><span class="s1">lazy: true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">watcher.noRecurse = !cb;</span><span class="s2">\n    </span><span class="s1">var oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;</span><span class="s2">\n    </span><span class="s1">// overwrite default run</span><span class="s2">\n    </span><span class="s1">watcher.run = function () {</span><span class="s2">\n        </span><span class="s1">if (!watcher.active) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (cb) {</span><span class="s2">\n            </span><span class="s1">// watch(source, cb)</span><span class="s2">\n            </span><span class="s1">var newValue = watcher.get();</span><span class="s2">\n            </span><span class="s1">if (deep ||</span><span class="s2">\n                </span><span class="s1">forceTrigger ||</span><span class="s2">\n                </span><span class="s1">(isMultiSource</span><span class="s2">\n                    </span><span class="s1">? newValue.some(function (v, i) {</span><span class="s2">\n                        </span><span class="s1">return hasChanged(v, oldValue[i]);</span><span class="s2">\n                    </span><span class="s1">})</span><span class="s2">\n                    </span><span class="s1">: hasChanged(newValue, oldValue))) {</span><span class="s2">\n                </span><span class="s1">// cleanup before running cb again</span><span class="s2">\n                </span><span class="s1">if (cleanup) {</span><span class="s2">\n                    </span><span class="s1">cleanup();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">call(cb, WATCHER_CB, [</span><span class="s2">\n                    </span><span class="s1">newValue,</span><span class="s2">\n                    </span><span class="s1">// pass undefined as the old value when it's changed for the first time</span><span class="s2">\n                    </span><span class="s1">oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,</span><span class="s2">\n                    </span><span class="s1">onCleanup</span><span class="s2">\n                </span><span class="s1">]);</span><span class="s2">\n                </span><span class="s1">oldValue = newValue;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// watchEffect</span><span class="s2">\n            </span><span class="s1">watcher.get();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (flush === 'sync') {</span><span class="s2">\n        </span><span class="s1">watcher.update = watcher.run;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (flush === 'post') {</span><span class="s2">\n        </span><span class="s1">watcher.post = true;</span><span class="s2">\n        </span><span class="s1">watcher.update = function () { return queueWatcher(watcher); };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// pre</span><span class="s2">\n        </span><span class="s1">watcher.update = function () {</span><span class="s2">\n            </span><span class="s1">if (instance &amp;&amp; instance === currentInstance &amp;&amp; !instance._isMounted) {</span><span class="s2">\n                </span><span class="s1">// pre-watcher triggered before</span><span class="s2">\n                </span><span class="s1">var buffer = instance._preWatchers || (instance._preWatchers = []);</span><span class="s2">\n                </span><span class="s1">if (buffer.indexOf(watcher) &lt; 0)</span><span class="s2">\n                    </span><span class="s1">buffer.push(watcher);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">queueWatcher(watcher);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">watcher.onTrack = onTrack;</span><span class="s2">\n        </span><span class="s1">watcher.onTrigger = onTrigger;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// initial run</span><span class="s2">\n    </span><span class="s1">if (cb) {</span><span class="s2">\n        </span><span class="s1">if (immediate) {</span><span class="s2">\n            </span><span class="s1">watcher.run();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">oldValue = watcher.get();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (flush === 'post' &amp;&amp; instance) {</span><span class="s2">\n        </span><span class="s1">instance.$once('hook:mounted', function () { return watcher.get(); });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">watcher.get();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return function () {</span><span class="s2">\n        </span><span class="s1">watcher.teardown();</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var activeEffectScope;</span><span class="s2">\n</span><span class="s1">var EffectScope = /** @class */ (function () {</span><span class="s2">\n    </span><span class="s1">function EffectScope(detached) {</span><span class="s2">\n        </span><span class="s1">if (detached === void 0) { detached = false; }</span><span class="s2">\n        </span><span class="s1">this.detached = detached;</span><span class="s2">\n        </span><span class="s1">/**</span><span class="s2">\n         </span><span class="s1">* @internal</span><span class="s2">\n         </span><span class="s1">*/</span><span class="s2">\n        </span><span class="s1">this.active = true;</span><span class="s2">\n        </span><span class="s1">/**</span><span class="s2">\n         </span><span class="s1">* @internal</span><span class="s2">\n         </span><span class="s1">*/</span><span class="s2">\n        </span><span class="s1">this.effects = [];</span><span class="s2">\n        </span><span class="s1">/**</span><span class="s2">\n         </span><span class="s1">* @internal</span><span class="s2">\n         </span><span class="s1">*/</span><span class="s2">\n        </span><span class="s1">this.cleanups = [];</span><span class="s2">\n        </span><span class="s1">this.parent = activeEffectScope;</span><span class="s2">\n        </span><span class="s1">if (!detached &amp;&amp; activeEffectScope) {</span><span class="s2">\n            </span><span class="s1">this.index =</span><span class="s2">\n                </span><span class="s1">(activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">EffectScope.prototype.run = function (fn) {</span><span class="s2">\n        </span><span class="s1">if (this.active) {</span><span class="s2">\n            </span><span class="s1">var currentEffectScope = activeEffectScope;</span><span class="s2">\n            </span><span class="s1">try {</span><span class="s2">\n                </span><span class="s1">activeEffectScope = this;</span><span class="s2">\n                </span><span class="s1">return fn();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">finally {</span><span class="s2">\n                </span><span class="s1">activeEffectScope = currentEffectScope;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">cannot run an inactive effect scope.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* This should only be called on non-detached scopes</span><span class="s2">\n     </span><span class="s1">* @internal</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">EffectScope.prototype.on = function () {</span><span class="s2">\n        </span><span class="s1">activeEffectScope = this;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* This should only be called on non-detached scopes</span><span class="s2">\n     </span><span class="s1">* @internal</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">EffectScope.prototype.off = function () {</span><span class="s2">\n        </span><span class="s1">activeEffectScope = this.parent;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">EffectScope.prototype.stop = function (fromParent) {</span><span class="s2">\n        </span><span class="s1">if (this.active) {</span><span class="s2">\n            </span><span class="s1">var i = void 0, l = void 0;</span><span class="s2">\n            </span><span class="s1">for (i = 0, l = this.effects.length; i &lt; l; i++) {</span><span class="s2">\n                </span><span class="s1">this.effects[i].teardown();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">for (i = 0, l = this.cleanups.length; i &lt; l; i++) {</span><span class="s2">\n                </span><span class="s1">this.cleanups[i]();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (this.scopes) {</span><span class="s2">\n                </span><span class="s1">for (i = 0, l = this.scopes.length; i &lt; l; i++) {</span><span class="s2">\n                    </span><span class="s1">this.scopes[i].stop(true);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// nested scope, dereference from parent to avoid memory leaks</span><span class="s2">\n            </span><span class="s1">if (!this.detached &amp;&amp; this.parent &amp;&amp; !fromParent) {</span><span class="s2">\n                </span><span class="s1">// optimized O(1) removal</span><span class="s2">\n                </span><span class="s1">var last = this.parent.scopes.pop();</span><span class="s2">\n                </span><span class="s1">if (last &amp;&amp; last !== this) {</span><span class="s2">\n                    </span><span class="s1">this.parent.scopes[this.index] = last;</span><span class="s2">\n                    </span><span class="s1">last.index = this.index;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">this.parent = undefined;</span><span class="s2">\n            </span><span class="s1">this.active = false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return EffectScope;</span><span class="s2">\n</span><span class="s1">}());</span><span class="s2">\n</span><span class="s1">function effectScope(detached) {</span><span class="s2">\n    </span><span class="s1">return new EffectScope(detached);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function recordEffectScope(effect, scope) {</span><span class="s2">\n    </span><span class="s1">if (scope === void 0) { scope = activeEffectScope; }</span><span class="s2">\n    </span><span class="s1">if (scope &amp;&amp; scope.active) {</span><span class="s2">\n        </span><span class="s1">scope.effects.push(effect);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getCurrentScope() {</span><span class="s2">\n    </span><span class="s1">return activeEffectScope;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function onScopeDispose(fn) {</span><span class="s2">\n    </span><span class="s1">if (activeEffectScope) {</span><span class="s2">\n        </span><span class="s1">activeEffectScope.cleanups.push(fn);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">onScopeDispose() is called when there is no active effect scope</span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n            \&quot; </span><span class="s1">to be associated with.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function provide(key, value) {</span><span class="s2">\n    </span><span class="s1">if (!currentInstance) {</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">provide() can only be used inside setup().</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// TS doesn't allow symbol as index type</span><span class="s2">\n        </span><span class="s1">resolveProvided(currentInstance)[key] = value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveProvided(vm) {</span><span class="s2">\n    </span><span class="s1">// by default an instance inherits its parent's provides object</span><span class="s2">\n    </span><span class="s1">// but when it needs to provide values of its own, it creates its</span><span class="s2">\n    </span><span class="s1">// own provides object using parent provides object as prototype.</span><span class="s2">\n    </span><span class="s1">// this way in `inject` we can simply look up injections from direct</span><span class="s2">\n    </span><span class="s1">// parent and let the prototype chain do the work.</span><span class="s2">\n    </span><span class="s1">var existing = vm._provided;</span><span class="s2">\n    </span><span class="s1">var parentProvides = vm.$parent &amp;&amp; vm.$parent._provided;</span><span class="s2">\n    </span><span class="s1">if (parentProvides === existing) {</span><span class="s2">\n        </span><span class="s1">return (vm._provided = Object.create(parentProvides));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">return existing;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function inject(key, defaultValue, treatDefaultAsFactory) {</span><span class="s2">\n    </span><span class="s1">if (treatDefaultAsFactory === void 0) { treatDefaultAsFactory = false; }</span><span class="s2">\n    </span><span class="s1">// fallback to `currentRenderingInstance` so that this can be called in</span><span class="s2">\n    </span><span class="s1">// a functional component</span><span class="s2">\n    </span><span class="s1">var instance = currentInstance;</span><span class="s2">\n    </span><span class="s1">if (instance) {</span><span class="s2">\n        </span><span class="s1">// #2400</span><span class="s2">\n        </span><span class="s1">// to support `app.use` plugins,</span><span class="s2">\n        </span><span class="s1">// fallback to appContext's `provides` if the instance is at root</span><span class="s2">\n        </span><span class="s1">var provides = instance.$parent &amp;&amp; instance.$parent._provided;</span><span class="s2">\n        </span><span class="s1">if (provides &amp;&amp; key in provides) {</span><span class="s2">\n            </span><span class="s1">// TS doesn't allow symbol as index type</span><span class="s2">\n            </span><span class="s1">return provides[key];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (arguments.length &gt; 1) {</span><span class="s2">\n            </span><span class="s1">return treatDefaultAsFactory &amp;&amp; isFunction(defaultValue)</span><span class="s2">\n                </span><span class="s1">? defaultValue.call(instance)</span><span class="s2">\n                </span><span class="s1">: defaultValue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">injection </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(String(key), </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">not found.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">inject() can only be used inside setup() or functional components.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var normalizeEvent = cached(function (name) {</span><span class="s2">\n    </span><span class="s1">var passive = name.charAt(0) === '&amp;';</span><span class="s2">\n    </span><span class="s1">name = passive ? name.slice(1) : name;</span><span class="s2">\n    </span><span class="s1">var once = name.charAt(0) === '~'; // Prefixed last, checked first</span><span class="s2">\n    </span><span class="s1">name = once ? name.slice(1) : name;</span><span class="s2">\n    </span><span class="s1">var capture = name.charAt(0) === '!';</span><span class="s2">\n    </span><span class="s1">name = capture ? name.slice(1) : name;</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">name: name,</span><span class="s2">\n        </span><span class="s1">once: once,</span><span class="s2">\n        </span><span class="s1">capture: capture,</span><span class="s2">\n        </span><span class="s1">passive: passive</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">function createFnInvoker(fns, vm) {</span><span class="s2">\n    </span><span class="s1">function invoker() {</span><span class="s2">\n        </span><span class="s1">var fns = invoker.fns;</span><span class="s2">\n        </span><span class="s1">if (isArray(fns)) {</span><span class="s2">\n            </span><span class="s1">var cloned = fns.slice();</span><span class="s2">\n            </span><span class="s1">for (var i = 0; i &lt; cloned.length; i++) {</span><span class="s2">\n                </span><span class="s1">invokeWithErrorHandling(cloned[i], null, arguments, vm, </span><span class="s2">\&quot;</span><span class="s1">v-on handler</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// return handler return value for single handlers</span><span class="s2">\n            </span><span class="s1">return invokeWithErrorHandling(fns, null, arguments, vm, </span><span class="s2">\&quot;</span><span class="s1">v-on handler</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">invoker.fns = fns;</span><span class="s2">\n    </span><span class="s1">return invoker;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {</span><span class="s2">\n    </span><span class="s1">var name, cur, old, event;</span><span class="s2">\n    </span><span class="s1">for (name in on) {</span><span class="s2">\n        </span><span class="s1">cur = on[name];</span><span class="s2">\n        </span><span class="s1">old = oldOn[name];</span><span class="s2">\n        </span><span class="s1">event = normalizeEvent(name);</span><span class="s2">\n        </span><span class="s1">if (isUndef(cur)) {</span><span class="s2">\n            </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Invalid handler for event </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(event.name, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">: got </span><span class="s2">\&quot;</span><span class="s1">) + String(cur), vm);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (isUndef(old)) {</span><span class="s2">\n            </span><span class="s1">if (isUndef(cur.fns)) {</span><span class="s2">\n                </span><span class="s1">cur = on[name] = createFnInvoker(cur, vm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (isTrue(event.once)) {</span><span class="s2">\n                </span><span class="s1">cur = on[name] = createOnceHandler(event.name, cur, event.capture);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">add(event.name, cur, event.capture, event.passive, event.params);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (cur !== old) {</span><span class="s2">\n            </span><span class="s1">old.fns = cur;</span><span class="s2">\n            </span><span class="s1">on[name] = old;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (name in oldOn) {</span><span class="s2">\n        </span><span class="s1">if (isUndef(on[name])) {</span><span class="s2">\n            </span><span class="s1">event = normalizeEvent(name);</span><span class="s2">\n            </span><span class="s1">remove(event.name, oldOn[name], event.capture);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function mergeVNodeHook(def, hookKey, hook) {</span><span class="s2">\n    </span><span class="s1">if (def instanceof VNode) {</span><span class="s2">\n        </span><span class="s1">def = def.data.hook || (def.data.hook = {});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var invoker;</span><span class="s2">\n    </span><span class="s1">var oldHook = def[hookKey];</span><span class="s2">\n    </span><span class="s1">function wrappedHook() {</span><span class="s2">\n        </span><span class="s1">hook.apply(this, arguments);</span><span class="s2">\n        </span><span class="s1">// important: remove merged hook to ensure it's called only once</span><span class="s2">\n        </span><span class="s1">// and prevent memory leak</span><span class="s2">\n        </span><span class="s1">remove$2(invoker.fns, wrappedHook);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isUndef(oldHook)) {</span><span class="s2">\n        </span><span class="s1">// no existing hook</span><span class="s2">\n        </span><span class="s1">invoker = createFnInvoker([wrappedHook]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n        </span><span class="s1">if (isDef(oldHook.fns) &amp;&amp; isTrue(oldHook.merged)) {</span><span class="s2">\n            </span><span class="s1">// already a merged invoker</span><span class="s2">\n            </span><span class="s1">invoker = oldHook;</span><span class="s2">\n            </span><span class="s1">invoker.fns.push(wrappedHook);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// existing plain hook</span><span class="s2">\n            </span><span class="s1">invoker = createFnInvoker([oldHook, wrappedHook]);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">invoker.merged = true;</span><span class="s2">\n    </span><span class="s1">def[hookKey] = invoker;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function extractPropsFromVNodeData(data, Ctor, tag) {</span><span class="s2">\n    </span><span class="s1">// we are only extracting raw values here.</span><span class="s2">\n    </span><span class="s1">// validation and default values are handled in the child</span><span class="s2">\n    </span><span class="s1">// component itself.</span><span class="s2">\n    </span><span class="s1">var propOptions = Ctor.options.props;</span><span class="s2">\n    </span><span class="s1">if (isUndef(propOptions)) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var res = {};</span><span class="s2">\n    </span><span class="s1">var attrs = data.attrs, props = data.props;</span><span class="s2">\n    </span><span class="s1">if (isDef(attrs) || isDef(props)) {</span><span class="s2">\n        </span><span class="s1">for (var key in propOptions) {</span><span class="s2">\n            </span><span class="s1">var altKey = hyphenate(key);</span><span class="s2">\n            </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n                </span><span class="s1">var keyInLowerCase = key.toLowerCase();</span><span class="s2">\n                </span><span class="s1">if (key !== keyInLowerCase &amp;&amp; attrs &amp;&amp; hasOwn(attrs, keyInLowerCase)) {</span><span class="s2">\n                    </span><span class="s1">tip(</span><span class="s2">\&quot;</span><span class="s1">Prop </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(keyInLowerCase, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is passed to component </span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n                        \&quot;\&quot;</span><span class="s1">.concat(formatComponentName(</span><span class="s2">\n                        </span><span class="s1">// @ts-expect-error tag is string</span><span class="s2">\n                        </span><span class="s1">tag || Ctor), </span><span class="s2">\&quot;</span><span class="s1">, but the declared prop name is</span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n                        \&quot; \\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">. </span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n                        \&quot;</span><span class="s1">Note that HTML attributes are case-insensitive and camelCased </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                        \&quot;</span><span class="s1">props need to use their kebab-case equivalents when using in-DOM </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                        \&quot;</span><span class="s1">templates. You should probably use </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(altKey, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">instead of </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">).concat(key, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">checkProp(res, props, key, altKey, true) ||</span><span class="s2">\n                </span><span class="s1">checkProp(res, attrs, key, altKey, false);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function checkProp(res, hash, key, altKey, preserve) {</span><span class="s2">\n    </span><span class="s1">if (isDef(hash)) {</span><span class="s2">\n        </span><span class="s1">if (hasOwn(hash, key)) {</span><span class="s2">\n            </span><span class="s1">res[key] = hash[key];</span><span class="s2">\n            </span><span class="s1">if (!preserve) {</span><span class="s2">\n                </span><span class="s1">delete hash[key];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (hasOwn(hash, altKey)) {</span><span class="s2">\n            </span><span class="s1">res[key] = hash[altKey];</span><span class="s2">\n            </span><span class="s1">if (!preserve) {</span><span class="s2">\n                </span><span class="s1">delete hash[altKey];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// The template compiler attempts to minimize the need for normalization by</span><span class="s2">\n</span><span class="s1">// statically analyzing the template at compile time.</span><span class="s2">\n</span><span class="s1">//</span><span class="s2">\n</span><span class="s1">// For plain HTML markup, normalization can be completely skipped because the</span><span class="s2">\n</span><span class="s1">// generated render function is guaranteed to return Array&lt;VNode&gt;. There are</span><span class="s2">\n</span><span class="s1">// two cases where extra normalization is needed:</span><span class="s2">\n</span><span class="s1">// 1. When the children contains components - because a functional component</span><span class="s2">\n</span><span class="s1">// may return an Array instead of a single root. In this case, just a simple</span><span class="s2">\n</span><span class="s1">// normalization is needed - if any child is an Array, we flatten the whole</span><span class="s2">\n</span><span class="s1">// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep</span><span class="s2">\n</span><span class="s1">// because functional components already normalize their own children.</span><span class="s2">\n</span><span class="s1">function simpleNormalizeChildren(children) {</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; children.length; i++) {</span><span class="s2">\n        </span><span class="s1">if (isArray(children[i])) {</span><span class="s2">\n            </span><span class="s1">return Array.prototype.concat.apply([], children);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return children;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// 2. When the children contains constructs that always generated nested Arrays,</span><span class="s2">\n</span><span class="s1">// e.g. &lt;template&gt;, &lt;slot&gt;, v-for, or when the children is provided by user</span><span class="s2">\n</span><span class="s1">// with hand-written render functions / JSX. In such cases a full normalization</span><span class="s2">\n</span><span class="s1">// is needed to cater to all possible types of children values.</span><span class="s2">\n</span><span class="s1">function normalizeChildren(children) {</span><span class="s2">\n    </span><span class="s1">return isPrimitive(children)</span><span class="s2">\n        </span><span class="s1">? [createTextVNode(children)]</span><span class="s2">\n        </span><span class="s1">: isArray(children)</span><span class="s2">\n            </span><span class="s1">? normalizeArrayChildren(children)</span><span class="s2">\n            </span><span class="s1">: undefined;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isTextNode(node) {</span><span class="s2">\n    </span><span class="s1">return isDef(node) &amp;&amp; isDef(node.text) &amp;&amp; isFalse(node.isComment);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeArrayChildren(children, nestedIndex) {</span><span class="s2">\n    </span><span class="s1">var res = [];</span><span class="s2">\n    </span><span class="s1">var i, c, lastIndex, last;</span><span class="s2">\n    </span><span class="s1">for (i = 0; i &lt; children.length; i++) {</span><span class="s2">\n        </span><span class="s1">c = children[i];</span><span class="s2">\n        </span><span class="s1">if (isUndef(c) || typeof c === 'boolean')</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">lastIndex = res.length - 1;</span><span class="s2">\n        </span><span class="s1">last = res[lastIndex];</span><span class="s2">\n        </span><span class="s1">//  nested</span><span class="s2">\n        </span><span class="s1">if (isArray(c)) {</span><span class="s2">\n            </span><span class="s1">if (c.length &gt; 0) {</span><span class="s2">\n                </span><span class="s1">c = normalizeArrayChildren(c, </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(nestedIndex || '', </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot;</span><span class="s1">).concat(i));</span><span class="s2">\n                </span><span class="s1">// merge adjacent text nodes</span><span class="s2">\n                </span><span class="s1">if (isTextNode(c[0]) &amp;&amp; isTextNode(last)) {</span><span class="s2">\n                    </span><span class="s1">res[lastIndex] = createTextVNode(last.text + c[0].text);</span><span class="s2">\n                    </span><span class="s1">c.shift();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">res.push.apply(res, c);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (isPrimitive(c)) {</span><span class="s2">\n            </span><span class="s1">if (isTextNode(last)) {</span><span class="s2">\n                </span><span class="s1">// merge adjacent text nodes</span><span class="s2">\n                </span><span class="s1">// this is necessary for SSR hydration because text nodes are</span><span class="s2">\n                </span><span class="s1">// essentially merged when rendered to HTML strings</span><span class="s2">\n                </span><span class="s1">res[lastIndex] = createTextVNode(last.text + c);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (c !== '') {</span><span class="s2">\n                </span><span class="s1">// convert primitive to vnode</span><span class="s2">\n                </span><span class="s1">res.push(createTextVNode(c));</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">if (isTextNode(c) &amp;&amp; isTextNode(last)) {</span><span class="s2">\n                </span><span class="s1">// merge adjacent text nodes</span><span class="s2">\n                </span><span class="s1">res[lastIndex] = createTextVNode(last.text + c.text);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">// default key for nested array children (likely generated by v-for)</span><span class="s2">\n                </span><span class="s1">if (isTrue(children._isVList) &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">isDef(c.tag) &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">isUndef(c.key) &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">isDef(nestedIndex)) {</span><span class="s2">\n                    </span><span class="s1">c.key = </span><span class="s2">\&quot;</span><span class="s1">__vlist</span><span class="s2">\&quot;</span><span class="s1">.concat(nestedIndex, </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot;</span><span class="s1">).concat(i, </span><span class="s2">\&quot;</span><span class="s1">__</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">res.push(c);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for rendering v-for lists.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function renderList(val, render) {</span><span class="s2">\n    </span><span class="s1">var ret = null, i, l, keys, key;</span><span class="s2">\n    </span><span class="s1">if (isArray(val) || typeof val === 'string') {</span><span class="s2">\n        </span><span class="s1">ret = new Array(val.length);</span><span class="s2">\n        </span><span class="s1">for (i = 0, l = val.length; i &lt; l; i++) {</span><span class="s2">\n            </span><span class="s1">ret[i] = render(val[i], i);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (typeof val === 'number') {</span><span class="s2">\n        </span><span class="s1">ret = new Array(val);</span><span class="s2">\n        </span><span class="s1">for (i = 0; i &lt; val; i++) {</span><span class="s2">\n            </span><span class="s1">ret[i] = render(i + 1, i);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isObject(val)) {</span><span class="s2">\n        </span><span class="s1">if (hasSymbol &amp;&amp; val[Symbol.iterator]) {</span><span class="s2">\n            </span><span class="s1">ret = [];</span><span class="s2">\n            </span><span class="s1">var iterator = val[Symbol.iterator]();</span><span class="s2">\n            </span><span class="s1">var result = iterator.next();</span><span class="s2">\n            </span><span class="s1">while (!result.done) {</span><span class="s2">\n                </span><span class="s1">ret.push(render(result.value, ret.length));</span><span class="s2">\n                </span><span class="s1">result = iterator.next();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">keys = Object.keys(val);</span><span class="s2">\n            </span><span class="s1">ret = new Array(keys.length);</span><span class="s2">\n            </span><span class="s1">for (i = 0, l = keys.length; i &lt; l; i++) {</span><span class="s2">\n                </span><span class="s1">key = keys[i];</span><span class="s2">\n                </span><span class="s1">ret[i] = render(val[key], key, i);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!isDef(ret)) {</span><span class="s2">\n        </span><span class="s1">ret = [];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">ret._isVList = true;</span><span class="s2">\n    </span><span class="s1">return ret;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for rendering &lt;slot&gt;</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function renderSlot(name, fallbackRender, props, bindObject) {</span><span class="s2">\n    </span><span class="s1">var scopedSlotFn = this.$scopedSlots[name];</span><span class="s2">\n    </span><span class="s1">var nodes;</span><span class="s2">\n    </span><span class="s1">if (scopedSlotFn) {</span><span class="s2">\n        </span><span class="s1">// scoped slot</span><span class="s2">\n        </span><span class="s1">props = props || {};</span><span class="s2">\n        </span><span class="s1">if (bindObject) {</span><span class="s2">\n            </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !isObject(bindObject)) {</span><span class="s2">\n                </span><span class="s1">warn('slot v-bind without argument expects an Object', this);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">props = extend(extend({}, bindObject), props);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">nodes =</span><span class="s2">\n            </span><span class="s1">scopedSlotFn(props) ||</span><span class="s2">\n                </span><span class="s1">(isFunction(fallbackRender) ? fallbackRender() : fallbackRender);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">nodes =</span><span class="s2">\n            </span><span class="s1">this.$slots[name] ||</span><span class="s2">\n                </span><span class="s1">(isFunction(fallbackRender) ? fallbackRender() : fallbackRender);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var target = props &amp;&amp; props.slot;</span><span class="s2">\n    </span><span class="s1">if (target) {</span><span class="s2">\n        </span><span class="s1">return this.$createElement('template', { slot: target }, nodes);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">return nodes;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for resolving filters</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function resolveFilter(id) {</span><span class="s2">\n    </span><span class="s1">return resolveAsset(this.$options, 'filters', id, true) || identity;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function isKeyNotMatch(expect, actual) {</span><span class="s2">\n    </span><span class="s1">if (isArray(expect)) {</span><span class="s2">\n        </span><span class="s1">return expect.indexOf(actual) === -1;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">return expect !== actual;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for checking keyCodes from config.</span><span class="s2">\n </span><span class="s1">* exposed as Vue.prototype._k</span><span class="s2">\n </span><span class="s1">* passing in eventKeyName as last argument separately for backwards compat</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {</span><span class="s2">\n    </span><span class="s1">var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;</span><span class="s2">\n    </span><span class="s1">if (builtInKeyName &amp;&amp; eventKeyName &amp;&amp; !config.keyCodes[key]) {</span><span class="s2">\n        </span><span class="s1">return isKeyNotMatch(builtInKeyName, eventKeyName);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (mappedKeyCode) {</span><span class="s2">\n        </span><span class="s1">return isKeyNotMatch(mappedKeyCode, eventKeyCode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (eventKeyName) {</span><span class="s2">\n        </span><span class="s1">return hyphenate(eventKeyName) !== key;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return eventKeyCode === undefined;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for merging v-bind=</span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">into a VNode's data.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function bindObjectProps(data, tag, value, asProp, isSync) {</span><span class="s2">\n    </span><span class="s1">if (value) {</span><span class="s2">\n        </span><span class="s1">if (!isObject(value)) {</span><span class="s2">\n            </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n                </span><span class="s1">warn('v-bind without argument expects an Object or Array value', this);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">if (isArray(value)) {</span><span class="s2">\n                </span><span class="s1">value = toObject(value);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">var hash = void 0;</span><span class="s2">\n            </span><span class="s1">var _loop_1 = function (key) {</span><span class="s2">\n                </span><span class="s1">if (key === 'class' || key === 'style' || isReservedAttribute(key)) {</span><span class="s2">\n                    </span><span class="s1">hash = data;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">var type = data.attrs &amp;&amp; data.attrs.type;</span><span class="s2">\n                    </span><span class="s1">hash =</span><span class="s2">\n                        </span><span class="s1">asProp || config.mustUseProp(tag, type, key)</span><span class="s2">\n                            </span><span class="s1">? data.domProps || (data.domProps = {})</span><span class="s2">\n                            </span><span class="s1">: data.attrs || (data.attrs = {});</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">var camelizedKey = camelize(key);</span><span class="s2">\n                </span><span class="s1">var hyphenatedKey = hyphenate(key);</span><span class="s2">\n                </span><span class="s1">if (!(camelizedKey in hash) &amp;&amp; !(hyphenatedKey in hash)) {</span><span class="s2">\n                    </span><span class="s1">hash[key] = value[key];</span><span class="s2">\n                    </span><span class="s1">if (isSync) {</span><span class="s2">\n                        </span><span class="s1">var on = data.on || (data.on = {});</span><span class="s2">\n                        </span><span class="s1">on[</span><span class="s2">\&quot;</span><span class="s1">update:</span><span class="s2">\&quot;</span><span class="s1">.concat(key)] = function ($event) {</span><span class="s2">\n                            </span><span class="s1">value[key] = $event;</span><span class="s2">\n                        </span><span class="s1">};</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">};</span><span class="s2">\n            </span><span class="s1">for (var key in value) {</span><span class="s2">\n                </span><span class="s1">_loop_1(key);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return data;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for rendering static trees.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function renderStatic(index, isInFor) {</span><span class="s2">\n    </span><span class="s1">var cached = this._staticTrees || (this._staticTrees = []);</span><span class="s2">\n    </span><span class="s1">var tree = cached[index];</span><span class="s2">\n    </span><span class="s1">// if has already-rendered static tree and not inside v-for,</span><span class="s2">\n    </span><span class="s1">// we can reuse the same tree.</span><span class="s2">\n    </span><span class="s1">if (tree &amp;&amp; !isInFor) {</span><span class="s2">\n        </span><span class="s1">return tree;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// otherwise, render a fresh tree.</span><span class="s2">\n    </span><span class="s1">tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, this._c, this // for render fns generated for functional component templates</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">markStatic(tree, </span><span class="s2">\&quot;</span><span class="s1">__static__</span><span class="s2">\&quot;</span><span class="s1">.concat(index), false);</span><span class="s2">\n    </span><span class="s1">return tree;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for v-once.</span><span class="s2">\n </span><span class="s1">* Effectively it means marking the node as static with a unique key.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function markOnce(tree, index, key) {</span><span class="s2">\n    </span><span class="s1">markStatic(tree, </span><span class="s2">\&quot;</span><span class="s1">__once__</span><span class="s2">\&quot;</span><span class="s1">.concat(index).concat(key ? </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot;</span><span class="s1">.concat(key) : </span><span class="s2">\&quot;\&quot;</span><span class="s1">), true);</span><span class="s2">\n    </span><span class="s1">return tree;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function markStatic(tree, key, isOnce) {</span><span class="s2">\n    </span><span class="s1">if (isArray(tree)) {</span><span class="s2">\n        </span><span class="s1">for (var i = 0; i &lt; tree.length; i++) {</span><span class="s2">\n            </span><span class="s1">if (tree[i] &amp;&amp; typeof tree[i] !== 'string') {</span><span class="s2">\n                </span><span class="s1">markStaticNode(tree[i], </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot;</span><span class="s1">).concat(i), isOnce);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">markStaticNode(tree, key, isOnce);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function markStaticNode(node, key, isOnce) {</span><span class="s2">\n    </span><span class="s1">node.isStatic = true;</span><span class="s2">\n    </span><span class="s1">node.key = key;</span><span class="s2">\n    </span><span class="s1">node.isOnce = isOnce;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function bindObjectListeners(data, value) {</span><span class="s2">\n    </span><span class="s1">if (value) {</span><span class="s2">\n        </span><span class="s1">if (!isPlainObject(value)) {</span><span class="s2">\n            </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn('v-on without argument expects an Object value', this);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">var on = (data.on = data.on ? extend({}, data.on) : {});</span><span class="s2">\n            </span><span class="s1">for (var key in value) {</span><span class="s2">\n                </span><span class="s1">var existing = on[key];</span><span class="s2">\n                </span><span class="s1">var ours = value[key];</span><span class="s2">\n                </span><span class="s1">on[key] = existing ? [].concat(existing, ours) : ours;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return data;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function resolveScopedSlots(fns, res, </span><span class="s2">\n</span><span class="s1">// the following are added in 2.6</span><span class="s2">\n</span><span class="s1">hasDynamicKeys, contentHashKey) {</span><span class="s2">\n    </span><span class="s1">res = res || { $stable: !hasDynamicKeys };</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; fns.length; i++) {</span><span class="s2">\n        </span><span class="s1">var slot = fns[i];</span><span class="s2">\n        </span><span class="s1">if (isArray(slot)) {</span><span class="s2">\n            </span><span class="s1">resolveScopedSlots(slot, res, hasDynamicKeys);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (slot) {</span><span class="s2">\n            </span><span class="s1">// marker for reverse proxying v-slot without scope on this.$slots</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error</span><span class="s2">\n            </span><span class="s1">if (slot.proxy) {</span><span class="s2">\n                </span><span class="s1">// @ts-expect-error</span><span class="s2">\n                </span><span class="s1">slot.fn.proxy = true;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">res[slot.key] = slot.fn;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (contentHashKey) {</span><span class="s2">\n        </span><span class="s1">res.$key = contentHashKey;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// helper to process dynamic keys for dynamic arguments in v-bind and v-on.</span><span class="s2">\n</span><span class="s1">function bindDynamicKeys(baseObj, values) {</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; values.length; i += 2) {</span><span class="s2">\n        </span><span class="s1">var key = values[i];</span><span class="s2">\n        </span><span class="s1">if (typeof key === 'string' &amp;&amp; key) {</span><span class="s2">\n            </span><span class="s1">baseObj[values[i]] = values[i + 1];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (process.env.NODE_ENV !== 'production' &amp;&amp; key !== '' &amp;&amp; key !== null) {</span><span class="s2">\n            </span><span class="s1">// null is a special value for explicitly removing a binding</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Invalid value for dynamic directive argument (expected string or null): </span><span class="s2">\&quot;</span><span class="s1">.concat(key), this);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return baseObj;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// helper to dynamically append modifier runtime markers to event names.</span><span class="s2">\n</span><span class="s1">// ensure only append when value is already string, otherwise it will be cast</span><span class="s2">\n</span><span class="s1">// to string and cause the type check to miss.</span><span class="s2">\n</span><span class="s1">function prependModifier(value, symbol) {</span><span class="s2">\n    </span><span class="s1">return typeof value === 'string' ? symbol + value : value;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function installRenderHelpers(target) {</span><span class="s2">\n    </span><span class="s1">target._o = markOnce;</span><span class="s2">\n    </span><span class="s1">target._n = toNumber;</span><span class="s2">\n    </span><span class="s1">target._s = toString;</span><span class="s2">\n    </span><span class="s1">target._l = renderList;</span><span class="s2">\n    </span><span class="s1">target._t = renderSlot;</span><span class="s2">\n    </span><span class="s1">target._q = looseEqual;</span><span class="s2">\n    </span><span class="s1">target._i = looseIndexOf;</span><span class="s2">\n    </span><span class="s1">target._m = renderStatic;</span><span class="s2">\n    </span><span class="s1">target._f = resolveFilter;</span><span class="s2">\n    </span><span class="s1">target._k = checkKeyCodes;</span><span class="s2">\n    </span><span class="s1">target._b = bindObjectProps;</span><span class="s2">\n    </span><span class="s1">target._v = createTextVNode;</span><span class="s2">\n    </span><span class="s1">target._e = createEmptyVNode;</span><span class="s2">\n    </span><span class="s1">target._u = resolveScopedSlots;</span><span class="s2">\n    </span><span class="s1">target._g = bindObjectListeners;</span><span class="s2">\n    </span><span class="s1">target._d = bindDynamicKeys;</span><span class="s2">\n    </span><span class="s1">target._p = prependModifier;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for resolving raw children VNodes into a slot object.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function resolveSlots(children, context) {</span><span class="s2">\n    </span><span class="s1">if (!children || !children.length) {</span><span class="s2">\n        </span><span class="s1">return {};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var slots = {};</span><span class="s2">\n    </span><span class="s1">for (var i = 0, l = children.length; i &lt; l; i++) {</span><span class="s2">\n        </span><span class="s1">var child = children[i];</span><span class="s2">\n        </span><span class="s1">var data = child.data;</span><span class="s2">\n        </span><span class="s1">// remove slot attribute if the node is resolved as a Vue slot node</span><span class="s2">\n        </span><span class="s1">if (data &amp;&amp; data.attrs &amp;&amp; data.attrs.slot) {</span><span class="s2">\n            </span><span class="s1">delete data.attrs.slot;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// named slots should only be respected if the vnode was rendered in the</span><span class="s2">\n        </span><span class="s1">// same context.</span><span class="s2">\n        </span><span class="s1">if ((child.context === context || child.fnContext === context) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">data &amp;&amp;</span><span class="s2">\n            </span><span class="s1">data.slot != null) {</span><span class="s2">\n            </span><span class="s1">var name_1 = data.slot;</span><span class="s2">\n            </span><span class="s1">var slot = slots[name_1] || (slots[name_1] = []);</span><span class="s2">\n            </span><span class="s1">if (child.tag === 'template') {</span><span class="s2">\n                </span><span class="s1">slot.push.apply(slot, child.children || []);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">slot.push(child);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">(slots.default || (slots.default = [])).push(child);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// ignore slots that contains only whitespace</span><span class="s2">\n    </span><span class="s1">for (var name_2 in slots) {</span><span class="s2">\n        </span><span class="s1">if (slots[name_2].every(isWhitespace)) {</span><span class="s2">\n            </span><span class="s1">delete slots[name_2];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return slots;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isWhitespace(node) {</span><span class="s2">\n    </span><span class="s1">return (node.isComment &amp;&amp; !node.asyncFactory) || node.text === ' ';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function isAsyncPlaceholder(node) {</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error not really boolean type</span><span class="s2">\n    </span><span class="s1">return node.isComment &amp;&amp; node.asyncFactory;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {</span><span class="s2">\n    </span><span class="s1">var res;</span><span class="s2">\n    </span><span class="s1">var hasNormalSlots = Object.keys(normalSlots).length &gt; 0;</span><span class="s2">\n    </span><span class="s1">var isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;</span><span class="s2">\n    </span><span class="s1">var key = scopedSlots &amp;&amp; scopedSlots.$key;</span><span class="s2">\n    </span><span class="s1">if (!scopedSlots) {</span><span class="s2">\n        </span><span class="s1">res = {};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (scopedSlots._normalized) {</span><span class="s2">\n        </span><span class="s1">// fast path 1: child component re-render only, parent did not change</span><span class="s2">\n        </span><span class="s1">return scopedSlots._normalized;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isStable &amp;&amp;</span><span class="s2">\n        </span><span class="s1">prevScopedSlots &amp;&amp;</span><span class="s2">\n        </span><span class="s1">prevScopedSlots !== emptyObject &amp;&amp;</span><span class="s2">\n        </span><span class="s1">key === prevScopedSlots.$key &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!hasNormalSlots &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!prevScopedSlots.$hasNormal) {</span><span class="s2">\n        </span><span class="s1">// fast path 2: stable scoped slots w/ no normal slots to proxy,</span><span class="s2">\n        </span><span class="s1">// only need to normalize once</span><span class="s2">\n        </span><span class="s1">return prevScopedSlots;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">res = {};</span><span class="s2">\n        </span><span class="s1">for (var key_1 in scopedSlots) {</span><span class="s2">\n            </span><span class="s1">if (scopedSlots[key_1] &amp;&amp; key_1[0] !== '$') {</span><span class="s2">\n                </span><span class="s1">res[key_1] = normalizeScopedSlot(ownerVm, normalSlots, key_1, scopedSlots[key_1]);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// expose normal slots on scopedSlots</span><span class="s2">\n    </span><span class="s1">for (var key_2 in normalSlots) {</span><span class="s2">\n        </span><span class="s1">if (!(key_2 in res)) {</span><span class="s2">\n            </span><span class="s1">res[key_2] = proxyNormalSlot(normalSlots, key_2);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// avoriaz seems to mock a non-extensible $scopedSlots object</span><span class="s2">\n    </span><span class="s1">// and when that is passed down this would cause an error</span><span class="s2">\n    </span><span class="s1">if (scopedSlots &amp;&amp; Object.isExtensible(scopedSlots)) {</span><span class="s2">\n        </span><span class="s1">scopedSlots._normalized = res;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">def(res, '$stable', isStable);</span><span class="s2">\n    </span><span class="s1">def(res, '$key', key);</span><span class="s2">\n    </span><span class="s1">def(res, '$hasNormal', hasNormalSlots);</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeScopedSlot(vm, normalSlots, key, fn) {</span><span class="s2">\n    </span><span class="s1">var normalized = function () {</span><span class="s2">\n        </span><span class="s1">var cur = currentInstance;</span><span class="s2">\n        </span><span class="s1">setCurrentInstance(vm);</span><span class="s2">\n        </span><span class="s1">var res = arguments.length ? fn.apply(null, arguments) : fn({});</span><span class="s2">\n        </span><span class="s1">res =</span><span class="s2">\n            </span><span class="s1">res &amp;&amp; typeof res === 'object' &amp;&amp; !isArray(res)</span><span class="s2">\n                </span><span class="s1">? [res] // single vnode</span><span class="s2">\n                </span><span class="s1">: normalizeChildren(res);</span><span class="s2">\n        </span><span class="s1">var vnode = res &amp;&amp; res[0];</span><span class="s2">\n        </span><span class="s1">setCurrentInstance(cur);</span><span class="s2">\n        </span><span class="s1">return res &amp;&amp;</span><span class="s2">\n            </span><span class="s1">(!vnode ||</span><span class="s2">\n                </span><span class="s1">(res.length === 1 &amp;&amp; vnode.isComment &amp;&amp; !isAsyncPlaceholder(vnode))) // #9658, #10391</span><span class="s2">\n            </span><span class="s1">? undefined</span><span class="s2">\n            </span><span class="s1">: res;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">// this is a slot using the new v-slot syntax without scope. although it is</span><span class="s2">\n    </span><span class="s1">// compiled as a scoped slot, render fn users would expect it to be present</span><span class="s2">\n    </span><span class="s1">// on this.$slots because the usage is semantically a normal slot.</span><span class="s2">\n    </span><span class="s1">if (fn.proxy) {</span><span class="s2">\n        </span><span class="s1">Object.defineProperty(normalSlots, key, {</span><span class="s2">\n            </span><span class="s1">get: normalized,</span><span class="s2">\n            </span><span class="s1">enumerable: true,</span><span class="s2">\n            </span><span class="s1">configurable: true</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return normalized;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function proxyNormalSlot(slots, key) {</span><span class="s2">\n    </span><span class="s1">return function () { return slots[key]; };</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function initSetup(vm) {</span><span class="s2">\n    </span><span class="s1">var options = vm.$options;</span><span class="s2">\n    </span><span class="s1">var setup = options.setup;</span><span class="s2">\n    </span><span class="s1">if (setup) {</span><span class="s2">\n        </span><span class="s1">var ctx = (vm._setupContext = createSetupContext(vm));</span><span class="s2">\n        </span><span class="s1">setCurrentInstance(vm);</span><span class="s2">\n        </span><span class="s1">pushTarget();</span><span class="s2">\n        </span><span class="s1">var setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, </span><span class="s2">\&quot;</span><span class="s1">setup</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">popTarget();</span><span class="s2">\n        </span><span class="s1">setCurrentInstance();</span><span class="s2">\n        </span><span class="s1">if (isFunction(setupResult)) {</span><span class="s2">\n            </span><span class="s1">// render function</span><span class="s2">\n            </span><span class="s1">// @ts-ignore</span><span class="s2">\n            </span><span class="s1">options.render = setupResult;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (isObject(setupResult)) {</span><span class="s2">\n            </span><span class="s1">// bindings</span><span class="s2">\n            </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; setupResult instanceof VNode) {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">setup() should not return VNodes directly - </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                    \&quot;</span><span class="s1">return a render function instead.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">vm._setupState = setupResult;</span><span class="s2">\n            </span><span class="s1">// __sfc indicates compiled bindings from &lt;script setup&gt;</span><span class="s2">\n            </span><span class="s1">if (!setupResult.__sfc) {</span><span class="s2">\n                </span><span class="s1">for (var key in setupResult) {</span><span class="s2">\n                    </span><span class="s1">if (!isReserved(key)) {</span><span class="s2">\n                        </span><span class="s1">proxyWithRefUnwrap(vm, setupResult, key);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n                        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Avoid using variables that start with _ or $ in setup().</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">// exposed for compiled render fn</span><span class="s2">\n                </span><span class="s1">var proxy = (vm._setupProxy = {});</span><span class="s2">\n                </span><span class="s1">for (var key in setupResult) {</span><span class="s2">\n                    </span><span class="s1">if (key !== '__sfc') {</span><span class="s2">\n                        </span><span class="s1">proxyWithRefUnwrap(proxy, setupResult, key);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (process.env.NODE_ENV !== 'production' &amp;&amp; setupResult !== undefined) {</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">setup() should return an object. Received: </span><span class="s2">\&quot;</span><span class="s1">.concat(setupResult === null ? 'null' : typeof setupResult));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createSetupContext(vm) {</span><span class="s2">\n    </span><span class="s1">var exposeCalled = false;</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">get attrs() {</span><span class="s2">\n            </span><span class="s1">if (!vm._attrsProxy) {</span><span class="s2">\n                </span><span class="s1">var proxy = (vm._attrsProxy = {});</span><span class="s2">\n                </span><span class="s1">def(proxy, '_v_attr_proxy', true);</span><span class="s2">\n                </span><span class="s1">syncSetupProxy(proxy, vm.$attrs, emptyObject, vm, '$attrs');</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return vm._attrsProxy;</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">get listeners() {</span><span class="s2">\n            </span><span class="s1">if (!vm._listenersProxy) {</span><span class="s2">\n                </span><span class="s1">var proxy = (vm._listenersProxy = {});</span><span class="s2">\n                </span><span class="s1">syncSetupProxy(proxy, vm.$listeners, emptyObject, vm, '$listeners');</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return vm._listenersProxy;</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">get slots() {</span><span class="s2">\n            </span><span class="s1">return initSlotsProxy(vm);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">emit: bind(vm.$emit, vm),</span><span class="s2">\n        </span><span class="s1">expose: function (exposed) {</span><span class="s2">\n            </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n                </span><span class="s1">if (exposeCalled) {</span><span class="s2">\n                    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">expose() should be called only once per setup().</span><span class="s2">\&quot;</span><span class="s1">, vm);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">exposeCalled = true;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (exposed) {</span><span class="s2">\n                </span><span class="s1">Object.keys(exposed).forEach(function (key) {</span><span class="s2">\n                    </span><span class="s1">return proxyWithRefUnwrap(vm, exposed, key);</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function syncSetupProxy(to, from, prev, instance, type) {</span><span class="s2">\n    </span><span class="s1">var changed = false;</span><span class="s2">\n    </span><span class="s1">for (var key in from) {</span><span class="s2">\n        </span><span class="s1">if (!(key in to)) {</span><span class="s2">\n            </span><span class="s1">changed = true;</span><span class="s2">\n            </span><span class="s1">defineProxyAttr(to, key, instance, type);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (from[key] !== prev[key]) {</span><span class="s2">\n            </span><span class="s1">changed = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (var key in to) {</span><span class="s2">\n        </span><span class="s1">if (!(key in from)) {</span><span class="s2">\n            </span><span class="s1">changed = true;</span><span class="s2">\n            </span><span class="s1">delete to[key];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return changed;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function defineProxyAttr(proxy, key, instance, type) {</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(proxy, key, {</span><span class="s2">\n        </span><span class="s1">enumerable: true,</span><span class="s2">\n        </span><span class="s1">configurable: true,</span><span class="s2">\n        </span><span class="s1">get: function () {</span><span class="s2">\n            </span><span class="s1">return instance[type][key];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initSlotsProxy(vm) {</span><span class="s2">\n    </span><span class="s1">if (!vm._slotsProxy) {</span><span class="s2">\n        </span><span class="s1">syncSetupSlots((vm._slotsProxy = {}), vm.$scopedSlots);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return vm._slotsProxy;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function syncSetupSlots(to, from) {</span><span class="s2">\n    </span><span class="s1">for (var key in from) {</span><span class="s2">\n        </span><span class="s1">to[key] = from[key];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (var key in to) {</span><span class="s2">\n        </span><span class="s1">if (!(key in from)) {</span><span class="s2">\n            </span><span class="s1">delete to[key];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal use manual type def because public setup context type relies on</span><span class="s2">\n </span><span class="s1">* legacy VNode types</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function useSlots() {</span><span class="s2">\n    </span><span class="s1">return getContext().slots;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal use manual type def because public setup context type relies on</span><span class="s2">\n </span><span class="s1">* legacy VNode types</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function useAttrs() {</span><span class="s2">\n    </span><span class="s1">return getContext().attrs;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Vue 2 only</span><span class="s2">\n </span><span class="s1">* @internal use manual type def because public setup context type relies on</span><span class="s2">\n </span><span class="s1">* legacy VNode types</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function useListeners() {</span><span class="s2">\n    </span><span class="s1">return getContext().listeners;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getContext() {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !currentInstance) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">useContext() called without active instance.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var vm = currentInstance;</span><span class="s2">\n    </span><span class="s1">return vm._setupContext || (vm._setupContext = createSetupContext(vm));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for merging default declarations. Imported by compiled code</span><span class="s2">\n </span><span class="s1">* only.</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function mergeDefaults(raw, defaults) {</span><span class="s2">\n    </span><span class="s1">var props = isArray(raw)</span><span class="s2">\n        </span><span class="s1">? raw.reduce(function (normalized, p) { return ((normalized[p] = {}), normalized); }, {})</span><span class="s2">\n        </span><span class="s1">: raw;</span><span class="s2">\n    </span><span class="s1">for (var key in defaults) {</span><span class="s2">\n        </span><span class="s1">var opt = props[key];</span><span class="s2">\n        </span><span class="s1">if (opt) {</span><span class="s2">\n            </span><span class="s1">if (isArray(opt) || isFunction(opt)) {</span><span class="s2">\n                </span><span class="s1">props[key] = { type: opt, default: defaults[key] };</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">opt.default = defaults[key];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (opt === null) {</span><span class="s2">\n            </span><span class="s1">props[key] = { default: defaults[key] };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">props default key </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">has no corresponding declaration.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return props;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function initRender(vm) {</span><span class="s2">\n    </span><span class="s1">vm._vnode = null; // the root of the child tree</span><span class="s2">\n    </span><span class="s1">vm._staticTrees = null; // v-once cached trees</span><span class="s2">\n    </span><span class="s1">var options = vm.$options;</span><span class="s2">\n    </span><span class="s1">var parentVnode = (vm.$vnode = options._parentVnode); // the placeholder node in parent tree</span><span class="s2">\n    </span><span class="s1">var renderContext = parentVnode &amp;&amp; parentVnode.context;</span><span class="s2">\n    </span><span class="s1">vm.$slots = resolveSlots(options._renderChildren, renderContext);</span><span class="s2">\n    </span><span class="s1">vm.$scopedSlots = parentVnode</span><span class="s2">\n        </span><span class="s1">? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots)</span><span class="s2">\n        </span><span class="s1">: emptyObject;</span><span class="s2">\n    </span><span class="s1">// bind the createElement fn to this instance</span><span class="s2">\n    </span><span class="s1">// so that we get proper render context inside it.</span><span class="s2">\n    </span><span class="s1">// args order: tag, data, children, normalizationType, alwaysNormalize</span><span class="s2">\n    </span><span class="s1">// internal version is used by render functions compiled from templates</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">vm._c = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, false); };</span><span class="s2">\n    </span><span class="s1">// normalization is always applied for the public version, used in</span><span class="s2">\n    </span><span class="s1">// user-written render functions.</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">vm.$createElement = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, true); };</span><span class="s2">\n    </span><span class="s1">// $attrs &amp; $listeners are exposed for easier HOC creation.</span><span class="s2">\n    </span><span class="s1">// they need to be reactive so that HOCs using them are always updated</span><span class="s2">\n    </span><span class="s1">var parentData = parentVnode &amp;&amp; parentVnode.data;</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">defineReactive(vm, '$attrs', (parentData &amp;&amp; parentData.attrs) || emptyObject, function () {</span><span class="s2">\n            </span><span class="s1">!isUpdatingChildComponent &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">$attrs is readonly.</span><span class="s2">\&quot;</span><span class="s1">, vm);</span><span class="s2">\n        </span><span class="s1">}, true);</span><span class="s2">\n        </span><span class="s1">defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {</span><span class="s2">\n            </span><span class="s1">!isUpdatingChildComponent &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">$listeners is readonly.</span><span class="s2">\&quot;</span><span class="s1">, vm);</span><span class="s2">\n        </span><span class="s1">}, true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">defineReactive(vm, '$attrs', (parentData &amp;&amp; parentData.attrs) || emptyObject, null, true);</span><span class="s2">\n        </span><span class="s1">defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var currentRenderingInstance = null;</span><span class="s2">\n</span><span class="s1">function renderMixin(Vue) {</span><span class="s2">\n    </span><span class="s1">// install runtime convenience helpers</span><span class="s2">\n    </span><span class="s1">installRenderHelpers(Vue.prototype);</span><span class="s2">\n    </span><span class="s1">Vue.prototype.$nextTick = function (fn) {</span><span class="s2">\n        </span><span class="s1">return nextTick(fn, this);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">Vue.prototype._render = function () {</span><span class="s2">\n        </span><span class="s1">var vm = this;</span><span class="s2">\n        </span><span class="s1">var _a = vm.$options, render = _a.render, _parentVnode = _a._parentVnode;</span><span class="s2">\n        </span><span class="s1">if (_parentVnode &amp;&amp; vm._isMounted) {</span><span class="s2">\n            </span><span class="s1">vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);</span><span class="s2">\n            </span><span class="s1">if (vm._slotsProxy) {</span><span class="s2">\n                </span><span class="s1">syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// set parent vnode. this allows render functions to have access</span><span class="s2">\n        </span><span class="s1">// to the data on the placeholder node.</span><span class="s2">\n        </span><span class="s1">vm.$vnode = _parentVnode;</span><span class="s2">\n        </span><span class="s1">// render self</span><span class="s2">\n        </span><span class="s1">var vnode;</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">// There's no need to maintain a stack because all render fns are called</span><span class="s2">\n            </span><span class="s1">// separately from one another. Nested component's render fns are called</span><span class="s2">\n            </span><span class="s1">// when parent component is patched.</span><span class="s2">\n            </span><span class="s1">setCurrentInstance(vm);</span><span class="s2">\n            </span><span class="s1">currentRenderingInstance = vm;</span><span class="s2">\n            </span><span class="s1">vnode = render.call(vm._renderProxy, vm.$createElement);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">catch (e) {</span><span class="s2">\n            </span><span class="s1">handleError(e, vm, </span><span class="s2">\&quot;</span><span class="s1">render</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">// return error render result,</span><span class="s2">\n            </span><span class="s1">// or previous vnode to prevent render error causing blank component</span><span class="s2">\n            </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n            </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; vm.$options.renderError) {</span><span class="s2">\n                </span><span class="s1">try {</span><span class="s2">\n                    </span><span class="s1">vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">catch (e) {</span><span class="s2">\n                    </span><span class="s1">handleError(e, vm, </span><span class="s2">\&quot;</span><span class="s1">renderError</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n                    </span><span class="s1">vnode = vm._vnode;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">vnode = vm._vnode;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">finally {</span><span class="s2">\n            </span><span class="s1">currentRenderingInstance = null;</span><span class="s2">\n            </span><span class="s1">setCurrentInstance();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// if the returned array contains only a single node, allow it</span><span class="s2">\n        </span><span class="s1">if (isArray(vnode) &amp;&amp; vnode.length === 1) {</span><span class="s2">\n            </span><span class="s1">vnode = vnode[0];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// return empty vnode in case the render function errored out</span><span class="s2">\n        </span><span class="s1">if (!(vnode instanceof VNode)) {</span><span class="s2">\n            </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; isArray(vnode)) {</span><span class="s2">\n                </span><span class="s1">warn('Multiple root nodes returned from render function. Render function ' +</span><span class="s2">\n                    </span><span class="s1">'should return a single root node.', vm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">vnode = createEmptyVNode();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// set parent</span><span class="s2">\n        </span><span class="s1">vnode.parent = _parentVnode;</span><span class="s2">\n        </span><span class="s1">return vnode;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function ensureCtor(comp, base) {</span><span class="s2">\n    </span><span class="s1">if (comp.__esModule || (hasSymbol &amp;&amp; comp[Symbol.toStringTag] === 'Module')) {</span><span class="s2">\n        </span><span class="s1">comp = comp.default;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return isObject(comp) ? base.extend(comp) : comp;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createAsyncPlaceholder(factory, data, context, children, tag) {</span><span class="s2">\n    </span><span class="s1">var node = createEmptyVNode();</span><span class="s2">\n    </span><span class="s1">node.asyncFactory = factory;</span><span class="s2">\n    </span><span class="s1">node.asyncMeta = { data: data, context: context, children: children, tag: tag };</span><span class="s2">\n    </span><span class="s1">return node;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveAsyncComponent(factory, baseCtor) {</span><span class="s2">\n    </span><span class="s1">if (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) {</span><span class="s2">\n        </span><span class="s1">return factory.errorComp;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isDef(factory.resolved)) {</span><span class="s2">\n        </span><span class="s1">return factory.resolved;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var owner = currentRenderingInstance;</span><span class="s2">\n    </span><span class="s1">if (owner &amp;&amp; isDef(factory.owners) &amp;&amp; factory.owners.indexOf(owner) === -1) {</span><span class="s2">\n        </span><span class="s1">// already pending</span><span class="s2">\n        </span><span class="s1">factory.owners.push(owner);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isTrue(factory.loading) &amp;&amp; isDef(factory.loadingComp)) {</span><span class="s2">\n        </span><span class="s1">return factory.loadingComp;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (owner &amp;&amp; !isDef(factory.owners)) {</span><span class="s2">\n        </span><span class="s1">var owners_1 = (factory.owners = [owner]);</span><span class="s2">\n        </span><span class="s1">var sync_1 = true;</span><span class="s2">\n        </span><span class="s1">var timerLoading_1 = null;</span><span class="s2">\n        </span><span class="s1">var timerTimeout_1 = null;</span><span class="s2">\n        </span><span class="s1">owner.$on('hook:destroyed', function () { return remove$2(owners_1, owner); });</span><span class="s2">\n        </span><span class="s1">var forceRender_1 = function (renderCompleted) {</span><span class="s2">\n            </span><span class="s1">for (var i = 0, l = owners_1.length; i &lt; l; i++) {</span><span class="s2">\n                </span><span class="s1">owners_1[i].$forceUpdate();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (renderCompleted) {</span><span class="s2">\n                </span><span class="s1">owners_1.length = 0;</span><span class="s2">\n                </span><span class="s1">if (timerLoading_1 !== null) {</span><span class="s2">\n                    </span><span class="s1">clearTimeout(timerLoading_1);</span><span class="s2">\n                    </span><span class="s1">timerLoading_1 = null;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (timerTimeout_1 !== null) {</span><span class="s2">\n                    </span><span class="s1">clearTimeout(timerTimeout_1);</span><span class="s2">\n                    </span><span class="s1">timerTimeout_1 = null;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">var resolve = once(function (res) {</span><span class="s2">\n            </span><span class="s1">// cache resolved</span><span class="s2">\n            </span><span class="s1">factory.resolved = ensureCtor(res, baseCtor);</span><span class="s2">\n            </span><span class="s1">// invoke callbacks only if this is not a synchronous resolve</span><span class="s2">\n            </span><span class="s1">// (async resolves are shimmed as synchronous during SSR)</span><span class="s2">\n            </span><span class="s1">if (!sync_1) {</span><span class="s2">\n                </span><span class="s1">forceRender_1(true);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">owners_1.length = 0;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">var reject_1 = once(function (reason) {</span><span class="s2">\n            </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Failed to resolve async component: </span><span class="s2">\&quot;</span><span class="s1">.concat(String(factory)) +</span><span class="s2">\n                    </span><span class="s1">(reason ? </span><span class="s2">\&quot;\\</span><span class="s1">nReason: </span><span class="s2">\&quot;</span><span class="s1">.concat(reason) : ''));</span><span class="s2">\n            </span><span class="s1">if (isDef(factory.errorComp)) {</span><span class="s2">\n                </span><span class="s1">factory.error = true;</span><span class="s2">\n                </span><span class="s1">forceRender_1(true);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">var res_1 = factory(resolve, reject_1);</span><span class="s2">\n        </span><span class="s1">if (isObject(res_1)) {</span><span class="s2">\n            </span><span class="s1">if (isPromise(res_1)) {</span><span class="s2">\n                </span><span class="s1">// () =&gt; Promise</span><span class="s2">\n                </span><span class="s1">if (isUndef(factory.resolved)) {</span><span class="s2">\n                    </span><span class="s1">res_1.then(resolve, reject_1);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (isPromise(res_1.component)) {</span><span class="s2">\n                </span><span class="s1">res_1.component.then(resolve, reject_1);</span><span class="s2">\n                </span><span class="s1">if (isDef(res_1.error)) {</span><span class="s2">\n                    </span><span class="s1">factory.errorComp = ensureCtor(res_1.error, baseCtor);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (isDef(res_1.loading)) {</span><span class="s2">\n                    </span><span class="s1">factory.loadingComp = ensureCtor(res_1.loading, baseCtor);</span><span class="s2">\n                    </span><span class="s1">if (res_1.delay === 0) {</span><span class="s2">\n                        </span><span class="s1">factory.loading = true;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">// @ts-expect-error NodeJS timeout type</span><span class="s2">\n                        </span><span class="s1">timerLoading_1 = setTimeout(function () {</span><span class="s2">\n                            </span><span class="s1">timerLoading_1 = null;</span><span class="s2">\n                            </span><span class="s1">if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) {</span><span class="s2">\n                                </span><span class="s1">factory.loading = true;</span><span class="s2">\n                                </span><span class="s1">forceRender_1(false);</span><span class="s2">\n                            </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">}, res_1.delay || 200);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (isDef(res_1.timeout)) {</span><span class="s2">\n                    </span><span class="s1">// @ts-expect-error NodeJS timeout type</span><span class="s2">\n                    </span><span class="s1">timerTimeout_1 = setTimeout(function () {</span><span class="s2">\n                        </span><span class="s1">timerTimeout_1 = null;</span><span class="s2">\n                        </span><span class="s1">if (isUndef(factory.resolved)) {</span><span class="s2">\n                            </span><span class="s1">reject_1(process.env.NODE_ENV !== 'production' ? </span><span class="s2">\&quot;</span><span class="s1">timeout (</span><span class="s2">\&quot;</span><span class="s1">.concat(res_1.timeout, </span><span class="s2">\&quot;</span><span class="s1">ms)</span><span class="s2">\&quot;</span><span class="s1">) : null);</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">}, res_1.timeout);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">sync_1 = false;</span><span class="s2">\n        </span><span class="s1">// return in case resolved synchronously</span><span class="s2">\n        </span><span class="s1">return factory.loading ? factory.loadingComp : factory.resolved;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function getFirstComponentChild(children) {</span><span class="s2">\n    </span><span class="s1">if (isArray(children)) {</span><span class="s2">\n        </span><span class="s1">for (var i = 0; i &lt; children.length; i++) {</span><span class="s2">\n            </span><span class="s1">var c = children[i];</span><span class="s2">\n            </span><span class="s1">if (isDef(c) &amp;&amp; (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {</span><span class="s2">\n                </span><span class="s1">return c;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var SIMPLE_NORMALIZE = 1;</span><span class="s2">\n</span><span class="s1">var ALWAYS_NORMALIZE = 2;</span><span class="s2">\n</span><span class="s1">// wrapper function for providing a more flexible interface</span><span class="s2">\n</span><span class="s1">// without getting yelled at by flow</span><span class="s2">\n</span><span class="s1">function createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {</span><span class="s2">\n    </span><span class="s1">if (isArray(data) || isPrimitive(data)) {</span><span class="s2">\n        </span><span class="s1">normalizationType = children;</span><span class="s2">\n        </span><span class="s1">children = data;</span><span class="s2">\n        </span><span class="s1">data = undefined;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isTrue(alwaysNormalize)) {</span><span class="s2">\n        </span><span class="s1">normalizationType = ALWAYS_NORMALIZE;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return _createElement(context, tag, data, children, normalizationType);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function _createElement(context, tag, data, children, normalizationType) {</span><span class="s2">\n    </span><span class="s1">if (isDef(data) &amp;&amp; isDef(data.__ob__)) {</span><span class="s2">\n        </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Avoid using observed data object as vnode data: </span><span class="s2">\&quot;</span><span class="s1">.concat(JSON.stringify(data), </span><span class="s2">\&quot;\\</span><span class="s1">n</span><span class="s2">\&quot;</span><span class="s1">) + 'Always create fresh vnode data objects in each render!', context);</span><span class="s2">\n        </span><span class="s1">return createEmptyVNode();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// object syntax in v-bind</span><span class="s2">\n    </span><span class="s1">if (isDef(data) &amp;&amp; isDef(data.is)) {</span><span class="s2">\n        </span><span class="s1">tag = data.is;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!tag) {</span><span class="s2">\n        </span><span class="s1">// in case of component :is set to falsy value</span><span class="s2">\n        </span><span class="s1">return createEmptyVNode();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// warn against non-primitive key</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key)) {</span><span class="s2">\n        </span><span class="s1">warn('Avoid using non-primitive value as key, ' +</span><span class="s2">\n            </span><span class="s1">'use string/number value instead.', context);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// support single function children as default scoped slot</span><span class="s2">\n    </span><span class="s1">if (isArray(children) &amp;&amp; isFunction(children[0])) {</span><span class="s2">\n        </span><span class="s1">data = data || {};</span><span class="s2">\n        </span><span class="s1">data.scopedSlots = { default: children[0] };</span><span class="s2">\n        </span><span class="s1">children.length = 0;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (normalizationType === ALWAYS_NORMALIZE) {</span><span class="s2">\n        </span><span class="s1">children = normalizeChildren(children);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (normalizationType === SIMPLE_NORMALIZE) {</span><span class="s2">\n        </span><span class="s1">children = simpleNormalizeChildren(children);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var vnode, ns;</span><span class="s2">\n    </span><span class="s1">if (typeof tag === 'string') {</span><span class="s2">\n        </span><span class="s1">var Ctor = void 0;</span><span class="s2">\n        </span><span class="s1">ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag);</span><span class="s2">\n        </span><span class="s1">if (config.isReservedTag(tag)) {</span><span class="s2">\n            </span><span class="s1">// platform built-in elements</span><span class="s2">\n            </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n                </span><span class="s1">isDef(data) &amp;&amp;</span><span class="s2">\n                </span><span class="s1">isDef(data.nativeOn) &amp;&amp;</span><span class="s2">\n                </span><span class="s1">data.tag !== 'component') {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">The .native modifier for v-on is only valid on components but it was used on &lt;</span><span class="s2">\&quot;</span><span class="s1">.concat(tag, </span><span class="s2">\&quot;</span><span class="s1">&gt;.</span><span class="s2">\&quot;</span><span class="s1">), context);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if ((!data || !data.pre) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">isDef((Ctor = resolveAsset(context.$options, 'components', tag)))) {</span><span class="s2">\n            </span><span class="s1">// component</span><span class="s2">\n            </span><span class="s1">vnode = createComponent(Ctor, data, context, children, tag);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// unknown or unlisted namespaced elements</span><span class="s2">\n            </span><span class="s1">// check at runtime because it may get assigned a namespace when its</span><span class="s2">\n            </span><span class="s1">// parent normalizes children</span><span class="s2">\n            </span><span class="s1">vnode = new VNode(tag, data, children, undefined, undefined, context);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// direct component options / constructor</span><span class="s2">\n        </span><span class="s1">vnode = createComponent(tag, data, context, children);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isArray(vnode)) {</span><span class="s2">\n        </span><span class="s1">return vnode;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isDef(vnode)) {</span><span class="s2">\n        </span><span class="s1">if (isDef(ns))</span><span class="s2">\n            </span><span class="s1">applyNS(vnode, ns);</span><span class="s2">\n        </span><span class="s1">if (isDef(data))</span><span class="s2">\n            </span><span class="s1">registerDeepBindings(data);</span><span class="s2">\n        </span><span class="s1">return vnode;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">return createEmptyVNode();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function applyNS(vnode, ns, force) {</span><span class="s2">\n    </span><span class="s1">vnode.ns = ns;</span><span class="s2">\n    </span><span class="s1">if (vnode.tag === 'foreignObject') {</span><span class="s2">\n        </span><span class="s1">// use default namespace inside foreignObject</span><span class="s2">\n        </span><span class="s1">ns = undefined;</span><span class="s2">\n        </span><span class="s1">force = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isDef(vnode.children)) {</span><span class="s2">\n        </span><span class="s1">for (var i = 0, l = vnode.children.length; i &lt; l; i++) {</span><span class="s2">\n            </span><span class="s1">var child = vnode.children[i];</span><span class="s2">\n            </span><span class="s1">if (isDef(child.tag) &amp;&amp;</span><span class="s2">\n                </span><span class="s1">(isUndef(child.ns) || (isTrue(force) &amp;&amp; child.tag !== 'svg'))) {</span><span class="s2">\n                </span><span class="s1">applyNS(child, ns, force);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// ref #5318</span><span class="s2">\n</span><span class="s1">// necessary to ensure parent re-render when deep bindings like :style and</span><span class="s2">\n</span><span class="s1">// :class are used on slot nodes</span><span class="s2">\n</span><span class="s1">function registerDeepBindings(data) {</span><span class="s2">\n    </span><span class="s1">if (isObject(data.style)) {</span><span class="s2">\n        </span><span class="s1">traverse(data.style);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isObject(data.class)) {</span><span class="s2">\n        </span><span class="s1">traverse(data.class);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal this function needs manual public type declaration because it relies</span><span class="s2">\n </span><span class="s1">* on previously manually authored types from Vue 2</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function h(type, props, children) {</span><span class="s2">\n    </span><span class="s1">if (!currentInstance) {</span><span class="s2">\n        </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">globally imported h() can only be invoked when there is an active </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                \&quot;</span><span class="s1">component instance, e.g. synchronously in a component's render or setup function.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return createElement$1(currentInstance, type, props, children, 2, true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function handleError(err, vm, info) {</span><span class="s2">\n    </span><span class="s1">// Deactivate deps tracking while processing error handler to avoid possible infinite rendering.</span><span class="s2">\n    </span><span class="s1">// See: https://github.com/vuejs/vuex/issues/1505</span><span class="s2">\n    </span><span class="s1">pushTarget();</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">if (vm) {</span><span class="s2">\n            </span><span class="s1">var cur = vm;</span><span class="s2">\n            </span><span class="s1">while ((cur = cur.$parent)) {</span><span class="s2">\n                </span><span class="s1">var hooks = cur.$options.errorCaptured;</span><span class="s2">\n                </span><span class="s1">if (hooks) {</span><span class="s2">\n                    </span><span class="s1">for (var i = 0; i &lt; hooks.length; i++) {</span><span class="s2">\n                        </span><span class="s1">try {</span><span class="s2">\n                            </span><span class="s1">var capture = hooks[i].call(cur, err, vm, info) === false;</span><span class="s2">\n                            </span><span class="s1">if (capture)</span><span class="s2">\n                                </span><span class="s1">return;</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">catch (e) {</span><span class="s2">\n                            </span><span class="s1">globalHandleError(e, cur, 'errorCaptured hook');</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">globalHandleError(err, vm, info);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">finally {</span><span class="s2">\n        </span><span class="s1">popTarget();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function invokeWithErrorHandling(handler, context, args, vm, info) {</span><span class="s2">\n    </span><span class="s1">var res;</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">res = args ? handler.apply(context, args) : handler.call(context);</span><span class="s2">\n        </span><span class="s1">if (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) {</span><span class="s2">\n            </span><span class="s1">res.catch(function (e) { return handleError(e, vm, info + </span><span class="s2">\&quot; </span><span class="s1">(Promise/async)</span><span class="s2">\&quot;</span><span class="s1">); });</span><span class="s2">\n            </span><span class="s1">res._handled = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">catch (e) {</span><span class="s2">\n        </span><span class="s1">handleError(e, vm, info);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function globalHandleError(err, vm, info) {</span><span class="s2">\n    </span><span class="s1">if (config.errorHandler) {</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">return config.errorHandler.call(null, err, vm, info);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">catch (e) {</span><span class="s2">\n            </span><span class="s1">// if the user intentionally throws the original error in the handler,</span><span class="s2">\n            </span><span class="s1">// do not log it twice</span><span class="s2">\n            </span><span class="s1">if (e !== err) {</span><span class="s2">\n                </span><span class="s1">logError(e, null, 'config.errorHandler');</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">logError(err, vm, info);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function logError(err, vm, info) {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Error in </span><span class="s2">\&quot;</span><span class="s1">.concat(info, </span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">).concat(err.toString(), </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">), vm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n    </span><span class="s1">if (inBrowser &amp;&amp; typeof console !== 'undefined') {</span><span class="s2">\n        </span><span class="s1">console.error(err);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">throw err;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/* globals MutationObserver */</span><span class="s2">\n</span><span class="s1">var isUsingMicroTask = false;</span><span class="s2">\n</span><span class="s1">var callbacks = [];</span><span class="s2">\n</span><span class="s1">var pending = false;</span><span class="s2">\n</span><span class="s1">function flushCallbacks() {</span><span class="s2">\n    </span><span class="s1">pending = false;</span><span class="s2">\n    </span><span class="s1">var copies = callbacks.slice(0);</span><span class="s2">\n    </span><span class="s1">callbacks.length = 0;</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; copies.length; i++) {</span><span class="s2">\n        </span><span class="s1">copies[i]();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// Here we have async deferring wrappers using microtasks.</span><span class="s2">\n</span><span class="s1">// In 2.5 we used (macro) tasks (in combination with microtasks).</span><span class="s2">\n</span><span class="s1">// However, it has subtle problems when state is changed right before repaint</span><span class="s2">\n</span><span class="s1">// (e.g. #6813, out-in transitions).</span><span class="s2">\n</span><span class="s1">// Also, using (macro) tasks in event handler would cause some weird behaviors</span><span class="s2">\n</span><span class="s1">// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).</span><span class="s2">\n</span><span class="s1">// So we now use microtasks everywhere, again.</span><span class="s2">\n</span><span class="s1">// A major drawback of this tradeoff is that there are some scenarios</span><span class="s2">\n</span><span class="s1">// where microtasks have too high a priority and fire in between supposedly</span><span class="s2">\n</span><span class="s1">// sequential events (e.g. #4521, #6690, which have workarounds)</span><span class="s2">\n</span><span class="s1">// or even between bubbling of the same event (#6566).</span><span class="s2">\n</span><span class="s1">var timerFunc;</span><span class="s2">\n</span><span class="s1">// The nextTick behavior leverages the microtask queue, which can be accessed</span><span class="s2">\n</span><span class="s1">// via either native Promise.then or MutationObserver.</span><span class="s2">\n</span><span class="s1">// MutationObserver has wider support, however it is seriously bugged in</span><span class="s2">\n</span><span class="s1">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span><span class="s2">\n</span><span class="s1">// completely stops working after triggering a few times... so, if native</span><span class="s2">\n</span><span class="s1">// Promise is available, we will use it:</span><span class="s2">\n</span><span class="s1">/* istanbul ignore next, $flow-disable-line */</span><span class="s2">\n</span><span class="s1">if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) {</span><span class="s2">\n    </span><span class="s1">var p_1 = Promise.resolve();</span><span class="s2">\n    </span><span class="s1">timerFunc = function () {</span><span class="s2">\n        </span><span class="s1">p_1.then(flushCallbacks);</span><span class="s2">\n        </span><span class="s1">// In problematic UIWebViews, Promise.then doesn't completely break, but</span><span class="s2">\n        </span><span class="s1">// it can get stuck in a weird state where callbacks are pushed into the</span><span class="s2">\n        </span><span class="s1">// microtask queue but the queue isn't being flushed, until the browser</span><span class="s2">\n        </span><span class="s1">// needs to do some other work, e.g. handle a timer. Therefore we can</span><span class="s2">\n        </span><span class="s1">// </span><span class="s2">\&quot;</span><span class="s1">force</span><span class="s2">\&quot; </span><span class="s1">the microtask queue to be flushed by adding an empty timer.</span><span class="s2">\n        </span><span class="s1">if (isIOS)</span><span class="s2">\n            </span><span class="s1">setTimeout(noop);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">isUsingMicroTask = true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">else if (!isIE &amp;&amp;</span><span class="s2">\n    </span><span class="s1">typeof MutationObserver !== 'undefined' &amp;&amp;</span><span class="s2">\n    </span><span class="s1">(isNative(MutationObserver) ||</span><span class="s2">\n        </span><span class="s1">// PhantomJS and iOS 7.x</span><span class="s2">\n        </span><span class="s1">MutationObserver.toString() === '[object MutationObserverConstructor]')) {</span><span class="s2">\n    </span><span class="s1">// Use MutationObserver where native Promise is not available,</span><span class="s2">\n    </span><span class="s1">// e.g. PhantomJS, iOS7, Android 4.4</span><span class="s2">\n    </span><span class="s1">// (#6466 MutationObserver is unreliable in IE11)</span><span class="s2">\n    </span><span class="s1">var counter_1 = 1;</span><span class="s2">\n    </span><span class="s1">var observer = new MutationObserver(flushCallbacks);</span><span class="s2">\n    </span><span class="s1">var textNode_1 = document.createTextNode(String(counter_1));</span><span class="s2">\n    </span><span class="s1">observer.observe(textNode_1, {</span><span class="s2">\n        </span><span class="s1">characterData: true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">timerFunc = function () {</span><span class="s2">\n        </span><span class="s1">counter_1 = (counter_1 + 1) % 2;</span><span class="s2">\n        </span><span class="s1">textNode_1.data = String(counter_1);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">isUsingMicroTask = true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">else if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) {</span><span class="s2">\n    </span><span class="s1">// Fallback to setImmediate.</span><span class="s2">\n    </span><span class="s1">// Technically it leverages the (macro) task queue,</span><span class="s2">\n    </span><span class="s1">// but it is still a better choice than setTimeout.</span><span class="s2">\n    </span><span class="s1">timerFunc = function () {</span><span class="s2">\n        </span><span class="s1">setImmediate(flushCallbacks);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">else {</span><span class="s2">\n    </span><span class="s1">// Fallback to setTimeout.</span><span class="s2">\n    </span><span class="s1">timerFunc = function () {</span><span class="s2">\n        </span><span class="s1">setTimeout(flushCallbacks, 0);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function nextTick(cb, ctx) {</span><span class="s2">\n    </span><span class="s1">var _resolve;</span><span class="s2">\n    </span><span class="s1">callbacks.push(function () {</span><span class="s2">\n        </span><span class="s1">if (cb) {</span><span class="s2">\n            </span><span class="s1">try {</span><span class="s2">\n                </span><span class="s1">cb.call(ctx);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">catch (e) {</span><span class="s2">\n                </span><span class="s1">handleError(e, ctx, 'nextTick');</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (_resolve) {</span><span class="s2">\n            </span><span class="s1">_resolve(ctx);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (!pending) {</span><span class="s2">\n        </span><span class="s1">pending = true;</span><span class="s2">\n        </span><span class="s1">timerFunc();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// $flow-disable-line</span><span class="s2">\n    </span><span class="s1">if (!cb &amp;&amp; typeof Promise !== 'undefined') {</span><span class="s2">\n        </span><span class="s1">return new Promise(function (resolve) {</span><span class="s2">\n            </span><span class="s1">_resolve = resolve;</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function useCssModule(name) {</span><span class="s2">\n    </span><span class="s1">if (name === void 0) { name = '$style'; }</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">if (!currentInstance) {</span><span class="s2">\n            </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(</span><span class="s2">\&quot;</span><span class="s1">useCssModule must be called inside setup()</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">return emptyObject;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var mod = currentInstance[name];</span><span class="s2">\n        </span><span class="s1">if (!mod) {</span><span class="s2">\n            </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Current instance does not have CSS module named </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n            </span><span class="s1">return emptyObject;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return mod;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for SFC's CSS variable injection feature.</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function useCssVars(getter) {</span><span class="s2">\n    </span><span class="s1">if (!inBrowser &amp;&amp; !false)</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">var instance = currentInstance;</span><span class="s2">\n    </span><span class="s1">if (!instance) {</span><span class="s2">\n        </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">useCssVars is called without current active component instance.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">watchPostEffect(function () {</span><span class="s2">\n        </span><span class="s1">var el = instance.$el;</span><span class="s2">\n        </span><span class="s1">var vars = getter(instance, instance._setupProxy);</span><span class="s2">\n        </span><span class="s1">if (el &amp;&amp; el.nodeType === 1) {</span><span class="s2">\n            </span><span class="s1">var style = el.style;</span><span class="s2">\n            </span><span class="s1">for (var key in vars) {</span><span class="s2">\n                </span><span class="s1">style.setProperty(</span><span class="s2">\&quot;</span><span class="s1">--</span><span class="s2">\&quot;</span><span class="s1">.concat(key), vars[key]);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* v3-compatible async component API.</span><span class="s2">\n </span><span class="s1">* @internal the type is manually declared in &lt;root&gt;/types/v3-define-async-component.d.ts</span><span class="s2">\n </span><span class="s1">* because it relies on existing manual types</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function defineAsyncComponent(source) {</span><span class="s2">\n    </span><span class="s1">if (isFunction(source)) {</span><span class="s2">\n        </span><span class="s1">source = { loader: source };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var loader = source.loader, loadingComponent = source.loadingComponent, errorComponent = source.errorComponent, _a = source.delay, delay = _a === void 0 ? 200 : _a, timeout = source.timeout, // undefined = never times out</span><span class="s2">\n    </span><span class="s1">_b = source.suspensible, // undefined = never times out</span><span class="s2">\n    </span><span class="s1">suspensible = _b === void 0 ? false : _b, // in Vue 3 default is true</span><span class="s2">\n    </span><span class="s1">userOnError = source.onError;</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; suspensible) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">The suspensiblbe option for async components is not supported in Vue2. It is ignored.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var pendingRequest = null;</span><span class="s2">\n    </span><span class="s1">var retries = 0;</span><span class="s2">\n    </span><span class="s1">var retry = function () {</span><span class="s2">\n        </span><span class="s1">retries++;</span><span class="s2">\n        </span><span class="s1">pendingRequest = null;</span><span class="s2">\n        </span><span class="s1">return load();</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var load = function () {</span><span class="s2">\n        </span><span class="s1">var thisRequest;</span><span class="s2">\n        </span><span class="s1">return (pendingRequest ||</span><span class="s2">\n            </span><span class="s1">(thisRequest = pendingRequest =</span><span class="s2">\n                </span><span class="s1">loader()</span><span class="s2">\n                    </span><span class="s1">.catch(function (err) {</span><span class="s2">\n                    </span><span class="s1">err = err instanceof Error ? err : new Error(String(err));</span><span class="s2">\n                    </span><span class="s1">if (userOnError) {</span><span class="s2">\n                        </span><span class="s1">return new Promise(function (resolve, reject) {</span><span class="s2">\n                            </span><span class="s1">var userRetry = function () { return resolve(retry()); };</span><span class="s2">\n                            </span><span class="s1">var userFail = function () { return reject(err); };</span><span class="s2">\n                            </span><span class="s1">userOnError(err, userRetry, userFail, retries + 1);</span><span class="s2">\n                        </span><span class="s1">});</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">throw err;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">})</span><span class="s2">\n                    </span><span class="s1">.then(function (comp) {</span><span class="s2">\n                    </span><span class="s1">if (thisRequest !== pendingRequest &amp;&amp; pendingRequest) {</span><span class="s2">\n                        </span><span class="s1">return pendingRequest;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !comp) {</span><span class="s2">\n                        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Async component loader resolved to undefined. </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                            \&quot;</span><span class="s1">If you are using retry(), make sure to return its return value.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">// interop module default</span><span class="s2">\n                    </span><span class="s1">if (comp &amp;&amp;</span><span class="s2">\n                        </span><span class="s1">(comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {</span><span class="s2">\n                        </span><span class="s1">comp = comp.default;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; comp &amp;&amp; !isObject(comp) &amp;&amp; !isFunction(comp)) {</span><span class="s2">\n                        </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">Invalid async component load result: </span><span class="s2">\&quot;</span><span class="s1">.concat(comp));</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">return comp;</span><span class="s2">\n                </span><span class="s1">})));</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return function () {</span><span class="s2">\n        </span><span class="s1">var component = load();</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n            </span><span class="s1">component: component,</span><span class="s2">\n            </span><span class="s1">delay: delay,</span><span class="s2">\n            </span><span class="s1">timeout: timeout,</span><span class="s2">\n            </span><span class="s1">error: errorComponent,</span><span class="s2">\n            </span><span class="s1">loading: loadingComponent</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function createLifeCycle(hookName) {</span><span class="s2">\n    </span><span class="s1">return function (fn, target) {</span><span class="s2">\n        </span><span class="s1">if (target === void 0) { target = currentInstance; }</span><span class="s2">\n        </span><span class="s1">if (!target) {</span><span class="s2">\n            </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(formatName(hookName), </span><span class="s2">\&quot; </span><span class="s1">is called when there is no active component instance to be </span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n                    \&quot;</span><span class="s1">associated with. </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                    \&quot;</span><span class="s1">Lifecycle injection APIs can only be used during execution of setup().</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return injectHook(target, hookName, fn);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function formatName(name) {</span><span class="s2">\n    </span><span class="s1">if (name === 'beforeDestroy') {</span><span class="s2">\n        </span><span class="s1">name = 'beforeUnmount';</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (name === 'destroyed') {</span><span class="s2">\n        </span><span class="s1">name = 'unmounted';</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return </span><span class="s2">\&quot;</span><span class="s1">on</span><span class="s2">\&quot;</span><span class="s1">.concat(name[0].toUpperCase() + name.slice(1));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function injectHook(instance, hookName, fn) {</span><span class="s2">\n    </span><span class="s1">var options = instance.$options;</span><span class="s2">\n    </span><span class="s1">options[hookName] = mergeLifecycleHook(options[hookName], fn);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var onBeforeMount = createLifeCycle('beforeMount');</span><span class="s2">\n</span><span class="s1">var onMounted = createLifeCycle('mounted');</span><span class="s2">\n</span><span class="s1">var onBeforeUpdate = createLifeCycle('beforeUpdate');</span><span class="s2">\n</span><span class="s1">var onUpdated = createLifeCycle('updated');</span><span class="s2">\n</span><span class="s1">var onBeforeUnmount = createLifeCycle('beforeDestroy');</span><span class="s2">\n</span><span class="s1">var onUnmounted = createLifeCycle('destroyed');</span><span class="s2">\n</span><span class="s1">var onActivated = createLifeCycle('activated');</span><span class="s2">\n</span><span class="s1">var onDeactivated = createLifeCycle('deactivated');</span><span class="s2">\n</span><span class="s1">var onServerPrefetch = createLifeCycle('serverPrefetch');</span><span class="s2">\n</span><span class="s1">var onRenderTracked = createLifeCycle('renderTracked');</span><span class="s2">\n</span><span class="s1">var onRenderTriggered = createLifeCycle('renderTriggered');</span><span class="s2">\n</span><span class="s1">var injectErrorCapturedHook = createLifeCycle('errorCaptured');</span><span class="s2">\n</span><span class="s1">function onErrorCaptured(hook, target) {</span><span class="s2">\n    </span><span class="s1">if (target === void 0) { target = currentInstance; }</span><span class="s2">\n    </span><span class="s1">injectErrorCapturedHook(hook, target);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Note: also update dist/vue.runtime.mjs when adding new exports to this file.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var version = '2.7.14';</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal type is manually declared in &lt;root&gt;/types/v3-define-component.d.ts</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function defineComponent(options) {</span><span class="s2">\n    </span><span class="s1">return options;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var seenObjects = new _Set();</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Recursively traverse an object to evoke all converted</span><span class="s2">\n </span><span class="s1">* getters, so that every nested property inside the object</span><span class="s2">\n </span><span class="s1">* is collected as a </span><span class="s2">\&quot;</span><span class="s1">deep</span><span class="s2">\&quot; </span><span class="s1">dependency.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function traverse(val) {</span><span class="s2">\n    </span><span class="s1">_traverse(val, seenObjects);</span><span class="s2">\n    </span><span class="s1">seenObjects.clear();</span><span class="s2">\n    </span><span class="s1">return val;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function _traverse(val, seen) {</span><span class="s2">\n    </span><span class="s1">var i, keys;</span><span class="s2">\n    </span><span class="s1">var isA = isArray(val);</span><span class="s2">\n    </span><span class="s1">if ((!isA &amp;&amp; !isObject(val)) ||</span><span class="s2">\n        </span><span class="s1">val.__v_skip /* ReactiveFlags.SKIP */ ||</span><span class="s2">\n        </span><span class="s1">Object.isFrozen(val) ||</span><span class="s2">\n        </span><span class="s1">val instanceof VNode) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (val.__ob__) {</span><span class="s2">\n        </span><span class="s1">var depId = val.__ob__.dep.id;</span><span class="s2">\n        </span><span class="s1">if (seen.has(depId)) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">seen.add(depId);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isA) {</span><span class="s2">\n        </span><span class="s1">i = val.length;</span><span class="s2">\n        </span><span class="s1">while (i--)</span><span class="s2">\n            </span><span class="s1">_traverse(val[i], seen);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isRef(val)) {</span><span class="s2">\n        </span><span class="s1">_traverse(val.value, seen);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">keys = Object.keys(val);</span><span class="s2">\n        </span><span class="s1">i = keys.length;</span><span class="s2">\n        </span><span class="s1">while (i--)</span><span class="s2">\n            </span><span class="s1">_traverse(val[keys[i]], seen);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var uid$1 = 0;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* A watcher parses an expression, collects dependencies,</span><span class="s2">\n </span><span class="s1">* and fires callback when the expression value changes.</span><span class="s2">\n </span><span class="s1">* This is used for both the $watch() api and directives.</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var Watcher = /** @class */ (function () {</span><span class="s2">\n    </span><span class="s1">function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {</span><span class="s2">\n        </span><span class="s1">recordEffectScope(this, </span><span class="s2">\n        </span><span class="s1">// if the active effect scope is manually created (not a component scope),</span><span class="s2">\n        </span><span class="s1">// prioritize it</span><span class="s2">\n        </span><span class="s1">activeEffectScope &amp;&amp; !activeEffectScope._vm</span><span class="s2">\n            </span><span class="s1">? activeEffectScope</span><span class="s2">\n            </span><span class="s1">: vm</span><span class="s2">\n                </span><span class="s1">? vm._scope</span><span class="s2">\n                </span><span class="s1">: undefined);</span><span class="s2">\n        </span><span class="s1">if ((this.vm = vm) &amp;&amp; isRenderWatcher) {</span><span class="s2">\n            </span><span class="s1">vm._watcher = this;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// options</span><span class="s2">\n        </span><span class="s1">if (options) {</span><span class="s2">\n            </span><span class="s1">this.deep = !!options.deep;</span><span class="s2">\n            </span><span class="s1">this.user = !!options.user;</span><span class="s2">\n            </span><span class="s1">this.lazy = !!options.lazy;</span><span class="s2">\n            </span><span class="s1">this.sync = !!options.sync;</span><span class="s2">\n            </span><span class="s1">this.before = options.before;</span><span class="s2">\n            </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n                </span><span class="s1">this.onTrack = options.onTrack;</span><span class="s2">\n                </span><span class="s1">this.onTrigger = options.onTrigger;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">this.deep = this.user = this.lazy = this.sync = false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.cb = cb;</span><span class="s2">\n        </span><span class="s1">this.id = ++uid$1; // uid for batching</span><span class="s2">\n        </span><span class="s1">this.active = true;</span><span class="s2">\n        </span><span class="s1">this.post = false;</span><span class="s2">\n        </span><span class="s1">this.dirty = this.lazy; // for lazy watchers</span><span class="s2">\n        </span><span class="s1">this.deps = [];</span><span class="s2">\n        </span><span class="s1">this.newDeps = [];</span><span class="s2">\n        </span><span class="s1">this.depIds = new _Set();</span><span class="s2">\n        </span><span class="s1">this.newDepIds = new _Set();</span><span class="s2">\n        </span><span class="s1">this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';</span><span class="s2">\n        </span><span class="s1">// parse expression for getter</span><span class="s2">\n        </span><span class="s1">if (isFunction(expOrFn)) {</span><span class="s2">\n            </span><span class="s1">this.getter = expOrFn;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">this.getter = parsePath(expOrFn);</span><span class="s2">\n            </span><span class="s1">if (!this.getter) {</span><span class="s2">\n                </span><span class="s1">this.getter = noop;</span><span class="s2">\n                </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Failed watching path: </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(expOrFn, </span><span class="s2">\&quot;\\\&quot; \&quot;</span><span class="s1">) +</span><span class="s2">\n                        </span><span class="s1">'Watcher only accepts simple dot-delimited paths. ' +</span><span class="s2">\n                        </span><span class="s1">'For full control, use a function instead.', vm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.value = this.lazy ? undefined : this.get();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Evaluate the getter, and re-collect dependencies.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">Watcher.prototype.get = function () {</span><span class="s2">\n        </span><span class="s1">pushTarget(this);</span><span class="s2">\n        </span><span class="s1">var value;</span><span class="s2">\n        </span><span class="s1">var vm = this.vm;</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">value = this.getter.call(vm, vm);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">catch (e) {</span><span class="s2">\n            </span><span class="s1">if (this.user) {</span><span class="s2">\n                </span><span class="s1">handleError(e, vm, </span><span class="s2">\&quot;</span><span class="s1">getter for watcher </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(this.expression, </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">));</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">throw e;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">finally {</span><span class="s2">\n            </span><span class="s1">// </span><span class="s2">\&quot;</span><span class="s1">touch</span><span class="s2">\&quot; </span><span class="s1">every property so they are all tracked as</span><span class="s2">\n            </span><span class="s1">// dependencies for deep watching</span><span class="s2">\n            </span><span class="s1">if (this.deep) {</span><span class="s2">\n                </span><span class="s1">traverse(value);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">popTarget();</span><span class="s2">\n            </span><span class="s1">this.cleanupDeps();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return value;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Add a dependency to this directive.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">Watcher.prototype.addDep = function (dep) {</span><span class="s2">\n        </span><span class="s1">var id = dep.id;</span><span class="s2">\n        </span><span class="s1">if (!this.newDepIds.has(id)) {</span><span class="s2">\n            </span><span class="s1">this.newDepIds.add(id);</span><span class="s2">\n            </span><span class="s1">this.newDeps.push(dep);</span><span class="s2">\n            </span><span class="s1">if (!this.depIds.has(id)) {</span><span class="s2">\n                </span><span class="s1">dep.addSub(this);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Clean up for dependency collection.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">Watcher.prototype.cleanupDeps = function () {</span><span class="s2">\n        </span><span class="s1">var i = this.deps.length;</span><span class="s2">\n        </span><span class="s1">while (i--) {</span><span class="s2">\n            </span><span class="s1">var dep = this.deps[i];</span><span class="s2">\n            </span><span class="s1">if (!this.newDepIds.has(dep.id)) {</span><span class="s2">\n                </span><span class="s1">dep.removeSub(this);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var tmp = this.depIds;</span><span class="s2">\n        </span><span class="s1">this.depIds = this.newDepIds;</span><span class="s2">\n        </span><span class="s1">this.newDepIds = tmp;</span><span class="s2">\n        </span><span class="s1">this.newDepIds.clear();</span><span class="s2">\n        </span><span class="s1">tmp = this.deps;</span><span class="s2">\n        </span><span class="s1">this.deps = this.newDeps;</span><span class="s2">\n        </span><span class="s1">this.newDeps = tmp;</span><span class="s2">\n        </span><span class="s1">this.newDeps.length = 0;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Subscriber interface.</span><span class="s2">\n     </span><span class="s1">* Will be called when a dependency changes.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">Watcher.prototype.update = function () {</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n        </span><span class="s1">if (this.lazy) {</span><span class="s2">\n            </span><span class="s1">this.dirty = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (this.sync) {</span><span class="s2">\n            </span><span class="s1">this.run();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">queueWatcher(this);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Scheduler job interface.</span><span class="s2">\n     </span><span class="s1">* Will be called by the scheduler.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">Watcher.prototype.run = function () {</span><span class="s2">\n        </span><span class="s1">if (this.active) {</span><span class="s2">\n            </span><span class="s1">var value = this.get();</span><span class="s2">\n            </span><span class="s1">if (value !== this.value ||</span><span class="s2">\n                </span><span class="s1">// Deep watchers and watchers on Object/Arrays should fire even</span><span class="s2">\n                </span><span class="s1">// when the value is the same, because the value may</span><span class="s2">\n                </span><span class="s1">// have mutated.</span><span class="s2">\n                </span><span class="s1">isObject(value) ||</span><span class="s2">\n                </span><span class="s1">this.deep) {</span><span class="s2">\n                </span><span class="s1">// set new value</span><span class="s2">\n                </span><span class="s1">var oldValue = this.value;</span><span class="s2">\n                </span><span class="s1">this.value = value;</span><span class="s2">\n                </span><span class="s1">if (this.user) {</span><span class="s2">\n                    </span><span class="s1">var info = </span><span class="s2">\&quot;</span><span class="s1">callback for watcher </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(this.expression, </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n                    </span><span class="s1">invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">this.cb.call(this.vm, value, oldValue);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Evaluate the value of the watcher.</span><span class="s2">\n     </span><span class="s1">* This only gets called for lazy watchers.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">Watcher.prototype.evaluate = function () {</span><span class="s2">\n        </span><span class="s1">this.value = this.get();</span><span class="s2">\n        </span><span class="s1">this.dirty = false;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Depend on all deps collected by this watcher.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">Watcher.prototype.depend = function () {</span><span class="s2">\n        </span><span class="s1">var i = this.deps.length;</span><span class="s2">\n        </span><span class="s1">while (i--) {</span><span class="s2">\n            </span><span class="s1">this.deps[i].depend();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Remove self from all dependencies' subscriber list.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">Watcher.prototype.teardown = function () {</span><span class="s2">\n        </span><span class="s1">if (this.vm &amp;&amp; !this.vm._isBeingDestroyed) {</span><span class="s2">\n            </span><span class="s1">remove$2(this.vm._scope.effects, this);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (this.active) {</span><span class="s2">\n            </span><span class="s1">var i = this.deps.length;</span><span class="s2">\n            </span><span class="s1">while (i--) {</span><span class="s2">\n                </span><span class="s1">this.deps[i].removeSub(this);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">this.active = false;</span><span class="s2">\n            </span><span class="s1">if (this.onStop) {</span><span class="s2">\n                </span><span class="s1">this.onStop();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return Watcher;</span><span class="s2">\n</span><span class="s1">}());</span><span class="s2">\n\n</span><span class="s1">var mark;</span><span class="s2">\n</span><span class="s1">var measure;</span><span class="s2">\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">var perf_1 = inBrowser &amp;&amp; window.performance;</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (perf_1 &amp;&amp;</span><span class="s2">\n        </span><span class="s1">// @ts-ignore</span><span class="s2">\n        </span><span class="s1">perf_1.mark &amp;&amp;</span><span class="s2">\n        </span><span class="s1">// @ts-ignore</span><span class="s2">\n        </span><span class="s1">perf_1.measure &amp;&amp;</span><span class="s2">\n        </span><span class="s1">// @ts-ignore</span><span class="s2">\n        </span><span class="s1">perf_1.clearMarks &amp;&amp;</span><span class="s2">\n        </span><span class="s1">// @ts-ignore</span><span class="s2">\n        </span><span class="s1">perf_1.clearMeasures) {</span><span class="s2">\n        </span><span class="s1">mark = function (tag) { return perf_1.mark(tag); };</span><span class="s2">\n        </span><span class="s1">measure = function (name, startTag, endTag) {</span><span class="s2">\n            </span><span class="s1">perf_1.measure(name, startTag, endTag);</span><span class="s2">\n            </span><span class="s1">perf_1.clearMarks(startTag);</span><span class="s2">\n            </span><span class="s1">perf_1.clearMarks(endTag);</span><span class="s2">\n            </span><span class="s1">// perf.clearMeasures(name)</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function initEvents(vm) {</span><span class="s2">\n    </span><span class="s1">vm._events = Object.create(null);</span><span class="s2">\n    </span><span class="s1">vm._hasHookEvent = false;</span><span class="s2">\n    </span><span class="s1">// init parent attached events</span><span class="s2">\n    </span><span class="s1">var listeners = vm.$options._parentListeners;</span><span class="s2">\n    </span><span class="s1">if (listeners) {</span><span class="s2">\n        </span><span class="s1">updateComponentListeners(vm, listeners);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var target$1;</span><span class="s2">\n</span><span class="s1">function add$1(event, fn) {</span><span class="s2">\n    </span><span class="s1">target$1.$on(event, fn);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function remove$1(event, fn) {</span><span class="s2">\n    </span><span class="s1">target$1.$off(event, fn);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createOnceHandler$1(event, fn) {</span><span class="s2">\n    </span><span class="s1">var _target = target$1;</span><span class="s2">\n    </span><span class="s1">return function onceHandler() {</span><span class="s2">\n        </span><span class="s1">var res = fn.apply(null, arguments);</span><span class="s2">\n        </span><span class="s1">if (res !== null) {</span><span class="s2">\n            </span><span class="s1">_target.$off(event, onceHandler);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function updateComponentListeners(vm, listeners, oldListeners) {</span><span class="s2">\n    </span><span class="s1">target$1 = vm;</span><span class="s2">\n    </span><span class="s1">updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);</span><span class="s2">\n    </span><span class="s1">target$1 = undefined;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function eventsMixin(Vue) {</span><span class="s2">\n    </span><span class="s1">var hookRE = /^hook:/;</span><span class="s2">\n    </span><span class="s1">Vue.prototype.$on = function (event, fn) {</span><span class="s2">\n        </span><span class="s1">var vm = this;</span><span class="s2">\n        </span><span class="s1">if (isArray(event)) {</span><span class="s2">\n            </span><span class="s1">for (var i = 0, l = event.length; i &lt; l; i++) {</span><span class="s2">\n                </span><span class="s1">vm.$on(event[i], fn);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">(vm._events[event] || (vm._events[event] = [])).push(fn);</span><span class="s2">\n            </span><span class="s1">// optimize hook:event cost by using a boolean flag marked at registration</span><span class="s2">\n            </span><span class="s1">// instead of a hash lookup</span><span class="s2">\n            </span><span class="s1">if (hookRE.test(event)) {</span><span class="s2">\n                </span><span class="s1">vm._hasHookEvent = true;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return vm;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">Vue.prototype.$once = function (event, fn) {</span><span class="s2">\n        </span><span class="s1">var vm = this;</span><span class="s2">\n        </span><span class="s1">function on() {</span><span class="s2">\n            </span><span class="s1">vm.$off(event, on);</span><span class="s2">\n            </span><span class="s1">fn.apply(vm, arguments);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">on.fn = fn;</span><span class="s2">\n        </span><span class="s1">vm.$on(event, on);</span><span class="s2">\n        </span><span class="s1">return vm;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">Vue.prototype.$off = function (event, fn) {</span><span class="s2">\n        </span><span class="s1">var vm = this;</span><span class="s2">\n        </span><span class="s1">// all</span><span class="s2">\n        </span><span class="s1">if (!arguments.length) {</span><span class="s2">\n            </span><span class="s1">vm._events = Object.create(null);</span><span class="s2">\n            </span><span class="s1">return vm;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// array of events</span><span class="s2">\n        </span><span class="s1">if (isArray(event)) {</span><span class="s2">\n            </span><span class="s1">for (var i_1 = 0, l = event.length; i_1 &lt; l; i_1++) {</span><span class="s2">\n                </span><span class="s1">vm.$off(event[i_1], fn);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return vm;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// specific event</span><span class="s2">\n        </span><span class="s1">var cbs = vm._events[event];</span><span class="s2">\n        </span><span class="s1">if (!cbs) {</span><span class="s2">\n            </span><span class="s1">return vm;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (!fn) {</span><span class="s2">\n            </span><span class="s1">vm._events[event] = null;</span><span class="s2">\n            </span><span class="s1">return vm;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// specific handler</span><span class="s2">\n        </span><span class="s1">var cb;</span><span class="s2">\n        </span><span class="s1">var i = cbs.length;</span><span class="s2">\n        </span><span class="s1">while (i--) {</span><span class="s2">\n            </span><span class="s1">cb = cbs[i];</span><span class="s2">\n            </span><span class="s1">if (cb === fn || cb.fn === fn) {</span><span class="s2">\n                </span><span class="s1">cbs.splice(i, 1);</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return vm;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">Vue.prototype.$emit = function (event) {</span><span class="s2">\n        </span><span class="s1">var vm = this;</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">var lowerCaseEvent = event.toLowerCase();</span><span class="s2">\n            </span><span class="s1">if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) {</span><span class="s2">\n                </span><span class="s1">tip(</span><span class="s2">\&quot;</span><span class="s1">Event </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(lowerCaseEvent, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is emitted in component </span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n                    \&quot;\&quot;</span><span class="s1">.concat(formatComponentName(vm), </span><span class="s2">\&quot; </span><span class="s1">but the handler is registered for </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">).concat(event, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">. </span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n                    \&quot;</span><span class="s1">Note that HTML attributes are case-insensitive and you cannot use </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                    \&quot;</span><span class="s1">v-on to listen to camelCase events when using in-DOM templates. </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                    \&quot;</span><span class="s1">You should probably use </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(hyphenate(event), </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">instead of </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">).concat(event, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var cbs = vm._events[event];</span><span class="s2">\n        </span><span class="s1">if (cbs) {</span><span class="s2">\n            </span><span class="s1">cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs;</span><span class="s2">\n            </span><span class="s1">var args = toArray(arguments, 1);</span><span class="s2">\n            </span><span class="s1">var info = </span><span class="s2">\&quot;</span><span class="s1">event handler for </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(event, </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">for (var i = 0, l = cbs.length; i &lt; l; i++) {</span><span class="s2">\n                </span><span class="s1">invokeWithErrorHandling(cbs[i], vm, args, vm, info);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return vm;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var activeInstance = null;</span><span class="s2">\n</span><span class="s1">var isUpdatingChildComponent = false;</span><span class="s2">\n</span><span class="s1">function setActiveInstance(vm) {</span><span class="s2">\n    </span><span class="s1">var prevActiveInstance = activeInstance;</span><span class="s2">\n    </span><span class="s1">activeInstance = vm;</span><span class="s2">\n    </span><span class="s1">return function () {</span><span class="s2">\n        </span><span class="s1">activeInstance = prevActiveInstance;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initLifecycle(vm) {</span><span class="s2">\n    </span><span class="s1">var options = vm.$options;</span><span class="s2">\n    </span><span class="s1">// locate first non-abstract parent</span><span class="s2">\n    </span><span class="s1">var parent = options.parent;</span><span class="s2">\n    </span><span class="s1">if (parent &amp;&amp; !options.abstract) {</span><span class="s2">\n        </span><span class="s1">while (parent.$options.abstract &amp;&amp; parent.$parent) {</span><span class="s2">\n            </span><span class="s1">parent = parent.$parent;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">parent.$children.push(vm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">vm.$parent = parent;</span><span class="s2">\n    </span><span class="s1">vm.$root = parent ? parent.$root : vm;</span><span class="s2">\n    </span><span class="s1">vm.$children = [];</span><span class="s2">\n    </span><span class="s1">vm.$refs = {};</span><span class="s2">\n    </span><span class="s1">vm._provided = parent ? parent._provided : Object.create(null);</span><span class="s2">\n    </span><span class="s1">vm._watcher = null;</span><span class="s2">\n    </span><span class="s1">vm._inactive = null;</span><span class="s2">\n    </span><span class="s1">vm._directInactive = false;</span><span class="s2">\n    </span><span class="s1">vm._isMounted = false;</span><span class="s2">\n    </span><span class="s1">vm._isDestroyed = false;</span><span class="s2">\n    </span><span class="s1">vm._isBeingDestroyed = false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function lifecycleMixin(Vue) {</span><span class="s2">\n    </span><span class="s1">Vue.prototype._update = function (vnode, hydrating) {</span><span class="s2">\n        </span><span class="s1">var vm = this;</span><span class="s2">\n        </span><span class="s1">var prevEl = vm.$el;</span><span class="s2">\n        </span><span class="s1">var prevVnode = vm._vnode;</span><span class="s2">\n        </span><span class="s1">var restoreActiveInstance = setActiveInstance(vm);</span><span class="s2">\n        </span><span class="s1">vm._vnode = vnode;</span><span class="s2">\n        </span><span class="s1">// Vue.prototype.__patch__ is injected in entry points</span><span class="s2">\n        </span><span class="s1">// based on the rendering backend used.</span><span class="s2">\n        </span><span class="s1">if (!prevVnode) {</span><span class="s2">\n            </span><span class="s1">// initial render</span><span class="s2">\n            </span><span class="s1">vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// updates</span><span class="s2">\n            </span><span class="s1">vm.$el = vm.__patch__(prevVnode, vnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">restoreActiveInstance();</span><span class="s2">\n        </span><span class="s1">// update __vue__ reference</span><span class="s2">\n        </span><span class="s1">if (prevEl) {</span><span class="s2">\n            </span><span class="s1">prevEl.__vue__ = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (vm.$el) {</span><span class="s2">\n            </span><span class="s1">vm.$el.__vue__ = vm;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// if parent is an HOC, update its $el as well</span><span class="s2">\n        </span><span class="s1">var wrapper = vm;</span><span class="s2">\n        </span><span class="s1">while (wrapper &amp;&amp;</span><span class="s2">\n            </span><span class="s1">wrapper.$vnode &amp;&amp;</span><span class="s2">\n            </span><span class="s1">wrapper.$parent &amp;&amp;</span><span class="s2">\n            </span><span class="s1">wrapper.$vnode === wrapper.$parent._vnode) {</span><span class="s2">\n            </span><span class="s1">wrapper.$parent.$el = wrapper.$el;</span><span class="s2">\n            </span><span class="s1">wrapper = wrapper.$parent;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// updated hook is called by the scheduler to ensure that children are</span><span class="s2">\n        </span><span class="s1">// updated in a parent's updated hook.</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">Vue.prototype.$forceUpdate = function () {</span><span class="s2">\n        </span><span class="s1">var vm = this;</span><span class="s2">\n        </span><span class="s1">if (vm._watcher) {</span><span class="s2">\n            </span><span class="s1">vm._watcher.update();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">Vue.prototype.$destroy = function () {</span><span class="s2">\n        </span><span class="s1">var vm = this;</span><span class="s2">\n        </span><span class="s1">if (vm._isBeingDestroyed) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">callHook$1(vm, 'beforeDestroy');</span><span class="s2">\n        </span><span class="s1">vm._isBeingDestroyed = true;</span><span class="s2">\n        </span><span class="s1">// remove self from parent</span><span class="s2">\n        </span><span class="s1">var parent = vm.$parent;</span><span class="s2">\n        </span><span class="s1">if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) {</span><span class="s2">\n            </span><span class="s1">remove$2(parent.$children, vm);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// teardown scope. this includes both the render watcher and other</span><span class="s2">\n        </span><span class="s1">// watchers created</span><span class="s2">\n        </span><span class="s1">vm._scope.stop();</span><span class="s2">\n        </span><span class="s1">// remove reference from data ob</span><span class="s2">\n        </span><span class="s1">// frozen object may not have observer.</span><span class="s2">\n        </span><span class="s1">if (vm._data.__ob__) {</span><span class="s2">\n            </span><span class="s1">vm._data.__ob__.vmCount--;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// call the last hook...</span><span class="s2">\n        </span><span class="s1">vm._isDestroyed = true;</span><span class="s2">\n        </span><span class="s1">// invoke destroy hooks on current rendered tree</span><span class="s2">\n        </span><span class="s1">vm.__patch__(vm._vnode, null);</span><span class="s2">\n        </span><span class="s1">// fire destroyed hook</span><span class="s2">\n        </span><span class="s1">callHook$1(vm, 'destroyed');</span><span class="s2">\n        </span><span class="s1">// turn off all instance listeners.</span><span class="s2">\n        </span><span class="s1">vm.$off();</span><span class="s2">\n        </span><span class="s1">// remove __vue__ reference</span><span class="s2">\n        </span><span class="s1">if (vm.$el) {</span><span class="s2">\n            </span><span class="s1">vm.$el.__vue__ = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// release circular reference (#6759)</span><span class="s2">\n        </span><span class="s1">if (vm.$vnode) {</span><span class="s2">\n            </span><span class="s1">vm.$vnode.parent = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mountComponent(vm, el, hydrating) {</span><span class="s2">\n    </span><span class="s1">vm.$el = el;</span><span class="s2">\n    </span><span class="s1">if (!vm.$options.render) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error invalid type</span><span class="s2">\n        </span><span class="s1">vm.$options.render = createEmptyVNode;</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n            </span><span class="s1">if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== '#') ||</span><span class="s2">\n                </span><span class="s1">vm.$options.el ||</span><span class="s2">\n                </span><span class="s1">el) {</span><span class="s2">\n                </span><span class="s1">warn('You are using the runtime-only build of Vue where the template ' +</span><span class="s2">\n                    </span><span class="s1">'compiler is not available. Either pre-compile the templates into ' +</span><span class="s2">\n                    </span><span class="s1">'render functions, or use the compiler-included build.', vm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">warn('Failed to mount component: template or render function not defined.', vm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">callHook$1(vm, 'beforeMount');</span><span class="s2">\n    </span><span class="s1">var updateComponent;</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {</span><span class="s2">\n        </span><span class="s1">updateComponent = function () {</span><span class="s2">\n            </span><span class="s1">var name = vm._name;</span><span class="s2">\n            </span><span class="s1">var id = vm._uid;</span><span class="s2">\n            </span><span class="s1">var startTag = </span><span class="s2">\&quot;</span><span class="s1">vue-perf-start:</span><span class="s2">\&quot;</span><span class="s1">.concat(id);</span><span class="s2">\n            </span><span class="s1">var endTag = </span><span class="s2">\&quot;</span><span class="s1">vue-perf-end:</span><span class="s2">\&quot;</span><span class="s1">.concat(id);</span><span class="s2">\n            </span><span class="s1">mark(startTag);</span><span class="s2">\n            </span><span class="s1">var vnode = vm._render();</span><span class="s2">\n            </span><span class="s1">mark(endTag);</span><span class="s2">\n            </span><span class="s1">measure(</span><span class="s2">\&quot;</span><span class="s1">vue </span><span class="s2">\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot; </span><span class="s1">render</span><span class="s2">\&quot;</span><span class="s1">), startTag, endTag);</span><span class="s2">\n            </span><span class="s1">mark(startTag);</span><span class="s2">\n            </span><span class="s1">vm._update(vnode, hydrating);</span><span class="s2">\n            </span><span class="s1">mark(endTag);</span><span class="s2">\n            </span><span class="s1">measure(</span><span class="s2">\&quot;</span><span class="s1">vue </span><span class="s2">\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot; </span><span class="s1">patch</span><span class="s2">\&quot;</span><span class="s1">), startTag, endTag);</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">updateComponent = function () {</span><span class="s2">\n            </span><span class="s1">vm._update(vm._render(), hydrating);</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var watcherOptions = {</span><span class="s2">\n        </span><span class="s1">before: function () {</span><span class="s2">\n            </span><span class="s1">if (vm._isMounted &amp;&amp; !vm._isDestroyed) {</span><span class="s2">\n                </span><span class="s1">callHook$1(vm, 'beforeUpdate');</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">watcherOptions.onTrack = function (e) { return callHook$1(vm, 'renderTracked', [e]); };</span><span class="s2">\n        </span><span class="s1">watcherOptions.onTrigger = function (e) { return callHook$1(vm, 'renderTriggered', [e]); };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// we set this to vm._watcher inside the watcher's constructor</span><span class="s2">\n    </span><span class="s1">// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span><span class="s2">\n    </span><span class="s1">// component's mounted hook), which relies on vm._watcher being already defined</span><span class="s2">\n    </span><span class="s1">new Watcher(vm, updateComponent, noop, watcherOptions, true /* isRenderWatcher */);</span><span class="s2">\n    </span><span class="s1">hydrating = false;</span><span class="s2">\n    </span><span class="s1">// flush buffer for flush: </span><span class="s2">\&quot;</span><span class="s1">pre</span><span class="s2">\&quot; </span><span class="s1">watchers queued in setup()</span><span class="s2">\n    </span><span class="s1">var preWatchers = vm._preWatchers;</span><span class="s2">\n    </span><span class="s1">if (preWatchers) {</span><span class="s2">\n        </span><span class="s1">for (var i = 0; i &lt; preWatchers.length; i++) {</span><span class="s2">\n            </span><span class="s1">preWatchers[i].run();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// manually mounted instance, call mounted on self</span><span class="s2">\n    </span><span class="s1">// mounted is called for render-created child components in its inserted hook</span><span class="s2">\n    </span><span class="s1">if (vm.$vnode == null) {</span><span class="s2">\n        </span><span class="s1">vm._isMounted = true;</span><span class="s2">\n        </span><span class="s1">callHook$1(vm, 'mounted');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return vm;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">isUpdatingChildComponent = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// determine whether component has slot children</span><span class="s2">\n    </span><span class="s1">// we need to do this before overwriting $options._renderChildren.</span><span class="s2">\n    </span><span class="s1">// check if there are dynamic scopedSlots (hand-written or compiled but with</span><span class="s2">\n    </span><span class="s1">// dynamic slot names). Static scoped slots compiled from template has the</span><span class="s2">\n    </span><span class="s1">// </span><span class="s2">\&quot;</span><span class="s1">$stable</span><span class="s2">\&quot; </span><span class="s1">marker.</span><span class="s2">\n    </span><span class="s1">var newScopedSlots = parentVnode.data.scopedSlots;</span><span class="s2">\n    </span><span class="s1">var oldScopedSlots = vm.$scopedSlots;</span><span class="s2">\n    </span><span class="s1">var hasDynamicScopedSlot = !!((newScopedSlots &amp;&amp; !newScopedSlots.$stable) ||</span><span class="s2">\n        </span><span class="s1">(oldScopedSlots !== emptyObject &amp;&amp; !oldScopedSlots.$stable) ||</span><span class="s2">\n        </span><span class="s1">(newScopedSlots &amp;&amp; vm.$scopedSlots.$key !== newScopedSlots.$key) ||</span><span class="s2">\n        </span><span class="s1">(!newScopedSlots &amp;&amp; vm.$scopedSlots.$key));</span><span class="s2">\n    </span><span class="s1">// Any static slot children from the parent may have changed during parent's</span><span class="s2">\n    </span><span class="s1">// update. Dynamic scoped slots may also have changed. In such cases, a forced</span><span class="s2">\n    </span><span class="s1">// update is necessary to ensure correctness.</span><span class="s2">\n    </span><span class="s1">var needsForceUpdate = !!(renderChildren || // has new static slots</span><span class="s2">\n        </span><span class="s1">vm.$options._renderChildren || // has old static slots</span><span class="s2">\n        </span><span class="s1">hasDynamicScopedSlot);</span><span class="s2">\n    </span><span class="s1">var prevVNode = vm.$vnode;</span><span class="s2">\n    </span><span class="s1">vm.$options._parentVnode = parentVnode;</span><span class="s2">\n    </span><span class="s1">vm.$vnode = parentVnode; // update vm's placeholder node without re-render</span><span class="s2">\n    </span><span class="s1">if (vm._vnode) {</span><span class="s2">\n        </span><span class="s1">// update child tree's parent</span><span class="s2">\n        </span><span class="s1">vm._vnode.parent = parentVnode;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">vm.$options._renderChildren = renderChildren;</span><span class="s2">\n    </span><span class="s1">// update $attrs and $listeners hash</span><span class="s2">\n    </span><span class="s1">// these are also reactive so they may trigger child update if the child</span><span class="s2">\n    </span><span class="s1">// used them during render</span><span class="s2">\n    </span><span class="s1">var attrs = parentVnode.data.attrs || emptyObject;</span><span class="s2">\n    </span><span class="s1">if (vm._attrsProxy) {</span><span class="s2">\n        </span><span class="s1">// force update if attrs are accessed and has changed since it may be</span><span class="s2">\n        </span><span class="s1">// passed to a child component.</span><span class="s2">\n        </span><span class="s1">if (syncSetupProxy(vm._attrsProxy, attrs, (prevVNode.data &amp;&amp; prevVNode.data.attrs) || emptyObject, vm, '$attrs')) {</span><span class="s2">\n            </span><span class="s1">needsForceUpdate = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">vm.$attrs = attrs;</span><span class="s2">\n    </span><span class="s1">// update listeners</span><span class="s2">\n    </span><span class="s1">listeners = listeners || emptyObject;</span><span class="s2">\n    </span><span class="s1">var prevListeners = vm.$options._parentListeners;</span><span class="s2">\n    </span><span class="s1">if (vm._listenersProxy) {</span><span class="s2">\n        </span><span class="s1">syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, '$listeners');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">vm.$listeners = vm.$options._parentListeners = listeners;</span><span class="s2">\n    </span><span class="s1">updateComponentListeners(vm, listeners, prevListeners);</span><span class="s2">\n    </span><span class="s1">// update props</span><span class="s2">\n    </span><span class="s1">if (propsData &amp;&amp; vm.$options.props) {</span><span class="s2">\n        </span><span class="s1">toggleObserving(false);</span><span class="s2">\n        </span><span class="s1">var props = vm._props;</span><span class="s2">\n        </span><span class="s1">var propKeys = vm.$options._propKeys || [];</span><span class="s2">\n        </span><span class="s1">for (var i = 0; i &lt; propKeys.length; i++) {</span><span class="s2">\n            </span><span class="s1">var key = propKeys[i];</span><span class="s2">\n            </span><span class="s1">var propOptions = vm.$options.props; // wtf flow?</span><span class="s2">\n            </span><span class="s1">props[key] = validateProp(key, propOptions, propsData, vm);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">toggleObserving(true);</span><span class="s2">\n        </span><span class="s1">// keep a copy of raw propsData</span><span class="s2">\n        </span><span class="s1">vm.$options.propsData = propsData;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// resolve slots + force update if has children</span><span class="s2">\n    </span><span class="s1">if (needsForceUpdate) {</span><span class="s2">\n        </span><span class="s1">vm.$slots = resolveSlots(renderChildren, parentVnode.context);</span><span class="s2">\n        </span><span class="s1">vm.$forceUpdate();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">isUpdatingChildComponent = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isInInactiveTree(vm) {</span><span class="s2">\n    </span><span class="s1">while (vm &amp;&amp; (vm = vm.$parent)) {</span><span class="s2">\n        </span><span class="s1">if (vm._inactive)</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function activateChildComponent(vm, direct) {</span><span class="s2">\n    </span><span class="s1">if (direct) {</span><span class="s2">\n        </span><span class="s1">vm._directInactive = false;</span><span class="s2">\n        </span><span class="s1">if (isInInactiveTree(vm)) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (vm._directInactive) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (vm._inactive || vm._inactive === null) {</span><span class="s2">\n        </span><span class="s1">vm._inactive = false;</span><span class="s2">\n        </span><span class="s1">for (var i = 0; i &lt; vm.$children.length; i++) {</span><span class="s2">\n            </span><span class="s1">activateChildComponent(vm.$children[i]);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">callHook$1(vm, 'activated');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function deactivateChildComponent(vm, direct) {</span><span class="s2">\n    </span><span class="s1">if (direct) {</span><span class="s2">\n        </span><span class="s1">vm._directInactive = true;</span><span class="s2">\n        </span><span class="s1">if (isInInactiveTree(vm)) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!vm._inactive) {</span><span class="s2">\n        </span><span class="s1">vm._inactive = true;</span><span class="s2">\n        </span><span class="s1">for (var i = 0; i &lt; vm.$children.length; i++) {</span><span class="s2">\n            </span><span class="s1">deactivateChildComponent(vm.$children[i]);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">callHook$1(vm, 'deactivated');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function callHook$1(vm, hook, args, setContext) {</span><span class="s2">\n    </span><span class="s1">if (setContext === void 0) { setContext = true; }</span><span class="s2">\n    </span><span class="s1">// #7573 disable dep collection when invoking lifecycle hooks</span><span class="s2">\n    </span><span class="s1">pushTarget();</span><span class="s2">\n    </span><span class="s1">var prev = currentInstance;</span><span class="s2">\n    </span><span class="s1">setContext &amp;&amp; setCurrentInstance(vm);</span><span class="s2">\n    </span><span class="s1">var handlers = vm.$options[hook];</span><span class="s2">\n    </span><span class="s1">var info = </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(hook, </span><span class="s2">\&quot; </span><span class="s1">hook</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (handlers) {</span><span class="s2">\n        </span><span class="s1">for (var i = 0, j = handlers.length; i &lt; j; i++) {</span><span class="s2">\n            </span><span class="s1">invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (vm._hasHookEvent) {</span><span class="s2">\n        </span><span class="s1">vm.$emit('hook:' + hook);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">setContext &amp;&amp; setCurrentInstance(prev);</span><span class="s2">\n    </span><span class="s1">popTarget();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var MAX_UPDATE_COUNT = 100;</span><span class="s2">\n</span><span class="s1">var queue = [];</span><span class="s2">\n</span><span class="s1">var activatedChildren = [];</span><span class="s2">\n</span><span class="s1">var has = {};</span><span class="s2">\n</span><span class="s1">var circular = {};</span><span class="s2">\n</span><span class="s1">var waiting = false;</span><span class="s2">\n</span><span class="s1">var flushing = false;</span><span class="s2">\n</span><span class="s1">var index = 0;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Reset the scheduler's state.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function resetSchedulerState() {</span><span class="s2">\n    </span><span class="s1">index = queue.length = activatedChildren.length = 0;</span><span class="s2">\n    </span><span class="s1">has = {};</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">circular = {};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">waiting = flushing = false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// Async edge case #6566 requires saving the timestamp when event listeners are</span><span class="s2">\n</span><span class="s1">// attached. However, calling performance.now() has a perf overhead especially</span><span class="s2">\n</span><span class="s1">// if the page has thousands of event listeners. Instead, we take a timestamp</span><span class="s2">\n</span><span class="s1">// every time the scheduler flushes and use that for all event listeners</span><span class="s2">\n</span><span class="s1">// attached during that flush.</span><span class="s2">\n</span><span class="s1">var currentFlushTimestamp = 0;</span><span class="s2">\n</span><span class="s1">// Async edge case fix requires storing an event listener's attach timestamp.</span><span class="s2">\n</span><span class="s1">var getNow = Date.now;</span><span class="s2">\n</span><span class="s1">// Determine what event timestamp the browser is using. Annoyingly, the</span><span class="s2">\n</span><span class="s1">// timestamp can either be hi-res (relative to page load) or low-res</span><span class="s2">\n</span><span class="s1">// (relative to UNIX epoch), so in order to compare time we have to use the</span><span class="s2">\n</span><span class="s1">// same timestamp type when saving the flush timestamp.</span><span class="s2">\n</span><span class="s1">// All IE versions use low-res event timestamps, and have problematic clock</span><span class="s2">\n</span><span class="s1">// implementations (#9632)</span><span class="s2">\n</span><span class="s1">if (inBrowser &amp;&amp; !isIE) {</span><span class="s2">\n    </span><span class="s1">var performance_1 = window.performance;</span><span class="s2">\n    </span><span class="s1">if (performance_1 &amp;&amp;</span><span class="s2">\n        </span><span class="s1">typeof performance_1.now === 'function' &amp;&amp;</span><span class="s2">\n        </span><span class="s1">getNow() &gt; document.createEvent('Event').timeStamp) {</span><span class="s2">\n        </span><span class="s1">// if the event timestamp, although evaluated AFTER the Date.now(), is</span><span class="s2">\n        </span><span class="s1">// smaller than it, it means the event is using a hi-res timestamp,</span><span class="s2">\n        </span><span class="s1">// and we need to use the hi-res version for event listener timestamps as</span><span class="s2">\n        </span><span class="s1">// well.</span><span class="s2">\n        </span><span class="s1">getNow = function () { return performance_1.now(); };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var sortCompareFn = function (a, b) {</span><span class="s2">\n    </span><span class="s1">if (a.post) {</span><span class="s2">\n        </span><span class="s1">if (!b.post)</span><span class="s2">\n            </span><span class="s1">return 1;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (b.post) {</span><span class="s2">\n        </span><span class="s1">return -1;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return a.id - b.id;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Flush both queues and run the watchers.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function flushSchedulerQueue() {</span><span class="s2">\n    </span><span class="s1">currentFlushTimestamp = getNow();</span><span class="s2">\n    </span><span class="s1">flushing = true;</span><span class="s2">\n    </span><span class="s1">var watcher, id;</span><span class="s2">\n    </span><span class="s1">// Sort queue before flush.</span><span class="s2">\n    </span><span class="s1">// This ensures that:</span><span class="s2">\n    </span><span class="s1">// 1. Components are updated from parent to child. (because parent is always</span><span class="s2">\n    </span><span class="s1">//    created before the child)</span><span class="s2">\n    </span><span class="s1">// 2. A component's user watchers are run before its render watcher (because</span><span class="s2">\n    </span><span class="s1">//    user watchers are created before the render watcher)</span><span class="s2">\n    </span><span class="s1">// 3. If a component is destroyed during a parent component's watcher run,</span><span class="s2">\n    </span><span class="s1">//    its watchers can be skipped.</span><span class="s2">\n    </span><span class="s1">queue.sort(sortCompareFn);</span><span class="s2">\n    </span><span class="s1">// do not cache length because more watchers might be pushed</span><span class="s2">\n    </span><span class="s1">// as we run existing watchers</span><span class="s2">\n    </span><span class="s1">for (index = 0; index &lt; queue.length; index++) {</span><span class="s2">\n        </span><span class="s1">watcher = queue[index];</span><span class="s2">\n        </span><span class="s1">if (watcher.before) {</span><span class="s2">\n            </span><span class="s1">watcher.before();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">id = watcher.id;</span><span class="s2">\n        </span><span class="s1">has[id] = null;</span><span class="s2">\n        </span><span class="s1">watcher.run();</span><span class="s2">\n        </span><span class="s1">// in dev build, check and stop circular updates.</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; has[id] != null) {</span><span class="s2">\n            </span><span class="s1">circular[id] = (circular[id] || 0) + 1;</span><span class="s2">\n            </span><span class="s1">if (circular[id] &gt; MAX_UPDATE_COUNT) {</span><span class="s2">\n                </span><span class="s1">warn('You may have an infinite update loop ' +</span><span class="s2">\n                    </span><span class="s1">(watcher.user</span><span class="s2">\n                        </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">in watcher with expression </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(watcher.expression, </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">)</span><span class="s2">\n                        </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">in a component render function.</span><span class="s2">\&quot;</span><span class="s1">), watcher.vm);</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// keep copies of post queues before resetting state</span><span class="s2">\n    </span><span class="s1">var activatedQueue = activatedChildren.slice();</span><span class="s2">\n    </span><span class="s1">var updatedQueue = queue.slice();</span><span class="s2">\n    </span><span class="s1">resetSchedulerState();</span><span class="s2">\n    </span><span class="s1">// call component updated and activated hooks</span><span class="s2">\n    </span><span class="s1">callActivatedHooks(activatedQueue);</span><span class="s2">\n    </span><span class="s1">callUpdatedHooks(updatedQueue);</span><span class="s2">\n    </span><span class="s1">cleanupDeps();</span><span class="s2">\n    </span><span class="s1">// devtool hook</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (devtools &amp;&amp; config.devtools) {</span><span class="s2">\n        </span><span class="s1">devtools.emit('flush');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function callUpdatedHooks(queue) {</span><span class="s2">\n    </span><span class="s1">var i = queue.length;</span><span class="s2">\n    </span><span class="s1">while (i--) {</span><span class="s2">\n        </span><span class="s1">var watcher = queue[i];</span><span class="s2">\n        </span><span class="s1">var vm = watcher.vm;</span><span class="s2">\n        </span><span class="s1">if (vm &amp;&amp; vm._watcher === watcher &amp;&amp; vm._isMounted &amp;&amp; !vm._isDestroyed) {</span><span class="s2">\n            </span><span class="s1">callHook$1(vm, 'updated');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Queue a kept-alive component that was activated during patch.</span><span class="s2">\n </span><span class="s1">* The queue will be processed after the entire tree has been patched.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function queueActivatedComponent(vm) {</span><span class="s2">\n    </span><span class="s1">// setting _inactive to false here so that a render function can</span><span class="s2">\n    </span><span class="s1">// rely on checking whether it's in an inactive tree (e.g. router-view)</span><span class="s2">\n    </span><span class="s1">vm._inactive = false;</span><span class="s2">\n    </span><span class="s1">activatedChildren.push(vm);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function callActivatedHooks(queue) {</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; queue.length; i++) {</span><span class="s2">\n        </span><span class="s1">queue[i]._inactive = true;</span><span class="s2">\n        </span><span class="s1">activateChildComponent(queue[i], true /* true */);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Push a watcher into the watcher queue.</span><span class="s2">\n </span><span class="s1">* Jobs with duplicate IDs will be skipped unless it's</span><span class="s2">\n </span><span class="s1">* pushed when the queue is being flushed.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function queueWatcher(watcher) {</span><span class="s2">\n    </span><span class="s1">var id = watcher.id;</span><span class="s2">\n    </span><span class="s1">if (has[id] != null) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (watcher === Dep.target &amp;&amp; watcher.noRecurse) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">has[id] = true;</span><span class="s2">\n    </span><span class="s1">if (!flushing) {</span><span class="s2">\n        </span><span class="s1">queue.push(watcher);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// if already flushing, splice the watcher based on its id</span><span class="s2">\n        </span><span class="s1">// if already past its id, it will be run next immediately.</span><span class="s2">\n        </span><span class="s1">var i = queue.length - 1;</span><span class="s2">\n        </span><span class="s1">while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) {</span><span class="s2">\n            </span><span class="s1">i--;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">queue.splice(i + 1, 0, watcher);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// queue the flush</span><span class="s2">\n    </span><span class="s1">if (!waiting) {</span><span class="s2">\n        </span><span class="s1">waiting = true;</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) {</span><span class="s2">\n            </span><span class="s1">flushSchedulerQueue();</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">nextTick(flushSchedulerQueue);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function initProvide(vm) {</span><span class="s2">\n    </span><span class="s1">var provideOption = vm.$options.provide;</span><span class="s2">\n    </span><span class="s1">if (provideOption) {</span><span class="s2">\n        </span><span class="s1">var provided = isFunction(provideOption)</span><span class="s2">\n            </span><span class="s1">? provideOption.call(vm)</span><span class="s2">\n            </span><span class="s1">: provideOption;</span><span class="s2">\n        </span><span class="s1">if (!isObject(provided)) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var source = resolveProvided(vm);</span><span class="s2">\n        </span><span class="s1">// IE9 doesn't support Object.getOwnPropertyDescriptors so we have to</span><span class="s2">\n        </span><span class="s1">// iterate the keys ourselves.</span><span class="s2">\n        </span><span class="s1">var keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);</span><span class="s2">\n        </span><span class="s1">for (var i = 0; i &lt; keys.length; i++) {</span><span class="s2">\n            </span><span class="s1">var key = keys[i];</span><span class="s2">\n            </span><span class="s1">Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initInjections(vm) {</span><span class="s2">\n    </span><span class="s1">var result = resolveInject(vm.$options.inject, vm);</span><span class="s2">\n    </span><span class="s1">if (result) {</span><span class="s2">\n        </span><span class="s1">toggleObserving(false);</span><span class="s2">\n        </span><span class="s1">Object.keys(result).forEach(function (key) {</span><span class="s2">\n            </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n            </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n                </span><span class="s1">defineReactive(vm, key, result[key], function () {</span><span class="s2">\n                    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Avoid mutating an injected value directly since the changes will be </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                        \&quot;</span><span class="s1">overwritten whenever the provided component re-renders. </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                        \&quot;</span><span class="s1">injection being mutated: </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">), vm);</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">defineReactive(vm, key, result[key]);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">toggleObserving(true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveInject(inject, vm) {</span><span class="s2">\n    </span><span class="s1">if (inject) {</span><span class="s2">\n        </span><span class="s1">// inject is :any because flow is not smart enough to figure out cached</span><span class="s2">\n        </span><span class="s1">var result = Object.create(null);</span><span class="s2">\n        </span><span class="s1">var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);</span><span class="s2">\n        </span><span class="s1">for (var i = 0; i &lt; keys.length; i++) {</span><span class="s2">\n            </span><span class="s1">var key = keys[i];</span><span class="s2">\n            </span><span class="s1">// #6574 in case the inject object is observed...</span><span class="s2">\n            </span><span class="s1">if (key === '__ob__')</span><span class="s2">\n                </span><span class="s1">continue;</span><span class="s2">\n            </span><span class="s1">var provideKey = inject[key].from;</span><span class="s2">\n            </span><span class="s1">if (provideKey in vm._provided) {</span><span class="s2">\n                </span><span class="s1">result[key] = vm._provided[provideKey];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if ('default' in inject[key]) {</span><span class="s2">\n                </span><span class="s1">var provideDefault = inject[key].default;</span><span class="s2">\n                </span><span class="s1">result[key] = isFunction(provideDefault)</span><span class="s2">\n                    </span><span class="s1">? provideDefault.call(vm)</span><span class="s2">\n                    </span><span class="s1">: provideDefault;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Injection </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">not found</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return result;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function FunctionalRenderContext(data, props, children, parent, Ctor) {</span><span class="s2">\n    </span><span class="s1">var _this = this;</span><span class="s2">\n    </span><span class="s1">var options = Ctor.options;</span><span class="s2">\n    </span><span class="s1">// ensure the createElement function in functional components</span><span class="s2">\n    </span><span class="s1">// gets a unique context - this is necessary for correct named slot check</span><span class="s2">\n    </span><span class="s1">var contextVm;</span><span class="s2">\n    </span><span class="s1">if (hasOwn(parent, '_uid')) {</span><span class="s2">\n        </span><span class="s1">contextVm = Object.create(parent);</span><span class="s2">\n        </span><span class="s1">contextVm._original = parent;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// the context vm passed in is a functional context as well.</span><span class="s2">\n        </span><span class="s1">// in this case we want to make sure we are able to get a hold to the</span><span class="s2">\n        </span><span class="s1">// real context instance.</span><span class="s2">\n        </span><span class="s1">contextVm = parent;</span><span class="s2">\n        </span><span class="s1">// @ts-ignore</span><span class="s2">\n        </span><span class="s1">parent = parent._original;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var isCompiled = isTrue(options._compiled);</span><span class="s2">\n    </span><span class="s1">var needNormalization = !isCompiled;</span><span class="s2">\n    </span><span class="s1">this.data = data;</span><span class="s2">\n    </span><span class="s1">this.props = props;</span><span class="s2">\n    </span><span class="s1">this.children = children;</span><span class="s2">\n    </span><span class="s1">this.parent = parent;</span><span class="s2">\n    </span><span class="s1">this.listeners = data.on || emptyObject;</span><span class="s2">\n    </span><span class="s1">this.injections = resolveInject(options.inject, parent);</span><span class="s2">\n    </span><span class="s1">this.slots = function () {</span><span class="s2">\n        </span><span class="s1">if (!_this.$slots) {</span><span class="s2">\n            </span><span class="s1">normalizeScopedSlots(parent, data.scopedSlots, (_this.$slots = resolveSlots(children, parent)));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return _this.$slots;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(this, 'scopedSlots', {</span><span class="s2">\n        </span><span class="s1">enumerable: true,</span><span class="s2">\n        </span><span class="s1">get: function () {</span><span class="s2">\n            </span><span class="s1">return normalizeScopedSlots(parent, data.scopedSlots, this.slots());</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">// support for compiled functional template</span><span class="s2">\n    </span><span class="s1">if (isCompiled) {</span><span class="s2">\n        </span><span class="s1">// exposing $options for renderStatic()</span><span class="s2">\n        </span><span class="s1">this.$options = options;</span><span class="s2">\n        </span><span class="s1">// pre-resolve slots for renderSlot()</span><span class="s2">\n        </span><span class="s1">this.$slots = this.slots();</span><span class="s2">\n        </span><span class="s1">this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (options._scopeId) {</span><span class="s2">\n        </span><span class="s1">this._c = function (a, b, c, d) {</span><span class="s2">\n            </span><span class="s1">var vnode = createElement$1(contextVm, a, b, c, d, needNormalization);</span><span class="s2">\n            </span><span class="s1">if (vnode &amp;&amp; !isArray(vnode)) {</span><span class="s2">\n                </span><span class="s1">vnode.fnScopeId = options._scopeId;</span><span class="s2">\n                </span><span class="s1">vnode.fnContext = parent;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return vnode;</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">this._c = function (a, b, c, d) {</span><span class="s2">\n            </span><span class="s1">return createElement$1(contextVm, a, b, c, d, needNormalization);</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">installRenderHelpers(FunctionalRenderContext.prototype);</span><span class="s2">\n</span><span class="s1">function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {</span><span class="s2">\n    </span><span class="s1">var options = Ctor.options;</span><span class="s2">\n    </span><span class="s1">var props = {};</span><span class="s2">\n    </span><span class="s1">var propOptions = options.props;</span><span class="s2">\n    </span><span class="s1">if (isDef(propOptions)) {</span><span class="s2">\n        </span><span class="s1">for (var key in propOptions) {</span><span class="s2">\n            </span><span class="s1">props[key] = validateProp(key, propOptions, propsData || emptyObject);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">if (isDef(data.attrs))</span><span class="s2">\n            </span><span class="s1">mergeProps(props, data.attrs);</span><span class="s2">\n        </span><span class="s1">if (isDef(data.props))</span><span class="s2">\n            </span><span class="s1">mergeProps(props, data.props);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);</span><span class="s2">\n    </span><span class="s1">var vnode = options.render.call(null, renderContext._c, renderContext);</span><span class="s2">\n    </span><span class="s1">if (vnode instanceof VNode) {</span><span class="s2">\n        </span><span class="s1">return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isArray(vnode)) {</span><span class="s2">\n        </span><span class="s1">var vnodes = normalizeChildren(vnode) || [];</span><span class="s2">\n        </span><span class="s1">var res = new Array(vnodes.length);</span><span class="s2">\n        </span><span class="s1">for (var i = 0; i &lt; vnodes.length; i++) {</span><span class="s2">\n            </span><span class="s1">res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return res;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {</span><span class="s2">\n    </span><span class="s1">// #7817 clone node before setting fnContext, otherwise if the node is reused</span><span class="s2">\n    </span><span class="s1">// (e.g. it was from a cached normal slot) the fnContext causes named slots</span><span class="s2">\n    </span><span class="s1">// that should not be matched to match.</span><span class="s2">\n    </span><span class="s1">var clone = cloneVNode(vnode);</span><span class="s2">\n    </span><span class="s1">clone.fnContext = contextVm;</span><span class="s2">\n    </span><span class="s1">clone.fnOptions = options;</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">(clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext =</span><span class="s2">\n            </span><span class="s1">renderContext;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (data.slot) {</span><span class="s2">\n        </span><span class="s1">(clone.data || (clone.data = {})).slot = data.slot;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return clone;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mergeProps(to, from) {</span><span class="s2">\n    </span><span class="s1">for (var key in from) {</span><span class="s2">\n        </span><span class="s1">to[camelize(key)] = from[key];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function getComponentName(options) {</span><span class="s2">\n    </span><span class="s1">return options.name || options.__name || options._componentTag;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// inline hooks to be invoked on component VNodes during patch</span><span class="s2">\n</span><span class="s1">var componentVNodeHooks = {</span><span class="s2">\n    </span><span class="s1">init: function (vnode, hydrating) {</span><span class="s2">\n        </span><span class="s1">if (vnode.componentInstance &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!vnode.componentInstance._isDestroyed &amp;&amp;</span><span class="s2">\n            </span><span class="s1">vnode.data.keepAlive) {</span><span class="s2">\n            </span><span class="s1">// kept-alive components, treat as a patch</span><span class="s2">\n            </span><span class="s1">var mountedNode = vnode; // work around flow</span><span class="s2">\n            </span><span class="s1">componentVNodeHooks.prepatch(mountedNode, mountedNode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">var child = (vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance));</span><span class="s2">\n            </span><span class="s1">child.$mount(hydrating ? vnode.elm : undefined, hydrating);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">prepatch: function (oldVnode, vnode) {</span><span class="s2">\n        </span><span class="s1">var options = vnode.componentOptions;</span><span class="s2">\n        </span><span class="s1">var child = (vnode.componentInstance = oldVnode.componentInstance);</span><span class="s2">\n        </span><span class="s1">updateChildComponent(child, options.propsData, // updated props</span><span class="s2">\n        </span><span class="s1">options.listeners, // updated listeners</span><span class="s2">\n        </span><span class="s1">vnode, // new parent vnode</span><span class="s2">\n        </span><span class="s1">options.children // new children</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">insert: function (vnode) {</span><span class="s2">\n        </span><span class="s1">var context = vnode.context, componentInstance = vnode.componentInstance;</span><span class="s2">\n        </span><span class="s1">if (!componentInstance._isMounted) {</span><span class="s2">\n            </span><span class="s1">componentInstance._isMounted = true;</span><span class="s2">\n            </span><span class="s1">callHook$1(componentInstance, 'mounted');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (vnode.data.keepAlive) {</span><span class="s2">\n            </span><span class="s1">if (context._isMounted) {</span><span class="s2">\n                </span><span class="s1">// vue-router#1212</span><span class="s2">\n                </span><span class="s1">// During updates, a kept-alive component's child components may</span><span class="s2">\n                </span><span class="s1">// change, so directly walking the tree here may call activated hooks</span><span class="s2">\n                </span><span class="s1">// on incorrect children. Instead we push them into a queue which will</span><span class="s2">\n                </span><span class="s1">// be processed after the whole patch process ended.</span><span class="s2">\n                </span><span class="s1">queueActivatedComponent(componentInstance);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">activateChildComponent(componentInstance, true /* direct */);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">destroy: function (vnode) {</span><span class="s2">\n        </span><span class="s1">var componentInstance = vnode.componentInstance;</span><span class="s2">\n        </span><span class="s1">if (!componentInstance._isDestroyed) {</span><span class="s2">\n            </span><span class="s1">if (!vnode.data.keepAlive) {</span><span class="s2">\n                </span><span class="s1">componentInstance.$destroy();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">deactivateChildComponent(componentInstance, true /* direct */);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var hooksToMerge = Object.keys(componentVNodeHooks);</span><span class="s2">\n</span><span class="s1">function createComponent(Ctor, data, context, children, tag) {</span><span class="s2">\n    </span><span class="s1">if (isUndef(Ctor)) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var baseCtor = context.$options._base;</span><span class="s2">\n    </span><span class="s1">// plain options object: turn it into a constructor</span><span class="s2">\n    </span><span class="s1">if (isObject(Ctor)) {</span><span class="s2">\n        </span><span class="s1">Ctor = baseCtor.extend(Ctor);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// if at this stage it's not a constructor or an async component factory,</span><span class="s2">\n    </span><span class="s1">// reject.</span><span class="s2">\n    </span><span class="s1">if (typeof Ctor !== 'function') {</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Invalid Component definition: </span><span class="s2">\&quot;</span><span class="s1">.concat(String(Ctor)), context);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// async component</span><span class="s2">\n    </span><span class="s1">var asyncFactory;</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">if (isUndef(Ctor.cid)) {</span><span class="s2">\n        </span><span class="s1">asyncFactory = Ctor;</span><span class="s2">\n        </span><span class="s1">Ctor = resolveAsyncComponent(asyncFactory, baseCtor);</span><span class="s2">\n        </span><span class="s1">if (Ctor === undefined) {</span><span class="s2">\n            </span><span class="s1">// return a placeholder node for async component, which is rendered</span><span class="s2">\n            </span><span class="s1">// as a comment node but preserves all the raw information for the node.</span><span class="s2">\n            </span><span class="s1">// the information will be used for async server-rendering and hydration.</span><span class="s2">\n            </span><span class="s1">return createAsyncPlaceholder(asyncFactory, data, context, children, tag);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">data = data || {};</span><span class="s2">\n    </span><span class="s1">// resolve constructor options in case global mixins are applied after</span><span class="s2">\n    </span><span class="s1">// component constructor creation</span><span class="s2">\n    </span><span class="s1">resolveConstructorOptions(Ctor);</span><span class="s2">\n    </span><span class="s1">// transform component v-model data into props &amp; events</span><span class="s2">\n    </span><span class="s1">if (isDef(data.model)) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error</span><span class="s2">\n        </span><span class="s1">transformModel(Ctor.options, data);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// extract props</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">var propsData = extractPropsFromVNodeData(data, Ctor, tag);</span><span class="s2">\n    </span><span class="s1">// functional component</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">if (isTrue(Ctor.options.functional)) {</span><span class="s2">\n        </span><span class="s1">return createFunctionalComponent(Ctor, propsData, data, context, children);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// extract listeners, since these needs to be treated as</span><span class="s2">\n    </span><span class="s1">// child component listeners instead of DOM listeners</span><span class="s2">\n    </span><span class="s1">var listeners = data.on;</span><span class="s2">\n    </span><span class="s1">// replace with listeners with .native modifier</span><span class="s2">\n    </span><span class="s1">// so it gets processed during parent component patch.</span><span class="s2">\n    </span><span class="s1">data.on = data.nativeOn;</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">if (isTrue(Ctor.options.abstract)) {</span><span class="s2">\n        </span><span class="s1">// abstract components do not keep anything</span><span class="s2">\n        </span><span class="s1">// other than props &amp; listeners &amp; slot</span><span class="s2">\n        </span><span class="s1">// work around flow</span><span class="s2">\n        </span><span class="s1">var slot = data.slot;</span><span class="s2">\n        </span><span class="s1">data = {};</span><span class="s2">\n        </span><span class="s1">if (slot) {</span><span class="s2">\n            </span><span class="s1">data.slot = slot;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// install component management hooks onto the placeholder node</span><span class="s2">\n    </span><span class="s1">installComponentHooks(data);</span><span class="s2">\n    </span><span class="s1">// return a placeholder vnode</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">var name = getComponentName(Ctor.options) || tag;</span><span class="s2">\n    </span><span class="s1">var vnode = new VNode(</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    \&quot;</span><span class="s1">vue-component-</span><span class="s2">\&quot;</span><span class="s1">.concat(Ctor.cid).concat(name ? </span><span class="s2">\&quot;</span><span class="s1">-</span><span class="s2">\&quot;</span><span class="s1">.concat(name) : ''), data, undefined, undefined, undefined, context, </span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">{ Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);</span><span class="s2">\n    </span><span class="s1">return vnode;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createComponentInstanceForVnode(</span><span class="s2">\n</span><span class="s1">// we know it's MountedComponentVNode but flow doesn't</span><span class="s2">\n</span><span class="s1">vnode, </span><span class="s2">\n</span><span class="s1">// activeInstance in lifecycle state</span><span class="s2">\n</span><span class="s1">parent) {</span><span class="s2">\n    </span><span class="s1">var options = {</span><span class="s2">\n        </span><span class="s1">_isComponent: true,</span><span class="s2">\n        </span><span class="s1">_parentVnode: vnode,</span><span class="s2">\n        </span><span class="s1">parent: parent</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">// check inline-template render functions</span><span class="s2">\n    </span><span class="s1">var inlineTemplate = vnode.data.inlineTemplate;</span><span class="s2">\n    </span><span class="s1">if (isDef(inlineTemplate)) {</span><span class="s2">\n        </span><span class="s1">options.render = inlineTemplate.render;</span><span class="s2">\n        </span><span class="s1">options.staticRenderFns = inlineTemplate.staticRenderFns;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return new vnode.componentOptions.Ctor(options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function installComponentHooks(data) {</span><span class="s2">\n    </span><span class="s1">var hooks = data.hook || (data.hook = {});</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; hooksToMerge.length; i++) {</span><span class="s2">\n        </span><span class="s1">var key = hooksToMerge[i];</span><span class="s2">\n        </span><span class="s1">var existing = hooks[key];</span><span class="s2">\n        </span><span class="s1">var toMerge = componentVNodeHooks[key];</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error</span><span class="s2">\n        </span><span class="s1">if (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) {</span><span class="s2">\n            </span><span class="s1">hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mergeHook(f1, f2) {</span><span class="s2">\n    </span><span class="s1">var merged = function (a, b) {</span><span class="s2">\n        </span><span class="s1">// flow complains about extra args which is why we use any</span><span class="s2">\n        </span><span class="s1">f1(a, b);</span><span class="s2">\n        </span><span class="s1">f2(a, b);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">merged._merged = true;</span><span class="s2">\n    </span><span class="s1">return merged;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// transform component v-model info (value and callback) into</span><span class="s2">\n</span><span class="s1">// prop and event handler respectively.</span><span class="s2">\n</span><span class="s1">function transformModel(options, data) {</span><span class="s2">\n    </span><span class="s1">var prop = (options.model &amp;&amp; options.model.prop) || 'value';</span><span class="s2">\n    </span><span class="s1">var event = (options.model &amp;&amp; options.model.event) || 'input';</span><span class="s2">\n    </span><span class="s1">(data.attrs || (data.attrs = {}))[prop] = data.model.value;</span><span class="s2">\n    </span><span class="s1">var on = data.on || (data.on = {});</span><span class="s2">\n    </span><span class="s1">var existing = on[event];</span><span class="s2">\n    </span><span class="s1">var callback = data.model.callback;</span><span class="s2">\n    </span><span class="s1">if (isDef(existing)) {</span><span class="s2">\n        </span><span class="s1">if (isArray(existing)</span><span class="s2">\n            </span><span class="s1">? existing.indexOf(callback) === -1</span><span class="s2">\n            </span><span class="s1">: existing !== callback) {</span><span class="s2">\n            </span><span class="s1">on[event] = [callback].concat(existing);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">on[event] = callback;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var warn = noop;</span><span class="s2">\n</span><span class="s1">var tip = noop;</span><span class="s2">\n</span><span class="s1">var generateComponentTrace; // work around flow check</span><span class="s2">\n</span><span class="s1">var formatComponentName;</span><span class="s2">\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">var hasConsole_1 = typeof console !== 'undefined';</span><span class="s2">\n    </span><span class="s1">var classifyRE_1 = /(?:^|[-_])(</span><span class="s2">\\</span><span class="s1">w)/g;</span><span class="s2">\n    </span><span class="s1">var classify_1 = function (str) {</span><span class="s2">\n        </span><span class="s1">return str.replace(classifyRE_1, function (c) { return c.toUpperCase(); }).replace(/[-_]/g, '');</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">warn = function (msg, vm) {</span><span class="s2">\n        </span><span class="s1">if (vm === void 0) { vm = currentInstance; }</span><span class="s2">\n        </span><span class="s1">var trace = vm ? generateComponentTrace(vm) : '';</span><span class="s2">\n        </span><span class="s1">if (config.warnHandler) {</span><span class="s2">\n            </span><span class="s1">config.warnHandler.call(null, msg, vm, trace);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (hasConsole_1 &amp;&amp; !config.silent) {</span><span class="s2">\n            </span><span class="s1">console.error(</span><span class="s2">\&quot;</span><span class="s1">[Vue warn]: </span><span class="s2">\&quot;</span><span class="s1">.concat(msg).concat(trace));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">tip = function (msg, vm) {</span><span class="s2">\n        </span><span class="s1">if (hasConsole_1 &amp;&amp; !config.silent) {</span><span class="s2">\n            </span><span class="s1">console.warn(</span><span class="s2">\&quot;</span><span class="s1">[Vue tip]: </span><span class="s2">\&quot;</span><span class="s1">.concat(msg) + (vm ? generateComponentTrace(vm) : ''));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">formatComponentName = function (vm, includeFile) {</span><span class="s2">\n        </span><span class="s1">if (vm.$root === vm) {</span><span class="s2">\n            </span><span class="s1">return '&lt;Root&gt;';</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var options = isFunction(vm) &amp;&amp; vm.cid != null</span><span class="s2">\n            </span><span class="s1">? vm.options</span><span class="s2">\n            </span><span class="s1">: vm._isVue</span><span class="s2">\n                </span><span class="s1">? vm.$options || vm.constructor.options</span><span class="s2">\n                </span><span class="s1">: vm;</span><span class="s2">\n        </span><span class="s1">var name = getComponentName(options);</span><span class="s2">\n        </span><span class="s1">var file = options.__file;</span><span class="s2">\n        </span><span class="s1">if (!name &amp;&amp; file) {</span><span class="s2">\n            </span><span class="s1">var match = file.match(/([^/</span><span class="s2">\\\\</span><span class="s1">]+)</span><span class="s2">\\</span><span class="s1">.vue$/);</span><span class="s2">\n            </span><span class="s1">name = match &amp;&amp; match[1];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return ((name ? </span><span class="s2">\&quot;</span><span class="s1">&lt;</span><span class="s2">\&quot;</span><span class="s1">.concat(classify_1(name), </span><span class="s2">\&quot;</span><span class="s1">&gt;</span><span class="s2">\&quot;</span><span class="s1">) : </span><span class="s2">\&quot;</span><span class="s1">&lt;Anonymous&gt;</span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n            </span><span class="s1">(file &amp;&amp; includeFile !== false ? </span><span class="s2">\&quot; </span><span class="s1">at </span><span class="s2">\&quot;</span><span class="s1">.concat(file) : ''));</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var repeat_1 = function (str, n) {</span><span class="s2">\n        </span><span class="s1">var res = '';</span><span class="s2">\n        </span><span class="s1">while (n) {</span><span class="s2">\n            </span><span class="s1">if (n % 2 === 1)</span><span class="s2">\n                </span><span class="s1">res += str;</span><span class="s2">\n            </span><span class="s1">if (n &gt; 1)</span><span class="s2">\n                </span><span class="s1">str += str;</span><span class="s2">\n            </span><span class="s1">n &gt;&gt;= 1;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return res;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">generateComponentTrace = function (vm) {</span><span class="s2">\n        </span><span class="s1">if (vm._isVue &amp;&amp; vm.$parent) {</span><span class="s2">\n            </span><span class="s1">var tree = [];</span><span class="s2">\n            </span><span class="s1">var currentRecursiveSequence = 0;</span><span class="s2">\n            </span><span class="s1">while (vm) {</span><span class="s2">\n                </span><span class="s1">if (tree.length &gt; 0) {</span><span class="s2">\n                    </span><span class="s1">var last = tree[tree.length - 1];</span><span class="s2">\n                    </span><span class="s1">if (last.constructor === vm.constructor) {</span><span class="s2">\n                        </span><span class="s1">currentRecursiveSequence++;</span><span class="s2">\n                        </span><span class="s1">vm = vm.$parent;</span><span class="s2">\n                        </span><span class="s1">continue;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else if (currentRecursiveSequence &gt; 0) {</span><span class="s2">\n                        </span><span class="s1">tree[tree.length - 1] = [last, currentRecursiveSequence];</span><span class="s2">\n                        </span><span class="s1">currentRecursiveSequence = 0;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">tree.push(vm);</span><span class="s2">\n                </span><span class="s1">vm = vm.$parent;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return ('</span><span class="s2">\\</span><span class="s1">n</span><span class="s2">\\</span><span class="s1">nfound in</span><span class="s2">\\</span><span class="s1">n</span><span class="s2">\\</span><span class="s1">n' +</span><span class="s2">\n                </span><span class="s1">tree</span><span class="s2">\n                    </span><span class="s1">.map(function (vm, i) {</span><span class="s2">\n                    </span><span class="s1">return </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(i === 0 ? '---&gt; ' : repeat_1(' ', 5 + i * 2)).concat(isArray(vm)</span><span class="s2">\n                        </span><span class="s1">? </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(formatComponentName(vm[0]), </span><span class="s2">\&quot;</span><span class="s1">... (</span><span class="s2">\&quot;</span><span class="s1">).concat(vm[1], </span><span class="s2">\&quot; </span><span class="s1">recursive calls)</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n                        </span><span class="s1">: formatComponentName(vm));</span><span class="s2">\n                </span><span class="s1">})</span><span class="s2">\n                    </span><span class="s1">.join('</span><span class="s2">\\</span><span class="s1">n'));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">return </span><span class="s2">\&quot;\\</span><span class="s1">n</span><span class="s2">\\</span><span class="s1">n(found in </span><span class="s2">\&quot;</span><span class="s1">.concat(formatComponentName(vm), </span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Option overwriting strategies are functions that handle</span><span class="s2">\n </span><span class="s1">* how to merge a parent option value and a child option</span><span class="s2">\n </span><span class="s1">* value into the final value.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var strats = config.optionMergeStrategies;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Options with restrictions</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">strats.el = strats.propsData = function (parent, child, vm, key) {</span><span class="s2">\n        </span><span class="s1">if (!vm) {</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">option </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">can only be used during instance </span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n                </span><span class="s1">'creation with the `new` keyword.');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return defaultStrat(parent, child);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Helper that recursively merges two data objects together.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function mergeData(to, from, recursive) {</span><span class="s2">\n    </span><span class="s1">if (recursive === void 0) { recursive = true; }</span><span class="s2">\n    </span><span class="s1">if (!from)</span><span class="s2">\n        </span><span class="s1">return to;</span><span class="s2">\n    </span><span class="s1">var key, toVal, fromVal;</span><span class="s2">\n    </span><span class="s1">var keys = hasSymbol</span><span class="s2">\n        </span><span class="s1">? Reflect.ownKeys(from)</span><span class="s2">\n        </span><span class="s1">: Object.keys(from);</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; keys.length; i++) {</span><span class="s2">\n        </span><span class="s1">key = keys[i];</span><span class="s2">\n        </span><span class="s1">// in case the object is already observed...</span><span class="s2">\n        </span><span class="s1">if (key === '__ob__')</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">toVal = to[key];</span><span class="s2">\n        </span><span class="s1">fromVal = from[key];</span><span class="s2">\n        </span><span class="s1">if (!recursive || !hasOwn(to, key)) {</span><span class="s2">\n            </span><span class="s1">set(to, key, fromVal);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (toVal !== fromVal &amp;&amp;</span><span class="s2">\n            </span><span class="s1">isPlainObject(toVal) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">isPlainObject(fromVal)) {</span><span class="s2">\n            </span><span class="s1">mergeData(toVal, fromVal);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return to;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Data</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function mergeDataOrFn(parentVal, childVal, vm) {</span><span class="s2">\n    </span><span class="s1">if (!vm) {</span><span class="s2">\n        </span><span class="s1">// in a Vue.extend merge, both should be functions</span><span class="s2">\n        </span><span class="s1">if (!childVal) {</span><span class="s2">\n            </span><span class="s1">return parentVal;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (!parentVal) {</span><span class="s2">\n            </span><span class="s1">return childVal;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// when parentVal &amp; childVal are both present,</span><span class="s2">\n        </span><span class="s1">// we need to return a function that returns the</span><span class="s2">\n        </span><span class="s1">// merged result of both functions... no need to</span><span class="s2">\n        </span><span class="s1">// check if parentVal is a function here because</span><span class="s2">\n        </span><span class="s1">// it has to be a function to pass previous merges.</span><span class="s2">\n        </span><span class="s1">return function mergedDataFn() {</span><span class="s2">\n            </span><span class="s1">return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">return function mergedInstanceDataFn() {</span><span class="s2">\n            </span><span class="s1">// instance merge</span><span class="s2">\n            </span><span class="s1">var instanceData = isFunction(childVal)</span><span class="s2">\n                </span><span class="s1">? childVal.call(vm, vm)</span><span class="s2">\n                </span><span class="s1">: childVal;</span><span class="s2">\n            </span><span class="s1">var defaultData = isFunction(parentVal)</span><span class="s2">\n                </span><span class="s1">? parentVal.call(vm, vm)</span><span class="s2">\n                </span><span class="s1">: parentVal;</span><span class="s2">\n            </span><span class="s1">if (instanceData) {</span><span class="s2">\n                </span><span class="s1">return mergeData(instanceData, defaultData);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">return defaultData;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">strats.data = function (parentVal, childVal, vm) {</span><span class="s2">\n    </span><span class="s1">if (!vm) {</span><span class="s2">\n        </span><span class="s1">if (childVal &amp;&amp; typeof childVal !== 'function') {</span><span class="s2">\n            </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n                </span><span class="s1">warn('The </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">option should be a function ' +</span><span class="s2">\n                    </span><span class="s1">'that returns a per-instance value in component ' +</span><span class="s2">\n                    </span><span class="s1">'definitions.', vm);</span><span class="s2">\n            </span><span class="s1">return parentVal;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return mergeDataOrFn(parentVal, childVal);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return mergeDataOrFn(parentVal, childVal, vm);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Hooks and props are merged as arrays.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function mergeLifecycleHook(parentVal, childVal) {</span><span class="s2">\n    </span><span class="s1">var res = childVal</span><span class="s2">\n        </span><span class="s1">? parentVal</span><span class="s2">\n            </span><span class="s1">? parentVal.concat(childVal)</span><span class="s2">\n            </span><span class="s1">: isArray(childVal)</span><span class="s2">\n                </span><span class="s1">? childVal</span><span class="s2">\n                </span><span class="s1">: [childVal]</span><span class="s2">\n        </span><span class="s1">: parentVal;</span><span class="s2">\n    </span><span class="s1">return res ? dedupeHooks(res) : res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function dedupeHooks(hooks) {</span><span class="s2">\n    </span><span class="s1">var res = [];</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; hooks.length; i++) {</span><span class="s2">\n        </span><span class="s1">if (res.indexOf(hooks[i]) === -1) {</span><span class="s2">\n            </span><span class="s1">res.push(hooks[i]);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">LIFECYCLE_HOOKS.forEach(function (hook) {</span><span class="s2">\n    </span><span class="s1">strats[hook] = mergeLifecycleHook;</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Assets</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* When a vm is present (instance creation), we need to do</span><span class="s2">\n </span><span class="s1">* a three-way merge between constructor options, instance</span><span class="s2">\n </span><span class="s1">* options and parent options.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function mergeAssets(parentVal, childVal, vm, key) {</span><span class="s2">\n    </span><span class="s1">var res = Object.create(parentVal || null);</span><span class="s2">\n    </span><span class="s1">if (childVal) {</span><span class="s2">\n        </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; assertObjectType(key, childVal, vm);</span><span class="s2">\n        </span><span class="s1">return extend(res, childVal);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">return res;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">ASSET_TYPES.forEach(function (type) {</span><span class="s2">\n    </span><span class="s1">strats[type + 's'] = mergeAssets;</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Watchers.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Watchers hashes should not overwrite one</span><span class="s2">\n </span><span class="s1">* another, so we merge them as arrays.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">strats.watch = function (parentVal, childVal, vm, key) {</span><span class="s2">\n    </span><span class="s1">// work around Firefox's Object.prototype.watch...</span><span class="s2">\n    </span><span class="s1">//@ts-expect-error work around</span><span class="s2">\n    </span><span class="s1">if (parentVal === nativeWatch)</span><span class="s2">\n        </span><span class="s1">parentVal = undefined;</span><span class="s2">\n    </span><span class="s1">//@ts-expect-error work around</span><span class="s2">\n    </span><span class="s1">if (childVal === nativeWatch)</span><span class="s2">\n        </span><span class="s1">childVal = undefined;</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (!childVal)</span><span class="s2">\n        </span><span class="s1">return Object.create(parentVal || null);</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">assertObjectType(key, childVal, vm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!parentVal)</span><span class="s2">\n        </span><span class="s1">return childVal;</span><span class="s2">\n    </span><span class="s1">var ret = {};</span><span class="s2">\n    </span><span class="s1">extend(ret, parentVal);</span><span class="s2">\n    </span><span class="s1">for (var key_1 in childVal) {</span><span class="s2">\n        </span><span class="s1">var parent_1 = ret[key_1];</span><span class="s2">\n        </span><span class="s1">var child = childVal[key_1];</span><span class="s2">\n        </span><span class="s1">if (parent_1 &amp;&amp; !isArray(parent_1)) {</span><span class="s2">\n            </span><span class="s1">parent_1 = [parent_1];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">ret[key_1] = parent_1 ? parent_1.concat(child) : isArray(child) ? child : [child];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return ret;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Other object hashes.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">strats.props =</span><span class="s2">\n    </span><span class="s1">strats.methods =</span><span class="s2">\n        </span><span class="s1">strats.inject =</span><span class="s2">\n            </span><span class="s1">strats.computed =</span><span class="s2">\n                </span><span class="s1">function (parentVal, childVal, vm, key) {</span><span class="s2">\n                    </span><span class="s1">if (childVal &amp;&amp; process.env.NODE_ENV !== 'production') {</span><span class="s2">\n                        </span><span class="s1">assertObjectType(key, childVal, vm);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">if (!parentVal)</span><span class="s2">\n                        </span><span class="s1">return childVal;</span><span class="s2">\n                    </span><span class="s1">var ret = Object.create(null);</span><span class="s2">\n                    </span><span class="s1">extend(ret, parentVal);</span><span class="s2">\n                    </span><span class="s1">if (childVal)</span><span class="s2">\n                        </span><span class="s1">extend(ret, childVal);</span><span class="s2">\n                    </span><span class="s1">return ret;</span><span class="s2">\n                </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">strats.provide = function (parentVal, childVal) {</span><span class="s2">\n    </span><span class="s1">if (!parentVal)</span><span class="s2">\n        </span><span class="s1">return childVal;</span><span class="s2">\n    </span><span class="s1">return function () {</span><span class="s2">\n        </span><span class="s1">var ret = Object.create(null);</span><span class="s2">\n        </span><span class="s1">mergeData(ret, isFunction(parentVal) ? parentVal.call(this) : parentVal);</span><span class="s2">\n        </span><span class="s1">if (childVal) {</span><span class="s2">\n            </span><span class="s1">mergeData(ret, isFunction(childVal) ? childVal.call(this) : childVal, false // non-recursive</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return ret;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Default strategy.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var defaultStrat = function (parentVal, childVal) {</span><span class="s2">\n    </span><span class="s1">return childVal === undefined ? parentVal : childVal;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Validate component names</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function checkComponents(options) {</span><span class="s2">\n    </span><span class="s1">for (var key in options.components) {</span><span class="s2">\n        </span><span class="s1">validateComponentName(key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function validateComponentName(name) {</span><span class="s2">\n    </span><span class="s1">if (!new RegExp(</span><span class="s2">\&quot;</span><span class="s1">^[a-zA-Z][</span><span class="s2">\\\\</span><span class="s1">-</span><span class="s2">\\\\</span><span class="s1">.0-9_</span><span class="s2">\&quot;</span><span class="s1">.concat(unicodeRegExp.source, </span><span class="s2">\&quot;</span><span class="s1">]*$</span><span class="s2">\&quot;</span><span class="s1">)).test(name)) {</span><span class="s2">\n        </span><span class="s1">warn('Invalid component name: </span><span class="s2">\&quot;</span><span class="s1">' +</span><span class="s2">\n            </span><span class="s1">name +</span><span class="s2">\n            </span><span class="s1">'</span><span class="s2">\&quot;</span><span class="s1">. Component names ' +</span><span class="s2">\n            </span><span class="s1">'should conform to valid custom element name in html5 specification.');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isBuiltInTag(name) || config.isReservedTag(name)) {</span><span class="s2">\n        </span><span class="s1">warn('Do not use built-in or reserved HTML elements as component ' +</span><span class="s2">\n            </span><span class="s1">'id: ' +</span><span class="s2">\n            </span><span class="s1">name);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Ensure all props option syntax are normalized into the</span><span class="s2">\n </span><span class="s1">* Object-based format.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function normalizeProps(options, vm) {</span><span class="s2">\n    </span><span class="s1">var props = options.props;</span><span class="s2">\n    </span><span class="s1">if (!props)</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">var res = {};</span><span class="s2">\n    </span><span class="s1">var i, val, name;</span><span class="s2">\n    </span><span class="s1">if (isArray(props)) {</span><span class="s2">\n        </span><span class="s1">i = props.length;</span><span class="s2">\n        </span><span class="s1">while (i--) {</span><span class="s2">\n            </span><span class="s1">val = props[i];</span><span class="s2">\n            </span><span class="s1">if (typeof val === 'string') {</span><span class="s2">\n                </span><span class="s1">name = camelize(val);</span><span class="s2">\n                </span><span class="s1">res[name] = { type: null };</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n                </span><span class="s1">warn('props must be strings when using array syntax.');</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isPlainObject(props)) {</span><span class="s2">\n        </span><span class="s1">for (var key in props) {</span><span class="s2">\n            </span><span class="s1">val = props[key];</span><span class="s2">\n            </span><span class="s1">name = camelize(key);</span><span class="s2">\n            </span><span class="s1">res[name] = isPlainObject(val) ? val : { type: val };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Invalid value for option </span><span class="s2">\\\&quot;</span><span class="s1">props</span><span class="s2">\\\&quot;</span><span class="s1">: expected an Array or an Object, </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n            \&quot;</span><span class="s1">but got </span><span class="s2">\&quot;</span><span class="s1">.concat(toRawType(props), </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">options.props = res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Normalize all injections into Object-based format</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function normalizeInject(options, vm) {</span><span class="s2">\n    </span><span class="s1">var inject = options.inject;</span><span class="s2">\n    </span><span class="s1">if (!inject)</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">var normalized = (options.inject = {});</span><span class="s2">\n    </span><span class="s1">if (isArray(inject)) {</span><span class="s2">\n        </span><span class="s1">for (var i = 0; i &lt; inject.length; i++) {</span><span class="s2">\n            </span><span class="s1">normalized[inject[i]] = { from: inject[i] };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isPlainObject(inject)) {</span><span class="s2">\n        </span><span class="s1">for (var key in inject) {</span><span class="s2">\n            </span><span class="s1">var val = inject[key];</span><span class="s2">\n            </span><span class="s1">normalized[key] = isPlainObject(val)</span><span class="s2">\n                </span><span class="s1">? extend({ from: key }, val)</span><span class="s2">\n                </span><span class="s1">: { from: val };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Invalid value for option </span><span class="s2">\\\&quot;</span><span class="s1">inject</span><span class="s2">\\\&quot;</span><span class="s1">: expected an Array or an Object, </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n            \&quot;</span><span class="s1">but got </span><span class="s2">\&quot;</span><span class="s1">.concat(toRawType(inject), </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Normalize raw function directives into object format.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function normalizeDirectives$1(options) {</span><span class="s2">\n    </span><span class="s1">var dirs = options.directives;</span><span class="s2">\n    </span><span class="s1">if (dirs) {</span><span class="s2">\n        </span><span class="s1">for (var key in dirs) {</span><span class="s2">\n            </span><span class="s1">var def = dirs[key];</span><span class="s2">\n            </span><span class="s1">if (isFunction(def)) {</span><span class="s2">\n                </span><span class="s1">dirs[key] = { bind: def, update: def };</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function assertObjectType(name, value, vm) {</span><span class="s2">\n    </span><span class="s1">if (!isPlainObject(value)) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Invalid value for option </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">: expected an Object, </span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n            \&quot;</span><span class="s1">but got </span><span class="s2">\&quot;</span><span class="s1">.concat(toRawType(value), </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Merge two option objects into a new one.</span><span class="s2">\n </span><span class="s1">* Core utility used in both instantiation and inheritance.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function mergeOptions(parent, child, vm) {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">checkComponents(child);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isFunction(child)) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error</span><span class="s2">\n        </span><span class="s1">child = child.options;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">normalizeProps(child, vm);</span><span class="s2">\n    </span><span class="s1">normalizeInject(child, vm);</span><span class="s2">\n    </span><span class="s1">normalizeDirectives$1(child);</span><span class="s2">\n    </span><span class="s1">// Apply extends and mixins on the child options,</span><span class="s2">\n    </span><span class="s1">// but only if it is a raw options object that isn't</span><span class="s2">\n    </span><span class="s1">// the result of another mergeOptions call.</span><span class="s2">\n    </span><span class="s1">// Only merged options has the _base property.</span><span class="s2">\n    </span><span class="s1">if (!child._base) {</span><span class="s2">\n        </span><span class="s1">if (child.extends) {</span><span class="s2">\n            </span><span class="s1">parent = mergeOptions(parent, child.extends, vm);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (child.mixins) {</span><span class="s2">\n            </span><span class="s1">for (var i = 0, l = child.mixins.length; i &lt; l; i++) {</span><span class="s2">\n                </span><span class="s1">parent = mergeOptions(parent, child.mixins[i], vm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var options = {};</span><span class="s2">\n    </span><span class="s1">var key;</span><span class="s2">\n    </span><span class="s1">for (key in parent) {</span><span class="s2">\n        </span><span class="s1">mergeField(key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (key in child) {</span><span class="s2">\n        </span><span class="s1">if (!hasOwn(parent, key)) {</span><span class="s2">\n            </span><span class="s1">mergeField(key);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function mergeField(key) {</span><span class="s2">\n        </span><span class="s1">var strat = strats[key] || defaultStrat;</span><span class="s2">\n        </span><span class="s1">options[key] = strat(parent[key], child[key], vm, key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return options;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Resolve an asset.</span><span class="s2">\n </span><span class="s1">* This function is used because child instances need access</span><span class="s2">\n </span><span class="s1">* to assets defined in its ancestor chain.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function resolveAsset(options, type, id, warnMissing) {</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (typeof id !== 'string') {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var assets = options[type];</span><span class="s2">\n    </span><span class="s1">// check local registration variations first</span><span class="s2">\n    </span><span class="s1">if (hasOwn(assets, id))</span><span class="s2">\n        </span><span class="s1">return assets[id];</span><span class="s2">\n    </span><span class="s1">var camelizedId = camelize(id);</span><span class="s2">\n    </span><span class="s1">if (hasOwn(assets, camelizedId))</span><span class="s2">\n        </span><span class="s1">return assets[camelizedId];</span><span class="s2">\n    </span><span class="s1">var PascalCaseId = capitalize(camelizedId);</span><span class="s2">\n    </span><span class="s1">if (hasOwn(assets, PascalCaseId))</span><span class="s2">\n        </span><span class="s1">return assets[PascalCaseId];</span><span class="s2">\n    </span><span class="s1">// fallback to prototype chain</span><span class="s2">\n    </span><span class="s1">var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; warnMissing &amp;&amp; !res) {</span><span class="s2">\n        </span><span class="s1">warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function validateProp(key, propOptions, propsData, vm) {</span><span class="s2">\n    </span><span class="s1">var prop = propOptions[key];</span><span class="s2">\n    </span><span class="s1">var absent = !hasOwn(propsData, key);</span><span class="s2">\n    </span><span class="s1">var value = propsData[key];</span><span class="s2">\n    </span><span class="s1">// boolean casting</span><span class="s2">\n    </span><span class="s1">var booleanIndex = getTypeIndex(Boolean, prop.type);</span><span class="s2">\n    </span><span class="s1">if (booleanIndex &gt; -1) {</span><span class="s2">\n        </span><span class="s1">if (absent &amp;&amp; !hasOwn(prop, 'default')) {</span><span class="s2">\n            </span><span class="s1">value = false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (value === '' || value === hyphenate(key)) {</span><span class="s2">\n            </span><span class="s1">// only cast empty string / same name to boolean if</span><span class="s2">\n            </span><span class="s1">// boolean has higher priority</span><span class="s2">\n            </span><span class="s1">var stringIndex = getTypeIndex(String, prop.type);</span><span class="s2">\n            </span><span class="s1">if (stringIndex &lt; 0 || booleanIndex &lt; stringIndex) {</span><span class="s2">\n                </span><span class="s1">value = true;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// check default value</span><span class="s2">\n    </span><span class="s1">if (value === undefined) {</span><span class="s2">\n        </span><span class="s1">value = getPropDefaultValue(vm, prop, key);</span><span class="s2">\n        </span><span class="s1">// since the default value is a fresh copy,</span><span class="s2">\n        </span><span class="s1">// make sure to observe it.</span><span class="s2">\n        </span><span class="s1">var prevShouldObserve = shouldObserve;</span><span class="s2">\n        </span><span class="s1">toggleObserving(true);</span><span class="s2">\n        </span><span class="s1">observe(value);</span><span class="s2">\n        </span><span class="s1">toggleObserving(prevShouldObserve);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">assertProp(prop, key, value, vm, absent);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return value;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Get the default value of a prop.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function getPropDefaultValue(vm, prop, key) {</span><span class="s2">\n    </span><span class="s1">// no default, return undefined</span><span class="s2">\n    </span><span class="s1">if (!hasOwn(prop, 'default')) {</span><span class="s2">\n        </span><span class="s1">return undefined;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var def = prop.default;</span><span class="s2">\n    </span><span class="s1">// warn against non-factory defaults for Object &amp; Array</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; isObject(def)) {</span><span class="s2">\n        </span><span class="s1">warn('Invalid default value for prop </span><span class="s2">\&quot;</span><span class="s1">' +</span><span class="s2">\n            </span><span class="s1">key +</span><span class="s2">\n            </span><span class="s1">'</span><span class="s2">\&quot;</span><span class="s1">: ' +</span><span class="s2">\n            </span><span class="s1">'Props with type Object/Array must use a factory function ' +</span><span class="s2">\n            </span><span class="s1">'to return the default value.', vm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// the raw prop value was also undefined from previous render,</span><span class="s2">\n    </span><span class="s1">// return previous default value to avoid unnecessary watcher trigger</span><span class="s2">\n    </span><span class="s1">if (vm &amp;&amp;</span><span class="s2">\n        </span><span class="s1">vm.$options.propsData &amp;&amp;</span><span class="s2">\n        </span><span class="s1">vm.$options.propsData[key] === undefined &amp;&amp;</span><span class="s2">\n        </span><span class="s1">vm._props[key] !== undefined) {</span><span class="s2">\n        </span><span class="s1">return vm._props[key];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// call factory function for non-Function types</span><span class="s2">\n    </span><span class="s1">// a value is Function if its prototype is function even across different execution context</span><span class="s2">\n    </span><span class="s1">return isFunction(def) &amp;&amp; getType(prop.type) !== 'Function'</span><span class="s2">\n        </span><span class="s1">? def.call(vm)</span><span class="s2">\n        </span><span class="s1">: def;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Assert whether a prop is valid.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function assertProp(prop, name, value, vm, absent) {</span><span class="s2">\n    </span><span class="s1">if (prop.required &amp;&amp; absent) {</span><span class="s2">\n        </span><span class="s1">warn('Missing required prop: </span><span class="s2">\&quot;</span><span class="s1">' + name + '</span><span class="s2">\&quot;</span><span class="s1">', vm);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (value == null &amp;&amp; !prop.required) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var type = prop.type;</span><span class="s2">\n    </span><span class="s1">var valid = !type || type === true;</span><span class="s2">\n    </span><span class="s1">var expectedTypes = [];</span><span class="s2">\n    </span><span class="s1">if (type) {</span><span class="s2">\n        </span><span class="s1">if (!isArray(type)) {</span><span class="s2">\n            </span><span class="s1">type = [type];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">for (var i = 0; i &lt; type.length &amp;&amp; !valid; i++) {</span><span class="s2">\n            </span><span class="s1">var assertedType = assertType(value, type[i], vm);</span><span class="s2">\n            </span><span class="s1">expectedTypes.push(assertedType.expectedType || '');</span><span class="s2">\n            </span><span class="s1">valid = assertedType.valid;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var haveExpectedTypes = expectedTypes.some(function (t) { return t; });</span><span class="s2">\n    </span><span class="s1">if (!valid &amp;&amp; haveExpectedTypes) {</span><span class="s2">\n        </span><span class="s1">warn(getInvalidTypeMessage(name, value, expectedTypes), vm);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var validator = prop.validator;</span><span class="s2">\n    </span><span class="s1">if (validator) {</span><span class="s2">\n        </span><span class="s1">if (!validator(value)) {</span><span class="s2">\n            </span><span class="s1">warn('Invalid prop: custom validator check failed for prop </span><span class="s2">\&quot;</span><span class="s1">' + name + '</span><span class="s2">\&quot;</span><span class="s1">.', vm);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;</span><span class="s2">\n</span><span class="s1">function assertType(value, type, vm) {</span><span class="s2">\n    </span><span class="s1">var valid;</span><span class="s2">\n    </span><span class="s1">var expectedType = getType(type);</span><span class="s2">\n    </span><span class="s1">if (simpleCheckRE.test(expectedType)) {</span><span class="s2">\n        </span><span class="s1">var t = typeof value;</span><span class="s2">\n        </span><span class="s1">valid = t === expectedType.toLowerCase();</span><span class="s2">\n        </span><span class="s1">// for primitive wrapper objects</span><span class="s2">\n        </span><span class="s1">if (!valid &amp;&amp; t === 'object') {</span><span class="s2">\n            </span><span class="s1">valid = value instanceof type;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (expectedType === 'Object') {</span><span class="s2">\n        </span><span class="s1">valid = isPlainObject(value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (expectedType === 'Array') {</span><span class="s2">\n        </span><span class="s1">valid = isArray(value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">valid = value instanceof type;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">catch (e) {</span><span class="s2">\n            </span><span class="s1">warn('Invalid prop type: </span><span class="s2">\&quot;</span><span class="s1">' + String(type) + '</span><span class="s2">\&quot; </span><span class="s1">is not a constructor', vm);</span><span class="s2">\n            </span><span class="s1">valid = false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">valid: valid,</span><span class="s2">\n        </span><span class="s1">expectedType: expectedType</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var functionTypeCheckRE = /^</span><span class="s2">\\</span><span class="s1">s*function (</span><span class="s2">\\</span><span class="s1">w+)/;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Use function string name to check built-in types,</span><span class="s2">\n </span><span class="s1">* because a simple equality check will fail when running</span><span class="s2">\n </span><span class="s1">* across different vms / iframes.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function getType(fn) {</span><span class="s2">\n    </span><span class="s1">var match = fn &amp;&amp; fn.toString().match(functionTypeCheckRE);</span><span class="s2">\n    </span><span class="s1">return match ? match[1] : '';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isSameType(a, b) {</span><span class="s2">\n    </span><span class="s1">return getType(a) === getType(b);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getTypeIndex(type, expectedTypes) {</span><span class="s2">\n    </span><span class="s1">if (!isArray(expectedTypes)) {</span><span class="s2">\n        </span><span class="s1">return isSameType(expectedTypes, type) ? 0 : -1;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (var i = 0, len = expectedTypes.length; i &lt; len; i++) {</span><span class="s2">\n        </span><span class="s1">if (isSameType(expectedTypes[i], type)) {</span><span class="s2">\n            </span><span class="s1">return i;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return -1;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getInvalidTypeMessage(name, value, expectedTypes) {</span><span class="s2">\n    </span><span class="s1">var message = </span><span class="s2">\&quot;</span><span class="s1">Invalid prop: type check failed for prop </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n        \&quot; </span><span class="s1">Expected </span><span class="s2">\&quot;</span><span class="s1">.concat(expectedTypes.map(capitalize).join(', '));</span><span class="s2">\n    </span><span class="s1">var expectedType = expectedTypes[0];</span><span class="s2">\n    </span><span class="s1">var receivedType = toRawType(value);</span><span class="s2">\n    </span><span class="s1">// check if we need to specify expected value</span><span class="s2">\n    </span><span class="s1">if (expectedTypes.length === 1 &amp;&amp;</span><span class="s2">\n        </span><span class="s1">isExplicable(expectedType) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">isExplicable(typeof value) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!isBoolean(expectedType, receivedType)) {</span><span class="s2">\n        </span><span class="s1">message += </span><span class="s2">\&quot; </span><span class="s1">with value </span><span class="s2">\&quot;</span><span class="s1">.concat(styleValue(value, expectedType));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">message += </span><span class="s2">\&quot;</span><span class="s1">, got </span><span class="s2">\&quot;</span><span class="s1">.concat(receivedType, </span><span class="s2">\&quot; \&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">// check if we need to specify received value</span><span class="s2">\n    </span><span class="s1">if (isExplicable(receivedType)) {</span><span class="s2">\n        </span><span class="s1">message += </span><span class="s2">\&quot;</span><span class="s1">with value </span><span class="s2">\&quot;</span><span class="s1">.concat(styleValue(value, receivedType), </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return message;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function styleValue(value, type) {</span><span class="s2">\n    </span><span class="s1">if (type === 'String') {</span><span class="s2">\n        </span><span class="s1">return </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">.concat(value, </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (type === 'Number') {</span><span class="s2">\n        </span><span class="s1">return </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(Number(value));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">return </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];</span><span class="s2">\n</span><span class="s1">function isExplicable(value) {</span><span class="s2">\n    </span><span class="s1">return EXPLICABLE_TYPES.some(function (elem) { return value.toLowerCase() === elem; });</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isBoolean() {</span><span class="s2">\n    </span><span class="s1">var args = [];</span><span class="s2">\n    </span><span class="s1">for (var _i = 0; _i &lt; arguments.length; _i++) {</span><span class="s2">\n        </span><span class="s1">args[_i] = arguments[_i];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; });</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/* not type checking this file because flow doesn't play well with Proxy */</span><span class="s2">\n</span><span class="s1">var initProxy;</span><span class="s2">\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">var allowedGlobals_1 = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' +</span><span class="s2">\n        </span><span class="s1">'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +</span><span class="s2">\n        </span><span class="s1">'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +</span><span class="s2">\n        </span><span class="s1">'require' // for Webpack/Browserify</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">var warnNonPresent_1 = function (target, key) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Property or method </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is not defined on the instance but </span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n            </span><span class="s1">'referenced during render. Make sure that this property is reactive, ' +</span><span class="s2">\n            </span><span class="s1">'either in the data option, or for class-based components, by ' +</span><span class="s2">\n            </span><span class="s1">'initializing the property. ' +</span><span class="s2">\n            </span><span class="s1">'See: https://v2.vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var warnReservedPrefix_1 = function (target, key) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Property </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">must be accessed with </span><span class="s2">\\\&quot;</span><span class="s1">$data.</span><span class="s2">\&quot;</span><span class="s1">).concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">because </span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n            </span><span class="s1">'properties starting with </span><span class="s2">\&quot;</span><span class="s1">$</span><span class="s2">\&quot; </span><span class="s1">or </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot; </span><span class="s1">are not proxied in the Vue instance to ' +</span><span class="s2">\n            </span><span class="s1">'prevent conflicts with Vue internals. ' +</span><span class="s2">\n            </span><span class="s1">'See: https://v2.vuejs.org/v2/api/#data', target);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var hasProxy_1 = typeof Proxy !== 'undefined' &amp;&amp; isNative(Proxy);</span><span class="s2">\n    </span><span class="s1">if (hasProxy_1) {</span><span class="s2">\n        </span><span class="s1">var isBuiltInModifier_1 = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');</span><span class="s2">\n        </span><span class="s1">config.keyCodes = new Proxy(config.keyCodes, {</span><span class="s2">\n            </span><span class="s1">set: function (target, key, value) {</span><span class="s2">\n                </span><span class="s1">if (isBuiltInModifier_1(key)) {</span><span class="s2">\n                    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Avoid overwriting built-in modifier in config.keyCodes: .</span><span class="s2">\&quot;</span><span class="s1">.concat(key));</span><span class="s2">\n                    </span><span class="s1">return false;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">target[key] = value;</span><span class="s2">\n                    </span><span class="s1">return true;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var hasHandler_1 = {</span><span class="s2">\n        </span><span class="s1">has: function (target, key) {</span><span class="s2">\n            </span><span class="s1">var has = key in target;</span><span class="s2">\n            </span><span class="s1">var isAllowed = allowedGlobals_1(key) ||</span><span class="s2">\n                </span><span class="s1">(typeof key === 'string' &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">key.charAt(0) === '_' &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">!(key in target.$data));</span><span class="s2">\n            </span><span class="s1">if (!has &amp;&amp; !isAllowed) {</span><span class="s2">\n                </span><span class="s1">if (key in target.$data)</span><span class="s2">\n                    </span><span class="s1">warnReservedPrefix_1(target, key);</span><span class="s2">\n                </span><span class="s1">else</span><span class="s2">\n                    </span><span class="s1">warnNonPresent_1(target, key);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return has || !isAllowed;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var getHandler_1 = {</span><span class="s2">\n        </span><span class="s1">get: function (target, key) {</span><span class="s2">\n            </span><span class="s1">if (typeof key === 'string' &amp;&amp; !(key in target)) {</span><span class="s2">\n                </span><span class="s1">if (key in target.$data)</span><span class="s2">\n                    </span><span class="s1">warnReservedPrefix_1(target, key);</span><span class="s2">\n                </span><span class="s1">else</span><span class="s2">\n                    </span><span class="s1">warnNonPresent_1(target, key);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return target[key];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">initProxy = function initProxy(vm) {</span><span class="s2">\n        </span><span class="s1">if (hasProxy_1) {</span><span class="s2">\n            </span><span class="s1">// determine which proxy handler to use</span><span class="s2">\n            </span><span class="s1">var options = vm.$options;</span><span class="s2">\n            </span><span class="s1">var handlers = options.render &amp;&amp; options.render._withStripped ? getHandler_1 : hasHandler_1;</span><span class="s2">\n            </span><span class="s1">vm._renderProxy = new Proxy(vm, handlers);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">vm._renderProxy = vm;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var sharedPropertyDefinition = {</span><span class="s2">\n    </span><span class="s1">enumerable: true,</span><span class="s2">\n    </span><span class="s1">configurable: true,</span><span class="s2">\n    </span><span class="s1">get: noop,</span><span class="s2">\n    </span><span class="s1">set: noop</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function proxy(target, sourceKey, key) {</span><span class="s2">\n    </span><span class="s1">sharedPropertyDefinition.get = function proxyGetter() {</span><span class="s2">\n        </span><span class="s1">return this[sourceKey][key];</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">sharedPropertyDefinition.set = function proxySetter(val) {</span><span class="s2">\n        </span><span class="s1">this[sourceKey][key] = val;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(target, key, sharedPropertyDefinition);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initState(vm) {</span><span class="s2">\n    </span><span class="s1">var opts = vm.$options;</span><span class="s2">\n    </span><span class="s1">if (opts.props)</span><span class="s2">\n        </span><span class="s1">initProps$1(vm, opts.props);</span><span class="s2">\n    </span><span class="s1">// Composition API</span><span class="s2">\n    </span><span class="s1">initSetup(vm);</span><span class="s2">\n    </span><span class="s1">if (opts.methods)</span><span class="s2">\n        </span><span class="s1">initMethods(vm, opts.methods);</span><span class="s2">\n    </span><span class="s1">if (opts.data) {</span><span class="s2">\n        </span><span class="s1">initData(vm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">var ob = observe((vm._data = {}));</span><span class="s2">\n        </span><span class="s1">ob &amp;&amp; ob.vmCount++;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (opts.computed)</span><span class="s2">\n        </span><span class="s1">initComputed$1(vm, opts.computed);</span><span class="s2">\n    </span><span class="s1">if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {</span><span class="s2">\n        </span><span class="s1">initWatch(vm, opts.watch);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initProps$1(vm, propsOptions) {</span><span class="s2">\n    </span><span class="s1">var propsData = vm.$options.propsData || {};</span><span class="s2">\n    </span><span class="s1">var props = (vm._props = shallowReactive({}));</span><span class="s2">\n    </span><span class="s1">// cache prop keys so that future props updates can iterate using Array</span><span class="s2">\n    </span><span class="s1">// instead of dynamic object key enumeration.</span><span class="s2">\n    </span><span class="s1">var keys = (vm.$options._propKeys = []);</span><span class="s2">\n    </span><span class="s1">var isRoot = !vm.$parent;</span><span class="s2">\n    </span><span class="s1">// root instance props should be converted</span><span class="s2">\n    </span><span class="s1">if (!isRoot) {</span><span class="s2">\n        </span><span class="s1">toggleObserving(false);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var _loop_1 = function (key) {</span><span class="s2">\n        </span><span class="s1">keys.push(key);</span><span class="s2">\n        </span><span class="s1">var value = validateProp(key, propsOptions, propsData, vm);</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">var hyphenatedKey = hyphenate(key);</span><span class="s2">\n            </span><span class="s1">if (isReservedAttribute(hyphenatedKey) ||</span><span class="s2">\n                </span><span class="s1">config.isReservedAttr(hyphenatedKey)) {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">.concat(hyphenatedKey, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is a reserved attribute and cannot be used as component prop.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">defineReactive(props, key, value, function () {</span><span class="s2">\n                </span><span class="s1">if (!isRoot &amp;&amp; !isUpdatingChildComponent) {</span><span class="s2">\n                    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Avoid mutating a prop directly since the value will be </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                        \&quot;</span><span class="s1">overwritten whenever the parent component re-renders. </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                        \&quot;</span><span class="s1">Instead, use a data or computed property based on the prop's </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                        \&quot;</span><span class="s1">value. Prop being mutated: </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">), vm);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">defineReactive(props, key, value);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// static props are already proxied on the component's prototype</span><span class="s2">\n        </span><span class="s1">// during Vue.extend(). We only need to proxy props defined at</span><span class="s2">\n        </span><span class="s1">// instantiation here.</span><span class="s2">\n        </span><span class="s1">if (!(key in vm)) {</span><span class="s2">\n            </span><span class="s1">proxy(vm, </span><span class="s2">\&quot;</span><span class="s1">_props</span><span class="s2">\&quot;</span><span class="s1">, key);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">for (var key in propsOptions) {</span><span class="s2">\n        </span><span class="s1">_loop_1(key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">toggleObserving(true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initData(vm) {</span><span class="s2">\n    </span><span class="s1">var data = vm.$options.data;</span><span class="s2">\n    </span><span class="s1">data = vm._data = isFunction(data) ? getData(data, vm) : data || {};</span><span class="s2">\n    </span><span class="s1">if (!isPlainObject(data)) {</span><span class="s2">\n        </span><span class="s1">data = {};</span><span class="s2">\n        </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n            </span><span class="s1">warn('data functions should return an object:</span><span class="s2">\\</span><span class="s1">n' +</span><span class="s2">\n                </span><span class="s1">'https://v2.vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// proxy data on instance</span><span class="s2">\n    </span><span class="s1">var keys = Object.keys(data);</span><span class="s2">\n    </span><span class="s1">var props = vm.$options.props;</span><span class="s2">\n    </span><span class="s1">var methods = vm.$options.methods;</span><span class="s2">\n    </span><span class="s1">var i = keys.length;</span><span class="s2">\n    </span><span class="s1">while (i--) {</span><span class="s2">\n        </span><span class="s1">var key = keys[i];</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">if (methods &amp;&amp; hasOwn(methods, key)) {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Method </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">has already been defined as a data property.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (props &amp;&amp; hasOwn(props, key)) {</span><span class="s2">\n            </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">The data property </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is already declared as a prop. </span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n                    \&quot;</span><span class="s1">Use prop default value instead.</span><span class="s2">\&quot;</span><span class="s1">, vm);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (!isReserved(key)) {</span><span class="s2">\n            </span><span class="s1">proxy(vm, </span><span class="s2">\&quot;</span><span class="s1">_data</span><span class="s2">\&quot;</span><span class="s1">, key);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// observe data</span><span class="s2">\n    </span><span class="s1">var ob = observe(data);</span><span class="s2">\n    </span><span class="s1">ob &amp;&amp; ob.vmCount++;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getData(data, vm) {</span><span class="s2">\n    </span><span class="s1">// #7573 disable dep collection when invoking data getters</span><span class="s2">\n    </span><span class="s1">pushTarget();</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">return data.call(vm, vm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">catch (e) {</span><span class="s2">\n        </span><span class="s1">handleError(e, vm, </span><span class="s2">\&quot;</span><span class="s1">data()</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return {};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">finally {</span><span class="s2">\n        </span><span class="s1">popTarget();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var computedWatcherOptions = { lazy: true };</span><span class="s2">\n</span><span class="s1">function initComputed$1(vm, computed) {</span><span class="s2">\n    </span><span class="s1">// $flow-disable-line</span><span class="s2">\n    </span><span class="s1">var watchers = (vm._computedWatchers = Object.create(null));</span><span class="s2">\n    </span><span class="s1">// computed properties are just getters during SSR</span><span class="s2">\n    </span><span class="s1">var isSSR = isServerRendering();</span><span class="s2">\n    </span><span class="s1">for (var key in computed) {</span><span class="s2">\n        </span><span class="s1">var userDef = computed[key];</span><span class="s2">\n        </span><span class="s1">var getter = isFunction(userDef) ? userDef : userDef.get;</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; getter == null) {</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Getter is missing for computed property </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (!isSSR) {</span><span class="s2">\n            </span><span class="s1">// create internal watcher for the computed property.</span><span class="s2">\n            </span><span class="s1">watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// component-defined computed properties are already defined on the</span><span class="s2">\n        </span><span class="s1">// component prototype. We only need to define computed properties defined</span><span class="s2">\n        </span><span class="s1">// at instantiation here.</span><span class="s2">\n        </span><span class="s1">if (!(key in vm)) {</span><span class="s2">\n            </span><span class="s1">defineComputed(vm, key, userDef);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">if (key in vm.$data) {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">The computed property </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is already defined in data.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (vm.$options.props &amp;&amp; key in vm.$options.props) {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">The computed property </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is already defined as a prop.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (vm.$options.methods &amp;&amp; key in vm.$options.methods) {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">The computed property </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is already defined as a method.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function defineComputed(target, key, userDef) {</span><span class="s2">\n    </span><span class="s1">var shouldCache = !isServerRendering();</span><span class="s2">\n    </span><span class="s1">if (isFunction(userDef)) {</span><span class="s2">\n        </span><span class="s1">sharedPropertyDefinition.get = shouldCache</span><span class="s2">\n            </span><span class="s1">? createComputedGetter(key)</span><span class="s2">\n            </span><span class="s1">: createGetterInvoker(userDef);</span><span class="s2">\n        </span><span class="s1">sharedPropertyDefinition.set = noop;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">sharedPropertyDefinition.get = userDef.get</span><span class="s2">\n            </span><span class="s1">? shouldCache &amp;&amp; userDef.cache !== false</span><span class="s2">\n                </span><span class="s1">? createComputedGetter(key)</span><span class="s2">\n                </span><span class="s1">: createGetterInvoker(userDef.get)</span><span class="s2">\n            </span><span class="s1">: noop;</span><span class="s2">\n        </span><span class="s1">sharedPropertyDefinition.set = userDef.set || noop;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; sharedPropertyDefinition.set === noop) {</span><span class="s2">\n        </span><span class="s1">sharedPropertyDefinition.set = function () {</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Computed property </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">was assigned to but it has no setter.</span><span class="s2">\&quot;</span><span class="s1">), this);</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(target, key, sharedPropertyDefinition);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createComputedGetter(key) {</span><span class="s2">\n    </span><span class="s1">return function computedGetter() {</span><span class="s2">\n        </span><span class="s1">var watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key];</span><span class="s2">\n        </span><span class="s1">if (watcher) {</span><span class="s2">\n            </span><span class="s1">if (watcher.dirty) {</span><span class="s2">\n                </span><span class="s1">watcher.evaluate();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (Dep.target) {</span><span class="s2">\n                </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; Dep.target.onTrack) {</span><span class="s2">\n                    </span><span class="s1">Dep.target.onTrack({</span><span class="s2">\n                        </span><span class="s1">effect: Dep.target,</span><span class="s2">\n                        </span><span class="s1">target: this,</span><span class="s2">\n                        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.GET */,</span><span class="s2">\n                        </span><span class="s1">key: key</span><span class="s2">\n                    </span><span class="s1">});</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">watcher.depend();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return watcher.value;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createGetterInvoker(fn) {</span><span class="s2">\n    </span><span class="s1">return function computedGetter() {</span><span class="s2">\n        </span><span class="s1">return fn.call(this, this);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initMethods(vm, methods) {</span><span class="s2">\n    </span><span class="s1">var props = vm.$options.props;</span><span class="s2">\n    </span><span class="s1">for (var key in methods) {</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">if (typeof methods[key] !== 'function') {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Method </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">has type </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">).concat(typeof methods[key], </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">in the component definition. </span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n                    \&quot;</span><span class="s1">Did you reference the function correctly?</span><span class="s2">\&quot;</span><span class="s1">, vm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (props &amp;&amp; hasOwn(props, key)) {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Method </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">has already been defined as a prop.</span><span class="s2">\&quot;</span><span class="s1">), vm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (key in vm &amp;&amp; isReserved(key)) {</span><span class="s2">\n                </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Method </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">conflicts with an existing Vue instance method. </span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n                    \&quot;</span><span class="s1">Avoid defining component methods that start with _ or $.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initWatch(vm, watch) {</span><span class="s2">\n    </span><span class="s1">for (var key in watch) {</span><span class="s2">\n        </span><span class="s1">var handler = watch[key];</span><span class="s2">\n        </span><span class="s1">if (isArray(handler)) {</span><span class="s2">\n            </span><span class="s1">for (var i = 0; i &lt; handler.length; i++) {</span><span class="s2">\n                </span><span class="s1">createWatcher(vm, key, handler[i]);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">createWatcher(vm, key, handler);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createWatcher(vm, expOrFn, handler, options) {</span><span class="s2">\n    </span><span class="s1">if (isPlainObject(handler)) {</span><span class="s2">\n        </span><span class="s1">options = handler;</span><span class="s2">\n        </span><span class="s1">handler = handler.handler;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (typeof handler === 'string') {</span><span class="s2">\n        </span><span class="s1">handler = vm[handler];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return vm.$watch(expOrFn, handler, options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stateMixin(Vue) {</span><span class="s2">\n    </span><span class="s1">// flow somehow has problems with directly declared definition object</span><span class="s2">\n    </span><span class="s1">// when using Object.defineProperty, so we have to procedurally build up</span><span class="s2">\n    </span><span class="s1">// the object here.</span><span class="s2">\n    </span><span class="s1">var dataDef = {};</span><span class="s2">\n    </span><span class="s1">dataDef.get = function () {</span><span class="s2">\n        </span><span class="s1">return this._data;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var propsDef = {};</span><span class="s2">\n    </span><span class="s1">propsDef.get = function () {</span><span class="s2">\n        </span><span class="s1">return this._props;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">dataDef.set = function () {</span><span class="s2">\n            </span><span class="s1">warn('Avoid replacing instance root $data. ' +</span><span class="s2">\n                </span><span class="s1">'Use nested data properties instead.', this);</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">propsDef.set = function () {</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">$props is readonly.</span><span class="s2">\&quot;</span><span class="s1">, this);</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(Vue.prototype, '$data', dataDef);</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(Vue.prototype, '$props', propsDef);</span><span class="s2">\n    </span><span class="s1">Vue.prototype.$set = set;</span><span class="s2">\n    </span><span class="s1">Vue.prototype.$delete = del;</span><span class="s2">\n    </span><span class="s1">Vue.prototype.$watch = function (expOrFn, cb, options) {</span><span class="s2">\n        </span><span class="s1">var vm = this;</span><span class="s2">\n        </span><span class="s1">if (isPlainObject(cb)) {</span><span class="s2">\n            </span><span class="s1">return createWatcher(vm, expOrFn, cb, options);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">options = options || {};</span><span class="s2">\n        </span><span class="s1">options.user = true;</span><span class="s2">\n        </span><span class="s1">var watcher = new Watcher(vm, expOrFn, cb, options);</span><span class="s2">\n        </span><span class="s1">if (options.immediate) {</span><span class="s2">\n            </span><span class="s1">var info = </span><span class="s2">\&quot;</span><span class="s1">callback for immediate watcher </span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(watcher.expression, </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">pushTarget();</span><span class="s2">\n            </span><span class="s1">invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);</span><span class="s2">\n            </span><span class="s1">popTarget();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return function unwatchFn() {</span><span class="s2">\n            </span><span class="s1">watcher.teardown();</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var uid = 0;</span><span class="s2">\n</span><span class="s1">function initMixin$1(Vue) {</span><span class="s2">\n    </span><span class="s1">Vue.prototype._init = function (options) {</span><span class="s2">\n        </span><span class="s1">var vm = this;</span><span class="s2">\n        </span><span class="s1">// a uid</span><span class="s2">\n        </span><span class="s1">vm._uid = uid++;</span><span class="s2">\n        </span><span class="s1">var startTag, endTag;</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {</span><span class="s2">\n            </span><span class="s1">startTag = </span><span class="s2">\&quot;</span><span class="s1">vue-perf-start:</span><span class="s2">\&quot;</span><span class="s1">.concat(vm._uid);</span><span class="s2">\n            </span><span class="s1">endTag = </span><span class="s2">\&quot;</span><span class="s1">vue-perf-end:</span><span class="s2">\&quot;</span><span class="s1">.concat(vm._uid);</span><span class="s2">\n            </span><span class="s1">mark(startTag);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// a flag to mark this as a Vue instance without having to do instanceof</span><span class="s2">\n        </span><span class="s1">// check</span><span class="s2">\n        </span><span class="s1">vm._isVue = true;</span><span class="s2">\n        </span><span class="s1">// avoid instances from being observed</span><span class="s2">\n        </span><span class="s1">vm.__v_skip = true;</span><span class="s2">\n        </span><span class="s1">// effect scope</span><span class="s2">\n        </span><span class="s1">vm._scope = new EffectScope(true /* detached */);</span><span class="s2">\n        </span><span class="s1">vm._scope._vm = true;</span><span class="s2">\n        </span><span class="s1">// merge options</span><span class="s2">\n        </span><span class="s1">if (options &amp;&amp; options._isComponent) {</span><span class="s2">\n            </span><span class="s1">// optimize internal component instantiation</span><span class="s2">\n            </span><span class="s1">// since dynamic options merging is pretty slow, and none of the</span><span class="s2">\n            </span><span class="s1">// internal component options needs special treatment.</span><span class="s2">\n            </span><span class="s1">initInternalComponent(vm, options);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">initProxy(vm);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">vm._renderProxy = vm;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// expose real self</span><span class="s2">\n        </span><span class="s1">vm._self = vm;</span><span class="s2">\n        </span><span class="s1">initLifecycle(vm);</span><span class="s2">\n        </span><span class="s1">initEvents(vm);</span><span class="s2">\n        </span><span class="s1">initRender(vm);</span><span class="s2">\n        </span><span class="s1">callHook$1(vm, 'beforeCreate', undefined, false /* setContext */);</span><span class="s2">\n        </span><span class="s1">initInjections(vm); // resolve injections before data/props</span><span class="s2">\n        </span><span class="s1">initState(vm);</span><span class="s2">\n        </span><span class="s1">initProvide(vm); // resolve provide after data/props</span><span class="s2">\n        </span><span class="s1">callHook$1(vm, 'created');</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {</span><span class="s2">\n            </span><span class="s1">vm._name = formatComponentName(vm, false);</span><span class="s2">\n            </span><span class="s1">mark(endTag);</span><span class="s2">\n            </span><span class="s1">measure(</span><span class="s2">\&quot;</span><span class="s1">vue </span><span class="s2">\&quot;</span><span class="s1">.concat(vm._name, </span><span class="s2">\&quot; </span><span class="s1">init</span><span class="s2">\&quot;</span><span class="s1">), startTag, endTag);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (vm.$options.el) {</span><span class="s2">\n            </span><span class="s1">vm.$mount(vm.$options.el);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initInternalComponent(vm, options) {</span><span class="s2">\n    </span><span class="s1">var opts = (vm.$options = Object.create(vm.constructor.options));</span><span class="s2">\n    </span><span class="s1">// doing this because it's faster than dynamic enumeration.</span><span class="s2">\n    </span><span class="s1">var parentVnode = options._parentVnode;</span><span class="s2">\n    </span><span class="s1">opts.parent = options.parent;</span><span class="s2">\n    </span><span class="s1">opts._parentVnode = parentVnode;</span><span class="s2">\n    </span><span class="s1">var vnodeComponentOptions = parentVnode.componentOptions;</span><span class="s2">\n    </span><span class="s1">opts.propsData = vnodeComponentOptions.propsData;</span><span class="s2">\n    </span><span class="s1">opts._parentListeners = vnodeComponentOptions.listeners;</span><span class="s2">\n    </span><span class="s1">opts._renderChildren = vnodeComponentOptions.children;</span><span class="s2">\n    </span><span class="s1">opts._componentTag = vnodeComponentOptions.tag;</span><span class="s2">\n    </span><span class="s1">if (options.render) {</span><span class="s2">\n        </span><span class="s1">opts.render = options.render;</span><span class="s2">\n        </span><span class="s1">opts.staticRenderFns = options.staticRenderFns;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveConstructorOptions(Ctor) {</span><span class="s2">\n    </span><span class="s1">var options = Ctor.options;</span><span class="s2">\n    </span><span class="s1">if (Ctor.super) {</span><span class="s2">\n        </span><span class="s1">var superOptions = resolveConstructorOptions(Ctor.super);</span><span class="s2">\n        </span><span class="s1">var cachedSuperOptions = Ctor.superOptions;</span><span class="s2">\n        </span><span class="s1">if (superOptions !== cachedSuperOptions) {</span><span class="s2">\n            </span><span class="s1">// super option changed,</span><span class="s2">\n            </span><span class="s1">// need to resolve new options.</span><span class="s2">\n            </span><span class="s1">Ctor.superOptions = superOptions;</span><span class="s2">\n            </span><span class="s1">// check if there are any late-modified/attached options (#4976)</span><span class="s2">\n            </span><span class="s1">var modifiedOptions = resolveModifiedOptions(Ctor);</span><span class="s2">\n            </span><span class="s1">// update base extend options</span><span class="s2">\n            </span><span class="s1">if (modifiedOptions) {</span><span class="s2">\n                </span><span class="s1">extend(Ctor.extendOptions, modifiedOptions);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);</span><span class="s2">\n            </span><span class="s1">if (options.name) {</span><span class="s2">\n                </span><span class="s1">options.components[options.name] = Ctor;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return options;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveModifiedOptions(Ctor) {</span><span class="s2">\n    </span><span class="s1">var modified;</span><span class="s2">\n    </span><span class="s1">var latest = Ctor.options;</span><span class="s2">\n    </span><span class="s1">var sealed = Ctor.sealedOptions;</span><span class="s2">\n    </span><span class="s1">for (var key in latest) {</span><span class="s2">\n        </span><span class="s1">if (latest[key] !== sealed[key]) {</span><span class="s2">\n            </span><span class="s1">if (!modified)</span><span class="s2">\n                </span><span class="s1">modified = {};</span><span class="s2">\n            </span><span class="s1">modified[key] = latest[key];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return modified;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function Vue(options) {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue)) {</span><span class="s2">\n        </span><span class="s1">warn('Vue is a constructor and should be called with the `new` keyword');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this._init(options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">//@ts-expect-error Vue has function type</span><span class="s2">\n</span><span class="s1">initMixin$1(Vue);</span><span class="s2">\n</span><span class="s1">//@ts-expect-error Vue has function type</span><span class="s2">\n</span><span class="s1">stateMixin(Vue);</span><span class="s2">\n</span><span class="s1">//@ts-expect-error Vue has function type</span><span class="s2">\n</span><span class="s1">eventsMixin(Vue);</span><span class="s2">\n</span><span class="s1">//@ts-expect-error Vue has function type</span><span class="s2">\n</span><span class="s1">lifecycleMixin(Vue);</span><span class="s2">\n</span><span class="s1">//@ts-expect-error Vue has function type</span><span class="s2">\n</span><span class="s1">renderMixin(Vue);</span><span class="s2">\n\n</span><span class="s1">function initUse(Vue) {</span><span class="s2">\n    </span><span class="s1">Vue.use = function (plugin) {</span><span class="s2">\n        </span><span class="s1">var installedPlugins = this._installedPlugins || (this._installedPlugins = []);</span><span class="s2">\n        </span><span class="s1">if (installedPlugins.indexOf(plugin) &gt; -1) {</span><span class="s2">\n            </span><span class="s1">return this;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// additional parameters</span><span class="s2">\n        </span><span class="s1">var args = toArray(arguments, 1);</span><span class="s2">\n        </span><span class="s1">args.unshift(this);</span><span class="s2">\n        </span><span class="s1">if (isFunction(plugin.install)) {</span><span class="s2">\n            </span><span class="s1">plugin.install.apply(plugin, args);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (isFunction(plugin)) {</span><span class="s2">\n            </span><span class="s1">plugin.apply(null, args);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">installedPlugins.push(plugin);</span><span class="s2">\n        </span><span class="s1">return this;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function initMixin(Vue) {</span><span class="s2">\n    </span><span class="s1">Vue.mixin = function (mixin) {</span><span class="s2">\n        </span><span class="s1">this.options = mergeOptions(this.options, mixin);</span><span class="s2">\n        </span><span class="s1">return this;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function initExtend(Vue) {</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Each instance constructor, including Vue, has a unique</span><span class="s2">\n     </span><span class="s1">* cid. This enables us to create wrapped </span><span class="s2">\&quot;</span><span class="s1">child</span><span class="s2">\n     </span><span class="s1">* constructors</span><span class="s2">\&quot; </span><span class="s1">for prototypal inheritance and cache them.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">Vue.cid = 0;</span><span class="s2">\n    </span><span class="s1">var cid = 1;</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Class inheritance</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">Vue.extend = function (extendOptions) {</span><span class="s2">\n        </span><span class="s1">extendOptions = extendOptions || {};</span><span class="s2">\n        </span><span class="s1">var Super = this;</span><span class="s2">\n        </span><span class="s1">var SuperId = Super.cid;</span><span class="s2">\n        </span><span class="s1">var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});</span><span class="s2">\n        </span><span class="s1">if (cachedCtors[SuperId]) {</span><span class="s2">\n            </span><span class="s1">return cachedCtors[SuperId];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var name = getComponentName(extendOptions) || getComponentName(Super.options);</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; name) {</span><span class="s2">\n            </span><span class="s1">validateComponentName(name);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var Sub = function VueComponent(options) {</span><span class="s2">\n            </span><span class="s1">this._init(options);</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">Sub.prototype = Object.create(Super.prototype);</span><span class="s2">\n        </span><span class="s1">Sub.prototype.constructor = Sub;</span><span class="s2">\n        </span><span class="s1">Sub.cid = cid++;</span><span class="s2">\n        </span><span class="s1">Sub.options = mergeOptions(Super.options, extendOptions);</span><span class="s2">\n        </span><span class="s1">Sub['super'] = Super;</span><span class="s2">\n        </span><span class="s1">// For props and computed properties, we define the proxy getters on</span><span class="s2">\n        </span><span class="s1">// the Vue instances at extension time, on the extended prototype. This</span><span class="s2">\n        </span><span class="s1">// avoids Object.defineProperty calls for each instance created.</span><span class="s2">\n        </span><span class="s1">if (Sub.options.props) {</span><span class="s2">\n            </span><span class="s1">initProps(Sub);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (Sub.options.computed) {</span><span class="s2">\n            </span><span class="s1">initComputed(Sub);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// allow further extension/mixin/plugin usage</span><span class="s2">\n        </span><span class="s1">Sub.extend = Super.extend;</span><span class="s2">\n        </span><span class="s1">Sub.mixin = Super.mixin;</span><span class="s2">\n        </span><span class="s1">Sub.use = Super.use;</span><span class="s2">\n        </span><span class="s1">// create asset registers, so extended classes</span><span class="s2">\n        </span><span class="s1">// can have their private assets too.</span><span class="s2">\n        </span><span class="s1">ASSET_TYPES.forEach(function (type) {</span><span class="s2">\n            </span><span class="s1">Sub[type] = Super[type];</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">// enable recursive self-lookup</span><span class="s2">\n        </span><span class="s1">if (name) {</span><span class="s2">\n            </span><span class="s1">Sub.options.components[name] = Sub;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// keep a reference to the super options at extension time.</span><span class="s2">\n        </span><span class="s1">// later at instantiation we can check if Super's options have</span><span class="s2">\n        </span><span class="s1">// been updated.</span><span class="s2">\n        </span><span class="s1">Sub.superOptions = Super.options;</span><span class="s2">\n        </span><span class="s1">Sub.extendOptions = extendOptions;</span><span class="s2">\n        </span><span class="s1">Sub.sealedOptions = extend({}, Sub.options);</span><span class="s2">\n        </span><span class="s1">// cache constructor</span><span class="s2">\n        </span><span class="s1">cachedCtors[SuperId] = Sub;</span><span class="s2">\n        </span><span class="s1">return Sub;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initProps(Comp) {</span><span class="s2">\n    </span><span class="s1">var props = Comp.options.props;</span><span class="s2">\n    </span><span class="s1">for (var key in props) {</span><span class="s2">\n        </span><span class="s1">proxy(Comp.prototype, </span><span class="s2">\&quot;</span><span class="s1">_props</span><span class="s2">\&quot;</span><span class="s1">, key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function initComputed(Comp) {</span><span class="s2">\n    </span><span class="s1">var computed = Comp.options.computed;</span><span class="s2">\n    </span><span class="s1">for (var key in computed) {</span><span class="s2">\n        </span><span class="s1">defineComputed(Comp.prototype, key, computed[key]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function initAssetRegisters(Vue) {</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Create asset registration methods.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">ASSET_TYPES.forEach(function (type) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error function is not exact same type</span><span class="s2">\n        </span><span class="s1">Vue[type] = function (id, definition) {</span><span class="s2">\n            </span><span class="s1">if (!definition) {</span><span class="s2">\n                </span><span class="s1">return this.options[type + 's'][id];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n                </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; type === 'component') {</span><span class="s2">\n                    </span><span class="s1">validateComponentName(id);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (type === 'component' &amp;&amp; isPlainObject(definition)) {</span><span class="s2">\n                    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n                    </span><span class="s1">definition.name = definition.name || id;</span><span class="s2">\n                    </span><span class="s1">definition = this.options._base.extend(definition);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (type === 'directive' &amp;&amp; isFunction(definition)) {</span><span class="s2">\n                    </span><span class="s1">definition = { bind: definition, update: definition };</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">this.options[type + 's'][id] = definition;</span><span class="s2">\n                </span><span class="s1">return definition;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function _getComponentName(opts) {</span><span class="s2">\n    </span><span class="s1">return opts &amp;&amp; (getComponentName(opts.Ctor.options) || opts.tag);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function matches(pattern, name) {</span><span class="s2">\n    </span><span class="s1">if (isArray(pattern)) {</span><span class="s2">\n        </span><span class="s1">return pattern.indexOf(name) &gt; -1;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (typeof pattern === 'string') {</span><span class="s2">\n        </span><span class="s1">return pattern.split(',').indexOf(name) &gt; -1;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isRegExp(pattern)) {</span><span class="s2">\n        </span><span class="s1">return pattern.test(name);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function pruneCache(keepAliveInstance, filter) {</span><span class="s2">\n    </span><span class="s1">var cache = keepAliveInstance.cache, keys = keepAliveInstance.keys, _vnode = keepAliveInstance._vnode;</span><span class="s2">\n    </span><span class="s1">for (var key in cache) {</span><span class="s2">\n        </span><span class="s1">var entry = cache[key];</span><span class="s2">\n        </span><span class="s1">if (entry) {</span><span class="s2">\n            </span><span class="s1">var name_1 = entry.name;</span><span class="s2">\n            </span><span class="s1">if (name_1 &amp;&amp; !filter(name_1)) {</span><span class="s2">\n                </span><span class="s1">pruneCacheEntry(cache, key, keys, _vnode);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function pruneCacheEntry(cache, key, keys, current) {</span><span class="s2">\n    </span><span class="s1">var entry = cache[key];</span><span class="s2">\n    </span><span class="s1">if (entry &amp;&amp; (!current || entry.tag !== current.tag)) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error can be undefined</span><span class="s2">\n        </span><span class="s1">entry.componentInstance.$destroy();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">cache[key] = null;</span><span class="s2">\n    </span><span class="s1">remove$2(keys, key);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var patternTypes = [String, RegExp, Array];</span><span class="s2">\n</span><span class="s1">// TODO defineComponent</span><span class="s2">\n</span><span class="s1">var KeepAlive = {</span><span class="s2">\n    </span><span class="s1">name: 'keep-alive',</span><span class="s2">\n    </span><span class="s1">abstract: true,</span><span class="s2">\n    </span><span class="s1">props: {</span><span class="s2">\n        </span><span class="s1">include: patternTypes,</span><span class="s2">\n        </span><span class="s1">exclude: patternTypes,</span><span class="s2">\n        </span><span class="s1">max: [String, Number]</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">methods: {</span><span class="s2">\n        </span><span class="s1">cacheVNode: function () {</span><span class="s2">\n            </span><span class="s1">var _a = this, cache = _a.cache, keys = _a.keys, vnodeToCache = _a.vnodeToCache, keyToCache = _a.keyToCache;</span><span class="s2">\n            </span><span class="s1">if (vnodeToCache) {</span><span class="s2">\n                </span><span class="s1">var tag = vnodeToCache.tag, componentInstance = vnodeToCache.componentInstance, componentOptions = vnodeToCache.componentOptions;</span><span class="s2">\n                </span><span class="s1">cache[keyToCache] = {</span><span class="s2">\n                    </span><span class="s1">name: _getComponentName(componentOptions),</span><span class="s2">\n                    </span><span class="s1">tag: tag,</span><span class="s2">\n                    </span><span class="s1">componentInstance: componentInstance</span><span class="s2">\n                </span><span class="s1">};</span><span class="s2">\n                </span><span class="s1">keys.push(keyToCache);</span><span class="s2">\n                </span><span class="s1">// prune oldest entry</span><span class="s2">\n                </span><span class="s1">if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) {</span><span class="s2">\n                    </span><span class="s1">pruneCacheEntry(cache, keys[0], keys, this._vnode);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">this.vnodeToCache = null;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">created: function () {</span><span class="s2">\n        </span><span class="s1">this.cache = Object.create(null);</span><span class="s2">\n        </span><span class="s1">this.keys = [];</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">destroyed: function () {</span><span class="s2">\n        </span><span class="s1">for (var key in this.cache) {</span><span class="s2">\n            </span><span class="s1">pruneCacheEntry(this.cache, key, this.keys);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">mounted: function () {</span><span class="s2">\n        </span><span class="s1">var _this = this;</span><span class="s2">\n        </span><span class="s1">this.cacheVNode();</span><span class="s2">\n        </span><span class="s1">this.$watch('include', function (val) {</span><span class="s2">\n            </span><span class="s1">pruneCache(_this, function (name) { return matches(val, name); });</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">this.$watch('exclude', function (val) {</span><span class="s2">\n            </span><span class="s1">pruneCache(_this, function (name) { return !matches(val, name); });</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">updated: function () {</span><span class="s2">\n        </span><span class="s1">this.cacheVNode();</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">render: function () {</span><span class="s2">\n        </span><span class="s1">var slot = this.$slots.default;</span><span class="s2">\n        </span><span class="s1">var vnode = getFirstComponentChild(slot);</span><span class="s2">\n        </span><span class="s1">var componentOptions = vnode &amp;&amp; vnode.componentOptions;</span><span class="s2">\n        </span><span class="s1">if (componentOptions) {</span><span class="s2">\n            </span><span class="s1">// check pattern</span><span class="s2">\n            </span><span class="s1">var name_2 = _getComponentName(componentOptions);</span><span class="s2">\n            </span><span class="s1">var _a = this, include = _a.include, exclude = _a.exclude;</span><span class="s2">\n            </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">// not included</span><span class="s2">\n            </span><span class="s1">(include &amp;&amp; (!name_2 || !matches(include, name_2))) ||</span><span class="s2">\n                </span><span class="s1">// excluded</span><span class="s2">\n                </span><span class="s1">(exclude &amp;&amp; name_2 &amp;&amp; matches(exclude, name_2))) {</span><span class="s2">\n                </span><span class="s1">return vnode;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">var _b = this, cache = _b.cache, keys = _b.keys;</span><span class="s2">\n            </span><span class="s1">var key = vnode.key == null</span><span class="s2">\n                </span><span class="s1">? // same constructor may get registered as different local components</span><span class="s2">\n                    </span><span class="s1">// so cid alone is not enough (#3269)</span><span class="s2">\n                    </span><span class="s1">componentOptions.Ctor.cid +</span><span class="s2">\n                        </span><span class="s1">(componentOptions.tag ? </span><span class="s2">\&quot;</span><span class="s1">::</span><span class="s2">\&quot;</span><span class="s1">.concat(componentOptions.tag) : '')</span><span class="s2">\n                </span><span class="s1">: vnode.key;</span><span class="s2">\n            </span><span class="s1">if (cache[key]) {</span><span class="s2">\n                </span><span class="s1">vnode.componentInstance = cache[key].componentInstance;</span><span class="s2">\n                </span><span class="s1">// make current key freshest</span><span class="s2">\n                </span><span class="s1">remove$2(keys, key);</span><span class="s2">\n                </span><span class="s1">keys.push(key);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">// delay setting the cache until update</span><span class="s2">\n                </span><span class="s1">this.vnodeToCache = vnode;</span><span class="s2">\n                </span><span class="s1">this.keyToCache = key;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error can vnode.data can be undefined</span><span class="s2">\n            </span><span class="s1">vnode.data.keepAlive = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return vnode || (slot &amp;&amp; slot[0]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">var builtInComponents = {</span><span class="s2">\n    </span><span class="s1">KeepAlive: KeepAlive</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">function initGlobalAPI(Vue) {</span><span class="s2">\n    </span><span class="s1">// config</span><span class="s2">\n    </span><span class="s1">var configDef = {};</span><span class="s2">\n    </span><span class="s1">configDef.get = function () { return config; };</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">configDef.set = function () {</span><span class="s2">\n            </span><span class="s1">warn('Do not replace the Vue.config object, set individual fields instead.');</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(Vue, 'config', configDef);</span><span class="s2">\n    </span><span class="s1">// exposed util methods.</span><span class="s2">\n    </span><span class="s1">// NOTE: these are not considered part of the public API - avoid relying on</span><span class="s2">\n    </span><span class="s1">// them unless you are aware of the risk.</span><span class="s2">\n    </span><span class="s1">Vue.util = {</span><span class="s2">\n        </span><span class="s1">warn: warn,</span><span class="s2">\n        </span><span class="s1">extend: extend,</span><span class="s2">\n        </span><span class="s1">mergeOptions: mergeOptions,</span><span class="s2">\n        </span><span class="s1">defineReactive: defineReactive</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">Vue.set = set;</span><span class="s2">\n    </span><span class="s1">Vue.delete = del;</span><span class="s2">\n    </span><span class="s1">Vue.nextTick = nextTick;</span><span class="s2">\n    </span><span class="s1">// 2.6 explicit observable API</span><span class="s2">\n    </span><span class="s1">Vue.observable = function (obj) {</span><span class="s2">\n        </span><span class="s1">observe(obj);</span><span class="s2">\n        </span><span class="s1">return obj;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">Vue.options = Object.create(null);</span><span class="s2">\n    </span><span class="s1">ASSET_TYPES.forEach(function (type) {</span><span class="s2">\n        </span><span class="s1">Vue.options[type + 's'] = Object.create(null);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">// this is used to identify the </span><span class="s2">\&quot;</span><span class="s1">base</span><span class="s2">\&quot; </span><span class="s1">constructor to extend all plain-object</span><span class="s2">\n    </span><span class="s1">// components with in Weex's multi-instance scenarios.</span><span class="s2">\n    </span><span class="s1">Vue.options._base = Vue;</span><span class="s2">\n    </span><span class="s1">extend(Vue.options.components, builtInComponents);</span><span class="s2">\n    </span><span class="s1">initUse(Vue);</span><span class="s2">\n    </span><span class="s1">initMixin(Vue);</span><span class="s2">\n    </span><span class="s1">initExtend(Vue);</span><span class="s2">\n    </span><span class="s1">initAssetRegisters(Vue);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">initGlobalAPI(Vue);</span><span class="s2">\n</span><span class="s1">Object.defineProperty(Vue.prototype, '$isServer', {</span><span class="s2">\n    </span><span class="s1">get: isServerRendering</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">Object.defineProperty(Vue.prototype, '$ssrContext', {</span><span class="s2">\n    </span><span class="s1">get: function () {</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n        </span><span class="s1">return this.$vnode &amp;&amp; this.$vnode.ssrContext;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">// expose FunctionalRenderContext for ssr runtime helper installation</span><span class="s2">\n</span><span class="s1">Object.defineProperty(Vue, 'FunctionalRenderContext', {</span><span class="s2">\n    </span><span class="s1">value: FunctionalRenderContext</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">Vue.version = version;</span><span class="s2">\n\n</span><span class="s1">// these are reserved for web because they are directly compiled away</span><span class="s2">\n</span><span class="s1">// during template compilation</span><span class="s2">\n</span><span class="s1">var isReservedAttr = makeMap('style,class');</span><span class="s2">\n</span><span class="s1">// attributes that should be using props for binding</span><span class="s2">\n</span><span class="s1">var acceptValue = makeMap('input,textarea,option,select,progress');</span><span class="s2">\n</span><span class="s1">var mustUseProp = function (tag, type, attr) {</span><span class="s2">\n    </span><span class="s1">return ((attr === 'value' &amp;&amp; acceptValue(tag) &amp;&amp; type !== 'button') ||</span><span class="s2">\n        </span><span class="s1">(attr === 'selected' &amp;&amp; tag === 'option') ||</span><span class="s2">\n        </span><span class="s1">(attr === 'checked' &amp;&amp; tag === 'input') ||</span><span class="s2">\n        </span><span class="s1">(attr === 'muted' &amp;&amp; tag === 'video'));</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');</span><span class="s2">\n</span><span class="s1">var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');</span><span class="s2">\n</span><span class="s1">var convertEnumeratedValue = function (key, value) {</span><span class="s2">\n    </span><span class="s1">return isFalsyAttrValue(value) || value === 'false'</span><span class="s2">\n        </span><span class="s1">? 'false'</span><span class="s2">\n        </span><span class="s1">: // allow arbitrary string value for contenteditable</span><span class="s2">\n            </span><span class="s1">key === 'contenteditable' &amp;&amp; isValidContentEditableValue(value)</span><span class="s2">\n                </span><span class="s1">? value</span><span class="s2">\n                </span><span class="s1">: 'true';</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +</span><span class="s2">\n    </span><span class="s1">'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +</span><span class="s2">\n    </span><span class="s1">'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +</span><span class="s2">\n    </span><span class="s1">'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +</span><span class="s2">\n    </span><span class="s1">'required,reversed,scoped,seamless,selected,sortable,' +</span><span class="s2">\n    </span><span class="s1">'truespeed,typemustmatch,visible');</span><span class="s2">\n</span><span class="s1">var xlinkNS = 'http://www.w3.org/1999/xlink';</span><span class="s2">\n</span><span class="s1">var isXlink = function (name) {</span><span class="s2">\n    </span><span class="s1">return name.charAt(5) === ':' &amp;&amp; name.slice(0, 5) === 'xlink';</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var getXlinkProp = function (name) {</span><span class="s2">\n    </span><span class="s1">return isXlink(name) ? name.slice(6, name.length) : '';</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var isFalsyAttrValue = function (val) {</span><span class="s2">\n    </span><span class="s1">return val == null || val === false;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">function genClassForVnode(vnode) {</span><span class="s2">\n    </span><span class="s1">var data = vnode.data;</span><span class="s2">\n    </span><span class="s1">var parentNode = vnode;</span><span class="s2">\n    </span><span class="s1">var childNode = vnode;</span><span class="s2">\n    </span><span class="s1">while (isDef(childNode.componentInstance)) {</span><span class="s2">\n        </span><span class="s1">childNode = childNode.componentInstance._vnode;</span><span class="s2">\n        </span><span class="s1">if (childNode &amp;&amp; childNode.data) {</span><span class="s2">\n            </span><span class="s1">data = mergeClassData(childNode.data, data);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error parentNode.parent not VNodeWithData</span><span class="s2">\n    </span><span class="s1">while (isDef((parentNode = parentNode.parent))) {</span><span class="s2">\n        </span><span class="s1">if (parentNode &amp;&amp; parentNode.data) {</span><span class="s2">\n            </span><span class="s1">data = mergeClassData(data, parentNode.data);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return renderClass(data.staticClass, data.class);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mergeClassData(child, parent) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">staticClass: concat(child.staticClass, parent.staticClass),</span><span class="s2">\n        </span><span class="s1">class: isDef(child.class) ? [child.class, parent.class] : parent.class</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function renderClass(staticClass, dynamicClass) {</span><span class="s2">\n    </span><span class="s1">if (isDef(staticClass) || isDef(dynamicClass)) {</span><span class="s2">\n        </span><span class="s1">return concat(staticClass, stringifyClass(dynamicClass));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n    </span><span class="s1">return '';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function concat(a, b) {</span><span class="s2">\n    </span><span class="s1">return a ? (b ? a + ' ' + b : a) : b || '';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stringifyClass(value) {</span><span class="s2">\n    </span><span class="s1">if (Array.isArray(value)) {</span><span class="s2">\n        </span><span class="s1">return stringifyArray(value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isObject(value)) {</span><span class="s2">\n        </span><span class="s1">return stringifyObject(value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (typeof value === 'string') {</span><span class="s2">\n        </span><span class="s1">return value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n    </span><span class="s1">return '';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stringifyArray(value) {</span><span class="s2">\n    </span><span class="s1">var res = '';</span><span class="s2">\n    </span><span class="s1">var stringified;</span><span class="s2">\n    </span><span class="s1">for (var i = 0, l = value.length; i &lt; l; i++) {</span><span class="s2">\n        </span><span class="s1">if (isDef((stringified = stringifyClass(value[i]))) &amp;&amp; stringified !== '') {</span><span class="s2">\n            </span><span class="s1">if (res)</span><span class="s2">\n                </span><span class="s1">res += ' ';</span><span class="s2">\n            </span><span class="s1">res += stringified;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stringifyObject(value) {</span><span class="s2">\n    </span><span class="s1">var res = '';</span><span class="s2">\n    </span><span class="s1">for (var key in value) {</span><span class="s2">\n        </span><span class="s1">if (value[key]) {</span><span class="s2">\n            </span><span class="s1">if (res)</span><span class="s2">\n                </span><span class="s1">res += ' ';</span><span class="s2">\n            </span><span class="s1">res += key;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var namespaceMap = {</span><span class="s2">\n    </span><span class="s1">svg: 'http://www.w3.org/2000/svg',</span><span class="s2">\n    </span><span class="s1">math: 'http://www.w3.org/1998/Math/MathML'</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' +</span><span class="s2">\n    </span><span class="s1">'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +</span><span class="s2">\n    </span><span class="s1">'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +</span><span class="s2">\n    </span><span class="s1">'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +</span><span class="s2">\n    </span><span class="s1">'s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +</span><span class="s2">\n    </span><span class="s1">'embed,object,param,source,canvas,script,noscript,del,ins,' +</span><span class="s2">\n    </span><span class="s1">'caption,col,colgroup,table,thead,tbody,td,th,tr,' +</span><span class="s2">\n    </span><span class="s1">'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +</span><span class="s2">\n    </span><span class="s1">'output,progress,select,textarea,' +</span><span class="s2">\n    </span><span class="s1">'details,dialog,menu,menuitem,summary,' +</span><span class="s2">\n    </span><span class="s1">'content,element,shadow,template,blockquote,iframe,tfoot');</span><span class="s2">\n</span><span class="s1">// this map is intentionally selective, only covering SVG elements that may</span><span class="s2">\n</span><span class="s1">// contain child elements.</span><span class="s2">\n</span><span class="s1">var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +</span><span class="s2">\n    </span><span class="s1">'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +</span><span class="s2">\n    </span><span class="s1">'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);</span><span class="s2">\n</span><span class="s1">var isReservedTag = function (tag) {</span><span class="s2">\n    </span><span class="s1">return isHTMLTag(tag) || isSVG(tag);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function getTagNamespace(tag) {</span><span class="s2">\n    </span><span class="s1">if (isSVG(tag)) {</span><span class="s2">\n        </span><span class="s1">return 'svg';</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// basic support for MathML</span><span class="s2">\n    </span><span class="s1">// note it doesn't support other MathML elements being component roots</span><span class="s2">\n    </span><span class="s1">if (tag === 'math') {</span><span class="s2">\n        </span><span class="s1">return 'math';</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var unknownElementCache = Object.create(null);</span><span class="s2">\n</span><span class="s1">function isUnknownElement(tag) {</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (!inBrowser) {</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isReservedTag(tag)) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">tag = tag.toLowerCase();</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (unknownElementCache[tag] != null) {</span><span class="s2">\n        </span><span class="s1">return unknownElementCache[tag];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var el = document.createElement(tag);</span><span class="s2">\n    </span><span class="s1">if (tag.indexOf('-') &gt; -1) {</span><span class="s2">\n        </span><span class="s1">// http://stackoverflow.com/a/28210364/1070244</span><span class="s2">\n        </span><span class="s1">return (unknownElementCache[tag] =</span><span class="s2">\n            </span><span class="s1">el.constructor === window.HTMLUnknownElement ||</span><span class="s2">\n                </span><span class="s1">el.constructor === window.HTMLElement);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var isTextInputType = makeMap('text,number,password,search,email,tel,url');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Query an element selector if it's not an element already.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function query(el) {</span><span class="s2">\n    </span><span class="s1">if (typeof el === 'string') {</span><span class="s2">\n        </span><span class="s1">var selected = document.querySelector(el);</span><span class="s2">\n        </span><span class="s1">if (!selected) {</span><span class="s2">\n            </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn('Cannot find element: ' + el);</span><span class="s2">\n            </span><span class="s1">return document.createElement('div');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return selected;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">return el;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function createElement(tagName, vnode) {</span><span class="s2">\n    </span><span class="s1">var elm = document.createElement(tagName);</span><span class="s2">\n    </span><span class="s1">if (tagName !== 'select') {</span><span class="s2">\n        </span><span class="s1">return elm;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// false or null will remove the attribute but undefined will not</span><span class="s2">\n    </span><span class="s1">if (vnode.data &amp;&amp;</span><span class="s2">\n        </span><span class="s1">vnode.data.attrs &amp;&amp;</span><span class="s2">\n        </span><span class="s1">vnode.data.attrs.multiple !== undefined) {</span><span class="s2">\n        </span><span class="s1">elm.setAttribute('multiple', 'multiple');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return elm;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createElementNS(namespace, tagName) {</span><span class="s2">\n    </span><span class="s1">return document.createElementNS(namespaceMap[namespace], tagName);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createTextNode(text) {</span><span class="s2">\n    </span><span class="s1">return document.createTextNode(text);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createComment(text) {</span><span class="s2">\n    </span><span class="s1">return document.createComment(text);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function insertBefore(parentNode, newNode, referenceNode) {</span><span class="s2">\n    </span><span class="s1">parentNode.insertBefore(newNode, referenceNode);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function removeChild(node, child) {</span><span class="s2">\n    </span><span class="s1">node.removeChild(child);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function appendChild(node, child) {</span><span class="s2">\n    </span><span class="s1">node.appendChild(child);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function parentNode(node) {</span><span class="s2">\n    </span><span class="s1">return node.parentNode;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function nextSibling(node) {</span><span class="s2">\n    </span><span class="s1">return node.nextSibling;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function tagName(node) {</span><span class="s2">\n    </span><span class="s1">return node.tagName;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setTextContent(node, text) {</span><span class="s2">\n    </span><span class="s1">node.textContent = text;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setStyleScope(node, scopeId) {</span><span class="s2">\n    </span><span class="s1">node.setAttribute(scopeId, '');</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var nodeOps = /*#__PURE__*/Object.freeze({</span><span class="s2">\n  </span><span class="s1">__proto__: null,</span><span class="s2">\n  </span><span class="s1">createElement: createElement,</span><span class="s2">\n  </span><span class="s1">createElementNS: createElementNS,</span><span class="s2">\n  </span><span class="s1">createTextNode: createTextNode,</span><span class="s2">\n  </span><span class="s1">createComment: createComment,</span><span class="s2">\n  </span><span class="s1">insertBefore: insertBefore,</span><span class="s2">\n  </span><span class="s1">removeChild: removeChild,</span><span class="s2">\n  </span><span class="s1">appendChild: appendChild,</span><span class="s2">\n  </span><span class="s1">parentNode: parentNode,</span><span class="s2">\n  </span><span class="s1">nextSibling: nextSibling,</span><span class="s2">\n  </span><span class="s1">tagName: tagName,</span><span class="s2">\n  </span><span class="s1">setTextContent: setTextContent,</span><span class="s2">\n  </span><span class="s1">setStyleScope: setStyleScope</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n\n</span><span class="s1">var ref = {</span><span class="s2">\n    </span><span class="s1">create: function (_, vnode) {</span><span class="s2">\n        </span><span class="s1">registerRef(vnode);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">update: function (oldVnode, vnode) {</span><span class="s2">\n        </span><span class="s1">if (oldVnode.data.ref !== vnode.data.ref) {</span><span class="s2">\n            </span><span class="s1">registerRef(oldVnode, true);</span><span class="s2">\n            </span><span class="s1">registerRef(vnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">destroy: function (vnode) {</span><span class="s2">\n        </span><span class="s1">registerRef(vnode, true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function registerRef(vnode, isRemoval) {</span><span class="s2">\n    </span><span class="s1">var ref = vnode.data.ref;</span><span class="s2">\n    </span><span class="s1">if (!isDef(ref))</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">var vm = vnode.context;</span><span class="s2">\n    </span><span class="s1">var refValue = vnode.componentInstance || vnode.elm;</span><span class="s2">\n    </span><span class="s1">var value = isRemoval ? null : refValue;</span><span class="s2">\n    </span><span class="s1">var $refsValue = isRemoval ? undefined : refValue;</span><span class="s2">\n    </span><span class="s1">if (isFunction(ref)) {</span><span class="s2">\n        </span><span class="s1">invokeWithErrorHandling(ref, vm, [value], vm, </span><span class="s2">\&quot;</span><span class="s1">template ref function</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var isFor = vnode.data.refInFor;</span><span class="s2">\n    </span><span class="s1">var _isString = typeof ref === 'string' || typeof ref === 'number';</span><span class="s2">\n    </span><span class="s1">var _isRef = isRef(ref);</span><span class="s2">\n    </span><span class="s1">var refs = vm.$refs;</span><span class="s2">\n    </span><span class="s1">if (_isString || _isRef) {</span><span class="s2">\n        </span><span class="s1">if (isFor) {</span><span class="s2">\n            </span><span class="s1">var existing = _isString ? refs[ref] : ref.value;</span><span class="s2">\n            </span><span class="s1">if (isRemoval) {</span><span class="s2">\n                </span><span class="s1">isArray(existing) &amp;&amp; remove$2(existing, refValue);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">if (!isArray(existing)) {</span><span class="s2">\n                    </span><span class="s1">if (_isString) {</span><span class="s2">\n                        </span><span class="s1">refs[ref] = [refValue];</span><span class="s2">\n                        </span><span class="s1">setSetupRef(vm, ref, refs[ref]);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">ref.value = [refValue];</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (!existing.includes(refValue)) {</span><span class="s2">\n                    </span><span class="s1">existing.push(refValue);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (_isString) {</span><span class="s2">\n            </span><span class="s1">if (isRemoval &amp;&amp; refs[ref] !== refValue) {</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">refs[ref] = $refsValue;</span><span class="s2">\n            </span><span class="s1">setSetupRef(vm, ref, value);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (_isRef) {</span><span class="s2">\n            </span><span class="s1">if (isRemoval &amp;&amp; ref.value !== refValue) {</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">ref.value = value;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Invalid template ref type: </span><span class="s2">\&quot;</span><span class="s1">.concat(typeof ref));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setSetupRef(_a, key, val) {</span><span class="s2">\n    </span><span class="s1">var _setupState = _a._setupState;</span><span class="s2">\n    </span><span class="s1">if (_setupState &amp;&amp; hasOwn(_setupState, key)) {</span><span class="s2">\n        </span><span class="s1">if (isRef(_setupState[key])) {</span><span class="s2">\n            </span><span class="s1">_setupState[key].value = val;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">_setupState[key] = val;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Virtual DOM patching algorithm based on Snabbdom by</span><span class="s2">\n </span><span class="s1">* Simon Friis Vindum (@paldepind)</span><span class="s2">\n </span><span class="s1">* Licensed under the MIT License</span><span class="s2">\n </span><span class="s1">* https://github.com/paldepind/snabbdom/blob/master/LICENSE</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* modified by Evan You (@yyx990803)</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Not type-checking this because this file is perf-critical and the cost</span><span class="s2">\n </span><span class="s1">* of making flow understand it is not worth it.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var emptyNode = new VNode('', {}, []);</span><span class="s2">\n</span><span class="s1">var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];</span><span class="s2">\n</span><span class="s1">function sameVnode(a, b) {</span><span class="s2">\n    </span><span class="s1">return (a.key === b.key &amp;&amp;</span><span class="s2">\n        </span><span class="s1">a.asyncFactory === b.asyncFactory &amp;&amp;</span><span class="s2">\n        </span><span class="s1">((a.tag === b.tag &amp;&amp;</span><span class="s2">\n            </span><span class="s1">a.isComment === b.isComment &amp;&amp;</span><span class="s2">\n            </span><span class="s1">isDef(a.data) === isDef(b.data) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">sameInputType(a, b)) ||</span><span class="s2">\n            </span><span class="s1">(isTrue(a.isAsyncPlaceholder) &amp;&amp; isUndef(b.asyncFactory.error))));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function sameInputType(a, b) {</span><span class="s2">\n    </span><span class="s1">if (a.tag !== 'input')</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">var i;</span><span class="s2">\n    </span><span class="s1">var typeA = isDef((i = a.data)) &amp;&amp; isDef((i = i.attrs)) &amp;&amp; i.type;</span><span class="s2">\n    </span><span class="s1">var typeB = isDef((i = b.data)) &amp;&amp; isDef((i = i.attrs)) &amp;&amp; i.type;</span><span class="s2">\n    </span><span class="s1">return typeA === typeB || (isTextInputType(typeA) &amp;&amp; isTextInputType(typeB));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createKeyToOldIdx(children, beginIdx, endIdx) {</span><span class="s2">\n    </span><span class="s1">var i, key;</span><span class="s2">\n    </span><span class="s1">var map = {};</span><span class="s2">\n    </span><span class="s1">for (i = beginIdx; i &lt;= endIdx; ++i) {</span><span class="s2">\n        </span><span class="s1">key = children[i].key;</span><span class="s2">\n        </span><span class="s1">if (isDef(key))</span><span class="s2">\n            </span><span class="s1">map[key] = i;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return map;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createPatchFunction(backend) {</span><span class="s2">\n    </span><span class="s1">var i, j;</span><span class="s2">\n    </span><span class="s1">var cbs = {};</span><span class="s2">\n    </span><span class="s1">var modules = backend.modules, nodeOps = backend.nodeOps;</span><span class="s2">\n    </span><span class="s1">for (i = 0; i &lt; hooks.length; ++i) {</span><span class="s2">\n        </span><span class="s1">cbs[hooks[i]] = [];</span><span class="s2">\n        </span><span class="s1">for (j = 0; j &lt; modules.length; ++j) {</span><span class="s2">\n            </span><span class="s1">if (isDef(modules[j][hooks[i]])) {</span><span class="s2">\n                </span><span class="s1">cbs[hooks[i]].push(modules[j][hooks[i]]);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function emptyNodeAt(elm) {</span><span class="s2">\n        </span><span class="s1">return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function createRmCb(childElm, listeners) {</span><span class="s2">\n        </span><span class="s1">function remove() {</span><span class="s2">\n            </span><span class="s1">if (--remove.listeners === 0) {</span><span class="s2">\n                </span><span class="s1">removeNode(childElm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">remove.listeners = listeners;</span><span class="s2">\n        </span><span class="s1">return remove;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function removeNode(el) {</span><span class="s2">\n        </span><span class="s1">var parent = nodeOps.parentNode(el);</span><span class="s2">\n        </span><span class="s1">// element may have already been removed due to v-html / v-text</span><span class="s2">\n        </span><span class="s1">if (isDef(parent)) {</span><span class="s2">\n            </span><span class="s1">nodeOps.removeChild(parent, el);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function isUnknownElement(vnode, inVPre) {</span><span class="s2">\n        </span><span class="s1">return (!inVPre &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!vnode.ns &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!(config.ignoredElements.length &amp;&amp;</span><span class="s2">\n                </span><span class="s1">config.ignoredElements.some(function (ignore) {</span><span class="s2">\n                    </span><span class="s1">return isRegExp(ignore)</span><span class="s2">\n                        </span><span class="s1">? ignore.test(vnode.tag)</span><span class="s2">\n                        </span><span class="s1">: ignore === vnode.tag;</span><span class="s2">\n                </span><span class="s1">})) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">config.isUnknownElement(vnode.tag));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var creatingElmInVPre = 0;</span><span class="s2">\n    </span><span class="s1">function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {</span><span class="s2">\n        </span><span class="s1">if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) {</span><span class="s2">\n            </span><span class="s1">// This vnode was used in a previous render!</span><span class="s2">\n            </span><span class="s1">// now it's used as a new node, overwriting its elm would cause</span><span class="s2">\n            </span><span class="s1">// potential patch errors down the road when it's used as an insertion</span><span class="s2">\n            </span><span class="s1">// reference node. Instead, we clone the node on-demand before creating</span><span class="s2">\n            </span><span class="s1">// associated DOM element for it.</span><span class="s2">\n            </span><span class="s1">vnode = ownerArray[index] = cloneVNode(vnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">vnode.isRootInsert = !nested; // for transition enter check</span><span class="s2">\n        </span><span class="s1">if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var data = vnode.data;</span><span class="s2">\n        </span><span class="s1">var children = vnode.children;</span><span class="s2">\n        </span><span class="s1">var tag = vnode.tag;</span><span class="s2">\n        </span><span class="s1">if (isDef(tag)) {</span><span class="s2">\n            </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n                </span><span class="s1">if (data &amp;&amp; data.pre) {</span><span class="s2">\n                    </span><span class="s1">creatingElmInVPre++;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (isUnknownElement(vnode, creatingElmInVPre)) {</span><span class="s2">\n                    </span><span class="s1">warn('Unknown custom element: &lt;' +</span><span class="s2">\n                        </span><span class="s1">tag +</span><span class="s2">\n                        </span><span class="s1">'&gt; - did you ' +</span><span class="s2">\n                        </span><span class="s1">'register the component correctly? For recursive components, ' +</span><span class="s2">\n                        </span><span class="s1">'make sure to provide the </span><span class="s2">\&quot;</span><span class="s1">name</span><span class="s2">\&quot; </span><span class="s1">option.', vnode.context);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">vnode.elm = vnode.ns</span><span class="s2">\n                </span><span class="s1">? nodeOps.createElementNS(vnode.ns, tag)</span><span class="s2">\n                </span><span class="s1">: nodeOps.createElement(tag, vnode);</span><span class="s2">\n            </span><span class="s1">setScope(vnode);</span><span class="s2">\n            </span><span class="s1">createChildren(vnode, children, insertedVnodeQueue);</span><span class="s2">\n            </span><span class="s1">if (isDef(data)) {</span><span class="s2">\n                </span><span class="s1">invokeCreateHooks(vnode, insertedVnodeQueue);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">insert(parentElm, vnode.elm, refElm);</span><span class="s2">\n            </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; data &amp;&amp; data.pre) {</span><span class="s2">\n                </span><span class="s1">creatingElmInVPre--;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (isTrue(vnode.isComment)) {</span><span class="s2">\n            </span><span class="s1">vnode.elm = nodeOps.createComment(vnode.text);</span><span class="s2">\n            </span><span class="s1">insert(parentElm, vnode.elm, refElm);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">vnode.elm = nodeOps.createTextNode(vnode.text);</span><span class="s2">\n            </span><span class="s1">insert(parentElm, vnode.elm, refElm);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {</span><span class="s2">\n        </span><span class="s1">var i = vnode.data;</span><span class="s2">\n        </span><span class="s1">if (isDef(i)) {</span><span class="s2">\n            </span><span class="s1">var isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive;</span><span class="s2">\n            </span><span class="s1">if (isDef((i = i.hook)) &amp;&amp; isDef((i = i.init))) {</span><span class="s2">\n                </span><span class="s1">i(vnode, false /* hydrating */);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// after calling the init hook, if the vnode is a child component</span><span class="s2">\n            </span><span class="s1">// it should've created a child instance and mounted it. the child</span><span class="s2">\n            </span><span class="s1">// component also has set the placeholder vnode's elm.</span><span class="s2">\n            </span><span class="s1">// in that case we can just return the element and be done.</span><span class="s2">\n            </span><span class="s1">if (isDef(vnode.componentInstance)) {</span><span class="s2">\n                </span><span class="s1">initComponent(vnode, insertedVnodeQueue);</span><span class="s2">\n                </span><span class="s1">insert(parentElm, vnode.elm, refElm);</span><span class="s2">\n                </span><span class="s1">if (isTrue(isReactivated)) {</span><span class="s2">\n                    </span><span class="s1">reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">return true;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function initComponent(vnode, insertedVnodeQueue) {</span><span class="s2">\n        </span><span class="s1">if (isDef(vnode.data.pendingInsert)) {</span><span class="s2">\n            </span><span class="s1">insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);</span><span class="s2">\n            </span><span class="s1">vnode.data.pendingInsert = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">vnode.elm = vnode.componentInstance.$el;</span><span class="s2">\n        </span><span class="s1">if (isPatchable(vnode)) {</span><span class="s2">\n            </span><span class="s1">invokeCreateHooks(vnode, insertedVnodeQueue);</span><span class="s2">\n            </span><span class="s1">setScope(vnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// empty component root.</span><span class="s2">\n            </span><span class="s1">// skip all element-related modules except for ref (#3455)</span><span class="s2">\n            </span><span class="s1">registerRef(vnode);</span><span class="s2">\n            </span><span class="s1">// make sure to invoke the insert hook</span><span class="s2">\n            </span><span class="s1">insertedVnodeQueue.push(vnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {</span><span class="s2">\n        </span><span class="s1">var i;</span><span class="s2">\n        </span><span class="s1">// hack for #4339: a reactivated component with inner transition</span><span class="s2">\n        </span><span class="s1">// does not trigger because the inner node's created hooks are not called</span><span class="s2">\n        </span><span class="s1">// again. It's not ideal to involve module-specific logic in here but</span><span class="s2">\n        </span><span class="s1">// there doesn't seem to be a better way to do it.</span><span class="s2">\n        </span><span class="s1">var innerNode = vnode;</span><span class="s2">\n        </span><span class="s1">while (innerNode.componentInstance) {</span><span class="s2">\n            </span><span class="s1">innerNode = innerNode.componentInstance._vnode;</span><span class="s2">\n            </span><span class="s1">if (isDef((i = innerNode.data)) &amp;&amp; isDef((i = i.transition))) {</span><span class="s2">\n                </span><span class="s1">for (i = 0; i &lt; cbs.activate.length; ++i) {</span><span class="s2">\n                    </span><span class="s1">cbs.activate[i](emptyNode, innerNode);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">insertedVnodeQueue.push(innerNode);</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// unlike a newly created component,</span><span class="s2">\n        </span><span class="s1">// a reactivated keep-alive component doesn't insert itself</span><span class="s2">\n        </span><span class="s1">insert(parentElm, vnode.elm, refElm);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function insert(parent, elm, ref) {</span><span class="s2">\n        </span><span class="s1">if (isDef(parent)) {</span><span class="s2">\n            </span><span class="s1">if (isDef(ref)) {</span><span class="s2">\n                </span><span class="s1">if (nodeOps.parentNode(ref) === parent) {</span><span class="s2">\n                    </span><span class="s1">nodeOps.insertBefore(parent, elm, ref);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">nodeOps.appendChild(parent, elm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function createChildren(vnode, children, insertedVnodeQueue) {</span><span class="s2">\n        </span><span class="s1">if (isArray(children)) {</span><span class="s2">\n            </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n                </span><span class="s1">checkDuplicateKeys(children);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">for (var i_1 = 0; i_1 &lt; children.length; ++i_1) {</span><span class="s2">\n                </span><span class="s1">createElm(children[i_1], insertedVnodeQueue, vnode.elm, null, true, children, i_1);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (isPrimitive(vnode.text)) {</span><span class="s2">\n            </span><span class="s1">nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function isPatchable(vnode) {</span><span class="s2">\n        </span><span class="s1">while (vnode.componentInstance) {</span><span class="s2">\n            </span><span class="s1">vnode = vnode.componentInstance._vnode;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return isDef(vnode.tag);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function invokeCreateHooks(vnode, insertedVnodeQueue) {</span><span class="s2">\n        </span><span class="s1">for (var i_2 = 0; i_2 &lt; cbs.create.length; ++i_2) {</span><span class="s2">\n            </span><span class="s1">cbs.create[i_2](emptyNode, vnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">i = vnode.data.hook; // Reuse variable</span><span class="s2">\n        </span><span class="s1">if (isDef(i)) {</span><span class="s2">\n            </span><span class="s1">if (isDef(i.create))</span><span class="s2">\n                </span><span class="s1">i.create(emptyNode, vnode);</span><span class="s2">\n            </span><span class="s1">if (isDef(i.insert))</span><span class="s2">\n                </span><span class="s1">insertedVnodeQueue.push(vnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// set scope id attribute for scoped CSS.</span><span class="s2">\n    </span><span class="s1">// this is implemented as a special case to avoid the overhead</span><span class="s2">\n    </span><span class="s1">// of going through the normal attribute patching process.</span><span class="s2">\n    </span><span class="s1">function setScope(vnode) {</span><span class="s2">\n        </span><span class="s1">var i;</span><span class="s2">\n        </span><span class="s1">if (isDef((i = vnode.fnScopeId))) {</span><span class="s2">\n            </span><span class="s1">nodeOps.setStyleScope(vnode.elm, i);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">var ancestor = vnode;</span><span class="s2">\n            </span><span class="s1">while (ancestor) {</span><span class="s2">\n                </span><span class="s1">if (isDef((i = ancestor.context)) &amp;&amp; isDef((i = i.$options._scopeId))) {</span><span class="s2">\n                    </span><span class="s1">nodeOps.setStyleScope(vnode.elm, i);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">ancestor = ancestor.parent;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// for slot content they should also get the scopeId from the host instance.</span><span class="s2">\n        </span><span class="s1">if (isDef((i = activeInstance)) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">i !== vnode.context &amp;&amp;</span><span class="s2">\n            </span><span class="s1">i !== vnode.fnContext &amp;&amp;</span><span class="s2">\n            </span><span class="s1">isDef((i = i.$options._scopeId))) {</span><span class="s2">\n            </span><span class="s1">nodeOps.setStyleScope(vnode.elm, i);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {</span><span class="s2">\n        </span><span class="s1">for (; startIdx &lt;= endIdx; ++startIdx) {</span><span class="s2">\n            </span><span class="s1">createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function invokeDestroyHook(vnode) {</span><span class="s2">\n        </span><span class="s1">var i, j;</span><span class="s2">\n        </span><span class="s1">var data = vnode.data;</span><span class="s2">\n        </span><span class="s1">if (isDef(data)) {</span><span class="s2">\n            </span><span class="s1">if (isDef((i = data.hook)) &amp;&amp; isDef((i = i.destroy)))</span><span class="s2">\n                </span><span class="s1">i(vnode);</span><span class="s2">\n            </span><span class="s1">for (i = 0; i &lt; cbs.destroy.length; ++i)</span><span class="s2">\n                </span><span class="s1">cbs.destroy[i](vnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isDef((i = vnode.children))) {</span><span class="s2">\n            </span><span class="s1">for (j = 0; j &lt; vnode.children.length; ++j) {</span><span class="s2">\n                </span><span class="s1">invokeDestroyHook(vnode.children[j]);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function removeVnodes(vnodes, startIdx, endIdx) {</span><span class="s2">\n        </span><span class="s1">for (; startIdx &lt;= endIdx; ++startIdx) {</span><span class="s2">\n            </span><span class="s1">var ch = vnodes[startIdx];</span><span class="s2">\n            </span><span class="s1">if (isDef(ch)) {</span><span class="s2">\n                </span><span class="s1">if (isDef(ch.tag)) {</span><span class="s2">\n                    </span><span class="s1">removeAndInvokeRemoveHook(ch);</span><span class="s2">\n                    </span><span class="s1">invokeDestroyHook(ch);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">// Text node</span><span class="s2">\n                    </span><span class="s1">removeNode(ch.elm);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function removeAndInvokeRemoveHook(vnode, rm) {</span><span class="s2">\n        </span><span class="s1">if (isDef(rm) || isDef(vnode.data)) {</span><span class="s2">\n            </span><span class="s1">var i_3;</span><span class="s2">\n            </span><span class="s1">var listeners = cbs.remove.length + 1;</span><span class="s2">\n            </span><span class="s1">if (isDef(rm)) {</span><span class="s2">\n                </span><span class="s1">// we have a recursively passed down rm callback</span><span class="s2">\n                </span><span class="s1">// increase the listeners count</span><span class="s2">\n                </span><span class="s1">rm.listeners += listeners;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">// directly removing</span><span class="s2">\n                </span><span class="s1">rm = createRmCb(vnode.elm, listeners);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// recursively invoke hooks on child component root node</span><span class="s2">\n            </span><span class="s1">if (isDef((i_3 = vnode.componentInstance)) &amp;&amp;</span><span class="s2">\n                </span><span class="s1">isDef((i_3 = i_3._vnode)) &amp;&amp;</span><span class="s2">\n                </span><span class="s1">isDef(i_3.data)) {</span><span class="s2">\n                </span><span class="s1">removeAndInvokeRemoveHook(i_3, rm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">for (i_3 = 0; i_3 &lt; cbs.remove.length; ++i_3) {</span><span class="s2">\n                </span><span class="s1">cbs.remove[i_3](vnode, rm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (isDef((i_3 = vnode.data.hook)) &amp;&amp; isDef((i_3 = i_3.remove))) {</span><span class="s2">\n                </span><span class="s1">i_3(vnode, rm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">rm();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">removeNode(vnode.elm);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {</span><span class="s2">\n        </span><span class="s1">var oldStartIdx = 0;</span><span class="s2">\n        </span><span class="s1">var newStartIdx = 0;</span><span class="s2">\n        </span><span class="s1">var oldEndIdx = oldCh.length - 1;</span><span class="s2">\n        </span><span class="s1">var oldStartVnode = oldCh[0];</span><span class="s2">\n        </span><span class="s1">var oldEndVnode = oldCh[oldEndIdx];</span><span class="s2">\n        </span><span class="s1">var newEndIdx = newCh.length - 1;</span><span class="s2">\n        </span><span class="s1">var newStartVnode = newCh[0];</span><span class="s2">\n        </span><span class="s1">var newEndVnode = newCh[newEndIdx];</span><span class="s2">\n        </span><span class="s1">var oldKeyToIdx, idxInOld, vnodeToMove, refElm;</span><span class="s2">\n        </span><span class="s1">// removeOnly is a special flag used only by &lt;transition-group&gt;</span><span class="s2">\n        </span><span class="s1">// to ensure removed elements stay in correct relative positions</span><span class="s2">\n        </span><span class="s1">// during leaving transitions</span><span class="s2">\n        </span><span class="s1">var canMove = !removeOnly;</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">checkDuplicateKeys(newCh);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {</span><span class="s2">\n            </span><span class="s1">if (isUndef(oldStartVnode)) {</span><span class="s2">\n                </span><span class="s1">oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (isUndef(oldEndVnode)) {</span><span class="s2">\n                </span><span class="s1">oldEndVnode = oldCh[--oldEndIdx];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (sameVnode(oldStartVnode, newStartVnode)) {</span><span class="s2">\n                </span><span class="s1">patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><span class="s2">\n                </span><span class="s1">oldStartVnode = oldCh[++oldStartIdx];</span><span class="s2">\n                </span><span class="s1">newStartVnode = newCh[++newStartIdx];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (sameVnode(oldEndVnode, newEndVnode)) {</span><span class="s2">\n                </span><span class="s1">patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);</span><span class="s2">\n                </span><span class="s1">oldEndVnode = oldCh[--oldEndIdx];</span><span class="s2">\n                </span><span class="s1">newEndVnode = newCh[--newEndIdx];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (sameVnode(oldStartVnode, newEndVnode)) {</span><span class="s2">\n                </span><span class="s1">// Vnode moved right</span><span class="s2">\n                </span><span class="s1">patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);</span><span class="s2">\n                </span><span class="s1">canMove &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));</span><span class="s2">\n                </span><span class="s1">oldStartVnode = oldCh[++oldStartIdx];</span><span class="s2">\n                </span><span class="s1">newEndVnode = newCh[--newEndIdx];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (sameVnode(oldEndVnode, newStartVnode)) {</span><span class="s2">\n                </span><span class="s1">// Vnode moved left</span><span class="s2">\n                </span><span class="s1">patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><span class="s2">\n                </span><span class="s1">canMove &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);</span><span class="s2">\n                </span><span class="s1">oldEndVnode = oldCh[--oldEndIdx];</span><span class="s2">\n                </span><span class="s1">newStartVnode = newCh[++newStartIdx];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">if (isUndef(oldKeyToIdx))</span><span class="s2">\n                    </span><span class="s1">oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);</span><span class="s2">\n                </span><span class="s1">idxInOld = isDef(newStartVnode.key)</span><span class="s2">\n                    </span><span class="s1">? oldKeyToIdx[newStartVnode.key]</span><span class="s2">\n                    </span><span class="s1">: findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><span class="s2">\n                </span><span class="s1">if (isUndef(idxInOld)) {</span><span class="s2">\n                    </span><span class="s1">// New element</span><span class="s2">\n                    </span><span class="s1">createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">vnodeToMove = oldCh[idxInOld];</span><span class="s2">\n                    </span><span class="s1">if (sameVnode(vnodeToMove, newStartVnode)) {</span><span class="s2">\n                        </span><span class="s1">patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><span class="s2">\n                        </span><span class="s1">oldCh[idxInOld] = undefined;</span><span class="s2">\n                        </span><span class="s1">canMove &amp;&amp;</span><span class="s2">\n                            </span><span class="s1">nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">// same key but different element. treat as new element</span><span class="s2">\n                        </span><span class="s1">createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">newStartVnode = newCh[++newStartIdx];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (oldStartIdx &gt; oldEndIdx) {</span><span class="s2">\n            </span><span class="s1">refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;</span><span class="s2">\n            </span><span class="s1">addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (newStartIdx &gt; newEndIdx) {</span><span class="s2">\n            </span><span class="s1">removeVnodes(oldCh, oldStartIdx, oldEndIdx);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function checkDuplicateKeys(children) {</span><span class="s2">\n        </span><span class="s1">var seenKeys = {};</span><span class="s2">\n        </span><span class="s1">for (var i_4 = 0; i_4 &lt; children.length; i_4++) {</span><span class="s2">\n            </span><span class="s1">var vnode = children[i_4];</span><span class="s2">\n            </span><span class="s1">var key = vnode.key;</span><span class="s2">\n            </span><span class="s1">if (isDef(key)) {</span><span class="s2">\n                </span><span class="s1">if (seenKeys[key]) {</span><span class="s2">\n                    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">Duplicate keys detected: '</span><span class="s2">\&quot;</span><span class="s1">.concat(key, </span><span class="s2">\&quot;</span><span class="s1">'. This may cause an update error.</span><span class="s2">\&quot;</span><span class="s1">), vnode.context);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">seenKeys[key] = true;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function findIdxInOld(node, oldCh, start, end) {</span><span class="s2">\n        </span><span class="s1">for (var i_5 = start; i_5 &lt; end; i_5++) {</span><span class="s2">\n            </span><span class="s1">var c = oldCh[i_5];</span><span class="s2">\n            </span><span class="s1">if (isDef(c) &amp;&amp; sameVnode(node, c))</span><span class="s2">\n                </span><span class="s1">return i_5;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {</span><span class="s2">\n        </span><span class="s1">if (oldVnode === vnode) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) {</span><span class="s2">\n            </span><span class="s1">// clone reused vnode</span><span class="s2">\n            </span><span class="s1">vnode = ownerArray[index] = cloneVNode(vnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var elm = (vnode.elm = oldVnode.elm);</span><span class="s2">\n        </span><span class="s1">if (isTrue(oldVnode.isAsyncPlaceholder)) {</span><span class="s2">\n            </span><span class="s1">if (isDef(vnode.asyncFactory.resolved)) {</span><span class="s2">\n                </span><span class="s1">hydrate(oldVnode.elm, vnode, insertedVnodeQueue);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">vnode.isAsyncPlaceholder = true;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// reuse element for static trees.</span><span class="s2">\n        </span><span class="s1">// note we only do this if the vnode is cloned -</span><span class="s2">\n        </span><span class="s1">// if the new node is not cloned it means the render functions have been</span><span class="s2">\n        </span><span class="s1">// reset by the hot-reload-api and we need to do a proper re-render.</span><span class="s2">\n        </span><span class="s1">if (isTrue(vnode.isStatic) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">isTrue(oldVnode.isStatic) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">vnode.key === oldVnode.key &amp;&amp;</span><span class="s2">\n            </span><span class="s1">(isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {</span><span class="s2">\n            </span><span class="s1">vnode.componentInstance = oldVnode.componentInstance;</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var i;</span><span class="s2">\n        </span><span class="s1">var data = vnode.data;</span><span class="s2">\n        </span><span class="s1">if (isDef(data) &amp;&amp; isDef((i = data.hook)) &amp;&amp; isDef((i = i.prepatch))) {</span><span class="s2">\n            </span><span class="s1">i(oldVnode, vnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var oldCh = oldVnode.children;</span><span class="s2">\n        </span><span class="s1">var ch = vnode.children;</span><span class="s2">\n        </span><span class="s1">if (isDef(data) &amp;&amp; isPatchable(vnode)) {</span><span class="s2">\n            </span><span class="s1">for (i = 0; i &lt; cbs.update.length; ++i)</span><span class="s2">\n                </span><span class="s1">cbs.update[i](oldVnode, vnode);</span><span class="s2">\n            </span><span class="s1">if (isDef((i = data.hook)) &amp;&amp; isDef((i = i.update)))</span><span class="s2">\n                </span><span class="s1">i(oldVnode, vnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isUndef(vnode.text)) {</span><span class="s2">\n            </span><span class="s1">if (isDef(oldCh) &amp;&amp; isDef(ch)) {</span><span class="s2">\n                </span><span class="s1">if (oldCh !== ch)</span><span class="s2">\n                    </span><span class="s1">updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (isDef(ch)) {</span><span class="s2">\n                </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n                    </span><span class="s1">checkDuplicateKeys(ch);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (isDef(oldVnode.text))</span><span class="s2">\n                    </span><span class="s1">nodeOps.setTextContent(elm, '');</span><span class="s2">\n                </span><span class="s1">addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (isDef(oldCh)) {</span><span class="s2">\n                </span><span class="s1">removeVnodes(oldCh, 0, oldCh.length - 1);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (isDef(oldVnode.text)) {</span><span class="s2">\n                </span><span class="s1">nodeOps.setTextContent(elm, '');</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (oldVnode.text !== vnode.text) {</span><span class="s2">\n            </span><span class="s1">nodeOps.setTextContent(elm, vnode.text);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isDef(data)) {</span><span class="s2">\n            </span><span class="s1">if (isDef((i = data.hook)) &amp;&amp; isDef((i = i.postpatch)))</span><span class="s2">\n                </span><span class="s1">i(oldVnode, vnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function invokeInsertHook(vnode, queue, initial) {</span><span class="s2">\n        </span><span class="s1">// delay insert hooks for component root nodes, invoke them after the</span><span class="s2">\n        </span><span class="s1">// element is really inserted</span><span class="s2">\n        </span><span class="s1">if (isTrue(initial) &amp;&amp; isDef(vnode.parent)) {</span><span class="s2">\n            </span><span class="s1">vnode.parent.data.pendingInsert = queue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">for (var i_6 = 0; i_6 &lt; queue.length; ++i_6) {</span><span class="s2">\n                </span><span class="s1">queue[i_6].data.hook.insert(queue[i_6]);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var hydrationBailed = false;</span><span class="s2">\n    </span><span class="s1">// list of modules that can skip create hook during hydration because they</span><span class="s2">\n    </span><span class="s1">// are already rendered on the client or has no need for initialization</span><span class="s2">\n    </span><span class="s1">// Note: style is excluded because it relies on initial clone for future</span><span class="s2">\n    </span><span class="s1">// deep updates (#7063).</span><span class="s2">\n    </span><span class="s1">var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');</span><span class="s2">\n    </span><span class="s1">// Note: this is a browser-only function so we can assume elms are DOM nodes.</span><span class="s2">\n    </span><span class="s1">function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {</span><span class="s2">\n        </span><span class="s1">var i;</span><span class="s2">\n        </span><span class="s1">var tag = vnode.tag, data = vnode.data, children = vnode.children;</span><span class="s2">\n        </span><span class="s1">inVPre = inVPre || (data &amp;&amp; data.pre);</span><span class="s2">\n        </span><span class="s1">vnode.elm = elm;</span><span class="s2">\n        </span><span class="s1">if (isTrue(vnode.isComment) &amp;&amp; isDef(vnode.asyncFactory)) {</span><span class="s2">\n            </span><span class="s1">vnode.isAsyncPlaceholder = true;</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// assert node match</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">if (!assertNodeMatch(elm, vnode, inVPre)) {</span><span class="s2">\n                </span><span class="s1">return false;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isDef(data)) {</span><span class="s2">\n            </span><span class="s1">if (isDef((i = data.hook)) &amp;&amp; isDef((i = i.init)))</span><span class="s2">\n                </span><span class="s1">i(vnode, true /* hydrating */);</span><span class="s2">\n            </span><span class="s1">if (isDef((i = vnode.componentInstance))) {</span><span class="s2">\n                </span><span class="s1">// child component. it should have hydrated its own tree.</span><span class="s2">\n                </span><span class="s1">initComponent(vnode, insertedVnodeQueue);</span><span class="s2">\n                </span><span class="s1">return true;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isDef(tag)) {</span><span class="s2">\n            </span><span class="s1">if (isDef(children)) {</span><span class="s2">\n                </span><span class="s1">// empty element, allow client to pick up and populate children</span><span class="s2">\n                </span><span class="s1">if (!elm.hasChildNodes()) {</span><span class="s2">\n                    </span><span class="s1">createChildren(vnode, children, insertedVnodeQueue);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">// v-html and domProps: innerHTML</span><span class="s2">\n                    </span><span class="s1">if (isDef((i = data)) &amp;&amp;</span><span class="s2">\n                        </span><span class="s1">isDef((i = i.domProps)) &amp;&amp;</span><span class="s2">\n                        </span><span class="s1">isDef((i = i.innerHTML))) {</span><span class="s2">\n                        </span><span class="s1">if (i !== elm.innerHTML) {</span><span class="s2">\n                            </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n                            </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n                                </span><span class="s1">typeof console !== 'undefined' &amp;&amp;</span><span class="s2">\n                                </span><span class="s1">!hydrationBailed) {</span><span class="s2">\n                                </span><span class="s1">hydrationBailed = true;</span><span class="s2">\n                                </span><span class="s1">console.warn('Parent: ', elm);</span><span class="s2">\n                                </span><span class="s1">console.warn('server innerHTML: ', i);</span><span class="s2">\n                                </span><span class="s1">console.warn('client innerHTML: ', elm.innerHTML);</span><span class="s2">\n                            </span><span class="s1">}</span><span class="s2">\n                            </span><span class="s1">return false;</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">// iterate and compare children lists</span><span class="s2">\n                        </span><span class="s1">var childrenMatch = true;</span><span class="s2">\n                        </span><span class="s1">var childNode = elm.firstChild;</span><span class="s2">\n                        </span><span class="s1">for (var i_7 = 0; i_7 &lt; children.length; i_7++) {</span><span class="s2">\n                            </span><span class="s1">if (!childNode ||</span><span class="s2">\n                                </span><span class="s1">!hydrate(childNode, children[i_7], insertedVnodeQueue, inVPre)) {</span><span class="s2">\n                                </span><span class="s1">childrenMatch = false;</span><span class="s2">\n                                </span><span class="s1">break;</span><span class="s2">\n                            </span><span class="s1">}</span><span class="s2">\n                            </span><span class="s1">childNode = childNode.nextSibling;</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">// if childNode is not null, it means the actual childNodes list is</span><span class="s2">\n                        </span><span class="s1">// longer than the virtual children list.</span><span class="s2">\n                        </span><span class="s1">if (!childrenMatch || childNode) {</span><span class="s2">\n                            </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n                            </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n                                </span><span class="s1">typeof console !== 'undefined' &amp;&amp;</span><span class="s2">\n                                </span><span class="s1">!hydrationBailed) {</span><span class="s2">\n                                </span><span class="s1">hydrationBailed = true;</span><span class="s2">\n                                </span><span class="s1">console.warn('Parent: ', elm);</span><span class="s2">\n                                </span><span class="s1">console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);</span><span class="s2">\n                            </span><span class="s1">}</span><span class="s2">\n                            </span><span class="s1">return false;</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (isDef(data)) {</span><span class="s2">\n                </span><span class="s1">var fullInvoke = false;</span><span class="s2">\n                </span><span class="s1">for (var key in data) {</span><span class="s2">\n                    </span><span class="s1">if (!isRenderedModule(key)) {</span><span class="s2">\n                        </span><span class="s1">fullInvoke = true;</span><span class="s2">\n                        </span><span class="s1">invokeCreateHooks(vnode, insertedVnodeQueue);</span><span class="s2">\n                        </span><span class="s1">break;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (!fullInvoke &amp;&amp; data['class']) {</span><span class="s2">\n                    </span><span class="s1">// ensure collecting deps for deep class bindings for future updates</span><span class="s2">\n                    </span><span class="s1">traverse(data['class']);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (elm.data !== vnode.text) {</span><span class="s2">\n            </span><span class="s1">elm.data = vnode.text;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function assertNodeMatch(node, vnode, inVPre) {</span><span class="s2">\n        </span><span class="s1">if (isDef(vnode.tag)) {</span><span class="s2">\n            </span><span class="s1">return (vnode.tag.indexOf('vue-component') === 0 ||</span><span class="s2">\n                </span><span class="s1">(!isUnknownElement(vnode, inVPre) &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">vnode.tag.toLowerCase() ===</span><span class="s2">\n                        </span><span class="s1">(node.tagName &amp;&amp; node.tagName.toLowerCase())));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">return node.nodeType === (vnode.isComment ? 8 : 3);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return function patch(oldVnode, vnode, hydrating, removeOnly) {</span><span class="s2">\n        </span><span class="s1">if (isUndef(vnode)) {</span><span class="s2">\n            </span><span class="s1">if (isDef(oldVnode))</span><span class="s2">\n                </span><span class="s1">invokeDestroyHook(oldVnode);</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var isInitialPatch = false;</span><span class="s2">\n        </span><span class="s1">var insertedVnodeQueue = [];</span><span class="s2">\n        </span><span class="s1">if (isUndef(oldVnode)) {</span><span class="s2">\n            </span><span class="s1">// empty mount (likely as component), create new root element</span><span class="s2">\n            </span><span class="s1">isInitialPatch = true;</span><span class="s2">\n            </span><span class="s1">createElm(vnode, insertedVnodeQueue);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">var isRealElement = isDef(oldVnode.nodeType);</span><span class="s2">\n            </span><span class="s1">if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) {</span><span class="s2">\n                </span><span class="s1">// patch existing root node</span><span class="s2">\n                </span><span class="s1">patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">if (isRealElement) {</span><span class="s2">\n                    </span><span class="s1">// mounting to a real element</span><span class="s2">\n                    </span><span class="s1">// check if this is server-rendered content and if we can perform</span><span class="s2">\n                    </span><span class="s1">// a successful hydration.</span><span class="s2">\n                    </span><span class="s1">if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) {</span><span class="s2">\n                        </span><span class="s1">oldVnode.removeAttribute(SSR_ATTR);</span><span class="s2">\n                        </span><span class="s1">hydrating = true;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">if (isTrue(hydrating)) {</span><span class="s2">\n                        </span><span class="s1">if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {</span><span class="s2">\n                            </span><span class="s1">invokeInsertHook(vnode, insertedVnodeQueue, true);</span><span class="s2">\n                            </span><span class="s1">return oldVnode;</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n                            </span><span class="s1">warn('The client-side rendered virtual DOM tree is not matching ' +</span><span class="s2">\n                                </span><span class="s1">'server-rendered content. This is likely caused by incorrect ' +</span><span class="s2">\n                                </span><span class="s1">'HTML markup, for example nesting block-level elements inside ' +</span><span class="s2">\n                                </span><span class="s1">'&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing ' +</span><span class="s2">\n                                </span><span class="s1">'full client-side render.');</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">// either not server-rendered, or hydration failed.</span><span class="s2">\n                    </span><span class="s1">// create an empty node and replace it</span><span class="s2">\n                    </span><span class="s1">oldVnode = emptyNodeAt(oldVnode);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// replacing existing element</span><span class="s2">\n                </span><span class="s1">var oldElm = oldVnode.elm;</span><span class="s2">\n                </span><span class="s1">var parentElm = nodeOps.parentNode(oldElm);</span><span class="s2">\n                </span><span class="s1">// create new node</span><span class="s2">\n                </span><span class="s1">createElm(vnode, insertedVnodeQueue, </span><span class="s2">\n                </span><span class="s1">// extremely rare edge case: do not insert if old element is in a</span><span class="s2">\n                </span><span class="s1">// leaving transition. Only happens when combining transition +</span><span class="s2">\n                </span><span class="s1">// keep-alive + HOCs. (#4590)</span><span class="s2">\n                </span><span class="s1">oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));</span><span class="s2">\n                </span><span class="s1">// update parent placeholder node element, recursively</span><span class="s2">\n                </span><span class="s1">if (isDef(vnode.parent)) {</span><span class="s2">\n                    </span><span class="s1">var ancestor = vnode.parent;</span><span class="s2">\n                    </span><span class="s1">var patchable = isPatchable(vnode);</span><span class="s2">\n                    </span><span class="s1">while (ancestor) {</span><span class="s2">\n                        </span><span class="s1">for (var i_8 = 0; i_8 &lt; cbs.destroy.length; ++i_8) {</span><span class="s2">\n                            </span><span class="s1">cbs.destroy[i_8](ancestor);</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">ancestor.elm = vnode.elm;</span><span class="s2">\n                        </span><span class="s1">if (patchable) {</span><span class="s2">\n                            </span><span class="s1">for (var i_9 = 0; i_9 &lt; cbs.create.length; ++i_9) {</span><span class="s2">\n                                </span><span class="s1">cbs.create[i_9](emptyNode, ancestor);</span><span class="s2">\n                            </span><span class="s1">}</span><span class="s2">\n                            </span><span class="s1">// #6513</span><span class="s2">\n                            </span><span class="s1">// invoke insert hooks that may have been merged by create hooks.</span><span class="s2">\n                            </span><span class="s1">// e.g. for directives that uses the </span><span class="s2">\&quot;</span><span class="s1">inserted</span><span class="s2">\&quot; </span><span class="s1">hook.</span><span class="s2">\n                            </span><span class="s1">var insert_1 = ancestor.data.hook.insert;</span><span class="s2">\n                            </span><span class="s1">if (insert_1.merged) {</span><span class="s2">\n                                </span><span class="s1">// start at index 1 to avoid re-invoking component mounted hook</span><span class="s2">\n                                </span><span class="s1">for (var i_10 = 1; i_10 &lt; insert_1.fns.length; i_10++) {</span><span class="s2">\n                                    </span><span class="s1">insert_1.fns[i_10]();</span><span class="s2">\n                                </span><span class="s1">}</span><span class="s2">\n                            </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">else {</span><span class="s2">\n                            </span><span class="s1">registerRef(ancestor);</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">ancestor = ancestor.parent;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// destroy old node</span><span class="s2">\n                </span><span class="s1">if (isDef(parentElm)) {</span><span class="s2">\n                    </span><span class="s1">removeVnodes([oldVnode], 0, 0);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (isDef(oldVnode.tag)) {</span><span class="s2">\n                    </span><span class="s1">invokeDestroyHook(oldVnode);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);</span><span class="s2">\n        </span><span class="s1">return vnode.elm;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var directives = {</span><span class="s2">\n    </span><span class="s1">create: updateDirectives,</span><span class="s2">\n    </span><span class="s1">update: updateDirectives,</span><span class="s2">\n    </span><span class="s1">destroy: function unbindDirectives(vnode) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error emptyNode is not VNodeWithData</span><span class="s2">\n        </span><span class="s1">updateDirectives(vnode, emptyNode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function updateDirectives(oldVnode, vnode) {</span><span class="s2">\n    </span><span class="s1">if (oldVnode.data.directives || vnode.data.directives) {</span><span class="s2">\n        </span><span class="s1">_update(oldVnode, vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function _update(oldVnode, vnode) {</span><span class="s2">\n    </span><span class="s1">var isCreate = oldVnode === emptyNode;</span><span class="s2">\n    </span><span class="s1">var isDestroy = vnode === emptyNode;</span><span class="s2">\n    </span><span class="s1">var oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);</span><span class="s2">\n    </span><span class="s1">var newDirs = normalizeDirectives(vnode.data.directives, vnode.context);</span><span class="s2">\n    </span><span class="s1">var dirsWithInsert = [];</span><span class="s2">\n    </span><span class="s1">var dirsWithPostpatch = [];</span><span class="s2">\n    </span><span class="s1">var key, oldDir, dir;</span><span class="s2">\n    </span><span class="s1">for (key in newDirs) {</span><span class="s2">\n        </span><span class="s1">oldDir = oldDirs[key];</span><span class="s2">\n        </span><span class="s1">dir = newDirs[key];</span><span class="s2">\n        </span><span class="s1">if (!oldDir) {</span><span class="s2">\n            </span><span class="s1">// new directive, bind</span><span class="s2">\n            </span><span class="s1">callHook(dir, 'bind', vnode, oldVnode);</span><span class="s2">\n            </span><span class="s1">if (dir.def &amp;&amp; dir.def.inserted) {</span><span class="s2">\n                </span><span class="s1">dirsWithInsert.push(dir);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// existing directive, update</span><span class="s2">\n            </span><span class="s1">dir.oldValue = oldDir.value;</span><span class="s2">\n            </span><span class="s1">dir.oldArg = oldDir.arg;</span><span class="s2">\n            </span><span class="s1">callHook(dir, 'update', vnode, oldVnode);</span><span class="s2">\n            </span><span class="s1">if (dir.def &amp;&amp; dir.def.componentUpdated) {</span><span class="s2">\n                </span><span class="s1">dirsWithPostpatch.push(dir);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (dirsWithInsert.length) {</span><span class="s2">\n        </span><span class="s1">var callInsert = function () {</span><span class="s2">\n            </span><span class="s1">for (var i = 0; i &lt; dirsWithInsert.length; i++) {</span><span class="s2">\n                </span><span class="s1">callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">if (isCreate) {</span><span class="s2">\n            </span><span class="s1">mergeVNodeHook(vnode, 'insert', callInsert);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">callInsert();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (dirsWithPostpatch.length) {</span><span class="s2">\n        </span><span class="s1">mergeVNodeHook(vnode, 'postpatch', function () {</span><span class="s2">\n            </span><span class="s1">for (var i = 0; i &lt; dirsWithPostpatch.length; i++) {</span><span class="s2">\n                </span><span class="s1">callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!isCreate) {</span><span class="s2">\n        </span><span class="s1">for (key in oldDirs) {</span><span class="s2">\n            </span><span class="s1">if (!newDirs[key]) {</span><span class="s2">\n                </span><span class="s1">// no longer present, unbind</span><span class="s2">\n                </span><span class="s1">callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var emptyModifiers = Object.create(null);</span><span class="s2">\n</span><span class="s1">function normalizeDirectives(dirs, vm) {</span><span class="s2">\n    </span><span class="s1">var res = Object.create(null);</span><span class="s2">\n    </span><span class="s1">if (!dirs) {</span><span class="s2">\n        </span><span class="s1">// $flow-disable-line</span><span class="s2">\n        </span><span class="s1">return res;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var i, dir;</span><span class="s2">\n    </span><span class="s1">for (i = 0; i &lt; dirs.length; i++) {</span><span class="s2">\n        </span><span class="s1">dir = dirs[i];</span><span class="s2">\n        </span><span class="s1">if (!dir.modifiers) {</span><span class="s2">\n            </span><span class="s1">// $flow-disable-line</span><span class="s2">\n            </span><span class="s1">dir.modifiers = emptyModifiers;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">res[getRawDirName(dir)] = dir;</span><span class="s2">\n        </span><span class="s1">if (vm._setupState &amp;&amp; vm._setupState.__sfc) {</span><span class="s2">\n            </span><span class="s1">var setupDef = dir.def || resolveAsset(vm, '_setupState', 'v-' + dir.name);</span><span class="s2">\n            </span><span class="s1">if (typeof setupDef === 'function') {</span><span class="s2">\n                </span><span class="s1">dir.def = {</span><span class="s2">\n                    </span><span class="s1">bind: setupDef,</span><span class="s2">\n                    </span><span class="s1">update: setupDef,</span><span class="s2">\n                </span><span class="s1">};</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">dir.def = setupDef;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">dir.def = dir.def || resolveAsset(vm.$options, 'directives', dir.name, true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// $flow-disable-line</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getRawDirName(dir) {</span><span class="s2">\n    </span><span class="s1">return (dir.rawName || </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(dir.name, </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">).concat(Object.keys(dir.modifiers || {}).join('.')));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function callHook(dir, hook, vnode, oldVnode, isDestroy) {</span><span class="s2">\n    </span><span class="s1">var fn = dir.def &amp;&amp; dir.def[hook];</span><span class="s2">\n    </span><span class="s1">if (fn) {</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">fn(vnode.elm, dir, vnode, oldVnode, isDestroy);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">catch (e) {</span><span class="s2">\n            </span><span class="s1">handleError(e, vnode.context, </span><span class="s2">\&quot;</span><span class="s1">directive </span><span class="s2">\&quot;</span><span class="s1">.concat(dir.name, </span><span class="s2">\&quot; \&quot;</span><span class="s1">).concat(hook, </span><span class="s2">\&quot; </span><span class="s1">hook</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var baseModules = [ref, directives];</span><span class="s2">\n\n</span><span class="s1">function updateAttrs(oldVnode, vnode) {</span><span class="s2">\n    </span><span class="s1">var opts = vnode.componentOptions;</span><span class="s2">\n    </span><span class="s1">if (isDef(opts) &amp;&amp; opts.Ctor.options.inheritAttrs === false) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isUndef(oldVnode.data.attrs) &amp;&amp; isUndef(vnode.data.attrs)) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var key, cur, old;</span><span class="s2">\n    </span><span class="s1">var elm = vnode.elm;</span><span class="s2">\n    </span><span class="s1">var oldAttrs = oldVnode.data.attrs || {};</span><span class="s2">\n    </span><span class="s1">var attrs = vnode.data.attrs || {};</span><span class="s2">\n    </span><span class="s1">// clone observed objects, as the user probably wants to mutate it</span><span class="s2">\n    </span><span class="s1">if (isDef(attrs.__ob__) || isTrue(attrs._v_attr_proxy)) {</span><span class="s2">\n        </span><span class="s1">attrs = vnode.data.attrs = extend({}, attrs);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (key in attrs) {</span><span class="s2">\n        </span><span class="s1">cur = attrs[key];</span><span class="s2">\n        </span><span class="s1">old = oldAttrs[key];</span><span class="s2">\n        </span><span class="s1">if (old !== cur) {</span><span class="s2">\n            </span><span class="s1">setAttr(elm, key, cur, vnode.data.pre);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// #4391: in IE9, setting type can reset value for input[type=radio]</span><span class="s2">\n    </span><span class="s1">// #6666: IE/Edge forces progress value down to 1 before setting a max</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if ((isIE || isEdge) &amp;&amp; attrs.value !== oldAttrs.value) {</span><span class="s2">\n        </span><span class="s1">setAttr(elm, 'value', attrs.value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (key in oldAttrs) {</span><span class="s2">\n        </span><span class="s1">if (isUndef(attrs[key])) {</span><span class="s2">\n            </span><span class="s1">if (isXlink(key)) {</span><span class="s2">\n                </span><span class="s1">elm.removeAttributeNS(xlinkNS, getXlinkProp(key));</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (!isEnumeratedAttr(key)) {</span><span class="s2">\n                </span><span class="s1">elm.removeAttribute(key);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setAttr(el, key, value, isInPre) {</span><span class="s2">\n    </span><span class="s1">if (isInPre || el.tagName.indexOf('-') &gt; -1) {</span><span class="s2">\n        </span><span class="s1">baseSetAttr(el, key, value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isBooleanAttr(key)) {</span><span class="s2">\n        </span><span class="s1">// set attribute for blank value</span><span class="s2">\n        </span><span class="s1">// e.g. &lt;option disabled&gt;Select one&lt;/option&gt;</span><span class="s2">\n        </span><span class="s1">if (isFalsyAttrValue(value)) {</span><span class="s2">\n            </span><span class="s1">el.removeAttribute(key);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// technically allowfullscreen is a boolean attribute for &lt;iframe&gt;,</span><span class="s2">\n            </span><span class="s1">// but Flash expects a value of </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot; </span><span class="s1">when used on &lt;embed&gt; tag</span><span class="s2">\n            </span><span class="s1">value = key === 'allowfullscreen' &amp;&amp; el.tagName === 'EMBED' ? 'true' : key;</span><span class="s2">\n            </span><span class="s1">el.setAttribute(key, value);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isEnumeratedAttr(key)) {</span><span class="s2">\n        </span><span class="s1">el.setAttribute(key, convertEnumeratedValue(key, value));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isXlink(key)) {</span><span class="s2">\n        </span><span class="s1">if (isFalsyAttrValue(value)) {</span><span class="s2">\n            </span><span class="s1">el.removeAttributeNS(xlinkNS, getXlinkProp(key));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">el.setAttributeNS(xlinkNS, key, value);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">baseSetAttr(el, key, value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function baseSetAttr(el, key, value) {</span><span class="s2">\n    </span><span class="s1">if (isFalsyAttrValue(value)) {</span><span class="s2">\n        </span><span class="s1">el.removeAttribute(key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// #7138: IE10 &amp; 11 fires input event when setting placeholder on</span><span class="s2">\n        </span><span class="s1">// &lt;textarea&gt;... block the first input event and remove the blocker</span><span class="s2">\n        </span><span class="s1">// immediately.</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n        </span><span class="s1">if (isIE &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!isIE9 &amp;&amp;</span><span class="s2">\n            </span><span class="s1">el.tagName === 'TEXTAREA' &amp;&amp;</span><span class="s2">\n            </span><span class="s1">key === 'placeholder' &amp;&amp;</span><span class="s2">\n            </span><span class="s1">value !== '' &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!el.__ieph) {</span><span class="s2">\n            </span><span class="s1">var blocker_1 = function (e) {</span><span class="s2">\n                </span><span class="s1">e.stopImmediatePropagation();</span><span class="s2">\n                </span><span class="s1">el.removeEventListener('input', blocker_1);</span><span class="s2">\n            </span><span class="s1">};</span><span class="s2">\n            </span><span class="s1">el.addEventListener('input', blocker_1);</span><span class="s2">\n            </span><span class="s1">// $flow-disable-line</span><span class="s2">\n            </span><span class="s1">el.__ieph = true; /* IE placeholder patched */</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">el.setAttribute(key, value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var attrs = {</span><span class="s2">\n    </span><span class="s1">create: updateAttrs,</span><span class="s2">\n    </span><span class="s1">update: updateAttrs</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">function updateClass(oldVnode, vnode) {</span><span class="s2">\n    </span><span class="s1">var el = vnode.elm;</span><span class="s2">\n    </span><span class="s1">var data = vnode.data;</span><span class="s2">\n    </span><span class="s1">var oldData = oldVnode.data;</span><span class="s2">\n    </span><span class="s1">if (isUndef(data.staticClass) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">isUndef(data.class) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">(isUndef(oldData) ||</span><span class="s2">\n            </span><span class="s1">(isUndef(oldData.staticClass) &amp;&amp; isUndef(oldData.class)))) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var cls = genClassForVnode(vnode);</span><span class="s2">\n    </span><span class="s1">// handle transition classes</span><span class="s2">\n    </span><span class="s1">var transitionClass = el._transitionClasses;</span><span class="s2">\n    </span><span class="s1">if (isDef(transitionClass)) {</span><span class="s2">\n        </span><span class="s1">cls = concat(cls, stringifyClass(transitionClass));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// set the class</span><span class="s2">\n    </span><span class="s1">if (cls !== el._prevClass) {</span><span class="s2">\n        </span><span class="s1">el.setAttribute('class', cls);</span><span class="s2">\n        </span><span class="s1">el._prevClass = cls;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var klass = {</span><span class="s2">\n    </span><span class="s1">create: updateClass,</span><span class="s2">\n    </span><span class="s1">update: updateClass</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// in some cases, the event used has to be determined at runtime</span><span class="s2">\n</span><span class="s1">// so we used some reserved tokens during compile.</span><span class="s2">\n</span><span class="s1">var RANGE_TOKEN = '__r';</span><span class="s2">\n</span><span class="s1">var CHECKBOX_RADIO_TOKEN = '__c';</span><span class="s2">\n\n</span><span class="s1">// normalize v-model event tokens that can only be determined at runtime.</span><span class="s2">\n</span><span class="s1">// it's important to place the event as the first in the array because</span><span class="s2">\n</span><span class="s1">// the whole point is ensuring the v-model callback gets called before</span><span class="s2">\n</span><span class="s1">// user-attached handlers.</span><span class="s2">\n</span><span class="s1">function normalizeEvents(on) {</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (isDef(on[RANGE_TOKEN])) {</span><span class="s2">\n        </span><span class="s1">// IE input[type=range] only supports `change` event</span><span class="s2">\n        </span><span class="s1">var event_1 = isIE ? 'change' : 'input';</span><span class="s2">\n        </span><span class="s1">on[event_1] = [].concat(on[RANGE_TOKEN], on[event_1] || []);</span><span class="s2">\n        </span><span class="s1">delete on[RANGE_TOKEN];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// This was originally intended to fix #4521 but no longer necessary</span><span class="s2">\n    </span><span class="s1">// after 2.5. Keeping it for backwards compat with generated code from &lt; 2.4</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (isDef(on[CHECKBOX_RADIO_TOKEN])) {</span><span class="s2">\n        </span><span class="s1">on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);</span><span class="s2">\n        </span><span class="s1">delete on[CHECKBOX_RADIO_TOKEN];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var target;</span><span class="s2">\n</span><span class="s1">function createOnceHandler(event, handler, capture) {</span><span class="s2">\n    </span><span class="s1">var _target = target; // save current target element in closure</span><span class="s2">\n    </span><span class="s1">return function onceHandler() {</span><span class="s2">\n        </span><span class="s1">var res = handler.apply(null, arguments);</span><span class="s2">\n        </span><span class="s1">if (res !== null) {</span><span class="s2">\n            </span><span class="s1">remove(event, onceHandler, capture, _target);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// #9446: Firefox &lt;= 53 (in particular, ESR 52) has incorrect Event.timeStamp</span><span class="s2">\n</span><span class="s1">// implementation and does not fire microtasks in between event propagation, so</span><span class="s2">\n</span><span class="s1">// safe to exclude.</span><span class="s2">\n</span><span class="s1">var useMicrotaskFix = isUsingMicroTask &amp;&amp; !(isFF &amp;&amp; Number(isFF[1]) &lt;= 53);</span><span class="s2">\n</span><span class="s1">function add(name, handler, capture, passive) {</span><span class="s2">\n    </span><span class="s1">// async edge case #6566: inner click event triggers patch, event handler</span><span class="s2">\n    </span><span class="s1">// attached to outer element during patch, and triggered again. This</span><span class="s2">\n    </span><span class="s1">// happens because browsers fire microtask ticks between event propagation.</span><span class="s2">\n    </span><span class="s1">// the solution is simple: we save the timestamp when a handler is attached,</span><span class="s2">\n    </span><span class="s1">// and the handler would only fire if the event passed to it was fired</span><span class="s2">\n    </span><span class="s1">// AFTER it was attached.</span><span class="s2">\n    </span><span class="s1">if (useMicrotaskFix) {</span><span class="s2">\n        </span><span class="s1">var attachedTimestamp_1 = currentFlushTimestamp;</span><span class="s2">\n        </span><span class="s1">var original_1 = handler;</span><span class="s2">\n        </span><span class="s1">//@ts-expect-error</span><span class="s2">\n        </span><span class="s1">handler = original_1._wrapper = function (e) {</span><span class="s2">\n            </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">// no bubbling, should always fire.</span><span class="s2">\n            </span><span class="s1">// this is just a safety net in case event.timeStamp is unreliable in</span><span class="s2">\n            </span><span class="s1">// certain weird environments...</span><span class="s2">\n            </span><span class="s1">e.target === e.currentTarget ||</span><span class="s2">\n                </span><span class="s1">// event is fired after handler attachment</span><span class="s2">\n                </span><span class="s1">e.timeStamp &gt;= attachedTimestamp_1 ||</span><span class="s2">\n                </span><span class="s1">// bail for environments that have buggy event.timeStamp implementations</span><span class="s2">\n                </span><span class="s1">// #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState</span><span class="s2">\n                </span><span class="s1">// #9681 QtWebEngine event.timeStamp is negative value</span><span class="s2">\n                </span><span class="s1">e.timeStamp &lt;= 0 ||</span><span class="s2">\n                </span><span class="s1">// #9448 bail if event is fired in another document in a multi-page</span><span class="s2">\n                </span><span class="s1">// electron/nw.js app, since event.timeStamp will be using a different</span><span class="s2">\n                </span><span class="s1">// starting reference</span><span class="s2">\n                </span><span class="s1">e.target.ownerDocument !== document) {</span><span class="s2">\n                </span><span class="s1">return original_1.apply(this, arguments);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">target.addEventListener(name, handler, supportsPassive ? { capture: capture, passive: passive } : capture);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function remove(name, handler, capture, _target) {</span><span class="s2">\n    </span><span class="s1">(_target || target).removeEventListener(name, </span><span class="s2">\n    </span><span class="s1">//@ts-expect-error</span><span class="s2">\n    </span><span class="s1">handler._wrapper || handler, capture);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function updateDOMListeners(oldVnode, vnode) {</span><span class="s2">\n    </span><span class="s1">if (isUndef(oldVnode.data.on) &amp;&amp; isUndef(vnode.data.on)) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var on = vnode.data.on || {};</span><span class="s2">\n    </span><span class="s1">var oldOn = oldVnode.data.on || {};</span><span class="s2">\n    </span><span class="s1">// vnode is empty when removing all listeners,</span><span class="s2">\n    </span><span class="s1">// and use old vnode dom element</span><span class="s2">\n    </span><span class="s1">target = vnode.elm || oldVnode.elm;</span><span class="s2">\n    </span><span class="s1">normalizeEvents(on);</span><span class="s2">\n    </span><span class="s1">updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);</span><span class="s2">\n    </span><span class="s1">target = undefined;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var events = {</span><span class="s2">\n    </span><span class="s1">create: updateDOMListeners,</span><span class="s2">\n    </span><span class="s1">update: updateDOMListeners,</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error emptyNode has actually data</span><span class="s2">\n    </span><span class="s1">destroy: function (vnode) { return updateDOMListeners(vnode, emptyNode); }</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">var svgContainer;</span><span class="s2">\n</span><span class="s1">function updateDOMProps(oldVnode, vnode) {</span><span class="s2">\n    </span><span class="s1">if (isUndef(oldVnode.data.domProps) &amp;&amp; isUndef(vnode.data.domProps)) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var key, cur;</span><span class="s2">\n    </span><span class="s1">var elm = vnode.elm;</span><span class="s2">\n    </span><span class="s1">var oldProps = oldVnode.data.domProps || {};</span><span class="s2">\n    </span><span class="s1">var props = vnode.data.domProps || {};</span><span class="s2">\n    </span><span class="s1">// clone observed objects, as the user probably wants to mutate it</span><span class="s2">\n    </span><span class="s1">if (isDef(props.__ob__) || isTrue(props._v_attr_proxy)) {</span><span class="s2">\n        </span><span class="s1">props = vnode.data.domProps = extend({}, props);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (key in oldProps) {</span><span class="s2">\n        </span><span class="s1">if (!(key in props)) {</span><span class="s2">\n            </span><span class="s1">elm[key] = '';</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (key in props) {</span><span class="s2">\n        </span><span class="s1">cur = props[key];</span><span class="s2">\n        </span><span class="s1">// ignore children if the node has textContent or innerHTML,</span><span class="s2">\n        </span><span class="s1">// as these will throw away existing DOM nodes and cause removal errors</span><span class="s2">\n        </span><span class="s1">// on subsequent patches (#3360)</span><span class="s2">\n        </span><span class="s1">if (key === 'textContent' || key === 'innerHTML') {</span><span class="s2">\n            </span><span class="s1">if (vnode.children)</span><span class="s2">\n                </span><span class="s1">vnode.children.length = 0;</span><span class="s2">\n            </span><span class="s1">if (cur === oldProps[key])</span><span class="s2">\n                </span><span class="s1">continue;</span><span class="s2">\n            </span><span class="s1">// #6601 work around Chrome version &lt;= 55 bug where single textNode</span><span class="s2">\n            </span><span class="s1">// replaced by innerHTML/textContent retains its parentNode property</span><span class="s2">\n            </span><span class="s1">if (elm.childNodes.length === 1) {</span><span class="s2">\n                </span><span class="s1">elm.removeChild(elm.childNodes[0]);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (key === 'value' &amp;&amp; elm.tagName !== 'PROGRESS') {</span><span class="s2">\n            </span><span class="s1">// store value as _value as well since</span><span class="s2">\n            </span><span class="s1">// non-string values will be stringified</span><span class="s2">\n            </span><span class="s1">elm._value = cur;</span><span class="s2">\n            </span><span class="s1">// avoid resetting cursor position when value is the same</span><span class="s2">\n            </span><span class="s1">var strCur = isUndef(cur) ? '' : String(cur);</span><span class="s2">\n            </span><span class="s1">if (shouldUpdateValue(elm, strCur)) {</span><span class="s2">\n                </span><span class="s1">elm.value = strCur;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (key === 'innerHTML' &amp;&amp;</span><span class="s2">\n            </span><span class="s1">isSVG(elm.tagName) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">isUndef(elm.innerHTML)) {</span><span class="s2">\n            </span><span class="s1">// IE doesn't support innerHTML for SVG elements</span><span class="s2">\n            </span><span class="s1">svgContainer = svgContainer || document.createElement('div');</span><span class="s2">\n            </span><span class="s1">svgContainer.innerHTML = </span><span class="s2">\&quot;</span><span class="s1">&lt;svg&gt;</span><span class="s2">\&quot;</span><span class="s1">.concat(cur, </span><span class="s2">\&quot;</span><span class="s1">&lt;/svg&gt;</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">var svg = svgContainer.firstChild;</span><span class="s2">\n            </span><span class="s1">while (elm.firstChild) {</span><span class="s2">\n                </span><span class="s1">elm.removeChild(elm.firstChild);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">while (svg.firstChild) {</span><span class="s2">\n                </span><span class="s1">elm.appendChild(svg.firstChild);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (</span><span class="s2">\n        </span><span class="s1">// skip the update if old and new VDOM state is the same.</span><span class="s2">\n        </span><span class="s1">// `value` is handled separately because the DOM value may be temporarily</span><span class="s2">\n        </span><span class="s1">// out of sync with VDOM state due to focus, composition and modifiers.</span><span class="s2">\n        </span><span class="s1">// This  #4521 by skipping the unnecessary `checked` update.</span><span class="s2">\n        </span><span class="s1">cur !== oldProps[key]) {</span><span class="s2">\n            </span><span class="s1">// some property updates can throw</span><span class="s2">\n            </span><span class="s1">// e.g. `value` on &lt;progress&gt; w/ non-finite value</span><span class="s2">\n            </span><span class="s1">try {</span><span class="s2">\n                </span><span class="s1">elm[key] = cur;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">catch (e) { }</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function shouldUpdateValue(elm, checkVal) {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n    </span><span class="s1">//@ts-expect-error</span><span class="s2">\n    </span><span class="s1">!elm.composing &amp;&amp;</span><span class="s2">\n        </span><span class="s1">(elm.tagName === 'OPTION' ||</span><span class="s2">\n            </span><span class="s1">isNotInFocusAndDirty(elm, checkVal) ||</span><span class="s2">\n            </span><span class="s1">isDirtyWithModifiers(elm, checkVal)));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isNotInFocusAndDirty(elm, checkVal) {</span><span class="s2">\n    </span><span class="s1">// return true when textbox (.number and .trim) loses focus and its value is</span><span class="s2">\n    </span><span class="s1">// not equal to the updated value</span><span class="s2">\n    </span><span class="s1">var notInFocus = true;</span><span class="s2">\n    </span><span class="s1">// #6157</span><span class="s2">\n    </span><span class="s1">// work around IE bug when accessing document.activeElement in an iframe</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">notInFocus = document.activeElement !== elm;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">catch (e) { }</span><span class="s2">\n    </span><span class="s1">return notInFocus &amp;&amp; elm.value !== checkVal;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isDirtyWithModifiers(elm, newVal) {</span><span class="s2">\n    </span><span class="s1">var value = elm.value;</span><span class="s2">\n    </span><span class="s1">var modifiers = elm._vModifiers; // injected by v-model runtime</span><span class="s2">\n    </span><span class="s1">if (isDef(modifiers)) {</span><span class="s2">\n        </span><span class="s1">if (modifiers.number) {</span><span class="s2">\n            </span><span class="s1">return toNumber(value) !== toNumber(newVal);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (modifiers.trim) {</span><span class="s2">\n            </span><span class="s1">return value.trim() !== newVal.trim();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return value !== newVal;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var domProps = {</span><span class="s2">\n    </span><span class="s1">create: updateDOMProps,</span><span class="s2">\n    </span><span class="s1">update: updateDOMProps</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">var parseStyleText = cached(function (cssText) {</span><span class="s2">\n    </span><span class="s1">var res = {};</span><span class="s2">\n    </span><span class="s1">var listDelimiter = /;(?![^(]*</span><span class="s2">\\</span><span class="s1">))/g;</span><span class="s2">\n    </span><span class="s1">var propertyDelimiter = /:(.+)/;</span><span class="s2">\n    </span><span class="s1">cssText.split(listDelimiter).forEach(function (item) {</span><span class="s2">\n        </span><span class="s1">if (item) {</span><span class="s2">\n            </span><span class="s1">var tmp = item.split(propertyDelimiter);</span><span class="s2">\n            </span><span class="s1">tmp.length &gt; 1 &amp;&amp; (res[tmp[0].trim()] = tmp[1].trim());</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">// merge static and dynamic style data on the same vnode</span><span class="s2">\n</span><span class="s1">function normalizeStyleData(data) {</span><span class="s2">\n    </span><span class="s1">var style = normalizeStyleBinding(data.style);</span><span class="s2">\n    </span><span class="s1">// static style is pre-processed into an object during compilation</span><span class="s2">\n    </span><span class="s1">// and is always a fresh object, so it's safe to merge into it</span><span class="s2">\n    </span><span class="s1">return data.staticStyle ? extend(data.staticStyle, style) : style;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// normalize possible array / string values into Object</span><span class="s2">\n</span><span class="s1">function normalizeStyleBinding(bindingStyle) {</span><span class="s2">\n    </span><span class="s1">if (Array.isArray(bindingStyle)) {</span><span class="s2">\n        </span><span class="s1">return toObject(bindingStyle);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (typeof bindingStyle === 'string') {</span><span class="s2">\n        </span><span class="s1">return parseStyleText(bindingStyle);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return bindingStyle;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* parent component style should be after child's</span><span class="s2">\n </span><span class="s1">* so that parent component's style could override it</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function getStyle(vnode, checkChild) {</span><span class="s2">\n    </span><span class="s1">var res = {};</span><span class="s2">\n    </span><span class="s1">var styleData;</span><span class="s2">\n    </span><span class="s1">if (checkChild) {</span><span class="s2">\n        </span><span class="s1">var childNode = vnode;</span><span class="s2">\n        </span><span class="s1">while (childNode.componentInstance) {</span><span class="s2">\n            </span><span class="s1">childNode = childNode.componentInstance._vnode;</span><span class="s2">\n            </span><span class="s1">if (childNode &amp;&amp;</span><span class="s2">\n                </span><span class="s1">childNode.data &amp;&amp;</span><span class="s2">\n                </span><span class="s1">(styleData = normalizeStyleData(childNode.data))) {</span><span class="s2">\n                </span><span class="s1">extend(res, styleData);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if ((styleData = normalizeStyleData(vnode.data))) {</span><span class="s2">\n        </span><span class="s1">extend(res, styleData);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var parentNode = vnode;</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error parentNode.parent not VNodeWithData</span><span class="s2">\n    </span><span class="s1">while ((parentNode = parentNode.parent)) {</span><span class="s2">\n        </span><span class="s1">if (parentNode.data &amp;&amp; (styleData = normalizeStyleData(parentNode.data))) {</span><span class="s2">\n            </span><span class="s1">extend(res, styleData);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var cssVarRE = /^--/;</span><span class="s2">\n</span><span class="s1">var importantRE = /</span><span class="s2">\\</span><span class="s1">s*!important$/;</span><span class="s2">\n</span><span class="s1">var setProp = function (el, name, val) {</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (cssVarRE.test(name)) {</span><span class="s2">\n        </span><span class="s1">el.style.setProperty(name, val);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (importantRE.test(val)) {</span><span class="s2">\n        </span><span class="s1">el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">var normalizedName = normalize(name);</span><span class="s2">\n        </span><span class="s1">if (Array.isArray(val)) {</span><span class="s2">\n            </span><span class="s1">// Support values array created by autoprefixer, e.g.</span><span class="s2">\n            </span><span class="s1">// {display: [</span><span class="s2">\&quot;</span><span class="s1">-webkit-box</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">-ms-flexbox</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">flex</span><span class="s2">\&quot;</span><span class="s1">]}</span><span class="s2">\n            </span><span class="s1">// Set them one by one, and the browser will only set those it can recognize</span><span class="s2">\n            </span><span class="s1">for (var i = 0, len = val.length; i &lt; len; i++) {</span><span class="s2">\n                </span><span class="s1">el.style[normalizedName] = val[i];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">el.style[normalizedName] = val;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var vendorNames = ['Webkit', 'Moz', 'ms'];</span><span class="s2">\n</span><span class="s1">var emptyStyle;</span><span class="s2">\n</span><span class="s1">var normalize = cached(function (prop) {</span><span class="s2">\n    </span><span class="s1">emptyStyle = emptyStyle || document.createElement('div').style;</span><span class="s2">\n    </span><span class="s1">prop = camelize(prop);</span><span class="s2">\n    </span><span class="s1">if (prop !== 'filter' &amp;&amp; prop in emptyStyle) {</span><span class="s2">\n        </span><span class="s1">return prop;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var capName = prop.charAt(0).toUpperCase() + prop.slice(1);</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; vendorNames.length; i++) {</span><span class="s2">\n        </span><span class="s1">var name_1 = vendorNames[i] + capName;</span><span class="s2">\n        </span><span class="s1">if (name_1 in emptyStyle) {</span><span class="s2">\n            </span><span class="s1">return name_1;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">function updateStyle(oldVnode, vnode) {</span><span class="s2">\n    </span><span class="s1">var data = vnode.data;</span><span class="s2">\n    </span><span class="s1">var oldData = oldVnode.data;</span><span class="s2">\n    </span><span class="s1">if (isUndef(data.staticStyle) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">isUndef(data.style) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">isUndef(oldData.staticStyle) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">isUndef(oldData.style)) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var cur, name;</span><span class="s2">\n    </span><span class="s1">var el = vnode.elm;</span><span class="s2">\n    </span><span class="s1">var oldStaticStyle = oldData.staticStyle;</span><span class="s2">\n    </span><span class="s1">var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};</span><span class="s2">\n    </span><span class="s1">// if static style exists, stylebinding already merged into it when doing normalizeStyleData</span><span class="s2">\n    </span><span class="s1">var oldStyle = oldStaticStyle || oldStyleBinding;</span><span class="s2">\n    </span><span class="s1">var style = normalizeStyleBinding(vnode.data.style) || {};</span><span class="s2">\n    </span><span class="s1">// store normalized style under a different key for next diff</span><span class="s2">\n    </span><span class="s1">// make sure to clone it if it's reactive, since the user likely wants</span><span class="s2">\n    </span><span class="s1">// to mutate it.</span><span class="s2">\n    </span><span class="s1">vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;</span><span class="s2">\n    </span><span class="s1">var newStyle = getStyle(vnode, true);</span><span class="s2">\n    </span><span class="s1">for (name in oldStyle) {</span><span class="s2">\n        </span><span class="s1">if (isUndef(newStyle[name])) {</span><span class="s2">\n            </span><span class="s1">setProp(el, name, '');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (name in newStyle) {</span><span class="s2">\n        </span><span class="s1">cur = newStyle[name];</span><span class="s2">\n        </span><span class="s1">if (cur !== oldStyle[name]) {</span><span class="s2">\n            </span><span class="s1">// ie9 setting to null has no effect, must use empty string</span><span class="s2">\n            </span><span class="s1">setProp(el, name, cur == null ? '' : cur);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var style = {</span><span class="s2">\n    </span><span class="s1">create: updateStyle,</span><span class="s2">\n    </span><span class="s1">update: updateStyle</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">var whitespaceRE = /</span><span class="s2">\\</span><span class="s1">s+/;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Add class with compatibility for SVG since classList is not supported on</span><span class="s2">\n </span><span class="s1">* SVG elements in IE</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function addClass(el, cls) {</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (!cls || !(cls = cls.trim())) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n    </span><span class="s1">if (el.classList) {</span><span class="s2">\n        </span><span class="s1">if (cls.indexOf(' ') &gt; -1) {</span><span class="s2">\n            </span><span class="s1">cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">el.classList.add(cls);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">var cur = </span><span class="s2">\&quot; \&quot;</span><span class="s1">.concat(el.getAttribute('class') || '', </span><span class="s2">\&quot; \&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">if (cur.indexOf(' ' + cls + ' ') &lt; 0) {</span><span class="s2">\n            </span><span class="s1">el.setAttribute('class', (cur + cls).trim());</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Remove class with compatibility for SVG since classList is not supported on</span><span class="s2">\n </span><span class="s1">* SVG elements in IE</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function removeClass(el, cls) {</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (!cls || !(cls = cls.trim())) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n    </span><span class="s1">if (el.classList) {</span><span class="s2">\n        </span><span class="s1">if (cls.indexOf(' ') &gt; -1) {</span><span class="s2">\n            </span><span class="s1">cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">el.classList.remove(cls);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (!el.classList.length) {</span><span class="s2">\n            </span><span class="s1">el.removeAttribute('class');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">var cur = </span><span class="s2">\&quot; \&quot;</span><span class="s1">.concat(el.getAttribute('class') || '', </span><span class="s2">\&quot; \&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">var tar = ' ' + cls + ' ';</span><span class="s2">\n        </span><span class="s1">while (cur.indexOf(tar) &gt;= 0) {</span><span class="s2">\n            </span><span class="s1">cur = cur.replace(tar, ' ');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">cur = cur.trim();</span><span class="s2">\n        </span><span class="s1">if (cur) {</span><span class="s2">\n            </span><span class="s1">el.setAttribute('class', cur);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">el.removeAttribute('class');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function resolveTransition(def) {</span><span class="s2">\n    </span><span class="s1">if (!def) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n    </span><span class="s1">if (typeof def === 'object') {</span><span class="s2">\n        </span><span class="s1">var res = {};</span><span class="s2">\n        </span><span class="s1">if (def.css !== false) {</span><span class="s2">\n            </span><span class="s1">extend(res, autoCssTransition(def.name || 'v'));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">extend(res, def);</span><span class="s2">\n        </span><span class="s1">return res;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (typeof def === 'string') {</span><span class="s2">\n        </span><span class="s1">return autoCssTransition(def);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var autoCssTransition = cached(function (name) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">enterClass: </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;</span><span class="s1">-enter</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n        </span><span class="s1">enterToClass: </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;</span><span class="s1">-enter-to</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n        </span><span class="s1">enterActiveClass: </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;</span><span class="s1">-enter-active</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n        </span><span class="s1">leaveClass: </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;</span><span class="s1">-leave</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n        </span><span class="s1">leaveToClass: </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;</span><span class="s1">-leave-to</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n        </span><span class="s1">leaveActiveClass: </span><span class="s2">\&quot;\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot;</span><span class="s1">-leave-active</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">var hasTransition = inBrowser &amp;&amp; !isIE9;</span><span class="s2">\n</span><span class="s1">var TRANSITION = 'transition';</span><span class="s2">\n</span><span class="s1">var ANIMATION = 'animation';</span><span class="s2">\n</span><span class="s1">// Transition property/event sniffing</span><span class="s2">\n</span><span class="s1">var transitionProp = 'transition';</span><span class="s2">\n</span><span class="s1">var transitionEndEvent = 'transitionend';</span><span class="s2">\n</span><span class="s1">var animationProp = 'animation';</span><span class="s2">\n</span><span class="s1">var animationEndEvent = 'animationend';</span><span class="s2">\n</span><span class="s1">if (hasTransition) {</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (window.ontransitionend === undefined &amp;&amp;</span><span class="s2">\n        </span><span class="s1">window.onwebkittransitionend !== undefined) {</span><span class="s2">\n        </span><span class="s1">transitionProp = 'WebkitTransition';</span><span class="s2">\n        </span><span class="s1">transitionEndEvent = 'webkitTransitionEnd';</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (window.onanimationend === undefined &amp;&amp;</span><span class="s2">\n        </span><span class="s1">window.onwebkitanimationend !== undefined) {</span><span class="s2">\n        </span><span class="s1">animationProp = 'WebkitAnimation';</span><span class="s2">\n        </span><span class="s1">animationEndEvent = 'webkitAnimationEnd';</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// binding to window is necessary to make hot reload work in IE in strict mode</span><span class="s2">\n</span><span class="s1">var raf = inBrowser</span><span class="s2">\n    </span><span class="s1">? window.requestAnimationFrame</span><span class="s2">\n        </span><span class="s1">? window.requestAnimationFrame.bind(window)</span><span class="s2">\n        </span><span class="s1">: setTimeout</span><span class="s2">\n    </span><span class="s1">: /* istanbul ignore next */ function (/* istanbul ignore next */ fn) { return fn(); };</span><span class="s2">\n</span><span class="s1">function nextFrame(fn) {</span><span class="s2">\n    </span><span class="s1">raf(function () {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error</span><span class="s2">\n        </span><span class="s1">raf(fn);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function addTransitionClass(el, cls) {</span><span class="s2">\n    </span><span class="s1">var transitionClasses = el._transitionClasses || (el._transitionClasses = []);</span><span class="s2">\n    </span><span class="s1">if (transitionClasses.indexOf(cls) &lt; 0) {</span><span class="s2">\n        </span><span class="s1">transitionClasses.push(cls);</span><span class="s2">\n        </span><span class="s1">addClass(el, cls);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function removeTransitionClass(el, cls) {</span><span class="s2">\n    </span><span class="s1">if (el._transitionClasses) {</span><span class="s2">\n        </span><span class="s1">remove$2(el._transitionClasses, cls);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">removeClass(el, cls);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function whenTransitionEnds(el, expectedType, cb) {</span><span class="s2">\n    </span><span class="s1">var _a = getTransitionInfo(el, expectedType), type = _a.type, timeout = _a.timeout, propCount = _a.propCount;</span><span class="s2">\n    </span><span class="s1">if (!type)</span><span class="s2">\n        </span><span class="s1">return cb();</span><span class="s2">\n    </span><span class="s1">var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;</span><span class="s2">\n    </span><span class="s1">var ended = 0;</span><span class="s2">\n    </span><span class="s1">var end = function () {</span><span class="s2">\n        </span><span class="s1">el.removeEventListener(event, onEnd);</span><span class="s2">\n        </span><span class="s1">cb();</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var onEnd = function (e) {</span><span class="s2">\n        </span><span class="s1">if (e.target === el) {</span><span class="s2">\n            </span><span class="s1">if (++ended &gt;= propCount) {</span><span class="s2">\n                </span><span class="s1">end();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">setTimeout(function () {</span><span class="s2">\n        </span><span class="s1">if (ended &lt; propCount) {</span><span class="s2">\n            </span><span class="s1">end();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}, timeout + 1);</span><span class="s2">\n    </span><span class="s1">el.addEventListener(event, onEnd);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var transformRE = /</span><span class="s2">\\</span><span class="s1">b(transform|all)(,|$)/;</span><span class="s2">\n</span><span class="s1">function getTransitionInfo(el, expectedType) {</span><span class="s2">\n    </span><span class="s1">var styles = window.getComputedStyle(el);</span><span class="s2">\n    </span><span class="s1">// JSDOM may return undefined for transition properties</span><span class="s2">\n    </span><span class="s1">var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');</span><span class="s2">\n    </span><span class="s1">var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');</span><span class="s2">\n    </span><span class="s1">var transitionTimeout = getTimeout(transitionDelays, transitionDurations);</span><span class="s2">\n    </span><span class="s1">var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');</span><span class="s2">\n    </span><span class="s1">var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');</span><span class="s2">\n    </span><span class="s1">var animationTimeout = getTimeout(animationDelays, animationDurations);</span><span class="s2">\n    </span><span class="s1">var type;</span><span class="s2">\n    </span><span class="s1">var timeout = 0;</span><span class="s2">\n    </span><span class="s1">var propCount = 0;</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (expectedType === TRANSITION) {</span><span class="s2">\n        </span><span class="s1">if (transitionTimeout &gt; 0) {</span><span class="s2">\n            </span><span class="s1">type = TRANSITION;</span><span class="s2">\n            </span><span class="s1">timeout = transitionTimeout;</span><span class="s2">\n            </span><span class="s1">propCount = transitionDurations.length;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (expectedType === ANIMATION) {</span><span class="s2">\n        </span><span class="s1">if (animationTimeout &gt; 0) {</span><span class="s2">\n            </span><span class="s1">type = ANIMATION;</span><span class="s2">\n            </span><span class="s1">timeout = animationTimeout;</span><span class="s2">\n            </span><span class="s1">propCount = animationDurations.length;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">timeout = Math.max(transitionTimeout, animationTimeout);</span><span class="s2">\n        </span><span class="s1">type =</span><span class="s2">\n            </span><span class="s1">timeout &gt; 0</span><span class="s2">\n                </span><span class="s1">? transitionTimeout &gt; animationTimeout</span><span class="s2">\n                    </span><span class="s1">? TRANSITION</span><span class="s2">\n                    </span><span class="s1">: ANIMATION</span><span class="s2">\n                </span><span class="s1">: null;</span><span class="s2">\n        </span><span class="s1">propCount = type</span><span class="s2">\n            </span><span class="s1">? type === TRANSITION</span><span class="s2">\n                </span><span class="s1">? transitionDurations.length</span><span class="s2">\n                </span><span class="s1">: animationDurations.length</span><span class="s2">\n            </span><span class="s1">: 0;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var hasTransform = type === TRANSITION &amp;&amp; transformRE.test(styles[transitionProp + 'Property']);</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">type: type,</span><span class="s2">\n        </span><span class="s1">timeout: timeout,</span><span class="s2">\n        </span><span class="s1">propCount: propCount,</span><span class="s2">\n        </span><span class="s1">hasTransform: hasTransform</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getTimeout(delays, durations) {</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n    </span><span class="s1">while (delays.length &lt; durations.length) {</span><span class="s2">\n        </span><span class="s1">delays = delays.concat(delays);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return Math.max.apply(null, durations.map(function (d, i) {</span><span class="s2">\n        </span><span class="s1">return toMs(d) + toMs(delays[i]);</span><span class="s2">\n    </span><span class="s1">}));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers</span><span class="s2">\n</span><span class="s1">// in a locale-dependent way, using a comma instead of a dot.</span><span class="s2">\n</span><span class="s1">// If comma is not replaced with a dot, the input will be rounded down (i.e. acting</span><span class="s2">\n</span><span class="s1">// as a floor function) causing unexpected behaviors</span><span class="s2">\n</span><span class="s1">function toMs(s) {</span><span class="s2">\n    </span><span class="s1">return Number(s.slice(0, -1).replace(',', '.')) * 1000;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function enter(vnode, toggleDisplay) {</span><span class="s2">\n    </span><span class="s1">var el = vnode.elm;</span><span class="s2">\n    </span><span class="s1">// call leave callback now</span><span class="s2">\n    </span><span class="s1">if (isDef(el._leaveCb)) {</span><span class="s2">\n        </span><span class="s1">el._leaveCb.cancelled = true;</span><span class="s2">\n        </span><span class="s1">el._leaveCb();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var data = resolveTransition(vnode.data.transition);</span><span class="s2">\n    </span><span class="s1">if (isUndef(data)) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (isDef(el._enterCb) || el.nodeType !== 1) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var css = data.css, type = data.type, enterClass = data.enterClass, enterToClass = data.enterToClass, enterActiveClass = data.enterActiveClass, appearClass = data.appearClass, appearToClass = data.appearToClass, appearActiveClass = data.appearActiveClass, beforeEnter = data.beforeEnter, enter = data.enter, afterEnter = data.afterEnter, enterCancelled = data.enterCancelled, beforeAppear = data.beforeAppear, appear = data.appear, afterAppear = data.afterAppear, appearCancelled = data.appearCancelled, duration = data.duration;</span><span class="s2">\n    </span><span class="s1">// activeInstance will always be the &lt;transition&gt; component managing this</span><span class="s2">\n    </span><span class="s1">// transition. One edge case to check is when the &lt;transition&gt; is placed</span><span class="s2">\n    </span><span class="s1">// as the root node of a child component. In that case we need to check</span><span class="s2">\n    </span><span class="s1">// &lt;transition&gt;'s parent for appear check.</span><span class="s2">\n    </span><span class="s1">var context = activeInstance;</span><span class="s2">\n    </span><span class="s1">var transitionNode = activeInstance.$vnode;</span><span class="s2">\n    </span><span class="s1">while (transitionNode &amp;&amp; transitionNode.parent) {</span><span class="s2">\n        </span><span class="s1">context = transitionNode.context;</span><span class="s2">\n        </span><span class="s1">transitionNode = transitionNode.parent;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var isAppear = !context._isMounted || !vnode.isRootInsert;</span><span class="s2">\n    </span><span class="s1">if (isAppear &amp;&amp; !appear &amp;&amp; appear !== '') {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var startClass = isAppear &amp;&amp; appearClass ? appearClass : enterClass;</span><span class="s2">\n    </span><span class="s1">var activeClass = isAppear &amp;&amp; appearActiveClass ? appearActiveClass : enterActiveClass;</span><span class="s2">\n    </span><span class="s1">var toClass = isAppear &amp;&amp; appearToClass ? appearToClass : enterToClass;</span><span class="s2">\n    </span><span class="s1">var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;</span><span class="s2">\n    </span><span class="s1">var enterHook = isAppear ? (isFunction(appear) ? appear : enter) : enter;</span><span class="s2">\n    </span><span class="s1">var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;</span><span class="s2">\n    </span><span class="s1">var enterCancelledHook = isAppear</span><span class="s2">\n        </span><span class="s1">? appearCancelled || enterCancelled</span><span class="s2">\n        </span><span class="s1">: enterCancelled;</span><span class="s2">\n    </span><span class="s1">var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; explicitEnterDuration != null) {</span><span class="s2">\n        </span><span class="s1">checkDuration(explicitEnterDuration, 'enter', vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var expectsCSS = css !== false &amp;&amp; !isIE9;</span><span class="s2">\n    </span><span class="s1">var userWantsControl = getHookArgumentsLength(enterHook);</span><span class="s2">\n    </span><span class="s1">var cb = (el._enterCb = once(function () {</span><span class="s2">\n        </span><span class="s1">if (expectsCSS) {</span><span class="s2">\n            </span><span class="s1">removeTransitionClass(el, toClass);</span><span class="s2">\n            </span><span class="s1">removeTransitionClass(el, activeClass);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error</span><span class="s2">\n        </span><span class="s1">if (cb.cancelled) {</span><span class="s2">\n            </span><span class="s1">if (expectsCSS) {</span><span class="s2">\n                </span><span class="s1">removeTransitionClass(el, startClass);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">enterCancelledHook &amp;&amp; enterCancelledHook(el);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">afterEnterHook &amp;&amp; afterEnterHook(el);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">el._enterCb = null;</span><span class="s2">\n    </span><span class="s1">}));</span><span class="s2">\n    </span><span class="s1">if (!vnode.data.show) {</span><span class="s2">\n        </span><span class="s1">// remove pending leave element on enter by injecting an insert hook</span><span class="s2">\n        </span><span class="s1">mergeVNodeHook(vnode, 'insert', function () {</span><span class="s2">\n            </span><span class="s1">var parent = el.parentNode;</span><span class="s2">\n            </span><span class="s1">var pendingNode = parent &amp;&amp; parent._pending &amp;&amp; parent._pending[vnode.key];</span><span class="s2">\n            </span><span class="s1">if (pendingNode &amp;&amp;</span><span class="s2">\n                </span><span class="s1">pendingNode.tag === vnode.tag &amp;&amp;</span><span class="s2">\n                </span><span class="s1">pendingNode.elm._leaveCb) {</span><span class="s2">\n                </span><span class="s1">pendingNode.elm._leaveCb();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">enterHook &amp;&amp; enterHook(el, cb);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// start enter transition</span><span class="s2">\n    </span><span class="s1">beforeEnterHook &amp;&amp; beforeEnterHook(el);</span><span class="s2">\n    </span><span class="s1">if (expectsCSS) {</span><span class="s2">\n        </span><span class="s1">addTransitionClass(el, startClass);</span><span class="s2">\n        </span><span class="s1">addTransitionClass(el, activeClass);</span><span class="s2">\n        </span><span class="s1">nextFrame(function () {</span><span class="s2">\n            </span><span class="s1">removeTransitionClass(el, startClass);</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error</span><span class="s2">\n            </span><span class="s1">if (!cb.cancelled) {</span><span class="s2">\n                </span><span class="s1">addTransitionClass(el, toClass);</span><span class="s2">\n                </span><span class="s1">if (!userWantsControl) {</span><span class="s2">\n                    </span><span class="s1">if (isValidDuration(explicitEnterDuration)) {</span><span class="s2">\n                        </span><span class="s1">setTimeout(cb, explicitEnterDuration);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">whenTransitionEnds(el, type, cb);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (vnode.data.show) {</span><span class="s2">\n        </span><span class="s1">toggleDisplay &amp;&amp; toggleDisplay();</span><span class="s2">\n        </span><span class="s1">enterHook &amp;&amp; enterHook(el, cb);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!expectsCSS &amp;&amp; !userWantsControl) {</span><span class="s2">\n        </span><span class="s1">cb();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function leave(vnode, rm) {</span><span class="s2">\n    </span><span class="s1">var el = vnode.elm;</span><span class="s2">\n    </span><span class="s1">// call enter callback now</span><span class="s2">\n    </span><span class="s1">if (isDef(el._enterCb)) {</span><span class="s2">\n        </span><span class="s1">el._enterCb.cancelled = true;</span><span class="s2">\n        </span><span class="s1">el._enterCb();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var data = resolveTransition(vnode.data.transition);</span><span class="s2">\n    </span><span class="s1">if (isUndef(data) || el.nodeType !== 1) {</span><span class="s2">\n        </span><span class="s1">return rm();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (isDef(el._leaveCb)) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var css = data.css, type = data.type, leaveClass = data.leaveClass, leaveToClass = data.leaveToClass, leaveActiveClass = data.leaveActiveClass, beforeLeave = data.beforeLeave, leave = data.leave, afterLeave = data.afterLeave, leaveCancelled = data.leaveCancelled, delayLeave = data.delayLeave, duration = data.duration;</span><span class="s2">\n    </span><span class="s1">var expectsCSS = css !== false &amp;&amp; !isIE9;</span><span class="s2">\n    </span><span class="s1">var userWantsControl = getHookArgumentsLength(leave);</span><span class="s2">\n    </span><span class="s1">var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; isDef(explicitLeaveDuration)) {</span><span class="s2">\n        </span><span class="s1">checkDuration(explicitLeaveDuration, 'leave', vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var cb = (el._leaveCb = once(function () {</span><span class="s2">\n        </span><span class="s1">if (el.parentNode &amp;&amp; el.parentNode._pending) {</span><span class="s2">\n            </span><span class="s1">el.parentNode._pending[vnode.key] = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (expectsCSS) {</span><span class="s2">\n            </span><span class="s1">removeTransitionClass(el, leaveToClass);</span><span class="s2">\n            </span><span class="s1">removeTransitionClass(el, leaveActiveClass);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error</span><span class="s2">\n        </span><span class="s1">if (cb.cancelled) {</span><span class="s2">\n            </span><span class="s1">if (expectsCSS) {</span><span class="s2">\n                </span><span class="s1">removeTransitionClass(el, leaveClass);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">leaveCancelled &amp;&amp; leaveCancelled(el);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">rm();</span><span class="s2">\n            </span><span class="s1">afterLeave &amp;&amp; afterLeave(el);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">el._leaveCb = null;</span><span class="s2">\n    </span><span class="s1">}));</span><span class="s2">\n    </span><span class="s1">if (delayLeave) {</span><span class="s2">\n        </span><span class="s1">delayLeave(performLeave);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">performLeave();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function performLeave() {</span><span class="s2">\n        </span><span class="s1">// the delayed leave may have already been cancelled</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error</span><span class="s2">\n        </span><span class="s1">if (cb.cancelled) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// record leaving element</span><span class="s2">\n        </span><span class="s1">if (!vnode.data.show &amp;&amp; el.parentNode) {</span><span class="s2">\n            </span><span class="s1">(el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] =</span><span class="s2">\n                </span><span class="s1">vnode;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">beforeLeave &amp;&amp; beforeLeave(el);</span><span class="s2">\n        </span><span class="s1">if (expectsCSS) {</span><span class="s2">\n            </span><span class="s1">addTransitionClass(el, leaveClass);</span><span class="s2">\n            </span><span class="s1">addTransitionClass(el, leaveActiveClass);</span><span class="s2">\n            </span><span class="s1">nextFrame(function () {</span><span class="s2">\n                </span><span class="s1">removeTransitionClass(el, leaveClass);</span><span class="s2">\n                </span><span class="s1">// @ts-expect-error</span><span class="s2">\n                </span><span class="s1">if (!cb.cancelled) {</span><span class="s2">\n                    </span><span class="s1">addTransitionClass(el, leaveToClass);</span><span class="s2">\n                    </span><span class="s1">if (!userWantsControl) {</span><span class="s2">\n                        </span><span class="s1">if (isValidDuration(explicitLeaveDuration)) {</span><span class="s2">\n                            </span><span class="s1">setTimeout(cb, explicitLeaveDuration);</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">else {</span><span class="s2">\n                            </span><span class="s1">whenTransitionEnds(el, type, cb);</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">leave &amp;&amp; leave(el, cb);</span><span class="s2">\n        </span><span class="s1">if (!expectsCSS &amp;&amp; !userWantsControl) {</span><span class="s2">\n            </span><span class="s1">cb();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// only used in dev mode</span><span class="s2">\n</span><span class="s1">function checkDuration(val, name, vnode) {</span><span class="s2">\n    </span><span class="s1">if (typeof val !== 'number') {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">&lt;transition&gt; explicit </span><span class="s2">\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot; </span><span class="s1">duration is not a valid number - </span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n            \&quot;</span><span class="s1">got </span><span class="s2">\&quot;</span><span class="s1">.concat(JSON.stringify(val), </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">), vnode.context);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isNaN(val)) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">&lt;transition&gt; explicit </span><span class="s2">\&quot;</span><span class="s1">.concat(name, </span><span class="s2">\&quot; </span><span class="s1">duration is NaN - </span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n            </span><span class="s1">'the duration expression might be incorrect.', vnode.context);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isValidDuration(val) {</span><span class="s2">\n    </span><span class="s1">return typeof val === 'number' &amp;&amp; !isNaN(val);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Normalize a transition hook's argument length. The hook may be:</span><span class="s2">\n </span><span class="s1">* - a merged hook (invoker) with the original in .fns</span><span class="s2">\n </span><span class="s1">* - a wrapped component method (check ._length)</span><span class="s2">\n </span><span class="s1">* - a plain function (.length)</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function getHookArgumentsLength(fn) {</span><span class="s2">\n    </span><span class="s1">if (isUndef(fn)) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">var invokerFns = fn.fns;</span><span class="s2">\n    </span><span class="s1">if (isDef(invokerFns)) {</span><span class="s2">\n        </span><span class="s1">// invoker</span><span class="s2">\n        </span><span class="s1">return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error</span><span class="s2">\n        </span><span class="s1">return (fn._length || fn.length) &gt; 1;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function _enter(_, vnode) {</span><span class="s2">\n    </span><span class="s1">if (vnode.data.show !== true) {</span><span class="s2">\n        </span><span class="s1">enter(vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var transition = inBrowser</span><span class="s2">\n    </span><span class="s1">? {</span><span class="s2">\n        </span><span class="s1">create: _enter,</span><span class="s2">\n        </span><span class="s1">activate: _enter,</span><span class="s2">\n        </span><span class="s1">remove: function (vnode, rm) {</span><span class="s2">\n            </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n            </span><span class="s1">if (vnode.data.show !== true) {</span><span class="s2">\n                </span><span class="s1">// @ts-expect-error</span><span class="s2">\n                </span><span class="s1">leave(vnode, rm);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">rm();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">: {};</span><span class="s2">\n\n</span><span class="s1">var platformModules = [attrs, klass, events, domProps, style, transition];</span><span class="s2">\n\n</span><span class="s1">// the directive module should be applied last, after all</span><span class="s2">\n</span><span class="s1">// built-in modules have been applied.</span><span class="s2">\n</span><span class="s1">var modules = platformModules.concat(baseModules);</span><span class="s2">\n</span><span class="s1">var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Not type checking this file because flow doesn't like attaching</span><span class="s2">\n </span><span class="s1">* properties to Elements.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n</span><span class="s1">if (isIE9) {</span><span class="s2">\n    </span><span class="s1">// http://www.matts411.com/post/internet-explorer-9-oninput/</span><span class="s2">\n    </span><span class="s1">document.addEventListener('selectionchange', function () {</span><span class="s2">\n        </span><span class="s1">var el = document.activeElement;</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error</span><span class="s2">\n        </span><span class="s1">if (el &amp;&amp; el.vmodel) {</span><span class="s2">\n            </span><span class="s1">trigger(el, 'input');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var directive = {</span><span class="s2">\n    </span><span class="s1">inserted: function (el, binding, vnode, oldVnode) {</span><span class="s2">\n        </span><span class="s1">if (vnode.tag === 'select') {</span><span class="s2">\n            </span><span class="s1">// #6903</span><span class="s2">\n            </span><span class="s1">if (oldVnode.elm &amp;&amp; !oldVnode.elm._vOptions) {</span><span class="s2">\n                </span><span class="s1">mergeVNodeHook(vnode, 'postpatch', function () {</span><span class="s2">\n                    </span><span class="s1">directive.componentUpdated(el, binding, vnode);</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">setSelected(el, binding, vnode.context);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">el._vOptions = [].map.call(el.options, getValue);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {</span><span class="s2">\n            </span><span class="s1">el._vModifiers = binding.modifiers;</span><span class="s2">\n            </span><span class="s1">if (!binding.modifiers.lazy) {</span><span class="s2">\n                </span><span class="s1">el.addEventListener('compositionstart', onCompositionStart);</span><span class="s2">\n                </span><span class="s1">el.addEventListener('compositionend', onCompositionEnd);</span><span class="s2">\n                </span><span class="s1">// Safari &lt; 10.2 &amp; UIWebView doesn't fire compositionend when</span><span class="s2">\n                </span><span class="s1">// switching focus before confirming composition choice</span><span class="s2">\n                </span><span class="s1">// this also fixes the issue where some browsers e.g. iOS Chrome</span><span class="s2">\n                </span><span class="s1">// fires </span><span class="s2">\&quot;</span><span class="s1">change</span><span class="s2">\&quot; </span><span class="s1">instead of </span><span class="s2">\&quot;</span><span class="s1">input</span><span class="s2">\&quot; </span><span class="s1">on autocomplete.</span><span class="s2">\n                </span><span class="s1">el.addEventListener('change', onCompositionEnd);</span><span class="s2">\n                </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n                </span><span class="s1">if (isIE9) {</span><span class="s2">\n                    </span><span class="s1">el.vmodel = true;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">componentUpdated: function (el, binding, vnode) {</span><span class="s2">\n        </span><span class="s1">if (vnode.tag === 'select') {</span><span class="s2">\n            </span><span class="s1">setSelected(el, binding, vnode.context);</span><span class="s2">\n            </span><span class="s1">// in case the options rendered by v-for have changed,</span><span class="s2">\n            </span><span class="s1">// it's possible that the value is out-of-sync with the rendered options.</span><span class="s2">\n            </span><span class="s1">// detect such cases and filter out values that no longer has a matching</span><span class="s2">\n            </span><span class="s1">// option in the DOM.</span><span class="s2">\n            </span><span class="s1">var prevOptions_1 = el._vOptions;</span><span class="s2">\n            </span><span class="s1">var curOptions_1 = (el._vOptions = [].map.call(el.options, getValue));</span><span class="s2">\n            </span><span class="s1">if (curOptions_1.some(function (o, i) { return !looseEqual(o, prevOptions_1[i]); })) {</span><span class="s2">\n                </span><span class="s1">// trigger change event if</span><span class="s2">\n                </span><span class="s1">// no matching option found for at least one value</span><span class="s2">\n                </span><span class="s1">var needReset = el.multiple</span><span class="s2">\n                    </span><span class="s1">? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions_1); })</span><span class="s2">\n                    </span><span class="s1">: binding.value !== binding.oldValue &amp;&amp;</span><span class="s2">\n                        </span><span class="s1">hasNoMatchingOption(binding.value, curOptions_1);</span><span class="s2">\n                </span><span class="s1">if (needReset) {</span><span class="s2">\n                    </span><span class="s1">trigger(el, 'change');</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function setSelected(el, binding, vm) {</span><span class="s2">\n    </span><span class="s1">actuallySetSelected(el, binding, vm);</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (isIE || isEdge) {</span><span class="s2">\n        </span><span class="s1">setTimeout(function () {</span><span class="s2">\n            </span><span class="s1">actuallySetSelected(el, binding, vm);</span><span class="s2">\n        </span><span class="s1">}, 0);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function actuallySetSelected(el, binding, vm) {</span><span class="s2">\n    </span><span class="s1">var value = binding.value;</span><span class="s2">\n    </span><span class="s1">var isMultiple = el.multiple;</span><span class="s2">\n    </span><span class="s1">if (isMultiple &amp;&amp; !Array.isArray(value)) {</span><span class="s2">\n        </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n            </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">&lt;select multiple v-model=</span><span class="s2">\\\&quot;\&quot;</span><span class="s1">.concat(binding.expression, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">&gt; </span><span class="s2">\&quot;</span><span class="s1">) +</span><span class="s2">\n                \&quot;</span><span class="s1">expects an Array value for its binding, but got </span><span class="s2">\&quot;</span><span class="s1">.concat(Object.prototype.toString</span><span class="s2">\n                    </span><span class="s1">.call(value)</span><span class="s2">\n                    </span><span class="s1">.slice(8, -1)), vm);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var selected, option;</span><span class="s2">\n    </span><span class="s1">for (var i = 0, l = el.options.length; i &lt; l; i++) {</span><span class="s2">\n        </span><span class="s1">option = el.options[i];</span><span class="s2">\n        </span><span class="s1">if (isMultiple) {</span><span class="s2">\n            </span><span class="s1">selected = looseIndexOf(value, getValue(option)) &gt; -1;</span><span class="s2">\n            </span><span class="s1">if (option.selected !== selected) {</span><span class="s2">\n                </span><span class="s1">option.selected = selected;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">if (looseEqual(getValue(option), value)) {</span><span class="s2">\n                </span><span class="s1">if (el.selectedIndex !== i) {</span><span class="s2">\n                    </span><span class="s1">el.selectedIndex = i;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!isMultiple) {</span><span class="s2">\n        </span><span class="s1">el.selectedIndex = -1;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function hasNoMatchingOption(value, options) {</span><span class="s2">\n    </span><span class="s1">return options.every(function (o) { return !looseEqual(o, value); });</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getValue(option) {</span><span class="s2">\n    </span><span class="s1">return '_value' in option ? option._value : option.value;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function onCompositionStart(e) {</span><span class="s2">\n    </span><span class="s1">e.target.composing = true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function onCompositionEnd(e) {</span><span class="s2">\n    </span><span class="s1">// prevent triggering an input event for no reason</span><span class="s2">\n    </span><span class="s1">if (!e.target.composing)</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">e.target.composing = false;</span><span class="s2">\n    </span><span class="s1">trigger(e.target, 'input');</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function trigger(el, type) {</span><span class="s2">\n    </span><span class="s1">var e = document.createEvent('HTMLEvents');</span><span class="s2">\n    </span><span class="s1">e.initEvent(type, true, true);</span><span class="s2">\n    </span><span class="s1">el.dispatchEvent(e);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// recursively search for possible transition defined inside the component root</span><span class="s2">\n</span><span class="s1">function locateNode(vnode) {</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">return vnode.componentInstance &amp;&amp; (!vnode.data || !vnode.data.transition)</span><span class="s2">\n        </span><span class="s1">? locateNode(vnode.componentInstance._vnode)</span><span class="s2">\n        </span><span class="s1">: vnode;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var show = {</span><span class="s2">\n    </span><span class="s1">bind: function (el, _a, vnode) {</span><span class="s2">\n        </span><span class="s1">var value = _a.value;</span><span class="s2">\n        </span><span class="s1">vnode = locateNode(vnode);</span><span class="s2">\n        </span><span class="s1">var transition = vnode.data &amp;&amp; vnode.data.transition;</span><span class="s2">\n        </span><span class="s1">var originalDisplay = (el.__vOriginalDisplay =</span><span class="s2">\n            </span><span class="s1">el.style.display === 'none' ? '' : el.style.display);</span><span class="s2">\n        </span><span class="s1">if (value &amp;&amp; transition) {</span><span class="s2">\n            </span><span class="s1">vnode.data.show = true;</span><span class="s2">\n            </span><span class="s1">enter(vnode, function () {</span><span class="s2">\n                </span><span class="s1">el.style.display = originalDisplay;</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">el.style.display = value ? originalDisplay : 'none';</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">update: function (el, _a, vnode) {</span><span class="s2">\n        </span><span class="s1">var value = _a.value, oldValue = _a.oldValue;</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n        </span><span class="s1">if (!value === !oldValue)</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">vnode = locateNode(vnode);</span><span class="s2">\n        </span><span class="s1">var transition = vnode.data &amp;&amp; vnode.data.transition;</span><span class="s2">\n        </span><span class="s1">if (transition) {</span><span class="s2">\n            </span><span class="s1">vnode.data.show = true;</span><span class="s2">\n            </span><span class="s1">if (value) {</span><span class="s2">\n                </span><span class="s1">enter(vnode, function () {</span><span class="s2">\n                    </span><span class="s1">el.style.display = el.__vOriginalDisplay;</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">leave(vnode, function () {</span><span class="s2">\n                    </span><span class="s1">el.style.display = 'none';</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">el.style.display = value ? el.__vOriginalDisplay : 'none';</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">unbind: function (el, binding, vnode, oldVnode, isDestroy) {</span><span class="s2">\n        </span><span class="s1">if (!isDestroy) {</span><span class="s2">\n            </span><span class="s1">el.style.display = el.__vOriginalDisplay;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">var platformDirectives = {</span><span class="s2">\n    </span><span class="s1">model: directive,</span><span class="s2">\n    </span><span class="s1">show: show</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// Provides transition support for a single element/component.</span><span class="s2">\n</span><span class="s1">var transitionProps = {</span><span class="s2">\n    </span><span class="s1">name: String,</span><span class="s2">\n    </span><span class="s1">appear: Boolean,</span><span class="s2">\n    </span><span class="s1">css: Boolean,</span><span class="s2">\n    </span><span class="s1">mode: String,</span><span class="s2">\n    </span><span class="s1">type: String,</span><span class="s2">\n    </span><span class="s1">enterClass: String,</span><span class="s2">\n    </span><span class="s1">leaveClass: String,</span><span class="s2">\n    </span><span class="s1">enterToClass: String,</span><span class="s2">\n    </span><span class="s1">leaveToClass: String,</span><span class="s2">\n    </span><span class="s1">enterActiveClass: String,</span><span class="s2">\n    </span><span class="s1">leaveActiveClass: String,</span><span class="s2">\n    </span><span class="s1">appearClass: String,</span><span class="s2">\n    </span><span class="s1">appearActiveClass: String,</span><span class="s2">\n    </span><span class="s1">appearToClass: String,</span><span class="s2">\n    </span><span class="s1">duration: [Number, String, Object]</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">// in case the child is also an abstract component, e.g. &lt;keep-alive&gt;</span><span class="s2">\n</span><span class="s1">// we want to recursively retrieve the real component to be rendered</span><span class="s2">\n</span><span class="s1">function getRealChild(vnode) {</span><span class="s2">\n    </span><span class="s1">var compOptions = vnode &amp;&amp; vnode.componentOptions;</span><span class="s2">\n    </span><span class="s1">if (compOptions &amp;&amp; compOptions.Ctor.options.abstract) {</span><span class="s2">\n        </span><span class="s1">return getRealChild(getFirstComponentChild(compOptions.children));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">return vnode;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function extractTransitionData(comp) {</span><span class="s2">\n    </span><span class="s1">var data = {};</span><span class="s2">\n    </span><span class="s1">var options = comp.$options;</span><span class="s2">\n    </span><span class="s1">// props</span><span class="s2">\n    </span><span class="s1">for (var key in options.propsData) {</span><span class="s2">\n        </span><span class="s1">data[key] = comp[key];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// events.</span><span class="s2">\n    </span><span class="s1">// extract listeners and pass them directly to the transition methods</span><span class="s2">\n    </span><span class="s1">var listeners = options._parentListeners;</span><span class="s2">\n    </span><span class="s1">for (var key in listeners) {</span><span class="s2">\n        </span><span class="s1">data[camelize(key)] = listeners[key];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return data;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function placeholder(h, rawChild) {</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">if (/</span><span class="s2">\\</span><span class="s1">d-keep-alive$/.test(rawChild.tag)) {</span><span class="s2">\n        </span><span class="s1">return h('keep-alive', {</span><span class="s2">\n            </span><span class="s1">props: rawChild.componentOptions.propsData</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function hasParentTransition(vnode) {</span><span class="s2">\n    </span><span class="s1">while ((vnode = vnode.parent)) {</span><span class="s2">\n        </span><span class="s1">if (vnode.data.transition) {</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isSameChild(child, oldChild) {</span><span class="s2">\n    </span><span class="s1">return oldChild.key === child.key &amp;&amp; oldChild.tag === child.tag;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };</span><span class="s2">\n</span><span class="s1">var isVShowDirective = function (d) { return d.name === 'show'; };</span><span class="s2">\n</span><span class="s1">var Transition = {</span><span class="s2">\n    </span><span class="s1">name: 'transition',</span><span class="s2">\n    </span><span class="s1">props: transitionProps,</span><span class="s2">\n    </span><span class="s1">abstract: true,</span><span class="s2">\n    </span><span class="s1">render: function (h) {</span><span class="s2">\n        </span><span class="s1">var _this = this;</span><span class="s2">\n        </span><span class="s1">var children = this.$slots.default;</span><span class="s2">\n        </span><span class="s1">if (!children) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// filter out text nodes (possible whitespaces)</span><span class="s2">\n        </span><span class="s1">children = children.filter(isNotTextNode);</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n        </span><span class="s1">if (!children.length) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// warn multiple elements</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; children.length &gt; 1) {</span><span class="s2">\n            </span><span class="s1">warn('&lt;transition&gt; can only be used on a single element. Use ' +</span><span class="s2">\n                </span><span class="s1">'&lt;transition-group&gt; for lists.', this.$parent);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var mode = this.mode;</span><span class="s2">\n        </span><span class="s1">// warn invalid mode</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; mode &amp;&amp; mode !== 'in-out' &amp;&amp; mode !== 'out-in') {</span><span class="s2">\n            </span><span class="s1">warn('invalid &lt;transition&gt; mode: ' + mode, this.$parent);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var rawChild = children[0];</span><span class="s2">\n        </span><span class="s1">// if this is a component root node and the component's</span><span class="s2">\n        </span><span class="s1">// parent container node also has transition, skip.</span><span class="s2">\n        </span><span class="s1">if (hasParentTransition(this.$vnode)) {</span><span class="s2">\n            </span><span class="s1">return rawChild;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// apply transition data to child</span><span class="s2">\n        </span><span class="s1">// use getRealChild() to ignore abstract components e.g. keep-alive</span><span class="s2">\n        </span><span class="s1">var child = getRealChild(rawChild);</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n        </span><span class="s1">if (!child) {</span><span class="s2">\n            </span><span class="s1">return rawChild;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (this._leaving) {</span><span class="s2">\n            </span><span class="s1">return placeholder(h, rawChild);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// ensure a key that is unique to the vnode type and to this transition</span><span class="s2">\n        </span><span class="s1">// component instance. This key will be used to remove pending leaving nodes</span><span class="s2">\n        </span><span class="s1">// during entering.</span><span class="s2">\n        </span><span class="s1">var id = </span><span class="s2">\&quot;</span><span class="s1">__transition-</span><span class="s2">\&quot;</span><span class="s1">.concat(this._uid, </span><span class="s2">\&quot;</span><span class="s1">-</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">child.key =</span><span class="s2">\n            </span><span class="s1">child.key == null</span><span class="s2">\n                </span><span class="s1">? child.isComment</span><span class="s2">\n                    </span><span class="s1">? id + 'comment'</span><span class="s2">\n                    </span><span class="s1">: id + child.tag</span><span class="s2">\n                </span><span class="s1">: isPrimitive(child.key)</span><span class="s2">\n                    </span><span class="s1">? String(child.key).indexOf(id) === 0</span><span class="s2">\n                        </span><span class="s1">? child.key</span><span class="s2">\n                        </span><span class="s1">: id + child.key</span><span class="s2">\n                    </span><span class="s1">: child.key;</span><span class="s2">\n        </span><span class="s1">var data = ((child.data || (child.data = {})).transition =</span><span class="s2">\n            </span><span class="s1">extractTransitionData(this));</span><span class="s2">\n        </span><span class="s1">var oldRawChild = this._vnode;</span><span class="s2">\n        </span><span class="s1">var oldChild = getRealChild(oldRawChild);</span><span class="s2">\n        </span><span class="s1">// mark v-show</span><span class="s2">\n        </span><span class="s1">// so that the transition module can hand over the control to the directive</span><span class="s2">\n        </span><span class="s1">if (child.data.directives &amp;&amp; child.data.directives.some(isVShowDirective)) {</span><span class="s2">\n            </span><span class="s1">child.data.show = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (oldChild &amp;&amp;</span><span class="s2">\n            </span><span class="s1">oldChild.data &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!isSameChild(child, oldChild) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!isAsyncPlaceholder(oldChild) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">// #6687 component root is a comment node</span><span class="s2">\n            </span><span class="s1">!(oldChild.componentInstance &amp;&amp;</span><span class="s2">\n                </span><span class="s1">oldChild.componentInstance._vnode.isComment)) {</span><span class="s2">\n            </span><span class="s1">// replace old child transition data with fresh one</span><span class="s2">\n            </span><span class="s1">// important for dynamic transitions!</span><span class="s2">\n            </span><span class="s1">var oldData = (oldChild.data.transition = extend({}, data));</span><span class="s2">\n            </span><span class="s1">// handle transition mode</span><span class="s2">\n            </span><span class="s1">if (mode === 'out-in') {</span><span class="s2">\n                </span><span class="s1">// return placeholder node and queue update when leave finishes</span><span class="s2">\n                </span><span class="s1">this._leaving = true;</span><span class="s2">\n                </span><span class="s1">mergeVNodeHook(oldData, 'afterLeave', function () {</span><span class="s2">\n                    </span><span class="s1">_this._leaving = false;</span><span class="s2">\n                    </span><span class="s1">_this.$forceUpdate();</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n                </span><span class="s1">return placeholder(h, rawChild);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (mode === 'in-out') {</span><span class="s2">\n                </span><span class="s1">if (isAsyncPlaceholder(child)) {</span><span class="s2">\n                    </span><span class="s1">return oldRawChild;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">var delayedLeave_1;</span><span class="s2">\n                </span><span class="s1">var performLeave = function () {</span><span class="s2">\n                    </span><span class="s1">delayedLeave_1();</span><span class="s2">\n                </span><span class="s1">};</span><span class="s2">\n                </span><span class="s1">mergeVNodeHook(data, 'afterEnter', performLeave);</span><span class="s2">\n                </span><span class="s1">mergeVNodeHook(data, 'enterCancelled', performLeave);</span><span class="s2">\n                </span><span class="s1">mergeVNodeHook(oldData, 'delayLeave', function (leave) {</span><span class="s2">\n                    </span><span class="s1">delayedLeave_1 = leave;</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return rawChild;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// Provides transition support for list items.</span><span class="s2">\n</span><span class="s1">var props = extend({</span><span class="s2">\n    </span><span class="s1">tag: String,</span><span class="s2">\n    </span><span class="s1">moveClass: String</span><span class="s2">\n</span><span class="s1">}, transitionProps);</span><span class="s2">\n</span><span class="s1">delete props.mode;</span><span class="s2">\n</span><span class="s1">var TransitionGroup = {</span><span class="s2">\n    </span><span class="s1">props: props,</span><span class="s2">\n    </span><span class="s1">beforeMount: function () {</span><span class="s2">\n        </span><span class="s1">var _this = this;</span><span class="s2">\n        </span><span class="s1">var update = this._update;</span><span class="s2">\n        </span><span class="s1">this._update = function (vnode, hydrating) {</span><span class="s2">\n            </span><span class="s1">var restoreActiveInstance = setActiveInstance(_this);</span><span class="s2">\n            </span><span class="s1">// force removing pass</span><span class="s2">\n            </span><span class="s1">_this.__patch__(_this._vnode, _this.kept, false, // hydrating</span><span class="s2">\n            </span><span class="s1">true // removeOnly (!important, avoids unnecessary moves)</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">_this._vnode = _this.kept;</span><span class="s2">\n            </span><span class="s1">restoreActiveInstance();</span><span class="s2">\n            </span><span class="s1">update.call(_this, vnode, hydrating);</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">render: function (h) {</span><span class="s2">\n        </span><span class="s1">var tag = this.tag || this.$vnode.data.tag || 'span';</span><span class="s2">\n        </span><span class="s1">var map = Object.create(null);</span><span class="s2">\n        </span><span class="s1">var prevChildren = (this.prevChildren = this.children);</span><span class="s2">\n        </span><span class="s1">var rawChildren = this.$slots.default || [];</span><span class="s2">\n        </span><span class="s1">var children = (this.children = []);</span><span class="s2">\n        </span><span class="s1">var transitionData = extractTransitionData(this);</span><span class="s2">\n        </span><span class="s1">for (var i = 0; i &lt; rawChildren.length; i++) {</span><span class="s2">\n            </span><span class="s1">var c = rawChildren[i];</span><span class="s2">\n            </span><span class="s1">if (c.tag) {</span><span class="s2">\n                </span><span class="s1">if (c.key != null &amp;&amp; String(c.key).indexOf('__vlist') !== 0) {</span><span class="s2">\n                    </span><span class="s1">children.push(c);</span><span class="s2">\n                    </span><span class="s1">map[c.key] = c;</span><span class="s2">\n                    </span><span class="s1">(c.data || (c.data = {})).transition = transitionData;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n                    </span><span class="s1">var opts = c.componentOptions;</span><span class="s2">\n                    </span><span class="s1">var name_1 = opts</span><span class="s2">\n                        </span><span class="s1">? getComponentName(opts.Ctor.options) || opts.tag || ''</span><span class="s2">\n                        </span><span class="s1">: c.tag;</span><span class="s2">\n                    </span><span class="s1">warn(</span><span class="s2">\&quot;</span><span class="s1">&lt;transition-group&gt; children must be keyed: &lt;</span><span class="s2">\&quot;</span><span class="s1">.concat(name_1, </span><span class="s2">\&quot;</span><span class="s1">&gt;</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (prevChildren) {</span><span class="s2">\n            </span><span class="s1">var kept = [];</span><span class="s2">\n            </span><span class="s1">var removed = [];</span><span class="s2">\n            </span><span class="s1">for (var i = 0; i &lt; prevChildren.length; i++) {</span><span class="s2">\n                </span><span class="s1">var c = prevChildren[i];</span><span class="s2">\n                </span><span class="s1">c.data.transition = transitionData;</span><span class="s2">\n                </span><span class="s1">// @ts-expect-error .getBoundingClientRect is not typed in Node</span><span class="s2">\n                </span><span class="s1">c.data.pos = c.elm.getBoundingClientRect();</span><span class="s2">\n                </span><span class="s1">if (map[c.key]) {</span><span class="s2">\n                    </span><span class="s1">kept.push(c);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">removed.push(c);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">this.kept = h(tag, null, kept);</span><span class="s2">\n            </span><span class="s1">this.removed = removed;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return h(tag, null, children);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">updated: function () {</span><span class="s2">\n        </span><span class="s1">var children = this.prevChildren;</span><span class="s2">\n        </span><span class="s1">var moveClass = this.moveClass || (this.name || 'v') + '-move';</span><span class="s2">\n        </span><span class="s1">if (!children.length || !this.hasMove(children[0].elm, moveClass)) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// we divide the work into three loops to avoid mixing DOM reads and writes</span><span class="s2">\n        </span><span class="s1">// in each iteration - which helps prevent layout thrashing.</span><span class="s2">\n        </span><span class="s1">children.forEach(callPendingCbs);</span><span class="s2">\n        </span><span class="s1">children.forEach(recordPosition);</span><span class="s2">\n        </span><span class="s1">children.forEach(applyTranslation);</span><span class="s2">\n        </span><span class="s1">// force reflow to put everything in position</span><span class="s2">\n        </span><span class="s1">// assign to this to avoid being removed in tree-shaking</span><span class="s2">\n        </span><span class="s1">// $flow-disable-line</span><span class="s2">\n        </span><span class="s1">this._reflow = document.body.offsetHeight;</span><span class="s2">\n        </span><span class="s1">children.forEach(function (c) {</span><span class="s2">\n            </span><span class="s1">if (c.data.moved) {</span><span class="s2">\n                </span><span class="s1">var el_1 = c.elm;</span><span class="s2">\n                </span><span class="s1">var s = el_1.style;</span><span class="s2">\n                </span><span class="s1">addTransitionClass(el_1, moveClass);</span><span class="s2">\n                </span><span class="s1">s.transform = s.WebkitTransform = s.transitionDuration = '';</span><span class="s2">\n                </span><span class="s1">el_1.addEventListener(transitionEndEvent, (el_1._moveCb = function cb(e) {</span><span class="s2">\n                    </span><span class="s1">if (e &amp;&amp; e.target !== el_1) {</span><span class="s2">\n                        </span><span class="s1">return;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">if (!e || /transform$/.test(e.propertyName)) {</span><span class="s2">\n                        </span><span class="s1">el_1.removeEventListener(transitionEndEvent, cb);</span><span class="s2">\n                        </span><span class="s1">el_1._moveCb = null;</span><span class="s2">\n                        </span><span class="s1">removeTransitionClass(el_1, moveClass);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}));</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">methods: {</span><span class="s2">\n        </span><span class="s1">hasMove: function (el, moveClass) {</span><span class="s2">\n            </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n            </span><span class="s1">if (!hasTransition) {</span><span class="s2">\n                </span><span class="s1">return false;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n            </span><span class="s1">if (this._hasMove) {</span><span class="s2">\n                </span><span class="s1">return this._hasMove;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// Detect whether an element with the move class applied has</span><span class="s2">\n            </span><span class="s1">// CSS transitions. Since the element may be inside an entering</span><span class="s2">\n            </span><span class="s1">// transition at this very moment, we make a clone of it and remove</span><span class="s2">\n            </span><span class="s1">// all other transition classes applied to ensure only the move class</span><span class="s2">\n            </span><span class="s1">// is applied.</span><span class="s2">\n            </span><span class="s1">var clone = el.cloneNode();</span><span class="s2">\n            </span><span class="s1">if (el._transitionClasses) {</span><span class="s2">\n                </span><span class="s1">el._transitionClasses.forEach(function (cls) {</span><span class="s2">\n                    </span><span class="s1">removeClass(clone, cls);</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">addClass(clone, moveClass);</span><span class="s2">\n            </span><span class="s1">clone.style.display = 'none';</span><span class="s2">\n            </span><span class="s1">this.$el.appendChild(clone);</span><span class="s2">\n            </span><span class="s1">var info = getTransitionInfo(clone);</span><span class="s2">\n            </span><span class="s1">this.$el.removeChild(clone);</span><span class="s2">\n            </span><span class="s1">return (this._hasMove = info.hasTransform);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function callPendingCbs(c) {</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (c.elm._moveCb) {</span><span class="s2">\n        </span><span class="s1">c.elm._moveCb();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (c.elm._enterCb) {</span><span class="s2">\n        </span><span class="s1">c.elm._enterCb();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function recordPosition(c) {</span><span class="s2">\n    </span><span class="s1">c.data.newPos = c.elm.getBoundingClientRect();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function applyTranslation(c) {</span><span class="s2">\n    </span><span class="s1">var oldPos = c.data.pos;</span><span class="s2">\n    </span><span class="s1">var newPos = c.data.newPos;</span><span class="s2">\n    </span><span class="s1">var dx = oldPos.left - newPos.left;</span><span class="s2">\n    </span><span class="s1">var dy = oldPos.top - newPos.top;</span><span class="s2">\n    </span><span class="s1">if (dx || dy) {</span><span class="s2">\n        </span><span class="s1">c.data.moved = true;</span><span class="s2">\n        </span><span class="s1">var s = c.elm.style;</span><span class="s2">\n        </span><span class="s1">s.transform = s.WebkitTransform = </span><span class="s2">\&quot;</span><span class="s1">translate(</span><span class="s2">\&quot;</span><span class="s1">.concat(dx, </span><span class="s2">\&quot;</span><span class="s1">px,</span><span class="s2">\&quot;</span><span class="s1">).concat(dy, </span><span class="s2">\&quot;</span><span class="s1">px)</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">s.transitionDuration = '0s';</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var platformComponents = {</span><span class="s2">\n    </span><span class="s1">Transition: Transition,</span><span class="s2">\n    </span><span class="s1">TransitionGroup: TransitionGroup</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// install platform specific utils</span><span class="s2">\n</span><span class="s1">Vue.config.mustUseProp = mustUseProp;</span><span class="s2">\n</span><span class="s1">Vue.config.isReservedTag = isReservedTag;</span><span class="s2">\n</span><span class="s1">Vue.config.isReservedAttr = isReservedAttr;</span><span class="s2">\n</span><span class="s1">Vue.config.getTagNamespace = getTagNamespace;</span><span class="s2">\n</span><span class="s1">Vue.config.isUnknownElement = isUnknownElement;</span><span class="s2">\n</span><span class="s1">// install platform runtime directives &amp; components</span><span class="s2">\n</span><span class="s1">extend(Vue.options.directives, platformDirectives);</span><span class="s2">\n</span><span class="s1">extend(Vue.options.components, platformComponents);</span><span class="s2">\n</span><span class="s1">// install platform patch function</span><span class="s2">\n</span><span class="s1">Vue.prototype.__patch__ = inBrowser ? patch : noop;</span><span class="s2">\n</span><span class="s1">// public mount method</span><span class="s2">\n</span><span class="s1">Vue.prototype.$mount = function (el, hydrating) {</span><span class="s2">\n    </span><span class="s1">el = el &amp;&amp; inBrowser ? query(el) : undefined;</span><span class="s2">\n    </span><span class="s1">return mountComponent(this, el, hydrating);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">// devtools global hook</span><span class="s2">\n</span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n</span><span class="s1">if (inBrowser) {</span><span class="s2">\n    </span><span class="s1">setTimeout(function () {</span><span class="s2">\n        </span><span class="s1">if (config.devtools) {</span><span class="s2">\n            </span><span class="s1">if (devtools) {</span><span class="s2">\n                </span><span class="s1">devtools.emit('init', Vue);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (process.env.NODE_ENV !== 'production' &amp;&amp; process.env.NODE_ENV !== 'test') {</span><span class="s2">\n                </span><span class="s1">// @ts-expect-error</span><span class="s2">\n                </span><span class="s1">console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:</span><span class="s2">\\</span><span class="s1">n' +</span><span class="s2">\n                    </span><span class="s1">'https://github.com/vuejs/vue-devtools');</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n            </span><span class="s1">process.env.NODE_ENV !== 'test' &amp;&amp;</span><span class="s2">\n            </span><span class="s1">config.productionTip !== false &amp;&amp;</span><span class="s2">\n            </span><span class="s1">typeof console !== 'undefined') {</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error</span><span class="s2">\n            </span><span class="s1">console[console.info ? 'info' : 'log'](</span><span class="s2">\&quot;</span><span class="s1">You are running Vue in development mode.</span><span class="s2">\\</span><span class="s1">n</span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                \&quot;</span><span class="s1">Make sure to turn on production mode when deploying for production.</span><span class="s2">\\</span><span class="s1">n</span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                \&quot;</span><span class="s1">See more tips at https://vuejs.org/guide/deployment.html</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}, 0);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export { EffectScope, computed, customRef, Vue as default, defineAsyncComponent, defineComponent, del, effectScope, getCurrentInstance, getCurrentScope, h, inject, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, mergeDefaults, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onScopeDispose, onServerPrefetch, onUnmounted, onUpdated, provide, proxyRefs, reactive, readonly, ref$1 as ref, set, shallowReactive, shallowReadonly, shallowRef, toRaw, toRef, toRefs, triggerRef, unref, useAttrs, useCssModule, useCssVars, useListeners, useSlots, version, watch, watchEffect, watchPostEffect, watchSyncEffect };</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">},</span><span class="s1">&quot;metadata&quot;</span><span class="s0">:{},</span><span class="s1">&quot;sourceType&quot;</span><span class="s0">:</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;externalDependencies&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>