<html>
<head>
<title>isReferenced.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
isReferenced.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;isReferenced&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;grandparent&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;local&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/validators/isReferenced.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type * as t from </span><span class="s3">\&quot;</span><span class="s1">../index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check if the input `node` is a reference to a bound variable.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function isReferenced(</span><span class="s3">\n  </span><span class="s1">node: t.Node,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n  </span><span class="s1">grandparent?: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">switch (parent.type) {</span><span class="s3">\n    </span><span class="s1">// yes: PARENT[NODE]</span><span class="s3">\n    </span><span class="s1">// yes: NODE.child</span><span class="s3">\n    </span><span class="s1">// no: parent.NODE</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">MemberExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">OptionalMemberExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">if (parent.property === node) {</span><span class="s3">\n        </span><span class="s1">return !!parent.computed;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return parent.object === node;</span><span class="s3">\n\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">JSXMemberExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return parent.object === node;</span><span class="s3">\n    </span><span class="s1">// no: let NODE = init;</span><span class="s3">\n    </span><span class="s1">// yes: let id = NODE;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">VariableDeclarator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return parent.init === node;</span><span class="s3">\n\n    </span><span class="s1">// yes: () =&gt; NODE</span><span class="s3">\n    </span><span class="s1">// no: (NODE) =&gt; {}</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ArrowFunctionExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return parent.body === node;</span><span class="s3">\n\n    </span><span class="s1">// no: class { #NODE; }</span><span class="s3">\n    </span><span class="s1">// no: class { get #NODE() {} }</span><span class="s3">\n    </span><span class="s1">// no: class { #NODE() {} }</span><span class="s3">\n    </span><span class="s1">// no: class { fn() { return this.#NODE; } }</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">PrivateName</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n\n    </span><span class="s1">// no: class { NODE() {} }</span><span class="s3">\n    </span><span class="s1">// yes: class { [NODE]() {} }</span><span class="s3">\n    </span><span class="s1">// no: class { foo(NODE) {} }</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassMethod</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassPrivateMethod</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ObjectMethod</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">if (parent.key === node) {</span><span class="s3">\n        </span><span class="s1">return !!parent.computed;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n\n    </span><span class="s1">// yes: { [NODE]: </span><span class="s3">\&quot;\&quot; </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// no: { NODE: </span><span class="s3">\&quot;\&quot; </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// depends: { NODE }</span><span class="s3">\n    </span><span class="s1">// depends: { key: NODE }</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ObjectProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">if (parent.key === node) {</span><span class="s3">\n        </span><span class="s1">return !!parent.computed;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// parent.value === node</span><span class="s3">\n      </span><span class="s1">return !grandparent || grandparent.type !== </span><span class="s3">\&quot;</span><span class="s1">ObjectPattern</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// no: class { NODE = value; }</span><span class="s3">\n    </span><span class="s1">// yes: class { [NODE] = value; }</span><span class="s3">\n    </span><span class="s1">// yes: class { key = NODE; }</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassAccessorProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">if (parent.key === node) {</span><span class="s3">\n        </span><span class="s1">return !!parent.computed;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassPrivateProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return parent.key !== node;</span><span class="s3">\n\n    </span><span class="s1">// no: class NODE {}</span><span class="s3">\n    </span><span class="s1">// yes: class Foo extends NODE {}</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return parent.superClass === node;</span><span class="s3">\n\n    </span><span class="s1">// yes: left = NODE;</span><span class="s3">\n    </span><span class="s1">// no: NODE = right;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return parent.right === node;</span><span class="s3">\n\n    </span><span class="s1">// no: [NODE = foo] = [];</span><span class="s3">\n    </span><span class="s1">// yes: [foo = NODE] = [];</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return parent.right === node;</span><span class="s3">\n\n    </span><span class="s1">// no: NODE: for (;;) {}</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">LabeledStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n\n    </span><span class="s1">// no: try {} catch (NODE) {}</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">CatchClause</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n\n    </span><span class="s1">// no: function foo(...NODE) {}</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">RestElement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">BreakStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ContinueStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n\n    </span><span class="s1">// no: function NODE() {}</span><span class="s3">\n    </span><span class="s1">// no: function foo(NODE) {}</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">FunctionDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">FunctionExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n\n    </span><span class="s1">// no: export NODE from </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// no: export * as NODE from </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ExportNamespaceSpecifier</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ExportDefaultSpecifier</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n\n    </span><span class="s1">// no: export { foo as NODE };</span><span class="s3">\n    </span><span class="s1">// yes: export { NODE as foo };</span><span class="s3">\n    </span><span class="s1">// no: export { NODE as foo } from </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ExportSpecifier</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): Property 'source' does not exist on type 'AnyTypeAnnotation'.</span><span class="s3">\n      </span><span class="s1">if (grandparent?.source) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return parent.local === node;</span><span class="s3">\n\n    </span><span class="s1">// no: import NODE from </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// no: import * as NODE from </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// no: import { NODE as foo } from </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// no: import { foo as NODE } from </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// no: import NODE from </span><span class="s3">\&quot;</span><span class="s1">bar</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ImportDefaultSpecifier</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ImportNamespaceSpecifier</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ImportSpecifier</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n\n    </span><span class="s1">// no: import </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot; </span><span class="s1">assert { NODE: </span><span class="s3">\&quot;</span><span class="s1">json</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ImportAttribute</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n\n    </span><span class="s1">// no: &lt;div NODE=</span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">JSXAttribute</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n\n    </span><span class="s1">// no: [NODE] = [];</span><span class="s3">\n    </span><span class="s1">// no: ({ NODE }) = [];</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ObjectPattern</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ArrayPattern</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n\n    </span><span class="s1">// no: new.NODE</span><span class="s3">\n    </span><span class="s1">// no: NODE.target</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">MetaProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n\n    </span><span class="s1">// yes: type X = { someProperty: NODE }</span><span class="s3">\n    </span><span class="s1">// no: type X = { NODE: OtherType }</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ObjectTypeProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return parent.key !== node;</span><span class="s3">\n\n    </span><span class="s1">// yes: enum X { Foo = NODE }</span><span class="s3">\n    </span><span class="s1">// no: enum X { NODE }</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSEnumMember</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return parent.id !== node;</span><span class="s3">\n\n    </span><span class="s1">// yes: { [NODE]: value }</span><span class="s3">\n    </span><span class="s1">// no: { NODE: value }</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSPropertySignature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">if (parent.key === node) {</span><span class="s3">\n        </span><span class="s1">return !!parent.computed;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAKe,SAASA,YAAYA,CAClCC,IAAY,EACZC,MAAc,EACdC,WAAoB,EACX;EACT,QAAQD,MAAM,CAACE,IAAI;IAIjB,KAAK,kBAAkB;IACvB,KAAK,0BAA0B;MAC7B,IAAIF,MAAM,CAACG,QAAQ,KAAKJ,IAAI,EAAE;QAC5B,OAAO,CAAC,CAACC,MAAM,CAACI,QAAQ;MAC1B;MACA,OAAOJ,MAAM,CAACK,MAAM,KAAKN,IAAI;IAE/B,KAAK,qBAAqB;MACxB,OAAOC,MAAM,CAACK,MAAM,KAAKN,IAAI;IAG/B,KAAK,oBAAoB;MACvB,OAAOC,MAAM,CAACM,IAAI,KAAKP,IAAI;IAI7B,KAAK,yBAAyB;MAC5B,OAAOC,MAAM,CAACO,IAAI,KAAKR,IAAI;IAM7B,KAAK,aAAa;MAChB,OAAO,KAAK;IAKd,KAAK,aAAa;IAClB,KAAK,oBAAoB;IACzB,KAAK,cAAc;MACjB,IAAIC,MAAM,CAACQ,GAAG,KAAKT,IAAI,EAAE;QACvB,OAAO,CAAC,CAACC,MAAM,CAACI,QAAQ;MAC1B;MACA,OAAO,KAAK;IAMd,KAAK,gBAAgB;MACnB,IAAIJ,MAAM,CAACQ,GAAG,KAAKT,IAAI,EAAE;QACvB,OAAO,CAAC,CAACC,MAAM,CAACI,QAAQ;MAC1B;MAEA,OAAO,CAACH,WAAW,IAAIA,WAAW,CAACC,IAAI,KAAK,eAAe;IAI7D,KAAK,eAAe;IACpB,KAAK,uBAAuB;MAC1B,IAAIF,MAAM,CAACQ,GAAG,KAAKT,IAAI,EAAE;QACvB,OAAO,CAAC,CAACC,MAAM,CAACI,QAAQ;MAC1B;MACA,OAAO,IAAI;IACb,KAAK,sBAAsB;MACzB,OAAOJ,MAAM,CAACQ,GAAG,KAAKT,IAAI;IAI5B,KAAK,kBAAkB;IACvB,KAAK,iBAAiB;MACpB,OAAOC,MAAM,CAACS,UAAU,KAAKV,IAAI;IAInC,KAAK,sBAAsB;MACzB,OAAOC,MAAM,CAACU,KAAK,KAAKX,IAAI;IAI9B,KAAK,mBAAmB;MACtB,OAAOC,MAAM,CAACU,KAAK,KAAKX,IAAI;IAG9B,KAAK,kBAAkB;MACrB,OAAO,KAAK;IAGd,KAAK,aAAa;MAChB,OAAO,KAAK;IAGd,KAAK,aAAa;MAChB,OAAO,KAAK;IAEd,KAAK,gBAAgB;IACrB,KAAK,mBAAmB;MACtB,OAAO,KAAK;IAId,KAAK,qBAAqB;IAC1B,KAAK,oBAAoB;MACvB,OAAO,KAAK;IAId,KAAK,0BAA0B;IAC/B,KAAK,wBAAwB;MAC3B,OAAO,KAAK;IAKd,KAAK,iBAAiB;MAEpB,IAAIE,WAAW,YAAXA,WAAW,CAAEU,MAAM,EAAE;QACvB,OAAO,KAAK;MACd;MACA,OAAOX,MAAM,CAACY,KAAK,KAAKb,IAAI;IAO9B,KAAK,wBAAwB;IAC7B,KAAK,0BAA0B;IAC/B,KAAK,iBAAiB;MACpB,OAAO,KAAK;IAGd,KAAK,iBAAiB;MACpB,OAAO,KAAK;IAGd,KAAK,cAAc;MACjB,OAAO,KAAK;IAId,KAAK,eAAe;IACpB,KAAK,cAAc;MACjB,OAAO,KAAK;IAId,KAAK,cAAc;MACjB,OAAO,KAAK;IAId,KAAK,oBAAoB;MACvB,OAAOC,MAAM,CAACQ,GAAG,KAAKT,IAAI;IAI5B,KAAK,cAAc;MACjB,OAAOC,MAAM,CAACa,EAAE,KAAKd,IAAI;IAI3B,KAAK,qBAAqB;MACxB,IAAIC,MAAM,CAACQ,GAAG,KAAKT,IAAI,EAAE;QACvB,OAAO,CAAC,CAACC,MAAM,CAACI,QAAQ;MAC1B;MAEA,OAAO,IAAI;EACf;EAEA,OAAO,IAAI;AACb&quot;</span><span class="s0">}</span></pre>
</body>
</html>