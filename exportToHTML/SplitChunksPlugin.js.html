<html>
<head>
<title>SplitChunksPlugin.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #bcbec4;}
.s4 { color: #cf8e6d;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #67a37c; font-style: italic;}
.s7 { color: #2aacb8;}
.s8 { color: #42c3d4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
SplitChunksPlugin.js</font>
</center></td></tr></table>
<pre><span class="s0">/* 
    MIT License http://www.opensource.org/licenses/mit-license.php 
    Author Tobias Koppers @sokra 
*/</span>

<span class="s2">&quot;use strict&quot;</span><span class="s3">;</span>

<span class="s4">const </span><span class="s1">Chunk </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../Chunk&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">STAGE_ADVANCED </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../OptimizationStages&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">WebpackError </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../WebpackError&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">requestToId </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../ids/IdHelpers&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">isSubset </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../util/SetHelpers&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">SortableSet </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../util/SortableSet&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{</span>
	<span class="s1">compareModulesByIdentifier</span><span class="s3">,</span>
	<span class="s1">compareIterables</span>
<span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../util/comparators&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">createHash </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../util/createHash&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">deterministicGrouping </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../util/deterministicGrouping&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">makePathsRelative </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../util/identifier&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">memoize </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../util/memoize&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">MinMaxSizeWarning </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./MinMaxSizeWarning&quot;</span><span class="s3">);</span>

<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../../declarations/WebpackOptions&quot;).OptimizationSplitChunksCacheGroup} OptimizationSplitChunksCacheGroup */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../../declarations/WebpackOptions&quot;).OptimizationSplitChunksGetCacheGroups} OptimizationSplitChunksGetCacheGroups */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../../declarations/WebpackOptions&quot;).OptimizationSplitChunksOptions} OptimizationSplitChunksOptions */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../../declarations/WebpackOptions&quot;).OptimizationSplitChunksSizes} OptimizationSplitChunksSizes */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../../declarations/WebpackOptions&quot;).Output} OutputOptions */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../ChunkGraph&quot;)} ChunkGraph */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../ChunkGroup&quot;)} ChunkGroup */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../Compilation&quot;).AssetInfo} AssetInfo */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../Compilation&quot;).PathData} PathData */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../Compiler&quot;)} Compiler */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../Module&quot;)} Module */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../ModuleGraph&quot;)} ModuleGraph */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../util/deterministicGrouping&quot;).GroupedItems&lt;Module&gt;} DeterministicGroupingGroupedItemsForModule */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../util/deterministicGrouping&quot;).Options&lt;Module&gt;} DeterministicGroupingOptionsForModule */</span>

<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{Record&lt;string, number&gt;} SplitChunksSizes */</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@callback </span><span class="s5">ChunkFilterFunction</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean | undefined}</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@callback </span><span class="s5">CombineSizeFunction</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} a</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} b</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number}</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} CacheGroupSource</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} key</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number=} priority</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{GetName=} getName</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ChunkFilterFunction=} chunksFilter</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean=} enforce</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} minSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} minSizeReduction</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} minRemainingSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} enforceSizeThreshold</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} maxAsyncSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} maxInitialSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number=} minChunks</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number=} maxAsyncRequests</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number=} maxInitialRequests</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{(string | function(PathData, AssetInfo=): string)=} filename</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} idHint</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} automaticNameDelimiter</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean=} reuseExistingChunk</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean=} usedExports</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} CacheGroup</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} key</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number=} priority</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{GetName=} getName</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ChunkFilterFunction=} chunksFilter</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} minSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} minSizeReduction</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} minRemainingSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} enforceSizeThreshold</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} maxAsyncSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} maxInitialSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number=} minChunks</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number=} maxAsyncRequests</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number=} maxInitialRequests</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{(string | function(PathData, AssetInfo=): string)=} filename</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} idHint</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} automaticNameDelimiter</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} reuseExistingChunk</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} usedExports</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} _validateSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} _validateRemainingSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} _minSizeForMaxSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} _conditionalEnforce</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} FallbackCacheGroup</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ChunkFilterFunction} chunksFilter</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} minSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} maxAsyncSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} maxInitialSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} automaticNameDelimiter</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} CacheGroupsContext</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ModuleGraph} moduleGraph</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ChunkGraph} chunkGraph</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@callback </span><span class="s5">GetCacheGroups</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{CacheGroupsContext} context</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{CacheGroupSource[]}</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@callback </span><span class="s5">GetName</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module=} module</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk[]=} chunks</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string=} key</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string=}</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} SplitChunksOptions</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ChunkFilterFunction} chunksFilter</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string[]} defaultSizeTypes</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} minSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} minSizeReduction</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} minRemainingSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} enforceSizeThreshold</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} maxInitialSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} maxAsyncSize</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number} minChunks</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number} maxAsyncRequests</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number} maxInitialRequests</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} hidePathInfo</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string | function(PathData, AssetInfo=): string} filename</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} automaticNameDelimiter</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{GetCacheGroups} getCacheGroups</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{GetName} getName</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} usedExports</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{FallbackCacheGroup} fallbackCacheGroup</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} ChunksInfoItem</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SortableSet&lt;Module&gt;} modules</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{CacheGroup} cacheGroup</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number} cacheGroupIndex</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} name</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Record&lt;string, number&gt;} sizes</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Set&lt;Chunk&gt;} chunks</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Set&lt;Chunk&gt;} reuseableChunks</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Set&lt;bigint | Chunk&gt;} chunksKeys</span>
 <span class="s5">*/</span>

<span class="s4">const </span><span class="s1">defaultGetName </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{GetName} */ </span><span class="s3">(() =&gt; {});</span>

<span class="s4">const </span><span class="s1">deterministicGroupingForModules </span><span class="s3">=</span>
	<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */ </span><span class="s3">(</span>
		<span class="s1">deterministicGrouping</span>
	<span class="s3">);</span>

<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WeakMap&lt;Module, string&gt;} */</span>
<span class="s4">const </span><span class="s1">getKeyCache </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} name a filename to hash</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{OutputOptions} outputOptions hash function used</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} hashed filename</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">hashFilename </span><span class="s3">= (</span><span class="s1">name</span><span class="s3">, </span><span class="s1">outputOptions</span><span class="s3">) =&gt; {</span>
	<span class="s4">const </span><span class="s1">digest </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */ </span><span class="s3">(</span>
		<span class="s1">createHash</span><span class="s3">(</span><span class="s1">outputOptions</span><span class="s3">.</span><span class="s1">hashFunction</span><span class="s3">)</span>
			<span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
			<span class="s3">.</span><span class="s1">digest</span><span class="s3">(</span><span class="s1">outputOptions</span><span class="s3">.</span><span class="s1">hashDigest</span><span class="s3">)</span>
	<span class="s3">);</span>
	<span class="s4">return </span><span class="s1">digest</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">0</span><span class="s3">, </span><span class="s7">8</span><span class="s3">);</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number} the number of requests</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">getRequests </span><span class="s3">= </span><span class="s1">chunk </span><span class="s3">=&gt; {</span>
	<span class="s4">let </span><span class="s1">requests </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunkGroup of chunk</span><span class="s3">.</span><span class="s1">groupsIterable</span><span class="s3">) {</span>
		<span class="s1">requests </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">requests</span><span class="s3">, </span><span class="s1">chunkGroup</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">length</span><span class="s3">);</span>
	<span class="s3">}</span>
	<span class="s4">return </span><span class="s1">requests</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s4">const </span><span class="s1">mapObject </span><span class="s3">= (</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">) =&gt; {</span>
	<span class="s4">const </span><span class="s1">newObj </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s4">null</span><span class="s3">);</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">key of Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)) {</span>
		<span class="s1">newObj</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">fn</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">[</span><span class="s1">key</span><span class="s3">], </span><span class="s1">key</span><span class="s3">);</span>
	<span class="s3">}</span>
	<span class="s4">return </span><span class="s1">newObj</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@template </span><span class="s5">T</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Set&lt;T&gt;} a set</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Set&lt;T&gt;} b other set</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true if at least one item of a is in b</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">isOverlap </span><span class="s3">= (</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">) =&gt; {</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">item of a</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">item</span><span class="s3">)) </span><span class="s4">return true</span><span class="s3">;</span>
	<span class="s3">}</span>
	<span class="s4">return false</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s4">const </span><span class="s1">compareModuleIterables </span><span class="s3">= </span><span class="s1">compareIterables</span><span class="s3">(</span><span class="s1">compareModulesByIdentifier</span><span class="s3">);</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunksInfoItem} a item</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunksInfoItem} b item</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number} compare result</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">compareEntries </span><span class="s3">= (</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">) =&gt; {</span>
	<span class="s0">// 1. by priority</span>
	<span class="s4">const </span><span class="s1">diffPriority </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">priority </span><span class="s3">- </span><span class="s1">b</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">priority</span><span class="s3">;</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">diffPriority</span><span class="s3">) </span><span class="s4">return </span><span class="s1">diffPriority</span><span class="s3">;</span>
	<span class="s0">// 2. by number of chunks</span>
	<span class="s4">const </span><span class="s1">diffCount </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">size </span><span class="s3">- </span><span class="s1">b</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">size</span><span class="s3">;</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">diffCount</span><span class="s3">) </span><span class="s4">return </span><span class="s1">diffCount</span><span class="s3">;</span>
	<span class="s0">// 3. by size reduction</span>
	<span class="s4">const </span><span class="s1">aSizeReduce </span><span class="s3">= </span><span class="s1">totalSize</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">sizes</span><span class="s3">) * (</span><span class="s1">a</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">size </span><span class="s3">- </span><span class="s7">1</span><span class="s3">);</span>
	<span class="s4">const </span><span class="s1">bSizeReduce </span><span class="s3">= </span><span class="s1">totalSize</span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">sizes</span><span class="s3">) * (</span><span class="s1">b</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">size </span><span class="s3">- </span><span class="s7">1</span><span class="s3">);</span>
	<span class="s4">const </span><span class="s1">diffSizeReduce </span><span class="s3">= </span><span class="s1">aSizeReduce </span><span class="s3">- </span><span class="s1">bSizeReduce</span><span class="s3">;</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">diffSizeReduce</span><span class="s3">) </span><span class="s4">return </span><span class="s1">diffSizeReduce</span><span class="s3">;</span>
	<span class="s0">// 4. by cache group index</span>
	<span class="s4">const </span><span class="s1">indexDiff </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">cacheGroupIndex </span><span class="s3">- </span><span class="s1">a</span><span class="s3">.</span><span class="s1">cacheGroupIndex</span><span class="s3">;</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">indexDiff</span><span class="s3">) </span><span class="s4">return </span><span class="s1">indexDiff</span><span class="s3">;</span>
	<span class="s0">// 5. by number of modules (to be able to compare by identifier)</span>
	<span class="s4">const </span><span class="s1">modulesA </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">;</span>
	<span class="s4">const </span><span class="s1">modulesB </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">;</span>
	<span class="s4">const </span><span class="s1">diff </span><span class="s3">= </span><span class="s1">modulesA</span><span class="s3">.</span><span class="s1">size </span><span class="s3">- </span><span class="s1">modulesB</span><span class="s3">.</span><span class="s1">size</span><span class="s3">;</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">diff</span><span class="s3">) </span><span class="s4">return </span><span class="s1">diff</span><span class="s3">;</span>
	<span class="s0">// 6. by module identifiers</span>
	<span class="s1">modulesA</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">();</span>
	<span class="s1">modulesB</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">();</span>
	<span class="s4">return </span><span class="s1">compareModuleIterables</span><span class="s3">(</span><span class="s1">modulesA</span><span class="s3">, </span><span class="s1">modulesB</span><span class="s3">);</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true, if the chunk is an entry chunk</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">INITIAL_CHUNK_FILTER </span><span class="s3">= </span><span class="s1">chunk </span><span class="s3">=&gt; </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">canBeInitial</span><span class="s3">();</span>
<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true, if the chunk is an async chunk</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">ASYNC_CHUNK_FILTER </span><span class="s3">= </span><span class="s1">chunk </span><span class="s3">=&gt; !</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">canBeInitial</span><span class="s3">();</span>
<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} always true</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">ALL_CHUNK_FILTER </span><span class="s3">= </span><span class="s1">chunk </span><span class="s3">=&gt; </span><span class="s4">true</span><span class="s3">;</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{OptimizationSplitChunksSizes | undefined} value the sizes</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string[]} defaultSizeTypes the default size types</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{SplitChunksSizes} normalized representation</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">normalizeSizes </span><span class="s3">= (</span><span class="s1">value</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">) =&gt; {</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">value </span><span class="s3">=== </span><span class="s2">&quot;number&quot;</span><span class="s3">) {</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Record&lt;string, number&gt;} */</span>
		<span class="s4">const </span><span class="s1">o </span><span class="s3">= {};</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">sizeType of defaultSizeTypes</span><span class="s3">) </span><span class="s1">o</span><span class="s3">[</span><span class="s1">sizeType</span><span class="s3">] = </span><span class="s1">value</span><span class="s3">;</span>
		<span class="s4">return </span><span class="s1">o</span><span class="s3">;</span>
	<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">value </span><span class="s3">=== </span><span class="s2">&quot;object&quot; </span><span class="s3">&amp;&amp; </span><span class="s1">value </span><span class="s3">!== </span><span class="s4">null</span><span class="s3">) {</span>
		<span class="s4">return </span><span class="s3">{ </span><span class="s1">...value </span><span class="s3">};</span>
	<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
		<span class="s4">return </span><span class="s3">{};</span>
	<span class="s3">}</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{...SplitChunksSizes} sizes the sizes</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{SplitChunksSizes} the merged sizes</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">mergeSizes </span><span class="s3">= (</span><span class="s1">...sizes</span><span class="s3">) =&gt; {</span>
	<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SplitChunksSizes} */</span>
	<span class="s4">let </span><span class="s1">merged </span><span class="s3">= {};</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">let </span><span class="s1">i </span><span class="s3">= </span><span class="s1">sizes</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s7">1</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&gt;= </span><span class="s7">0</span><span class="s3">; </span><span class="s1">i</span><span class="s3">--) {</span>
		<span class="s1">merged </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">assign</span><span class="s3">(</span><span class="s1">merged</span><span class="s3">, </span><span class="s1">sizes</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]);</span>
	<span class="s3">}</span>
	<span class="s4">return </span><span class="s1">merged</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{SplitChunksSizes} sizes the sizes</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true, if there are sizes &gt; 0</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">hasNonZeroSizes </span><span class="s3">= </span><span class="s1">sizes </span><span class="s3">=&gt; {</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">key of Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">sizes</span><span class="s3">)) {</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">sizes</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] &gt; </span><span class="s7">0</span><span class="s3">) </span><span class="s4">return true</span><span class="s3">;</span>
	<span class="s3">}</span>
	<span class="s4">return false</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{SplitChunksSizes} a first sizes</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{SplitChunksSizes} b second sizes</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{CombineSizeFunction} combine a function to combine sizes</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{SplitChunksSizes} the combine sizes</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">combineSizes </span><span class="s3">= (</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">combine</span><span class="s3">) =&gt; {</span>
	<span class="s4">const </span><span class="s1">aKeys </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">a</span><span class="s3">));</span>
	<span class="s4">const </span><span class="s1">bKeys </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">b</span><span class="s3">));</span>
	<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SplitChunksSizes} */</span>
	<span class="s4">const </span><span class="s1">result </span><span class="s3">= {};</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">key of aKeys</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">bKeys</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)) {</span>
			<span class="s1">result</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">combine</span><span class="s3">(</span><span class="s1">a</span><span class="s3">[</span><span class="s1">key</span><span class="s3">], </span><span class="s1">b</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]);</span>
		<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
			<span class="s1">result</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
		<span class="s3">}</span>
	<span class="s3">}</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">key of bKeys</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(!</span><span class="s1">aKeys</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)) {</span>
			<span class="s1">result</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">b</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
		<span class="s3">}</span>
	<span class="s3">}</span>
	<span class="s4">return </span><span class="s1">result</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{SplitChunksSizes} sizes the sizes</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{SplitChunksSizes} minSize the min sizes</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true if there are sizes and all existing sizes are at least `minSize`</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">checkMinSize </span><span class="s3">= (</span><span class="s1">sizes</span><span class="s3">, </span><span class="s1">minSize</span><span class="s3">) =&gt; {</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">key of Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">minSize</span><span class="s3">)) {</span>
		<span class="s4">const </span><span class="s1">size </span><span class="s3">= </span><span class="s1">sizes</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">size </span><span class="s3">=== </span><span class="s1">undefined </span><span class="s3">|| </span><span class="s1">size </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">size </span><span class="s3">&lt; </span><span class="s1">minSize</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]) </span><span class="s4">return false</span><span class="s3">;</span>
	<span class="s3">}</span>
	<span class="s4">return true</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{SplitChunksSizes} sizes the sizes</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{SplitChunksSizes} minSizeReduction the min sizes</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} chunkCount number of chunks</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true if there are sizes and all existing sizes are at least `minSizeReduction`</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">checkMinSizeReduction </span><span class="s3">= (</span><span class="s1">sizes</span><span class="s3">, </span><span class="s1">minSizeReduction</span><span class="s3">, </span><span class="s1">chunkCount</span><span class="s3">) =&gt; {</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">key of Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">minSizeReduction</span><span class="s3">)) {</span>
		<span class="s4">const </span><span class="s1">size </span><span class="s3">= </span><span class="s1">sizes</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">size </span><span class="s3">=== </span><span class="s1">undefined </span><span class="s3">|| </span><span class="s1">size </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">size </span><span class="s3">* </span><span class="s1">chunkCount </span><span class="s3">&lt; </span><span class="s1">minSizeReduction</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]) </span><span class="s4">return false</span><span class="s3">;</span>
	<span class="s3">}</span>
	<span class="s4">return true</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{SplitChunksSizes} sizes the sizes</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{SplitChunksSizes} minSize the min sizes</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{undefined | string[]} list of size types that are below min size</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">getViolatingMinSizes </span><span class="s3">= (</span><span class="s1">sizes</span><span class="s3">, </span><span class="s1">minSize</span><span class="s3">) =&gt; {</span>
	<span class="s4">let </span><span class="s1">list</span><span class="s3">;</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">key of Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">minSize</span><span class="s3">)) {</span>
		<span class="s4">const </span><span class="s1">size </span><span class="s3">= </span><span class="s1">sizes</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">size </span><span class="s3">=== </span><span class="s1">undefined </span><span class="s3">|| </span><span class="s1">size </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">size </span><span class="s3">&lt; </span><span class="s1">minSize</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">list </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s1">list </span><span class="s3">= [</span><span class="s1">key</span><span class="s3">];</span>
			<span class="s4">else </span><span class="s1">list</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">}</span>
	<span class="s4">return </span><span class="s1">list</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{SplitChunksSizes} sizes the sizes</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number} the total size</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">totalSize </span><span class="s3">= </span><span class="s1">sizes </span><span class="s3">=&gt; {</span>
	<span class="s4">let </span><span class="s1">size </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">key of Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">sizes</span><span class="s3">)) {</span>
		<span class="s1">size </span><span class="s3">+= </span><span class="s1">sizes</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
	<span class="s3">}</span>
	<span class="s4">return </span><span class="s1">size</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{false|string|Function|undefined} name the chunk name</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{GetName | undefined} a function to get the name of the chunk</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">normalizeName </span><span class="s3">= </span><span class="s1">name </span><span class="s3">=&gt; {</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">name </span><span class="s3">=== </span><span class="s2">&quot;string&quot;</span><span class="s3">) {</span>
		<span class="s4">return </span><span class="s3">() =&gt; </span><span class="s1">name</span><span class="s3">;</span>
	<span class="s3">}</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">name </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
		<span class="s4">return </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{GetName} */ </span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
	<span class="s3">}</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{OptimizationSplitChunksCacheGroup[&quot;chunks&quot;]} chunks the chunk filter option</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ChunkFilterFunction} the chunk filter function</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">normalizeChunksFilter </span><span class="s3">= </span><span class="s1">chunks </span><span class="s3">=&gt; {</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">chunks </span><span class="s3">=== </span><span class="s2">&quot;initial&quot;</span><span class="s3">) {</span>
		<span class="s4">return </span><span class="s1">INITIAL_CHUNK_FILTER</span><span class="s3">;</span>
	<span class="s3">}</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">chunks </span><span class="s3">=== </span><span class="s2">&quot;async&quot;</span><span class="s3">) {</span>
		<span class="s4">return </span><span class="s1">ASYNC_CHUNK_FILTER</span><span class="s3">;</span>
	<span class="s3">}</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">chunks </span><span class="s3">=== </span><span class="s2">&quot;all&quot;</span><span class="s3">) {</span>
		<span class="s4">return </span><span class="s1">ALL_CHUNK_FILTER</span><span class="s3">;</span>
	<span class="s3">}</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">chunks </span><span class="s4">instanceof </span><span class="s1">RegExp</span><span class="s3">) {</span>
		<span class="s4">return </span><span class="s1">chunk </span><span class="s3">=&gt; {</span>
			<span class="s4">return </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">name </span><span class="s3">? </span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">name</span><span class="s3">) : </span><span class="s4">false</span><span class="s3">;</span>
		<span class="s3">};</span>
	<span class="s3">}</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">chunks </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
		<span class="s4">return </span><span class="s1">chunks</span><span class="s3">;</span>
	<span class="s3">}</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{GetCacheGroups | Record&lt;string, false|string|RegExp|OptimizationSplitChunksGetCacheGroups|OptimizationSplitChunksCacheGroup&gt;} cacheGroups the cache group options</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string[]} defaultSizeTypes the default size types</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{GetCacheGroups} a function to get the cache groups</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">normalizeCacheGroups </span><span class="s3">= (</span><span class="s1">cacheGroups</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">) =&gt; {</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">cacheGroups </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
		<span class="s4">return </span><span class="s1">cacheGroups</span><span class="s3">;</span>
	<span class="s3">}</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">cacheGroups </span><span class="s3">=== </span><span class="s2">&quot;object&quot; </span><span class="s3">&amp;&amp; </span><span class="s1">cacheGroups </span><span class="s3">!== </span><span class="s4">null</span><span class="s3">) {</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{(function(Module, CacheGroupsContext, CacheGroupSource[]): void)[]} */</span>
		<span class="s4">const </span><span class="s1">handlers </span><span class="s3">= [];</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">key of Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">cacheGroups</span><span class="s3">)) {</span>
			<span class="s4">const </span><span class="s1">option </span><span class="s3">= </span><span class="s1">cacheGroups</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">option </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">) {</span>
				<span class="s4">continue</span><span class="s3">;</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">option </span><span class="s3">=== </span><span class="s2">&quot;string&quot; </span><span class="s3">|| </span><span class="s1">option </span><span class="s4">instanceof </span><span class="s1">RegExp</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">source </span><span class="s3">= </span><span class="s1">createCacheGroupSource</span><span class="s3">({}, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">);</span>
				<span class="s1">handlers</span><span class="s3">.</span><span class="s1">push</span><span class="s3">((</span><span class="s1">module</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">results</span><span class="s3">) =&gt; {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">checkTest</span><span class="s3">(</span><span class="s1">option</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">context</span><span class="s3">)) {</span>
						<span class="s1">results</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">source</span><span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">});</span>
			<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">option </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">cache </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>
				<span class="s1">handlers</span><span class="s3">.</span><span class="s1">push</span><span class="s3">((</span><span class="s1">module</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">results</span><span class="s3">) =&gt; {</span>
					<span class="s4">const </span><span class="s1">result </span><span class="s3">= </span><span class="s1">option</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">result</span><span class="s3">) {</span>
						<span class="s4">const </span><span class="s1">groups </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">result</span><span class="s3">) ? </span><span class="s1">result </span><span class="s3">: [</span><span class="s1">result</span><span class="s3">];</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">group of groups</span><span class="s3">) {</span>
							<span class="s4">const </span><span class="s1">cachedSource </span><span class="s3">= </span><span class="s1">cache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">group</span><span class="s3">);</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">cachedSource </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
								<span class="s1">results</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">cachedSource</span><span class="s3">);</span>
							<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
								<span class="s4">const </span><span class="s1">source </span><span class="s3">= </span><span class="s1">createCacheGroupSource</span><span class="s3">(</span>
									<span class="s1">group</span><span class="s3">,</span>
									<span class="s1">key</span><span class="s3">,</span>
									<span class="s1">defaultSizeTypes</span>
								<span class="s3">);</span>
								<span class="s1">cache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">group</span><span class="s3">, </span><span class="s1">source</span><span class="s3">);</span>
								<span class="s1">results</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">source</span><span class="s3">);</span>
							<span class="s3">}</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
				<span class="s3">});</span>
			<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
				<span class="s4">const </span><span class="s1">source </span><span class="s3">= </span><span class="s1">createCacheGroupSource</span><span class="s3">(</span><span class="s1">option</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">);</span>
				<span class="s1">handlers</span><span class="s3">.</span><span class="s1">push</span><span class="s3">((</span><span class="s1">module</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">results</span><span class="s3">) =&gt; {</span>
					<span class="s4">if </span><span class="s3">(</span>
						<span class="s1">checkTest</span><span class="s3">(</span><span class="s1">option</span><span class="s3">.</span><span class="s1">test</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) &amp;&amp;</span>
						<span class="s1">checkModuleType</span><span class="s3">(</span><span class="s1">option</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">module</span><span class="s3">) &amp;&amp;</span>
						<span class="s1">checkModuleLayer</span><span class="s3">(</span><span class="s1">option</span><span class="s3">.</span><span class="s1">layer</span><span class="s3">, </span><span class="s1">module</span><span class="s3">)</span>
					<span class="s3">) {</span>
						<span class="s1">results</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">source</span><span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">});</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s5">/**</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the current module</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{CacheGroupsContext} context the current context</span>
		 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{CacheGroupSource[]} the matching cache groups</span>
		 <span class="s5">*/</span>
		<span class="s4">const </span><span class="s1">fn </span><span class="s3">= (</span><span class="s1">module</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) =&gt; {</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{CacheGroupSource[]} */</span>
			<span class="s4">let </span><span class="s1">results </span><span class="s3">= [];</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">fn of handlers</span><span class="s3">) {</span>
				<span class="s1">fn</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">results</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">return </span><span class="s1">results</span><span class="s3">;</span>
		<span class="s3">};</span>
		<span class="s4">return </span><span class="s1">fn</span><span class="s3">;</span>
	<span class="s3">}</span>
	<span class="s4">return </span><span class="s3">() =&gt; </span><span class="s4">null</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{undefined|boolean|string|RegExp|Function} test test option</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{CacheGroupsContext} context context object</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true, if the module should be selected</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">checkTest </span><span class="s3">= (</span><span class="s1">test</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) =&gt; {</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">test </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">return true</span><span class="s3">;</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">test </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
		<span class="s4">return </span><span class="s1">test</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
	<span class="s3">}</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">test </span><span class="s3">=== </span><span class="s2">&quot;boolean&quot;</span><span class="s3">) </span><span class="s4">return </span><span class="s1">test</span><span class="s3">;</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">test </span><span class="s3">=== </span><span class="s2">&quot;string&quot;</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">name </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">nameForCondition</span><span class="s3">();</span>
		<span class="s4">return </span><span class="s1">name </span><span class="s3">&amp;&amp; </span><span class="s1">name</span><span class="s3">.</span><span class="s1">startsWith</span><span class="s3">(</span><span class="s1">test</span><span class="s3">);</span>
	<span class="s3">}</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">test </span><span class="s4">instanceof </span><span class="s1">RegExp</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">name </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">nameForCondition</span><span class="s3">();</span>
		<span class="s4">return </span><span class="s1">name </span><span class="s3">&amp;&amp; </span><span class="s1">test</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
	<span class="s3">}</span>
	<span class="s4">return false</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{undefined|string|RegExp|Function} test type option</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true, if the module should be selected</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">checkModuleType </span><span class="s3">= (</span><span class="s1">test</span><span class="s3">, </span><span class="s1">module</span><span class="s3">) =&gt; {</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">test </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">return true</span><span class="s3">;</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">test </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
		<span class="s4">return </span><span class="s1">test</span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">type</span><span class="s3">);</span>
	<span class="s3">}</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">test </span><span class="s3">=== </span><span class="s2">&quot;string&quot;</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">type </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">type</span><span class="s3">;</span>
		<span class="s4">return </span><span class="s1">test </span><span class="s3">=== </span><span class="s1">type</span><span class="s3">;</span>
	<span class="s3">}</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">test </span><span class="s4">instanceof </span><span class="s1">RegExp</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">type </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">type</span><span class="s3">;</span>
		<span class="s4">return </span><span class="s1">test</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">type</span><span class="s3">);</span>
	<span class="s3">}</span>
	<span class="s4">return false</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{undefined|string|RegExp|Function} test type option</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true, if the module should be selected</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">checkModuleLayer </span><span class="s3">= (</span><span class="s1">test</span><span class="s3">, </span><span class="s1">module</span><span class="s3">) =&gt; {</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">test </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">return true</span><span class="s3">;</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">test </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
		<span class="s4">return </span><span class="s1">test</span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">layer</span><span class="s3">);</span>
	<span class="s3">}</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">test </span><span class="s3">=== </span><span class="s2">&quot;string&quot;</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">layer </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">layer</span><span class="s3">;</span>
		<span class="s4">return </span><span class="s1">test </span><span class="s3">=== </span><span class="s2">&quot;&quot; </span><span class="s3">? !</span><span class="s1">layer </span><span class="s3">: </span><span class="s1">layer </span><span class="s3">&amp;&amp; </span><span class="s1">layer</span><span class="s3">.</span><span class="s1">startsWith</span><span class="s3">(</span><span class="s1">test</span><span class="s3">);</span>
	<span class="s3">}</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">test </span><span class="s4">instanceof </span><span class="s1">RegExp</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">layer </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">layer</span><span class="s3">;</span>
		<span class="s4">return </span><span class="s1">test</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">layer</span><span class="s3">);</span>
	<span class="s3">}</span>
	<span class="s4">return false</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{OptimizationSplitChunksCacheGroup} options the group options</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} key key of cache group</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string[]} defaultSizeTypes the default size types</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{CacheGroupSource} the normalized cached group</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">createCacheGroupSource </span><span class="s3">= (</span><span class="s1">options</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">) =&gt; {</span>
	<span class="s4">const </span><span class="s1">minSize </span><span class="s3">= </span><span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">minSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">);</span>
	<span class="s4">const </span><span class="s1">minSizeReduction </span><span class="s3">= </span><span class="s1">normalizeSizes</span><span class="s3">(</span>
		<span class="s1">options</span><span class="s3">.</span><span class="s1">minSizeReduction</span><span class="s3">,</span>
		<span class="s1">defaultSizeTypes</span>
	<span class="s3">);</span>
	<span class="s4">const </span><span class="s1">maxSize </span><span class="s3">= </span><span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">);</span>
	<span class="s4">return </span><span class="s3">{</span>
		<span class="s1">key</span><span class="s3">,</span>
		<span class="s1">priority</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">priority</span><span class="s3">,</span>
		<span class="s1">getName</span><span class="s3">: </span><span class="s1">normalizeName</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">name</span><span class="s3">),</span>
		<span class="s1">chunksFilter</span><span class="s3">: </span><span class="s1">normalizeChunksFilter</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">),</span>
		<span class="s1">enforce</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">enforce</span><span class="s3">,</span>
		<span class="s1">minSize</span><span class="s3">,</span>
		<span class="s1">minSizeReduction</span><span class="s3">,</span>
		<span class="s1">minRemainingSize</span><span class="s3">: </span><span class="s1">mergeSizes</span><span class="s3">(</span>
			<span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">minRemainingSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">),</span>
			<span class="s1">minSize</span>
		<span class="s3">),</span>
		<span class="s1">enforceSizeThreshold</span><span class="s3">: </span><span class="s1">normalizeSizes</span><span class="s3">(</span>
			<span class="s1">options</span><span class="s3">.</span><span class="s1">enforceSizeThreshold</span><span class="s3">,</span>
			<span class="s1">defaultSizeTypes</span>
		<span class="s3">),</span>
		<span class="s1">maxAsyncSize</span><span class="s3">: </span><span class="s1">mergeSizes</span><span class="s3">(</span>
			<span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxAsyncSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">),</span>
			<span class="s1">maxSize</span>
		<span class="s3">),</span>
		<span class="s1">maxInitialSize</span><span class="s3">: </span><span class="s1">mergeSizes</span><span class="s3">(</span>
			<span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxInitialSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">),</span>
			<span class="s1">maxSize</span>
		<span class="s3">),</span>
		<span class="s1">minChunks</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">minChunks</span><span class="s3">,</span>
		<span class="s1">maxAsyncRequests</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxAsyncRequests</span><span class="s3">,</span>
		<span class="s1">maxInitialRequests</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxInitialRequests</span><span class="s3">,</span>
		<span class="s1">filename</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">,</span>
		<span class="s1">idHint</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">idHint</span><span class="s3">,</span>
		<span class="s1">automaticNameDelimiter</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">automaticNameDelimiter</span><span class="s3">,</span>
		<span class="s1">reuseExistingChunk</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">reuseExistingChunk</span><span class="s3">,</span>
		<span class="s1">usedExports</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">usedExports</span>
	<span class="s3">};</span>
<span class="s3">};</span>

<span class="s1">module</span><span class="s3">.</span><span class="s1">exports </span><span class="s3">= </span><span class="s4">class </span><span class="s1">SplitChunksPlugin </span><span class="s3">{</span>
	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{OptimizationSplitChunksOptions=} options plugin options</span>
	 <span class="s5">*/</span>
	<span class="s1">constructor</span><span class="s3">(</span><span class="s1">options </span><span class="s3">= {}) {</span>
		<span class="s4">const </span><span class="s1">defaultSizeTypes </span><span class="s3">= </span><span class="s1">options</span><span class="s3">.</span><span class="s1">defaultSizeTypes </span><span class="s3">|| [</span>
			<span class="s2">&quot;javascript&quot;</span><span class="s3">,</span>
			<span class="s2">&quot;unknown&quot;</span>
		<span class="s3">];</span>
		<span class="s4">const </span><span class="s1">fallbackCacheGroup </span><span class="s3">= </span><span class="s1">options</span><span class="s3">.</span><span class="s1">fallbackCacheGroup </span><span class="s3">|| {};</span>
		<span class="s4">const </span><span class="s1">minSize </span><span class="s3">= </span><span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">minSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">minSizeReduction </span><span class="s3">= </span><span class="s1">normalizeSizes</span><span class="s3">(</span>
			<span class="s1">options</span><span class="s3">.</span><span class="s1">minSizeReduction</span><span class="s3">,</span>
			<span class="s1">defaultSizeTypes</span>
		<span class="s3">);</span>
		<span class="s4">const </span><span class="s1">maxSize </span><span class="s3">= </span><span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">);</span>

		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SplitChunksOptions} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">options </span><span class="s3">= {</span>
			<span class="s1">chunksFilter</span><span class="s3">: </span><span class="s1">normalizeChunksFilter</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">chunks </span><span class="s3">|| </span><span class="s2">&quot;all&quot;</span><span class="s3">),</span>
			<span class="s1">defaultSizeTypes</span><span class="s3">,</span>
			<span class="s1">minSize</span><span class="s3">,</span>
			<span class="s1">minSizeReduction</span><span class="s3">,</span>
			<span class="s1">minRemainingSize</span><span class="s3">: </span><span class="s1">mergeSizes</span><span class="s3">(</span>
				<span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">minRemainingSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">),</span>
				<span class="s1">minSize</span>
			<span class="s3">),</span>
			<span class="s1">enforceSizeThreshold</span><span class="s3">: </span><span class="s1">normalizeSizes</span><span class="s3">(</span>
				<span class="s1">options</span><span class="s3">.</span><span class="s1">enforceSizeThreshold</span><span class="s3">,</span>
				<span class="s1">defaultSizeTypes</span>
			<span class="s3">),</span>
			<span class="s1">maxAsyncSize</span><span class="s3">: </span><span class="s1">mergeSizes</span><span class="s3">(</span>
				<span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxAsyncSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">),</span>
				<span class="s1">maxSize</span>
			<span class="s3">),</span>
			<span class="s1">maxInitialSize</span><span class="s3">: </span><span class="s1">mergeSizes</span><span class="s3">(</span>
				<span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxInitialSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">),</span>
				<span class="s1">maxSize</span>
			<span class="s3">),</span>
			<span class="s1">minChunks</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">minChunks </span><span class="s3">|| </span><span class="s7">1</span><span class="s3">,</span>
			<span class="s1">maxAsyncRequests</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxAsyncRequests </span><span class="s3">|| </span><span class="s7">1</span><span class="s3">,</span>
			<span class="s1">maxInitialRequests</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxInitialRequests </span><span class="s3">|| </span><span class="s7">1</span><span class="s3">,</span>
			<span class="s1">hidePathInfo</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">hidePathInfo </span><span class="s3">|| </span><span class="s4">false</span><span class="s3">,</span>
			<span class="s1">filename</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">filename </span><span class="s3">|| </span><span class="s1">undefined</span><span class="s3">,</span>
			<span class="s1">getCacheGroups</span><span class="s3">: </span><span class="s1">normalizeCacheGroups</span><span class="s3">(</span>
				<span class="s1">options</span><span class="s3">.</span><span class="s1">cacheGroups</span><span class="s3">,</span>
				<span class="s1">defaultSizeTypes</span>
			<span class="s3">),</span>
			<span class="s1">getName</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">name </span><span class="s3">? </span><span class="s1">normalizeName</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">name</span><span class="s3">) : </span><span class="s1">defaultGetName</span><span class="s3">,</span>
			<span class="s1">automaticNameDelimiter</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">automaticNameDelimiter</span><span class="s3">,</span>
			<span class="s1">usedExports</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">usedExports</span><span class="s3">,</span>
			<span class="s1">fallbackCacheGroup</span><span class="s3">: {</span>
				<span class="s1">chunksFilter</span><span class="s3">: </span><span class="s1">normalizeChunksFilter</span><span class="s3">(</span>
					<span class="s1">fallbackCacheGroup</span><span class="s3">.</span><span class="s1">chunks </span><span class="s3">|| </span><span class="s1">options</span><span class="s3">.</span><span class="s1">chunks </span><span class="s3">|| </span><span class="s2">&quot;all&quot;</span>
				<span class="s3">),</span>
				<span class="s1">minSize</span><span class="s3">: </span><span class="s1">mergeSizes</span><span class="s3">(</span>
					<span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">fallbackCacheGroup</span><span class="s3">.</span><span class="s1">minSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">),</span>
					<span class="s1">minSize</span>
				<span class="s3">),</span>
				<span class="s1">maxAsyncSize</span><span class="s3">: </span><span class="s1">mergeSizes</span><span class="s3">(</span>
					<span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">fallbackCacheGroup</span><span class="s3">.</span><span class="s1">maxAsyncSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">),</span>
					<span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">fallbackCacheGroup</span><span class="s3">.</span><span class="s1">maxSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">),</span>
					<span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxAsyncSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">),</span>
					<span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">)</span>
				<span class="s3">),</span>
				<span class="s1">maxInitialSize</span><span class="s3">: </span><span class="s1">mergeSizes</span><span class="s3">(</span>
					<span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">fallbackCacheGroup</span><span class="s3">.</span><span class="s1">maxInitialSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">),</span>
					<span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">fallbackCacheGroup</span><span class="s3">.</span><span class="s1">maxSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">),</span>
					<span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxInitialSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">),</span>
					<span class="s1">normalizeSizes</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxSize</span><span class="s3">, </span><span class="s1">defaultSizeTypes</span><span class="s3">)</span>
				<span class="s3">),</span>
				<span class="s1">automaticNameDelimiter</span><span class="s3">:</span>
					<span class="s1">fallbackCacheGroup</span><span class="s3">.</span><span class="s1">automaticNameDelimiter </span><span class="s3">||</span>
					<span class="s1">options</span><span class="s3">.</span><span class="s1">automaticNameDelimiter </span><span class="s3">||</span>
					<span class="s2">&quot;~&quot;</span>
			<span class="s3">}</span>
		<span class="s3">};</span>

		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WeakMap&lt;CacheGroupSource, CacheGroup&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_cacheGroupCache </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{CacheGroupSource} cacheGroupSource source</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{CacheGroup} the cache group (cached)</span>
	 <span class="s5">*/</span>
	<span class="s1">_getCacheGroup</span><span class="s3">(</span><span class="s1">cacheGroupSource</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cacheEntry </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_cacheGroupCache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">cacheGroupSource</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cacheEntry </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">return </span><span class="s1">cacheEntry</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">minSize </span><span class="s3">= </span><span class="s1">mergeSizes</span><span class="s3">(</span>
			<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">minSize</span><span class="s3">,</span>
			<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">enforce </span><span class="s3">? </span><span class="s1">undefined </span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">minSize</span>
		<span class="s3">);</span>
		<span class="s4">const </span><span class="s1">minSizeReduction </span><span class="s3">= </span><span class="s1">mergeSizes</span><span class="s3">(</span>
			<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">minSizeReduction</span><span class="s3">,</span>
			<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">enforce </span><span class="s3">? </span><span class="s1">undefined </span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">minSizeReduction</span>
		<span class="s3">);</span>
		<span class="s4">const </span><span class="s1">minRemainingSize </span><span class="s3">= </span><span class="s1">mergeSizes</span><span class="s3">(</span>
			<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">minRemainingSize</span><span class="s3">,</span>
			<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">enforce </span><span class="s3">? </span><span class="s1">undefined </span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">minRemainingSize</span>
		<span class="s3">);</span>
		<span class="s4">const </span><span class="s1">enforceSizeThreshold </span><span class="s3">= </span><span class="s1">mergeSizes</span><span class="s3">(</span>
			<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">enforceSizeThreshold</span><span class="s3">,</span>
			<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">enforce </span><span class="s3">? </span><span class="s1">undefined </span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">enforceSizeThreshold</span>
		<span class="s3">);</span>
		<span class="s4">const </span><span class="s1">cacheGroup </span><span class="s3">= {</span>
			<span class="s1">key</span><span class="s3">: </span><span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">key</span><span class="s3">,</span>
			<span class="s1">priority</span><span class="s3">: </span><span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">priority </span><span class="s3">|| </span><span class="s7">0</span><span class="s3">,</span>
			<span class="s1">chunksFilter</span><span class="s3">: </span><span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">chunksFilter </span><span class="s3">|| </span><span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">chunksFilter</span><span class="s3">,</span>
			<span class="s1">minSize</span><span class="s3">,</span>
			<span class="s1">minSizeReduction</span><span class="s3">,</span>
			<span class="s1">minRemainingSize</span><span class="s3">,</span>
			<span class="s1">enforceSizeThreshold</span><span class="s3">,</span>
			<span class="s1">maxAsyncSize</span><span class="s3">: </span><span class="s1">mergeSizes</span><span class="s3">(</span>
				<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">maxAsyncSize</span><span class="s3">,</span>
				<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">enforce </span><span class="s3">? </span><span class="s1">undefined </span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxAsyncSize</span>
			<span class="s3">),</span>
			<span class="s1">maxInitialSize</span><span class="s3">: </span><span class="s1">mergeSizes</span><span class="s3">(</span>
				<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">maxInitialSize</span><span class="s3">,</span>
				<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">enforce </span><span class="s3">? </span><span class="s1">undefined </span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxInitialSize</span>
			<span class="s3">),</span>
			<span class="s1">minChunks</span><span class="s3">:</span>
				<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">minChunks </span><span class="s3">!== </span><span class="s1">undefined</span>
					<span class="s3">? </span><span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">minChunks</span>
					<span class="s3">: </span><span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">enforce</span>
					<span class="s3">? </span><span class="s7">1</span>
					<span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">minChunks</span><span class="s3">,</span>
			<span class="s1">maxAsyncRequests</span><span class="s3">:</span>
				<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">maxAsyncRequests </span><span class="s3">!== </span><span class="s1">undefined</span>
					<span class="s3">? </span><span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">maxAsyncRequests</span>
					<span class="s3">: </span><span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">enforce</span>
					<span class="s3">? </span><span class="s1">Infinity</span>
					<span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxAsyncRequests</span><span class="s3">,</span>
			<span class="s1">maxInitialRequests</span><span class="s3">:</span>
				<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">maxInitialRequests </span><span class="s3">!== </span><span class="s1">undefined</span>
					<span class="s3">? </span><span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">maxInitialRequests</span>
					<span class="s3">: </span><span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">enforce</span>
					<span class="s3">? </span><span class="s1">Infinity</span>
					<span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">maxInitialRequests</span><span class="s3">,</span>
			<span class="s1">getName</span><span class="s3">:</span>
				<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">getName </span><span class="s3">!== </span><span class="s1">undefined</span>
					<span class="s3">? </span><span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">getName</span>
					<span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">getName</span><span class="s3">,</span>
			<span class="s1">usedExports</span><span class="s3">:</span>
				<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">usedExports </span><span class="s3">!== </span><span class="s1">undefined</span>
					<span class="s3">? </span><span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">usedExports</span>
					<span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">usedExports</span><span class="s3">,</span>
			<span class="s1">filename</span><span class="s3">:</span>
				<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">filename </span><span class="s3">!== </span><span class="s1">undefined</span>
					<span class="s3">? </span><span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">filename</span>
					<span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">,</span>
			<span class="s1">automaticNameDelimiter</span><span class="s3">:</span>
				<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">automaticNameDelimiter </span><span class="s3">!== </span><span class="s1">undefined</span>
					<span class="s3">? </span><span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">automaticNameDelimiter</span>
					<span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">automaticNameDelimiter</span><span class="s3">,</span>
			<span class="s1">idHint</span><span class="s3">:</span>
				<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">idHint </span><span class="s3">!== </span><span class="s1">undefined</span>
					<span class="s3">? </span><span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">idHint</span>
					<span class="s3">: </span><span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">key</span><span class="s3">,</span>
			<span class="s1">reuseExistingChunk</span><span class="s3">: </span><span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">reuseExistingChunk </span><span class="s3">|| </span><span class="s4">false</span><span class="s3">,</span>
			<span class="s1">_validateSize</span><span class="s3">: </span><span class="s1">hasNonZeroSizes</span><span class="s3">(</span><span class="s1">minSize</span><span class="s3">),</span>
			<span class="s1">_validateRemainingSize</span><span class="s3">: </span><span class="s1">hasNonZeroSizes</span><span class="s3">(</span><span class="s1">minRemainingSize</span><span class="s3">),</span>
			<span class="s1">_minSizeForMaxSize</span><span class="s3">: </span><span class="s1">mergeSizes</span><span class="s3">(</span>
				<span class="s1">cacheGroupSource</span><span class="s3">.</span><span class="s1">minSize</span><span class="s3">,</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">minSize</span>
			<span class="s3">),</span>
			<span class="s1">_conditionalEnforce</span><span class="s3">: </span><span class="s1">hasNonZeroSizes</span><span class="s3">(</span><span class="s1">enforceSizeThreshold</span><span class="s3">)</span>
		<span class="s3">};</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_cacheGroupCache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">cacheGroupSource</span><span class="s3">, </span><span class="s1">cacheGroup</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cacheGroup</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* Apply the plugin</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Compiler} compiler the compiler instance</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">apply</span><span class="s3">(</span><span class="s1">compiler</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cachedMakePathsRelative </span><span class="s3">= </span><span class="s1">makePathsRelative</span><span class="s3">.</span><span class="s1">bindContextCache</span><span class="s3">(</span>
			<span class="s1">compiler</span><span class="s3">.</span><span class="s1">context</span><span class="s3">,</span>
			<span class="s1">compiler</span><span class="s3">.</span><span class="s1">root</span>
		<span class="s3">);</span>
		<span class="s1">compiler</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">thisCompilation</span><span class="s3">.</span><span class="s1">tap</span><span class="s3">(</span><span class="s2">&quot;SplitChunksPlugin&quot;</span><span class="s3">, </span><span class="s1">compilation </span><span class="s3">=&gt; {</span>
			<span class="s4">const </span><span class="s1">logger </span><span class="s3">= </span><span class="s1">compilation</span><span class="s3">.</span><span class="s1">getLogger</span><span class="s3">(</span><span class="s2">&quot;webpack.SplitChunksPlugin&quot;</span><span class="s3">);</span>
			<span class="s4">let </span><span class="s1">alreadyOptimized </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
			<span class="s1">compilation</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">unseal</span><span class="s3">.</span><span class="s1">tap</span><span class="s3">(</span><span class="s2">&quot;SplitChunksPlugin&quot;</span><span class="s3">, () =&gt; {</span>
				<span class="s1">alreadyOptimized </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
			<span class="s3">});</span>
			<span class="s1">compilation</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">optimizeChunks</span><span class="s3">.</span><span class="s1">tap</span><span class="s3">(</span>
				<span class="s3">{</span>
					<span class="s1">name</span><span class="s3">: </span><span class="s2">&quot;SplitChunksPlugin&quot;</span><span class="s3">,</span>
					<span class="s1">stage</span><span class="s3">: </span><span class="s1">STAGE_ADVANCED</span>
				<span class="s3">},</span>
				<span class="s1">chunks </span><span class="s3">=&gt; {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">alreadyOptimized</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
					<span class="s1">alreadyOptimized </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
					<span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;prepare&quot;</span><span class="s3">);</span>
					<span class="s4">const </span><span class="s1">chunkGraph </span><span class="s3">= </span><span class="s1">compilation</span><span class="s3">.</span><span class="s1">chunkGraph</span><span class="s3">;</span>
					<span class="s4">const </span><span class="s1">moduleGraph </span><span class="s3">= </span><span class="s1">compilation</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">;</span>
					<span class="s0">// Give each selected chunk an index (to create strings from chunks)</span>
					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;Chunk, bigint&gt;} */</span>
					<span class="s4">const </span><span class="s1">chunkIndexMap </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
					<span class="s4">const </span><span class="s1">ZERO </span><span class="s3">= </span><span class="s1">BigInt</span><span class="s3">(</span><span class="s2">&quot;0&quot;</span><span class="s3">);</span>
					<span class="s4">const </span><span class="s1">ONE </span><span class="s3">= </span><span class="s1">BigInt</span><span class="s3">(</span><span class="s2">&quot;1&quot;</span><span class="s3">);</span>
					<span class="s4">const </span><span class="s1">START </span><span class="s3">= </span><span class="s1">ONE </span><span class="s3">&lt;&lt; </span><span class="s1">BigInt</span><span class="s3">(</span><span class="s2">&quot;31&quot;</span><span class="s3">);</span>
					<span class="s4">let </span><span class="s1">index </span><span class="s3">= </span><span class="s1">START</span><span class="s3">;</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of chunks</span><span class="s3">) {</span>
						<span class="s1">chunkIndexMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span>
							<span class="s1">chunk</span><span class="s3">,</span>
							<span class="s1">index </span><span class="s3">| </span><span class="s1">BigInt</span><span class="s3">((</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">random</span><span class="s3">() * </span><span class="s7">0x7fffffff</span><span class="s3">) | </span><span class="s7">0</span><span class="s3">)</span>
						<span class="s3">);</span>
						<span class="s1">index </span><span class="s3">= </span><span class="s1">index </span><span class="s3">&lt;&lt; </span><span class="s1">ONE</span><span class="s3">;</span>
					<span class="s3">}</span>
					<span class="s5">/**</span>
					 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Iterable&lt;Chunk&gt;} chunks list of chunks</span>
					 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{bigint | Chunk} key of the chunks</span>
					 <span class="s5">*/</span>
					<span class="s4">const </span><span class="s1">getKey </span><span class="s3">= </span><span class="s1">chunks </span><span class="s3">=&gt; {</span>
						<span class="s4">const </span><span class="s1">iterator </span><span class="s3">= </span><span class="s1">chunks</span><span class="s3">[</span><span class="s1">Symbol</span><span class="s3">.</span><span class="s1">iterator</span><span class="s3">]();</span>
						<span class="s4">let </span><span class="s1">result </span><span class="s3">= </span><span class="s1">iterator</span><span class="s3">.</span><span class="s1">next</span><span class="s3">();</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">result</span><span class="s3">.</span><span class="s1">done</span><span class="s3">) </span><span class="s4">return </span><span class="s1">ZERO</span><span class="s3">;</span>
						<span class="s4">const </span><span class="s1">first </span><span class="s3">= </span><span class="s1">result</span><span class="s3">.</span><span class="s1">value</span><span class="s3">;</span>
						<span class="s1">result </span><span class="s3">= </span><span class="s1">iterator</span><span class="s3">.</span><span class="s1">next</span><span class="s3">();</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">result</span><span class="s3">.</span><span class="s1">done</span><span class="s3">) </span><span class="s4">return </span><span class="s1">first</span><span class="s3">;</span>
						<span class="s4">let </span><span class="s1">key </span><span class="s3">=</span>
							<span class="s1">chunkIndexMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">first</span><span class="s3">) | </span><span class="s1">chunkIndexMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">result</span><span class="s3">.</span><span class="s1">value</span><span class="s3">);</span>
						<span class="s4">while </span><span class="s3">(!(</span><span class="s1">result </span><span class="s3">= </span><span class="s1">iterator</span><span class="s3">.</span><span class="s1">next</span><span class="s3">()).</span><span class="s1">done</span><span class="s3">) {</span>
							<span class="s4">const </span><span class="s1">raw </span><span class="s3">= </span><span class="s1">chunkIndexMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">result</span><span class="s3">.</span><span class="s1">value</span><span class="s3">);</span>
							<span class="s1">key </span><span class="s3">= </span><span class="s1">key </span><span class="s3">^ </span><span class="s1">raw</span><span class="s3">;</span>
						<span class="s3">}</span>
						<span class="s4">return </span><span class="s1">key</span><span class="s3">;</span>
					<span class="s3">};</span>
					<span class="s5">/**</span>
					 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{bigint | Chunk} key key of the chunks</span>
					 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} stringified key</span>
					 <span class="s5">*/</span>
					<span class="s4">const </span><span class="s1">keyToString </span><span class="s3">= </span><span class="s1">key </span><span class="s3">=&gt; {</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">key </span><span class="s3">=== </span><span class="s2">&quot;bigint&quot;</span><span class="s3">) </span><span class="s4">return </span><span class="s1">key</span><span class="s3">.</span><span class="s1">toString</span><span class="s3">(</span><span class="s7">16</span><span class="s3">);</span>
						<span class="s4">return </span><span class="s1">chunkIndexMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">key</span><span class="s3">).</span><span class="s1">toString</span><span class="s3">(</span><span class="s7">16</span><span class="s3">);</span>
					<span class="s3">};</span>

					<span class="s4">const </span><span class="s1">getChunkSetsInGraph </span><span class="s3">= </span><span class="s1">memoize</span><span class="s3">(() =&gt; {</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;bigint, Set&lt;Chunk&gt;&gt;} */</span>
						<span class="s4">const </span><span class="s1">chunkSetsInGraph </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;Chunk&gt;} */</span>
						<span class="s4">const </span><span class="s1">singleChunkSets </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of compilation</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
							<span class="s4">const </span><span class="s1">chunks </span><span class="s3">= </span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getModuleChunksIterable</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
							<span class="s4">const </span><span class="s1">chunksKey </span><span class="s3">= </span><span class="s1">getKey</span><span class="s3">(</span><span class="s1">chunks</span><span class="s3">);</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">chunksKey </span><span class="s3">=== </span><span class="s2">&quot;bigint&quot;</span><span class="s3">) {</span>
								<span class="s4">if </span><span class="s3">(!</span><span class="s1">chunkSetsInGraph</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">chunksKey</span><span class="s3">)) {</span>
									<span class="s1">chunkSetsInGraph</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">chunksKey</span><span class="s3">, </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">chunks</span><span class="s3">));</span>
								<span class="s3">}</span>
							<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
								<span class="s1">singleChunkSets</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">chunksKey</span><span class="s3">);</span>
							<span class="s3">}</span>
						<span class="s3">}</span>
						<span class="s4">return </span><span class="s3">{ </span><span class="s1">chunkSetsInGraph</span><span class="s3">, </span><span class="s1">singleChunkSets </span><span class="s3">};</span>
					<span class="s3">});</span>

					<span class="s5">/**</span>
					 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
					 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Iterable&lt;Chunk[]&gt;} groups of chunks with equal exports</span>
					 <span class="s5">*/</span>
					<span class="s4">const </span><span class="s1">groupChunksByExports </span><span class="s3">= </span><span class="s1">module </span><span class="s3">=&gt; {</span>
						<span class="s4">const </span><span class="s1">exportsInfo </span><span class="s3">= </span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getExportsInfo</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
						<span class="s4">const </span><span class="s1">groupedByUsedExports </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of chunkGraph</span><span class="s3">.</span><span class="s1">getModuleChunksIterable</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
							<span class="s4">const </span><span class="s1">key </span><span class="s3">= </span><span class="s1">exportsInfo</span><span class="s3">.</span><span class="s1">getUsageKey</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">runtime</span><span class="s3">);</span>
							<span class="s4">const </span><span class="s1">list </span><span class="s3">= </span><span class="s1">groupedByUsedExports</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">list </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
								<span class="s1">list</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
							<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
								<span class="s1">groupedByUsedExports</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, [</span><span class="s1">chunk</span><span class="s3">]);</span>
							<span class="s3">}</span>
						<span class="s3">}</span>
						<span class="s4">return </span><span class="s1">groupedByUsedExports</span><span class="s3">.</span><span class="s1">values</span><span class="s3">();</span>
					<span class="s3">};</span>

					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;Module, Iterable&lt;Chunk[]&gt;&gt;} */</span>
					<span class="s4">const </span><span class="s1">groupedByExportsMap </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>

					<span class="s4">const </span><span class="s1">getExportsChunkSetsInGraph </span><span class="s3">= </span><span class="s1">memoize</span><span class="s3">(() =&gt; {</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;bigint, Set&lt;Chunk&gt;&gt;} */</span>
						<span class="s4">const </span><span class="s1">chunkSetsInGraph </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;Chunk&gt;} */</span>
						<span class="s4">const </span><span class="s1">singleChunkSets </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of compilation</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
							<span class="s4">const </span><span class="s1">groupedChunks </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s1">groupChunksByExports</span><span class="s3">(</span><span class="s1">module</span><span class="s3">));</span>
							<span class="s1">groupedByExportsMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">groupedChunks</span><span class="s3">);</span>
							<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunks of groupedChunks</span><span class="s3">) {</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s7">1</span><span class="s3">) {</span>
									<span class="s1">singleChunkSets</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">chunks</span><span class="s3">[</span><span class="s7">0</span><span class="s3">]);</span>
								<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
									<span class="s4">const </span><span class="s1">chunksKey </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{bigint} */ </span><span class="s3">(</span><span class="s1">getKey</span><span class="s3">(</span><span class="s1">chunks</span><span class="s3">));</span>
									<span class="s4">if </span><span class="s3">(!</span><span class="s1">chunkSetsInGraph</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">chunksKey</span><span class="s3">)) {</span>
										<span class="s1">chunkSetsInGraph</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">chunksKey</span><span class="s3">, </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">chunks</span><span class="s3">));</span>
									<span class="s3">}</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
						<span class="s3">}</span>
						<span class="s4">return </span><span class="s3">{ </span><span class="s1">chunkSetsInGraph</span><span class="s3">, </span><span class="s1">singleChunkSets </span><span class="s3">};</span>
					<span class="s3">});</span>

					<span class="s0">// group these set of chunks by count</span>
					<span class="s0">// to allow to check less sets via isSubset</span>
					<span class="s0">// (only smaller sets can be subset)</span>
					<span class="s5">/**</span>
					 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{IterableIterator&lt;Set&lt;Chunk&gt;&gt;} chunkSets set of sets of chunks</span>
					 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Map&lt;number, Array&lt;Set&lt;Chunk&gt;&gt;&gt;} map of sets of chunks by count</span>
					 <span class="s5">*/</span>
					<span class="s4">const </span><span class="s1">groupChunkSetsByCount </span><span class="s3">= </span><span class="s1">chunkSets </span><span class="s3">=&gt; {</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;number, Array&lt;Set&lt;Chunk&gt;&gt;&gt;} */</span>
						<span class="s4">const </span><span class="s1">chunkSetsByCount </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunksSet of chunkSets</span><span class="s3">) {</span>
							<span class="s4">const </span><span class="s1">count </span><span class="s3">= </span><span class="s1">chunksSet</span><span class="s3">.</span><span class="s1">size</span><span class="s3">;</span>
							<span class="s4">let </span><span class="s1">array </span><span class="s3">= </span><span class="s1">chunkSetsByCount</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">count</span><span class="s3">);</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">array </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
								<span class="s1">array </span><span class="s3">= [];</span>
								<span class="s1">chunkSetsByCount</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">count</span><span class="s3">, </span><span class="s1">array</span><span class="s3">);</span>
							<span class="s3">}</span>
							<span class="s1">array</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">chunksSet</span><span class="s3">);</span>
						<span class="s3">}</span>
						<span class="s4">return </span><span class="s1">chunkSetsByCount</span><span class="s3">;</span>
					<span class="s3">};</span>
					<span class="s4">const </span><span class="s1">getChunkSetsByCount </span><span class="s3">= </span><span class="s1">memoize</span><span class="s3">(() =&gt;</span>
						<span class="s1">groupChunkSetsByCount</span><span class="s3">(</span>
							<span class="s1">getChunkSetsInGraph</span><span class="s3">().</span><span class="s1">chunkSetsInGraph</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()</span>
						<span class="s3">)</span>
					<span class="s3">);</span>
					<span class="s4">const </span><span class="s1">getExportsChunkSetsByCount </span><span class="s3">= </span><span class="s1">memoize</span><span class="s3">(() =&gt;</span>
						<span class="s1">groupChunkSetsByCount</span><span class="s3">(</span>
							<span class="s1">getExportsChunkSetsInGraph</span><span class="s3">().</span><span class="s1">chunkSetsInGraph</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()</span>
						<span class="s3">)</span>
					<span class="s3">);</span>

					<span class="s0">// Create a list of possible combinations</span>
					<span class="s4">const </span><span class="s1">createGetCombinations </span><span class="s3">= (</span>
						<span class="s1">chunkSets</span><span class="s3">,</span>
						<span class="s1">singleChunkSets</span><span class="s3">,</span>
						<span class="s1">chunkSetsByCount</span>
					<span class="s3">) =&gt; {</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;bigint | Chunk, (Set&lt;Chunk&gt; | Chunk)[]&gt;} */</span>
						<span class="s4">const </span><span class="s1">combinationsCache </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>

						<span class="s4">return </span><span class="s1">key </span><span class="s3">=&gt; {</span>
							<span class="s4">const </span><span class="s1">cacheEntry </span><span class="s3">= </span><span class="s1">combinationsCache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">cacheEntry </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">return </span><span class="s1">cacheEntry</span><span class="s3">;</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">key </span><span class="s4">instanceof </span><span class="s1">Chunk</span><span class="s3">) {</span>
								<span class="s4">const </span><span class="s1">result </span><span class="s3">= [</span><span class="s1">key</span><span class="s3">];</span>
								<span class="s1">combinationsCache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">result</span><span class="s3">);</span>
								<span class="s4">return </span><span class="s1">result</span><span class="s3">;</span>
							<span class="s3">}</span>
							<span class="s4">const </span><span class="s1">chunksSet </span><span class="s3">= </span><span class="s1">chunkSets</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
							<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{(Set&lt;Chunk&gt; | Chunk)[]} */</span>
							<span class="s4">const </span><span class="s1">array </span><span class="s3">= [</span><span class="s1">chunksSet</span><span class="s3">];</span>
							<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span><span class="s1">count</span><span class="s3">, </span><span class="s1">setArray</span><span class="s3">] </span><span class="s1">of chunkSetsByCount</span><span class="s3">) {</span>
								<span class="s0">// &quot;equal&quot; is not needed because they would have been merge in the first step</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">count </span><span class="s3">&lt; </span><span class="s1">chunksSet</span><span class="s3">.</span><span class="s1">size</span><span class="s3">) {</span>
									<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">set of setArray</span><span class="s3">) {</span>
										<span class="s4">if </span><span class="s3">(</span><span class="s1">isSubset</span><span class="s3">(</span><span class="s1">chunksSet</span><span class="s3">, </span><span class="s1">set</span><span class="s3">)) {</span>
											<span class="s1">array</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">set</span><span class="s3">);</span>
										<span class="s3">}</span>
									<span class="s3">}</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
							<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of singleChunkSets</span><span class="s3">) {</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">chunksSet</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">)) {</span>
									<span class="s1">array</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
							<span class="s1">combinationsCache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">array</span><span class="s3">);</span>
							<span class="s4">return </span><span class="s1">array</span><span class="s3">;</span>
						<span class="s3">};</span>
					<span class="s3">};</span>

					<span class="s4">const </span><span class="s1">getCombinationsFactory </span><span class="s3">= </span><span class="s1">memoize</span><span class="s3">(() =&gt; {</span>
						<span class="s4">const </span><span class="s3">{ </span><span class="s1">chunkSetsInGraph</span><span class="s3">, </span><span class="s1">singleChunkSets </span><span class="s3">} = </span><span class="s1">getChunkSetsInGraph</span><span class="s3">();</span>
						<span class="s4">return </span><span class="s1">createGetCombinations</span><span class="s3">(</span>
							<span class="s1">chunkSetsInGraph</span><span class="s3">,</span>
							<span class="s1">singleChunkSets</span><span class="s3">,</span>
							<span class="s1">getChunkSetsByCount</span><span class="s3">()</span>
						<span class="s3">);</span>
					<span class="s3">});</span>
					<span class="s4">const </span><span class="s1">getCombinations </span><span class="s3">= </span><span class="s1">key </span><span class="s3">=&gt; </span><span class="s1">getCombinationsFactory</span><span class="s3">()(</span><span class="s1">key</span><span class="s3">);</span>

					<span class="s4">const </span><span class="s1">getExportsCombinationsFactory </span><span class="s3">= </span><span class="s1">memoize</span><span class="s3">(() =&gt; {</span>
						<span class="s4">const </span><span class="s3">{ </span><span class="s1">chunkSetsInGraph</span><span class="s3">, </span><span class="s1">singleChunkSets </span><span class="s3">} =</span>
							<span class="s1">getExportsChunkSetsInGraph</span><span class="s3">();</span>
						<span class="s4">return </span><span class="s1">createGetCombinations</span><span class="s3">(</span>
							<span class="s1">chunkSetsInGraph</span><span class="s3">,</span>
							<span class="s1">singleChunkSets</span><span class="s3">,</span>
							<span class="s1">getExportsChunkSetsByCount</span><span class="s3">()</span>
						<span class="s3">);</span>
					<span class="s3">});</span>
					<span class="s4">const </span><span class="s1">getExportsCombinations </span><span class="s3">= </span><span class="s1">key </span><span class="s3">=&gt;</span>
						<span class="s1">getExportsCombinationsFactory</span><span class="s3">()(</span><span class="s1">key</span><span class="s3">);</span>

					<span class="s5">/**</span>
					 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} SelectedChunksResult</span>
					 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Chunk[]} chunks the list of chunks</span>
					 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{bigint | Chunk} key a key of the list</span>
					 <span class="s5">*/</span>

					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WeakMap&lt;Set&lt;Chunk&gt; | Chunk, WeakMap&lt;ChunkFilterFunction, SelectedChunksResult&gt;&gt;} */</span>
					<span class="s4">const </span><span class="s1">selectedChunksCacheByChunksSet </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>

					<span class="s5">/**</span>
					 <span class="s5">* get list and key by applying the filter function to the list</span>
					 <span class="s5">* It is cached for performance reasons</span>
					 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Set&lt;Chunk&gt; | Chunk} chunks list of chunks</span>
					 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunkFilterFunction} chunkFilter filter function for chunks</span>
					 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{SelectedChunksResult} list and key</span>
					 <span class="s5">*/</span>
					<span class="s4">const </span><span class="s1">getSelectedChunks </span><span class="s3">= (</span><span class="s1">chunks</span><span class="s3">, </span><span class="s1">chunkFilter</span><span class="s3">) =&gt; {</span>
						<span class="s4">let </span><span class="s1">entry </span><span class="s3">= </span><span class="s1">selectedChunksCacheByChunksSet</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">chunks</span><span class="s3">);</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">entry </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
							<span class="s1">entry </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>
							<span class="s1">selectedChunksCacheByChunksSet</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">chunks</span><span class="s3">, </span><span class="s1">entry</span><span class="s3">);</span>
						<span class="s3">}</span>
						<span class="s4">let </span><span class="s1">entry2 </span><span class="s3">=</span>
							<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SelectedChunksResult} */</span>
							<span class="s3">(</span><span class="s1">entry</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">chunkFilter</span><span class="s3">));</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">entry2 </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
							<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Chunk[]} */</span>
							<span class="s4">const </span><span class="s1">selectedChunks </span><span class="s3">= [];</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">chunks </span><span class="s4">instanceof </span><span class="s1">Chunk</span><span class="s3">) {</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">chunkFilter</span><span class="s3">(</span><span class="s1">chunks</span><span class="s3">)) </span><span class="s1">selectedChunks</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">chunks</span><span class="s3">);</span>
							<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
								<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of chunks</span><span class="s3">) {</span>
									<span class="s4">if </span><span class="s3">(</span><span class="s1">chunkFilter</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">)) </span><span class="s1">selectedChunks</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
							<span class="s1">entry2 </span><span class="s3">= {</span>
								<span class="s1">chunks</span><span class="s3">: </span><span class="s1">selectedChunks</span><span class="s3">,</span>
								<span class="s1">key</span><span class="s3">: </span><span class="s1">getKey</span><span class="s3">(</span><span class="s1">selectedChunks</span><span class="s3">)</span>
							<span class="s3">};</span>
							<span class="s1">entry</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">chunkFilter</span><span class="s3">, </span><span class="s1">entry2</span><span class="s3">);</span>
						<span class="s3">}</span>
						<span class="s4">return </span><span class="s1">entry2</span><span class="s3">;</span>
					<span class="s3">};</span>

					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, boolean&gt;} */</span>
					<span class="s4">const </span><span class="s1">alreadyValidatedParents </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;string&gt;} */</span>
					<span class="s4">const </span><span class="s1">alreadyReportedErrors </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>

					<span class="s0">// Map a list of chunks to a list of modules</span>
					<span class="s0">// For the key the chunk &quot;index&quot; is used, the value is a SortableSet of modules</span>
					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, ChunksInfoItem&gt;} */</span>
					<span class="s4">const </span><span class="s1">chunksInfoMap </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>

					<span class="s5">/**</span>
					 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{CacheGroup} cacheGroup the current cache group</span>
					 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} cacheGroupIndex the index of the cache group of ordering</span>
					 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk[]} selectedChunks chunks selected for this module</span>
					 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{bigint | Chunk} selectedChunksKey a key of selectedChunks</span>
					 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the current module</span>
					 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
					 <span class="s5">*/</span>
					<span class="s4">const </span><span class="s1">addModuleToChunksInfoMap </span><span class="s3">= (</span>
						<span class="s1">cacheGroup</span><span class="s3">,</span>
						<span class="s1">cacheGroupIndex</span><span class="s3">,</span>
						<span class="s1">selectedChunks</span><span class="s3">,</span>
						<span class="s1">selectedChunksKey</span><span class="s3">,</span>
						<span class="s1">module</span>
					<span class="s3">) =&gt; {</span>
						<span class="s0">// Break if minimum number of chunks is not reached</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">selectedChunks</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&lt; </span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">minChunks</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
						<span class="s0">// Determine name for split chunk</span>
						<span class="s4">const </span><span class="s1">name </span><span class="s3">=</span>
							<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */</span>
							<span class="s3">(</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">getName</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">selectedChunks</span><span class="s3">, </span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">key</span><span class="s3">));</span>
						<span class="s0">// Check if the name is ok</span>
						<span class="s4">const </span><span class="s1">existingChunk </span><span class="s3">= </span><span class="s1">compilation</span><span class="s3">.</span><span class="s1">namedChunks</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">existingChunk</span><span class="s3">) {</span>
							<span class="s4">const </span><span class="s1">parentValidationKey </span><span class="s3">= </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">|</span><span class="s1">$</span><span class="s3">{</span>
								<span class="s4">typeof </span><span class="s1">selectedChunksKey </span><span class="s3">=== </span><span class="s2">&quot;bigint&quot;</span>
									<span class="s3">? </span><span class="s1">selectedChunksKey</span>
									<span class="s3">: </span><span class="s1">selectedChunksKey</span><span class="s3">.</span><span class="s1">debugId</span>
							<span class="s3">}</span><span class="s2">`</span><span class="s3">;</span>
							<span class="s4">const </span><span class="s1">valid </span><span class="s3">= </span><span class="s1">alreadyValidatedParents</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">parentValidationKey</span><span class="s3">);</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">valid </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">valid </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
								<span class="s0">// Module can only be moved into the existing chunk if the existing chunk</span>
								<span class="s0">// is a parent of all selected chunks</span>
								<span class="s4">let </span><span class="s1">isInAllParents </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
								<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;ChunkGroup&gt;} */</span>
								<span class="s4">const </span><span class="s1">queue </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
								<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of selectedChunks</span><span class="s3">) {</span>
									<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">group of chunk</span><span class="s3">.</span><span class="s1">groupsIterable</span><span class="s3">) {</span>
										<span class="s1">queue</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">group</span><span class="s3">);</span>
									<span class="s3">}</span>
								<span class="s3">}</span>
								<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">group of queue</span><span class="s3">) {</span>
									<span class="s4">if </span><span class="s3">(</span><span class="s1">existingChunk</span><span class="s3">.</span><span class="s1">isInGroup</span><span class="s3">(</span><span class="s1">group</span><span class="s3">)) </span><span class="s4">continue</span><span class="s3">;</span>
									<span class="s4">let </span><span class="s1">hasParent </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
									<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">parent of group</span><span class="s3">.</span><span class="s1">parentsIterable</span><span class="s3">) {</span>
										<span class="s1">hasParent </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
										<span class="s1">queue</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">);</span>
									<span class="s3">}</span>
									<span class="s4">if </span><span class="s3">(!</span><span class="s1">hasParent</span><span class="s3">) {</span>
										<span class="s1">isInAllParents </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
									<span class="s3">}</span>
								<span class="s3">}</span>
								<span class="s4">const </span><span class="s1">valid </span><span class="s3">= </span><span class="s1">isInAllParents</span><span class="s3">;</span>
								<span class="s1">alreadyValidatedParents</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">parentValidationKey</span><span class="s3">, </span><span class="s1">valid</span><span class="s3">);</span>
								<span class="s4">if </span><span class="s3">(!</span><span class="s1">valid</span><span class="s3">) {</span>
									<span class="s4">if </span><span class="s3">(!</span><span class="s1">alreadyReportedErrors</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)) {</span>
										<span class="s1">alreadyReportedErrors</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
										<span class="s1">compilation</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span>
											<span class="s4">new </span><span class="s1">WebpackError</span><span class="s3">(</span>
												<span class="s2">&quot;SplitChunksPlugin</span><span class="s4">\n</span><span class="s2">&quot; </span><span class="s3">+</span>
													<span class="s2">`Cache group &quot;</span><span class="s1">$</span><span class="s3">{</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">key</span><span class="s3">}</span><span class="s2">&quot; conflicts with existing chunk.</span><span class="s4">\n</span><span class="s2">` </span><span class="s3">+</span>
													<span class="s2">`Both have the same name &quot;</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">&quot; and existing chunk is not a parent of the selected modules.</span><span class="s4">\n</span><span class="s2">` </span><span class="s3">+</span>
													<span class="s2">&quot;Use a different name for the cache group or make sure that the existing chunk is a parent (e. g. via dependOn).</span><span class="s4">\n</span><span class="s2">&quot; </span><span class="s3">+</span>
													<span class="s2">'HINT: You can omit &quot;name&quot; to automatically create a name.</span><span class="s4">\n</span><span class="s2">' </span><span class="s3">+</span>
													<span class="s2">&quot;BREAKING CHANGE: webpack &lt; 5 used to allow to use an entrypoint as splitChunk. &quot; </span><span class="s3">+</span>
													<span class="s2">&quot;This is no longer allowed when the entrypoint is not a parent of the selected modules.</span><span class="s4">\n</span><span class="s2">&quot; </span><span class="s3">+</span>
													<span class="s2">&quot;Remove this entrypoint and add modules to cache group's 'test' instead. &quot; </span><span class="s3">+</span>
													<span class="s2">&quot;If you need modules to be evaluated on startup, add them to the existing entrypoints (make them arrays). &quot; </span><span class="s3">+</span>
													<span class="s2">&quot;See migration guide of more info.&quot;</span>
											<span class="s3">)</span>
										<span class="s3">);</span>
									<span class="s3">}</span>
									<span class="s4">return</span><span class="s3">;</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
						<span class="s3">}</span>
						<span class="s0">// Create key for maps</span>
						<span class="s0">// When it has a name we use the name as key</span>
						<span class="s0">// Otherwise we create the key from chunks and cache group key</span>
						<span class="s0">// This automatically merges equal names</span>
						<span class="s4">const </span><span class="s1">key </span><span class="s3">=</span>
							<span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">key </span><span class="s3">+</span>
							<span class="s3">(</span><span class="s1">name</span>
								<span class="s3">? </span><span class="s2">` name:</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">`</span>
								<span class="s3">: </span><span class="s2">` chunks:</span><span class="s1">$</span><span class="s3">{</span><span class="s1">keyToString</span><span class="s3">(</span><span class="s1">selectedChunksKey</span><span class="s3">)}</span><span class="s2">`</span><span class="s3">);</span>
						<span class="s0">// Add module to maps</span>
						<span class="s4">let </span><span class="s1">info </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ChunksInfoItem} */ </span><span class="s3">(</span><span class="s1">chunksInfoMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">key</span><span class="s3">));</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">info </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
							<span class="s1">chunksInfoMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span>
								<span class="s1">key</span><span class="s3">,</span>
								<span class="s3">(</span><span class="s1">info </span><span class="s3">= {</span>
									<span class="s1">modules</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SortableSet</span><span class="s3">(</span>
										<span class="s1">undefined</span><span class="s3">,</span>
										<span class="s1">compareModulesByIdentifier</span>
									<span class="s3">),</span>
									<span class="s1">cacheGroup</span><span class="s3">,</span>
									<span class="s1">cacheGroupIndex</span><span class="s3">,</span>
									<span class="s1">name</span><span class="s3">,</span>
									<span class="s1">sizes</span><span class="s3">: {},</span>
									<span class="s1">chunks</span><span class="s3">: </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(),</span>
									<span class="s1">reuseableChunks</span><span class="s3">: </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(),</span>
									<span class="s1">chunksKeys</span><span class="s3">: </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">()</span>
								<span class="s3">})</span>
							<span class="s3">);</span>
						<span class="s3">}</span>
						<span class="s4">const </span><span class="s1">oldSize </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size</span><span class="s3">;</span>
						<span class="s1">info</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size </span><span class="s3">!== </span><span class="s1">oldSize</span><span class="s3">) {</span>
							<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">type of module</span><span class="s3">.</span><span class="s1">getSourceTypes</span><span class="s3">()) {</span>
								<span class="s1">info</span><span class="s3">.</span><span class="s1">sizes</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] = (</span><span class="s1">info</span><span class="s3">.</span><span class="s1">sizes</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] || </span><span class="s7">0</span><span class="s3">) + </span><span class="s1">module</span><span class="s3">.</span><span class="s1">size</span><span class="s3">(</span><span class="s1">type</span><span class="s3">);</span>
							<span class="s3">}</span>
						<span class="s3">}</span>
						<span class="s4">const </span><span class="s1">oldChunksKeysSize </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">chunksKeys</span><span class="s3">.</span><span class="s1">size</span><span class="s3">;</span>
						<span class="s1">info</span><span class="s3">.</span><span class="s1">chunksKeys</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">selectedChunksKey</span><span class="s3">);</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">oldChunksKeysSize </span><span class="s3">!== </span><span class="s1">info</span><span class="s3">.</span><span class="s1">chunksKeys</span><span class="s3">.</span><span class="s1">size</span><span class="s3">) {</span>
							<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of selectedChunks</span><span class="s3">) {</span>
								<span class="s1">info</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
							<span class="s3">}</span>
						<span class="s3">}</span>
					<span class="s3">};</span>

					<span class="s4">const </span><span class="s1">context </span><span class="s3">= {</span>
						<span class="s1">moduleGraph</span><span class="s3">,</span>
						<span class="s1">chunkGraph</span>
					<span class="s3">};</span>

					<span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;prepare&quot;</span><span class="s3">);</span>

					<span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;modules&quot;</span><span class="s3">);</span>

					<span class="s0">// Walk through all modules</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of compilation</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
						<span class="s0">// Get cache group</span>
						<span class="s4">let </span><span class="s1">cacheGroups </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">getCacheGroups</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
						<span class="s4">if </span><span class="s3">(!</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">cacheGroups</span><span class="s3">) || </span><span class="s1">cacheGroups</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) {</span>
							<span class="s4">continue</span><span class="s3">;</span>
						<span class="s3">}</span>

						<span class="s0">// Prepare some values (usedExports = false)</span>
						<span class="s4">const </span><span class="s1">getCombs </span><span class="s3">= </span><span class="s1">memoize</span><span class="s3">(() =&gt; {</span>
							<span class="s4">const </span><span class="s1">chunks </span><span class="s3">= </span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getModuleChunksIterable</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
							<span class="s4">const </span><span class="s1">chunksKey </span><span class="s3">= </span><span class="s1">getKey</span><span class="s3">(</span><span class="s1">chunks</span><span class="s3">);</span>
							<span class="s4">return </span><span class="s1">getCombinations</span><span class="s3">(</span><span class="s1">chunksKey</span><span class="s3">);</span>
						<span class="s3">});</span>

						<span class="s0">// Prepare some values (usedExports = true)</span>
						<span class="s4">const </span><span class="s1">getCombsByUsedExports </span><span class="s3">= </span><span class="s1">memoize</span><span class="s3">(() =&gt; {</span>
							<span class="s0">// fill the groupedByExportsMap</span>
							<span class="s1">getExportsChunkSetsInGraph</span><span class="s3">();</span>
							<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;Set&lt;Chunk&gt; | Chunk&gt;} */</span>
							<span class="s4">const </span><span class="s1">set </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
							<span class="s4">const </span><span class="s1">groupedByUsedExports </span><span class="s3">=</span>
								<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Iterable&lt;Chunk[]&gt;} */</span>
								<span class="s3">(</span><span class="s1">groupedByExportsMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">));</span>
							<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunks of groupedByUsedExports</span><span class="s3">) {</span>
								<span class="s4">const </span><span class="s1">chunksKey </span><span class="s3">= </span><span class="s1">getKey</span><span class="s3">(</span><span class="s1">chunks</span><span class="s3">);</span>
								<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">comb of getExportsCombinations</span><span class="s3">(</span><span class="s1">chunksKey</span><span class="s3">))</span>
									<span class="s1">set</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">comb</span><span class="s3">);</span>
							<span class="s3">}</span>
							<span class="s4">return </span><span class="s1">set</span><span class="s3">;</span>
						<span class="s3">});</span>

						<span class="s4">let </span><span class="s1">cacheGroupIndex </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">cacheGroupSource of cacheGroups</span><span class="s3">) {</span>
							<span class="s4">const </span><span class="s1">cacheGroup </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getCacheGroup</span><span class="s3">(</span><span class="s1">cacheGroupSource</span><span class="s3">);</span>

							<span class="s4">const </span><span class="s1">combs </span><span class="s3">= </span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">usedExports</span>
								<span class="s3">? </span><span class="s1">getCombsByUsedExports</span><span class="s3">()</span>
								<span class="s3">: </span><span class="s1">getCombs</span><span class="s3">();</span>
							<span class="s0">// For all combination of chunk selection</span>
							<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunkCombination of combs</span><span class="s3">) {</span>
								<span class="s0">// Break if minimum number of chunks is not reached</span>
								<span class="s4">const </span><span class="s1">count </span><span class="s3">=</span>
									<span class="s1">chunkCombination </span><span class="s4">instanceof </span><span class="s1">Chunk </span><span class="s3">? </span><span class="s7">1 </span><span class="s3">: </span><span class="s1">chunkCombination</span><span class="s3">.</span><span class="s1">size</span><span class="s3">;</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">count </span><span class="s3">&lt; </span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">minChunks</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
								<span class="s0">// Select chunks by configuration</span>
								<span class="s4">const </span><span class="s3">{ </span><span class="s1">chunks</span><span class="s3">: </span><span class="s1">selectedChunks</span><span class="s3">, </span><span class="s1">key</span><span class="s3">: </span><span class="s1">selectedChunksKey </span><span class="s3">} =</span>
									<span class="s1">getSelectedChunks</span><span class="s3">(</span>
										<span class="s1">chunkCombination</span><span class="s3">,</span>
										<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ChunkFilterFunction} */ </span><span class="s3">(</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">chunksFilter</span><span class="s3">)</span>
									<span class="s3">);</span>

								<span class="s1">addModuleToChunksInfoMap</span><span class="s3">(</span>
									<span class="s1">cacheGroup</span><span class="s3">,</span>
									<span class="s1">cacheGroupIndex</span><span class="s3">,</span>
									<span class="s1">selectedChunks</span><span class="s3">,</span>
									<span class="s1">selectedChunksKey</span><span class="s3">,</span>
									<span class="s1">module</span>
								<span class="s3">);</span>
							<span class="s3">}</span>
							<span class="s1">cacheGroupIndex</span><span class="s3">++;</span>
						<span class="s3">}</span>
					<span class="s3">}</span>

					<span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;modules&quot;</span><span class="s3">);</span>

					<span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;queue&quot;</span><span class="s3">);</span>

					<span class="s5">/**</span>
					 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunksInfoItem} info entry</span>
					 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string[]} sourceTypes source types to be removed</span>
					 <span class="s5">*/</span>
					<span class="s4">const </span><span class="s1">removeModulesWithSourceType </span><span class="s3">= (</span><span class="s1">info</span><span class="s3">, </span><span class="s1">sourceTypes</span><span class="s3">) =&gt; {</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of info</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
							<span class="s4">const </span><span class="s1">types </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">getSourceTypes</span><span class="s3">();</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">sourceTypes</span><span class="s3">.</span><span class="s1">some</span><span class="s3">(</span><span class="s1">type </span><span class="s3">=&gt; </span><span class="s1">types</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">type</span><span class="s3">))) {</span>
								<span class="s1">info</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
								<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">type of types</span><span class="s3">) {</span>
									<span class="s1">info</span><span class="s3">.</span><span class="s1">sizes</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] -= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">size</span><span class="s3">(</span><span class="s1">type</span><span class="s3">);</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
						<span class="s3">}</span>
					<span class="s3">};</span>

					<span class="s5">/**</span>
					 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunksInfoItem} info entry</span>
					 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true, if entry become empty</span>
					 <span class="s5">*/</span>
					<span class="s4">const </span><span class="s1">removeMinSizeViolatingModules </span><span class="s3">= </span><span class="s1">info </span><span class="s3">=&gt; {</span>
						<span class="s4">if </span><span class="s3">(!</span><span class="s1">info</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">_validateSize</span><span class="s3">) </span><span class="s4">return false</span><span class="s3">;</span>
						<span class="s4">const </span><span class="s1">violatingSizes </span><span class="s3">= </span><span class="s1">getViolatingMinSizes</span><span class="s3">(</span>
							<span class="s1">info</span><span class="s3">.</span><span class="s1">sizes</span><span class="s3">,</span>
							<span class="s1">info</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">minSize</span>
						<span class="s3">);</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">violatingSizes </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">return false</span><span class="s3">;</span>
						<span class="s1">removeModulesWithSourceType</span><span class="s3">(</span><span class="s1">info</span><span class="s3">, </span><span class="s1">violatingSizes</span><span class="s3">);</span>
						<span class="s4">return </span><span class="s1">info</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">;</span>
					<span class="s3">};</span>

					<span class="s0">// Filter items were size &lt; minSize</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span><span class="s1">key</span><span class="s3">, </span><span class="s1">info</span><span class="s3">] </span><span class="s1">of chunksInfoMap</span><span class="s3">) {</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">removeMinSizeViolatingModules</span><span class="s3">(</span><span class="s1">info</span><span class="s3">)) {</span>
							<span class="s1">chunksInfoMap</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
						<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span>
							<span class="s3">!</span><span class="s1">checkMinSizeReduction</span><span class="s3">(</span>
								<span class="s1">info</span><span class="s3">.</span><span class="s1">sizes</span><span class="s3">,</span>
								<span class="s1">info</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">minSizeReduction</span><span class="s3">,</span>
								<span class="s1">info</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">size</span>
							<span class="s3">)</span>
						<span class="s3">) {</span>
							<span class="s1">chunksInfoMap</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">}</span>

					<span class="s5">/**</span>
					 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} MaxSizeQueueItem</span>
					 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} minSize</span>
					 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} maxAsyncSize</span>
					 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SplitChunksSizes} maxInitialSize</span>
					 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} automaticNameDelimiter</span>
					 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string[]} keys</span>
					 <span class="s5">*/</span>

					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;Chunk, MaxSizeQueueItem&gt;} */</span>
					<span class="s4">const </span><span class="s1">maxSizeQueueMap </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>

					<span class="s4">while </span><span class="s3">(</span><span class="s1">chunksInfoMap</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
						<span class="s0">// Find best matching entry</span>
						<span class="s4">let </span><span class="s1">bestEntryKey</span><span class="s3">;</span>
						<span class="s4">let </span><span class="s1">bestEntry</span><span class="s3">;</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">pair of chunksInfoMap</span><span class="s3">) {</span>
							<span class="s4">const </span><span class="s1">key </span><span class="s3">= </span><span class="s1">pair</span><span class="s3">[</span><span class="s7">0</span><span class="s3">];</span>
							<span class="s4">const </span><span class="s1">info </span><span class="s3">= </span><span class="s1">pair</span><span class="s3">[</span><span class="s7">1</span><span class="s3">];</span>
							<span class="s4">if </span><span class="s3">(</span>
								<span class="s1">bestEntry </span><span class="s3">=== </span><span class="s1">undefined </span><span class="s3">||</span>
								<span class="s1">compareEntries</span><span class="s3">(</span><span class="s1">bestEntry</span><span class="s3">, </span><span class="s1">info</span><span class="s3">) &lt; </span><span class="s7">0</span>
							<span class="s3">) {</span>
								<span class="s1">bestEntry </span><span class="s3">= </span><span class="s1">info</span><span class="s3">;</span>
								<span class="s1">bestEntryKey </span><span class="s3">= </span><span class="s1">key</span><span class="s3">;</span>
							<span class="s3">}</span>
						<span class="s3">}</span>

						<span class="s4">const </span><span class="s1">item </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ChunksInfoItem} */ </span><span class="s3">(</span><span class="s1">bestEntry</span><span class="s3">);</span>
						<span class="s1">chunksInfoMap</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */ </span><span class="s3">(</span><span class="s1">bestEntryKey</span><span class="s3">));</span>

						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Chunk[&quot;name&quot;] | undefined} */</span>
						<span class="s4">let </span><span class="s1">chunkName </span><span class="s3">= </span><span class="s1">item</span><span class="s3">.</span><span class="s1">name</span><span class="s3">;</span>
						<span class="s0">// Variable for the new chunk (lazy created)</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Chunk | undefined} */</span>
						<span class="s4">let </span><span class="s1">newChunk</span><span class="s3">;</span>
						<span class="s0">// When no chunk name, check if we can reuse a chunk instead of creating a new one</span>
						<span class="s4">let </span><span class="s1">isExistingChunk </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
						<span class="s4">let </span><span class="s1">isReusedWithAllModules </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">chunkName</span><span class="s3">) {</span>
							<span class="s4">const </span><span class="s1">chunkByName </span><span class="s3">= </span><span class="s1">compilation</span><span class="s3">.</span><span class="s1">namedChunks</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">chunkName</span><span class="s3">);</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">chunkByName </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
								<span class="s1">newChunk </span><span class="s3">= </span><span class="s1">chunkByName</span><span class="s3">;</span>
								<span class="s4">const </span><span class="s1">oldSize </span><span class="s3">= </span><span class="s1">item</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">size</span><span class="s3">;</span>
								<span class="s1">item</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">newChunk</span><span class="s3">);</span>
								<span class="s1">isExistingChunk </span><span class="s3">= </span><span class="s1">item</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">size </span><span class="s3">!== </span><span class="s1">oldSize</span><span class="s3">;</span>
							<span class="s3">}</span>
						<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">reuseExistingChunk</span><span class="s3">) {</span>
							<span class="s1">outer</span><span class="s3">: </span><span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of item</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">) {</span>
								<span class="s4">if </span><span class="s3">(</span>
									<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getNumberOfChunkModules</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) !==</span>
									<span class="s1">item</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size</span>
								<span class="s3">) {</span>
									<span class="s4">continue</span><span class="s3">;</span>
								<span class="s3">}</span>
								<span class="s4">if </span><span class="s3">(</span>
									<span class="s1">item</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s7">1 </span><span class="s3">&amp;&amp;</span>
									<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getNumberOfEntryModules</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) &gt; </span><span class="s7">0</span>
								<span class="s3">) {</span>
									<span class="s4">continue</span><span class="s3">;</span>
								<span class="s3">}</span>
								<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of item</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
									<span class="s4">if </span><span class="s3">(!</span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">isModuleInChunk</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">)) {</span>
										<span class="s4">continue </span><span class="s1">outer</span><span class="s3">;</span>
									<span class="s3">}</span>
								<span class="s3">}</span>
								<span class="s4">if </span><span class="s3">(!</span><span class="s1">newChunk </span><span class="s3">|| !</span><span class="s1">newChunk</span><span class="s3">.</span><span class="s1">name</span><span class="s3">) {</span>
									<span class="s1">newChunk </span><span class="s3">= </span><span class="s1">chunk</span><span class="s3">;</span>
								<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span>
									<span class="s1">chunk</span><span class="s3">.</span><span class="s1">name </span><span class="s3">&amp;&amp;</span>
									<span class="s1">chunk</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&lt; </span><span class="s1">newChunk</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">length</span>
								<span class="s3">) {</span>
									<span class="s1">newChunk </span><span class="s3">= </span><span class="s1">chunk</span><span class="s3">;</span>
								<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span>
									<span class="s1">chunk</span><span class="s3">.</span><span class="s1">name </span><span class="s3">&amp;&amp;</span>
									<span class="s1">chunk</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s1">newChunk</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&amp;&amp;</span>
									<span class="s1">chunk</span><span class="s3">.</span><span class="s1">name </span><span class="s3">&lt; </span><span class="s1">newChunk</span><span class="s3">.</span><span class="s1">name</span>
								<span class="s3">) {</span>
									<span class="s1">newChunk </span><span class="s3">= </span><span class="s1">chunk</span><span class="s3">;</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">newChunk</span><span class="s3">) {</span>
								<span class="s1">item</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">newChunk</span><span class="s3">);</span>
								<span class="s1">chunkName </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
								<span class="s1">isExistingChunk </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
								<span class="s1">isReusedWithAllModules </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
							<span class="s3">}</span>
						<span class="s3">}</span>

						<span class="s4">const </span><span class="s1">enforced </span><span class="s3">=</span>
							<span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">_conditionalEnforce </span><span class="s3">&amp;&amp;</span>
							<span class="s1">checkMinSize</span><span class="s3">(</span><span class="s1">item</span><span class="s3">.</span><span class="s1">sizes</span><span class="s3">, </span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">enforceSizeThreshold</span><span class="s3">);</span>

						<span class="s4">const </span><span class="s1">usedChunks </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">item</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">);</span>

						<span class="s0">// Check if maxRequests condition can be fulfilled</span>
						<span class="s4">if </span><span class="s3">(</span>
							<span class="s3">!</span><span class="s1">enforced </span><span class="s3">&amp;&amp;</span>
							<span class="s3">(</span><span class="s1">Number</span><span class="s3">.</span><span class="s1">isFinite</span><span class="s3">(</span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">maxInitialRequests</span><span class="s3">) ||</span>
								<span class="s1">Number</span><span class="s3">.</span><span class="s1">isFinite</span><span class="s3">(</span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">maxAsyncRequests</span><span class="s3">))</span>
						<span class="s3">) {</span>
							<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of usedChunks</span><span class="s3">) {</span>
								<span class="s0">// respect max requests</span>
								<span class="s4">const </span><span class="s1">maxRequests </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{number} */ </span><span class="s3">(</span>
									<span class="s1">chunk</span><span class="s3">.</span><span class="s1">isOnlyInitial</span><span class="s3">()</span>
										<span class="s3">? </span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">maxInitialRequests</span>
										<span class="s3">: </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">canBeInitial</span><span class="s3">()</span>
										<span class="s3">? </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span>
												<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{number} */</span>
												<span class="s3">(</span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">maxInitialRequests</span><span class="s3">),</span>
												<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{number} */</span>
												<span class="s3">(</span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">maxAsyncRequests</span><span class="s3">)</span>
										  <span class="s3">)</span>
										<span class="s3">: </span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">maxAsyncRequests</span>
								<span class="s3">);</span>
								<span class="s4">if </span><span class="s3">(</span>
									<span class="s1">isFinite</span><span class="s3">(</span><span class="s1">maxRequests</span><span class="s3">) &amp;&amp;</span>
									<span class="s1">getRequests</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) &gt;= </span><span class="s1">maxRequests</span>
								<span class="s3">) {</span>
									<span class="s1">usedChunks</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
						<span class="s3">}</span>

						<span class="s1">outer</span><span class="s3">: </span><span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of usedChunks</span><span class="s3">) {</span>
							<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of item</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">isModuleInChunk</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">)) </span><span class="s4">continue </span><span class="s1">outer</span><span class="s3">;</span>
							<span class="s3">}</span>
							<span class="s1">usedChunks</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
						<span class="s3">}</span>

						<span class="s0">// Were some (invalid) chunks removed from usedChunks?</span>
						<span class="s0">// =&gt; readd all modules to the queue, as things could have been changed</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">usedChunks</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&lt; </span><span class="s1">item</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">size</span><span class="s3">) {</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">isExistingChunk</span><span class="s3">)</span>
								<span class="s1">usedChunks</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Chunk} */ </span><span class="s3">(</span><span class="s1">newChunk</span><span class="s3">));</span>
							<span class="s4">if </span><span class="s3">(</span>
								<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{number} */ </span><span class="s3">(</span><span class="s1">usedChunks</span><span class="s3">.</span><span class="s1">size</span><span class="s3">) &gt;=</span>
								<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{number} */ </span><span class="s3">(</span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">minChunks</span><span class="s3">)</span>
							<span class="s3">) {</span>
								<span class="s4">const </span><span class="s1">chunksArr </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s1">usedChunks</span><span class="s3">);</span>
								<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of item</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
									<span class="s1">addModuleToChunksInfoMap</span><span class="s3">(</span>
										<span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">,</span>
										<span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroupIndex</span><span class="s3">,</span>
										<span class="s1">chunksArr</span><span class="s3">,</span>
										<span class="s1">getKey</span><span class="s3">(</span><span class="s1">usedChunks</span><span class="s3">),</span>
										<span class="s1">module</span>
									<span class="s3">);</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
							<span class="s4">continue</span><span class="s3">;</span>
						<span class="s3">}</span>

						<span class="s0">// Validate minRemainingSize constraint when a single chunk is left over</span>
						<span class="s4">if </span><span class="s3">(</span>
							<span class="s3">!</span><span class="s1">enforced </span><span class="s3">&amp;&amp;</span>
							<span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">_validateRemainingSize </span><span class="s3">&amp;&amp;</span>
							<span class="s1">usedChunks</span><span class="s3">.</span><span class="s1">size </span><span class="s3">=== </span><span class="s7">1</span>
						<span class="s3">) {</span>
							<span class="s4">const </span><span class="s3">[</span><span class="s1">chunk</span><span class="s3">] = </span><span class="s1">usedChunks</span><span class="s3">;</span>
							<span class="s4">let </span><span class="s1">chunkSizes </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s4">null</span><span class="s3">);</span>
							<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of chunkGraph</span><span class="s3">.</span><span class="s1">getChunkModulesIterable</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">)) {</span>
								<span class="s4">if </span><span class="s3">(!</span><span class="s1">item</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
									<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">type of module</span><span class="s3">.</span><span class="s1">getSourceTypes</span><span class="s3">()) {</span>
										<span class="s1">chunkSizes</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] =</span>
											<span class="s3">(</span><span class="s1">chunkSizes</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] || </span><span class="s7">0</span><span class="s3">) + </span><span class="s1">module</span><span class="s3">.</span><span class="s1">size</span><span class="s3">(</span><span class="s1">type</span><span class="s3">);</span>
									<span class="s3">}</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
							<span class="s4">const </span><span class="s1">violatingSizes </span><span class="s3">= </span><span class="s1">getViolatingMinSizes</span><span class="s3">(</span>
								<span class="s1">chunkSizes</span><span class="s3">,</span>
								<span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">minRemainingSize</span>
							<span class="s3">);</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">violatingSizes </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
								<span class="s4">const </span><span class="s1">oldModulesSize </span><span class="s3">= </span><span class="s1">item</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size</span><span class="s3">;</span>
								<span class="s1">removeModulesWithSourceType</span><span class="s3">(</span><span class="s1">item</span><span class="s3">, </span><span class="s1">violatingSizes</span><span class="s3">);</span>
								<span class="s4">if </span><span class="s3">(</span>
									<span class="s1">item</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s7">0 </span><span class="s3">&amp;&amp;</span>
									<span class="s1">item</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size </span><span class="s3">!== </span><span class="s1">oldModulesSize</span>
								<span class="s3">) {</span>
									<span class="s0">// queue this item again to be processed again</span>
									<span class="s0">// without violating modules</span>
									<span class="s1">chunksInfoMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */ </span><span class="s3">(</span><span class="s1">bestEntryKey</span><span class="s3">), </span><span class="s1">item</span><span class="s3">);</span>
								<span class="s3">}</span>
								<span class="s4">continue</span><span class="s3">;</span>
							<span class="s3">}</span>
						<span class="s3">}</span>

						<span class="s0">// Create the new chunk if not reusing one</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">newChunk </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
							<span class="s1">newChunk </span><span class="s3">= </span><span class="s1">compilation</span><span class="s3">.</span><span class="s1">addChunk</span><span class="s3">(</span><span class="s1">chunkName</span><span class="s3">);</span>
						<span class="s3">}</span>
						<span class="s0">// Walk through all chunks</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of usedChunks</span><span class="s3">) {</span>
							<span class="s0">// Add graph connections for splitted chunk</span>
							<span class="s1">chunk</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">newChunk</span><span class="s3">);</span>
						<span class="s3">}</span>

						<span class="s0">// Add a note to the chunk</span>
						<span class="s1">newChunk</span><span class="s3">.</span><span class="s1">chunkReason </span><span class="s3">=</span>
							<span class="s3">(</span><span class="s1">newChunk</span><span class="s3">.</span><span class="s1">chunkReason </span><span class="s3">? </span><span class="s1">newChunk</span><span class="s3">.</span><span class="s1">chunkReason </span><span class="s3">+ </span><span class="s2">&quot;, &quot; </span><span class="s3">: </span><span class="s2">&quot;&quot;</span><span class="s3">) +</span>
							<span class="s3">(</span><span class="s1">isReusedWithAllModules</span>
								<span class="s3">? </span><span class="s2">&quot;reused as split chunk&quot;</span>
								<span class="s3">: </span><span class="s2">&quot;split chunk&quot;</span><span class="s3">);</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">key</span><span class="s3">) {</span>
							<span class="s1">newChunk</span><span class="s3">.</span><span class="s1">chunkReason </span><span class="s3">+= </span><span class="s2">` (cache group: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">key</span><span class="s3">}</span><span class="s2">)`</span><span class="s3">;</span>
						<span class="s3">}</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">chunkName</span><span class="s3">) {</span>
							<span class="s1">newChunk</span><span class="s3">.</span><span class="s1">chunkReason </span><span class="s3">+= </span><span class="s2">` (name: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">chunkName</span><span class="s3">}</span><span class="s2">)`</span><span class="s3">;</span>
						<span class="s3">}</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">) {</span>
							<span class="s1">newChunk</span><span class="s3">.</span><span class="s1">filenameTemplate </span><span class="s3">= </span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">;</span>
						<span class="s3">}</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">idHint</span><span class="s3">) {</span>
							<span class="s1">newChunk</span><span class="s3">.</span><span class="s1">idNameHints</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">idHint</span><span class="s3">);</span>
						<span class="s3">}</span>
						<span class="s4">if </span><span class="s3">(!</span><span class="s1">isReusedWithAllModules</span><span class="s3">) {</span>
							<span class="s0">// Add all modules to the new chunk</span>
							<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of item</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
								<span class="s4">if </span><span class="s3">(!</span><span class="s1">module</span><span class="s3">.</span><span class="s1">chunkCondition</span><span class="s3">(</span><span class="s1">newChunk</span><span class="s3">, </span><span class="s1">compilation</span><span class="s3">)) </span><span class="s4">continue</span><span class="s3">;</span>
								<span class="s0">// Add module to new chunk</span>
								<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">connectChunkAndModule</span><span class="s3">(</span><span class="s1">newChunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
								<span class="s0">// Remove module from used chunks</span>
								<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of usedChunks</span><span class="s3">) {</span>
									<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">disconnectChunkAndModule</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
						<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
							<span class="s0">// Remove all modules from used chunks</span>
							<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of item</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
								<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of usedChunks</span><span class="s3">) {</span>
									<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">disconnectChunkAndModule</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
						<span class="s3">}</span>

						<span class="s4">if </span><span class="s3">(</span>
							<span class="s1">Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">maxAsyncSize</span><span class="s3">).</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0 </span><span class="s3">||</span>
							<span class="s1">Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">maxInitialSize</span><span class="s3">).</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0</span>
						<span class="s3">) {</span>
							<span class="s4">const </span><span class="s1">oldMaxSizeSettings </span><span class="s3">= </span><span class="s1">maxSizeQueueMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">newChunk</span><span class="s3">);</span>
							<span class="s1">maxSizeQueueMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">newChunk</span><span class="s3">, {</span>
								<span class="s1">minSize</span><span class="s3">: </span><span class="s1">oldMaxSizeSettings</span>
									<span class="s3">? </span><span class="s1">combineSizes</span><span class="s3">(</span>
											<span class="s1">oldMaxSizeSettings</span><span class="s3">.</span><span class="s1">minSize</span><span class="s3">,</span>
											<span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">_minSizeForMaxSize</span><span class="s3">,</span>
											<span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span>
									  <span class="s3">)</span>
									<span class="s3">: </span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">minSize</span><span class="s3">,</span>
								<span class="s1">maxAsyncSize</span><span class="s3">: </span><span class="s1">oldMaxSizeSettings</span>
									<span class="s3">? </span><span class="s1">combineSizes</span><span class="s3">(</span>
											<span class="s1">oldMaxSizeSettings</span><span class="s3">.</span><span class="s1">maxAsyncSize</span><span class="s3">,</span>
											<span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">maxAsyncSize</span><span class="s3">,</span>
											<span class="s1">Math</span><span class="s3">.</span><span class="s1">min</span>
									  <span class="s3">)</span>
									<span class="s3">: </span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">maxAsyncSize</span><span class="s3">,</span>
								<span class="s1">maxInitialSize</span><span class="s3">: </span><span class="s1">oldMaxSizeSettings</span>
									<span class="s3">? </span><span class="s1">combineSizes</span><span class="s3">(</span>
											<span class="s1">oldMaxSizeSettings</span><span class="s3">.</span><span class="s1">maxInitialSize</span><span class="s3">,</span>
											<span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">maxInitialSize</span><span class="s3">,</span>
											<span class="s1">Math</span><span class="s3">.</span><span class="s1">min</span>
									  <span class="s3">)</span>
									<span class="s3">: </span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">maxInitialSize</span><span class="s3">,</span>
								<span class="s1">automaticNameDelimiter</span><span class="s3">: </span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">automaticNameDelimiter</span><span class="s3">,</span>
								<span class="s1">keys</span><span class="s3">: </span><span class="s1">oldMaxSizeSettings</span>
									<span class="s3">? </span><span class="s1">oldMaxSizeSettings</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">.</span><span class="s1">concat</span><span class="s3">(</span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">key</span><span class="s3">)</span>
									<span class="s3">: [</span><span class="s1">item</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">key</span><span class="s3">]</span>
							<span class="s3">});</span>
						<span class="s3">}</span>

						<span class="s0">// remove all modules from other entries and update size</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span><span class="s1">key</span><span class="s3">, </span><span class="s1">info</span><span class="s3">] </span><span class="s1">of chunksInfoMap</span><span class="s3">) {</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">isOverlap</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">, </span><span class="s1">usedChunks</span><span class="s3">)) {</span>
								<span class="s0">// update modules and total size</span>
								<span class="s0">// may remove it from the map when &lt; minSize</span>
								<span class="s4">let </span><span class="s1">updated </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
								<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of item</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
									<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
										<span class="s0">// remove module</span>
										<span class="s1">info</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
										<span class="s0">// update size</span>
										<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">key of module</span><span class="s3">.</span><span class="s1">getSourceTypes</span><span class="s3">()) {</span>
											<span class="s1">info</span><span class="s3">.</span><span class="s1">sizes</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] -= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">size</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
										<span class="s3">}</span>
										<span class="s1">updated </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
									<span class="s3">}</span>
								<span class="s3">}</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">updated</span><span class="s3">) {</span>
									<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) {</span>
										<span class="s1">chunksInfoMap</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
										<span class="s4">continue</span><span class="s3">;</span>
									<span class="s3">}</span>
									<span class="s4">if </span><span class="s3">(</span>
										<span class="s1">removeMinSizeViolatingModules</span><span class="s3">(</span><span class="s1">info</span><span class="s3">) ||</span>
										<span class="s3">!</span><span class="s1">checkMinSizeReduction</span><span class="s3">(</span>
											<span class="s1">info</span><span class="s3">.</span><span class="s1">sizes</span><span class="s3">,</span>
											<span class="s1">info</span><span class="s3">.</span><span class="s1">cacheGroup</span><span class="s3">.</span><span class="s1">minSizeReduction</span><span class="s3">,</span>
											<span class="s1">info</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">size</span>
										<span class="s3">)</span>
									<span class="s3">) {</span>
										<span class="s1">chunksInfoMap</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
										<span class="s4">continue</span><span class="s3">;</span>
									<span class="s3">}</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
						<span class="s3">}</span>
					<span class="s3">}</span>

					<span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;queue&quot;</span><span class="s3">);</span>

					<span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;maxSize&quot;</span><span class="s3">);</span>

					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;string&gt;} */</span>
					<span class="s4">const </span><span class="s1">incorrectMinMaxSizeSet </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>

					<span class="s4">const </span><span class="s3">{ </span><span class="s1">outputOptions </span><span class="s3">} = </span><span class="s1">compilation</span><span class="s3">;</span>

					<span class="s0">// Make sure that maxSize is fulfilled</span>
					<span class="s4">const </span><span class="s3">{ </span><span class="s1">fallbackCacheGroup </span><span class="s3">} = </span><span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">;</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s1">compilation</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">)) {</span>
						<span class="s4">const </span><span class="s1">chunkConfig </span><span class="s3">= </span><span class="s1">maxSizeQueueMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
						<span class="s4">const </span><span class="s3">{</span>
							<span class="s1">minSize</span><span class="s3">,</span>
							<span class="s1">maxAsyncSize</span><span class="s3">,</span>
							<span class="s1">maxInitialSize</span><span class="s3">,</span>
							<span class="s1">automaticNameDelimiter</span>
						<span class="s3">} = </span><span class="s1">chunkConfig </span><span class="s3">|| </span><span class="s1">fallbackCacheGroup</span><span class="s3">;</span>
						<span class="s4">if </span><span class="s3">(!</span><span class="s1">chunkConfig </span><span class="s3">&amp;&amp; !</span><span class="s1">fallbackCacheGroup</span><span class="s3">.</span><span class="s1">chunksFilter</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">))</span>
							<span class="s4">continue</span><span class="s3">;</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SplitChunksSizes} */</span>
						<span class="s4">let </span><span class="s1">maxSize</span><span class="s3">;</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">isOnlyInitial</span><span class="s3">()) {</span>
							<span class="s1">maxSize </span><span class="s3">= </span><span class="s1">maxInitialSize</span><span class="s3">;</span>
						<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">canBeInitial</span><span class="s3">()) {</span>
							<span class="s1">maxSize </span><span class="s3">= </span><span class="s1">combineSizes</span><span class="s3">(</span><span class="s1">maxAsyncSize</span><span class="s3">, </span><span class="s1">maxInitialSize</span><span class="s3">, </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">min</span><span class="s3">);</span>
						<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
							<span class="s1">maxSize </span><span class="s3">= </span><span class="s1">maxAsyncSize</span><span class="s3">;</span>
						<span class="s3">}</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">maxSize</span><span class="s3">).</span><span class="s1">length </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) {</span>
							<span class="s4">continue</span><span class="s3">;</span>
						<span class="s3">}</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">key of Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">maxSize</span><span class="s3">)) {</span>
							<span class="s4">const </span><span class="s1">maxSizeValue </span><span class="s3">= </span><span class="s1">maxSize</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
							<span class="s4">const </span><span class="s1">minSizeValue </span><span class="s3">= </span><span class="s1">minSize</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
							<span class="s4">if </span><span class="s3">(</span>
								<span class="s4">typeof </span><span class="s1">minSizeValue </span><span class="s3">=== </span><span class="s2">&quot;number&quot; </span><span class="s3">&amp;&amp;</span>
								<span class="s1">minSizeValue </span><span class="s3">&gt; </span><span class="s1">maxSizeValue</span>
							<span class="s3">) {</span>
								<span class="s4">const </span><span class="s1">keys </span><span class="s3">= </span><span class="s1">chunkConfig </span><span class="s3">&amp;&amp; </span><span class="s1">chunkConfig</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">;</span>
								<span class="s4">const </span><span class="s1">warningKey </span><span class="s3">= </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span>
									<span class="s1">keys </span><span class="s3">&amp;&amp; </span><span class="s1">keys</span><span class="s3">.</span><span class="s1">join</span><span class="s3">()</span>
								<span class="s3">} </span><span class="s1">$</span><span class="s3">{</span><span class="s1">minSizeValue</span><span class="s3">} </span><span class="s1">$</span><span class="s3">{</span><span class="s1">maxSizeValue</span><span class="s3">}</span><span class="s2">`</span><span class="s3">;</span>
								<span class="s4">if </span><span class="s3">(!</span><span class="s1">incorrectMinMaxSizeSet</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">warningKey</span><span class="s3">)) {</span>
									<span class="s1">incorrectMinMaxSizeSet</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">warningKey</span><span class="s3">);</span>
									<span class="s1">compilation</span><span class="s3">.</span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span>
										<span class="s4">new </span><span class="s1">MinMaxSizeWarning</span><span class="s3">(</span><span class="s1">keys</span><span class="s3">, </span><span class="s1">minSizeValue</span><span class="s3">, </span><span class="s1">maxSizeValue</span><span class="s3">)</span>
									<span class="s3">);</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
						<span class="s3">}</span>
						<span class="s4">const </span><span class="s1">results </span><span class="s3">= </span><span class="s1">deterministicGroupingForModules</span><span class="s3">({</span>
							<span class="s1">minSize</span><span class="s3">,</span>
							<span class="s1">maxSize</span><span class="s3">: </span><span class="s1">mapObject</span><span class="s3">(</span><span class="s1">maxSize</span><span class="s3">, (</span><span class="s1">value</span><span class="s3">, </span><span class="s1">key</span><span class="s3">) =&gt; {</span>
								<span class="s4">const </span><span class="s1">minSizeValue </span><span class="s3">= </span><span class="s1">minSize</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
								<span class="s4">return typeof </span><span class="s1">minSizeValue </span><span class="s3">=== </span><span class="s2">&quot;number&quot;</span>
									<span class="s3">? </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">minSizeValue</span><span class="s3">)</span>
									<span class="s3">: </span><span class="s1">value</span><span class="s3">;</span>
							<span class="s3">}),</span>
							<span class="s1">items</span><span class="s3">: </span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getChunkModulesIterable</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">),</span>
							<span class="s1">getKey</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
								<span class="s4">const </span><span class="s1">cache </span><span class="s3">= </span><span class="s1">getKeyCache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">cache </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">return </span><span class="s1">cache</span><span class="s3">;</span>
								<span class="s4">const </span><span class="s1">ident </span><span class="s3">= </span><span class="s1">cachedMakePathsRelative</span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">());</span>
								<span class="s4">const </span><span class="s1">nameForCondition </span><span class="s3">=</span>
									<span class="s1">module</span><span class="s3">.</span><span class="s1">nameForCondition </span><span class="s3">&amp;&amp; </span><span class="s1">module</span><span class="s3">.</span><span class="s1">nameForCondition</span><span class="s3">();</span>
								<span class="s4">const </span><span class="s1">name </span><span class="s3">= </span><span class="s1">nameForCondition</span>
									<span class="s3">? </span><span class="s1">cachedMakePathsRelative</span><span class="s3">(</span><span class="s1">nameForCondition</span><span class="s3">)</span>
									<span class="s3">: </span><span class="s1">ident</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s8">/^.*!|\?[^?!]*$/g</span><span class="s3">, </span><span class="s2">&quot;&quot;</span><span class="s3">);</span>
								<span class="s4">const </span><span class="s1">fullKey </span><span class="s3">=</span>
									<span class="s1">name </span><span class="s3">+</span>
									<span class="s1">automaticNameDelimiter </span><span class="s3">+</span>
									<span class="s1">hashFilename</span><span class="s3">(</span><span class="s1">ident</span><span class="s3">, </span><span class="s1">outputOptions</span><span class="s3">);</span>
								<span class="s4">const </span><span class="s1">key </span><span class="s3">= </span><span class="s1">requestToId</span><span class="s3">(</span><span class="s1">fullKey</span><span class="s3">);</span>
								<span class="s1">getKeyCache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">key</span><span class="s3">);</span>
								<span class="s4">return </span><span class="s1">key</span><span class="s3">;</span>
							<span class="s3">},</span>
							<span class="s1">getSize</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
								<span class="s4">const </span><span class="s1">size </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s4">null</span><span class="s3">);</span>
								<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">key of module</span><span class="s3">.</span><span class="s1">getSourceTypes</span><span class="s3">()) {</span>
									<span class="s1">size</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">module</span><span class="s3">.</span><span class="s1">size</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
								<span class="s3">}</span>
								<span class="s4">return </span><span class="s1">size</span><span class="s3">;</span>
							<span class="s3">}</span>
						<span class="s3">});</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">results</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&lt;= </span><span class="s7">1</span><span class="s3">) {</span>
							<span class="s4">continue</span><span class="s3">;</span>
						<span class="s3">}</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">let </span><span class="s1">i </span><span class="s3">= </span><span class="s7">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">results</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
							<span class="s4">const </span><span class="s1">group </span><span class="s3">= </span><span class="s1">results</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
							<span class="s4">const </span><span class="s1">key </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">hidePathInfo</span>
								<span class="s3">? </span><span class="s1">hashFilename</span><span class="s3">(</span><span class="s1">group</span><span class="s3">.</span><span class="s1">key</span><span class="s3">, </span><span class="s1">outputOptions</span><span class="s3">)</span>
								<span class="s3">: </span><span class="s1">group</span><span class="s3">.</span><span class="s1">key</span><span class="s3">;</span>
							<span class="s4">let </span><span class="s1">name </span><span class="s3">= </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">name</span>
								<span class="s3">? </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">name </span><span class="s3">+ </span><span class="s1">automaticNameDelimiter </span><span class="s3">+ </span><span class="s1">key</span>
								<span class="s3">: </span><span class="s4">null</span><span class="s3">;</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">name </span><span class="s3">&amp;&amp; </span><span class="s1">name</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">100</span><span class="s3">) {</span>
								<span class="s1">name </span><span class="s3">=</span>
									<span class="s1">name</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">0</span><span class="s3">, </span><span class="s7">100</span><span class="s3">) +</span>
									<span class="s1">automaticNameDelimiter </span><span class="s3">+</span>
									<span class="s1">hashFilename</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">outputOptions</span><span class="s3">);</span>
							<span class="s3">}</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">!== </span><span class="s1">results</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s7">1</span><span class="s3">) {</span>
								<span class="s4">const </span><span class="s1">newPart </span><span class="s3">= </span><span class="s1">compilation</span><span class="s3">.</span><span class="s1">addChunk</span><span class="s3">(</span>
									<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Chunk[&quot;name&quot;]} */ </span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
								<span class="s3">);</span>
								<span class="s1">chunk</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">newPart</span><span class="s3">);</span>
								<span class="s1">newPart</span><span class="s3">.</span><span class="s1">chunkReason </span><span class="s3">= </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">chunkReason</span><span class="s3">;</span>
								<span class="s0">// Add all modules to the new chunk</span>
								<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of group</span><span class="s3">.</span><span class="s1">items</span><span class="s3">) {</span>
									<span class="s4">if </span><span class="s3">(!</span><span class="s1">module</span><span class="s3">.</span><span class="s1">chunkCondition</span><span class="s3">(</span><span class="s1">newPart</span><span class="s3">, </span><span class="s1">compilation</span><span class="s3">)) {</span>
										<span class="s4">continue</span><span class="s3">;</span>
									<span class="s3">}</span>
									<span class="s0">// Add module to new chunk</span>
									<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">connectChunkAndModule</span><span class="s3">(</span><span class="s1">newPart</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
									<span class="s0">// Remove module from used chunks</span>
									<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">disconnectChunkAndModule</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
								<span class="s3">}</span>
							<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
								<span class="s0">// change the chunk to be a part</span>
								<span class="s1">chunk</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Chunk[&quot;name&quot;]} */ </span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
							<span class="s3">}</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
					<span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;maxSize&quot;</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">);</span>
		<span class="s3">});</span>
	<span class="s3">}</span>
<span class="s3">};</span>
</pre>
</body>
</html>