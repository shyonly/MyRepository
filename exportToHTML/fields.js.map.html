<html>
<head>
<title>fields.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fields.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperReplaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperEnvironmentVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperMemberExpressionToFunctions&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperOptimiseCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperAnnotateAsPure&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperSkipTransparentExpressionWrappers&quot;</span><span class="s0">,</span><span class="s1">&quot;ts&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateNamesMap&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNamesMap&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrivate&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;update&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;static&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;isProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassPrivateMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;getId&quot;</span><span class="s0">,</span><span class="s1">&quot;setId&quot;</span><span class="s0">,</span><span class="s1">&quot;methodId&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateNamesNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;privateFieldsAsProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;privateFieldsAsSymbols&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;initNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;isMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;isAccessor&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;addHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;newExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;annotateAsPure&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNameVisitorFactory&quot;</span><span class="s0">,</span><span class="s1">&quot;visitor&quot;</span><span class="s0">,</span><span class="s1">&quot;nestedVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;visitors&quot;</span><span class="s0">,</span><span class="s1">&quot;merge&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;environmentVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNameVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;Class&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;visiblePrivateNames&quot;</span><span class="s0">,</span><span class="s1">&quot;redeclared&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;skipKey&quot;</span><span class="s0">,</span><span class="s1">&quot;PrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;noDocumentAll&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptionalMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;handle&quot;</span><span class="s0">,</span><span class="s1">&quot;unshadow&quot;</span><span class="s0">,</span><span class="s1">&quot;innerBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;_scope&quot;</span><span class="s0">,</span><span class="s1">&quot;hasBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingIdentifierEquals&quot;</span><span class="s0">,</span><span class="s1">&quot;rename&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCheckInRHS&quot;</span><span class="s0">,</span><span class="s1">&quot;rhs&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;inRHSIsObject&quot;</span><span class="s0">,</span><span class="s1">&quot;availableHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;privateInVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;BinaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;classRef&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNameHandlerSpec&quot;</span><span class="s0">,</span><span class="s1">&quot;memoise&quot;</span><span class="s0">,</span><span class="s1">&quot;member&quot;</span><span class="s0">,</span><span class="s1">&quot;count&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;memo&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeGenerateMemoised&quot;</span><span class="s0">,</span><span class="s1">&quot;memoiser&quot;</span><span class="s0">,</span><span class="s1">&quot;receiver&quot;</span><span class="s0">,</span><span class="s1">&quot;helperName&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;boundGet&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;destructureSet&quot;</span><span class="s0">,</span><span class="s1">&quot;helper&quot;</span><span class="s0">,</span><span class="s1">&quot;_unused&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;optimiseCall&quot;</span><span class="s0">,</span><span class="s1">&quot;optionalCall&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNameHandlerLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;BASE&quot;</span><span class="s0">,</span><span class="s1">&quot;REF&quot;</span><span class="s0">,</span><span class="s1">&quot;PROP&quot;</span><span class="s0">,</span><span class="s1">&quot;simpleSet&quot;</span><span class="s0">,</span><span class="s1">&quot;optionalCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;transformPrivateNamesUsage&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpressionToFunctions&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateFieldInitLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;buildUndefinedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritPropComments&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateInstanceFieldInitSpec&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateStaticFieldInitSpec&quot;</span><span class="s0">,</span><span class="s1">&quot;privateName&quot;</span><span class="s0">,</span><span class="s1">&quot;initAdded&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateMethodInitLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateInstanceMethodInitSpec&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateAccessorInitialization&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateInstanceMethodInitialization&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPublicFieldInitLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPublicFieldInitSpec&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateStaticMethodInitLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateMethodDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;getterDeclared&quot;</span><span class="s0">,</span><span class="s1">&quot;setterDeclared&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;generator&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;isGetter&quot;</span><span class="s0">,</span><span class="s1">&quot;isSetter&quot;</span><span class="s0">,</span><span class="s1">&quot;declId&quot;</span><span class="s0">,</span><span class="s1">&quot;functionDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;thisContextVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;UnaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;argument&quot;</span><span class="s0">,</span><span class="s1">&quot;skipTransparentExprWrapperNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;isThisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;booleanLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;ThisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;needsClassRef&quot;</span><span class="s0">,</span><span class="s1">&quot;MetaProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;innerReferencesVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceThisContext&quot;</span><span class="s0">,</span><span class="s1">&quot;innerBindingRef&quot;</span><span class="s0">,</span><span class="s1">&quot;_state$classRef&quot;</span><span class="s0">,</span><span class="s1">&quot;isNameOrLength&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritLeadingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritInnerComments&quot;</span><span class="s0">,</span><span class="s1">&quot;buildFieldsInitNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;superRef&quot;</span><span class="s0">,</span><span class="s1">&quot;setPublicClassFields&quot;</span><span class="s0">,</span><span class="s1">&quot;constantSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref2&quot;</span><span class="s0">,</span><span class="s1">&quot;classRefFlags&quot;</span><span class="s0">,</span><span class="s1">&quot;injectSuperRef&quot;</span><span class="s0">,</span><span class="s1">&quot;staticNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;instanceNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;pureStaticNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;classBindingNode&quot;</span><span class="s0">,</span><span class="s1">&quot;getSuperRef&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;_injectSuperRef&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifierBasedOnNode&quot;</span><span class="s0">,</span><span class="s1">&quot;classRefForInnerBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;assertFieldTransformed&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;isInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;isPublic&quot;</span><span class="s0">,</span><span class="s1">&quot;isField&quot;</span><span class="s0">,</span><span class="s1">&quot;ReplaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;methodPath&quot;</span><span class="s0">,</span><span class="s1">&quot;refToPreserve&quot;</span><span class="s0">,</span><span class="s1">&quot;getObjectRef&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;replaced&quot;</span><span class="s0">,</span><span class="s1">&quot;blockBody&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritsComments&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapClass&quot;</span><span class="s0">,</span><span class="s1">&quot;leadingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassExpression&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/fields.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { template, traverse, types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { File } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath, Visitor, Scope } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import ReplaceSupers from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-replace-supers</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import environmentVisitor from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-environment-visitor</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import memberExpressionToFunctions from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-member-expression-to-functions</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Handler,</span><span class="s3">\n  </span><span class="s1">HandlerState,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-member-expression-to-functions</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import optimiseCall from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-optimise-call-expression</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import annotateAsPure from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-annotate-as-pure</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { skipTransparentExprWrapperNodes } from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-skip-transparent-expression-wrappers</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import * as ts from </span><span class="s3">\&quot;</span><span class="s1">./typescript.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">interface PrivateNameMetadata {</span><span class="s3">\n  </span><span class="s1">id: t.Identifier;</span><span class="s3">\n  </span><span class="s1">static: boolean;</span><span class="s3">\n  </span><span class="s1">method: boolean;</span><span class="s3">\n  </span><span class="s1">getId?: t.Identifier;</span><span class="s3">\n  </span><span class="s1">setId?: t.Identifier;</span><span class="s3">\n  </span><span class="s1">methodId?: t.Identifier;</span><span class="s3">\n  </span><span class="s1">initAdded?: boolean;</span><span class="s3">\n  </span><span class="s1">getterDeclared?: boolean;</span><span class="s3">\n  </span><span class="s1">setterDeclared?: boolean;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type PrivateNamesMap = Map&lt;string, PrivateNameMetadata&gt;;</span><span class="s3">\n\n</span><span class="s1">export function buildPrivateNamesMap(props: PropPath[]) {</span><span class="s3">\n  </span><span class="s1">const privateNamesMap: PrivateNamesMap = new Map();</span><span class="s3">\n  </span><span class="s1">for (const prop of props) {</span><span class="s3">\n    </span><span class="s1">if (prop.isPrivate()) {</span><span class="s3">\n      </span><span class="s1">const { name } = prop.node.key.id;</span><span class="s3">\n      </span><span class="s1">const update: PrivateNameMetadata = privateNamesMap.has(name)</span><span class="s3">\n        </span><span class="s1">? privateNamesMap.get(name)</span><span class="s3">\n        </span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">id: prop.scope.generateUidIdentifier(name),</span><span class="s3">\n            </span><span class="s1">static: prop.node.static,</span><span class="s3">\n            </span><span class="s1">method: !prop.isProperty(),</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">if (prop.isClassPrivateMethod()) {</span><span class="s3">\n        </span><span class="s1">if (prop.node.kind === </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">update.getId = prop.scope.generateUidIdentifier(`get_${name}`);</span><span class="s3">\n        </span><span class="s1">} else if (prop.node.kind === </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">update.setId = prop.scope.generateUidIdentifier(`set_${name}`);</span><span class="s3">\n        </span><span class="s1">} else if (prop.node.kind === </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">update.methodId = prop.scope.generateUidIdentifier(name);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">privateNamesMap.set(name, update);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return privateNamesMap;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function buildPrivateNamesNodes(</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">privateFieldsAsProperties: boolean,</span><span class="s3">\n  </span><span class="s1">privateFieldsAsSymbols: boolean,</span><span class="s3">\n  </span><span class="s1">state: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const initNodes: t.Statement[] = [];</span><span class="s3">\n\n  </span><span class="s1">for (const [name, value] of privateNamesMap) {</span><span class="s3">\n    </span><span class="s1">// - When the privateFieldsAsProperties assumption is enabled,</span><span class="s3">\n    </span><span class="s1">//   both static and instance fields are transpiled using a</span><span class="s3">\n    </span><span class="s1">//   secret non-enumerable property. Hence, we also need to generate that</span><span class="s3">\n    </span><span class="s1">//   key (using the classPrivateFieldLooseKey helper).</span><span class="s3">\n    </span><span class="s1">// - When the privateFieldsAsSymbols assumption is enabled,</span><span class="s3">\n    </span><span class="s1">//   both static and instance fields are transpiled using a</span><span class="s3">\n    </span><span class="s1">//   unique Symbol to define a non-enumerable property.</span><span class="s3">\n    </span><span class="s1">// - In spec mode, only instance fields need a </span><span class="s3">\&quot;</span><span class="s1">private name</span><span class="s3">\&quot; </span><span class="s1">initializer</span><span class="s3">\n    </span><span class="s1">//   because static fields are directly assigned to a variable in the</span><span class="s3">\n    </span><span class="s1">//   buildPrivateStaticFieldInitSpec function.</span><span class="s3">\n    </span><span class="s1">const { static: isStatic, method: isMethod, getId, setId } = value;</span><span class="s3">\n    </span><span class="s1">const isAccessor = getId || setId;</span><span class="s3">\n    </span><span class="s1">const id = t.cloneNode(value.id);</span><span class="s3">\n\n    </span><span class="s1">let init: t.Expression;</span><span class="s3">\n\n    </span><span class="s1">if (privateFieldsAsProperties) {</span><span class="s3">\n      </span><span class="s1">init = t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldLooseKey</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n        </span><span class="s1">t.stringLiteral(name),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">} else if (privateFieldsAsSymbols) {</span><span class="s3">\n      </span><span class="s1">init = t.callExpression(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">Symbol</span><span class="s3">\&quot;</span><span class="s1">), [t.stringLiteral(name)]);</span><span class="s3">\n    </span><span class="s1">} else if (!isStatic) {</span><span class="s3">\n      </span><span class="s1">init = t.newExpression(</span><span class="s3">\n        </span><span class="s1">t.identifier(!isMethod || isAccessor ? </span><span class="s3">\&quot;</span><span class="s1">WeakMap</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">WeakSet</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">[],</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (init) {</span><span class="s3">\n      </span><span class="s1">annotateAsPure(init);</span><span class="s3">\n      </span><span class="s1">initNodes.push(template.statement.ast`var ${id} = ${init}`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return initNodes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface PrivateNameVisitorState {</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap;</span><span class="s3">\n  </span><span class="s1">privateFieldsAsProperties: boolean;</span><span class="s3">\n  </span><span class="s1">redeclared?: string[];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Traverses the class scope, handling private name references. If an inner</span><span class="s3">\n</span><span class="s1">// class redeclares the same private name, it will hand off traversal to the</span><span class="s3">\n</span><span class="s1">// restricted visitor (which doesn't traverse the inner class's inner scope).</span><span class="s3">\n</span><span class="s1">function privateNameVisitorFactory&lt;S&gt;(</span><span class="s3">\n  </span><span class="s1">visitor: Visitor&lt;PrivateNameVisitorState &amp; S&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// Traverses the outer portion of a class, without touching the class's inner</span><span class="s3">\n  </span><span class="s1">// scope, for private names.</span><span class="s3">\n  </span><span class="s1">const nestedVisitor = traverse.visitors.merge([</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">...visitor,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">environmentVisitor,</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n\n  </span><span class="s1">const privateNameVisitor: Visitor&lt;PrivateNameVisitorState &amp; S&gt; = {</span><span class="s3">\n    </span><span class="s1">...visitor,</span><span class="s3">\n\n    </span><span class="s1">Class(path) {</span><span class="s3">\n      </span><span class="s1">const { privateNamesMap } = this;</span><span class="s3">\n      </span><span class="s1">const body = path.get(</span><span class="s3">\&quot;</span><span class="s1">body.body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">const visiblePrivateNames = new Map(privateNamesMap);</span><span class="s3">\n      </span><span class="s1">const redeclared = [];</span><span class="s3">\n      </span><span class="s1">for (const prop of body) {</span><span class="s3">\n        </span><span class="s1">if (!prop.isPrivate()) continue;</span><span class="s3">\n        </span><span class="s1">const { name } = prop.node.key.id;</span><span class="s3">\n        </span><span class="s1">visiblePrivateNames.delete(name);</span><span class="s3">\n        </span><span class="s1">redeclared.push(name);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If the class doesn't redeclare any private fields, we can continue with</span><span class="s3">\n      </span><span class="s1">// our overall traversal.</span><span class="s3">\n      </span><span class="s1">if (!redeclared.length) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// This class redeclares some private field. We need to process the outer</span><span class="s3">\n      </span><span class="s1">// environment with access to all the outer privates, then we can process</span><span class="s3">\n      </span><span class="s1">// the inner environment with only the still-visible outer privates.</span><span class="s3">\n      </span><span class="s1">path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).traverse(nestedVisitor, {</span><span class="s3">\n        </span><span class="s1">...this,</span><span class="s3">\n        </span><span class="s1">redeclared,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">path.traverse(privateNameVisitor, {</span><span class="s3">\n        </span><span class="s1">...this,</span><span class="s3">\n        </span><span class="s1">privateNamesMap: visiblePrivateNames,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">// We'll eventually hit this class node again with the overall Class</span><span class="s3">\n      </span><span class="s1">// Features visitor, which'll process the redeclared privates.</span><span class="s3">\n      </span><span class="s1">path.skipKey(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">return privateNameVisitor;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface PrivateNameState {</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap;</span><span class="s3">\n  </span><span class="s1">classRef: t.Identifier;</span><span class="s3">\n  </span><span class="s1">file: File;</span><span class="s3">\n  </span><span class="s1">noDocumentAll: boolean;</span><span class="s3">\n  </span><span class="s1">innerBinding?: t.Identifier;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const privateNameVisitor = privateNameVisitorFactory&lt;</span><span class="s3">\n  </span><span class="s1">HandlerState&lt;PrivateNameState&gt; &amp; PrivateNameState</span><span class="s3">\n</span><span class="s1">&gt;({</span><span class="s3">\n  </span><span class="s1">PrivateName(path, { noDocumentAll }) {</span><span class="s3">\n    </span><span class="s1">const { privateNamesMap, redeclared } = this;</span><span class="s3">\n    </span><span class="s1">const { node, parentPath } = path;</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!parentPath.isMemberExpression({ property: node }) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!parentPath.isOptionalMemberExpression({ property: node })</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { name } = node.id;</span><span class="s3">\n    </span><span class="s1">if (!privateNamesMap.has(name)) return;</span><span class="s3">\n    </span><span class="s1">if (redeclared &amp;&amp; redeclared.includes(name)) return;</span><span class="s3">\n\n    </span><span class="s1">this.handle(parentPath, noDocumentAll);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">// rename all bindings that shadows innerBinding</span><span class="s3">\n</span><span class="s1">function unshadow(</span><span class="s3">\n  </span><span class="s1">name: string,</span><span class="s3">\n  </span><span class="s1">scope: Scope,</span><span class="s3">\n  </span><span class="s1">innerBinding: t.Identifier | undefined,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// in some cases, scope.getBinding(name) === undefined</span><span class="s3">\n  </span><span class="s1">// so we check hasBinding to avoid keeping looping</span><span class="s3">\n  </span><span class="s1">// see: https://github.com/babel/babel/pull/13656#discussion_r686030715</span><span class="s3">\n  </span><span class="s1">while (</span><span class="s3">\n    </span><span class="s1">scope?.hasBinding(name) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!scope.bindingIdentifierEquals(name, innerBinding)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">scope.rename(name);</span><span class="s3">\n    </span><span class="s1">scope = scope.parent;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function buildCheckInRHS(</span><span class="s3">\n  </span><span class="s1">rhs: t.Expression,</span><span class="s3">\n  </span><span class="s1">file: File,</span><span class="s3">\n  </span><span class="s1">inRHSIsObject?: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (inRHSIsObject || !file.availableHelper?.(</span><span class="s3">\&quot;</span><span class="s1">checkInRHS</span><span class="s3">\&quot;</span><span class="s1">)) return rhs;</span><span class="s3">\n  </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">checkInRHS</span><span class="s3">\&quot;</span><span class="s1">), [rhs]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const privateInVisitor = privateNameVisitorFactory&lt;{</span><span class="s3">\n  </span><span class="s1">classRef: t.Identifier;</span><span class="s3">\n  </span><span class="s1">file: File;</span><span class="s3">\n  </span><span class="s1">innerBinding?: t.Identifier;</span><span class="s3">\n</span><span class="s1">}&gt;({</span><span class="s3">\n  </span><span class="s1">BinaryExpression(path, { file }) {</span><span class="s3">\n    </span><span class="s1">const { operator, left, right } = path.node;</span><span class="s3">\n    </span><span class="s1">if (operator !== </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">) return;</span><span class="s3">\n    </span><span class="s1">if (!t.isPrivateName(left)) return;</span><span class="s3">\n\n    </span><span class="s1">const { privateFieldsAsProperties, privateNamesMap, redeclared } = this;</span><span class="s3">\n\n    </span><span class="s1">const { name } = left.id;</span><span class="s3">\n\n    </span><span class="s1">if (!privateNamesMap.has(name)) return;</span><span class="s3">\n    </span><span class="s1">if (redeclared &amp;&amp; redeclared.includes(name)) return;</span><span class="s3">\n\n    </span><span class="s1">// if there are any local variable shadowing classRef, unshadow it</span><span class="s3">\n    </span><span class="s1">// see #12960</span><span class="s3">\n    </span><span class="s1">unshadow(this.classRef.name, path.scope, this.innerBinding);</span><span class="s3">\n\n    </span><span class="s1">if (privateFieldsAsProperties) {</span><span class="s3">\n      </span><span class="s1">const { id } = privateNamesMap.get(name);</span><span class="s3">\n      </span><span class="s1">path.replaceWith(template.expression.ast`</span><span class="s3">\n        </span><span class="s1">Object.prototype.hasOwnProperty.call(${buildCheckInRHS(</span><span class="s3">\n          </span><span class="s1">right,</span><span class="s3">\n          </span><span class="s1">file,</span><span class="s3">\n        </span><span class="s1">)}, ${t.cloneNode(id)})</span><span class="s3">\n      </span><span class="s1">`);</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const { id, static: isStatic } = privateNamesMap.get(name);</span><span class="s3">\n\n    </span><span class="s1">if (isStatic) {</span><span class="s3">\n      </span><span class="s1">path.replaceWith(</span><span class="s3">\n        </span><span class="s1">template.expression.ast`${buildCheckInRHS(</span><span class="s3">\n          </span><span class="s1">right,</span><span class="s3">\n          </span><span class="s1">file,</span><span class="s3">\n        </span><span class="s1">)} === ${t.cloneNode(this.classRef)}`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">path.replaceWith(</span><span class="s3">\n      </span><span class="s1">template.expression.ast`${t.cloneNode(id)}.has(${buildCheckInRHS(</span><span class="s3">\n        </span><span class="s1">right,</span><span class="s3">\n        </span><span class="s1">file,</span><span class="s3">\n      </span><span class="s1">)})`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">interface Receiver {</span><span class="s3">\n  </span><span class="s1">receiver(</span><span class="s3">\n    </span><span class="s1">this: HandlerState&lt;PrivateNameState&gt; &amp; PrivateNameState,</span><span class="s3">\n    </span><span class="s1">member: NodePath&lt;t.MemberExpression | t.OptionalMemberExpression&gt;,</span><span class="s3">\n  </span><span class="s1">): t.Expression;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const privateNameHandlerSpec: Handler&lt;PrivateNameState &amp; Receiver&gt; &amp; Receiver =</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">memoise(member, count) {</span><span class="s3">\n      </span><span class="s1">const { scope } = member;</span><span class="s3">\n      </span><span class="s1">const { object } = member.node as { object: t.Expression };</span><span class="s3">\n\n      </span><span class="s1">const memo = scope.maybeGenerateMemoised(object);</span><span class="s3">\n      </span><span class="s1">if (!memo) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">this.memoiser.set(object, memo, count);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">receiver(member) {</span><span class="s3">\n      </span><span class="s1">const { object } = member.node as { object: t.Expression };</span><span class="s3">\n\n      </span><span class="s1">if (this.memoiser.has(object)) {</span><span class="s3">\n        </span><span class="s1">return t.cloneNode(this.memoiser.get(object));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return t.cloneNode(object);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">get(member) {</span><span class="s3">\n      </span><span class="s1">const { classRef, privateNamesMap, file, innerBinding } = this;</span><span class="s3">\n      </span><span class="s1">const { name } = (member.node.property as t.PrivateName).id;</span><span class="s3">\n      </span><span class="s1">const {</span><span class="s3">\n        </span><span class="s1">id,</span><span class="s3">\n        </span><span class="s1">static: isStatic,</span><span class="s3">\n        </span><span class="s1">method: isMethod,</span><span class="s3">\n        </span><span class="s1">methodId,</span><span class="s3">\n        </span><span class="s1">getId,</span><span class="s3">\n        </span><span class="s1">setId,</span><span class="s3">\n      </span><span class="s1">} = privateNamesMap.get(name);</span><span class="s3">\n      </span><span class="s1">const isAccessor = getId || setId;</span><span class="s3">\n\n      </span><span class="s1">if (isStatic) {</span><span class="s3">\n        </span><span class="s1">// NOTE: This package has a peerDependency on @babel/core@^7.0.0, but these</span><span class="s3">\n        </span><span class="s1">// helpers have been introduced in @babel/helpers@7.1.0.</span><span class="s3">\n        </span><span class="s1">const helperName =</span><span class="s3">\n          </span><span class="s1">isMethod &amp;&amp; !isAccessor</span><span class="s3">\n            </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">classStaticPrivateMethodGet</span><span class="s3">\&quot;\n            </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">classStaticPrivateFieldSpecGet</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n        </span><span class="s1">// if there are any local variable shadowing classRef, unshadow it</span><span class="s3">\n        </span><span class="s1">// see #12960</span><span class="s3">\n        </span><span class="s1">unshadow(classRef.name, member.scope, innerBinding);</span><span class="s3">\n\n        </span><span class="s1">return t.callExpression(file.addHelper(helperName), [</span><span class="s3">\n          </span><span class="s1">this.receiver(member),</span><span class="s3">\n          </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n          </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isMethod) {</span><span class="s3">\n        </span><span class="s1">if (isAccessor) {</span><span class="s3">\n          </span><span class="s1">if (!getId &amp;&amp; setId) {</span><span class="s3">\n            </span><span class="s1">if (file.availableHelper(</span><span class="s3">\&quot;</span><span class="s1">writeOnlyError</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n              </span><span class="s1">return t.sequenceExpression([</span><span class="s3">\n                </span><span class="s1">this.receiver(member),</span><span class="s3">\n                </span><span class="s1">t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">writeOnlyError</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n                  </span><span class="s1">t.stringLiteral(`#${name}`),</span><span class="s3">\n                </span><span class="s1">]),</span><span class="s3">\n              </span><span class="s1">]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">console.warn(</span><span class="s3">\n              </span><span class="s1">`@babel/helpers is outdated, update it to silence this warning.`,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldGet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n            </span><span class="s1">this.receiver(member),</span><span class="s3">\n            </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateMethodGet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n          </span><span class="s1">this.receiver(member),</span><span class="s3">\n          </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n          </span><span class="s1">t.cloneNode(methodId),</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldGet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n        </span><span class="s1">this.receiver(member),</span><span class="s3">\n        </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">boundGet(member) {</span><span class="s3">\n      </span><span class="s1">this.memoise(member, 1);</span><span class="s3">\n\n      </span><span class="s1">return t.callExpression(</span><span class="s3">\n        </span><span class="s1">t.memberExpression(this.get(member), t.identifier(</span><span class="s3">\&quot;</span><span class="s1">bind</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n        </span><span class="s1">[this.receiver(member)],</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">set(member, value) {</span><span class="s3">\n      </span><span class="s1">const { classRef, privateNamesMap, file } = this;</span><span class="s3">\n      </span><span class="s1">const { name } = (member.node.property as t.PrivateName).id;</span><span class="s3">\n      </span><span class="s1">const {</span><span class="s3">\n        </span><span class="s1">id,</span><span class="s3">\n        </span><span class="s1">static: isStatic,</span><span class="s3">\n        </span><span class="s1">method: isMethod,</span><span class="s3">\n        </span><span class="s1">setId,</span><span class="s3">\n        </span><span class="s1">getId,</span><span class="s3">\n      </span><span class="s1">} = privateNamesMap.get(name);</span><span class="s3">\n      </span><span class="s1">const isAccessor = getId || setId;</span><span class="s3">\n\n      </span><span class="s1">if (isStatic) {</span><span class="s3">\n        </span><span class="s1">const helperName =</span><span class="s3">\n          </span><span class="s1">isMethod &amp;&amp; !isAccessor</span><span class="s3">\n            </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">classStaticPrivateMethodSet</span><span class="s3">\&quot;\n            </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">classStaticPrivateFieldSpecSet</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n        </span><span class="s1">return t.callExpression(file.addHelper(helperName), [</span><span class="s3">\n          </span><span class="s1">this.receiver(member),</span><span class="s3">\n          </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n          </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n          </span><span class="s1">value,</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (isMethod) {</span><span class="s3">\n        </span><span class="s1">if (setId) {</span><span class="s3">\n          </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldSet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n            </span><span class="s1">this.receiver(member),</span><span class="s3">\n            </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n            </span><span class="s1">value,</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return t.sequenceExpression([</span><span class="s3">\n          </span><span class="s1">this.receiver(member),</span><span class="s3">\n          </span><span class="s1">value,</span><span class="s3">\n          </span><span class="s1">t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">readOnlyError</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n            </span><span class="s1">t.stringLiteral(`#${name}`),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldSet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n        </span><span class="s1">this.receiver(member),</span><span class="s3">\n        </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n        </span><span class="s1">value,</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">destructureSet(member) {</span><span class="s3">\n      </span><span class="s1">const { classRef, privateNamesMap, file } = this;</span><span class="s3">\n      </span><span class="s1">const { name } = (member.node.property as t.PrivateName).id;</span><span class="s3">\n      </span><span class="s1">const { id, static: isStatic } = privateNamesMap.get(name);</span><span class="s3">\n      </span><span class="s1">if (isStatic) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">// classStaticPrivateFieldDestructureSet was introduced in 7.13.10</span><span class="s3">\n          </span><span class="s1">// eslint-disable-next-line no-var</span><span class="s3">\n          </span><span class="s1">var helper = file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classStaticPrivateFieldDestructureSet</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} catch {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            \&quot;</span><span class="s1">Babel can not transpile `[C.#p] = [0]` with @babel/helpers &lt; 7.13.10, </span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n              \&quot;</span><span class="s1">please update @babel/helpers to the latest version.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return t.memberExpression(</span><span class="s3">\n          </span><span class="s1">t.callExpression(helper, [</span><span class="s3">\n            </span><span class="s1">this.receiver(member),</span><span class="s3">\n            </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n            </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n          </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return t.memberExpression(</span><span class="s3">\n        </span><span class="s1">t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldDestructureSet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n          </span><span class="s1">this.receiver(member),</span><span class="s3">\n          </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">call(member, args: (t.Expression | t.SpreadElement)[]) {</span><span class="s3">\n      </span><span class="s1">// The first access (the get) should do the memo assignment.</span><span class="s3">\n      </span><span class="s1">this.memoise(member, 1);</span><span class="s3">\n\n      </span><span class="s1">return optimiseCall(this.get(member), this.receiver(member), args, false);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">optionalCall(member, args: (t.Expression | t.SpreadElement)[]) {</span><span class="s3">\n      </span><span class="s1">this.memoise(member, 1);</span><span class="s3">\n\n      </span><span class="s1">return optimiseCall(this.get(member), this.receiver(member), args, true);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">delete() {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        \&quot;</span><span class="s1">Internal Babel error: deleting private elements is a parsing error.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const privateNameHandlerLoose: Handler&lt;PrivateNameState&gt; = {</span><span class="s3">\n  </span><span class="s1">get(member) {</span><span class="s3">\n    </span><span class="s1">const { privateNamesMap, file } = this;</span><span class="s3">\n    </span><span class="s1">const { object } = member.node;</span><span class="s3">\n    </span><span class="s1">const { name } = (member.node.property as t.PrivateName).id;</span><span class="s3">\n\n    </span><span class="s1">return template.expression`BASE(REF, PROP)[PROP]`({</span><span class="s3">\n      </span><span class="s1">BASE: file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldLooseBase</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">REF: t.cloneNode(object),</span><span class="s3">\n      </span><span class="s1">PROP: t.cloneNode(privateNamesMap.get(name).id),</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">set() {</span><span class="s3">\n    </span><span class="s1">// noop</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">private name handler with loose = true don't need set()</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">boundGet(member) {</span><span class="s3">\n    </span><span class="s1">return t.callExpression(</span><span class="s3">\n      </span><span class="s1">t.memberExpression(this.get(member), t.identifier(</span><span class="s3">\&quot;</span><span class="s1">bind</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n      </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion</span><span class="s3">\n      </span><span class="s1">[t.cloneNode(member.node.object as t.Expression)],</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">simpleSet(member) {</span><span class="s3">\n    </span><span class="s1">return this.get(member);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">destructureSet(member) {</span><span class="s3">\n    </span><span class="s1">return this.get(member);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">call(member, args) {</span><span class="s3">\n    </span><span class="s1">return t.callExpression(this.get(member), args);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">optionalCall(member, args) {</span><span class="s3">\n    </span><span class="s1">return t.optionalCallExpression(this.get(member), args, true);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">delete() {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">Internal Babel error: deleting private elements is a parsing error.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function transformPrivateNamesUsage(</span><span class="s3">\n  </span><span class="s1">ref: t.Identifier,</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Class&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">privateFieldsAsProperties,</span><span class="s3">\n    </span><span class="s1">noDocumentAll,</span><span class="s3">\n    </span><span class="s1">innerBinding,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">privateFieldsAsProperties: boolean;</span><span class="s3">\n    </span><span class="s1">noDocumentAll: boolean;</span><span class="s3">\n    </span><span class="s1">innerBinding: t.Identifier;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">state: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!privateNamesMap.size) return;</span><span class="s3">\n\n  </span><span class="s1">const body = path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const handler = privateFieldsAsProperties</span><span class="s3">\n    </span><span class="s1">? privateNameHandlerLoose</span><span class="s3">\n    </span><span class="s1">: privateNameHandlerSpec;</span><span class="s3">\n\n  </span><span class="s1">memberExpressionToFunctions&lt;PrivateNameState&gt;(body, privateNameVisitor, {</span><span class="s3">\n    </span><span class="s1">privateNamesMap,</span><span class="s3">\n    </span><span class="s1">classRef: ref,</span><span class="s3">\n    </span><span class="s1">file: state,</span><span class="s3">\n    </span><span class="s1">...handler,</span><span class="s3">\n    </span><span class="s1">noDocumentAll,</span><span class="s3">\n    </span><span class="s1">innerBinding,</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">body.traverse(privateInVisitor, {</span><span class="s3">\n    </span><span class="s1">privateNamesMap,</span><span class="s3">\n    </span><span class="s1">classRef: ref,</span><span class="s3">\n    </span><span class="s1">file: state,</span><span class="s3">\n    </span><span class="s1">privateFieldsAsProperties,</span><span class="s3">\n    </span><span class="s1">innerBinding,</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateFieldInitLoose(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateProperty&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { id } = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n  </span><span class="s1">const value = prop.node.value || prop.scope.buildUndefinedNode();</span><span class="s3">\n\n  </span><span class="s1">return inheritPropComments(</span><span class="s3">\n    </span><span class="s1">template.statement.ast`</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(${ref}, ${t.cloneNode(id)}, {</span><span class="s3">\n        </span><span class="s1">// configurable is false by default</span><span class="s3">\n        </span><span class="s1">// enumerable is false by default</span><span class="s3">\n        </span><span class="s1">writable: true,</span><span class="s3">\n        </span><span class="s1">value: ${value}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">`,</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateInstanceFieldInitSpec(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateProperty&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">state: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { id } = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n  </span><span class="s1">const value = prop.node.value || prop.scope.buildUndefinedNode();</span><span class="s3">\n\n  </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">if (!state.availableHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldInitSpec</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">return inheritPropComments(</span><span class="s3">\n        </span><span class="s1">template.statement.ast`${t.cloneNode(id)}.set(${ref}, {</span><span class="s3">\n          </span><span class="s1">// configurable is always false for private elements</span><span class="s3">\n          </span><span class="s1">// enumerable is always false for private elements</span><span class="s3">\n          </span><span class="s1">writable: true,</span><span class="s3">\n          </span><span class="s1">value: ${value},</span><span class="s3">\n        </span><span class="s1">})`,</span><span class="s3">\n        </span><span class="s1">prop,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const helper = state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldInitSpec</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">return inheritPropComments(</span><span class="s3">\n    </span><span class="s1">template.statement.ast`${helper}(</span><span class="s3">\n      </span><span class="s1">${t.thisExpression()},</span><span class="s3">\n      </span><span class="s1">${t.cloneNode(id)},</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">writable: true,</span><span class="s3">\n        </span><span class="s1">value: ${value}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">)`,</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateStaticFieldInitSpec(</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateProperty&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n  </span><span class="s1">const { id, getId, setId, initAdded } = privateName;</span><span class="s3">\n  </span><span class="s1">const isAccessor = getId || setId;</span><span class="s3">\n\n  </span><span class="s1">if (!prop.isProperty() &amp;&amp; (initAdded || !isAccessor)) return;</span><span class="s3">\n\n  </span><span class="s1">if (isAccessor) {</span><span class="s3">\n    </span><span class="s1">privateNamesMap.set(prop.node.key.id.name, {</span><span class="s3">\n      </span><span class="s1">...privateName,</span><span class="s3">\n      </span><span class="s1">initAdded: true,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">return inheritPropComments(</span><span class="s3">\n      </span><span class="s1">template.statement.ast`</span><span class="s3">\n        </span><span class="s1">var ${t.cloneNode(id)} = {</span><span class="s3">\n          </span><span class="s1">// configurable is false by default</span><span class="s3">\n          </span><span class="s1">// enumerable is false by default</span><span class="s3">\n          </span><span class="s1">// writable is false by default</span><span class="s3">\n          </span><span class="s1">get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},</span><span class="s3">\n          </span><span class="s1">set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">`,</span><span class="s3">\n      </span><span class="s1">prop,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const value = prop.node.value || prop.scope.buildUndefinedNode();</span><span class="s3">\n  </span><span class="s1">return inheritPropComments(</span><span class="s3">\n    </span><span class="s1">template.statement.ast`</span><span class="s3">\n      </span><span class="s1">var ${t.cloneNode(id)} = {</span><span class="s3">\n        </span><span class="s1">// configurable is false by default</span><span class="s3">\n        </span><span class="s1">// enumerable is false by default</span><span class="s3">\n        </span><span class="s1">writable: true,</span><span class="s3">\n        </span><span class="s1">value: ${value}</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">`,</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateMethodInitLoose(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n  </span><span class="s1">const { methodId, id, getId, setId, initAdded } = privateName;</span><span class="s3">\n  </span><span class="s1">if (initAdded) return;</span><span class="s3">\n\n  </span><span class="s1">if (methodId) {</span><span class="s3">\n    </span><span class="s1">return inheritPropComments(</span><span class="s3">\n      </span><span class="s1">template.statement.ast`</span><span class="s3">\n        </span><span class="s1">Object.defineProperty(${ref}, ${id}, {</span><span class="s3">\n          </span><span class="s1">// configurable is false by default</span><span class="s3">\n          </span><span class="s1">// enumerable is false by default</span><span class="s3">\n          </span><span class="s1">// writable is false by default</span><span class="s3">\n          </span><span class="s1">value: ${methodId.name}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">`,</span><span class="s3">\n      </span><span class="s1">prop,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const isAccessor = getId || setId;</span><span class="s3">\n  </span><span class="s1">if (isAccessor) {</span><span class="s3">\n    </span><span class="s1">privateNamesMap.set(prop.node.key.id.name, {</span><span class="s3">\n      </span><span class="s1">...privateName,</span><span class="s3">\n      </span><span class="s1">initAdded: true,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">return inheritPropComments(</span><span class="s3">\n      </span><span class="s1">template.statement.ast`</span><span class="s3">\n        </span><span class="s1">Object.defineProperty(${ref}, ${id}, {</span><span class="s3">\n          </span><span class="s1">// configurable is false by default</span><span class="s3">\n          </span><span class="s1">// enumerable is false by default</span><span class="s3">\n          </span><span class="s1">// writable is false by default</span><span class="s3">\n          </span><span class="s1">get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},</span><span class="s3">\n          </span><span class="s1">set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">`,</span><span class="s3">\n      </span><span class="s1">prop,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateInstanceMethodInitSpec(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">state: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n  </span><span class="s1">const { getId, setId, initAdded } = privateName;</span><span class="s3">\n\n  </span><span class="s1">if (initAdded) return;</span><span class="s3">\n\n  </span><span class="s1">const isAccessor = getId || setId;</span><span class="s3">\n  </span><span class="s1">if (isAccessor) {</span><span class="s3">\n    </span><span class="s1">return buildPrivateAccessorInitialization(</span><span class="s3">\n      </span><span class="s1">ref,</span><span class="s3">\n      </span><span class="s1">prop,</span><span class="s3">\n      </span><span class="s1">privateNamesMap,</span><span class="s3">\n      </span><span class="s1">state,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return buildPrivateInstanceMethodInitialization(</span><span class="s3">\n    </span><span class="s1">ref,</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n    </span><span class="s1">privateNamesMap,</span><span class="s3">\n    </span><span class="s1">state,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateAccessorInitialization(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">state: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n  </span><span class="s1">const { id, getId, setId } = privateName;</span><span class="s3">\n\n  </span><span class="s1">privateNamesMap.set(prop.node.key.id.name, {</span><span class="s3">\n    </span><span class="s1">...privateName,</span><span class="s3">\n    </span><span class="s1">initAdded: true,</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">if (!state.availableHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldInitSpec</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">return inheritPropComments(</span><span class="s3">\n        </span><span class="s1">template.statement.ast`</span><span class="s3">\n          </span><span class="s1">${id}.set(${ref}, {</span><span class="s3">\n            </span><span class="s1">get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},</span><span class="s3">\n            </span><span class="s1">set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">`,</span><span class="s3">\n        </span><span class="s1">prop,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const helper = state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldInitSpec</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">return inheritPropComments(</span><span class="s3">\n    </span><span class="s1">template.statement.ast`${helper}(</span><span class="s3">\n      </span><span class="s1">${t.thisExpression()},</span><span class="s3">\n      </span><span class="s1">${t.cloneNode(id)},</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},</span><span class="s3">\n        </span><span class="s1">set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">)`,</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateInstanceMethodInitialization(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">state: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n  </span><span class="s1">const { id } = privateName;</span><span class="s3">\n\n  </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">if (!state.availableHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateMethodInitSpec</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">return inheritPropComments(</span><span class="s3">\n        </span><span class="s1">template.statement.ast`${id}.add(${ref})`,</span><span class="s3">\n        </span><span class="s1">prop,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const helper = state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateMethodInitSpec</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">return inheritPropComments(</span><span class="s3">\n    </span><span class="s1">template.statement.ast`${helper}(</span><span class="s3">\n      </span><span class="s1">${t.thisExpression()},</span><span class="s3">\n      </span><span class="s1">${t.cloneNode(id)}</span><span class="s3">\n    </span><span class="s1">)`,</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPublicFieldInitLoose(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassProperty&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { key, computed } = prop.node;</span><span class="s3">\n  </span><span class="s1">const value = prop.node.value || prop.scope.buildUndefinedNode();</span><span class="s3">\n\n  </span><span class="s1">return inheritPropComments(</span><span class="s3">\n    </span><span class="s1">t.expressionStatement(</span><span class="s3">\n      </span><span class="s1">t.assignmentExpression(</span><span class="s3">\n        \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">t.memberExpression(ref, key, computed || t.isLiteral(key)),</span><span class="s3">\n        </span><span class="s1">value,</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPublicFieldInitSpec(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassProperty&gt;,</span><span class="s3">\n  </span><span class="s1">state: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { key, computed } = prop.node;</span><span class="s3">\n  </span><span class="s1">const value = prop.node.value || prop.scope.buildUndefinedNode();</span><span class="s3">\n\n  </span><span class="s1">return inheritPropComments(</span><span class="s3">\n    </span><span class="s1">t.expressionStatement(</span><span class="s3">\n      </span><span class="s1">t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">defineProperty</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n        </span><span class="s1">ref,</span><span class="s3">\n        </span><span class="s1">computed || t.isLiteral(key)</span><span class="s3">\n          </span><span class="s1">? key</span><span class="s3">\n          </span><span class="s1">: t.stringLiteral((key as t.Identifier).name),</span><span class="s3">\n        </span><span class="s1">value,</span><span class="s3">\n      </span><span class="s1">]),</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateStaticMethodInitLoose(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n  </span><span class="s1">state: File,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n  </span><span class="s1">const { id, methodId, getId, setId, initAdded } = privateName;</span><span class="s3">\n\n  </span><span class="s1">if (initAdded) return;</span><span class="s3">\n\n  </span><span class="s1">const isAccessor = getId || setId;</span><span class="s3">\n  </span><span class="s1">if (isAccessor) {</span><span class="s3">\n    </span><span class="s1">privateNamesMap.set(prop.node.key.id.name, {</span><span class="s3">\n      </span><span class="s1">...privateName,</span><span class="s3">\n      </span><span class="s1">initAdded: true,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">return inheritPropComments(</span><span class="s3">\n      </span><span class="s1">template.statement.ast`</span><span class="s3">\n        </span><span class="s1">Object.defineProperty(${ref}, ${id}, {</span><span class="s3">\n          </span><span class="s1">// configurable is false by default</span><span class="s3">\n          </span><span class="s1">// enumerable is false by default</span><span class="s3">\n          </span><span class="s1">// writable is false by default</span><span class="s3">\n          </span><span class="s1">get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},</span><span class="s3">\n          </span><span class="s1">set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">`,</span><span class="s3">\n      </span><span class="s1">prop,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return inheritPropComments(</span><span class="s3">\n    </span><span class="s1">template.statement.ast`</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(${ref}, ${id}, {</span><span class="s3">\n        </span><span class="s1">// configurable is false by default</span><span class="s3">\n        </span><span class="s1">// enumerable is false by default</span><span class="s3">\n        </span><span class="s1">// writable is false by default</span><span class="s3">\n        </span><span class="s1">value: ${methodId.name}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">`,</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateMethodDeclaration(</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">privateFieldsAsProperties = false,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">methodId,</span><span class="s3">\n    </span><span class="s1">getId,</span><span class="s3">\n    </span><span class="s1">setId,</span><span class="s3">\n    </span><span class="s1">getterDeclared,</span><span class="s3">\n    </span><span class="s1">setterDeclared,</span><span class="s3">\n    </span><span class="s1">static: isStatic,</span><span class="s3">\n  </span><span class="s1">} = privateName;</span><span class="s3">\n  </span><span class="s1">const { params, body, generator, async } = prop.node;</span><span class="s3">\n  </span><span class="s1">const isGetter = getId &amp;&amp; !getterDeclared &amp;&amp; params.length === 0;</span><span class="s3">\n  </span><span class="s1">const isSetter = setId &amp;&amp; !setterDeclared &amp;&amp; params.length &gt; 0;</span><span class="s3">\n\n  </span><span class="s1">let declId = methodId;</span><span class="s3">\n\n  </span><span class="s1">if (isGetter) {</span><span class="s3">\n    </span><span class="s1">privateNamesMap.set(prop.node.key.id.name, {</span><span class="s3">\n      </span><span class="s1">...privateName,</span><span class="s3">\n      </span><span class="s1">getterDeclared: true,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">declId = getId;</span><span class="s3">\n  </span><span class="s1">} else if (isSetter) {</span><span class="s3">\n    </span><span class="s1">privateNamesMap.set(prop.node.key.id.name, {</span><span class="s3">\n      </span><span class="s1">...privateName,</span><span class="s3">\n      </span><span class="s1">setterDeclared: true,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">declId = setId;</span><span class="s3">\n  </span><span class="s1">} else if (isStatic &amp;&amp; !privateFieldsAsProperties) {</span><span class="s3">\n    </span><span class="s1">declId = id;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return inheritPropComments(</span><span class="s3">\n    </span><span class="s1">t.functionDeclaration(</span><span class="s3">\n      </span><span class="s1">t.cloneNode(declId),</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error params for ClassMethod has TSParameterProperty</span><span class="s3">\n      </span><span class="s1">params,</span><span class="s3">\n      </span><span class="s1">body,</span><span class="s3">\n      </span><span class="s1">generator,</span><span class="s3">\n      </span><span class="s1">async,</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ReplaceThisState = {</span><span class="s3">\n  </span><span class="s1">classRef: t.Identifier;</span><span class="s3">\n  </span><span class="s1">needsClassRef: boolean;</span><span class="s3">\n  </span><span class="s1">innerBinding: t.Identifier | null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">type ReplaceInnerBindingReferenceState = ReplaceThisState;</span><span class="s3">\n\n</span><span class="s1">const thisContextVisitor = traverse.visitors.merge&lt;ReplaceThisState&gt;([</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">UnaryExpression(path) {</span><span class="s3">\n      </span><span class="s1">// Replace `delete this` with `true`</span><span class="s3">\n      </span><span class="s1">const { node } = path;</span><span class="s3">\n      </span><span class="s1">if (node.operator === </span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const argument = skipTransparentExprWrapperNodes(node.argument);</span><span class="s3">\n        </span><span class="s1">if (t.isThisExpression(argument)) {</span><span class="s3">\n          </span><span class="s1">path.replaceWith(t.booleanLiteral(true));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">ThisExpression(path, state) {</span><span class="s3">\n      </span><span class="s1">state.needsClassRef = true;</span><span class="s3">\n      </span><span class="s1">path.replaceWith(t.cloneNode(state.classRef));</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">MetaProperty(path) {</span><span class="s3">\n      </span><span class="s1">const { node, scope } = path;</span><span class="s3">\n      </span><span class="s1">// if there are `new.target` in static field</span><span class="s3">\n      </span><span class="s1">// we should replace it with `undefined`</span><span class="s3">\n      </span><span class="s1">if (node.meta.name === </span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; node.property.name === </span><span class="s3">\&quot;</span><span class="s1">target</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">path.replaceWith(scope.buildUndefinedNode());</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">environmentVisitor,</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n\n</span><span class="s1">const innerReferencesVisitor: Visitor&lt;ReplaceInnerBindingReferenceState&gt; = {</span><span class="s3">\n  </span><span class="s1">ReferencedIdentifier(path, state) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">state.needsClassRef = true;</span><span class="s3">\n      </span><span class="s1">path.node.name = state.classRef.name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function replaceThisContext(</span><span class="s3">\n  </span><span class="s1">path: PropPath,</span><span class="s3">\n  </span><span class="s1">ref: t.Identifier,</span><span class="s3">\n  </span><span class="s1">innerBindingRef: t.Identifier | null,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const state: ReplaceThisState = {</span><span class="s3">\n    </span><span class="s1">classRef: ref,</span><span class="s3">\n    </span><span class="s1">needsClassRef: false,</span><span class="s3">\n    </span><span class="s1">innerBinding: innerBindingRef,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">if (!path.isMethod()) {</span><span class="s3">\n    </span><span class="s1">// replace `this` in property initializers and static blocks</span><span class="s3">\n    </span><span class="s1">path.traverse(thisContextVisitor, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// todo: use innerBinding.referencePaths to avoid full traversal</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">innerBindingRef != null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">state.classRef?.name &amp;&amp;</span><span class="s3">\n    </span><span class="s1">state.classRef.name !== innerBindingRef.name</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">path.traverse(innerReferencesVisitor, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return state.needsClassRef;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PropNode =</span><span class="s3">\n  </span><span class="s1">| t.ClassProperty</span><span class="s3">\n  </span><span class="s1">| t.ClassPrivateMethod</span><span class="s3">\n  </span><span class="s1">| t.ClassPrivateProperty</span><span class="s3">\n  </span><span class="s1">| t.StaticBlock;</span><span class="s3">\n</span><span class="s1">export type PropPath = NodePath&lt;PropNode&gt;;</span><span class="s3">\n\n</span><span class="s1">function isNameOrLength({ key, computed }: t.ClassProperty) {</span><span class="s3">\n  </span><span class="s1">if (key.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return !computed &amp;&amp; (key.name === </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot; </span><span class="s1">|| key.name === </span><span class="s3">\&quot;</span><span class="s1">length</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (key.type === </span><span class="s3">\&quot;</span><span class="s1">StringLiteral</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return key.value === </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot; </span><span class="s1">|| key.value === </span><span class="s3">\&quot;</span><span class="s1">length</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Inherit comments from class members. This is a reduced version of</span><span class="s3">\n </span><span class="s1">* t.inheritsComments: the trailing comments are not inherited because</span><span class="s3">\n </span><span class="s1">* for most class members except the last one, their trailing comments are</span><span class="s3">\n </span><span class="s1">* the next sibling's leading comments.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template T transformed class member type</span><span class="s3">\n </span><span class="s1">* @param {T} node transformed class member</span><span class="s3">\n </span><span class="s1">* @param {PropPath} prop class member</span><span class="s3">\n </span><span class="s1">* @returns transformed class member type with comments inherited</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function inheritPropComments&lt;T extends t.Node&gt;(node: T, prop: PropPath) {</span><span class="s3">\n  </span><span class="s1">t.inheritLeadingComments(node, prop.node);</span><span class="s3">\n  </span><span class="s1">t.inheritInnerComments(node, prop.node);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* ClassRefFlag records the requirement of the class binding reference.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @enum {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const enum ClassRefFlag {</span><span class="s3">\n  </span><span class="s1">None,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When this flag is enabled, the binding reference can be the class id,</span><span class="s3">\n   </span><span class="s1">* if exists, or the uid identifier generated for class expression. The</span><span class="s3">\n   </span><span class="s1">* reference is safe to be consumed by [[Define]].</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">ForDefine = 1 &lt;&lt; 0,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When this flag is enabled, the reference must be a uid, because the outer</span><span class="s3">\n   </span><span class="s1">* class binding can be mutated by user codes.</span><span class="s3">\n   </span><span class="s1">* E.g.</span><span class="s3">\n   </span><span class="s1">* class C { static p = C }; const oldC = C; C = null; oldC.p;</span><span class="s3">\n   </span><span class="s1">* we must memoize class `C` before defining the property `p`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">ForInnerBinding = 1 &lt;&lt; 1,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function buildFieldsInitNodes(</span><span class="s3">\n  </span><span class="s1">ref: t.Identifier | null,</span><span class="s3">\n  </span><span class="s1">superRef: t.Expression | undefined,</span><span class="s3">\n  </span><span class="s1">props: PropPath[],</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">file: File,</span><span class="s3">\n  </span><span class="s1">setPublicClassFields: boolean,</span><span class="s3">\n  </span><span class="s1">privateFieldsAsProperties: boolean,</span><span class="s3">\n  </span><span class="s1">constantSuper: boolean,</span><span class="s3">\n  </span><span class="s1">innerBindingRef: t.Identifier | null,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let classRefFlags = ClassRefFlag.None;</span><span class="s3">\n  </span><span class="s1">let injectSuperRef: t.Identifier;</span><span class="s3">\n  </span><span class="s1">const staticNodes: t.Statement[] = [];</span><span class="s3">\n  </span><span class="s1">const instanceNodes: t.Statement[] = [];</span><span class="s3">\n  </span><span class="s1">// These nodes are pure and can be moved to the closest statement position</span><span class="s3">\n  </span><span class="s1">const pureStaticNodes: t.FunctionDeclaration[] = [];</span><span class="s3">\n  </span><span class="s1">let classBindingNode: t.ExpressionStatement | null = null;</span><span class="s3">\n\n  </span><span class="s1">const getSuperRef = t.isIdentifier(superRef)</span><span class="s3">\n    </span><span class="s1">? () =&gt; superRef</span><span class="s3">\n    </span><span class="s1">: () =&gt; {</span><span class="s3">\n        </span><span class="s1">injectSuperRef ??=</span><span class="s3">\n          </span><span class="s1">props[0].scope.generateUidIdentifierBasedOnNode(superRef);</span><span class="s3">\n        </span><span class="s1">return injectSuperRef;</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">const classRefForInnerBinding =</span><span class="s3">\n    </span><span class="s1">ref ?? props[0].scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">ref ??= t.cloneNode(innerBindingRef);</span><span class="s3">\n\n  </span><span class="s1">for (const prop of props) {</span><span class="s3">\n    </span><span class="s1">prop.isClassProperty() &amp;&amp; ts.assertFieldTransformed(prop);</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error: TS doesn't infer that prop.node is not a StaticBlock</span><span class="s3">\n    </span><span class="s1">const isStatic = !t.isStaticBlock?.(prop.node) &amp;&amp; prop.node.static;</span><span class="s3">\n    </span><span class="s1">const isInstance = !isStatic;</span><span class="s3">\n    </span><span class="s1">const isPrivate = prop.isPrivate();</span><span class="s3">\n    </span><span class="s1">const isPublic = !isPrivate;</span><span class="s3">\n    </span><span class="s1">const isField = prop.isProperty();</span><span class="s3">\n    </span><span class="s1">const isMethod = !isField;</span><span class="s3">\n    </span><span class="s1">const isStaticBlock = prop.isStaticBlock?.();</span><span class="s3">\n\n    </span><span class="s1">if (isStatic) classRefFlags |= ClassRefFlag.ForDefine;</span><span class="s3">\n\n    </span><span class="s1">if (isStatic || (isMethod &amp;&amp; isPrivate) || isStaticBlock) {</span><span class="s3">\n      </span><span class="s1">new ReplaceSupers({</span><span class="s3">\n        </span><span class="s1">methodPath: prop,</span><span class="s3">\n        </span><span class="s1">constantSuper,</span><span class="s3">\n        </span><span class="s1">file: file,</span><span class="s3">\n        </span><span class="s1">refToPreserve: innerBindingRef,</span><span class="s3">\n        </span><span class="s1">getSuperRef,</span><span class="s3">\n        </span><span class="s1">getObjectRef() {</span><span class="s3">\n          </span><span class="s1">classRefFlags |= ClassRefFlag.ForInnerBinding;</span><span class="s3">\n          </span><span class="s1">if (isStatic || isStaticBlock) {</span><span class="s3">\n            </span><span class="s1">return classRefForInnerBinding;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">return t.memberExpression(</span><span class="s3">\n              </span><span class="s1">classRefForInnerBinding,</span><span class="s3">\n              </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">prototype</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">}).replace();</span><span class="s3">\n\n      </span><span class="s1">const replaced = replaceThisContext(</span><span class="s3">\n        </span><span class="s1">prop,</span><span class="s3">\n        </span><span class="s1">classRefForInnerBinding,</span><span class="s3">\n        </span><span class="s1">innerBindingRef,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (replaced) {</span><span class="s3">\n        </span><span class="s1">classRefFlags |= ClassRefFlag.ForInnerBinding;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// TODO(ts): there are so many `ts-expect-error` inside cases since</span><span class="s3">\n    </span><span class="s1">// ts can not infer type from pre-computed values (or a case test)</span><span class="s3">\n    </span><span class="s1">// even change `isStaticBlock` to `t.isStaticBlock(prop)` will not make prop</span><span class="s3">\n    </span><span class="s1">// a `NodePath&lt;t.StaticBlock&gt;`</span><span class="s3">\n    </span><span class="s1">// this maybe a bug for ts</span><span class="s3">\n    </span><span class="s1">switch (true) {</span><span class="s3">\n      </span><span class="s1">case isStaticBlock: {</span><span class="s3">\n        </span><span class="s1">const blockBody = (prop.node as t.StaticBlock).body;</span><span class="s3">\n        </span><span class="s1">// We special-case the single expression case to avoid the iife, since</span><span class="s3">\n        </span><span class="s1">// it's common.</span><span class="s3">\n        </span><span class="s1">if (blockBody.length === 1 &amp;&amp; t.isExpressionStatement(blockBody[0])) {</span><span class="s3">\n          </span><span class="s1">staticNodes.push(inheritPropComments(blockBody[0], prop));</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">staticNodes.push(</span><span class="s3">\n            </span><span class="s1">t.inheritsComments(</span><span class="s3">\n              </span><span class="s1">template.statement.ast`(() =&gt; { ${blockBody} })()`,</span><span class="s3">\n              </span><span class="s1">prop.node,</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case isStatic &amp;&amp; isPrivate &amp;&amp; isField &amp;&amp; privateFieldsAsProperties:</span><span class="s3">\n        </span><span class="s1">staticNodes.push(</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n          </span><span class="s1">buildPrivateFieldInitLoose(t.cloneNode(ref), prop, privateNamesMap),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isStatic &amp;&amp; isPrivate &amp;&amp; isField &amp;&amp; !privateFieldsAsProperties:</span><span class="s3">\n        </span><span class="s1">staticNodes.push(</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n          </span><span class="s1">buildPrivateStaticFieldInitSpec(prop, privateNamesMap),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isStatic &amp;&amp; isPublic &amp;&amp; isField &amp;&amp; setPublicClassFields:</span><span class="s3">\n        </span><span class="s1">// Functions always have non-writable .name and .length properties,</span><span class="s3">\n        </span><span class="s1">// so we must always use [[Define]] for them.</span><span class="s3">\n        </span><span class="s1">// It might still be possible to a computed static fields whose resulting</span><span class="s3">\n        </span><span class="s1">// key is </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">length</span><span class="s3">\&quot;</span><span class="s1">, but the assumption is telling us that it's</span><span class="s3">\n        </span><span class="s1">// not going to happen.</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n        </span><span class="s1">if (!isNameOrLength(prop.node)) {</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n          </span><span class="s1">staticNodes.push(buildPublicFieldInitLoose(t.cloneNode(ref), prop));</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// falls through</span><span class="s3">\n      </span><span class="s1">case isStatic &amp;&amp; isPublic &amp;&amp; isField &amp;&amp; !setPublicClassFields:</span><span class="s3">\n        </span><span class="s1">staticNodes.push(</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n          </span><span class="s1">buildPublicFieldInitSpec(t.cloneNode(ref), prop, file),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isInstance &amp;&amp; isPrivate &amp;&amp; isField &amp;&amp; privateFieldsAsProperties:</span><span class="s3">\n        </span><span class="s1">instanceNodes.push(</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n          </span><span class="s1">buildPrivateFieldInitLoose(t.thisExpression(), prop, privateNamesMap),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isInstance &amp;&amp; isPrivate &amp;&amp; isField &amp;&amp; !privateFieldsAsProperties:</span><span class="s3">\n        </span><span class="s1">instanceNodes.push(</span><span class="s3">\n          </span><span class="s1">buildPrivateInstanceFieldInitSpec(</span><span class="s3">\n            </span><span class="s1">t.thisExpression(),</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n            </span><span class="s1">prop,</span><span class="s3">\n            </span><span class="s1">privateNamesMap,</span><span class="s3">\n            </span><span class="s1">file,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isInstance &amp;&amp; isPrivate &amp;&amp; isMethod &amp;&amp; privateFieldsAsProperties:</span><span class="s3">\n        </span><span class="s1">instanceNodes.unshift(</span><span class="s3">\n          </span><span class="s1">buildPrivateMethodInitLoose(</span><span class="s3">\n            </span><span class="s1">t.thisExpression(),</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n            </span><span class="s1">prop,</span><span class="s3">\n            </span><span class="s1">privateNamesMap,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">pureStaticNodes.push(</span><span class="s3">\n          </span><span class="s1">buildPrivateMethodDeclaration(</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n            </span><span class="s1">prop,</span><span class="s3">\n            </span><span class="s1">privateNamesMap,</span><span class="s3">\n            </span><span class="s1">privateFieldsAsProperties,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isInstance &amp;&amp; isPrivate &amp;&amp; isMethod &amp;&amp; !privateFieldsAsProperties:</span><span class="s3">\n        </span><span class="s1">instanceNodes.unshift(</span><span class="s3">\n          </span><span class="s1">buildPrivateInstanceMethodInitSpec(</span><span class="s3">\n            </span><span class="s1">t.thisExpression(),</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n            </span><span class="s1">prop,</span><span class="s3">\n            </span><span class="s1">privateNamesMap,</span><span class="s3">\n            </span><span class="s1">file,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">pureStaticNodes.push(</span><span class="s3">\n          </span><span class="s1">buildPrivateMethodDeclaration(</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n            </span><span class="s1">prop,</span><span class="s3">\n            </span><span class="s1">privateNamesMap,</span><span class="s3">\n            </span><span class="s1">privateFieldsAsProperties,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isStatic &amp;&amp; isPrivate &amp;&amp; isMethod &amp;&amp; !privateFieldsAsProperties:</span><span class="s3">\n        </span><span class="s1">staticNodes.unshift(</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n          </span><span class="s1">buildPrivateStaticFieldInitSpec(prop, privateNamesMap),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">pureStaticNodes.push(</span><span class="s3">\n          </span><span class="s1">buildPrivateMethodDeclaration(</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n            </span><span class="s1">prop,</span><span class="s3">\n            </span><span class="s1">privateNamesMap,</span><span class="s3">\n            </span><span class="s1">privateFieldsAsProperties,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isStatic &amp;&amp; isPrivate &amp;&amp; isMethod &amp;&amp; privateFieldsAsProperties:</span><span class="s3">\n        </span><span class="s1">staticNodes.unshift(</span><span class="s3">\n          </span><span class="s1">buildPrivateStaticMethodInitLoose(</span><span class="s3">\n            </span><span class="s1">t.cloneNode(ref),</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n            </span><span class="s1">prop,</span><span class="s3">\n            </span><span class="s1">file,</span><span class="s3">\n            </span><span class="s1">privateNamesMap,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">pureStaticNodes.push(</span><span class="s3">\n          </span><span class="s1">buildPrivateMethodDeclaration(</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n            </span><span class="s1">prop,</span><span class="s3">\n            </span><span class="s1">privateNamesMap,</span><span class="s3">\n            </span><span class="s1">privateFieldsAsProperties,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isInstance &amp;&amp; isPublic &amp;&amp; isField &amp;&amp; setPublicClassFields:</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n        </span><span class="s1">instanceNodes.push(buildPublicFieldInitLoose(t.thisExpression(), prop));</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isInstance &amp;&amp; isPublic &amp;&amp; isField &amp;&amp; !setPublicClassFields:</span><span class="s3">\n        </span><span class="s1">instanceNodes.push(</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n          </span><span class="s1">buildPublicFieldInitSpec(t.thisExpression(), prop, file),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Unreachable.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (classRefFlags &amp; ClassRefFlag.ForInnerBinding &amp;&amp; innerBindingRef != null) {</span><span class="s3">\n    </span><span class="s1">classBindingNode = t.expressionStatement(</span><span class="s3">\n      </span><span class="s1">t.assignmentExpression(</span><span class="s3">\n        \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">t.cloneNode(classRefForInnerBinding),</span><span class="s3">\n        </span><span class="s1">t.cloneNode(innerBindingRef),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">staticNodes: staticNodes.filter(Boolean),</span><span class="s3">\n    </span><span class="s1">instanceNodes: instanceNodes.filter(Boolean),</span><span class="s3">\n    </span><span class="s1">pureStaticNodes: pureStaticNodes.filter(Boolean),</span><span class="s3">\n    </span><span class="s1">classBindingNode,</span><span class="s3">\n    </span><span class="s1">wrapClass(path: NodePath&lt;t.Class&gt;) {</span><span class="s3">\n      </span><span class="s1">for (const prop of props) {</span><span class="s3">\n        </span><span class="s1">// Delete leading comments so that they don't get attached as</span><span class="s3">\n        </span><span class="s1">// trailing comments of the previous sibling.</span><span class="s3">\n        </span><span class="s1">// When transforming props, we explicitly attach their leading</span><span class="s3">\n        </span><span class="s1">// comments to the transformed node with `inheritPropComments`</span><span class="s3">\n        </span><span class="s1">// above.</span><span class="s3">\n        </span><span class="s1">prop.node.leadingComments = null;</span><span class="s3">\n        </span><span class="s1">prop.remove();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (injectSuperRef) {</span><span class="s3">\n        </span><span class="s1">path.scope.push({ id: t.cloneNode(injectSuperRef) });</span><span class="s3">\n        </span><span class="s1">path.set(</span><span class="s3">\n          \&quot;</span><span class="s1">superClass</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, injectSuperRef, path.node.superClass),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (classRefFlags !== ClassRefFlag.None) {</span><span class="s3">\n        </span><span class="s1">if (path.isClassExpression()) {</span><span class="s3">\n          </span><span class="s1">path.scope.push({ id: ref });</span><span class="s3">\n          </span><span class="s1">path.replaceWith(</span><span class="s3">\n            </span><span class="s1">t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, t.cloneNode(ref), path.node),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">if (innerBindingRef == null) {</span><span class="s3">\n            </span><span class="s1">// export anonymous class declaration</span><span class="s3">\n            </span><span class="s1">path.node.id = ref;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (classBindingNode != null) {</span><span class="s3">\n            </span><span class="s1">path.scope.push({ id: classRefForInnerBinding });</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return path;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>