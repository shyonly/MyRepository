<html>
<head>
<title>uri.all.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
uri.all.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;uri.all.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/index.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/schemes/urn-uuid.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/schemes/urn.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/schemes/mailto.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/schemes/wss.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/schemes/ws.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/schemes/https.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/schemes/http.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/uri.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../node_modules/punycode/punycode.es6.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/regexps-iri.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/regexps-uri.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/util.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { SCHEMES } from </span><span class="s3">\&quot;</span><span class="s1">./uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import http from </span><span class="s3">\&quot;</span><span class="s1">./schemes/http</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">SCHEMES[http.scheme] = http;</span><span class="s3">\n\n</span><span class="s1">import https from </span><span class="s3">\&quot;</span><span class="s1">./schemes/https</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">SCHEMES[https.scheme] = https;</span><span class="s3">\n\n</span><span class="s1">import ws from </span><span class="s3">\&quot;</span><span class="s1">./schemes/ws</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">SCHEMES[ws.scheme] = ws;</span><span class="s3">\n\n</span><span class="s1">import wss from </span><span class="s3">\&quot;</span><span class="s1">./schemes/wss</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">SCHEMES[wss.scheme] = wss;</span><span class="s3">\n\n</span><span class="s1">import mailto from </span><span class="s3">\&quot;</span><span class="s1">./schemes/mailto</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">SCHEMES[mailto.scheme] = mailto;</span><span class="s3">\n\n</span><span class="s1">import urn from </span><span class="s3">\&quot;</span><span class="s1">./schemes/urn</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">SCHEMES[urn.scheme] = urn;</span><span class="s3">\n\n</span><span class="s1">import uuid from </span><span class="s3">\&quot;</span><span class="s1">./schemes/urn-uuid</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">SCHEMES[uuid.scheme] = uuid;</span><span class="s3">\n\n</span><span class="s1">export * from </span><span class="s3">\&quot;</span><span class="s1">./uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URISchemeHandler, URIComponents, URIOptions } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { URNComponents } from </span><span class="s3">\&quot;</span><span class="s1">./urn</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { SCHEMES } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export interface UUIDComponents extends URNComponents {</span><span class="s3">\n\t</span><span class="s1">uuid?: string;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const UUID = /^[0-9A-Fa-f]{8}(?:</span><span class="s3">\\</span><span class="s1">-[0-9A-Fa-f]{4}){3}</span><span class="s3">\\</span><span class="s1">-[0-9A-Fa-f]{12}$/;</span><span class="s3">\n</span><span class="s1">const UUID_PARSE = /^[0-9A-Fa-f</span><span class="s3">\\</span><span class="s1">-]{36}/;</span><span class="s3">\n\n</span><span class="s1">//RFC 4122</span><span class="s3">\n</span><span class="s1">const handler:URISchemeHandler&lt;UUIDComponents, URIOptions, URNComponents&gt; = {</span><span class="s3">\n\t</span><span class="s1">scheme : </span><span class="s3">\&quot;</span><span class="s1">urn:uuid</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n\t</span><span class="s1">parse : function (urnComponents:URNComponents, options:URIOptions):UUIDComponents {</span><span class="s3">\n\t\t</span><span class="s1">const uuidComponents = urnComponents as UUIDComponents;</span><span class="s3">\n\t\t</span><span class="s1">uuidComponents.uuid = uuidComponents.nss;</span><span class="s3">\n\t\t</span><span class="s1">uuidComponents.nss = undefined;</span><span class="s3">\n\n\t\t</span><span class="s1">if (!options.tolerant &amp;&amp; (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {</span><span class="s3">\n\t\t\t</span><span class="s1">uuidComponents.error = uuidComponents.error || </span><span class="s3">\&quot;</span><span class="s1">UUID is not valid.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return uuidComponents;</span><span class="s3">\n\t</span><span class="s1">},</span><span class="s3">\n\n\t</span><span class="s1">serialize : function (uuidComponents:UUIDComponents, options:URIOptions):URNComponents {</span><span class="s3">\n\t\t</span><span class="s1">const urnComponents = uuidComponents as URNComponents;</span><span class="s3">\n\t\t</span><span class="s1">//normalize UUID</span><span class="s3">\n\t\t</span><span class="s1">urnComponents.nss = (uuidComponents.uuid || </span><span class="s3">\&quot;\&quot;</span><span class="s1">).toLowerCase();</span><span class="s3">\n\t\t</span><span class="s1">return urnComponents;</span><span class="s3">\n\t</span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default handler;&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URISchemeHandler, URIComponents, URIOptions } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { pctEncChar, SCHEMES } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export interface URNComponents extends URIComponents {</span><span class="s3">\n\t</span><span class="s1">nid?:string;</span><span class="s3">\n\t</span><span class="s1">nss?:string;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface URNOptions extends URIOptions {</span><span class="s3">\n\t</span><span class="s1">nid?:string;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const NID$ = </span><span class="s3">\&quot;</span><span class="s1">(?:[0-9A-Za-z][0-9A-Za-z</span><span class="s3">\\\\</span><span class="s1">-]{1,31})</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const PCT_ENCODED$ = </span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\\\\</span><span class="s1">%[0-9A-Fa-f]{2})</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const TRANS$$ = </span><span class="s3">\&quot;</span><span class="s1">[0-9A-Za-z</span><span class="s3">\\\\</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">)</span><span class="s3">\\\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">,</span><span class="s3">\\\\</span><span class="s1">-</span><span class="s3">\\\\</span><span class="s1">.</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">=</span><span class="s3">\\\\</span><span class="s1">@</span><span class="s3">\\\\</span><span class="s1">;</span><span class="s3">\\\\</span><span class="s1">$</span><span class="s3">\\\\</span><span class="s1">_</span><span class="s3">\\\\</span><span class="s1">!</span><span class="s3">\\\\</span><span class="s1">*</span><span class="s3">\\\\</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">#]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const NSS$ = </span><span class="s3">\&quot;</span><span class="s1">(?:(?:</span><span class="s3">\&quot; </span><span class="s1">+ PCT_ENCODED$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ TRANS$$ + </span><span class="s3">\&quot;</span><span class="s1">)+)</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const URN_SCHEME = new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^urn</span><span class="s3">\\\\</span><span class="s1">:(</span><span class="s3">\&quot; </span><span class="s1">+ NID$ + </span><span class="s3">\&quot;</span><span class="s1">)$</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const URN_PATH = new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^(</span><span class="s3">\&quot; </span><span class="s1">+ NID$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\\\\</span><span class="s1">:(</span><span class="s3">\&quot; </span><span class="s1">+ NSS$ + </span><span class="s3">\&quot;</span><span class="s1">)$</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const URN_PARSE = /^([^</span><span class="s3">\\</span><span class="s1">:]+)</span><span class="s3">\\</span><span class="s1">:(.*)/;</span><span class="s3">\n</span><span class="s1">const URN_EXCLUDED = /[</span><span class="s3">\\</span><span class="s1">x00-</span><span class="s3">\\</span><span class="s1">x20</span><span class="s3">\\\\\\\&quot;\\</span><span class="s1">&amp;</span><span class="s3">\\</span><span class="s1">&lt;</span><span class="s3">\\</span><span class="s1">&gt;</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">^</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">{</span><span class="s3">\\</span><span class="s1">|</span><span class="s3">\\</span><span class="s1">}</span><span class="s3">\\</span><span class="s1">~</span><span class="s3">\\</span><span class="s1">x7F-</span><span class="s3">\\</span><span class="s1">xFF]/g;</span><span class="s3">\n\n</span><span class="s1">//RFC 2141</span><span class="s3">\n</span><span class="s1">const handler:URISchemeHandler&lt;URNComponents,URNOptions&gt; = {</span><span class="s3">\n\t</span><span class="s1">scheme : </span><span class="s3">\&quot;</span><span class="s1">urn</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n\t</span><span class="s1">parse : function (components:URIComponents, options:URNOptions):URNComponents {</span><span class="s3">\n\t\t</span><span class="s1">const matches = components.path &amp;&amp; components.path.match(URN_PARSE);</span><span class="s3">\n\t\t</span><span class="s1">let urnComponents = components as URNComponents;</span><span class="s3">\n\n\t\t</span><span class="s1">if (matches) {</span><span class="s3">\n\t\t\t</span><span class="s1">const scheme = options.scheme || urnComponents.scheme || </span><span class="s3">\&quot;</span><span class="s1">urn</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t\t</span><span class="s1">const nid = matches[1].toLowerCase();</span><span class="s3">\n\t\t\t</span><span class="s1">const nss = matches[2];</span><span class="s3">\n\t\t\t</span><span class="s1">const urnScheme = `${scheme}:${options.nid || nid}`;</span><span class="s3">\n\t\t\t</span><span class="s1">const schemeHandler = SCHEMES[urnScheme];</span><span class="s3">\n\n\t\t\t</span><span class="s1">urnComponents.nid = nid;</span><span class="s3">\n\t\t\t</span><span class="s1">urnComponents.nss = nss;</span><span class="s3">\n\t\t\t</span><span class="s1">urnComponents.path = undefined;</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (schemeHandler) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">urnComponents = schemeHandler.parse(urnComponents, options) as URNComponents;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">urnComponents.error = urnComponents.error || </span><span class="s3">\&quot;</span><span class="s1">URN can not be parsed.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return urnComponents;</span><span class="s3">\n\t</span><span class="s1">},</span><span class="s3">\n\n\t</span><span class="s1">serialize : function (urnComponents:URNComponents, options:URNOptions):URIComponents {</span><span class="s3">\n\t\t</span><span class="s1">const scheme = options.scheme || urnComponents.scheme || </span><span class="s3">\&quot;</span><span class="s1">urn</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">const nid = urnComponents.nid;</span><span class="s3">\n\t\t</span><span class="s1">const urnScheme = `${scheme}:${options.nid || nid}`;</span><span class="s3">\n\t\t</span><span class="s1">const schemeHandler = SCHEMES[urnScheme];</span><span class="s3">\n\n\t\t</span><span class="s1">if (schemeHandler) {</span><span class="s3">\n\t\t\t</span><span class="s1">urnComponents = schemeHandler.serialize(urnComponents, options) as URNComponents;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">const uriComponents = urnComponents as URIComponents;</span><span class="s3">\n\t\t</span><span class="s1">const nss = urnComponents.nss;</span><span class="s3">\n\t\t</span><span class="s1">uriComponents.path = `${nid || options.nid}:${nss}`;</span><span class="s3">\n\n\t\t</span><span class="s1">return uriComponents;</span><span class="s3">\n\t</span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default handler;&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URISchemeHandler, URIComponents, URIOptions } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { pctEncChar, pctDecChars, unescapeComponent } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import punycode from </span><span class="s3">\&quot;</span><span class="s1">punycode</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { merge, subexp, toUpperCase, toArray } from </span><span class="s3">\&quot;</span><span class="s1">../util</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export interface MailtoHeaders {</span><span class="s3">\n\t</span><span class="s1">[hfname:string]:string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface MailtoComponents extends URIComponents {</span><span class="s3">\n\t</span><span class="s1">to:Array&lt;string&gt;,</span><span class="s3">\n\t</span><span class="s1">headers?:MailtoHeaders,</span><span class="s3">\n\t</span><span class="s1">subject?:string,</span><span class="s3">\n\t</span><span class="s1">body?:string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const O:MailtoHeaders = {};</span><span class="s3">\n</span><span class="s1">const isIRI = true;</span><span class="s3">\n\n</span><span class="s1">//RFC 3986</span><span class="s3">\n</span><span class="s1">const UNRESERVED$$ = </span><span class="s3">\&quot;</span><span class="s1">[A-Za-z0-9</span><span class="s3">\\\\</span><span class="s1">-</span><span class="s3">\\\\</span><span class="s1">.</span><span class="s3">\\\\</span><span class="s1">_</span><span class="s3">\\\\</span><span class="s1">~</span><span class="s3">\&quot; </span><span class="s1">+ (isIRI ? </span><span class="s3">\&quot;\\\\</span><span class="s1">xA0-</span><span class="s3">\\\\</span><span class="s1">u200D</span><span class="s3">\\\\</span><span class="s1">u2010-</span><span class="s3">\\\\</span><span class="s1">u2029</span><span class="s3">\\\\</span><span class="s1">u202F-</span><span class="s3">\\\\</span><span class="s1">uD7FF</span><span class="s3">\\\\</span><span class="s1">uF900-</span><span class="s3">\\\\</span><span class="s1">uFDCF</span><span class="s3">\\\\</span><span class="s1">uFDF0-</span><span class="s3">\\\\</span><span class="s1">uFFEF</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const HEXDIG$$ = </span><span class="s3">\&quot;</span><span class="s1">[0-9A-Fa-f]</span><span class="s3">\&quot;</span><span class="s1">;  //case-insensitive</span><span class="s3">\n</span><span class="s1">const PCT_ENCODED$ = subexp(subexp(</span><span class="s3">\&quot;</span><span class="s1">%[EFef]</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">%[89A-Fa-f]</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$));  //expanded</span><span class="s3">\n\n</span><span class="s1">//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] &amp; ; =</span><span class="s3">\n</span><span class="s1">//const ATEXT$$ = </span><span class="s3">\&quot;</span><span class="s1">[A-Za-z0-9</span><span class="s3">\\\\</span><span class="s1">!</span><span class="s3">\\\\</span><span class="s1">#</span><span class="s3">\\\\</span><span class="s1">$</span><span class="s3">\\\\</span><span class="s1">%</span><span class="s3">\\\\</span><span class="s1">&amp;</span><span class="s3">\\\\</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">*</span><span class="s3">\\\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">-</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">=</span><span class="s3">\\\\</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">^</span><span class="s3">\\\\</span><span class="s1">_</span><span class="s3">\\\\</span><span class="s1">`</span><span class="s3">\\\\</span><span class="s1">{</span><span class="s3">\\\\</span><span class="s1">|</span><span class="s3">\\\\</span><span class="s1">}</span><span class="s3">\\\\</span><span class="s1">~]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">//const WSP$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x20</span><span class="s3">\\\\</span><span class="s1">x09]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">//const OBS_QTEXT$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x01-</span><span class="s3">\\\\</span><span class="s1">x08</span><span class="s3">\\\\</span><span class="s1">x0B</span><span class="s3">\\\\</span><span class="s1">x0C</span><span class="s3">\\\\</span><span class="s1">x0E-</span><span class="s3">\\\\</span><span class="s1">x1F</span><span class="s3">\\\\</span><span class="s1">x7F]</span><span class="s3">\&quot;</span><span class="s1">;  //(%d1-8 / %d11-12 / %d14-31 / %d127)</span><span class="s3">\n</span><span class="s1">//const QTEXT$$ = merge(</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x21</span><span class="s3">\\\\</span><span class="s1">x23-</span><span class="s3">\\\\</span><span class="s1">x5B</span><span class="s3">\\\\</span><span class="s1">x5D-</span><span class="s3">\\\\</span><span class="s1">x7E]</span><span class="s3">\&quot;</span><span class="s1">, OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext</span><span class="s3">\n</span><span class="s1">//const VCHAR$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x21-</span><span class="s3">\\\\</span><span class="s1">x7E]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">//const WSP$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x20</span><span class="s3">\\\\</span><span class="s1">x09]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">//const OBS_QP$ = subexp(</span><span class="s3">\&quot;\\\\\\\\\&quot; </span><span class="s1">+ merge(</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x00</span><span class="s3">\\\\</span><span class="s1">x0D</span><span class="s3">\\\\</span><span class="s1">x0A]</span><span class="s3">\&quot;</span><span class="s1">, OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext</span><span class="s3">\n</span><span class="s1">//const FWS$ = subexp(subexp(WSP$$ + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot; </span><span class="s1">+ </span><span class="s3">\&quot;\\\\</span><span class="s1">x0D</span><span class="s3">\\\\</span><span class="s1">x0A</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ WSP$$ + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">//const QUOTED_PAIR$ = subexp(subexp(</span><span class="s3">\&quot;\\\\\\\\\&quot; </span><span class="s1">+ subexp(VCHAR$$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ WSP$$)) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ OBS_QP$);</span><span class="s3">\n</span><span class="s1">//const QUOTED_STRING$ = subexp('</span><span class="s3">\\\\\&quot;</span><span class="s1">' + subexp(FWS$ + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ QCONTENT$) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot; </span><span class="s1">+ FWS$ + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ '</span><span class="s3">\\\\\&quot;</span><span class="s1">');</span><span class="s3">\n</span><span class="s1">const ATEXT$$ = </span><span class="s3">\&quot;</span><span class="s1">[A-Za-z0-9</span><span class="s3">\\\\</span><span class="s1">!</span><span class="s3">\\\\</span><span class="s1">$</span><span class="s3">\\\\</span><span class="s1">%</span><span class="s3">\\\\</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">*</span><span class="s3">\\\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">-</span><span class="s3">\\\\</span><span class="s1">^</span><span class="s3">\\\\</span><span class="s1">_</span><span class="s3">\\\\</span><span class="s1">`</span><span class="s3">\\\\</span><span class="s1">{</span><span class="s3">\\\\</span><span class="s1">|</span><span class="s3">\\\\</span><span class="s1">}</span><span class="s3">\\\\</span><span class="s1">~]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const QTEXT$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">!</span><span class="s3">\\\\</span><span class="s1">$</span><span class="s3">\\\\</span><span class="s1">%</span><span class="s3">\\\\</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">)</span><span class="s3">\\\\</span><span class="s1">*</span><span class="s3">\\\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">,</span><span class="s3">\\\\</span><span class="s1">-</span><span class="s3">\\\\</span><span class="s1">.0-9</span><span class="s3">\\\\</span><span class="s1">&lt;</span><span class="s3">\\\\</span><span class="s1">&gt;A-Z</span><span class="s3">\\\\</span><span class="s1">x5E-</span><span class="s3">\\\\</span><span class="s1">x7E]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const VCHAR$$ = merge(QTEXT$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\\\\&quot;\\\\\\\\</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const DOT_ATOM_TEXT$ = subexp(ATEXT$$ + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">+ ATEXT$$ + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const QUOTED_PAIR$ = subexp(</span><span class="s3">\&quot;\\\\\\\\\&quot; </span><span class="s1">+ VCHAR$$);</span><span class="s3">\n</span><span class="s1">const QCONTENT$ = subexp(QTEXT$$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ QUOTED_PAIR$);</span><span class="s3">\n</span><span class="s1">const QUOTED_STRING$ = subexp('</span><span class="s3">\\\\\&quot;</span><span class="s1">' + QCONTENT$ + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot; </span><span class="s1">+ '</span><span class="s3">\\\\\&quot;</span><span class="s1">');</span><span class="s3">\n\n</span><span class="s1">//RFC 6068</span><span class="s3">\n</span><span class="s1">const DTEXT_NO_OBS$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x21-</span><span class="s3">\\\\</span><span class="s1">x5A</span><span class="s3">\\\\</span><span class="s1">x5E-</span><span class="s3">\\\\</span><span class="s1">x7E]</span><span class="s3">\&quot;</span><span class="s1">;  //%d33-90 / %d94-126</span><span class="s3">\n</span><span class="s1">const SOME_DELIMS$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">!</span><span class="s3">\\\\</span><span class="s1">$</span><span class="s3">\\\\</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">)</span><span class="s3">\\\\</span><span class="s1">*</span><span class="s3">\\\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">,</span><span class="s3">\\\\</span><span class="s1">;</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">@]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const QCHAR$ = subexp(UNRESERVED$$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PCT_ENCODED$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ SOME_DELIMS$$);</span><span class="s3">\n</span><span class="s1">const DOMAIN$ = subexp(DOT_ATOM_TEXT$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ </span><span class="s3">\&quot;\\\\</span><span class="s1">[</span><span class="s3">\&quot; </span><span class="s1">+ DTEXT_NO_OBS$$ + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot; </span><span class="s1">+ </span><span class="s3">\&quot;\\\\</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ QUOTED_STRING$);</span><span class="s3">\n</span><span class="s1">const ADDR_SPEC$ = subexp(LOCAL_PART$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">@</span><span class="s3">\&quot; </span><span class="s1">+ DOMAIN$);</span><span class="s3">\n</span><span class="s1">const TO$ = subexp(ADDR_SPEC$ + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ ADDR_SPEC$) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const HFNAME$ = subexp(QCHAR$ + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const HFVALUE$ = HFNAME$;</span><span class="s3">\n</span><span class="s1">const HFIELD$ = subexp(HFNAME$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">=</span><span class="s3">\&quot; </span><span class="s1">+ HFVALUE$);</span><span class="s3">\n</span><span class="s1">const HFIELDS2$ = subexp(HFIELD$ + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">&amp;</span><span class="s3">\&quot; </span><span class="s1">+ HFIELD$) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const HFIELDS$ = subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ HFIELDS2$);</span><span class="s3">\n</span><span class="s1">const MAILTO_URI = new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^mailto</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ TO$ + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ HFIELDS$ + </span><span class="s3">\&quot;</span><span class="s1">?$</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">const UNRESERVED = new RegExp(UNRESERVED$$, </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const PCT_ENCODED = new RegExp(PCT_ENCODED$, </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const NOT_LOCAL_PART = new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^]</span><span class="s3">\&quot;</span><span class="s1">, ATEXT$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">.]</span><span class="s3">\&quot;</span><span class="s1">, '[</span><span class="s3">\\\\\&quot;</span><span class="s1">]', VCHAR$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const NOT_DOMAIN = new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^]</span><span class="s3">\&quot;</span><span class="s1">, ATEXT$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">.]</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">[]</span><span class="s3">\&quot;</span><span class="s1">, DTEXT_NO_OBS$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">]]</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const NOT_HFNAME = new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, SOME_DELIMS$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const NOT_HFVALUE = NOT_HFNAME;</span><span class="s3">\n</span><span class="s1">const TO = new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot; </span><span class="s1">+ TO$ + </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const HFIELDS = new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot; </span><span class="s1">+ HFIELDS2$ + </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">function decodeUnreserved(str:string):string {</span><span class="s3">\n\t</span><span class="s1">const decStr = pctDecChars(str);</span><span class="s3">\n\t</span><span class="s1">return (!decStr.match(UNRESERVED) ? str : decStr);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const handler:URISchemeHandler&lt;MailtoComponents&gt; =  {</span><span class="s3">\n\t</span><span class="s1">scheme : </span><span class="s3">\&quot;</span><span class="s1">mailto</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n\t</span><span class="s1">parse : function (components:URIComponents, options:URIOptions):MailtoComponents {</span><span class="s3">\n\t\t</span><span class="s1">const mailtoComponents = components as MailtoComponents;</span><span class="s3">\n\t\t</span><span class="s1">const to = mailtoComponents.to = (mailtoComponents.path ? mailtoComponents.path.split(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) : []);</span><span class="s3">\n\t\t</span><span class="s1">mailtoComponents.path = undefined;</span><span class="s3">\n\n\t\t</span><span class="s1">if (mailtoComponents.query) {</span><span class="s3">\n\t\t\t</span><span class="s1">let unknownHeaders = false</span><span class="s3">\n\t\t\t</span><span class="s1">const headers:MailtoHeaders = {};</span><span class="s3">\n\t\t\t</span><span class="s1">const hfields = mailtoComponents.query.split(</span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n\t\t\t</span><span class="s1">for (let x = 0, xl = hfields.length; x &lt; xl; ++x) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const hfield = hfields[x].split(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">switch (hfield[0]) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">to</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">const toAddrs = hfield[1].split(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">for (let x = 0, xl = toAddrs.length; x &lt; xl; ++x) {</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">to.push(toAddrs[x]);</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">subject</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">mailtoComponents.subject = unescapeComponent(hfield[1], options);</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">mailtoComponents.body = unescapeComponent(hfield[1], options);</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">default:</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">unknownHeaders = true;</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (unknownHeaders) mailtoComponents.headers = headers;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">mailtoComponents.query = undefined;</span><span class="s3">\n\n\t\t</span><span class="s1">for (let x = 0, xl = to.length; x &lt; xl; ++x) {</span><span class="s3">\n\t\t\t</span><span class="s1">const addr = to[x].split(</span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n\t\t\t</span><span class="s1">addr[0] = unescapeComponent(addr[0]);</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (!options.unicodeSupport) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">//convert Unicode IDN -&gt; ASCII IDN</span><span class="s3">\n\t\t\t\t</span><span class="s1">try {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());</span><span class="s3">\n\t\t\t\t</span><span class="s1">} catch (e) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">mailtoComponents.error = mailtoComponents.error || </span><span class="s3">\&quot;</span><span class="s1">Email address's domain name can not be converted to ASCII via punycode: </span><span class="s3">\&quot; </span><span class="s1">+ e;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">addr[1] = unescapeComponent(addr[1], options).toLowerCase();</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">to[x] = addr.join(</span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return mailtoComponents;</span><span class="s3">\n\t</span><span class="s1">},</span><span class="s3">\n\n\t</span><span class="s1">serialize : function (mailtoComponents:MailtoComponents, options:URIOptions):URIComponents {</span><span class="s3">\n\t\t</span><span class="s1">const components = mailtoComponents as URIComponents;</span><span class="s3">\n\t\t</span><span class="s1">const to = toArray(mailtoComponents.to);</span><span class="s3">\n\t\t</span><span class="s1">if (to) {</span><span class="s3">\n\t\t\t</span><span class="s1">for (let x = 0, xl = to.length; x &lt; xl; ++x) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const toAddr = String(to[x]);</span><span class="s3">\n\t\t\t\t</span><span class="s1">const atIdx = toAddr.lastIndexOf(</span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t\t\t</span><span class="s1">const localPart = (toAddr.slice(0, atIdx)).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);</span><span class="s3">\n\t\t\t\t</span><span class="s1">let domain = toAddr.slice(atIdx + 1);</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">//convert IDN via punycode</span><span class="s3">\n\t\t\t\t</span><span class="s1">try {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">domain = (!options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain));</span><span class="s3">\n\t\t\t\t</span><span class="s1">} catch (e) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">components.error = components.error || </span><span class="s3">\&quot;</span><span class="s1">Email address's domain name can not be converted to </span><span class="s3">\&quot; </span><span class="s1">+ (!options.iri ? </span><span class="s3">\&quot;</span><span class="s1">ASCII</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">Unicode</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot; </span><span class="s1">via punycode: </span><span class="s3">\&quot; </span><span class="s1">+ e;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">to[x] = localPart + </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot; </span><span class="s1">+ domain;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">components.path = to.join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">const headers = mailtoComponents.headers = mailtoComponents.headers || {};</span><span class="s3">\n\n\t\t</span><span class="s1">if (mailtoComponents.subject) headers[</span><span class="s3">\&quot;</span><span class="s1">subject</span><span class="s3">\&quot;</span><span class="s1">] = mailtoComponents.subject;</span><span class="s3">\n\t\t</span><span class="s1">if (mailtoComponents.body) headers[</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">] = mailtoComponents.body;</span><span class="s3">\n\n\t\t</span><span class="s1">const fields = [];</span><span class="s3">\n\t\t</span><span class="s1">for (const name in headers) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (headers[name] !== O[name]) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">fields.push(</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) +</span><span class="s3">\n\t\t\t\t\t\&quot;</span><span class="s1">=</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar)</span><span class="s3">\n\t\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">if (fields.length) {</span><span class="s3">\n\t\t\t</span><span class="s1">components.query = fields.join(</span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return components;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default handler;&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URISchemeHandler, URIComponents, URIOptions } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import ws from </span><span class="s3">\&quot;</span><span class="s1">./ws</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const handler:URISchemeHandler = {</span><span class="s3">\n\t</span><span class="s1">scheme : </span><span class="s3">\&quot;</span><span class="s1">wss</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t</span><span class="s1">domainHost : ws.domainHost,</span><span class="s3">\n\t</span><span class="s1">parse : ws.parse,</span><span class="s3">\n\t</span><span class="s1">serialize : ws.serialize</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default handler;&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URISchemeHandler, URIComponents, URIOptions } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export interface WSComponents extends URIComponents {</span><span class="s3">\n\t</span><span class="s1">resourceName?: string;</span><span class="s3">\n\t</span><span class="s1">secure?: boolean;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isSecure(wsComponents:WSComponents):boolean {</span><span class="s3">\n\t</span><span class="s1">return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === </span><span class="s3">\&quot;</span><span class="s1">wss</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">//RFC 6455</span><span class="s3">\n</span><span class="s1">const handler:URISchemeHandler = {</span><span class="s3">\n\t</span><span class="s1">scheme : </span><span class="s3">\&quot;</span><span class="s1">ws</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n\t</span><span class="s1">domainHost : true,</span><span class="s3">\n\n\t</span><span class="s1">parse : function (components:URIComponents, options:URIOptions):WSComponents {</span><span class="s3">\n\t\t</span><span class="s1">const wsComponents = components as WSComponents;</span><span class="s3">\n\n\t\t</span><span class="s1">//indicate if the secure flag is set</span><span class="s3">\n\t\t</span><span class="s1">wsComponents.secure = isSecure(wsComponents);</span><span class="s3">\n\n\t\t</span><span class="s1">//construct resouce name</span><span class="s3">\n\t\t</span><span class="s1">wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');</span><span class="s3">\n\t\t</span><span class="s1">wsComponents.path = undefined;</span><span class="s3">\n\t\t</span><span class="s1">wsComponents.query = undefined;</span><span class="s3">\n\n\t\t</span><span class="s1">return wsComponents;</span><span class="s3">\n\t</span><span class="s1">},</span><span class="s3">\n\n\t</span><span class="s1">serialize : function (wsComponents:WSComponents, options:URIOptions):URIComponents {</span><span class="s3">\n\t\t</span><span class="s1">//normalize the default port</span><span class="s3">\n\t\t</span><span class="s1">if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === </span><span class="s3">\&quot;\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t\t</span><span class="s1">wsComponents.port = undefined;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//ensure scheme matches secure flag</span><span class="s3">\n\t\t</span><span class="s1">if (typeof wsComponents.secure === 'boolean') {</span><span class="s3">\n\t\t\t</span><span class="s1">wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws');</span><span class="s3">\n\t\t\t</span><span class="s1">wsComponents.secure = undefined;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//reconstruct path from resource name</span><span class="s3">\n\t\t</span><span class="s1">if (wsComponents.resourceName) {</span><span class="s3">\n\t\t\t</span><span class="s1">const [path, query] = wsComponents.resourceName.split('?');</span><span class="s3">\n\t\t\t</span><span class="s1">wsComponents.path = (path &amp;&amp; path !== '/' ? path : undefined);</span><span class="s3">\n\t\t\t</span><span class="s1">wsComponents.query = query;</span><span class="s3">\n\t\t\t</span><span class="s1">wsComponents.resourceName = undefined;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//forbid fragment component</span><span class="s3">\n\t\t</span><span class="s1">wsComponents.fragment = undefined;</span><span class="s3">\n\n\t\t</span><span class="s1">return wsComponents;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default handler;&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URISchemeHandler, URIComponents, URIOptions } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import http from </span><span class="s3">\&quot;</span><span class="s1">./http</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const handler:URISchemeHandler = {</span><span class="s3">\n\t</span><span class="s1">scheme : </span><span class="s3">\&quot;</span><span class="s1">https</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t</span><span class="s1">domainHost : http.domainHost,</span><span class="s3">\n\t</span><span class="s1">parse : http.parse,</span><span class="s3">\n\t</span><span class="s1">serialize : http.serialize</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default handler;&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URISchemeHandler, URIComponents, URIOptions } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const handler:URISchemeHandler = {</span><span class="s3">\n\t</span><span class="s1">scheme : </span><span class="s3">\&quot;</span><span class="s1">http</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n\t</span><span class="s1">domainHost : true,</span><span class="s3">\n\n\t</span><span class="s1">parse : function (components:URIComponents, options:URIOptions):URIComponents {</span><span class="s3">\n\t\t</span><span class="s1">//report missing host</span><span class="s3">\n\t\t</span><span class="s1">if (!components.host) {</span><span class="s3">\n\t\t\t</span><span class="s1">components.error = components.error || </span><span class="s3">\&quot;</span><span class="s1">HTTP URIs must have a host.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return components;</span><span class="s3">\n\t</span><span class="s1">},</span><span class="s3">\n\n\t</span><span class="s1">serialize : function (components:URIComponents, options:URIOptions):URIComponents {</span><span class="s3">\n\t\t</span><span class="s1">const secure = String(components.scheme).toLowerCase() === </span><span class="s3">\&quot;</span><span class="s1">https</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\t\t</span><span class="s1">//normalize the default port</span><span class="s3">\n\t\t</span><span class="s1">if (components.port === (secure ? 443 : 80) || components.port === </span><span class="s3">\&quot;\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t\t</span><span class="s1">components.port = undefined;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\n\t\t</span><span class="s1">//normalize the empty path</span><span class="s3">\n\t\t</span><span class="s1">if (!components.path) {</span><span class="s3">\n\t\t\t</span><span class="s1">components.path = </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//NOTE: We do not parse query strings for HTTP URIs</span><span class="s3">\n\t\t</span><span class="s1">//as WWW Form Url Encoded query strings are part of the HTML4+ spec,</span><span class="s3">\n\t\t</span><span class="s1">//and not the HTTP spec.</span><span class="s3">\n\n\t\t</span><span class="s1">return components;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default handler;&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* URI.js</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.</span><span class="s3">\n </span><span class="s1">* @author &lt;a href=</span><span class="s3">\&quot;</span><span class="s1">mailto:gary.court@gmail.com</span><span class="s3">\&quot;</span><span class="s1">&gt;Gary Court&lt;/a&gt;</span><span class="s3">\n </span><span class="s1">* @see http://github.com/garycourt/uri-js</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Copyright 2011 Gary Court. All rights reserved.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Redistribution and use in source and binary forms, with or without modification, are</span><span class="s3">\n </span><span class="s1">* permitted provided that the following conditions are met:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. Redistributions of source code must retain the above copyright notice, this list of</span><span class="s3">\n </span><span class="s1">*       conditions and the following disclaimer.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    2. Redistributions in binary form must reproduce the above copyright notice, this list</span><span class="s3">\n </span><span class="s1">*       of conditions and the following disclaimer in the documentation and/or other materials</span><span class="s3">\n </span><span class="s1">*       provided with the distribution.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED</span><span class="s3">\n </span><span class="s1">* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND</span><span class="s3">\n </span><span class="s1">* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR</span><span class="s3">\n </span><span class="s1">* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span><span class="s3">\n </span><span class="s1">* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span><span class="s3">\n </span><span class="s1">* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON</span><span class="s3">\n </span><span class="s1">* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span><span class="s3">\n </span><span class="s1">* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF</span><span class="s3">\n </span><span class="s1">* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The views and conclusions contained in the software and documentation are those of the</span><span class="s3">\n </span><span class="s1">* authors and should not be interpreted as representing official policies, either expressed</span><span class="s3">\n </span><span class="s1">* or implied, of Gary Court.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import URI_PROTOCOL from </span><span class="s3">\&quot;</span><span class="s1">./regexps-uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import IRI_PROTOCOL from </span><span class="s3">\&quot;</span><span class="s1">./regexps-iri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import punycode from </span><span class="s3">\&quot;</span><span class="s1">punycode</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { toUpperCase, typeOf, assign } from </span><span class="s3">\&quot;</span><span class="s1">./util</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export interface URIComponents {</span><span class="s3">\n\t</span><span class="s1">scheme?:string;</span><span class="s3">\n\t</span><span class="s1">userinfo?:string;</span><span class="s3">\n\t</span><span class="s1">host?:string;</span><span class="s3">\n\t</span><span class="s1">port?:number|string;</span><span class="s3">\n\t</span><span class="s1">path?:string;</span><span class="s3">\n\t</span><span class="s1">query?:string;</span><span class="s3">\n\t</span><span class="s1">fragment?:string;</span><span class="s3">\n\t</span><span class="s1">reference?:string;</span><span class="s3">\n\t</span><span class="s1">error?:string;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface URIOptions {</span><span class="s3">\n\t</span><span class="s1">scheme?:string;</span><span class="s3">\n\t</span><span class="s1">reference?:string;</span><span class="s3">\n\t</span><span class="s1">tolerant?:boolean;</span><span class="s3">\n\t</span><span class="s1">absolutePath?:boolean;</span><span class="s3">\n\t</span><span class="s1">iri?:boolean;</span><span class="s3">\n\t</span><span class="s1">unicodeSupport?:boolean;</span><span class="s3">\n\t</span><span class="s1">domainHost?:boolean;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface URISchemeHandler&lt;Components extends URIComponents = URIComponents, Options extends URIOptions = URIOptions, ParentComponents extends URIComponents = URIComponents&gt; {</span><span class="s3">\n\t</span><span class="s1">scheme:string;</span><span class="s3">\n\t</span><span class="s1">parse(components:ParentComponents, options:Options):Components;</span><span class="s3">\n\t</span><span class="s1">serialize(components:Components, options:Options):ParentComponents;</span><span class="s3">\n\t</span><span class="s1">unicodeSupport?:boolean;</span><span class="s3">\n\t</span><span class="s1">domainHost?:boolean;</span><span class="s3">\n\t</span><span class="s1">absolutePath?:boolean;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface URIRegExps {</span><span class="s3">\n\t</span><span class="s1">NOT_SCHEME : RegExp,</span><span class="s3">\n\t</span><span class="s1">NOT_USERINFO : RegExp,</span><span class="s3">\n\t</span><span class="s1">NOT_HOST : RegExp,</span><span class="s3">\n\t</span><span class="s1">NOT_PATH : RegExp,</span><span class="s3">\n\t</span><span class="s1">NOT_PATH_NOSCHEME : RegExp,</span><span class="s3">\n\t</span><span class="s1">NOT_QUERY : RegExp,</span><span class="s3">\n\t</span><span class="s1">NOT_FRAGMENT : RegExp,</span><span class="s3">\n\t</span><span class="s1">ESCAPE : RegExp,</span><span class="s3">\n\t</span><span class="s1">UNRESERVED : RegExp,</span><span class="s3">\n\t</span><span class="s1">OTHER_CHARS : RegExp,</span><span class="s3">\n\t</span><span class="s1">PCT_ENCODED : RegExp,</span><span class="s3">\n\t</span><span class="s1">IPV4ADDRESS : RegExp,</span><span class="s3">\n\t</span><span class="s1">IPV6ADDRESS : RegExp,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const SCHEMES:{[scheme:string]:URISchemeHandler} = {};</span><span class="s3">\n\n</span><span class="s1">export function pctEncChar(chr:string):string {</span><span class="s3">\n\t</span><span class="s1">const c = chr.charCodeAt(0);</span><span class="s3">\n\t</span><span class="s1">let e:string;</span><span class="s3">\n\n\t</span><span class="s1">if (c &lt; 16) e = </span><span class="s3">\&quot;</span><span class="s1">%0</span><span class="s3">\&quot; </span><span class="s1">+ c.toString(16).toUpperCase();</span><span class="s3">\n\t</span><span class="s1">else if (c &lt; 128) e = </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ c.toString(16).toUpperCase();</span><span class="s3">\n\t</span><span class="s1">else if (c &lt; 2048) e = </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ ((c &gt;&gt; 6) | 192).toString(16).toUpperCase() + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ ((c &amp; 63) | 128).toString(16).toUpperCase();</span><span class="s3">\n\t</span><span class="s1">else e = </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ ((c &gt;&gt; 12) | 224).toString(16).toUpperCase() + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ (((c &gt;&gt; 6) &amp; 63) | 128).toString(16).toUpperCase() + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ ((c &amp; 63) | 128).toString(16).toUpperCase();</span><span class="s3">\n\n\t</span><span class="s1">return e;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function pctDecChars(str:string):string {</span><span class="s3">\n\t</span><span class="s1">let newStr = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n\t</span><span class="s1">let i = 0;</span><span class="s3">\n\t</span><span class="s1">const il = str.length;</span><span class="s3">\n\n\t</span><span class="s1">while (i &lt; il) {</span><span class="s3">\n\t\t</span><span class="s1">const c = parseInt(str.substr(i + 1, 2), 16);</span><span class="s3">\n\n\t\t</span><span class="s1">if (c &lt; 128) {</span><span class="s3">\n\t\t\t</span><span class="s1">newStr += String.fromCharCode(c);</span><span class="s3">\n\t\t\t</span><span class="s1">i += 3;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">else if (c &gt;= 194 &amp;&amp; c &lt; 224) {</span><span class="s3">\n\t\t\t</span><span class="s1">if ((il - i) &gt;= 6) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const c2 = parseInt(str.substr(i + 4, 2), 16);</span><span class="s3">\n\t\t\t\t</span><span class="s1">newStr += String.fromCharCode(((c &amp; 31) &lt;&lt; 6) | (c2 &amp; 63));</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">newStr += str.substr(i, 6);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">i += 6;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">else if (c &gt;= 224) {</span><span class="s3">\n\t\t\t</span><span class="s1">if ((il - i) &gt;= 9) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const c2 = parseInt(str.substr(i + 4, 2), 16);</span><span class="s3">\n\t\t\t\t</span><span class="s1">const c3 = parseInt(str.substr(i + 7, 2), 16);</span><span class="s3">\n\t\t\t\t</span><span class="s1">newStr += String.fromCharCode(((c &amp; 15) &lt;&lt; 12) | ((c2 &amp; 63) &lt;&lt; 6) | (c3 &amp; 63));</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">newStr += str.substr(i, 9);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">i += 9;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">else {</span><span class="s3">\n\t\t\t</span><span class="s1">newStr += str.substr(i, 3);</span><span class="s3">\n\t\t\t</span><span class="s1">i += 3;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return newStr;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function _normalizeComponentEncoding(components:URIComponents, protocol:URIRegExps) {</span><span class="s3">\n\t</span><span class="s1">function decodeUnreserved(str:string):string {</span><span class="s3">\n\t\t</span><span class="s1">const decStr = pctDecChars(str);</span><span class="s3">\n\t\t</span><span class="s1">return (!decStr.match(protocol.UNRESERVED) ? str : decStr);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n\t</span><span class="s1">if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span><span class="s3">\n\t</span><span class="s1">if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span><span class="s3">\n\t</span><span class="s1">if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span><span class="s3">\n\t</span><span class="s1">if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span><span class="s3">\n\t</span><span class="s1">if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span><span class="s3">\n\n\t</span><span class="s1">return components;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function _stripLeadingZeros(str:string):string {</span><span class="s3">\n\t</span><span class="s1">return str.replace(/^0*(.*)/, </span><span class="s3">\&quot;</span><span class="s1">$1</span><span class="s3">\&quot;</span><span class="s1">) || </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function _normalizeIPv4(host:string, protocol:URIRegExps):string {</span><span class="s3">\n\t</span><span class="s1">const matches = host.match(protocol.IPV4ADDRESS) || [];</span><span class="s3">\n\t</span><span class="s1">const [, address] = matches;</span><span class="s3">\n\t\n\t</span><span class="s1">if (address) {</span><span class="s3">\n\t\t</span><span class="s1">return address.split(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">).map(_stripLeadingZeros).join(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t</span><span class="s1">} else {</span><span class="s3">\n\t\t</span><span class="s1">return host;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function _normalizeIPv6(host:string, protocol:URIRegExps):string {</span><span class="s3">\n\t</span><span class="s1">const matches = host.match(protocol.IPV6ADDRESS) || [];</span><span class="s3">\n\t</span><span class="s1">const [, address, zone] = matches;</span><span class="s3">\n\n\t</span><span class="s1">if (address) {</span><span class="s3">\n\t\t</span><span class="s1">const [last, first] = address.toLowerCase().split('::').reverse();</span><span class="s3">\n\t\t</span><span class="s1">const firstFields = first ? first.split(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">).map(_stripLeadingZeros) : [];</span><span class="s3">\n\t\t</span><span class="s1">const lastFields = last.split(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">).map(_stripLeadingZeros);</span><span class="s3">\n\t\t</span><span class="s1">const isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);</span><span class="s3">\n\t\t</span><span class="s1">const fieldCount = isLastFieldIPv4Address ? 7 : 8;</span><span class="s3">\n\t\t</span><span class="s1">const lastFieldsStart = lastFields.length - fieldCount;</span><span class="s3">\n\t\t</span><span class="s1">const fields = Array&lt;string&gt;(fieldCount);</span><span class="s3">\n\n\t\t</span><span class="s1">for (let x = 0; x &lt; fieldCount; ++x) {</span><span class="s3">\n\t\t\t</span><span class="s1">fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (isLastFieldIPv4Address) {</span><span class="s3">\n\t\t\t</span><span class="s1">fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">const allZeroFields = fields.reduce&lt;Array&lt;{index:number,length:number}&gt;&gt;((acc, field, index) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">if (!field || field === </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const lastLongest = acc[acc.length - 1];</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (lastLongest &amp;&amp; lastLongest.index + lastLongest.length === index) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">lastLongest.length++;</span><span class="s3">\n\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">acc.push({ index, length : 1 });</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">return acc;</span><span class="s3">\n\t\t</span><span class="s1">}, []);</span><span class="s3">\n\n\t\t</span><span class="s1">const longestZeroFields = allZeroFields.sort((a, b) =&gt; b.length - a.length)[0];</span><span class="s3">\n\n\t\t</span><span class="s1">let newHost:string;</span><span class="s3">\n\t\t</span><span class="s1">if (longestZeroFields &amp;&amp; longestZeroFields.length &gt; 1) {</span><span class="s3">\n\t\t\t</span><span class="s1">const newFirst = fields.slice(0, longestZeroFields.index) ;</span><span class="s3">\n\t\t\t</span><span class="s1">const newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);</span><span class="s3">\n\t\t\t</span><span class="s1">newHost = newFirst.join(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot; </span><span class="s1">+ newLast.join(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">newHost = fields.join(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (zone) {</span><span class="s3">\n\t\t\t</span><span class="s1">newHost += </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ zone;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return newHost;</span><span class="s3">\n\t</span><span class="s1">} else {</span><span class="s3">\n\t\t</span><span class="s1">return host;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const URI_PARSE = /^(?:([^:</span><span class="s3">\\</span><span class="s1">/?#]+):)?(?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/((?:([^</span><span class="s3">\\</span><span class="s1">/?#@]*)@)?(</span><span class="s3">\\</span><span class="s1">[[^</span><span class="s3">\\</span><span class="s1">/?#</span><span class="s3">\\</span><span class="s1">]]+</span><span class="s3">\\</span><span class="s1">]|[^</span><span class="s3">\\</span><span class="s1">/?#:]*)(?:</span><span class="s3">\\</span><span class="s1">:(</span><span class="s3">\\</span><span class="s1">d*))?))?([^?#]*)(?:</span><span class="s3">\\</span><span class="s1">?([^#]*))?(?:#((?:.|</span><span class="s3">\\</span><span class="s1">n|</span><span class="s3">\\</span><span class="s1">r)*))?/i;</span><span class="s3">\n</span><span class="s1">const NO_MATCH_IS_UNDEFINED = (&lt;RegExpMatchArray&gt;(</span><span class="s3">\&quot;\&quot;</span><span class="s1">).match(/(){0}/))[1] === undefined;</span><span class="s3">\n\n</span><span class="s1">export function parse(uriString:string, options:URIOptions = {}):URIComponents {</span><span class="s3">\n\t</span><span class="s1">const components:URIComponents = {};</span><span class="s3">\n\t</span><span class="s1">const protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);</span><span class="s3">\n\n\t</span><span class="s1">if (options.reference === </span><span class="s3">\&quot;</span><span class="s1">suffix</span><span class="s3">\&quot;</span><span class="s1">) uriString = (options.scheme ? options.scheme + </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot; </span><span class="s1">+ uriString;</span><span class="s3">\n\n\t</span><span class="s1">const matches = uriString.match(URI_PARSE);</span><span class="s3">\n\n\t</span><span class="s1">if (matches) {</span><span class="s3">\n\t\t</span><span class="s1">if (NO_MATCH_IS_UNDEFINED) {</span><span class="s3">\n\t\t\t</span><span class="s1">//store each component</span><span class="s3">\n\t\t\t</span><span class="s1">components.scheme = matches[1];</span><span class="s3">\n\t\t\t</span><span class="s1">components.userinfo = matches[3];</span><span class="s3">\n\t\t\t</span><span class="s1">components.host = matches[4];</span><span class="s3">\n\t\t\t</span><span class="s1">components.port = parseInt(matches[5], 10);</span><span class="s3">\n\t\t\t</span><span class="s1">components.path = matches[6] || </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t\t</span><span class="s1">components.query = matches[7];</span><span class="s3">\n\t\t\t</span><span class="s1">components.fragment = matches[8];</span><span class="s3">\n\n\t\t\t</span><span class="s1">//fix port number</span><span class="s3">\n\t\t\t</span><span class="s1">if (isNaN(components.port)) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">components.port = matches[5];</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">} else {  //IE FIX for improper RegExp matching</span><span class="s3">\n\t\t\t</span><span class="s1">//store each component</span><span class="s3">\n\t\t\t</span><span class="s1">components.scheme = matches[1] || undefined;</span><span class="s3">\n\t\t\t</span><span class="s1">components.userinfo = (uriString.indexOf(</span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">) !== -1 ? matches[3] : undefined);</span><span class="s3">\n\t\t\t</span><span class="s1">components.host = (uriString.indexOf(</span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot;</span><span class="s1">) !== -1 ? matches[4] : undefined);</span><span class="s3">\n\t\t\t</span><span class="s1">components.port = parseInt(matches[5], 10);</span><span class="s3">\n\t\t\t</span><span class="s1">components.path = matches[6] || </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t\t</span><span class="s1">components.query = (uriString.indexOf(</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">) !== -1 ? matches[7] : undefined);</span><span class="s3">\n\t\t\t</span><span class="s1">components.fragment = (uriString.indexOf(</span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">) !== -1 ? matches[8] : undefined);</span><span class="s3">\n\n\t\t\t</span><span class="s1">//fix port number</span><span class="s3">\n\t\t\t</span><span class="s1">if (isNaN(components.port)) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">components.port = (uriString.match(/</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/(?:.|</span><span class="s3">\\</span><span class="s1">n)*</span><span class="s3">\\</span><span class="s1">:(?:</span><span class="s3">\\</span><span class="s1">/|</span><span class="s3">\\</span><span class="s1">?|</span><span class="s3">\\</span><span class="s1">#|$)/) ? matches[4] : undefined);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (components.host) {</span><span class="s3">\n\t\t\t</span><span class="s1">//normalize IP hosts</span><span class="s3">\n\t\t\t</span><span class="s1">components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//determine reference type</span><span class="s3">\n\t\t</span><span class="s1">if (components.scheme === undefined &amp;&amp; components.userinfo === undefined &amp;&amp; components.host === undefined &amp;&amp; components.port === undefined &amp;&amp; !components.path &amp;&amp; components.query === undefined) {</span><span class="s3">\n\t\t\t</span><span class="s1">components.reference = </span><span class="s3">\&quot;</span><span class="s1">same-document</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">} else if (components.scheme === undefined) {</span><span class="s3">\n\t\t\t</span><span class="s1">components.reference = </span><span class="s3">\&quot;</span><span class="s1">relative</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">} else if (components.fragment === undefined) {</span><span class="s3">\n\t\t\t</span><span class="s1">components.reference = </span><span class="s3">\&quot;</span><span class="s1">absolute</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">components.reference = </span><span class="s3">\&quot;</span><span class="s1">uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//check for reference errors</span><span class="s3">\n\t\t</span><span class="s1">if (options.reference &amp;&amp; options.reference !== </span><span class="s3">\&quot;</span><span class="s1">suffix</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; options.reference !== components.reference) {</span><span class="s3">\n\t\t\t</span><span class="s1">components.error = components.error || </span><span class="s3">\&quot;</span><span class="s1">URI is not a </span><span class="s3">\&quot; </span><span class="s1">+ options.reference + </span><span class="s3">\&quot; </span><span class="s1">reference.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//find scheme handler</span><span class="s3">\n\t\t</span><span class="s1">const schemeHandler = SCHEMES[(options.scheme || components.scheme || </span><span class="s3">\&quot;\&quot;</span><span class="s1">).toLowerCase()];</span><span class="s3">\n\n\t\t</span><span class="s1">//check if scheme can't handle IRIs</span><span class="s3">\n\t\t</span><span class="s1">if (!options.unicodeSupport &amp;&amp; (!schemeHandler || !schemeHandler.unicodeSupport)) {</span><span class="s3">\n\t\t\t</span><span class="s1">//if host component is a domain name</span><span class="s3">\n\t\t\t</span><span class="s1">if (components.host &amp;&amp; (options.domainHost || (schemeHandler &amp;&amp; schemeHandler.domainHost))) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">//convert Unicode IDN -&gt; ASCII IDN</span><span class="s3">\n\t\t\t\t</span><span class="s1">try {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());</span><span class="s3">\n\t\t\t\t</span><span class="s1">} catch (e) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">components.error = components.error || </span><span class="s3">\&quot;</span><span class="s1">Host's domain name can not be converted to ASCII via punycode: </span><span class="s3">\&quot; </span><span class="s1">+ e;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">//convert IRI -&gt; URI</span><span class="s3">\n\t\t\t</span><span class="s1">_normalizeComponentEncoding(components, URI_PROTOCOL);</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">//normalize encodings</span><span class="s3">\n\t\t\t</span><span class="s1">_normalizeComponentEncoding(components, protocol);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//perform scheme specific parsing</span><span class="s3">\n\t\t</span><span class="s1">if (schemeHandler &amp;&amp; schemeHandler.parse) {</span><span class="s3">\n\t\t\t</span><span class="s1">schemeHandler.parse(components, options);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">} else {</span><span class="s3">\n\t\t</span><span class="s1">components.error = components.error || </span><span class="s3">\&quot;</span><span class="s1">URI can not be parsed.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return components;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function _recomposeAuthority(components:URIComponents, options:URIOptions):string|undefined {</span><span class="s3">\n\t</span><span class="s1">const protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);</span><span class="s3">\n\t</span><span class="s1">const uriTokens:Array&lt;string&gt; = [];</span><span class="s3">\n\n\t</span><span class="s1">if (components.userinfo !== undefined) {</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(components.userinfo);</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(</span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">if (components.host !== undefined) {</span><span class="s3">\n\t\t</span><span class="s1">//normalize IP hosts, add brackets and escape zone separator for IPv6</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, (_, $1, $2) =&gt; </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot; </span><span class="s1">+ $1 + ($2 ? </span><span class="s3">\&quot;</span><span class="s1">%25</span><span class="s3">\&quot; </span><span class="s1">+ $2 : </span><span class="s3">\&quot;\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">if (typeof components.port === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| typeof components.port === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(String(components.port));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return uriTokens.length ? uriTokens.join(</span><span class="s3">\&quot;\&quot;</span><span class="s1">) : undefined;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const RDS1 = /^</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.?</span><span class="s3">\\</span><span class="s1">//;</span><span class="s3">\n</span><span class="s1">const RDS2 = /^</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">.(</span><span class="s3">\\</span><span class="s1">/|$)/;</span><span class="s3">\n</span><span class="s1">const RDS3 = /^</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.(</span><span class="s3">\\</span><span class="s1">/|$)/;</span><span class="s3">\n</span><span class="s1">const RDS4 = /^</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.?$/;</span><span class="s3">\n</span><span class="s1">const RDS5 = /^</span><span class="s3">\\</span><span class="s1">/?(?:.|</span><span class="s3">\\</span><span class="s1">n)*?(?=</span><span class="s3">\\</span><span class="s1">/|$)/;</span><span class="s3">\n\n</span><span class="s1">export function removeDotSegments(input:string):string {</span><span class="s3">\n\t</span><span class="s1">const output:Array&lt;string&gt; = [];</span><span class="s3">\n\n\t</span><span class="s1">while (input.length) {</span><span class="s3">\n\t\t</span><span class="s1">if (input.match(RDS1)) {</span><span class="s3">\n\t\t\t</span><span class="s1">input = input.replace(RDS1, </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">} else if (input.match(RDS2)) {</span><span class="s3">\n\t\t\t</span><span class="s1">input = input.replace(RDS2, </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">} else if (input.match(RDS3)) {</span><span class="s3">\n\t\t\t</span><span class="s1">input = input.replace(RDS3, </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t\t</span><span class="s1">output.pop();</span><span class="s3">\n\t\t</span><span class="s1">} else if (input === </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">|| input === </span><span class="s3">\&quot;</span><span class="s1">..</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t\t</span><span class="s1">input = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">const im = input.match(RDS5);</span><span class="s3">\n\t\t\t</span><span class="s1">if (im) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const s = im[0];</span><span class="s3">\n\t\t\t\t</span><span class="s1">input = input.slice(s.length);</span><span class="s3">\n\t\t\t\t</span><span class="s1">output.push(s);</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Unexpected dot segment condition</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return output.join(</span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function serialize(components:URIComponents, options:URIOptions = {}):string {</span><span class="s3">\n\t</span><span class="s1">const protocol = (options.iri ? IRI_PROTOCOL : URI_PROTOCOL);</span><span class="s3">\n\t</span><span class="s1">const uriTokens:Array&lt;string&gt; = [];</span><span class="s3">\n\n\t</span><span class="s1">//find scheme handler</span><span class="s3">\n\t</span><span class="s1">const schemeHandler = SCHEMES[(options.scheme || components.scheme || </span><span class="s3">\&quot;\&quot;</span><span class="s1">).toLowerCase()];</span><span class="s3">\n\n\t</span><span class="s1">//perform scheme specific serialization</span><span class="s3">\n\t</span><span class="s1">if (schemeHandler &amp;&amp; schemeHandler.serialize) schemeHandler.serialize(components, options);</span><span class="s3">\n\n\t</span><span class="s1">if (components.host) {</span><span class="s3">\n\t\t</span><span class="s1">//if host component is an IPv6 address</span><span class="s3">\n\t\t</span><span class="s1">if (protocol.IPV6ADDRESS.test(components.host)) {</span><span class="s3">\n\t\t\t</span><span class="s1">//TODO: normalize IPv6 address as per RFC 5952</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//if host component is a domain name</span><span class="s3">\n\t\t</span><span class="s1">else if (options.domainHost || (schemeHandler &amp;&amp; schemeHandler.domainHost)) {</span><span class="s3">\n\t\t\t</span><span class="s1">//convert IDN via punycode</span><span class="s3">\n\t\t\t</span><span class="s1">try {</span><span class="s3">\n\t\t\t\t</span><span class="s1">components.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));</span><span class="s3">\n\t\t\t</span><span class="s1">} catch (e) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">components.error = components.error || </span><span class="s3">\&quot;</span><span class="s1">Host's domain name can not be converted to </span><span class="s3">\&quot; </span><span class="s1">+ (!options.iri ? </span><span class="s3">\&quot;</span><span class="s1">ASCII</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">Unicode</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot; </span><span class="s1">via punycode: </span><span class="s3">\&quot; </span><span class="s1">+ e;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">//normalize encoding</span><span class="s3">\n\t</span><span class="s1">_normalizeComponentEncoding(components, protocol);</span><span class="s3">\n\n\t</span><span class="s1">if (options.reference !== </span><span class="s3">\&quot;</span><span class="s1">suffix</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; components.scheme) {</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(components.scheme);</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">const authority = _recomposeAuthority(components, options);</span><span class="s3">\n\t</span><span class="s1">if (authority !== undefined) {</span><span class="s3">\n\t\t</span><span class="s1">if (options.reference !== </span><span class="s3">\&quot;</span><span class="s1">suffix</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t\t</span><span class="s1">uriTokens.push(</span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">uriTokens.push(authority);</span><span class="s3">\n\n\t\t</span><span class="s1">if (components.path &amp;&amp; components.path.charAt(0) !== </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t\t</span><span class="s1">uriTokens.push(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">if (components.path !== undefined) {</span><span class="s3">\n\t\t</span><span class="s1">let s = components.path;</span><span class="s3">\n\n\t\t</span><span class="s1">if (!options.absolutePath &amp;&amp; (!schemeHandler || !schemeHandler.absolutePath)) {</span><span class="s3">\n\t\t\t</span><span class="s1">s = removeDotSegments(s);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (authority === undefined) {</span><span class="s3">\n\t\t\t</span><span class="s1">s = s.replace(/^</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">//, </span><span class="s3">\&quot;</span><span class="s1">/%2F</span><span class="s3">\&quot;</span><span class="s1">);  //don't allow the path to start with </span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot;\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">uriTokens.push(s);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">if (components.query !== undefined) {</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(components.query);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">if (components.fragment !== undefined) {</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(</span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(components.fragment);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return uriTokens.join(</span><span class="s3">\&quot;\&quot;</span><span class="s1">);  //merge tokens into a string</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function resolveComponents(base:URIComponents, relative:URIComponents, options:URIOptions = {}, skipNormalization?:boolean):URIComponents {</span><span class="s3">\n\t</span><span class="s1">const target:URIComponents = {};</span><span class="s3">\n\n\t</span><span class="s1">if (!skipNormalization) {</span><span class="s3">\n\t\t</span><span class="s1">base = parse(serialize(base, options), options);  //normalize base components</span><span class="s3">\n\t\t</span><span class="s1">relative = parse(serialize(relative, options), options);  //normalize relative components</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">options = options || {};</span><span class="s3">\n\n\t</span><span class="s1">if (!options.tolerant &amp;&amp; relative.scheme) {</span><span class="s3">\n\t\t</span><span class="s1">target.scheme = relative.scheme;</span><span class="s3">\n\t\t</span><span class="s1">//target.authority = relative.authority;</span><span class="s3">\n\t\t</span><span class="s1">target.userinfo = relative.userinfo;</span><span class="s3">\n\t\t</span><span class="s1">target.host = relative.host;</span><span class="s3">\n\t\t</span><span class="s1">target.port = relative.port;</span><span class="s3">\n\t\t</span><span class="s1">target.path = removeDotSegments(relative.path || </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">target.query = relative.query;</span><span class="s3">\n\t</span><span class="s1">} else {</span><span class="s3">\n\t\t</span><span class="s1">if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {</span><span class="s3">\n\t\t\t</span><span class="s1">//target.authority = relative.authority;</span><span class="s3">\n\t\t\t</span><span class="s1">target.userinfo = relative.userinfo;</span><span class="s3">\n\t\t\t</span><span class="s1">target.host = relative.host;</span><span class="s3">\n\t\t\t</span><span class="s1">target.port = relative.port;</span><span class="s3">\n\t\t\t</span><span class="s1">target.path = removeDotSegments(relative.path || </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t\t</span><span class="s1">target.query = relative.query;</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">if (!relative.path) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">target.path = base.path;</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (relative.query !== undefined) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">target.query = relative.query;</span><span class="s3">\n\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">target.query = base.query;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (relative.path.charAt(0) === </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">target.path = removeDotSegments(relative.path);</span><span class="s3">\n\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) &amp;&amp; !base.path) {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">target.path = </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ relative.path;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">} else if (!base.path) {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">target.path = relative.path;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">target.path = base.path.slice(0, base.path.lastIndexOf(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">) + 1) + relative.path;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">target.path = removeDotSegments(target.path);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">target.query = relative.query;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">//target.authority = base.authority;</span><span class="s3">\n\t\t\t</span><span class="s1">target.userinfo = base.userinfo;</span><span class="s3">\n\t\t\t</span><span class="s1">target.host = base.host;</span><span class="s3">\n\t\t\t</span><span class="s1">target.port = base.port;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">target.scheme = base.scheme;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">target.fragment = relative.fragment;</span><span class="s3">\n\n\t</span><span class="s1">return target;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function resolve(baseURI:string, relativeURI:string, options?:URIOptions):string {</span><span class="s3">\n\t</span><span class="s1">const schemelessOptions = assign({ scheme : 'null' }, options);</span><span class="s3">\n\t</span><span class="s1">return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function normalize(uri:string, options?:URIOptions):string;</span><span class="s3">\n</span><span class="s1">export function normalize(uri:URIComponents, options?:URIOptions):URIComponents;</span><span class="s3">\n</span><span class="s1">export function normalize(uri:any, options?:URIOptions):any {</span><span class="s3">\n\t</span><span class="s1">if (typeof uri === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t</span><span class="s1">uri = serialize(parse(uri, options), options);</span><span class="s3">\n\t</span><span class="s1">} else if (typeOf(uri) === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t</span><span class="s1">uri = parse(serialize(&lt;URIComponents&gt;uri, options), options);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return uri;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function equal(uriA:string, uriB:string, options?: URIOptions):boolean;</span><span class="s3">\n</span><span class="s1">export function equal(uriA:URIComponents, uriB:URIComponents, options?:URIOptions):boolean;</span><span class="s3">\n</span><span class="s1">export function equal(uriA:any, uriB:any, options?:URIOptions):boolean {</span><span class="s3">\n\t</span><span class="s1">if (typeof uriA === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t</span><span class="s1">uriA = serialize(parse(uriA, options), options);</span><span class="s3">\n\t</span><span class="s1">} else if (typeOf(uriA) === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t</span><span class="s1">uriA = serialize(&lt;URIComponents&gt;uriA, options);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">if (typeof uriB === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t</span><span class="s1">uriB = serialize(parse(uriB, options), options);</span><span class="s3">\n\t</span><span class="s1">} else if (typeOf(uriB) === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t</span><span class="s1">uriB = serialize(&lt;URIComponents&gt;uriB, options);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return uriA === uriB;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function escapeComponent(str:string, options?:URIOptions):string {</span><span class="s3">\n\t</span><span class="s1">return str &amp;&amp; str.toString().replace((!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function unescapeComponent(str:string, options?:URIOptions):string {</span><span class="s3">\n\t</span><span class="s1">return str &amp;&amp; str.toString().replace((!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict';</span><span class="s3">\n\n</span><span class="s1">/** Highest positive signed 32-bit float value */</span><span class="s3">\n</span><span class="s1">const maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1</span><span class="s3">\n\n</span><span class="s1">/** Bootstring parameters */</span><span class="s3">\n</span><span class="s1">const base = 36;</span><span class="s3">\n</span><span class="s1">const tMin = 1;</span><span class="s3">\n</span><span class="s1">const tMax = 26;</span><span class="s3">\n</span><span class="s1">const skew = 38;</span><span class="s3">\n</span><span class="s1">const damp = 700;</span><span class="s3">\n</span><span class="s1">const initialBias = 72;</span><span class="s3">\n</span><span class="s1">const initialN = 128; // 0x80</span><span class="s3">\n</span><span class="s1">const delimiter = '-'; // '</span><span class="s3">\\</span><span class="s1">x2D'</span><span class="s3">\n\n</span><span class="s1">/** Regular expressions */</span><span class="s3">\n</span><span class="s1">const regexPunycode = /^xn--/;</span><span class="s3">\n</span><span class="s1">const regexNonASCII = /[^</span><span class="s3">\\</span><span class="s1">0-</span><span class="s3">\\</span><span class="s1">x7E]/; // non-ASCII chars</span><span class="s3">\n</span><span class="s1">const regexSeparators = /[</span><span class="s3">\\</span><span class="s1">x2E</span><span class="s3">\\</span><span class="s1">u3002</span><span class="s3">\\</span><span class="s1">uFF0E</span><span class="s3">\\</span><span class="s1">uFF61]/g; // RFC 3490 separators</span><span class="s3">\n\n</span><span class="s1">/** Error messages */</span><span class="s3">\n</span><span class="s1">const errors = {</span><span class="s3">\n\t</span><span class="s1">'overflow': 'Overflow: input needs wider integers to process',</span><span class="s3">\n\t</span><span class="s1">'not-basic': 'Illegal input &gt;= 0x80 (not a basic code point)',</span><span class="s3">\n\t</span><span class="s1">'invalid-input': 'Invalid input'</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/** Convenience shortcuts */</span><span class="s3">\n</span><span class="s1">const baseMinusTMin = base - tMin;</span><span class="s3">\n</span><span class="s1">const floor = Math.floor;</span><span class="s3">\n</span><span class="s1">const stringFromCharCode = String.fromCharCode;</span><span class="s3">\n\n</span><span class="s1">/*--------------------------------------------------------------------------*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A generic error utility function.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {String} type The error type.</span><span class="s3">\n </span><span class="s1">* @returns {Error} Throws a `RangeError` with the applicable error message.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function error(type) {</span><span class="s3">\n\t</span><span class="s1">throw new RangeError(errors[type]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A generic `Array#map` utility function.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} callback The function that gets called for every array</span><span class="s3">\n </span><span class="s1">* item.</span><span class="s3">\n </span><span class="s1">* @returns {Array} A new array of values returned by the callback function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function map(array, fn) {</span><span class="s3">\n\t</span><span class="s1">const result = [];</span><span class="s3">\n\t</span><span class="s1">let length = array.length;</span><span class="s3">\n\t</span><span class="s1">while (length--) {</span><span class="s3">\n\t\t</span><span class="s1">result[length] = fn(array[length]);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A simple `Array#map`-like wrapper to work with domain name strings or email</span><span class="s3">\n </span><span class="s1">* addresses.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {String} domain The domain name or email address.</span><span class="s3">\n </span><span class="s1">* @param {Function} callback The function that gets called for every</span><span class="s3">\n </span><span class="s1">* character.</span><span class="s3">\n </span><span class="s1">* @returns {Array} A new string of characters returned by the callback</span><span class="s3">\n </span><span class="s1">* function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function mapDomain(string, fn) {</span><span class="s3">\n\t</span><span class="s1">const parts = string.split('@');</span><span class="s3">\n\t</span><span class="s1">let result = '';</span><span class="s3">\n\t</span><span class="s1">if (parts.length &gt; 1) {</span><span class="s3">\n\t\t</span><span class="s1">// In email addresses, only the domain name should be punycoded. Leave</span><span class="s3">\n\t\t</span><span class="s1">// the local part (i.e. everything up to `@`) intact.</span><span class="s3">\n\t\t</span><span class="s1">result = parts[0] + '@';</span><span class="s3">\n\t\t</span><span class="s1">string = parts[1];</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Avoid `split(regex)` for IE8 compatibility. See #17.</span><span class="s3">\n\t</span><span class="s1">string = string.replace(regexSeparators, '</span><span class="s3">\\</span><span class="s1">x2E');</span><span class="s3">\n\t</span><span class="s1">const labels = string.split('.');</span><span class="s3">\n\t</span><span class="s1">const encoded = map(labels, fn).join('.');</span><span class="s3">\n\t</span><span class="s1">return result + encoded;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an array containing the numeric code points of each Unicode</span><span class="s3">\n </span><span class="s1">* character in the string. While JavaScript uses UCS-2 internally,</span><span class="s3">\n </span><span class="s1">* this function will convert a pair of surrogate halves (each of which</span><span class="s3">\n </span><span class="s1">* UCS-2 exposes as separate characters) into a single code point,</span><span class="s3">\n </span><span class="s1">* matching UTF-16.</span><span class="s3">\n </span><span class="s1">* @see `punycode.ucs2.encode`</span><span class="s3">\n </span><span class="s1">* @see &lt;https://mathiasbynens.be/notes/javascript-encoding&gt;</span><span class="s3">\n </span><span class="s1">* @memberOf punycode.ucs2</span><span class="s3">\n </span><span class="s1">* @name decode</span><span class="s3">\n </span><span class="s1">* @param {String} string The Unicode input string (UCS-2).</span><span class="s3">\n </span><span class="s1">* @returns {Array} The new array of code points.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function ucs2decode(string) {</span><span class="s3">\n\t</span><span class="s1">const output = [];</span><span class="s3">\n\t</span><span class="s1">let counter = 0;</span><span class="s3">\n\t</span><span class="s1">const length = string.length;</span><span class="s3">\n\t</span><span class="s1">while (counter &lt; length) {</span><span class="s3">\n\t\t</span><span class="s1">const value = string.charCodeAt(counter++);</span><span class="s3">\n\t\t</span><span class="s1">if (value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDBFF &amp;&amp; counter &lt; length) {</span><span class="s3">\n\t\t\t</span><span class="s1">// It's a high surrogate, and there is a next character.</span><span class="s3">\n\t\t\t</span><span class="s1">const extra = string.charCodeAt(counter++);</span><span class="s3">\n\t\t\t</span><span class="s1">if ((extra &amp; 0xFC00) == 0xDC00) { // Low surrogate.</span><span class="s3">\n\t\t\t\t</span><span class="s1">output.push(((value &amp; 0x3FF) &lt;&lt; 10) + (extra &amp; 0x3FF) + 0x10000);</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">// It's an unmatched surrogate; only append this code unit, in case the</span><span class="s3">\n\t\t\t\t</span><span class="s1">// next code unit is the high surrogate of a surrogate pair.</span><span class="s3">\n\t\t\t\t</span><span class="s1">output.push(value);</span><span class="s3">\n\t\t\t\t</span><span class="s1">counter--;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">output.push(value);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return output;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a string based on an array of numeric code points.</span><span class="s3">\n </span><span class="s1">* @see `punycode.ucs2.decode`</span><span class="s3">\n </span><span class="s1">* @memberOf punycode.ucs2</span><span class="s3">\n </span><span class="s1">* @name encode</span><span class="s3">\n </span><span class="s1">* @param {Array} codePoints The array of numeric code points.</span><span class="s3">\n </span><span class="s1">* @returns {String} The new Unicode string (UCS-2).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const ucs2encode = array =&gt; String.fromCodePoint(...array);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a basic code point into a digit/integer.</span><span class="s3">\n </span><span class="s1">* @see `digitToBasic()`</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Number} codePoint The basic numeric code point value.</span><span class="s3">\n </span><span class="s1">* @returns {Number} The numeric value of a basic code point (for use in</span><span class="s3">\n </span><span class="s1">* representing integers) in the range `0` to `base - 1`, or `base` if</span><span class="s3">\n </span><span class="s1">* the code point does not represent a value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const basicToDigit = function(codePoint) {</span><span class="s3">\n\t</span><span class="s1">if (codePoint - 0x30 &lt; 0x0A) {</span><span class="s3">\n\t\t</span><span class="s1">return codePoint - 0x16;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">if (codePoint - 0x41 &lt; 0x1A) {</span><span class="s3">\n\t\t</span><span class="s1">return codePoint - 0x41;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">if (codePoint - 0x61 &lt; 0x1A) {</span><span class="s3">\n\t\t</span><span class="s1">return codePoint - 0x61;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return base;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a digit/integer into a basic code point.</span><span class="s3">\n </span><span class="s1">* @see `basicToDigit()`</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Number} digit The numeric value of a basic code point.</span><span class="s3">\n </span><span class="s1">* @returns {Number} The basic code point whose value (when used for</span><span class="s3">\n </span><span class="s1">* representing integers) is `digit`, which needs to be in the range</span><span class="s3">\n </span><span class="s1">* `0` to `base - 1`. If `flag` is non-zero, the uppercase form is</span><span class="s3">\n </span><span class="s1">* used; else, the lowercase form is used. The behavior is undefined</span><span class="s3">\n </span><span class="s1">* if `flag` is non-zero and `digit` has no uppercase form.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const digitToBasic = function(digit, flag) {</span><span class="s3">\n\t</span><span class="s1">//  0..25 map to ASCII a..z or A..Z</span><span class="s3">\n\t</span><span class="s1">// 26..35 map to ASCII 0..9</span><span class="s3">\n\t</span><span class="s1">return digit + 22 + 75 * (digit &lt; 26) - ((flag != 0) &lt;&lt; 5);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Bias adaptation function as per section 3.4 of RFC 3492.</span><span class="s3">\n </span><span class="s1">* https://tools.ietf.org/html/rfc3492#section-3.4</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const adapt = function(delta, numPoints, firstTime) {</span><span class="s3">\n\t</span><span class="s1">let k = 0;</span><span class="s3">\n\t</span><span class="s1">delta = firstTime ? floor(delta / damp) : delta &gt;&gt; 1;</span><span class="s3">\n\t</span><span class="s1">delta += floor(delta / numPoints);</span><span class="s3">\n\t</span><span class="s1">for (/* no initialization */; delta &gt; baseMinusTMin * tMax &gt;&gt; 1; k += base) {</span><span class="s3">\n\t\t</span><span class="s1">delta = floor(delta / baseMinusTMin);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a Punycode string of ASCII-only symbols to a string of Unicode</span><span class="s3">\n </span><span class="s1">* symbols.</span><span class="s3">\n </span><span class="s1">* @memberOf punycode</span><span class="s3">\n </span><span class="s1">* @param {String} input The Punycode string of ASCII-only symbols.</span><span class="s3">\n </span><span class="s1">* @returns {String} The resulting string of Unicode symbols.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const decode = function(input) {</span><span class="s3">\n\t</span><span class="s1">// Don't use UCS-2.</span><span class="s3">\n\t</span><span class="s1">const output = [];</span><span class="s3">\n\t</span><span class="s1">const inputLength = input.length;</span><span class="s3">\n\t</span><span class="s1">let i = 0;</span><span class="s3">\n\t</span><span class="s1">let n = initialN;</span><span class="s3">\n\t</span><span class="s1">let bias = initialBias;</span><span class="s3">\n\n\t</span><span class="s1">// Handle the basic code points: let `basic` be the number of input code</span><span class="s3">\n\t</span><span class="s1">// points before the last delimiter, or `0` if there is none, then copy</span><span class="s3">\n\t</span><span class="s1">// the first basic code points to the output.</span><span class="s3">\n\n\t</span><span class="s1">let basic = input.lastIndexOf(delimiter);</span><span class="s3">\n\t</span><span class="s1">if (basic &lt; 0) {</span><span class="s3">\n\t\t</span><span class="s1">basic = 0;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">for (let j = 0; j &lt; basic; ++j) {</span><span class="s3">\n\t\t</span><span class="s1">// if it's not a basic code point</span><span class="s3">\n\t\t</span><span class="s1">if (input.charCodeAt(j) &gt;= 0x80) {</span><span class="s3">\n\t\t\t</span><span class="s1">error('not-basic');</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">output.push(input.charCodeAt(j));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">// Main decoding loop: start just after the last delimiter if any basic code</span><span class="s3">\n\t</span><span class="s1">// points were copied; start at the beginning otherwise.</span><span class="s3">\n\n\t</span><span class="s1">for (let index = basic &gt; 0 ? basic + 1 : 0; index &lt; inputLength; /* no final expression */) {</span><span class="s3">\n\n\t\t</span><span class="s1">// `index` is the index of the next character to be consumed.</span><span class="s3">\n\t\t</span><span class="s1">// Decode a generalized variable-length integer into `delta`,</span><span class="s3">\n\t\t</span><span class="s1">// which gets added to `i`. The overflow checking is easier</span><span class="s3">\n\t\t</span><span class="s1">// if we increase `i` as we go, then subtract off its starting</span><span class="s3">\n\t\t</span><span class="s1">// value at the end to obtain `delta`.</span><span class="s3">\n\t\t</span><span class="s1">let oldi = i;</span><span class="s3">\n\t\t</span><span class="s1">for (let w = 1, k = base; /* no condition */; k += base) {</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (index &gt;= inputLength) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">error('invalid-input');</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">const digit = basicToDigit(input.charCodeAt(index++));</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (digit &gt;= base || digit &gt; floor((maxInt - i) / w)) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">error('overflow');</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">i += digit * w;</span><span class="s3">\n\t\t\t</span><span class="s1">const t = k &lt;= bias ? tMin : (k &gt;= bias + tMax ? tMax : k - bias);</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (digit &lt; t) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">const baseMinusT = base - t;</span><span class="s3">\n\t\t\t</span><span class="s1">if (w &gt; floor(maxInt / baseMinusT)) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">error('overflow');</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">w *= baseMinusT;</span><span class="s3">\n\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">const out = output.length + 1;</span><span class="s3">\n\t\t</span><span class="s1">bias = adapt(i - oldi, out, oldi == 0);</span><span class="s3">\n\n\t\t</span><span class="s1">// `i` was supposed to wrap around from `out` to `0`,</span><span class="s3">\n\t\t</span><span class="s1">// incrementing `n` each time, so we'll fix that now:</span><span class="s3">\n\t\t</span><span class="s1">if (floor(i / out) &gt; maxInt - n) {</span><span class="s3">\n\t\t\t</span><span class="s1">error('overflow');</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">n += floor(i / out);</span><span class="s3">\n\t\t</span><span class="s1">i %= out;</span><span class="s3">\n\n\t\t</span><span class="s1">// Insert `n` at position `i` of the output.</span><span class="s3">\n\t\t</span><span class="s1">output.splice(i++, 0, n);</span><span class="s3">\n\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return String.fromCodePoint(...output);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a string of Unicode symbols (e.g. a domain name label) to a</span><span class="s3">\n </span><span class="s1">* Punycode string of ASCII-only symbols.</span><span class="s3">\n </span><span class="s1">* @memberOf punycode</span><span class="s3">\n </span><span class="s1">* @param {String} input The string of Unicode symbols.</span><span class="s3">\n </span><span class="s1">* @returns {String} The resulting Punycode string of ASCII-only symbols.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const encode = function(input) {</span><span class="s3">\n\t</span><span class="s1">const output = [];</span><span class="s3">\n\n\t</span><span class="s1">// Convert the input in UCS-2 to an array of Unicode code points.</span><span class="s3">\n\t</span><span class="s1">input = ucs2decode(input);</span><span class="s3">\n\n\t</span><span class="s1">// Cache the length.</span><span class="s3">\n\t</span><span class="s1">let inputLength = input.length;</span><span class="s3">\n\n\t</span><span class="s1">// Initialize the state.</span><span class="s3">\n\t</span><span class="s1">let n = initialN;</span><span class="s3">\n\t</span><span class="s1">let delta = 0;</span><span class="s3">\n\t</span><span class="s1">let bias = initialBias;</span><span class="s3">\n\n\t</span><span class="s1">// Handle the basic code points.</span><span class="s3">\n\t</span><span class="s1">for (const currentValue of input) {</span><span class="s3">\n\t\t</span><span class="s1">if (currentValue &lt; 0x80) {</span><span class="s3">\n\t\t\t</span><span class="s1">output.push(stringFromCharCode(currentValue));</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">let basicLength = output.length;</span><span class="s3">\n\t</span><span class="s1">let handledCPCount = basicLength;</span><span class="s3">\n\n\t</span><span class="s1">// `handledCPCount` is the number of code points that have been handled;</span><span class="s3">\n\t</span><span class="s1">// `basicLength` is the number of basic code points.</span><span class="s3">\n\n\t</span><span class="s1">// Finish the basic string with a delimiter unless it's empty.</span><span class="s3">\n\t</span><span class="s1">if (basicLength) {</span><span class="s3">\n\t\t</span><span class="s1">output.push(delimiter);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">// Main encoding loop:</span><span class="s3">\n\t</span><span class="s1">while (handledCPCount &lt; inputLength) {</span><span class="s3">\n\n\t\t</span><span class="s1">// All non-basic code points &lt; n have been handled already. Find the next</span><span class="s3">\n\t\t</span><span class="s1">// larger one:</span><span class="s3">\n\t\t</span><span class="s1">let m = maxInt;</span><span class="s3">\n\t\t</span><span class="s1">for (const currentValue of input) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (currentValue &gt;= n &amp;&amp; currentValue &lt; m) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">m = currentValue;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">// Increase `delta` enough to advance the decoder's &lt;n,i&gt; state to &lt;m,0&gt;,</span><span class="s3">\n\t\t</span><span class="s1">// but guard against overflow.</span><span class="s3">\n\t\t</span><span class="s1">const handledCPCountPlusOne = handledCPCount + 1;</span><span class="s3">\n\t\t</span><span class="s1">if (m - n &gt; floor((maxInt - delta) / handledCPCountPlusOne)) {</span><span class="s3">\n\t\t\t</span><span class="s1">error('overflow');</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">delta += (m - n) * handledCPCountPlusOne;</span><span class="s3">\n\t\t</span><span class="s1">n = m;</span><span class="s3">\n\n\t\t</span><span class="s1">for (const currentValue of input) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (currentValue &lt; n &amp;&amp; ++delta &gt; maxInt) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">error('overflow');</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">if (currentValue == n) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">// Represent delta as a generalized variable-length integer.</span><span class="s3">\n\t\t\t\t</span><span class="s1">let q = delta;</span><span class="s3">\n\t\t\t\t</span><span class="s1">for (let k = base; /* no condition */; k += base) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">const t = k &lt;= bias ? tMin : (k &gt;= bias + tMax ? tMax : k - bias);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if (q &lt; t) {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">const qMinusT = q - t;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">const baseMinusT = base - t;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">output.push(</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">q = floor(qMinusT / baseMinusT);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">output.push(stringFromCharCode(digitToBasic(q, 0)));</span><span class="s3">\n\t\t\t\t</span><span class="s1">bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);</span><span class="s3">\n\t\t\t\t</span><span class="s1">delta = 0;</span><span class="s3">\n\t\t\t\t</span><span class="s1">++handledCPCount;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">++delta;</span><span class="s3">\n\t\t</span><span class="s1">++n;</span><span class="s3">\n\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return output.join('');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a Punycode string representing a domain name or an email address</span><span class="s3">\n </span><span class="s1">* to Unicode. Only the Punycoded parts of the input will be converted, i.e.</span><span class="s3">\n </span><span class="s1">* it doesn't matter if you call it on a string that has already been</span><span class="s3">\n </span><span class="s1">* converted to Unicode.</span><span class="s3">\n </span><span class="s1">* @memberOf punycode</span><span class="s3">\n </span><span class="s1">* @param {String} input The Punycoded domain name or email address to</span><span class="s3">\n </span><span class="s1">* convert to Unicode.</span><span class="s3">\n </span><span class="s1">* @returns {String} The Unicode representation of the given Punycode</span><span class="s3">\n </span><span class="s1">* string.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const toUnicode = function(input) {</span><span class="s3">\n\t</span><span class="s1">return mapDomain(input, function(string) {</span><span class="s3">\n\t\t</span><span class="s1">return regexPunycode.test(string)</span><span class="s3">\n\t\t\t</span><span class="s1">? decode(string.slice(4).toLowerCase())</span><span class="s3">\n\t\t\t</span><span class="s1">: string;</span><span class="s3">\n\t</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a Unicode string representing a domain name or an email address to</span><span class="s3">\n </span><span class="s1">* Punycode. Only the non-ASCII parts of the domain name will be converted,</span><span class="s3">\n </span><span class="s1">* i.e. it doesn't matter if you call it with a domain that's already in</span><span class="s3">\n </span><span class="s1">* ASCII.</span><span class="s3">\n </span><span class="s1">* @memberOf punycode</span><span class="s3">\n </span><span class="s1">* @param {String} input The domain name or email address to convert, as a</span><span class="s3">\n </span><span class="s1">* Unicode string.</span><span class="s3">\n </span><span class="s1">* @returns {String} The Punycode representation of the given domain name or</span><span class="s3">\n </span><span class="s1">* email address.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const toASCII = function(input) {</span><span class="s3">\n\t</span><span class="s1">return mapDomain(input, function(string) {</span><span class="s3">\n\t\t</span><span class="s1">return regexNonASCII.test(string)</span><span class="s3">\n\t\t\t</span><span class="s1">? 'xn--' + encode(string)</span><span class="s3">\n\t\t\t</span><span class="s1">: string;</span><span class="s3">\n\t</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/*--------------------------------------------------------------------------*/</span><span class="s3">\n\n</span><span class="s1">/** Define the public API */</span><span class="s3">\n</span><span class="s1">const punycode = {</span><span class="s3">\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* A string representing the current Punycode.js version number.</span><span class="s3">\n\t </span><span class="s1">* @memberOf punycode</span><span class="s3">\n\t </span><span class="s1">* @type String</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">'version': '2.1.0',</span><span class="s3">\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* An object of methods to convert from JavaScript's internal character</span><span class="s3">\n\t </span><span class="s1">* representation (UCS-2) to Unicode code points, and back.</span><span class="s3">\n\t </span><span class="s1">* @see &lt;https://mathiasbynens.be/notes/javascript-encoding&gt;</span><span class="s3">\n\t </span><span class="s1">* @memberOf punycode</span><span class="s3">\n\t </span><span class="s1">* @type Object</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">'ucs2': {</span><span class="s3">\n\t\t</span><span class="s1">'decode': ucs2decode,</span><span class="s3">\n\t\t</span><span class="s1">'encode': ucs2encode</span><span class="s3">\n\t</span><span class="s1">},</span><span class="s3">\n\t</span><span class="s1">'decode': decode,</span><span class="s3">\n\t</span><span class="s1">'encode': encode,</span><span class="s3">\n\t</span><span class="s1">'toASCII': toASCII,</span><span class="s3">\n\t</span><span class="s1">'toUnicode': toUnicode</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default punycode;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URIRegExps } from </span><span class="s3">\&quot;</span><span class="s1">./uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { buildExps } from </span><span class="s3">\&quot;</span><span class="s1">./regexps-uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export default buildExps(true);</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URIRegExps } from </span><span class="s3">\&quot;</span><span class="s1">./uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { merge, subexp } from </span><span class="s3">\&quot;</span><span class="s1">./util</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export function buildExps(isIRI:boolean):URIRegExps {</span><span class="s3">\n\t</span><span class="s1">const</span><span class="s3">\n\t\t</span><span class="s1">ALPHA$$ = </span><span class="s3">\&quot;</span><span class="s1">[A-Za-z]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">CR$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x0D]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">DIGIT$$ = </span><span class="s3">\&quot;</span><span class="s1">[0-9]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">DQUOTE$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x22]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">HEXDIG$$ = merge(DIGIT$$, </span><span class="s3">\&quot;</span><span class="s1">[A-Fa-f]</span><span class="s3">\&quot;</span><span class="s1">),  //case-insensitive</span><span class="s3">\n\t\t</span><span class="s1">LF$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x0A]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">SP$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x20]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">PCT_ENCODED$ = subexp(subexp(</span><span class="s3">\&quot;</span><span class="s1">%[EFef]</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">%[89A-Fa-f]</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$)),  //expanded</span><span class="s3">\n\t\t</span><span class="s1">GEN_DELIMS$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">#</span><span class="s3">\\\\</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">@]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">SUB_DELIMS$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">!</span><span class="s3">\\\\</span><span class="s1">$</span><span class="s3">\\\\</span><span class="s1">&amp;</span><span class="s3">\\\\</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">)</span><span class="s3">\\\\</span><span class="s1">*</span><span class="s3">\\\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">,</span><span class="s3">\\\\</span><span class="s1">;</span><span class="s3">\\\\</span><span class="s1">=]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),</span><span class="s3">\n\t\t</span><span class="s1">UCSCHAR$$ = isIRI ? </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">xA0-</span><span class="s3">\\\\</span><span class="s1">u200D</span><span class="s3">\\\\</span><span class="s1">u2010-</span><span class="s3">\\\\</span><span class="s1">u2029</span><span class="s3">\\\\</span><span class="s1">u202F-</span><span class="s3">\\\\</span><span class="s1">uD7FF</span><span class="s3">\\\\</span><span class="s1">uF900-</span><span class="s3">\\\\</span><span class="s1">uFDCF</span><span class="s3">\\\\</span><span class="s1">uFDF0-</span><span class="s3">\\\\</span><span class="s1">uFFEF]</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">[]</span><span class="s3">\&quot;</span><span class="s1">,  //subset, excludes bidi control characters</span><span class="s3">\n\t\t</span><span class="s1">IPRIVATE$$ = isIRI ? </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">uE000-</span><span class="s3">\\\\</span><span class="s1">uF8FF]</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">[]</span><span class="s3">\&quot;</span><span class="s1">,  //subset</span><span class="s3">\n\t\t</span><span class="s1">UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">-</span><span class="s3">\\\\</span><span class="s1">.</span><span class="s3">\\\\</span><span class="s1">_</span><span class="s3">\\\\</span><span class="s1">~]</span><span class="s3">\&quot;</span><span class="s1">, UCSCHAR$$),</span><span class="s3">\n\t\t</span><span class="s1">SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">-</span><span class="s3">\\\\</span><span class="s1">.]</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">USERINFO$ = subexp(subexp(PCT_ENCODED$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ merge(UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">:]</span><span class="s3">\&quot;</span><span class="s1">)) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">DEC_OCTET$ = subexp(subexp(</span><span class="s3">\&quot;</span><span class="s1">25[0-5]</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">2[0-4]</span><span class="s3">\&quot; </span><span class="s1">+ DIGIT$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">1</span><span class="s3">\&quot; </span><span class="s1">+ DIGIT$$ + DIGIT$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">[1-9]</span><span class="s3">\&quot; </span><span class="s1">+ DIGIT$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ DIGIT$$),</span><span class="s3">\n\t\t</span><span class="s1">DEC_OCTET_RELAXED$ = subexp(subexp(</span><span class="s3">\&quot;</span><span class="s1">25[0-5]</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">2[0-4]</span><span class="s3">\&quot; </span><span class="s1">+ DIGIT$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">1</span><span class="s3">\&quot; </span><span class="s1">+ DIGIT$$ + DIGIT$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">0?[1-9]</span><span class="s3">\&quot; </span><span class="s1">+ DIGIT$$) + </span><span class="s3">\&quot;</span><span class="s1">|0?0?</span><span class="s3">\&quot; </span><span class="s1">+ DIGIT$$),  //relaxed parsing rules</span><span class="s3">\n\t\t</span><span class="s1">IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">+ DEC_OCTET_RELAXED$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">+ DEC_OCTET_RELAXED$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">+ DEC_OCTET_RELAXED$),</span><span class="s3">\n\t\t</span><span class="s1">H16$ = subexp(HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">{1,4}</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">LS32$ = subexp(subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ H16$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ IPV4ADDRESS$),</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS1$ = subexp(                                                            subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{6}</span><span class="s3">\&quot; </span><span class="s1">+ LS32$), //                           6( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) ls32</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS2$ = subexp(                                                 </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{5}</span><span class="s3">\&quot; </span><span class="s1">+ LS32$), //                      </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot; </span><span class="s1">5( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) ls32</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS3$ = subexp(subexp(                                 H16$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{4}</span><span class="s3">\&quot; </span><span class="s1">+ LS32$), //[               h16 ] </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot; </span><span class="s1">4( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) ls32</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{0,1}</span><span class="s3">\&quot; </span><span class="s1">+ H16$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{3}</span><span class="s3">\&quot; </span><span class="s1">+ LS32$), //[ *1( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) h16 ] </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot; </span><span class="s1">3( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) ls32</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{0,2}</span><span class="s3">\&quot; </span><span class="s1">+ H16$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{2}</span><span class="s3">\&quot; </span><span class="s1">+ LS32$), //[ *2( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) h16 ] </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot; </span><span class="s1">2( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) ls32</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{0,3}</span><span class="s3">\&quot; </span><span class="s1">+ H16$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+        H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;          </span><span class="s1">+ LS32$), //[ *3( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) h16 ] </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot;    </span><span class="s1">h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;   </span><span class="s1">ls32</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{0,4}</span><span class="s3">\&quot; </span><span class="s1">+ H16$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot;                                </span><span class="s1">+ LS32$), //[ *4( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) h16 ] </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot;              </span><span class="s1">ls32</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{0,5}</span><span class="s3">\&quot; </span><span class="s1">+ H16$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot;                                </span><span class="s1">+ H16$ ), //[ *5( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) h16 ] </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot;              </span><span class="s1">h16</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{0,6}</span><span class="s3">\&quot; </span><span class="s1">+ H16$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot;                                       </span><span class="s1">), //[ *6( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) h16 ] </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot;\n\t\t</span><span class="s1">IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n\t\t</span><span class="s1">ZONEID$ = subexp(subexp(UNRESERVED$$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PCT_ENCODED$) + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">),  //RFC 6874</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">%25</span><span class="s3">\&quot; </span><span class="s1">+ ZONEID$),  //RFC 6874</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">%25|</span><span class="s3">\\\\</span><span class="s1">%(?!</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">{2})</span><span class="s3">\&quot;</span><span class="s1">) + ZONEID$),  //RFC 6874, with relaxed parsing rules</span><span class="s3">\n\t\t</span><span class="s1">IPVFUTURE$ = subexp(</span><span class="s3">\&quot;</span><span class="s1">[vV]</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">+ merge(UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">:]</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">IP_LITERAL$ = subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">[</span><span class="s3">\&quot; </span><span class="s1">+ subexp(IPV6ADDRZ_RELAXED$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ IPV6ADDRESS$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ IPVFUTURE$) + </span><span class="s3">\&quot;\\\\</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">),  //RFC 6874</span><span class="s3">\n\t\t</span><span class="s1">REG_NAME$ = subexp(subexp(PCT_ENCODED$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ merge(UNRESERVED$$, SUB_DELIMS$$)) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">HOST$ = subexp(IP_LITERAL$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ IPV4ADDRESS$ + </span><span class="s3">\&quot;</span><span class="s1">(?!</span><span class="s3">\&quot; </span><span class="s1">+ REG_NAME$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">+ </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ REG_NAME$),</span><span class="s3">\n\t\t</span><span class="s1">PORT$ = subexp(DIGIT$$ + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">AUTHORITY$ = subexp(subexp(USERINFO$ + </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ HOST$ + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ PORT$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">PCHAR$ = subexp(PCT_ENCODED$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ merge(UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">@]</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n\t\t</span><span class="s1">SEGMENT$ = subexp(PCHAR$ + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">SEGMENT_NZ$ = subexp(PCHAR$ + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ merge(UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">@]</span><span class="s3">\&quot;</span><span class="s1">)) + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">PATH_ABEMPTY$ = subexp(subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ SEGMENT$) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">PATH_ABSOLUTE$ = subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">),  //simplified</span><span class="s3">\n\t\t</span><span class="s1">PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),  //simplified</span><span class="s3">\n\t\t</span><span class="s1">PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),  //simplified</span><span class="s3">\n\t\t</span><span class="s1">PATH_EMPTY$ = </span><span class="s3">\&quot;</span><span class="s1">(?!</span><span class="s3">\&quot; </span><span class="s1">+ PCHAR$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">PATH$ = subexp(PATH_ABEMPTY$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_NOSCHEME$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ROOTLESS$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_EMPTY$),</span><span class="s3">\n\t\t</span><span class="s1">QUERY$ = subexp(subexp(PCHAR$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ merge(</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">?]</span><span class="s3">\&quot;</span><span class="s1">, IPRIVATE$$)) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">FRAGMENT$ = subexp(subexp(PCHAR$ + </span><span class="s3">\&quot;</span><span class="s1">|[</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">?]</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">HIER_PART$ = subexp(subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ AUTHORITY$ + PATH_ABEMPTY$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ROOTLESS$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_EMPTY$),</span><span class="s3">\n\t\t</span><span class="s1">URI$ = subexp(SCHEME$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ HIER_PART$ + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ QUERY$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">#</span><span class="s3">\&quot; </span><span class="s1">+ FRAGMENT$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">RELATIVE_PART$ = subexp(subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ AUTHORITY$ + PATH_ABEMPTY$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_NOSCHEME$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_EMPTY$),</span><span class="s3">\n\t\t</span><span class="s1">RELATIVE$ = subexp(RELATIVE_PART$ + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ QUERY$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">#</span><span class="s3">\&quot; </span><span class="s1">+ FRAGMENT$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">URI_REFERENCE$ = subexp(URI$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ RELATIVE$),</span><span class="s3">\n\t\t</span><span class="s1">ABSOLUTE_URI$ = subexp(SCHEME$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ HIER_PART$ + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ QUERY$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\n\t\t</span><span class="s1">GENERIC_REF$ = </span><span class="s3">\&quot;</span><span class="s1">^(</span><span class="s3">\&quot; </span><span class="s1">+ SCHEME$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ subexp(subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">/(</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot; </span><span class="s1">+ USERINFO$ + </span><span class="s3">\&quot;</span><span class="s1">)@</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ HOST$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">:(</span><span class="s3">\&quot; </span><span class="s1">+ PORT$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABEMPTY$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ROOTLESS$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_EMPTY$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ QUERY$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">#(</span><span class="s3">\&quot; </span><span class="s1">+ FRAGMENT$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?$</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">RELATIVE_REF$ = </span><span class="s3">\&quot;</span><span class="s1">^(){0}</span><span class="s3">\&quot; </span><span class="s1">+ subexp(subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">/(</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot; </span><span class="s1">+ USERINFO$ + </span><span class="s3">\&quot;</span><span class="s1">)@</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ HOST$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">:(</span><span class="s3">\&quot; </span><span class="s1">+ PORT$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABEMPTY$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_NOSCHEME$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_EMPTY$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ QUERY$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">#(</span><span class="s3">\&quot; </span><span class="s1">+ FRAGMENT$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?$</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">ABSOLUTE_REF$ = </span><span class="s3">\&quot;</span><span class="s1">^(</span><span class="s3">\&quot; </span><span class="s1">+ SCHEME$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ subexp(subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">/(</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot; </span><span class="s1">+ USERINFO$ + </span><span class="s3">\&quot;</span><span class="s1">)@</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ HOST$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">:(</span><span class="s3">\&quot; </span><span class="s1">+ PORT$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABEMPTY$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ROOTLESS$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_EMPTY$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ QUERY$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?$</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">SAMEDOC_REF$ = </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">#(</span><span class="s3">\&quot; </span><span class="s1">+ FRAGMENT$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?$</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">AUTHORITY_REF$ = </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot; </span><span class="s1">+ USERINFO$ + </span><span class="s3">\&quot;</span><span class="s1">)@</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ HOST$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">:(</span><span class="s3">\&quot; </span><span class="s1">+ PORT$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?$</span><span class="s3">\&quot;\n\t</span><span class="s1">;</span><span class="s3">\n\n\t</span><span class="s1">return {</span><span class="s3">\n\t\t</span><span class="s1">NOT_SCHEME : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^]</span><span class="s3">\&quot;</span><span class="s1">, ALPHA$$, DIGIT$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">-</span><span class="s3">\\\\</span><span class="s1">.]</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">NOT_USERINFO : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\\\\</span><span class="s1">%</span><span class="s3">\\\\</span><span class="s1">:]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">NOT_HOST : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\\\\</span><span class="s1">%</span><span class="s3">\\\\</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">:]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">NOT_PATH : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\\\\</span><span class="s1">%</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">@]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">NOT_PATH_NOSCHEME : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\\\\</span><span class="s1">%</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">@]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">NOT_QUERY : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\\\\</span><span class="s1">%]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">@</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">?]</span><span class="s3">\&quot;</span><span class="s1">, IPRIVATE$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">NOT_FRAGMENT : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\\\\</span><span class="s1">%]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">@</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">?]</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">ESCAPE : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">UNRESERVED : new RegExp(UNRESERVED$$, </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">OTHER_CHARS : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\\\\</span><span class="s1">%]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, RESERVED$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">PCT_ENCODED : new RegExp(PCT_ENCODED$, </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">IPV4ADDRESS : new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^(</span><span class="s3">\&quot; </span><span class="s1">+ IPV4ADDRESS$ + </span><span class="s3">\&quot;</span><span class="s1">)$</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS : new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\\\\</span><span class="s1">[?(</span><span class="s3">\&quot; </span><span class="s1">+ IPV6ADDRESS$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">+ subexp(subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">%25|</span><span class="s3">\\\\</span><span class="s1">%(?!</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">{2})</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot; </span><span class="s1">+ ZONEID$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">]?$</span><span class="s3">\&quot;</span><span class="s1">)  //RFC 6874, with relaxed parsing rules</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default buildExps(false);</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export function merge(...sets:Array&lt;string&gt;):string {</span><span class="s3">\n\t</span><span class="s1">if (sets.length &gt; 1) {</span><span class="s3">\n\t\t</span><span class="s1">sets[0] = sets[0].slice(0, -1);</span><span class="s3">\n\t\t</span><span class="s1">const xl = sets.length - 1;</span><span class="s3">\n\t\t</span><span class="s1">for (let x = 1; x &lt; xl; ++x) {</span><span class="s3">\n\t\t\t</span><span class="s1">sets[x] = sets[x].slice(1, -1);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">sets[xl] = sets[xl].slice(1);</span><span class="s3">\n\t\t</span><span class="s1">return sets.join('');</span><span class="s3">\n\t</span><span class="s1">} else {</span><span class="s3">\n\t\t</span><span class="s1">return sets[0];</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function subexp(str:string):string {</span><span class="s3">\n\t</span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot; </span><span class="s1">+ str + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function typeOf(o:any):string {</span><span class="s3">\n\t</span><span class="s1">return o === undefined ? </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">: (o === null ? </span><span class="s3">\&quot;</span><span class="s1">null</span><span class="s3">\&quot; </span><span class="s1">: Object.prototype.toString.call(o).split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">).pop().split(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">).shift().toLowerCase());</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function toUpperCase(str:string):string {</span><span class="s3">\n\t</span><span class="s1">return str.toUpperCase();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function toArray(obj:any):Array&lt;any&gt; {</span><span class="s3">\n\t</span><span class="s1">return obj !== undefined &amp;&amp; obj !== null ? (obj instanceof Array ? obj : (typeof obj.length !== </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj))) : [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n\n</span><span class="s1">export function assign(target: object, source: any): any {</span><span class="s3">\n\t</span><span class="s1">const obj = target as any;</span><span class="s3">\n\t</span><span class="s1">if (source) {</span><span class="s3">\n\t\t</span><span class="s1">for (const key in source) {</span><span class="s3">\n\t\t\t</span><span class="s1">obj[key] = source[key];</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return obj;</span><span class="s3">\n</span><span class="s1">}&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;SCHEMES&quot;</span><span class="s0">,</span><span class="s1">&quot;uuid&quot;</span><span class="s0">,</span><span class="s1">&quot;scheme&quot;</span><span class="s0">,</span><span class="s1">&quot;urn&quot;</span><span class="s0">,</span><span class="s1">&quot;mailto&quot;</span><span class="s0">,</span><span class="s1">&quot;wss&quot;</span><span class="s0">,</span><span class="s1">&quot;ws&quot;</span><span class="s0">,</span><span class="s1">&quot;https&quot;</span><span class="s0">,</span><span class="s1">&quot;http&quot;</span><span class="s0">,</span><span class="s1">&quot;urnComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;nss&quot;</span><span class="s0">,</span><span class="s1">&quot;uuidComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;tolerant&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;UUID&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;uriComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;nid&quot;</span><span class="s0">,</span><span class="s1">&quot;schemeHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;serialize&quot;</span><span class="s0">,</span><span class="s1">&quot;urnScheme&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;matches&quot;</span><span class="s0">,</span><span class="s1">&quot;components&quot;</span><span class="s0">,</span><span class="s1">&quot;URN_PARSE&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;fields&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;PCT_ENCODED&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeUnreserved&quot;</span><span class="s0">,</span><span class="s1">&quot;toUpperCase&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_HFNAME&quot;</span><span class="s0">,</span><span class="s1">&quot;pctEncChar&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_HFVALUE&quot;</span><span class="s0">,</span><span class="s1">&quot;O&quot;</span><span class="s0">,</span><span class="s1">&quot;mailtoComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;subject&quot;</span><span class="s0">,</span><span class="s1">&quot;to&quot;</span><span class="s0">,</span><span class="s1">&quot;x&quot;</span><span class="s0">,</span><span class="s1">&quot;localPart&quot;</span><span class="s0">,</span><span class="s1">&quot;domain&quot;</span><span class="s0">,</span><span class="s1">&quot;iri&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;punycode&quot;</span><span class="s0">,</span><span class="s1">&quot;toASCII&quot;</span><span class="s0">,</span><span class="s1">&quot;unescapeComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;toUnicode&quot;</span><span class="s0">,</span><span class="s1">&quot;toAddr&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;atIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_LOCAL_PART&quot;</span><span class="s0">,</span><span class="s1">&quot;lastIndexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;xl&quot;</span><span class="s0">,</span><span class="s1">&quot;toArray&quot;</span><span class="s0">,</span><span class="s1">&quot;addr&quot;</span><span class="s0">,</span><span class="s1">&quot;unicodeSupport&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;unknownHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;hfield&quot;</span><span class="s0">,</span><span class="s1">&quot;toAddrs&quot;</span><span class="s0">,</span><span class="s1">&quot;hfields&quot;</span><span class="s0">,</span><span class="s1">&quot;decStr&quot;</span><span class="s0">,</span><span class="s1">&quot;UNRESERVED&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;pctDecChars&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;merge&quot;</span><span class="s0">,</span><span class="s1">&quot;UNRESERVED$$&quot;</span><span class="s0">,</span><span class="s1">&quot;SOME_DELIMS$$&quot;</span><span class="s0">,</span><span class="s1">&quot;ATEXT$$&quot;</span><span class="s0">,</span><span class="s1">&quot;VCHAR$$&quot;</span><span class="s0">,</span><span class="s1">&quot;PCT_ENCODED$&quot;</span><span class="s0">,</span><span class="s1">&quot;QTEXT$$&quot;</span><span class="s0">,</span><span class="s1">&quot;subexp&quot;</span><span class="s0">,</span><span class="s1">&quot;HEXDIG$$&quot;</span><span class="s0">,</span><span class="s1">&quot;isIRI&quot;</span><span class="s0">,</span><span class="s1">&quot;domainHost&quot;</span><span class="s0">,</span><span class="s1">&quot;wsComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;fragment&quot;</span><span class="s0">,</span><span class="s1">&quot;resourceName&quot;</span><span class="s0">,</span><span class="s1">&quot;secure&quot;</span><span class="s0">,</span><span class="s1">&quot;port&quot;</span><span class="s0">,</span><span class="s1">&quot;isSecure&quot;</span><span class="s0">,</span><span class="s1">&quot;host&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;URI_PROTOCOL&quot;</span><span class="s0">,</span><span class="s1">&quot;IRI_PROTOCOL&quot;</span><span class="s0">,</span><span class="s1">&quot;ESCAPE&quot;</span><span class="s0">,</span><span class="s1">&quot;escapeComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;uriA&quot;</span><span class="s0">,</span><span class="s1">&quot;uriB&quot;</span><span class="s0">,</span><span class="s1">&quot;typeOf&quot;</span><span class="s0">,</span><span class="s1">&quot;equal&quot;</span><span class="s0">,</span><span class="s1">&quot;uri&quot;</span><span class="s0">,</span><span class="s1">&quot;normalize&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;baseURI&quot;</span><span class="s0">,</span><span class="s1">&quot;schemelessOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;relativeURI&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;relative&quot;</span><span class="s0">,</span><span class="s1">&quot;base&quot;</span><span class="s0">,</span><span class="s1">&quot;userinfo&quot;</span><span class="s0">,</span><span class="s1">&quot;removeDotSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;charAt&quot;</span><span class="s0">,</span><span class="s1">&quot;skipNormalization&quot;</span><span class="s0">,</span><span class="s1">&quot;uriTokens&quot;</span><span class="s0">,</span><span class="s1">&quot;s&quot;</span><span class="s0">,</span><span class="s1">&quot;authority&quot;</span><span class="s0">,</span><span class="s1">&quot;absolutePath&quot;</span><span class="s0">,</span><span class="s1">&quot;reference&quot;</span><span class="s0">,</span><span class="s1">&quot;_recomposeAuthority&quot;</span><span class="s0">,</span><span class="s1">&quot;protocol&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;output&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;input&quot;</span><span class="s0">,</span><span class="s1">&quot;im&quot;</span><span class="s0">,</span><span class="s1">&quot;RDS5&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;RDS3&quot;</span><span class="s0">,</span><span class="s1">&quot;RDS2&quot;</span><span class="s0">,</span><span class="s1">&quot;RDS1&quot;</span><span class="s0">,</span><span class="s1">&quot;$1&quot;</span><span class="s0">,</span><span class="s1">&quot;$2&quot;</span><span class="s0">,</span><span class="s1">&quot;_normalizeIPv6&quot;</span><span class="s0">,</span><span class="s1">&quot;_normalizeIPv4&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;uriString&quot;</span><span class="s0">,</span><span class="s1">&quot;isNaN&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s0">,</span><span class="s1">&quot;NO_MATCH_IS_UNDEFINED&quot;</span><span class="s0">,</span><span class="s1">&quot;URI_PARSE&quot;</span><span class="s0">,</span><span class="s1">&quot;newHost&quot;</span><span class="s0">,</span><span class="s1">&quot;zone&quot;</span><span class="s0">,</span><span class="s1">&quot;newFirst&quot;</span><span class="s0">,</span><span class="s1">&quot;newLast&quot;</span><span class="s0">,</span><span class="s1">&quot;longestZeroFields&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;allZeroFields&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">,</span><span class="s1">&quot;acc&quot;</span><span class="s0">,</span><span class="s1">&quot;lastLongest&quot;</span><span class="s0">,</span><span class="s1">&quot;field&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;fieldCount&quot;</span><span class="s0">,</span><span class="s1">&quot;isLastFieldIPv4Address&quot;</span><span class="s0">,</span><span class="s1">&quot;firstFields&quot;</span><span class="s0">,</span><span class="s1">&quot;lastFields&quot;</span><span class="s0">,</span><span class="s1">&quot;lastFieldsStart&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV4ADDRESS&quot;</span><span class="s0">,</span><span class="s1">&quot;last&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;_stripLeadingZeros&quot;</span><span class="s0">,</span><span class="s1">&quot;first&quot;</span><span class="s0">,</span><span class="s1">&quot;address&quot;</span><span class="s0">,</span><span class="s1">&quot;reverse&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_FRAGMENT&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_QUERY&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_PATH&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_PATH_NOSCHEME&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_HOST&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_USERINFO&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_SCHEME&quot;</span><span class="s0">,</span><span class="s1">&quot;_normalizeComponentEncoding&quot;</span><span class="s0">,</span><span class="s1">&quot;newStr&quot;</span><span class="s0">,</span><span class="s1">&quot;substr&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;fromCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;c&quot;</span><span class="s0">,</span><span class="s1">&quot;c2&quot;</span><span class="s0">,</span><span class="s1">&quot;c3&quot;</span><span class="s0">,</span><span class="s1">&quot;il&quot;</span><span class="s0">,</span><span class="s1">&quot;chr&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;encode&quot;</span><span class="s0">,</span><span class="s1">&quot;decode&quot;</span><span class="s0">,</span><span class="s1">&quot;ucs2encode&quot;</span><span class="s0">,</span><span class="s1">&quot;ucs2decode&quot;</span><span class="s0">,</span><span class="s1">&quot;regexNonASCII&quot;</span><span class="s0">,</span><span class="s1">&quot;string&quot;</span><span class="s0">,</span><span class="s1">&quot;mapDomain&quot;</span><span class="s0">,</span><span class="s1">&quot;regexPunycode&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;delta&quot;</span><span class="s0">,</span><span class="s1">&quot;handledCPCount&quot;</span><span class="s0">,</span><span class="s1">&quot;adapt&quot;</span><span class="s0">,</span><span class="s1">&quot;handledCPCountPlusOne&quot;</span><span class="s0">,</span><span class="s1">&quot;basicLength&quot;</span><span class="s0">,</span><span class="s1">&quot;stringFromCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;digitToBasic&quot;</span><span class="s0">,</span><span class="s1">&quot;q&quot;</span><span class="s0">,</span><span class="s1">&quot;floor&quot;</span><span class="s0">,</span><span class="s1">&quot;qMinusT&quot;</span><span class="s0">,</span><span class="s1">&quot;baseMinusT&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;k&quot;</span><span class="s0">,</span><span class="s1">&quot;bias&quot;</span><span class="s0">,</span><span class="s1">&quot;tMin&quot;</span><span class="s0">,</span><span class="s1">&quot;tMax&quot;</span><span class="s0">,</span><span class="s1">&quot;currentValue&quot;</span><span class="s0">,</span><span class="s1">&quot;maxInt&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;inputLength&quot;</span><span class="s0">,</span><span class="s1">&quot;delimiter&quot;</span><span class="s0">,</span><span class="s1">&quot;initialBias&quot;</span><span class="s0">,</span><span class="s1">&quot;initialN&quot;</span><span class="s0">,</span><span class="s1">&quot;fromCodePoint&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;out&quot;</span><span class="s0">,</span><span class="s1">&quot;oldi&quot;</span><span class="s0">,</span><span class="s1">&quot;w&quot;</span><span class="s0">,</span><span class="s1">&quot;digit&quot;</span><span class="s0">,</span><span class="s1">&quot;basicToDigit&quot;</span><span class="s0">,</span><span class="s1">&quot;basic&quot;</span><span class="s0">,</span><span class="s1">&quot;j&quot;</span><span class="s0">,</span><span class="s1">&quot;baseMinusTMin&quot;</span><span class="s0">,</span><span class="s1">&quot;skew&quot;</span><span class="s0">,</span><span class="s1">&quot;numPoints&quot;</span><span class="s0">,</span><span class="s1">&quot;firstTime&quot;</span><span class="s0">,</span><span class="s1">&quot;damp&quot;</span><span class="s0">,</span><span class="s1">&quot;flag&quot;</span><span class="s0">,</span><span class="s1">&quot;codePoint&quot;</span><span class="s0">,</span><span class="s1">&quot;array&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;extra&quot;</span><span class="s0">,</span><span class="s1">&quot;counter&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;encoded&quot;</span><span class="s0">,</span><span class="s1">&quot;labels&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;regexSeparators&quot;</span><span class="s0">,</span><span class="s1">&quot;parts&quot;</span><span class="s0">,</span><span class="s1">&quot;RangeError&quot;</span><span class="s0">,</span><span class="s1">&quot;errors&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;buildExps&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS$&quot;</span><span class="s0">,</span><span class="s1">&quot;ZONEID$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV4ADDRESS$&quot;</span><span class="s0">,</span><span class="s1">&quot;RESERVED$$&quot;</span><span class="s0">,</span><span class="s1">&quot;SUB_DELIMS$$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPRIVATE$$&quot;</span><span class="s0">,</span><span class="s1">&quot;ALPHA$$&quot;</span><span class="s0">,</span><span class="s1">&quot;DIGIT$$&quot;</span><span class="s0">,</span><span class="s1">&quot;AUTHORITY_REF$&quot;</span><span class="s0">,</span><span class="s1">&quot;USERINFO$&quot;</span><span class="s0">,</span><span class="s1">&quot;HOST$&quot;</span><span class="s0">,</span><span class="s1">&quot;PORT$&quot;</span><span class="s0">,</span><span class="s1">&quot;SAMEDOC_REF$&quot;</span><span class="s0">,</span><span class="s1">&quot;FRAGMENT$&quot;</span><span class="s0">,</span><span class="s1">&quot;ABSOLUTE_REF$&quot;</span><span class="s0">,</span><span class="s1">&quot;SCHEME$&quot;</span><span class="s0">,</span><span class="s1">&quot;PATH_ABEMPTY$&quot;</span><span class="s0">,</span><span class="s1">&quot;PATH_ABSOLUTE$&quot;</span><span class="s0">,</span><span class="s1">&quot;PATH_ROOTLESS$&quot;</span><span class="s0">,</span><span class="s1">&quot;PATH_EMPTY$&quot;</span><span class="s0">,</span><span class="s1">&quot;QUERY$&quot;</span><span class="s0">,</span><span class="s1">&quot;RELATIVE_REF$&quot;</span><span class="s0">,</span><span class="s1">&quot;PATH_NOSCHEME$&quot;</span><span class="s0">,</span><span class="s1">&quot;GENERIC_REF$&quot;</span><span class="s0">,</span><span class="s1">&quot;ABSOLUTE_URI$&quot;</span><span class="s0">,</span><span class="s1">&quot;HIER_PART$&quot;</span><span class="s0">,</span><span class="s1">&quot;URI_REFERENCE$&quot;</span><span class="s0">,</span><span class="s1">&quot;URI$&quot;</span><span class="s0">,</span><span class="s1">&quot;RELATIVE$&quot;</span><span class="s0">,</span><span class="s1">&quot;RELATIVE_PART$&quot;</span><span class="s0">,</span><span class="s1">&quot;AUTHORITY$&quot;</span><span class="s0">,</span><span class="s1">&quot;PCHAR$&quot;</span><span class="s0">,</span><span class="s1">&quot;PATH$&quot;</span><span class="s0">,</span><span class="s1">&quot;SEGMENT_NZ$&quot;</span><span class="s0">,</span><span class="s1">&quot;SEGMENT_NZ_NC$&quot;</span><span class="s0">,</span><span class="s1">&quot;SEGMENT$&quot;</span><span class="s0">,</span><span class="s1">&quot;IP_LITERAL$&quot;</span><span class="s0">,</span><span class="s1">&quot;REG_NAME$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRZ_RELAXED$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPVFUTURE$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS1$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS2$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS3$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS4$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS5$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS6$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS7$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS8$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS9$&quot;</span><span class="s0">,</span><span class="s1">&quot;H16$&quot;</span><span class="s0">,</span><span class="s1">&quot;LS32$&quot;</span><span class="s0">,</span><span class="s1">&quot;DEC_OCTET_RELAXED$&quot;</span><span class="s0">,</span><span class="s1">&quot;DEC_OCTET$&quot;</span><span class="s0">,</span><span class="s1">&quot;UCSCHAR$$&quot;</span><span class="s0">,</span><span class="s1">&quot;GEN_DELIMS$$&quot;</span><span class="s0">,</span><span class="s1">&quot;SP$$&quot;</span><span class="s0">,</span><span class="s1">&quot;DQUOTE$$&quot;</span><span class="s0">,</span><span class="s1">&quot;CR$&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;setInterval&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;o&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;shift&quot;</span><span class="s0">,</span><span class="s1">&quot;sets&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>