<html>
<head>
<title>family.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
family.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_index&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;getBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;_getBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;getOuterBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;_getOuterBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;isDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;numericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;unaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;NORMAL_COMPLETION&quot;</span><span class="s0">,</span><span class="s1">&quot;BREAK_COMPLETION&quot;</span><span class="s0">,</span><span class="s1">&quot;NormalCompletion&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;BreakCompletion&quot;</span><span class="s0">,</span><span class="s1">&quot;getOpposite&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;getSibling&quot;</span><span class="s0">,</span><span class="s1">&quot;addCompletionRecords&quot;</span><span class="s0">,</span><span class="s1">&quot;records&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;_getCompletionRecords&quot;</span><span class="s0">,</span><span class="s1">&quot;completionRecordForSwitch&quot;</span><span class="s0">,</span><span class="s1">&quot;cases&quot;</span><span class="s0">,</span><span class="s1">&quot;lastNormalCompletions&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;casePath&quot;</span><span class="s0">,</span><span class="s1">&quot;caseCompletions&quot;</span><span class="s0">,</span><span class="s1">&quot;normalCompletions&quot;</span><span class="s0">,</span><span class="s1">&quot;breakCompletions&quot;</span><span class="s0">,</span><span class="s1">&quot;c&quot;</span><span class="s0">,</span><span class="s1">&quot;normalCompletionToBreak&quot;</span><span class="s0">,</span><span class="s1">&quot;completions&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceBreakStatementInBreakCompletion&quot;</span><span class="s0">,</span><span class="s1">&quot;reachable&quot;</span><span class="s0">,</span><span class="s1">&quot;isBreakStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;label&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;getStatementListCompletion&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;canHaveBreak&quot;</span><span class="s0">,</span><span class="s1">&quot;newContext&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;inCaseClause&quot;</span><span class="s0">,</span><span class="s1">&quot;isBlockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldPopulateBreak&quot;</span><span class="s0">,</span><span class="s1">&quot;statementCompletions&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;pathCompletions&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isIfStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;isDoExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isFor&quot;</span><span class="s0">,</span><span class="s1">&quot;isWhile&quot;</span><span class="s0">,</span><span class="s1">&quot;isLabeledStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isProgram&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;isTryStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isCatchClause&quot;</span><span class="s0">,</span><span class="s1">&quot;isSwitchStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isSwitchCase&quot;</span><span class="s0">,</span><span class="s1">&quot;getCompletionRecords&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;r&quot;</span><span class="s0">,</span><span class="s1">&quot;NodePath&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;container&quot;</span><span class="s0">,</span><span class="s1">&quot;listKey&quot;</span><span class="s0">,</span><span class="s1">&quot;setContext&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrevSibling&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextSibling&quot;</span><span class="s0">,</span><span class="s1">&quot;getAllNextSiblings&quot;</span><span class="s0">,</span><span class="s1">&quot;_key&quot;</span><span class="s0">,</span><span class="s1">&quot;sibling&quot;</span><span class="s0">,</span><span class="s1">&quot;siblings&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;getAllPrevSiblings&quot;</span><span class="s0">,</span><span class="s1">&quot;parts&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;_getKey&quot;</span><span class="s0">,</span><span class="s1">&quot;_getPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;part&quot;</span><span class="s0">,</span><span class="s1">&quot;duplicates&quot;</span><span class="s0">,</span><span class="s1">&quot;getBindingIdentifierPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;outerOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;ids&quot;</span><span class="s0">,</span><span class="s1">&quot;create&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;shift&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;_ids&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;child&quot;</span><span class="s0">,</span><span class="s1">&quot;getOuterBindingIdentifierPaths&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/path/family.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// This file contains methods responsible for dealing with/retrieving children or siblings.</span><span class="s3">\n\n</span><span class="s1">import type TraversalContext from </span><span class="s3">\&quot;</span><span class="s1">../context.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import NodePath from </span><span class="s3">\&quot;</span><span class="s1">./index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getBindingIdentifiers as _getBindingIdentifiers,</span><span class="s3">\n  </span><span class="s1">getOuterBindingIdentifiers as _getOuterBindingIdentifiers,</span><span class="s3">\n  </span><span class="s1">isDeclaration,</span><span class="s3">\n  </span><span class="s1">numericLiteral,</span><span class="s3">\n  </span><span class="s1">unaryExpression,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const NORMAL_COMPLETION = 0 as const;</span><span class="s3">\n</span><span class="s1">const BREAK_COMPLETION = 1 as const;</span><span class="s3">\n\n</span><span class="s1">type Completion = {</span><span class="s3">\n  </span><span class="s1">path: NodePath;</span><span class="s3">\n  </span><span class="s1">type: 0 | 1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">type CompletionContext = {</span><span class="s3">\n  </span><span class="s1">// whether the current context allows `break` statement. When it allows, we have</span><span class="s3">\n  </span><span class="s1">// to search all the statements for potential `break`</span><span class="s3">\n  </span><span class="s1">canHaveBreak: boolean;</span><span class="s3">\n  </span><span class="s1">// whether the statement is an immediate descendant of a switch case clause</span><span class="s3">\n  </span><span class="s1">inCaseClause: boolean;</span><span class="s3">\n  </span><span class="s1">// whether the `break` statement record should be populated to upper level</span><span class="s3">\n  </span><span class="s1">// when a `break` statement is an immediate descendant of a block statement, e.g.</span><span class="s3">\n  </span><span class="s1">// `{ break }`, it can influence the control flow in the upper levels.</span><span class="s3">\n  </span><span class="s1">shouldPopulateBreak: boolean;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function NormalCompletion(path: NodePath) {</span><span class="s3">\n  </span><span class="s1">return { type: NORMAL_COMPLETION, path };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function BreakCompletion(path: NodePath) {</span><span class="s3">\n  </span><span class="s1">return { type: BREAK_COMPLETION, path };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getOpposite(this: NodePath): NodePath | null {</span><span class="s3">\n  </span><span class="s1">if (this.key === </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return this.getSibling(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else if (this.key === </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return this.getSibling(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function addCompletionRecords(</span><span class="s3">\n  </span><span class="s1">path: NodePath | null | undefined,</span><span class="s3">\n  </span><span class="s1">records: Completion[],</span><span class="s3">\n  </span><span class="s1">context: CompletionContext,</span><span class="s3">\n</span><span class="s1">): Completion[] {</span><span class="s3">\n  </span><span class="s1">if (path) {</span><span class="s3">\n    </span><span class="s1">records.push(..._getCompletionRecords(path, context));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return records;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function completionRecordForSwitch(</span><span class="s3">\n  </span><span class="s1">cases: NodePath&lt;t.SwitchCase&gt;[],</span><span class="s3">\n  </span><span class="s1">records: Completion[],</span><span class="s3">\n  </span><span class="s1">context: CompletionContext,</span><span class="s3">\n</span><span class="s1">): Completion[] {</span><span class="s3">\n  </span><span class="s1">// https://tc39.es/ecma262/#sec-runtime-semantics-caseblockevaluation</span><span class="s3">\n  </span><span class="s1">let lastNormalCompletions: Completion[] = [];</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; cases.length; i++) {</span><span class="s3">\n    </span><span class="s1">const casePath = cases[i];</span><span class="s3">\n    </span><span class="s1">const caseCompletions = _getCompletionRecords(casePath, context);</span><span class="s3">\n    </span><span class="s1">const normalCompletions = [];</span><span class="s3">\n    </span><span class="s1">const breakCompletions = [];</span><span class="s3">\n    </span><span class="s1">for (const c of caseCompletions) {</span><span class="s3">\n      </span><span class="s1">if (c.type === NORMAL_COMPLETION) {</span><span class="s3">\n        </span><span class="s1">normalCompletions.push(c);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (c.type === BREAK_COMPLETION) {</span><span class="s3">\n        </span><span class="s1">breakCompletions.push(c);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (normalCompletions.length) {</span><span class="s3">\n      </span><span class="s1">lastNormalCompletions = normalCompletions;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">records.push(...breakCompletions);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">records.push(...lastNormalCompletions);</span><span class="s3">\n  </span><span class="s1">return records;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function normalCompletionToBreak(completions: Completion[]) {</span><span class="s3">\n  </span><span class="s1">completions.forEach(c =&gt; {</span><span class="s3">\n    </span><span class="s1">c.type = BREAK_COMPLETION;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determine how we should handle the break statement for break completions</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Completion[]} completions</span><span class="s3">\n </span><span class="s1">* @param {boolean} reachable Whether the break statement is reachable after</span><span class="s3">\n   </span><span class="s1">we mark the normal completions _before_ the given break completions as the final</span><span class="s3">\n   </span><span class="s1">completions. For example,</span><span class="s3">\n   </span><span class="s1">`{ 0 }; break;` is transformed to `{ return 0 }; break;`, the `break` here is unreachable</span><span class="s3">\n   </span><span class="s1">and thus can be removed without consequences. We may in the future reserve them instead since</span><span class="s3">\n   </span><span class="s1">we do not consistently remove unreachable statements _after_ break</span><span class="s3">\n   </span><span class="s1">`{ var x = 0 }; break;` is transformed to `{ var x = 0 }; return void 0;`, the `break` is reachable</span><span class="s3">\n   </span><span class="s1">because we can not wrap variable declaration under a return statement</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function replaceBreakStatementInBreakCompletion(</span><span class="s3">\n  </span><span class="s1">completions: Completion[],</span><span class="s3">\n  </span><span class="s1">reachable: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">completions.forEach(c =&gt; {</span><span class="s3">\n    </span><span class="s1">if (c.path.isBreakStatement({ label: null })) {</span><span class="s3">\n      </span><span class="s1">if (reachable) {</span><span class="s3">\n        </span><span class="s1">c.path.replaceWith(unaryExpression(</span><span class="s3">\&quot;</span><span class="s1">void</span><span class="s3">\&quot;</span><span class="s1">, numericLiteral(0)));</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">c.path.remove();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getStatementListCompletion(</span><span class="s3">\n  </span><span class="s1">paths: NodePath[],</span><span class="s3">\n  </span><span class="s1">context: CompletionContext,</span><span class="s3">\n</span><span class="s1">): Completion[] {</span><span class="s3">\n  </span><span class="s1">const completions = [];</span><span class="s3">\n  </span><span class="s1">if (context.canHaveBreak) {</span><span class="s3">\n    </span><span class="s1">let lastNormalCompletions = [];</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; paths.length; i++) {</span><span class="s3">\n      </span><span class="s1">const path = paths[i];</span><span class="s3">\n      </span><span class="s1">const newContext = { ...context, inCaseClause: false };</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">path.isBlockStatement() &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(context.inCaseClause || // case test: { break }</span><span class="s3">\n          </span><span class="s1">context.shouldPopulateBreak) // case test: { { break } }</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">newContext.shouldPopulateBreak = true;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">newContext.shouldPopulateBreak = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const statementCompletions = _getCompletionRecords(path, newContext);</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">statementCompletions.length &gt; 0 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// we can stop search `paths` when we have seen a `path` that is</span><span class="s3">\n        </span><span class="s1">// effectively a `break` statement. Examples are</span><span class="s3">\n        </span><span class="s1">// - `break`</span><span class="s3">\n        </span><span class="s1">// - `if (true) { 1; break } else { 2; break }`</span><span class="s3">\n        </span><span class="s1">// - `{ break }```</span><span class="s3">\n        </span><span class="s1">// In other words, the paths after this `path` are unreachable</span><span class="s3">\n        </span><span class="s1">statementCompletions.every(c =&gt; c.type === BREAK_COMPLETION)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">lastNormalCompletions.length &gt; 0 &amp;&amp;</span><span class="s3">\n          </span><span class="s1">statementCompletions.every(c =&gt;</span><span class="s3">\n            </span><span class="s1">c.path.isBreakStatement({ label: null }),</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// when a break completion has a path as BreakStatement, it must be `{ break }`</span><span class="s3">\n          </span><span class="s1">// whose completion value we can not determine, otherwise it would have been</span><span class="s3">\n          </span><span class="s1">// replaced by `replaceBreakStatementInBreakCompletion`</span><span class="s3">\n          </span><span class="s1">// When we have seen normal completions from the last statement</span><span class="s3">\n          </span><span class="s1">// it is safe to stop populating break and mark normal completions as break</span><span class="s3">\n          </span><span class="s1">normalCompletionToBreak(lastNormalCompletions);</span><span class="s3">\n          </span><span class="s1">completions.push(...lastNormalCompletions);</span><span class="s3">\n          </span><span class="s1">// Declarations have empty completion record, however they can not be nested</span><span class="s3">\n          </span><span class="s1">// directly in return statement, i.e. `return (var a = 1)` is invalid.</span><span class="s3">\n          </span><span class="s1">if (lastNormalCompletions.some(c =&gt; c.path.isDeclaration())) {</span><span class="s3">\n            </span><span class="s1">completions.push(...statementCompletions);</span><span class="s3">\n            </span><span class="s1">replaceBreakStatementInBreakCompletion(</span><span class="s3">\n              </span><span class="s1">statementCompletions,</span><span class="s3">\n              </span><span class="s1">/* reachable */ true,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">replaceBreakStatementInBreakCompletion(</span><span class="s3">\n            </span><span class="s1">statementCompletions,</span><span class="s3">\n            </span><span class="s1">/* reachable */ false,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">completions.push(...statementCompletions);</span><span class="s3">\n          </span><span class="s1">if (!context.shouldPopulateBreak) {</span><span class="s3">\n            </span><span class="s1">replaceBreakStatementInBreakCompletion(</span><span class="s3">\n              </span><span class="s1">statementCompletions,</span><span class="s3">\n              </span><span class="s1">/* reachable */ true,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (i === paths.length - 1) {</span><span class="s3">\n        </span><span class="s1">completions.push(...statementCompletions);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">lastNormalCompletions = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; statementCompletions.length; i++) {</span><span class="s3">\n          </span><span class="s1">const c = statementCompletions[i];</span><span class="s3">\n          </span><span class="s1">if (c.type === BREAK_COMPLETION) {</span><span class="s3">\n            </span><span class="s1">completions.push(c);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (c.type === NORMAL_COMPLETION) {</span><span class="s3">\n            </span><span class="s1">lastNormalCompletions.push(c);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (paths.length) {</span><span class="s3">\n    </span><span class="s1">// When we are in a context where `break` must not exist, we can skip linear</span><span class="s3">\n    </span><span class="s1">// search on statement lists and assume that the last</span><span class="s3">\n    </span><span class="s1">// non-variable-declaration statement determines the completion.</span><span class="s3">\n    </span><span class="s1">for (let i = paths.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n      </span><span class="s1">const pathCompletions = _getCompletionRecords(paths[i], context);</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">pathCompletions.length &gt; 1 ||</span><span class="s3">\n        </span><span class="s1">(pathCompletions.length === 1 &amp;&amp;</span><span class="s3">\n          </span><span class="s1">!pathCompletions[0].path.isVariableDeclaration())</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">completions.push(...pathCompletions);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return completions;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function _getCompletionRecords(</span><span class="s3">\n  </span><span class="s1">path: NodePath,</span><span class="s3">\n  </span><span class="s1">context: CompletionContext,</span><span class="s3">\n</span><span class="s1">): Completion[] {</span><span class="s3">\n  </span><span class="s1">let records: Completion[] = [];</span><span class="s3">\n  </span><span class="s1">if (path.isIfStatement()) {</span><span class="s3">\n    </span><span class="s1">records = addCompletionRecords(path.get(</span><span class="s3">\&quot;</span><span class="s1">consequent</span><span class="s3">\&quot;</span><span class="s1">), records, context);</span><span class="s3">\n    </span><span class="s1">records = addCompletionRecords(path.get(</span><span class="s3">\&quot;</span><span class="s1">alternate</span><span class="s3">\&quot;</span><span class="s1">), records, context);</span><span class="s3">\n  </span><span class="s1">} else if (</span><span class="s3">\n    </span><span class="s1">path.isDoExpression() ||</span><span class="s3">\n    </span><span class="s1">path.isFor() ||</span><span class="s3">\n    </span><span class="s1">path.isWhile() ||</span><span class="s3">\n    </span><span class="s1">path.isLabeledStatement()</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error(flow-&gt;ts): todo</span><span class="s3">\n    </span><span class="s1">return addCompletionRecords(path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">), records, context);</span><span class="s3">\n  </span><span class="s1">} else if (path.isProgram() || path.isBlockStatement()) {</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error(flow-&gt;ts): todo</span><span class="s3">\n    </span><span class="s1">return getStatementListCompletion(path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">), context);</span><span class="s3">\n  </span><span class="s1">} else if (path.isFunction()) {</span><span class="s3">\n    </span><span class="s1">return _getCompletionRecords(path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">), context);</span><span class="s3">\n  </span><span class="s1">} else if (path.isTryStatement()) {</span><span class="s3">\n    </span><span class="s1">records = addCompletionRecords(path.get(</span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot;</span><span class="s1">), records, context);</span><span class="s3">\n    </span><span class="s1">records = addCompletionRecords(path.get(</span><span class="s3">\&quot;</span><span class="s1">handler</span><span class="s3">\&quot;</span><span class="s1">), records, context);</span><span class="s3">\n  </span><span class="s1">} else if (path.isCatchClause()) {</span><span class="s3">\n    </span><span class="s1">return addCompletionRecords(path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">), records, context);</span><span class="s3">\n  </span><span class="s1">} else if (path.isSwitchStatement()) {</span><span class="s3">\n    </span><span class="s1">return completionRecordForSwitch(path.get(</span><span class="s3">\&quot;</span><span class="s1">cases</span><span class="s3">\&quot;</span><span class="s1">), records, context);</span><span class="s3">\n  </span><span class="s1">} else if (path.isSwitchCase()) {</span><span class="s3">\n    </span><span class="s1">return getStatementListCompletion(path.get(</span><span class="s3">\&quot;</span><span class="s1">consequent</span><span class="s3">\&quot;</span><span class="s1">), {</span><span class="s3">\n      </span><span class="s1">canHaveBreak: true,</span><span class="s3">\n      </span><span class="s1">shouldPopulateBreak: false,</span><span class="s3">\n      </span><span class="s1">inCaseClause: true,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">} else if (path.isBreakStatement()) {</span><span class="s3">\n    </span><span class="s1">records.push(BreakCompletion(path));</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">records.push(NormalCompletion(path));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return records;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Retrieve the completion records of a given path.</span><span class="s3">\n </span><span class="s1">* Note: to ensure proper support on `break` statement, this method</span><span class="s3">\n </span><span class="s1">* will manipulate the AST around the break statement. Do not call the method</span><span class="s3">\n </span><span class="s1">* twice for the same path.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @export</span><span class="s3">\n </span><span class="s1">* @param {NodePath} this</span><span class="s3">\n </span><span class="s1">* @returns {NodePath[]} Completion records</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getCompletionRecords(this: NodePath): NodePath[] {</span><span class="s3">\n  </span><span class="s1">const records = _getCompletionRecords(this, {</span><span class="s3">\n    </span><span class="s1">canHaveBreak: false,</span><span class="s3">\n    </span><span class="s1">shouldPopulateBreak: false,</span><span class="s3">\n    </span><span class="s1">inCaseClause: false,</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return records.map(r =&gt; r.path);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getSibling(this: NodePath, key: string | number): NodePath {</span><span class="s3">\n  </span><span class="s1">return NodePath.get({</span><span class="s3">\n    </span><span class="s1">parentPath: this.parentPath,</span><span class="s3">\n    </span><span class="s1">parent: this.parent,</span><span class="s3">\n    </span><span class="s1">container: this.container,</span><span class="s3">\n    </span><span class="s1">listKey: this.listKey,</span><span class="s3">\n    </span><span class="s1">key: key,</span><span class="s3">\n  </span><span class="s1">}).setContext(this.context);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getPrevSibling(this: NodePath): NodePath {</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) this.key could be a string</span><span class="s3">\n  </span><span class="s1">return this.getSibling(this.key - 1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getNextSibling(this: NodePath): NodePath {</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) this.key could be a string</span><span class="s3">\n  </span><span class="s1">return this.getSibling(this.key + 1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getAllNextSiblings(this: NodePath): NodePath[] {</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) this.key could be a string</span><span class="s3">\n  </span><span class="s1">let _key: number = this.key;</span><span class="s3">\n  </span><span class="s1">let sibling = this.getSibling(++_key);</span><span class="s3">\n  </span><span class="s1">const siblings = [];</span><span class="s3">\n  </span><span class="s1">while (sibling.node) {</span><span class="s3">\n    </span><span class="s1">siblings.push(sibling);</span><span class="s3">\n    </span><span class="s1">sibling = this.getSibling(++_key);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return siblings;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getAllPrevSiblings(this: NodePath): NodePath[] {</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) this.key could be a string</span><span class="s3">\n  </span><span class="s1">let _key: number = this.key;</span><span class="s3">\n  </span><span class="s1">let sibling = this.getSibling(--_key);</span><span class="s3">\n  </span><span class="s1">const siblings = [];</span><span class="s3">\n  </span><span class="s1">while (sibling.node) {</span><span class="s3">\n    </span><span class="s1">siblings.push(sibling);</span><span class="s3">\n    </span><span class="s1">sibling = this.getSibling(--_key);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return siblings;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// convert </span><span class="s3">\&quot;</span><span class="s1">1</span><span class="s3">\&quot; </span><span class="s1">to 1 (string index to number index)</span><span class="s3">\n</span><span class="s1">type MaybeToIndex&lt;T extends string&gt; = T extends `${bigint}` ? number : T;</span><span class="s3">\n\n</span><span class="s1">type Pattern&lt;Obj extends string, Prop extends string&gt; = `${Obj}.${Prop}`;</span><span class="s3">\n\n</span><span class="s1">// split </span><span class="s3">\&quot;</span><span class="s1">body.body.1</span><span class="s3">\&quot; </span><span class="s1">to [</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, 1]</span><span class="s3">\n</span><span class="s1">type Split&lt;P extends string&gt; = P extends Pattern&lt;infer O, infer U&gt;</span><span class="s3">\n  </span><span class="s1">? [MaybeToIndex&lt;O&gt;, ...Split&lt;U&gt;]</span><span class="s3">\n  </span><span class="s1">: [MaybeToIndex&lt;P&gt;];</span><span class="s3">\n\n</span><span class="s1">// get all K with Node[K] is t.Node | t.Node[]</span><span class="s3">\n</span><span class="s1">type NodeKeyOf&lt;Node extends t.Node | t.Node[]&gt; = keyof Pick&lt;</span><span class="s3">\n  </span><span class="s1">Node,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">[Key in keyof Node]-?: Node[Key] extends t.Node | t.Node[] ? Key : never;</span><span class="s3">\n  </span><span class="s1">}[keyof Node]</span><span class="s3">\n</span><span class="s1">&gt;;</span><span class="s3">\n\n</span><span class="s1">// traverse the Node with tuple path [</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, 1]</span><span class="s3">\n</span><span class="s1">// Path should be created with Split</span><span class="s3">\n</span><span class="s1">type Trav&lt;</span><span class="s3">\n  </span><span class="s1">Node extends t.Node | t.Node[],</span><span class="s3">\n  </span><span class="s1">Path extends unknown[],</span><span class="s3">\n</span><span class="s1">&gt; = Path extends [infer K, ...infer R]</span><span class="s3">\n  </span><span class="s1">? K extends NodeKeyOf&lt;Node&gt;</span><span class="s3">\n    </span><span class="s1">? R extends []</span><span class="s3">\n      </span><span class="s1">? Node[K]</span><span class="s3">\n      </span><span class="s1">: // @ts-expect-error ignore since TS is not smart enough</span><span class="s3">\n        </span><span class="s1">Trav&lt;Node[K], R&gt;</span><span class="s3">\n    </span><span class="s1">: never</span><span class="s3">\n  </span><span class="s1">: never;</span><span class="s3">\n\n</span><span class="s1">type ToNodePath&lt;T&gt; = T extends Array&lt;t.Node | null | undefined&gt;</span><span class="s3">\n  </span><span class="s1">? Array&lt;NodePath&lt;T[number]&gt;&gt;</span><span class="s3">\n  </span><span class="s1">: T extends t.Node | null | undefined</span><span class="s3">\n  </span><span class="s1">? NodePath&lt;T&gt;</span><span class="s3">\n  </span><span class="s1">: never;</span><span class="s3">\n\n</span><span class="s1">function get&lt;T extends t.Node, K extends keyof T&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">key: K,</span><span class="s3">\n  </span><span class="s1">context?: boolean | TraversalContext,</span><span class="s3">\n</span><span class="s1">): T[K] extends Array&lt;t.Node | null | undefined&gt;</span><span class="s3">\n  </span><span class="s1">? Array&lt;NodePath&lt;T[K][number]&gt;&gt;</span><span class="s3">\n  </span><span class="s1">: T[K] extends t.Node | null | undefined</span><span class="s3">\n  </span><span class="s1">? NodePath&lt;T[K]&gt;</span><span class="s3">\n  </span><span class="s1">: never;</span><span class="s3">\n\n</span><span class="s1">function get&lt;T extends t.Node, K extends string&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">key: K,</span><span class="s3">\n  </span><span class="s1">context?: boolean | TraversalContext,</span><span class="s3">\n</span><span class="s1">): ToNodePath&lt;Trav&lt;T, Split&lt;K&gt;&gt;&gt;;</span><span class="s3">\n\n</span><span class="s1">function get&lt;T extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">key: string,</span><span class="s3">\n  </span><span class="s1">context?: true | TraversalContext,</span><span class="s3">\n</span><span class="s1">): NodePath | NodePath[];</span><span class="s3">\n\n</span><span class="s1">function get&lt;T extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">key: string,</span><span class="s3">\n  </span><span class="s1">context: true | TraversalContext = true,</span><span class="s3">\n</span><span class="s1">): NodePath | NodePath[] {</span><span class="s3">\n  </span><span class="s1">if (context === true) context = this.context;</span><span class="s3">\n  </span><span class="s1">const parts = key.split(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">if (parts.length === 1) {</span><span class="s3">\n    </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;\n    </span><span class="s1">// @ts-expect-error key may not index T</span><span class="s3">\n    </span><span class="s1">return this._getKey(key, context);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">foo.bar</span><span class="s3">\&quot;\n    </span><span class="s1">return this._getPattern(parts, context);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { get };</span><span class="s3">\n\n</span><span class="s1">export function _getKey&lt;T extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">key: keyof T &amp; string,</span><span class="s3">\n  </span><span class="s1">context?: TraversalContext,</span><span class="s3">\n</span><span class="s1">): NodePath | NodePath[] {</span><span class="s3">\n  </span><span class="s1">const node = this.node;</span><span class="s3">\n  </span><span class="s1">const container = node[key];</span><span class="s3">\n\n  </span><span class="s1">if (Array.isArray(container)) {</span><span class="s3">\n    </span><span class="s1">// requested a container so give them all the paths</span><span class="s3">\n    </span><span class="s1">return container.map((_, i) =&gt; {</span><span class="s3">\n      </span><span class="s1">return NodePath.get({</span><span class="s3">\n        </span><span class="s1">listKey: key,</span><span class="s3">\n        </span><span class="s1">parentPath: this,</span><span class="s3">\n        </span><span class="s1">parent: node,</span><span class="s3">\n        </span><span class="s1">container: container,</span><span class="s3">\n        </span><span class="s1">key: i,</span><span class="s3">\n      </span><span class="s1">}).setContext(context);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return NodePath.get({</span><span class="s3">\n      </span><span class="s1">parentPath: this,</span><span class="s3">\n      </span><span class="s1">parent: node,</span><span class="s3">\n      </span><span class="s1">container: node,</span><span class="s3">\n      </span><span class="s1">key: key,</span><span class="s3">\n    </span><span class="s1">}).setContext(context);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _getPattern(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">parts: string[],</span><span class="s3">\n  </span><span class="s1">context?: TraversalContext,</span><span class="s3">\n</span><span class="s1">): NodePath | NodePath[] {</span><span class="s3">\n  </span><span class="s1">let path: NodePath | NodePath[] = this;</span><span class="s3">\n  </span><span class="s1">for (const part of parts) {</span><span class="s3">\n    </span><span class="s1">if (part === </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error todo(flow-ts): Can path be an array here?</span><span class="s3">\n      </span><span class="s1">path = path.parentPath;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (Array.isArray(path)) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error part may not index path</span><span class="s3">\n        </span><span class="s1">path = path[part];</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">path = path.get(part, context);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return path;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getBindingIdentifiers(</span><span class="s3">\n  </span><span class="s1">duplicates: true,</span><span class="s3">\n</span><span class="s1">): Record&lt;string, t.Identifier[]&gt;;</span><span class="s3">\n</span><span class="s1">function getBindingIdentifiers(</span><span class="s3">\n  </span><span class="s1">duplicates?: false,</span><span class="s3">\n</span><span class="s1">): Record&lt;string, t.Identifier&gt;;</span><span class="s3">\n</span><span class="s1">function getBindingIdentifiers(</span><span class="s3">\n  </span><span class="s1">duplicates: boolean,</span><span class="s3">\n</span><span class="s1">): Record&lt;string, t.Identifier[] | t.Identifier&gt;;</span><span class="s3">\n\n</span><span class="s1">function getBindingIdentifiers(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">duplicates?: boolean,</span><span class="s3">\n</span><span class="s1">): Record&lt;string, t.Identifier[] | t.Identifier&gt; {</span><span class="s3">\n  </span><span class="s1">return _getBindingIdentifiers(this.node, duplicates);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { getBindingIdentifiers };</span><span class="s3">\n\n</span><span class="s1">function getOuterBindingIdentifiers(</span><span class="s3">\n  </span><span class="s1">duplicates: true,</span><span class="s3">\n</span><span class="s1">): Record&lt;string, t.Identifier[]&gt;;</span><span class="s3">\n</span><span class="s1">function getOuterBindingIdentifiers(</span><span class="s3">\n  </span><span class="s1">duplicates?: false,</span><span class="s3">\n</span><span class="s1">): Record&lt;string, t.Identifier&gt;;</span><span class="s3">\n</span><span class="s1">function getOuterBindingIdentifiers(</span><span class="s3">\n  </span><span class="s1">duplicates: boolean,</span><span class="s3">\n</span><span class="s1">): Record&lt;string, t.Identifier[] | t.Identifier&gt;;</span><span class="s3">\n\n</span><span class="s1">function getOuterBindingIdentifiers(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">duplicates?: boolean,</span><span class="s3">\n</span><span class="s1">): Record&lt;string, t.Identifier[] | t.Identifier&gt; {</span><span class="s3">\n  </span><span class="s1">return _getOuterBindingIdentifiers(this.node, duplicates);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { getOuterBindingIdentifiers };</span><span class="s3">\n\n</span><span class="s1">function getBindingIdentifierPaths(</span><span class="s3">\n  </span><span class="s1">duplicates: true,</span><span class="s3">\n  </span><span class="s1">outerOnly?: boolean,</span><span class="s3">\n</span><span class="s1">): Record&lt;string, NodePath&lt;t.Identifier&gt;[]&gt;;</span><span class="s3">\n</span><span class="s1">function getBindingIdentifierPaths(</span><span class="s3">\n  </span><span class="s1">duplicates: false,</span><span class="s3">\n  </span><span class="s1">outerOnly?: boolean,</span><span class="s3">\n</span><span class="s1">): Record&lt;string, NodePath&lt;t.Identifier&gt;&gt;;</span><span class="s3">\n</span><span class="s1">function getBindingIdentifierPaths(</span><span class="s3">\n  </span><span class="s1">duplicates?: boolean,</span><span class="s3">\n  </span><span class="s1">outerOnly?: boolean,</span><span class="s3">\n</span><span class="s1">): Record&lt;string, NodePath&lt;t.Identifier&gt; | NodePath&lt;t.Identifier&gt;[]&gt;;</span><span class="s3">\n\n</span><span class="s1">// original source - https://github.com/babel/babel/blob/main/packages/babel-types/src/retrievers/getBindingIdentifiers.js</span><span class="s3">\n</span><span class="s1">// path.getBindingIdentifiers returns nodes where the following re-implementation returns paths</span><span class="s3">\n</span><span class="s1">function getBindingIdentifierPaths(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">duplicates: boolean = false,</span><span class="s3">\n  </span><span class="s1">outerOnly: boolean = false,</span><span class="s3">\n</span><span class="s1">): Record&lt;string, NodePath&lt;t.Identifier&gt; | NodePath&lt;t.Identifier&gt;[]&gt; {</span><span class="s3">\n  </span><span class="s1">const path = this;</span><span class="s3">\n  </span><span class="s1">const search = [path];</span><span class="s3">\n  </span><span class="s1">const ids = Object.create(null);</span><span class="s3">\n\n  </span><span class="s1">while (search.length) {</span><span class="s3">\n    </span><span class="s1">const id = search.shift();</span><span class="s3">\n    </span><span class="s1">if (!id) continue;</span><span class="s3">\n    </span><span class="s1">if (!id.node) continue;</span><span class="s3">\n\n    </span><span class="s1">const keys =</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error _getBindingIdentifiers.keys do not cover all node types</span><span class="s3">\n      </span><span class="s1">_getBindingIdentifiers.keys[id.node.type];</span><span class="s3">\n\n    </span><span class="s1">if (id.isIdentifier()) {</span><span class="s3">\n      </span><span class="s1">if (duplicates) {</span><span class="s3">\n        </span><span class="s1">const _ids = (ids[id.node.name] = ids[id.node.name] || []);</span><span class="s3">\n        </span><span class="s1">_ids.push(id);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">ids[id.node.name] = id;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (id.isExportDeclaration()) {</span><span class="s3">\n      </span><span class="s1">const declaration = id.get(</span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (isDeclaration(declaration)) {</span><span class="s3">\n        </span><span class="s1">search.push(declaration);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (outerOnly) {</span><span class="s3">\n      </span><span class="s1">if (id.isFunctionDeclaration()) {</span><span class="s3">\n        </span><span class="s1">search.push(id.get(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (id.isFunctionExpression()) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (keys) {</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; keys.length; i++) {</span><span class="s3">\n        </span><span class="s1">const key = keys[i];</span><span class="s3">\n        </span><span class="s1">const child = id.get(key);</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(child)) {</span><span class="s3">\n          </span><span class="s1">search.push(...child);</span><span class="s3">\n        </span><span class="s1">} else if (child.node) {</span><span class="s3">\n          </span><span class="s1">search.push(child);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return ids;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { getBindingIdentifierPaths };</span><span class="s3">\n\n</span><span class="s1">function getOuterBindingIdentifierPaths(</span><span class="s3">\n  </span><span class="s1">duplicates: true,</span><span class="s3">\n</span><span class="s1">): Record&lt;string, NodePath&lt;t.Identifier&gt;[]&gt;;</span><span class="s3">\n</span><span class="s1">function getOuterBindingIdentifierPaths(</span><span class="s3">\n  </span><span class="s1">duplicates?: false,</span><span class="s3">\n</span><span class="s1">): Record&lt;string, NodePath&lt;t.Identifier&gt;&gt;;</span><span class="s3">\n</span><span class="s1">function getOuterBindingIdentifierPaths(</span><span class="s3">\n  </span><span class="s1">duplicates?: boolean,</span><span class="s3">\n</span><span class="s1">): Record&lt;string, NodePath&lt;t.Identifier&gt; | NodePath&lt;t.Identifier&gt;[]&gt;;</span><span class="s3">\n\n</span><span class="s1">function getOuterBindingIdentifierPaths(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">duplicates: boolean = false,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return this.getBindingIdentifierPaths(duplicates, true);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { getOuterBindingIdentifierPaths };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>