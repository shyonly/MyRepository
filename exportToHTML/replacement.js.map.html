<html>
<head>
<title>replacement.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
replacement.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_codeFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_index&quot;</span><span class="s0">,</span><span class="s1">&quot;_index2&quot;</span><span class="s0">,</span><span class="s1">&quot;_cache&quot;</span><span class="s0">,</span><span class="s1">&quot;_parser&quot;</span><span class="s0">,</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperHoistVariables&quot;</span><span class="s0">,</span><span class="s1">&quot;FUNCTION_TYPES&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;awaitExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritLeadingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritTrailingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritsComments&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isProgram&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;removeComments&quot;</span><span class="s0">,</span><span class="s1">&quot;returnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;toSequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;validate&quot;</span><span class="s0">,</span><span class="s1">&quot;yieldExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWithMultiple&quot;</span><span class="s0">,</span><span class="s1">&quot;nodes&quot;</span><span class="s0">,</span><span class="s1">&quot;_getCachedPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;resync&quot;</span><span class="s0">,</span><span class="s1">&quot;_verifyNodeList&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;getCachedPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;hub&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;container&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;insertAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;requeue&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWithSourceString&quot;</span><span class="s0">,</span><span class="s1">&quot;replacement&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;codeFrameColumns&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;line&quot;</span><span class="s0">,</span><span class="s1">&quot;column&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionAST&quot;</span><span class="s0">,</span><span class="s1">&quot;program&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;removeProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;replacementPath&quot;</span><span class="s0">,</span><span class="s1">&quot;removed&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;NodePath&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;nodePath&quot;</span><span class="s0">,</span><span class="s1">&quot;isNodeType&quot;</span><span class="s0">,</span><span class="s1">&quot;canHaveVariableDeclarationOrExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;canSwapBetweenExpressionAndStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDefaultDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceExpressionWithStatements&quot;</span><span class="s0">,</span><span class="s1">&quot;oldNode&quot;</span><span class="s0">,</span><span class="s1">&quot;_replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;setScope&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;_getCachedPaths2&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferenceError&quot;</span><span class="s0">,</span><span class="s1">&quot;inList&quot;</span><span class="s0">,</span><span class="s1">&quot;debug&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;nodesAsSequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;functionParent&quot;</span><span class="s0">,</span><span class="s1">&quot;getFunctionParent&quot;</span><span class="s0">,</span><span class="s1">&quot;isParentAsync&quot;</span><span class="s0">,</span><span class="s1">&quot;is&quot;</span><span class="s0">,</span><span class="s1">&quot;isParentGenerator&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;hoistVariables&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;completionRecords&quot;</span><span class="s0">,</span><span class="s1">&quot;getCompletionRecords&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;loop&quot;</span><span class="s0">,</span><span class="s1">&quot;findParent&quot;</span><span class="s0">,</span><span class="s1">&quot;isLoop&quot;</span><span class="s0">,</span><span class="s1">&quot;uid&quot;</span><span class="s0">,</span><span class="s1">&quot;getData&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDeclaredUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;pushContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;setData&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionToExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;newCallee&quot;</span><span class="s0">,</span><span class="s1">&quot;needToAwaitFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;hasType&quot;</span><span class="s0">,</span><span class="s1">&quot;needToYieldFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceInline&quot;</span><span class="s0">,</span><span class="s1">&quot;_containerInsertAfter&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/path/replacement.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// This file contains methods responsible for replacing a node with another.</span><span class="s3">\n\n</span><span class="s1">import { codeFrameColumns } from </span><span class="s3">\&quot;</span><span class="s1">@babel/code-frame</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import traverse from </span><span class="s3">\&quot;</span><span class="s1">../index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import NodePath from </span><span class="s3">\&quot;</span><span class="s1">./index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getCachedPaths } from </span><span class="s3">\&quot;</span><span class="s1">../cache.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { parse } from </span><span class="s3">\&quot;</span><span class="s1">@babel/parser</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">FUNCTION_TYPES,</span><span class="s3">\n  </span><span class="s1">arrowFunctionExpression,</span><span class="s3">\n  </span><span class="s1">assignmentExpression,</span><span class="s3">\n  </span><span class="s1">awaitExpression,</span><span class="s3">\n  </span><span class="s1">blockStatement,</span><span class="s3">\n  </span><span class="s1">callExpression,</span><span class="s3">\n  </span><span class="s1">cloneNode,</span><span class="s3">\n  </span><span class="s1">expressionStatement,</span><span class="s3">\n  </span><span class="s1">identifier,</span><span class="s3">\n  </span><span class="s1">inheritLeadingComments,</span><span class="s3">\n  </span><span class="s1">inheritTrailingComments,</span><span class="s3">\n  </span><span class="s1">inheritsComments,</span><span class="s3">\n  </span><span class="s1">isExpression,</span><span class="s3">\n  </span><span class="s1">isProgram,</span><span class="s3">\n  </span><span class="s1">isStatement,</span><span class="s3">\n  </span><span class="s1">removeComments,</span><span class="s3">\n  </span><span class="s1">returnStatement,</span><span class="s3">\n  </span><span class="s1">toSequenceExpression,</span><span class="s3">\n  </span><span class="s1">validate,</span><span class="s3">\n  </span><span class="s1">yieldExpression,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import hoistVariables from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-hoist-variables</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Replace a node with an array of multiple. This method performs the following steps:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*  - Inherit the comments of first provided node with that of the current node.</span><span class="s3">\n </span><span class="s1">*  - Insert the provided nodes after the current node.</span><span class="s3">\n </span><span class="s1">*  - Remove the current node.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function replaceWithMultiple(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">nodes: t.Node | t.Node[],</span><span class="s3">\n</span><span class="s1">): NodePath[] {</span><span class="s3">\n  </span><span class="s1">this.resync();</span><span class="s3">\n\n  </span><span class="s1">nodes = this._verifyNodeList(nodes);</span><span class="s3">\n  </span><span class="s1">inheritLeadingComments(nodes[0], this.node);</span><span class="s3">\n  </span><span class="s1">inheritTrailingComments(nodes[nodes.length - 1], this.node);</span><span class="s3">\n  </span><span class="s1">getCachedPaths(this.hub, this.parent)?.delete(this.node);</span><span class="s3">\n  </span><span class="s1">this.node =</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error this.key must present in this.container</span><span class="s3">\n    </span><span class="s1">this.container[this.key] = null;</span><span class="s3">\n  </span><span class="s1">const paths = this.insertAfter(nodes);</span><span class="s3">\n\n  </span><span class="s1">if (this.node) {</span><span class="s3">\n    </span><span class="s1">this.requeue();</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.remove();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return paths;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parse a string as an expression and replace the current node with the result.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* NOTE: This is typically not a good idea to use. Building source strings when</span><span class="s3">\n </span><span class="s1">* transforming ASTs is an antipattern and SHOULD NOT be encouraged. Even if it's</span><span class="s3">\n </span><span class="s1">* easier to use, your transforms will be extremely brittle.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function replaceWithSourceString(this: NodePath, replacement: string) {</span><span class="s3">\n  </span><span class="s1">this.resync();</span><span class="s3">\n  </span><span class="s1">let ast: t.File;</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">replacement = `(${replacement})`;</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error todo: use babel-types ast typings in Babel parser</span><span class="s3">\n    </span><span class="s1">ast = parse(replacement);</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">const loc = err.loc;</span><span class="s3">\n    </span><span class="s1">if (loc) {</span><span class="s3">\n      </span><span class="s1">err.message +=</span><span class="s3">\n        \&quot; </span><span class="s1">- make sure this is an expression.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        </span><span class="s1">codeFrameColumns(replacement, {</span><span class="s3">\n          </span><span class="s1">start: {</span><span class="s3">\n            </span><span class="s1">line: loc.line,</span><span class="s3">\n            </span><span class="s1">column: loc.column + 1,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">err.code = </span><span class="s3">\&quot;</span><span class="s1">BABEL_REPLACE_SOURCE_ERROR</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw err;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const expressionAST = (ast.program.body[0] as t.ExpressionStatement)</span><span class="s3">\n    </span><span class="s1">.expression;</span><span class="s3">\n  </span><span class="s1">traverse.removeProperties(expressionAST);</span><span class="s3">\n  </span><span class="s1">return this.replaceWith(expressionAST);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Replace the current node with another.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function replaceWith&lt;R extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">replacementPath: R | NodePath&lt;R&gt;,</span><span class="s3">\n</span><span class="s1">): [NodePath&lt;R&gt;] {</span><span class="s3">\n  </span><span class="s1">this.resync();</span><span class="s3">\n\n  </span><span class="s1">if (this.removed) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">You can't replace this node, we've already removed it</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let replacement: t.Node =</span><span class="s3">\n    </span><span class="s1">replacementPath instanceof NodePath</span><span class="s3">\n      </span><span class="s1">? replacementPath.node</span><span class="s3">\n      </span><span class="s1">: replacementPath;</span><span class="s3">\n\n  </span><span class="s1">if (!replacement) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">You passed `path.replaceWith()` a falsy node, use `path.remove()` instead</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.node === replacement) {</span><span class="s3">\n    </span><span class="s1">return [this as NodePath&lt;R&gt;];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.isProgram() &amp;&amp; !isProgram(replacement)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">You can only replace a Program root node with another Program node</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (Array.isArray(replacement)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (typeof replacement === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let nodePath = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n\n  </span><span class="s1">if (this.isNodeType(</span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; isExpression(replacement)) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!this.canHaveVariableDeclarationOrExpression() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!this.canSwapBetweenExpressionAndStatement(replacement) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!this.parentPath.isExportDefaultDeclaration()</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// replacing a statement with an expression so wrap it in an expression statement</span><span class="s3">\n      </span><span class="s1">replacement = expressionStatement(replacement);</span><span class="s3">\n      </span><span class="s1">nodePath = </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.isNodeType(</span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; isStatement(replacement)) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!this.canHaveVariableDeclarationOrExpression() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!this.canSwapBetweenExpressionAndStatement(replacement)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// replacing an expression with a statement so let's explode it</span><span class="s3">\n      </span><span class="s1">return this.replaceExpressionWithStatements([replacement]) as [</span><span class="s3">\n        </span><span class="s1">NodePath&lt;R&gt;,</span><span class="s3">\n      </span><span class="s1">];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const oldNode = this.node;</span><span class="s3">\n  </span><span class="s1">if (oldNode) {</span><span class="s3">\n    </span><span class="s1">inheritsComments(replacement, oldNode);</span><span class="s3">\n    </span><span class="s1">removeComments(oldNode);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// replace the node</span><span class="s3">\n  </span><span class="s1">this._replaceWith(replacement);</span><span class="s3">\n  </span><span class="s1">this.type = replacement.type;</span><span class="s3">\n\n  </span><span class="s1">// potentially create new scope</span><span class="s3">\n  </span><span class="s1">this.setScope();</span><span class="s3">\n\n  </span><span class="s1">// requeue for visiting</span><span class="s3">\n  </span><span class="s1">this.requeue();</span><span class="s3">\n\n  </span><span class="s1">return [</span><span class="s3">\n    </span><span class="s1">nodePath ? (this.get(nodePath) as NodePath&lt;R&gt;) : (this as NodePath&lt;R&gt;),</span><span class="s3">\n  </span><span class="s1">];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Description</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function _replaceWith(this: NodePath, node: t.Node) {</span><span class="s3">\n  </span><span class="s1">if (!this.container) {</span><span class="s3">\n    </span><span class="s1">throw new ReferenceError(</span><span class="s3">\&quot;</span><span class="s1">Container is falsy</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.inList) {</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): check if validate accepts a numeric key</span><span class="s3">\n    </span><span class="s1">validate(this.parent, this.key, [node]);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">validate(this.parent, this.key as string, node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.debug(`Replace with ${node?.type}`);</span><span class="s3">\n  </span><span class="s1">getCachedPaths(this.hub, this.parent)?.set(node, this).delete(this.node);</span><span class="s3">\n\n  </span><span class="s1">this.node =</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error this.key must present in this.container</span><span class="s3">\n    </span><span class="s1">this.container[this.key] = node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method takes an array of statements nodes and then explodes it</span><span class="s3">\n </span><span class="s1">* into expressions. This method retains completion records which is</span><span class="s3">\n </span><span class="s1">* extremely important to retain original semantics.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function replaceExpressionWithStatements(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">nodes: Array&lt;t.Statement&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">this.resync();</span><span class="s3">\n\n  </span><span class="s1">const nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);</span><span class="s3">\n\n  </span><span class="s1">if (nodesAsSequenceExpression) {</span><span class="s3">\n    </span><span class="s1">return this.replaceWith(nodesAsSequenceExpression)[0].get(</span><span class="s3">\&quot;</span><span class="s1">expressions</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const functionParent = this.getFunctionParent();</span><span class="s3">\n  </span><span class="s1">const isParentAsync = functionParent?.is(</span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const isParentGenerator = functionParent?.is(</span><span class="s3">\&quot;</span><span class="s1">generator</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">const container = arrowFunctionExpression([], blockStatement(nodes));</span><span class="s3">\n\n  </span><span class="s1">this.replaceWith(callExpression(container, []));</span><span class="s3">\n  </span><span class="s1">// replaceWith changes the type of </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">, but it isn't trackable by TS</span><span class="s3">\n  </span><span class="s1">type ThisType = NodePath&lt;</span><span class="s3">\n    </span><span class="s1">t.CallExpression &amp; {</span><span class="s3">\n      </span><span class="s1">callee: t.ArrowFunctionExpression &amp; { body: t.BlockStatement };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">&gt;;</span><span class="s3">\n\n  </span><span class="s1">// hoist variable declaration in do block</span><span class="s3">\n  </span><span class="s1">// `(do { var x = 1; x;})` -&gt; `var x; (() =&gt; { x = 1; return x; })()`</span><span class="s3">\n  </span><span class="s1">const callee = (this as ThisType).get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">hoistVariables(</span><span class="s3">\n    </span><span class="s1">callee.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">(id: t.Identifier) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.scope.push({ id });</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">// add implicit returns to all ending expression statements</span><span class="s3">\n  </span><span class="s1">const completionRecords: Array&lt;NodePath&gt; = (this as ThisType)</span><span class="s3">\n    </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">.getCompletionRecords();</span><span class="s3">\n  </span><span class="s1">for (const path of completionRecords) {</span><span class="s3">\n    </span><span class="s1">if (!path.isExpressionStatement()) continue;</span><span class="s3">\n\n    </span><span class="s1">const loop = path.findParent(path =&gt; path.isLoop());</span><span class="s3">\n    </span><span class="s1">if (loop) {</span><span class="s3">\n      </span><span class="s1">let uid = loop.getData(</span><span class="s3">\&quot;</span><span class="s1">expressionReplacementReturnUid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">if (!uid) {</span><span class="s3">\n        </span><span class="s1">uid = callee.scope.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">ret</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">callee</span><span class="s3">\n          </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">.pushContainer(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, returnStatement(cloneNode(uid)));</span><span class="s3">\n        </span><span class="s1">loop.setData(</span><span class="s3">\&quot;</span><span class="s1">expressionReplacementReturnUid</span><span class="s3">\&quot;</span><span class="s1">, uid);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">uid = identifier(uid.name);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">path</span><span class="s3">\n        </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replaceWith(</span><span class="s3">\n          </span><span class="s1">assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, cloneNode(uid), path.node.expression),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">path.replaceWith(returnStatement(path.node.expression));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// This is an IIFE, so we don't need to worry about the noNewArrows assumption</span><span class="s3">\n  </span><span class="s1">callee.arrowFunctionToExpression();</span><span class="s3">\n  </span><span class="s1">// Fixme: we can not `assert this is NodePath&lt;t.FunctionExpression&gt;` in `arrowFunctionToExpression`</span><span class="s3">\n  </span><span class="s1">// because it is not a class method known at compile time.</span><span class="s3">\n  </span><span class="s1">const newCallee = callee as unknown as NodePath&lt;t.FunctionExpression&gt;;</span><span class="s3">\n\n  </span><span class="s1">// (() =&gt; await xxx)() -&gt; await (async () =&gt; await xxx)();</span><span class="s3">\n  </span><span class="s1">const needToAwaitFunction =</span><span class="s3">\n    </span><span class="s1">isParentAsync &amp;&amp;</span><span class="s3">\n    </span><span class="s1">traverse.hasType(</span><span class="s3">\n      </span><span class="s1">(this.get(</span><span class="s3">\&quot;</span><span class="s1">callee.body</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.BlockStatement&gt;).node,</span><span class="s3">\n      \&quot;</span><span class="s1">AwaitExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">FUNCTION_TYPES,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const needToYieldFunction =</span><span class="s3">\n    </span><span class="s1">isParentGenerator &amp;&amp;</span><span class="s3">\n    </span><span class="s1">traverse.hasType(</span><span class="s3">\n      </span><span class="s1">(this.get(</span><span class="s3">\&quot;</span><span class="s1">callee.body</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.BlockStatement&gt;).node,</span><span class="s3">\n      \&quot;</span><span class="s1">YieldExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">FUNCTION_TYPES,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">if (needToAwaitFunction) {</span><span class="s3">\n    </span><span class="s1">newCallee.set(</span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n    </span><span class="s1">// yield* will await the generator return result</span><span class="s3">\n    </span><span class="s1">if (!needToYieldFunction) {</span><span class="s3">\n      </span><span class="s1">this.replaceWith(awaitExpression((this as ThisType).node));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (needToYieldFunction) {</span><span class="s3">\n    </span><span class="s1">newCallee.set(</span><span class="s3">\&quot;</span><span class="s1">generator</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n    </span><span class="s1">this.replaceWith(yieldExpression((this as ThisType).node, true));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return newCallee.get(</span><span class="s3">\&quot;</span><span class="s1">body.body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function replaceInline(this: NodePath, nodes: t.Node | Array&lt;t.Node&gt;) {</span><span class="s3">\n  </span><span class="s1">this.resync();</span><span class="s3">\n\n  </span><span class="s1">if (Array.isArray(nodes)) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(this.container)) {</span><span class="s3">\n      </span><span class="s1">nodes = this._verifyNodeList(nodes);</span><span class="s3">\n      </span><span class="s1">const paths = this._containerInsertAfter(nodes);</span><span class="s3">\n      </span><span class="s1">this.remove();</span><span class="s3">\n      </span><span class="s1">return paths;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return this.replaceWithMultiple(nodes);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return this.replaceWith(nodes);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>