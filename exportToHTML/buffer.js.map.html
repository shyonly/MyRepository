<html>
<head>
<title>buffer.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
buffer.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;Buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;_map&quot;</span><span class="s0">,</span><span class="s1">&quot;_buf&quot;</span><span class="s0">,</span><span class="s1">&quot;_str&quot;</span><span class="s0">,</span><span class="s1">&quot;_appendCount&quot;</span><span class="s0">,</span><span class="s1">&quot;_last&quot;</span><span class="s0">,</span><span class="s1">&quot;_queue&quot;</span><span class="s0">,</span><span class="s1">&quot;_queueCursor&quot;</span><span class="s0">,</span><span class="s1">&quot;_canMarkIdName&quot;</span><span class="s0">,</span><span class="s1">&quot;_position&quot;</span><span class="s0">,</span><span class="s1">&quot;line&quot;</span><span class="s0">,</span><span class="s1">&quot;column&quot;</span><span class="s0">,</span><span class="s1">&quot;_sourcePosition&quot;</span><span class="s0">,</span><span class="s1">&quot;identifierName&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;identifierNamePos&quot;</span><span class="s0">,</span><span class="s1">&quot;filename&quot;</span><span class="s0">,</span><span class="s1">&quot;_allocQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;queue&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;char&quot;</span><span class="s0">,</span><span class="s1">&quot;repeat&quot;</span><span class="s0">,</span><span class="s1">&quot;_pushQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;cursor&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;_popQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;_flush&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;trimRight&quot;</span><span class="s0">,</span><span class="s1">&quot;decodedMap&quot;</span><span class="s0">,</span><span class="s1">&quot;getDecoded&quot;</span><span class="s0">,</span><span class="s1">&quot;__mergedMap&quot;</span><span class="s0">,</span><span class="s1">&quot;resultMap&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;writable&quot;</span><span class="s0">,</span><span class="s1">&quot;rawMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">,</span><span class="s1">&quot;getRawMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;_append&quot;</span><span class="s0">,</span><span class="s1">&quot;appendChar&quot;</span><span class="s0">,</span><span class="s1">&quot;_appendChar&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcePosition&quot;</span><span class="s0">,</span><span class="s1">&quot;queueIndentation&quot;</span><span class="s0">,</span><span class="s1">&quot;queueCursor&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcePos&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;fromCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;_mark&quot;</span><span class="s0">,</span><span class="s1">&quot;len&quot;</span><span class="s0">,</span><span class="s1">&quot;position&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;last&quot;</span><span class="s0">,</span><span class="s1">&quot;_this$_map&quot;</span><span class="s0">,</span><span class="s1">&quot;mark&quot;</span><span class="s0">,</span><span class="s1">&quot;removeTrailingNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;removeLastSemicolon&quot;</span><span class="s0">,</span><span class="s1">&quot;getLastChar&quot;</span><span class="s0">,</span><span class="s1">&quot;getNewlineCount&quot;</span><span class="s0">,</span><span class="s1">&quot;count&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWithCharAndNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;lastCp&quot;</span><span class="s0">,</span><span class="s1">&quot;hasContent&quot;</span><span class="s0">,</span><span class="s1">&quot;exactSource&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;_normalizePosition&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceWithOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;columnOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;withSource&quot;</span><span class="s0">,</span><span class="s1">&quot;pos&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentColumn&quot;</span><span class="s0">,</span><span class="s1">&quot;lastIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentLine&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/buffer.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type SourceMap from </span><span class="s3">\&quot;</span><span class="s1">./source-map.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import * as charcodes from </span><span class="s3">\&quot;</span><span class="s1">charcodes</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export type Pos = {</span><span class="s3">\n  </span><span class="s1">line: number;</span><span class="s3">\n  </span><span class="s1">column: number;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">export type Loc = {</span><span class="s3">\n  </span><span class="s1">start?: Pos;</span><span class="s3">\n  </span><span class="s1">end?: Pos;</span><span class="s3">\n  </span><span class="s1">filename?: string;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">type SourcePos = {</span><span class="s3">\n  </span><span class="s1">line: number | undefined;</span><span class="s3">\n  </span><span class="s1">column: number | undefined;</span><span class="s3">\n  </span><span class="s1">identifierName: string | undefined;</span><span class="s3">\n  </span><span class="s1">filename: string | undefined;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">type InternalSourcePos = SourcePos &amp; { identifierNamePos: Pos };</span><span class="s3">\n\n</span><span class="s1">type QueueItem = {</span><span class="s3">\n  </span><span class="s1">char: number;</span><span class="s3">\n  </span><span class="s1">repeat: number;</span><span class="s3">\n  </span><span class="s1">line: number | undefined;</span><span class="s3">\n  </span><span class="s1">column: number | undefined;</span><span class="s3">\n  </span><span class="s1">identifierName: undefined; // Not used, it always undefined.</span><span class="s3">\n  </span><span class="s1">identifierNamePos: undefined; // Not used, it always undefined.</span><span class="s3">\n  </span><span class="s1">filename: string | undefined;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default class Buffer {</span><span class="s3">\n  </span><span class="s1">constructor(map?: SourceMap | null) {</span><span class="s3">\n    </span><span class="s1">this._map = map;</span><span class="s3">\n\n    </span><span class="s1">this._allocQueue();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_map: SourceMap = null;</span><span class="s3">\n  </span><span class="s1">_buf = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">_str = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">_appendCount = 0;</span><span class="s3">\n  </span><span class="s1">_last = 0;</span><span class="s3">\n  </span><span class="s1">_queue: QueueItem[] = [];</span><span class="s3">\n  </span><span class="s1">_queueCursor = 0;</span><span class="s3">\n  </span><span class="s1">_canMarkIdName = true;</span><span class="s3">\n\n  </span><span class="s1">_position = {</span><span class="s3">\n    </span><span class="s1">line: 1,</span><span class="s3">\n    </span><span class="s1">column: 0,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">_sourcePosition: InternalSourcePos = {</span><span class="s3">\n    </span><span class="s1">identifierName: undefined,</span><span class="s3">\n    </span><span class="s1">identifierNamePos: undefined,</span><span class="s3">\n    </span><span class="s1">line: undefined,</span><span class="s3">\n    </span><span class="s1">column: undefined,</span><span class="s3">\n    </span><span class="s1">filename: undefined,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">_allocQueue() {</span><span class="s3">\n    </span><span class="s1">const queue = this._queue;</span><span class="s3">\n\n    </span><span class="s1">for (let i = 0; i &lt; 16; i++) {</span><span class="s3">\n      </span><span class="s1">queue.push({</span><span class="s3">\n        </span><span class="s1">char: 0,</span><span class="s3">\n        </span><span class="s1">repeat: 1,</span><span class="s3">\n        </span><span class="s1">line: undefined,</span><span class="s3">\n        </span><span class="s1">column: undefined,</span><span class="s3">\n        </span><span class="s1">identifierName: undefined,</span><span class="s3">\n        </span><span class="s1">identifierNamePos: undefined,</span><span class="s3">\n        </span><span class="s1">filename: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_pushQueue(</span><span class="s3">\n    </span><span class="s1">char: number,</span><span class="s3">\n    </span><span class="s1">repeat: number,</span><span class="s3">\n    </span><span class="s1">line: number | undefined,</span><span class="s3">\n    </span><span class="s1">column: number | undefined,</span><span class="s3">\n    </span><span class="s1">filename: string | undefined,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const cursor = this._queueCursor;</span><span class="s3">\n    </span><span class="s1">if (cursor === this._queue.length) {</span><span class="s3">\n      </span><span class="s1">this._allocQueue();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const item = this._queue[cursor];</span><span class="s3">\n    </span><span class="s1">item.char = char;</span><span class="s3">\n    </span><span class="s1">item.repeat = repeat;</span><span class="s3">\n    </span><span class="s1">item.line = line;</span><span class="s3">\n    </span><span class="s1">item.column = column;</span><span class="s3">\n    </span><span class="s1">item.filename = filename;</span><span class="s3">\n\n    </span><span class="s1">this._queueCursor++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_popQueue(): QueueItem {</span><span class="s3">\n    </span><span class="s1">if (this._queueCursor === 0) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Cannot pop from empty queue</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this._queue[--this._queueCursor];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Get the final string output from the buffer, along with the sourcemap if one exists.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">get() {</span><span class="s3">\n    </span><span class="s1">this._flush();</span><span class="s3">\n\n    </span><span class="s1">const map = this._map;</span><span class="s3">\n    </span><span class="s1">const result = {</span><span class="s3">\n      </span><span class="s1">// Whatever trim is used here should not execute a regex against the</span><span class="s3">\n      </span><span class="s1">// source string since it may be arbitrarily large after all transformations</span><span class="s3">\n      </span><span class="s1">code: (this._buf + this._str).trimRight(),</span><span class="s3">\n      </span><span class="s1">// Decoded sourcemap is free to generate.</span><span class="s3">\n      </span><span class="s1">decodedMap: map?.getDecoded(),</span><span class="s3">\n      </span><span class="s1">// Used as a marker for backwards compatibility. We moved input map merging</span><span class="s3">\n      </span><span class="s1">// into the generator. We cannot merge the input map a second time, so the</span><span class="s3">\n      </span><span class="s1">// presence of this field tells us we've already done the work.</span><span class="s3">\n      </span><span class="s1">get __mergedMap() {</span><span class="s3">\n        </span><span class="s1">return this.map;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">// Encoding the sourcemap is moderately CPU expensive.</span><span class="s3">\n      </span><span class="s1">get map() {</span><span class="s3">\n        </span><span class="s1">const resultMap = map ? map.get() : null;</span><span class="s3">\n        </span><span class="s1">result.map = resultMap;</span><span class="s3">\n        </span><span class="s1">return resultMap;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">set map(value) {</span><span class="s3">\n        </span><span class="s1">Object.defineProperty(result, </span><span class="s3">\&quot;</span><span class="s1">map</span><span class="s3">\&quot;</span><span class="s1">, { value, writable: true });</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">// Retrieving the raw mappings is very memory intensive.</span><span class="s3">\n      </span><span class="s1">get rawMappings() {</span><span class="s3">\n        </span><span class="s1">const mappings = map?.getRawMappings();</span><span class="s3">\n        </span><span class="s1">result.rawMappings = mappings;</span><span class="s3">\n        </span><span class="s1">return mappings;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">set rawMappings(value) {</span><span class="s3">\n        </span><span class="s1">Object.defineProperty(result, </span><span class="s3">\&quot;</span><span class="s1">rawMappings</span><span class="s3">\&quot;</span><span class="s1">, { value, writable: true });</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">return result;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Add a string to the buffer that cannot be reverted.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">append(str: string, maybeNewline: boolean): void {</span><span class="s3">\n    </span><span class="s1">this._flush();</span><span class="s3">\n\n    </span><span class="s1">this._append(str, this._sourcePosition, maybeNewline);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">appendChar(char: number): void {</span><span class="s3">\n    </span><span class="s1">this._flush();</span><span class="s3">\n    </span><span class="s1">this._appendChar(char, 1, this._sourcePosition);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Add a string to the buffer than can be reverted.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">queue(char: number): void {</span><span class="s3">\n    </span><span class="s1">// Drop trailing spaces when a newline is inserted.</span><span class="s3">\n    </span><span class="s1">if (char === charcodes.lineFeed) {</span><span class="s3">\n      </span><span class="s1">while (this._queueCursor !== 0) {</span><span class="s3">\n        </span><span class="s1">const char = this._queue[this._queueCursor - 1].char;</span><span class="s3">\n        </span><span class="s1">if (char !== charcodes.space &amp;&amp; char !== charcodes.tab) {</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">this._queueCursor--;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const sourcePosition = this._sourcePosition;</span><span class="s3">\n    </span><span class="s1">this._pushQueue(</span><span class="s3">\n      </span><span class="s1">char,</span><span class="s3">\n      </span><span class="s1">1,</span><span class="s3">\n      </span><span class="s1">sourcePosition.line,</span><span class="s3">\n      </span><span class="s1">sourcePosition.column,</span><span class="s3">\n      </span><span class="s1">sourcePosition.filename,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Same as queue, but this indentation will never have a sourcemap marker.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">queueIndentation(char: number, repeat: number): void {</span><span class="s3">\n    </span><span class="s1">this._pushQueue(char, repeat, undefined, undefined, undefined);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_flush(): void {</span><span class="s3">\n    </span><span class="s1">const queueCursor = this._queueCursor;</span><span class="s3">\n    </span><span class="s1">const queue = this._queue;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; queueCursor; i++) {</span><span class="s3">\n      </span><span class="s1">const item: QueueItem = queue[i];</span><span class="s3">\n      </span><span class="s1">this._appendChar(item.char, item.repeat, item);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._queueCursor = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_appendChar(</span><span class="s3">\n    </span><span class="s1">char: number,</span><span class="s3">\n    </span><span class="s1">repeat: number,</span><span class="s3">\n    </span><span class="s1">sourcePos: InternalSourcePos,</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">this._last = char;</span><span class="s3">\n\n    </span><span class="s1">this._str +=</span><span class="s3">\n      </span><span class="s1">repeat &gt; 1</span><span class="s3">\n        </span><span class="s1">? String.fromCharCode(char).repeat(repeat)</span><span class="s3">\n        </span><span class="s1">: String.fromCharCode(char);</span><span class="s3">\n\n    </span><span class="s1">if (char !== charcodes.lineFeed) {</span><span class="s3">\n      </span><span class="s1">this._mark(</span><span class="s3">\n        </span><span class="s1">sourcePos.line,</span><span class="s3">\n        </span><span class="s1">sourcePos.column,</span><span class="s3">\n        </span><span class="s1">sourcePos.identifierName,</span><span class="s3">\n        </span><span class="s1">sourcePos.identifierNamePos,</span><span class="s3">\n        </span><span class="s1">sourcePos.filename,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">this._position.column += repeat;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this._position.line++;</span><span class="s3">\n      </span><span class="s1">this._position.column = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this._canMarkIdName) {</span><span class="s3">\n      </span><span class="s1">sourcePos.identifierName = undefined;</span><span class="s3">\n      </span><span class="s1">sourcePos.identifierNamePos = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_append(</span><span class="s3">\n    </span><span class="s1">str: string,</span><span class="s3">\n    </span><span class="s1">sourcePos: InternalSourcePos,</span><span class="s3">\n    </span><span class="s1">maybeNewline: boolean,</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">const len = str.length;</span><span class="s3">\n    </span><span class="s1">const position = this._position;</span><span class="s3">\n\n    </span><span class="s1">this._last = str.charCodeAt(len - 1);</span><span class="s3">\n\n    </span><span class="s1">if (++this._appendCount &gt; 4096) {</span><span class="s3">\n      </span><span class="s1">+this._str; // Unexplainable huge performance boost. Ref: https://github.com/davidmarkclements/flatstr License: MIT</span><span class="s3">\n      </span><span class="s1">this._buf += this._str;</span><span class="s3">\n      </span><span class="s1">this._str = str;</span><span class="s3">\n      </span><span class="s1">this._appendCount = 0;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this._str += str;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!maybeNewline &amp;&amp; !this._map) {</span><span class="s3">\n      </span><span class="s1">position.column += len;</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const { column, identifierName, identifierNamePos, filename } = sourcePos;</span><span class="s3">\n    </span><span class="s1">let line = sourcePos.line;</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(identifierName != null || identifierNamePos != null) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this._canMarkIdName</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">sourcePos.identifierName = undefined;</span><span class="s3">\n      </span><span class="s1">sourcePos.identifierNamePos = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Search for newline chars. We search only for `</span><span class="s3">\\</span><span class="s1">n`, since both `</span><span class="s3">\\</span><span class="s1">r` and</span><span class="s3">\n    </span><span class="s1">// `</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n` are normalized to `</span><span class="s3">\\</span><span class="s1">n` during parse. We exclude `</span><span class="s3">\\</span><span class="s1">u2028` and</span><span class="s3">\n    </span><span class="s1">// `</span><span class="s3">\\</span><span class="s1">u2029` for performance reasons, they're so uncommon that it's probably</span><span class="s3">\n    </span><span class="s1">// ok. It's also unclear how other sourcemap utilities handle them...</span><span class="s3">\n    </span><span class="s1">let i = str.indexOf(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let last = 0;</span><span class="s3">\n\n    </span><span class="s1">// If the string starts with a newline char, then adding a mark is redundant.</span><span class="s3">\n    </span><span class="s1">// This catches both </span><span class="s3">\&quot;</span><span class="s1">no newlines</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">newline after several chars</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n    </span><span class="s1">if (i !== 0) {</span><span class="s3">\n      </span><span class="s1">this._mark(line, column, identifierName, identifierNamePos, filename);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Now, find each remaining newline char in the string.</span><span class="s3">\n    </span><span class="s1">while (i !== -1) {</span><span class="s3">\n      </span><span class="s1">position.line++;</span><span class="s3">\n      </span><span class="s1">position.column = 0;</span><span class="s3">\n      </span><span class="s1">last = i + 1;</span><span class="s3">\n\n      </span><span class="s1">// We mark the start of each line, which happens directly after this newline char</span><span class="s3">\n      </span><span class="s1">// unless this is the last char.</span><span class="s3">\n      </span><span class="s1">// When manually adding multi-line content (such as a comment), `line` will be `undefined`.</span><span class="s3">\n      </span><span class="s1">if (last &lt; len &amp;&amp; line !== undefined) {</span><span class="s3">\n        </span><span class="s1">this._mark(++line, 0, null, null, filename);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">i = str.indexOf(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">, last);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">position.column += len - last;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_mark(</span><span class="s3">\n    </span><span class="s1">line: number | undefined,</span><span class="s3">\n    </span><span class="s1">column: number | undefined,</span><span class="s3">\n    </span><span class="s1">identifierName: string | undefined,</span><span class="s3">\n    </span><span class="s1">identifierNamePos: Pos | undefined,</span><span class="s3">\n    </span><span class="s1">filename: string | undefined,</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">this._map?.mark(</span><span class="s3">\n      </span><span class="s1">this._position,</span><span class="s3">\n      </span><span class="s1">line,</span><span class="s3">\n      </span><span class="s1">column,</span><span class="s3">\n      </span><span class="s1">identifierName,</span><span class="s3">\n      </span><span class="s1">identifierNamePos,</span><span class="s3">\n      </span><span class="s1">filename,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">removeTrailingNewline(): void {</span><span class="s3">\n    </span><span class="s1">const queueCursor = this._queueCursor;</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">queueCursor !== 0 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this._queue[queueCursor - 1].char === charcodes.lineFeed</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this._queueCursor--;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">removeLastSemicolon(): void {</span><span class="s3">\n    </span><span class="s1">const queueCursor = this._queueCursor;</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">queueCursor !== 0 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this._queue[queueCursor - 1].char === charcodes.semicolon</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this._queueCursor--;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getLastChar(): number {</span><span class="s3">\n    </span><span class="s1">const queueCursor = this._queueCursor;</span><span class="s3">\n    </span><span class="s1">return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This will only detect at most 1 newline after a call to `flush()`,</span><span class="s3">\n   </span><span class="s1">* but this has not been found so far, and an accurate count can be achieved if needed later.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getNewlineCount(): number {</span><span class="s3">\n    </span><span class="s1">const queueCursor = this._queueCursor;</span><span class="s3">\n    </span><span class="s1">let count = 0;</span><span class="s3">\n    </span><span class="s1">if (queueCursor === 0) return this._last === charcodes.lineFeed ? 1 : 0;</span><span class="s3">\n    </span><span class="s1">for (let i = queueCursor - 1; i &gt;= 0; i--) {</span><span class="s3">\n      </span><span class="s1">if (this._queue[i].char !== charcodes.lineFeed) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">count++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return count === queueCursor &amp;&amp; this._last === charcodes.lineFeed</span><span class="s3">\n      </span><span class="s1">? count + 1</span><span class="s3">\n      </span><span class="s1">: count;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* check if current _last + queue ends with newline, return the character before newline</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {*} ch</span><span class="s3">\n   </span><span class="s1">* @memberof Buffer</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">endsWithCharAndNewline(): number {</span><span class="s3">\n    </span><span class="s1">const queue = this._queue;</span><span class="s3">\n    </span><span class="s1">const queueCursor = this._queueCursor;</span><span class="s3">\n    </span><span class="s1">if (queueCursor !== 0) {</span><span class="s3">\n      </span><span class="s1">// every element in queue is one-length whitespace string</span><span class="s3">\n      </span><span class="s1">const lastCp = queue[queueCursor - 1].char;</span><span class="s3">\n      </span><span class="s1">if (lastCp !== charcodes.lineFeed) return;</span><span class="s3">\n      </span><span class="s1">if (queueCursor &gt; 1) {</span><span class="s3">\n        </span><span class="s1">return queue[queueCursor - 2].char;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return this._last;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// We assume that everything being matched is at most a single token plus some whitespace,</span><span class="s3">\n    </span><span class="s1">// which everything currently is, but otherwise we'd have to expand _last or check _buf.</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">hasContent(): boolean {</span><span class="s3">\n    </span><span class="s1">return this._queueCursor !== 0 || !!this._last;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Certain sourcemap usecases expect mappings to be more accurate than</span><span class="s3">\n   </span><span class="s1">* Babel's generic sourcemap handling allows. For now, we special-case</span><span class="s3">\n   </span><span class="s1">* identifiers to allow for the primary cases to work.</span><span class="s3">\n   </span><span class="s1">* The goal of this line is to ensure that the map output from Babel will</span><span class="s3">\n   </span><span class="s1">* have an exact range on identifiers in the output code. Without this</span><span class="s3">\n   </span><span class="s1">* line, Babel would potentially include some number of trailing tokens</span><span class="s3">\n   </span><span class="s1">* that are printed after the identifier, but before another location has</span><span class="s3">\n   </span><span class="s1">* been assigned.</span><span class="s3">\n   </span><span class="s1">* This allows tooling like Rollup and Webpack to more accurately perform</span><span class="s3">\n   </span><span class="s1">* their own transformations. Most importantly, this allows the import/export</span><span class="s3">\n   </span><span class="s1">* transformations performed by those tools to loose less information when</span><span class="s3">\n   </span><span class="s1">* applying their own transformations on top of the code and map results</span><span class="s3">\n   </span><span class="s1">* generated by Babel itself.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* The primary example of this is the snippet:</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*   import mod from </span><span class="s3">\&quot;</span><span class="s1">mod</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n   </span><span class="s1">*   mod();</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* With this line, there will be one mapping range over </span><span class="s3">\&quot;</span><span class="s1">mod</span><span class="s3">\&quot; </span><span class="s1">and another</span><span class="s3">\n   </span><span class="s1">* over </span><span class="s3">\&quot;</span><span class="s1">();</span><span class="s3">\&quot;</span><span class="s1">, where previously it would have been a single mapping.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">exactSource(loc: Loc | undefined, cb: () =&gt; void) {</span><span class="s3">\n    </span><span class="s1">if (!this._map) {</span><span class="s3">\n      </span><span class="s1">cb();</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.source(</span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot;</span><span class="s1">, loc);</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error identifierName is not defined</span><span class="s3">\n    </span><span class="s1">const identifierName = loc.identifierName;</span><span class="s3">\n    </span><span class="s1">const sourcePos = this._sourcePosition;</span><span class="s3">\n    </span><span class="s1">if (identifierName) {</span><span class="s3">\n      </span><span class="s1">this._canMarkIdName = false;</span><span class="s3">\n      </span><span class="s1">sourcePos.identifierName = identifierName;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cb();</span><span class="s3">\n\n    </span><span class="s1">if (identifierName) {</span><span class="s3">\n      </span><span class="s1">this._canMarkIdName = true;</span><span class="s3">\n      </span><span class="s1">sourcePos.identifierName = undefined;</span><span class="s3">\n      </span><span class="s1">sourcePos.identifierNamePos = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.source(</span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">, loc);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Sets a given position as the current source location so generated code after this call</span><span class="s3">\n   </span><span class="s1">* will be given this position in the sourcemap.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">source(prop: </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">, loc: Loc | undefined): void {</span><span class="s3">\n    </span><span class="s1">if (!this._map) return;</span><span class="s3">\n\n    </span><span class="s1">// Since this is called extremely often, we reuse the same _sourcePosition</span><span class="s3">\n    </span><span class="s1">// object for the whole lifetime of the buffer.</span><span class="s3">\n    </span><span class="s1">this._normalizePosition(prop, loc, 0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">sourceWithOffset(</span><span class="s3">\n    </span><span class="s1">prop: </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">loc: Loc | undefined,</span><span class="s3">\n    </span><span class="s1">columnOffset: number,</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">if (!this._map) return;</span><span class="s3">\n\n    </span><span class="s1">this._normalizePosition(prop, loc, columnOffset);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Call a callback with a specific source location</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">withSource(prop: </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">, loc: Loc, cb: () =&gt; void): void {</span><span class="s3">\n    </span><span class="s1">if (this._map) {</span><span class="s3">\n      </span><span class="s1">this.source(prop, loc);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">cb();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_normalizePosition(prop: </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">, loc: Loc, columnOffset: number) {</span><span class="s3">\n    </span><span class="s1">const pos = loc[prop];</span><span class="s3">\n    </span><span class="s1">const target = this._sourcePosition;</span><span class="s3">\n\n    </span><span class="s1">if (pos) {</span><span class="s3">\n      </span><span class="s1">target.line = pos.line;</span><span class="s3">\n      </span><span class="s1">// TODO: Fix https://github.com/babel/babel/issues/15712 in downstream</span><span class="s3">\n      </span><span class="s1">target.column = Math.max(pos.column + columnOffset, 0);</span><span class="s3">\n      </span><span class="s1">target.filename = loc.filename;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getCurrentColumn(): number {</span><span class="s3">\n    </span><span class="s1">const queue = this._queue;</span><span class="s3">\n    </span><span class="s1">const queueCursor = this._queueCursor;</span><span class="s3">\n\n    </span><span class="s1">let lastIndex = -1;</span><span class="s3">\n    </span><span class="s1">let len = 0;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; queueCursor; i++) {</span><span class="s3">\n      </span><span class="s1">const item = queue[i];</span><span class="s3">\n      </span><span class="s1">if (item.char === charcodes.lineFeed) {</span><span class="s3">\n        </span><span class="s1">lastIndex = len;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">len += item.repeat;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getCurrentLine(): number {</span><span class="s3">\n    </span><span class="s1">let count = 0;</span><span class="s3">\n\n    </span><span class="s1">const queue = this._queue;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; this._queueCursor; i++) {</span><span class="s3">\n      </span><span class="s1">if (queue[i].char === charcodes.lineFeed) {</span><span class="s3">\n        </span><span class="s1">count++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this._position.line + count;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>