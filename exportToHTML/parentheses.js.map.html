<html>
<head>
<title>parentheses.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
parentheses.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrayTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isAwaitExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isBinary&quot;</span><span class="s0">,</span><span class="s1">&quot;isBinaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isUpdateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isClass&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isConditional&quot;</span><span class="s0">,</span><span class="s1">&quot;isConditionalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDefaultDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isFor&quot;</span><span class="s0">,</span><span class="s1">&quot;isForInStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isForOfStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isForStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isIfStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isIndexedAccessType&quot;</span><span class="s0">,</span><span class="s1">&quot;isIntersectionTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;isLogicalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isNewExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isNullableTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptionalCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptionalMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isReturnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isSequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isSwitchStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSArrayType&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSAsExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSInstantiationExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSIntersectionType&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSNonNullExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSOptionalType&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSRestType&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSTypeAssertion&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSUnionType&quot;</span><span class="s0">,</span><span class="s1">&quot;isTaggedTemplateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isThrowStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnaryLike&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnionTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;isWhileStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isYieldExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSSatisfiesExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;PRECEDENCE&quot;</span><span class="s0">,</span><span class="s1">&quot;in&quot;</span><span class="s0">,</span><span class="s1">&quot;instanceof&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSTypeExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassExtendsClause&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;hasPostfixPart&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;NullableTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;printStack&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;UpdateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isFirstInContext&quot;</span><span class="s0">,</span><span class="s1">&quot;DoExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;Binary&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;parentOp&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPos&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeOp&quot;</span><span class="s0">,</span><span class="s1">&quot;nodePos&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;UnionTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;OptionalIndexedAccessType&quot;</span><span class="s0">,</span><span class="s1">&quot;objectType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSAsExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;TSUnionType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSInferType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSInstantiationExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s1">&quot;BinaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;SequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;discriminant&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;YieldExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;UnaryLike&quot;</span><span class="s0">,</span><span class="s1">&quot;FunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;ArrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;ConditionalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;OptionalMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;AssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;LogicalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$extra&quot;</span><span class="s0">,</span><span class="s1">&quot;extra&quot;</span><span class="s0">,</span><span class="s1">&quot;parenthesized&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;isFollowedByBracket&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;checkParam&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowBody&quot;</span><span class="s0">,</span><span class="s1">&quot;exportDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;forHead&quot;</span><span class="s0">,</span><span class="s1">&quot;forInHead&quot;</span><span class="s0">,</span><span class="s1">&quot;forOfHead&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;expressions&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/node/parentheses.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">isArrayTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">isArrowFunctionExpression,</span><span class="s3">\n  </span><span class="s1">isAssignmentExpression,</span><span class="s3">\n  </span><span class="s1">isAwaitExpression,</span><span class="s3">\n  </span><span class="s1">isBinary,</span><span class="s3">\n  </span><span class="s1">isBinaryExpression,</span><span class="s3">\n  </span><span class="s1">isUpdateExpression,</span><span class="s3">\n  </span><span class="s1">isCallExpression,</span><span class="s3">\n  </span><span class="s1">isClass,</span><span class="s3">\n  </span><span class="s1">isClassExpression,</span><span class="s3">\n  </span><span class="s1">isConditional,</span><span class="s3">\n  </span><span class="s1">isConditionalExpression,</span><span class="s3">\n  </span><span class="s1">isExportDeclaration,</span><span class="s3">\n  </span><span class="s1">isExportDefaultDeclaration,</span><span class="s3">\n  </span><span class="s1">isExpressionStatement,</span><span class="s3">\n  </span><span class="s1">isFor,</span><span class="s3">\n  </span><span class="s1">isForInStatement,</span><span class="s3">\n  </span><span class="s1">isForOfStatement,</span><span class="s3">\n  </span><span class="s1">isForStatement,</span><span class="s3">\n  </span><span class="s1">isFunctionExpression,</span><span class="s3">\n  </span><span class="s1">isIfStatement,</span><span class="s3">\n  </span><span class="s1">isIndexedAccessType,</span><span class="s3">\n  </span><span class="s1">isIntersectionTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">isLogicalExpression,</span><span class="s3">\n  </span><span class="s1">isMemberExpression,</span><span class="s3">\n  </span><span class="s1">isNewExpression,</span><span class="s3">\n  </span><span class="s1">isNullableTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">isObjectPattern,</span><span class="s3">\n  </span><span class="s1">isOptionalCallExpression,</span><span class="s3">\n  </span><span class="s1">isOptionalMemberExpression,</span><span class="s3">\n  </span><span class="s1">isReturnStatement,</span><span class="s3">\n  </span><span class="s1">isSequenceExpression,</span><span class="s3">\n  </span><span class="s1">isSwitchStatement,</span><span class="s3">\n  </span><span class="s1">isTSArrayType,</span><span class="s3">\n  </span><span class="s1">isTSAsExpression,</span><span class="s3">\n  </span><span class="s1">isTSInstantiationExpression,</span><span class="s3">\n  </span><span class="s1">isTSIntersectionType,</span><span class="s3">\n  </span><span class="s1">isTSNonNullExpression,</span><span class="s3">\n  </span><span class="s1">isTSOptionalType,</span><span class="s3">\n  </span><span class="s1">isTSRestType,</span><span class="s3">\n  </span><span class="s1">isTSTypeAssertion,</span><span class="s3">\n  </span><span class="s1">isTSUnionType,</span><span class="s3">\n  </span><span class="s1">isTaggedTemplateExpression,</span><span class="s3">\n  </span><span class="s1">isThrowStatement,</span><span class="s3">\n  </span><span class="s1">isTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">isUnaryLike,</span><span class="s3">\n  </span><span class="s1">isUnionTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">isVariableDeclarator,</span><span class="s3">\n  </span><span class="s1">isWhileStatement,</span><span class="s3">\n  </span><span class="s1">isYieldExpression,</span><span class="s3">\n  </span><span class="s1">isTSSatisfiesExpression,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const PRECEDENCE = {</span><span class="s3">\n  \&quot;</span><span class="s1">||</span><span class="s3">\&quot;</span><span class="s1">: 0,</span><span class="s3">\n  \&quot;</span><span class="s1">??</span><span class="s3">\&quot;</span><span class="s1">: 0,</span><span class="s3">\n  \&quot;</span><span class="s1">|&gt;</span><span class="s3">\&quot;</span><span class="s1">: 0,</span><span class="s3">\n  \&quot;</span><span class="s1">&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">: 1,</span><span class="s3">\n  \&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">: 2,</span><span class="s3">\n  \&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">: 3,</span><span class="s3">\n  \&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">: 4,</span><span class="s3">\n  \&quot;</span><span class="s1">==</span><span class="s3">\&quot;</span><span class="s1">: 5,</span><span class="s3">\n  \&quot;</span><span class="s1">===</span><span class="s3">\&quot;</span><span class="s1">: 5,</span><span class="s3">\n  \&quot;</span><span class="s1">!=</span><span class="s3">\&quot;</span><span class="s1">: 5,</span><span class="s3">\n  \&quot;</span><span class="s1">!==</span><span class="s3">\&quot;</span><span class="s1">: 5,</span><span class="s3">\n  \&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">: 6,</span><span class="s3">\n  \&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">: 6,</span><span class="s3">\n  \&quot;</span><span class="s1">&lt;=</span><span class="s3">\&quot;</span><span class="s1">: 6,</span><span class="s3">\n  \&quot;</span><span class="s1">&gt;=</span><span class="s3">\&quot;</span><span class="s1">: 6,</span><span class="s3">\n  </span><span class="s1">in: 6,</span><span class="s3">\n  </span><span class="s1">instanceof: 6,</span><span class="s3">\n  \&quot;</span><span class="s1">&gt;&gt;</span><span class="s3">\&quot;</span><span class="s1">: 7,</span><span class="s3">\n  \&quot;</span><span class="s1">&lt;&lt;</span><span class="s3">\&quot;</span><span class="s1">: 7,</span><span class="s3">\n  \&quot;</span><span class="s1">&gt;&gt;&gt;</span><span class="s3">\&quot;</span><span class="s1">: 7,</span><span class="s3">\n  \&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">: 8,</span><span class="s3">\n  \&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">: 8,</span><span class="s3">\n  \&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">: 9,</span><span class="s3">\n  \&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">: 9,</span><span class="s3">\n  \&quot;</span><span class="s1">%</span><span class="s3">\&quot;</span><span class="s1">: 9,</span><span class="s3">\n  \&quot;</span><span class="s1">**</span><span class="s3">\&quot;</span><span class="s1">: 10,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const enum CheckParam {</span><span class="s3">\n  </span><span class="s1">expressionStatement = 1 &lt;&lt; 0,</span><span class="s3">\n  </span><span class="s1">arrowBody = 1 &lt;&lt; 1,</span><span class="s3">\n  </span><span class="s1">exportDefault = 1 &lt;&lt; 2,</span><span class="s3">\n  </span><span class="s1">forHead = 1 &lt;&lt; 3,</span><span class="s3">\n  </span><span class="s1">forInHead = 1 &lt;&lt; 4,</span><span class="s3">\n  </span><span class="s1">forOfHead = 1 &lt;&lt; 5,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isTSTypeExpression(node: t.Node) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">isTSAsExpression(node) ||</span><span class="s3">\n    </span><span class="s1">isTSSatisfiesExpression(node) ||</span><span class="s3">\n    </span><span class="s1">isTSTypeAssertion(node)</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const isClassExtendsClause = (</span><span class="s3">\n  </span><span class="s1">node: t.Node,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): parent is t.Class =&gt; isClass(parent, { superClass: node });</span><span class="s3">\n\n</span><span class="s1">const hasPostfixPart = (node: t.Node, parent: t.Node) =&gt;</span><span class="s3">\n  </span><span class="s1">((isMemberExpression(parent) || isOptionalMemberExpression(parent)) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">parent.object === node) ||</span><span class="s3">\n  </span><span class="s1">((isCallExpression(parent) ||</span><span class="s3">\n    </span><span class="s1">isOptionalCallExpression(parent) ||</span><span class="s3">\n    </span><span class="s1">isNewExpression(parent)) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">parent.callee === node) ||</span><span class="s3">\n  </span><span class="s1">(isTaggedTemplateExpression(parent) &amp;&amp; parent.tag === node) ||</span><span class="s3">\n  </span><span class="s1">isTSNonNullExpression(parent);</span><span class="s3">\n\n</span><span class="s1">export function NullableTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">node: t.NullableTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return isArrayTypeAnnotation(parent);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function FunctionTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">node: t.FunctionTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n  </span><span class="s1">printStack: Array&lt;t.Node&gt;,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">if (printStack.length &lt; 3) return;</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">// (() =&gt; A) | (() =&gt; B)</span><span class="s3">\n    </span><span class="s1">isUnionTypeAnnotation(parent) ||</span><span class="s3">\n    </span><span class="s1">// (() =&gt; A) &amp; (() =&gt; B)</span><span class="s3">\n    </span><span class="s1">isIntersectionTypeAnnotation(parent) ||</span><span class="s3">\n    </span><span class="s1">// (() =&gt; A)[]</span><span class="s3">\n    </span><span class="s1">isArrayTypeAnnotation(parent) ||</span><span class="s3">\n    </span><span class="s1">// &lt;T&gt;(A: T): (T =&gt; T[]) =&gt; B =&gt; [A, B]</span><span class="s3">\n    </span><span class="s1">(isTypeAnnotation(parent) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Check grandparent</span><span class="s3">\n      </span><span class="s1">isArrowFunctionExpression(printStack[printStack.length - 3]))</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function UpdateExpression(</span><span class="s3">\n  </span><span class="s1">node: t.UpdateExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ObjectExpression(</span><span class="s3">\n  </span><span class="s1">node: t.ObjectExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n  </span><span class="s1">printStack: Array&lt;t.Node&gt;,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return isFirstInContext(</span><span class="s3">\n    </span><span class="s1">printStack,</span><span class="s3">\n    </span><span class="s1">CheckParam.expressionStatement | CheckParam.arrowBody,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function DoExpression(</span><span class="s3">\n  </span><span class="s1">node: t.DoExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n  </span><span class="s1">printStack: Array&lt;t.Node&gt;,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">// `async do` can start an expression statement</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">!node.async &amp;&amp; isFirstInContext(printStack, CheckParam.expressionStatement)</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function Binary(node: t.BinaryExpression, parent: t.Node): boolean {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">node.operator === </span><span class="s3">\&quot;</span><span class="s1">**</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">isBinaryExpression(parent, { operator: </span><span class="s3">\&quot;</span><span class="s1">**</span><span class="s3">\&quot; </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return parent.left === node;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isClassExtendsClause(node, parent)) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">hasPostfixPart(node, parent) ||</span><span class="s3">\n    </span><span class="s1">isUnaryLike(parent) ||</span><span class="s3">\n    </span><span class="s1">isAwaitExpression(parent)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isBinary(parent)) {</span><span class="s3">\n    </span><span class="s1">const parentOp = parent.operator;</span><span class="s3">\n    </span><span class="s1">const parentPos = PRECEDENCE[parentOp];</span><span class="s3">\n\n    </span><span class="s1">const nodeOp = node.operator;</span><span class="s3">\n    </span><span class="s1">const nodePos = PRECEDENCE[nodeOp];</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// Logical expressions with the same precedence don't need parens.</span><span class="s3">\n      </span><span class="s1">(parentPos === nodePos &amp;&amp;</span><span class="s3">\n        </span><span class="s1">parent.right === node &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!isLogicalExpression(parent)) ||</span><span class="s3">\n      </span><span class="s1">parentPos &gt; nodePos</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function UnionTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">node: t.UnionTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">isArrayTypeAnnotation(parent) ||</span><span class="s3">\n    </span><span class="s1">isNullableTypeAnnotation(parent) ||</span><span class="s3">\n    </span><span class="s1">isIntersectionTypeAnnotation(parent) ||</span><span class="s3">\n    </span><span class="s1">isUnionTypeAnnotation(parent)</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { UnionTypeAnnotation as IntersectionTypeAnnotation };</span><span class="s3">\n\n</span><span class="s1">export function OptionalIndexedAccessType(</span><span class="s3">\n  </span><span class="s1">node: t.OptionalIndexedAccessType,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return isIndexedAccessType(parent, { objectType: node });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function TSAsExpression() {</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">TSAsExpression as TSSatisfiesExpression,</span><span class="s3">\n  </span><span class="s1">TSAsExpression as TSTypeAssertion,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function TSUnionType(node: t.TSUnionType, parent: t.Node): boolean {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">isTSArrayType(parent) ||</span><span class="s3">\n    </span><span class="s1">isTSOptionalType(parent) ||</span><span class="s3">\n    </span><span class="s1">isTSIntersectionType(parent) ||</span><span class="s3">\n    </span><span class="s1">isTSUnionType(parent) ||</span><span class="s3">\n    </span><span class="s1">isTSRestType(parent)</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { TSUnionType as TSIntersectionType };</span><span class="s3">\n\n</span><span class="s1">export function TSInferType(node: t.TSInferType, parent: t.Node): boolean {</span><span class="s3">\n  </span><span class="s1">return isTSArrayType(parent) || isTSOptionalType(parent);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function TSInstantiationExpression(</span><span class="s3">\n  </span><span class="s1">node: t.TSInstantiationExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">(isCallExpression(parent) ||</span><span class="s3">\n      </span><span class="s1">isOptionalCallExpression(parent) ||</span><span class="s3">\n      </span><span class="s1">isNewExpression(parent) ||</span><span class="s3">\n      </span><span class="s1">isTSInstantiationExpression(parent)) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!!parent.typeParameters</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function BinaryExpression(</span><span class="s3">\n  </span><span class="s1">node: t.BinaryExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">// let i = (1 in []);</span><span class="s3">\n  </span><span class="s1">// for ((1 in []);;);</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">node.operator === </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; (isVariableDeclarator(parent) || isFor(parent))</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function SequenceExpression(</span><span class="s3">\n  </span><span class="s1">node: t.SequenceExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">// Although parentheses wouldn't hurt around sequence</span><span class="s3">\n    </span><span class="s1">// expressions in the head of for loops, traditional style</span><span class="s3">\n    </span><span class="s1">// dictates that e.g. i++, j++ should not be wrapped with</span><span class="s3">\n    </span><span class="s1">// parentheses.</span><span class="s3">\n    </span><span class="s1">isForStatement(parent) ||</span><span class="s3">\n    </span><span class="s1">isThrowStatement(parent) ||</span><span class="s3">\n    </span><span class="s1">isReturnStatement(parent) ||</span><span class="s3">\n    </span><span class="s1">(isIfStatement(parent) &amp;&amp; parent.test === node) ||</span><span class="s3">\n    </span><span class="s1">(isWhileStatement(parent) &amp;&amp; parent.test === node) ||</span><span class="s3">\n    </span><span class="s1">(isForInStatement(parent) &amp;&amp; parent.right === node) ||</span><span class="s3">\n    </span><span class="s1">(isSwitchStatement(parent) &amp;&amp; parent.discriminant === node) ||</span><span class="s3">\n    </span><span class="s1">(isExpressionStatement(parent) &amp;&amp; parent.expression === node)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Otherwise err on the side of overparenthesization, adding</span><span class="s3">\n  </span><span class="s1">// explicit exceptions above if this proves overzealous.</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function YieldExpression(</span><span class="s3">\n  </span><span class="s1">node: t.YieldExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">isBinary(parent) ||</span><span class="s3">\n    </span><span class="s1">isUnaryLike(parent) ||</span><span class="s3">\n    </span><span class="s1">hasPostfixPart(node, parent) ||</span><span class="s3">\n    </span><span class="s1">(isAwaitExpression(parent) &amp;&amp; isYieldExpression(node)) ||</span><span class="s3">\n    </span><span class="s1">(isConditionalExpression(parent) &amp;&amp; node === parent.test) ||</span><span class="s3">\n    </span><span class="s1">isClassExtendsClause(node, parent)</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { YieldExpression as AwaitExpression };</span><span class="s3">\n\n</span><span class="s1">export function ClassExpression(</span><span class="s3">\n  </span><span class="s1">node: t.ClassExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n  </span><span class="s1">printStack: Array&lt;t.Node&gt;,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return isFirstInContext(</span><span class="s3">\n    </span><span class="s1">printStack,</span><span class="s3">\n    </span><span class="s1">CheckParam.expressionStatement | CheckParam.exportDefault,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function UnaryLike(</span><span class="s3">\n  </span><span class="s1">node:</span><span class="s3">\n    </span><span class="s1">| t.UnaryLike</span><span class="s3">\n    </span><span class="s1">| t.ArrowFunctionExpression</span><span class="s3">\n    </span><span class="s1">| t.ConditionalExpression</span><span class="s3">\n    </span><span class="s1">| t.AssignmentExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">hasPostfixPart(node, parent) ||</span><span class="s3">\n    </span><span class="s1">isBinaryExpression(parent, { operator: </span><span class="s3">\&quot;</span><span class="s1">**</span><span class="s3">\&quot;</span><span class="s1">, left: node }) ||</span><span class="s3">\n    </span><span class="s1">isClassExtendsClause(node, parent)</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function FunctionExpression(</span><span class="s3">\n  </span><span class="s1">node: t.FunctionExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n  </span><span class="s1">printStack: Array&lt;t.Node&gt;,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return isFirstInContext(</span><span class="s3">\n    </span><span class="s1">printStack,</span><span class="s3">\n    </span><span class="s1">CheckParam.expressionStatement | CheckParam.exportDefault,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ArrowFunctionExpression(</span><span class="s3">\n  </span><span class="s1">node: t.ArrowFunctionExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return isExportDeclaration(parent) || ConditionalExpression(node, parent);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ConditionalExpression(</span><span class="s3">\n  </span><span class="s1">node:</span><span class="s3">\n    </span><span class="s1">| t.ConditionalExpression</span><span class="s3">\n    </span><span class="s1">| t.ArrowFunctionExpression</span><span class="s3">\n    </span><span class="s1">| t.AssignmentExpression,</span><span class="s3">\n  </span><span class="s1">parent?: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">isUnaryLike(parent) ||</span><span class="s3">\n    </span><span class="s1">isBinary(parent) ||</span><span class="s3">\n    </span><span class="s1">isConditionalExpression(parent, { test: node }) ||</span><span class="s3">\n    </span><span class="s1">isAwaitExpression(parent) ||</span><span class="s3">\n    </span><span class="s1">isTSTypeExpression(parent)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return UnaryLike(node, parent);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function OptionalMemberExpression(</span><span class="s3">\n  </span><span class="s1">node: t.OptionalMemberExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">isCallExpression(parent, { callee: node }) ||</span><span class="s3">\n    </span><span class="s1">isMemberExpression(parent, { object: node })</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { OptionalMemberExpression as OptionalCallExpression };</span><span class="s3">\n\n</span><span class="s1">export function AssignmentExpression(</span><span class="s3">\n  </span><span class="s1">node: t.AssignmentExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">if (isObjectPattern(node.left)) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return ConditionalExpression(node, parent);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function LogicalExpression(</span><span class="s3">\n  </span><span class="s1">node: t.LogicalExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">if (isTSTypeExpression(parent)) return true;</span><span class="s3">\n  </span><span class="s1">switch (node.operator) {</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">||</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">if (!isLogicalExpression(parent)) return false;</span><span class="s3">\n      </span><span class="s1">return parent.operator === </span><span class="s3">\&quot;</span><span class="s1">??</span><span class="s3">\&quot; </span><span class="s1">|| parent.operator === </span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return isLogicalExpression(parent, { operator: </span><span class="s3">\&quot;</span><span class="s1">??</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">??</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return isLogicalExpression(parent) &amp;&amp; parent.operator !== </span><span class="s3">\&quot;</span><span class="s1">??</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function Identifier(</span><span class="s3">\n  </span><span class="s1">node: t.Identifier,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n  </span><span class="s1">printStack: Array&lt;t.Node&gt;,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">// 13.15.2 AssignmentExpression RS: Evaluation</span><span class="s3">\n  </span><span class="s1">// (fn) = function () {};</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">node.extra?.parenthesized &amp;&amp;</span><span class="s3">\n    </span><span class="s1">isAssignmentExpression(parent, { left: node }) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(isFunctionExpression(parent.right) || isClassExpression(parent.right)) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">parent.right.id == null</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Non-strict code allows the identifier `let`, but it cannot occur as-is in</span><span class="s3">\n  </span><span class="s1">// certain contexts to avoid ambiguity with contextual keyword `let`.</span><span class="s3">\n  </span><span class="s1">if (node.name === </span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// Some contexts only forbid `let [`, so check if the next token would</span><span class="s3">\n    </span><span class="s1">// be the left bracket of a computed member expression.</span><span class="s3">\n    </span><span class="s1">const isFollowedByBracket =</span><span class="s3">\n      </span><span class="s1">isMemberExpression(parent, {</span><span class="s3">\n        </span><span class="s1">object: node,</span><span class="s3">\n        </span><span class="s1">computed: true,</span><span class="s3">\n      </span><span class="s1">}) ||</span><span class="s3">\n      </span><span class="s1">isOptionalMemberExpression(parent, {</span><span class="s3">\n        </span><span class="s1">object: node,</span><span class="s3">\n        </span><span class="s1">computed: true,</span><span class="s3">\n        </span><span class="s1">optional: false,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return isFirstInContext(</span><span class="s3">\n      </span><span class="s1">printStack,</span><span class="s3">\n      </span><span class="s1">isFollowedByBracket</span><span class="s3">\n        </span><span class="s1">? CheckParam.expressionStatement |</span><span class="s3">\n            </span><span class="s1">CheckParam.forHead |</span><span class="s3">\n            </span><span class="s1">CheckParam.forInHead |</span><span class="s3">\n            </span><span class="s1">CheckParam.forOfHead</span><span class="s3">\n        </span><span class="s1">: CheckParam.forOfHead,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// ECMAScript specifically forbids a for-of loop from starting with the</span><span class="s3">\n  </span><span class="s1">// token sequence `for (async of`, because it would be ambiguous with</span><span class="s3">\n  </span><span class="s1">// `for (async of =&gt; {};;)`, so we need to add extra parentheses.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// If the parent is a for-await-of loop (i.e. parent.await === true), the</span><span class="s3">\n  </span><span class="s1">// parentheses aren't strictly needed, but we add them anyway because</span><span class="s3">\n  </span><span class="s1">// some tools (including earlier Babel versions) can't parse</span><span class="s3">\n  </span><span class="s1">// `for await (async of [])` without them.</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">node.name === </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; isForOfStatement(parent) &amp;&amp; node === parent.left</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Walk up the print stack to determine if our node can come first</span><span class="s3">\n</span><span class="s1">// in a particular context.</span><span class="s3">\n</span><span class="s1">function isFirstInContext(</span><span class="s3">\n  </span><span class="s1">printStack: Array&lt;t.Node&gt;,</span><span class="s3">\n  </span><span class="s1">checkParam: CheckParam,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const expressionStatement = checkParam &amp; CheckParam.expressionStatement;</span><span class="s3">\n  </span><span class="s1">const arrowBody = checkParam &amp; CheckParam.arrowBody;</span><span class="s3">\n  </span><span class="s1">const exportDefault = checkParam &amp; CheckParam.exportDefault;</span><span class="s3">\n  </span><span class="s1">const forHead = checkParam &amp; CheckParam.forHead;</span><span class="s3">\n  </span><span class="s1">const forInHead = checkParam &amp; CheckParam.forInHead;</span><span class="s3">\n  </span><span class="s1">const forOfHead = checkParam &amp; CheckParam.forOfHead;</span><span class="s3">\n\n  </span><span class="s1">let i = printStack.length - 1;</span><span class="s3">\n  </span><span class="s1">if (i &lt;= 0) return;</span><span class="s3">\n  </span><span class="s1">let node = printStack[i];</span><span class="s3">\n  </span><span class="s1">i--;</span><span class="s3">\n  </span><span class="s1">let parent = printStack[i];</span><span class="s3">\n  </span><span class="s1">while (i &gt;= 0) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(expressionStatement &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isExpressionStatement(parent, { expression: node })) ||</span><span class="s3">\n      </span><span class="s1">(exportDefault &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isExportDefaultDeclaration(parent, { declaration: node })) ||</span><span class="s3">\n      </span><span class="s1">(arrowBody &amp;&amp; isArrowFunctionExpression(parent, { body: node })) ||</span><span class="s3">\n      </span><span class="s1">(forHead &amp;&amp; isForStatement(parent, { init: node })) ||</span><span class="s3">\n      </span><span class="s1">(forInHead &amp;&amp; isForInStatement(parent, { left: node })) ||</span><span class="s3">\n      </span><span class="s1">(forOfHead &amp;&amp; isForOfStatement(parent, { left: node }))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">i &gt; 0 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">((hasPostfixPart(node, parent) &amp;&amp; !isNewExpression(parent)) ||</span><span class="s3">\n        </span><span class="s1">(isSequenceExpression(parent) &amp;&amp; parent.expressions[0] === node) ||</span><span class="s3">\n        </span><span class="s1">(isUpdateExpression(parent) &amp;&amp; !parent.prefix) ||</span><span class="s3">\n        </span><span class="s1">isConditional(parent, { test: node }) ||</span><span class="s3">\n        </span><span class="s1">isBinary(parent, { left: node }) ||</span><span class="s3">\n        </span><span class="s1">isAssignmentExpression(parent, { left: node }))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">node = parent;</span><span class="s3">\n      </span><span class="s1">i--;</span><span class="s3">\n      </span><span class="s1">parent = printStack[i];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>