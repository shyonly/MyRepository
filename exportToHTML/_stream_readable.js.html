<html>
<head>
<title>_stream_readable.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #bcbec4;}
.s4 { color: #cf8e6d;}
.s5 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_stream_readable.js</font>
</center></td></tr></table>
<pre><span class="s0">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s0">//</span>
<span class="s0">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s0">// copy of this software and associated documentation files (the</span>
<span class="s0">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s0">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s0">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s0">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s0">// following conditions:</span>
<span class="s0">//</span>
<span class="s0">// The above copyright notice and this permission notice shall be included</span>
<span class="s0">// in all copies or substantial portions of the Software.</span>
<span class="s0">//</span>
<span class="s0">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s0">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s0">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s0">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s0">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s0">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s0">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s2">'use strict'</span><span class="s3">;</span>

<span class="s1">module</span><span class="s3">.</span><span class="s1">exports </span><span class="s3">= </span><span class="s1">Readable</span><span class="s3">;</span>

<span class="s0">/*&lt;replacement&gt;*/</span>
<span class="s4">var </span><span class="s1">Duplex</span><span class="s3">;</span>
<span class="s0">/*&lt;/replacement&gt;*/</span>

<span class="s1">Readable</span><span class="s3">.</span><span class="s1">ReadableState </span><span class="s3">= </span><span class="s1">ReadableState</span><span class="s3">;</span>

<span class="s0">/*&lt;replacement&gt;*/</span>
<span class="s4">var </span><span class="s1">EE </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">'events'</span><span class="s3">).</span><span class="s1">EventEmitter</span><span class="s3">;</span>
<span class="s4">var </span><span class="s1">EElistenerCount </span><span class="s3">= </span><span class="s4">function </span><span class="s1">EElistenerCount</span><span class="s3">(</span><span class="s1">emitter</span><span class="s3">, </span><span class="s1">type</span><span class="s3">) {</span>
  <span class="s4">return </span><span class="s1">emitter</span><span class="s3">.</span><span class="s1">listeners</span><span class="s3">(</span><span class="s1">type</span><span class="s3">).</span><span class="s1">length</span><span class="s3">;</span>
<span class="s3">};</span>
<span class="s0">/*&lt;/replacement&gt;*/</span>

<span class="s0">/*&lt;replacement&gt;*/</span>
<span class="s4">var </span><span class="s1">Stream </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">'./internal/streams/stream'</span><span class="s3">);</span>
<span class="s0">/*&lt;/replacement&gt;*/</span>

<span class="s4">var </span><span class="s1">Buffer </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">'buffer'</span><span class="s3">).</span><span class="s1">Buffer</span><span class="s3">;</span>
<span class="s4">var </span><span class="s1">OurUint8Array </span><span class="s3">= (</span><span class="s4">typeof </span><span class="s1">global </span><span class="s3">!== </span><span class="s2">'undefined' </span><span class="s3">? </span><span class="s1">global </span><span class="s3">: </span><span class="s4">typeof </span><span class="s1">window </span><span class="s3">!== </span><span class="s2">'undefined' </span><span class="s3">? </span><span class="s1">window </span><span class="s3">: </span><span class="s4">typeof </span><span class="s1">self </span><span class="s3">!== </span><span class="s2">'undefined' </span><span class="s3">? </span><span class="s1">self </span><span class="s3">: {}).</span><span class="s1">Uint8Array </span><span class="s3">|| </span><span class="s4">function </span><span class="s3">() {};</span>
<span class="s4">function </span><span class="s1">_uint8ArrayToBuffer</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
  <span class="s4">return </span><span class="s1">Buffer</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
<span class="s3">}</span>
<span class="s4">function </span><span class="s1">_isUint8Array</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s4">return </span><span class="s1">Buffer</span><span class="s3">.</span><span class="s1">isBuffer</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) || </span><span class="s1">obj </span><span class="s4">instanceof </span><span class="s1">OurUint8Array</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">/*&lt;replacement&gt;*/</span>
<span class="s4">var </span><span class="s1">debugUtil </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">'util'</span><span class="s3">);</span>
<span class="s4">var </span><span class="s1">debug</span><span class="s3">;</span>
<span class="s4">if </span><span class="s3">(</span><span class="s1">debugUtil </span><span class="s3">&amp;&amp; </span><span class="s1">debugUtil</span><span class="s3">.</span><span class="s1">debuglog</span><span class="s3">) {</span>
  <span class="s1">debug </span><span class="s3">= </span><span class="s1">debugUtil</span><span class="s3">.</span><span class="s1">debuglog</span><span class="s3">(</span><span class="s2">'stream'</span><span class="s3">);</span>
<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
  <span class="s1">debug </span><span class="s3">= </span><span class="s4">function </span><span class="s1">debug</span><span class="s3">() {};</span>
<span class="s3">}</span>
<span class="s0">/*&lt;/replacement&gt;*/</span>

<span class="s4">var </span><span class="s1">BufferList </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">'./internal/streams/buffer_list'</span><span class="s3">);</span>
<span class="s4">var </span><span class="s1">destroyImpl </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">'./internal/streams/destroy'</span><span class="s3">);</span>
<span class="s4">var </span><span class="s1">_require </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">'./internal/streams/state'</span><span class="s3">),</span>
  <span class="s1">getHighWaterMark </span><span class="s3">= </span><span class="s1">_require</span><span class="s3">.</span><span class="s1">getHighWaterMark</span><span class="s3">;</span>
<span class="s4">var </span><span class="s1">_require$codes </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">'../errors'</span><span class="s3">).</span><span class="s1">codes</span><span class="s3">,</span>
  <span class="s1">ERR_INVALID_ARG_TYPE </span><span class="s3">= </span><span class="s1">_require$codes</span><span class="s3">.</span><span class="s1">ERR_INVALID_ARG_TYPE</span><span class="s3">,</span>
  <span class="s1">ERR_STREAM_PUSH_AFTER_EOF </span><span class="s3">= </span><span class="s1">_require$codes</span><span class="s3">.</span><span class="s1">ERR_STREAM_PUSH_AFTER_EOF</span><span class="s3">,</span>
  <span class="s1">ERR_METHOD_NOT_IMPLEMENTED </span><span class="s3">= </span><span class="s1">_require$codes</span><span class="s3">.</span><span class="s1">ERR_METHOD_NOT_IMPLEMENTED</span><span class="s3">,</span>
  <span class="s1">ERR_STREAM_UNSHIFT_AFTER_END_EVENT </span><span class="s3">= </span><span class="s1">_require$codes</span><span class="s3">.</span><span class="s1">ERR_STREAM_UNSHIFT_AFTER_END_EVENT</span><span class="s3">;</span>

<span class="s0">// Lazy loaded to improve the startup performance.</span>
<span class="s4">var </span><span class="s1">StringDecoder</span><span class="s3">;</span>
<span class="s4">var </span><span class="s1">createReadableStreamAsyncIterator</span><span class="s3">;</span>
<span class="s4">var </span><span class="s1">from</span><span class="s3">;</span>
<span class="s1">require</span><span class="s3">(</span><span class="s2">'inherits'</span><span class="s3">)(</span><span class="s1">Readable</span><span class="s3">, </span><span class="s1">Stream</span><span class="s3">);</span>
<span class="s4">var </span><span class="s1">errorOrDestroy </span><span class="s3">= </span><span class="s1">destroyImpl</span><span class="s3">.</span><span class="s1">errorOrDestroy</span><span class="s3">;</span>
<span class="s4">var </span><span class="s1">kProxyEvents </span><span class="s3">= [</span><span class="s2">'error'</span><span class="s3">, </span><span class="s2">'close'</span><span class="s3">, </span><span class="s2">'destroy'</span><span class="s3">, </span><span class="s2">'pause'</span><span class="s3">, </span><span class="s2">'resume'</span><span class="s3">];</span>
<span class="s4">function </span><span class="s1">prependListener</span><span class="s3">(</span><span class="s1">emitter</span><span class="s3">, </span><span class="s1">event</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">) {</span>
  <span class="s0">// Sadly this is not cacheable as some libraries bundle their own</span>
  <span class="s0">// event emitter implementation with them.</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">emitter</span><span class="s3">.</span><span class="s1">prependListener </span><span class="s3">=== </span><span class="s2">'function'</span><span class="s3">) </span><span class="s4">return </span><span class="s1">emitter</span><span class="s3">.</span><span class="s1">prependListener</span><span class="s3">(</span><span class="s1">event</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">);</span>

  <span class="s0">// This is a hack to make sure that our error handler is attached before any</span>
  <span class="s0">// userland ones.  NEVER DO THIS. This is here only because this code needs</span>
  <span class="s0">// to continue to work with older versions of Node.js that do not include</span>
  <span class="s0">// the prependListener() method. The goal is to eventually remove this hack.</span>
  <span class="s4">if </span><span class="s3">(!</span><span class="s1">emitter</span><span class="s3">.</span><span class="s1">_events </span><span class="s3">|| !</span><span class="s1">emitter</span><span class="s3">.</span><span class="s1">_events</span><span class="s3">[</span><span class="s1">event</span><span class="s3">]) </span><span class="s1">emitter</span><span class="s3">.</span><span class="s1">on</span><span class="s3">(</span><span class="s1">event</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">);</span><span class="s4">else if </span><span class="s3">(</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">emitter</span><span class="s3">.</span><span class="s1">_events</span><span class="s3">[</span><span class="s1">event</span><span class="s3">])) </span><span class="s1">emitter</span><span class="s3">.</span><span class="s1">_events</span><span class="s3">[</span><span class="s1">event</span><span class="s3">].</span><span class="s1">unshift</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">);</span><span class="s4">else </span><span class="s1">emitter</span><span class="s3">.</span><span class="s1">_events</span><span class="s3">[</span><span class="s1">event</span><span class="s3">] = [</span><span class="s1">fn</span><span class="s3">, </span><span class="s1">emitter</span><span class="s3">.</span><span class="s1">_events</span><span class="s3">[</span><span class="s1">event</span><span class="s3">]];</span>
<span class="s3">}</span>
<span class="s4">function </span><span class="s1">ReadableState</span><span class="s3">(</span><span class="s1">options</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">, </span><span class="s1">isDuplex</span><span class="s3">) {</span>
  <span class="s1">Duplex </span><span class="s3">= </span><span class="s1">Duplex </span><span class="s3">|| </span><span class="s1">require</span><span class="s3">(</span><span class="s2">'./_stream_duplex'</span><span class="s3">);</span>
  <span class="s1">options </span><span class="s3">= </span><span class="s1">options </span><span class="s3">|| {};</span>

  <span class="s0">// Duplex streams are both readable and writable, but share</span>
  <span class="s0">// the same options object.</span>
  <span class="s0">// However, some cases require setting options to different</span>
  <span class="s0">// values for the readable and the writable sides of the duplex stream.</span>
  <span class="s0">// These options can be provided separately as readableXXX and writableXXX.</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">isDuplex </span><span class="s3">!== </span><span class="s2">'boolean'</span><span class="s3">) </span><span class="s1">isDuplex </span><span class="s3">= </span><span class="s1">stream </span><span class="s4">instanceof </span><span class="s1">Duplex</span><span class="s3">;</span>

  <span class="s0">// object stream flag. Used to make read(n) ignore n and to</span>
  <span class="s0">// make all the buffer merging and length checks go away</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">objectMode </span><span class="s3">= !!</span><span class="s1">options</span><span class="s3">.</span><span class="s1">objectMode</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">isDuplex</span><span class="s3">) </span><span class="s4">this</span><span class="s3">.</span><span class="s1">objectMode </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">objectMode </span><span class="s3">|| !!</span><span class="s1">options</span><span class="s3">.</span><span class="s1">readableObjectMode</span><span class="s3">;</span>

  <span class="s0">// the point at which it stops calling _read() to fill the buffer</span>
  <span class="s0">// Note: 0 is a valid value, means &quot;don't call _read preemptively ever&quot;</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">highWaterMark </span><span class="s3">= </span><span class="s1">getHighWaterMark</span><span class="s3">(</span><span class="s4">this</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s2">'readableHighWaterMark'</span><span class="s3">, </span><span class="s1">isDuplex</span><span class="s3">);</span>

  <span class="s0">// A linked list is used to store data chunks instead of an array because the</span>
  <span class="s0">// linked list can remove elements from the beginning faster than</span>
  <span class="s0">// array.shift()</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">buffer </span><span class="s3">= </span><span class="s4">new </span><span class="s1">BufferList</span><span class="s3">();</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">length </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">pipes </span><span class="s3">= </span><span class="s4">null</span><span class="s3">;</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">pipesCount </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">= </span><span class="s4">null</span><span class="s3">;</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">ended </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">endEmitted </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">reading </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>

  <span class="s0">// a flag to be able to tell if the event 'readable'/'data' is emitted</span>
  <span class="s0">// immediately, or on a later tick.  We set this to true at first, because</span>
  <span class="s0">// any actions that shouldn't happen until &quot;later&quot; should generally also</span>
  <span class="s0">// not happen before the first read call.</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">sync </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>

  <span class="s0">// whenever we return null, then we set a flag to say</span>
  <span class="s0">// that we're awaiting a 'readable' event emission.</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">needReadable </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">emittedReadable </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">readableListening </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">resumeScheduled </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">paused </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>

  <span class="s0">// Should close be emitted on destroy. Defaults to true.</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">emitClose </span><span class="s3">= </span><span class="s1">options</span><span class="s3">.</span><span class="s1">emitClose </span><span class="s3">!== </span><span class="s4">false</span><span class="s3">;</span>

  <span class="s0">// Should .destroy() be called after 'end' (and potentially 'finish')</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">autoDestroy </span><span class="s3">= !!</span><span class="s1">options</span><span class="s3">.</span><span class="s1">autoDestroy</span><span class="s3">;</span>

  <span class="s0">// has it been destroyed</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">destroyed </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>

  <span class="s0">// Crypto is kind of old and crusty.  Historically, its default string</span>
  <span class="s0">// encoding is 'binary' so we have to make this configurable.</span>
  <span class="s0">// Everything else in the universe uses 'utf8', though.</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">defaultEncoding </span><span class="s3">= </span><span class="s1">options</span><span class="s3">.</span><span class="s1">defaultEncoding </span><span class="s3">|| </span><span class="s2">'utf8'</span><span class="s3">;</span>

  <span class="s0">// the number of writers that are awaiting a drain event in .pipe()s</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">awaitDrain </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>

  <span class="s0">// if true, a maybeReadMore has been scheduled</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">readingMore </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">decoder </span><span class="s3">= </span><span class="s4">null</span><span class="s3">;</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">encoding </span><span class="s3">= </span><span class="s4">null</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">encoding</span><span class="s3">) {</span>
    <span class="s4">if </span><span class="s3">(!</span><span class="s1">StringDecoder</span><span class="s3">) </span><span class="s1">StringDecoder </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">'string_decoder/'</span><span class="s3">).</span><span class="s1">StringDecoder</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s3">.</span><span class="s1">decoder </span><span class="s3">= </span><span class="s4">new </span><span class="s1">StringDecoder</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">encoding</span><span class="s3">);</span>
    <span class="s4">this</span><span class="s3">.</span><span class="s1">encoding </span><span class="s3">= </span><span class="s1">options</span><span class="s3">.</span><span class="s1">encoding</span><span class="s3">;</span>
  <span class="s3">}</span>
<span class="s3">}</span>
<span class="s4">function </span><span class="s1">Readable</span><span class="s3">(</span><span class="s1">options</span><span class="s3">) {</span>
  <span class="s1">Duplex </span><span class="s3">= </span><span class="s1">Duplex </span><span class="s3">|| </span><span class="s1">require</span><span class="s3">(</span><span class="s2">'./_stream_duplex'</span><span class="s3">);</span>
  <span class="s4">if </span><span class="s3">(!(</span><span class="s4">this instanceof </span><span class="s1">Readable</span><span class="s3">)) </span><span class="s4">return new </span><span class="s1">Readable</span><span class="s3">(</span><span class="s1">options</span><span class="s3">);</span>

  <span class="s0">// Checking for a Stream.Duplex instance is faster here instead of inside</span>
  <span class="s0">// the ReadableState constructor, at least with V8 6.5</span>
  <span class="s4">var </span><span class="s1">isDuplex </span><span class="s3">= </span><span class="s4">this instanceof </span><span class="s1">Duplex</span><span class="s3">;</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState </span><span class="s3">= </span><span class="s4">new </span><span class="s1">ReadableState</span><span class="s3">(</span><span class="s1">options</span><span class="s3">, </span><span class="s4">this</span><span class="s3">, </span><span class="s1">isDuplex</span><span class="s3">);</span>

  <span class="s0">// legacy</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">readable </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">options</span><span class="s3">) {</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">options</span><span class="s3">.</span><span class="s1">read </span><span class="s3">=== </span><span class="s2">'function'</span><span class="s3">) </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_read </span><span class="s3">= </span><span class="s1">options</span><span class="s3">.</span><span class="s1">read</span><span class="s3">;</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">options</span><span class="s3">.</span><span class="s1">destroy </span><span class="s3">=== </span><span class="s2">'function'</span><span class="s3">) </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_destroy </span><span class="s3">= </span><span class="s1">options</span><span class="s3">.</span><span class="s1">destroy</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s1">Stream</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">);</span>
<span class="s3">}</span>
<span class="s1">Object</span><span class="s3">.</span><span class="s1">defineProperty</span><span class="s3">(</span><span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">, </span><span class="s2">'destroyed'</span><span class="s3">, {</span>
  <span class="s0">// making it explicit this property is not enumerable</span>
  <span class="s0">// because otherwise some prototype manipulation in</span>
  <span class="s0">// userland will fail</span>
  <span class="s1">enumerable</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
  <span class="s1">get</span><span class="s3">: </span><span class="s4">function </span><span class="s1">get</span><span class="s3">() {</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
      <span class="s4">return false</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s4">return this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">destroyed</span><span class="s3">;</span>
  <span class="s3">},</span>
  <span class="s1">set</span><span class="s3">: </span><span class="s4">function </span><span class="s1">set</span><span class="s3">(</span><span class="s1">value</span><span class="s3">) {</span>
    <span class="s0">// we ignore the value if the stream</span>
    <span class="s0">// has not been initialized yet</span>
    <span class="s4">if </span><span class="s3">(!</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">) {</span>
      <span class="s4">return</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s0">// backward compatibility, the user is explicitly</span>
    <span class="s0">// managing destroyed</span>
    <span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">destroyed </span><span class="s3">= </span><span class="s1">value</span><span class="s3">;</span>
  <span class="s3">}</span>
<span class="s3">});</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">destroy </span><span class="s3">= </span><span class="s1">destroyImpl</span><span class="s3">.</span><span class="s1">destroy</span><span class="s3">;</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">_undestroy </span><span class="s3">= </span><span class="s1">destroyImpl</span><span class="s3">.</span><span class="s1">undestroy</span><span class="s3">;</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">_destroy </span><span class="s3">= </span><span class="s4">function </span><span class="s3">(</span><span class="s1">err</span><span class="s3">, </span><span class="s1">cb</span><span class="s3">) {</span>
  <span class="s1">cb</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
<span class="s3">};</span>

<span class="s0">// Manually shove something into the read() buffer.</span>
<span class="s0">// This returns true if the highWaterMark has not been hit yet,</span>
<span class="s0">// similar to how Writable.write() returns true if you should</span>
<span class="s0">// write() some more.</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">push </span><span class="s3">= </span><span class="s4">function </span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">) {</span>
  <span class="s4">var </span><span class="s1">state </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">;</span>
  <span class="s4">var </span><span class="s1">skipChunkCheck</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">objectMode</span><span class="s3">) {</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">chunk </span><span class="s3">=== </span><span class="s2">'string'</span><span class="s3">) {</span>
      <span class="s1">encoding </span><span class="s3">= </span><span class="s1">encoding </span><span class="s3">|| </span><span class="s1">state</span><span class="s3">.</span><span class="s1">defaultEncoding</span><span class="s3">;</span>
      <span class="s4">if </span><span class="s3">(</span><span class="s1">encoding </span><span class="s3">!== </span><span class="s1">state</span><span class="s3">.</span><span class="s1">encoding</span><span class="s3">) {</span>
        <span class="s1">chunk </span><span class="s3">= </span><span class="s1">Buffer</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">);</span>
        <span class="s1">encoding </span><span class="s3">= </span><span class="s2">''</span><span class="s3">;</span>
      <span class="s3">}</span>
      <span class="s1">skipChunkCheck </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
    <span class="s3">}</span>
  <span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
    <span class="s1">skipChunkCheck </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s4">return </span><span class="s1">readableAddChunk</span><span class="s3">(</span><span class="s4">this</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">, </span><span class="s4">false</span><span class="s3">, </span><span class="s1">skipChunkCheck</span><span class="s3">);</span>
<span class="s3">};</span>

<span class="s0">// Unshift should *always* be something directly out of read()</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">unshift </span><span class="s3">= </span><span class="s4">function </span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
  <span class="s4">return </span><span class="s1">readableAddChunk</span><span class="s3">(</span><span class="s4">this</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">, </span><span class="s4">null</span><span class="s3">, </span><span class="s4">true</span><span class="s3">, </span><span class="s4">false</span><span class="s3">);</span>
<span class="s3">};</span>
<span class="s4">function </span><span class="s1">readableAddChunk</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">, </span><span class="s1">addToFront</span><span class="s3">, </span><span class="s1">skipChunkCheck</span><span class="s3">) {</span>
  <span class="s1">debug</span><span class="s3">(</span><span class="s2">'readableAddChunk'</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">);</span>
  <span class="s4">var </span><span class="s1">state </span><span class="s3">= </span><span class="s1">stream</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">chunk </span><span class="s3">=== </span><span class="s4">null</span><span class="s3">) {</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">reading </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
    <span class="s1">onEofChunk</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">state</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
    <span class="s4">var </span><span class="s1">er</span><span class="s3">;</span>
    <span class="s4">if </span><span class="s3">(!</span><span class="s1">skipChunkCheck</span><span class="s3">) </span><span class="s1">er </span><span class="s3">= </span><span class="s1">chunkInvalid</span><span class="s3">(</span><span class="s1">state</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">);</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">er</span><span class="s3">) {</span>
      <span class="s1">errorOrDestroy</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">er</span><span class="s3">);</span>
    <span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">objectMode </span><span class="s3">|| </span><span class="s1">chunk </span><span class="s3">&amp;&amp; </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">) {</span>
      <span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">chunk </span><span class="s3">!== </span><span class="s2">'string' </span><span class="s3">&amp;&amp; !</span><span class="s1">state</span><span class="s3">.</span><span class="s1">objectMode </span><span class="s3">&amp;&amp; </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">getPrototypeOf</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) !== </span><span class="s1">Buffer</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">) {</span>
        <span class="s1">chunk </span><span class="s3">= </span><span class="s1">_uint8ArrayToBuffer</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
      <span class="s3">}</span>
      <span class="s4">if </span><span class="s3">(</span><span class="s1">addToFront</span><span class="s3">) {</span>
        <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">endEmitted</span><span class="s3">) </span><span class="s1">errorOrDestroy</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s4">new </span><span class="s1">ERR_STREAM_UNSHIFT_AFTER_END_EVENT</span><span class="s3">());</span><span class="s4">else </span><span class="s1">addChunk</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">state</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">, </span><span class="s4">true</span><span class="s3">);</span>
      <span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">ended</span><span class="s3">) {</span>
        <span class="s1">errorOrDestroy</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s4">new </span><span class="s1">ERR_STREAM_PUSH_AFTER_EOF</span><span class="s3">());</span>
      <span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">destroyed</span><span class="s3">) {</span>
        <span class="s4">return false</span><span class="s3">;</span>
      <span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
        <span class="s1">state</span><span class="s3">.</span><span class="s1">reading </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
        <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">decoder </span><span class="s3">&amp;&amp; !</span><span class="s1">encoding</span><span class="s3">) {</span>
          <span class="s1">chunk </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">decoder</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
          <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">objectMode </span><span class="s3">|| </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">length </span><span class="s3">!== </span><span class="s5">0</span><span class="s3">) </span><span class="s1">addChunk</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">state</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">, </span><span class="s4">false</span><span class="s3">);</span><span class="s4">else </span><span class="s1">maybeReadMore</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">state</span><span class="s3">);</span>
        <span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
          <span class="s1">addChunk</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">state</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">, </span><span class="s4">false</span><span class="s3">);</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
    <span class="s3">} </span><span class="s4">else if </span><span class="s3">(!</span><span class="s1">addToFront</span><span class="s3">) {</span>
      <span class="s1">state</span><span class="s3">.</span><span class="s1">reading </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
      <span class="s1">maybeReadMore</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">state</span><span class="s3">);</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s0">// We can push more data if we are below the highWaterMark.</span>
  <span class="s0">// Also, if we have no data yet, we can stand some more bytes.</span>
  <span class="s0">// This is to work around cases where hwm=0, such as the repl.</span>
  <span class="s4">return </span><span class="s3">!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">ended </span><span class="s3">&amp;&amp; (</span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&lt; </span><span class="s1">state</span><span class="s3">.</span><span class="s1">highWaterMark </span><span class="s3">|| </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s5">0</span><span class="s3">);</span>
<span class="s3">}</span>
<span class="s4">function </span><span class="s1">addChunk</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">state</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">addToFront</span><span class="s3">) {</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">&amp;&amp; </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s5">0 </span><span class="s3">&amp;&amp; !</span><span class="s1">state</span><span class="s3">.</span><span class="s1">sync</span><span class="s3">) {</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">awaitDrain </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">emit</span><span class="s3">(</span><span class="s2">'data'</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
    <span class="s0">// update the buffer info.</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">+= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">objectMode </span><span class="s3">? </span><span class="s5">1 </span><span class="s3">: </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">addToFront</span><span class="s3">) </span><span class="s1">state</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">.</span><span class="s1">unshift</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span><span class="s4">else </span><span class="s1">state</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">needReadable</span><span class="s3">) </span><span class="s1">emitReadable</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s1">maybeReadMore</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">state</span><span class="s3">);</span>
<span class="s3">}</span>
<span class="s4">function </span><span class="s1">chunkInvalid</span><span class="s3">(</span><span class="s1">state</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">) {</span>
  <span class="s4">var </span><span class="s1">er</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(!</span><span class="s1">_isUint8Array</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) &amp;&amp; </span><span class="s4">typeof </span><span class="s1">chunk </span><span class="s3">!== </span><span class="s2">'string' </span><span class="s3">&amp;&amp; </span><span class="s1">chunk </span><span class="s3">!== </span><span class="s1">undefined </span><span class="s3">&amp;&amp; !</span><span class="s1">state</span><span class="s3">.</span><span class="s1">objectMode</span><span class="s3">) {</span>
    <span class="s1">er </span><span class="s3">= </span><span class="s4">new </span><span class="s1">ERR_INVALID_ARG_TYPE</span><span class="s3">(</span><span class="s2">'chunk'</span><span class="s3">, [</span><span class="s2">'string'</span><span class="s3">, </span><span class="s2">'Buffer'</span><span class="s3">, </span><span class="s2">'Uint8Array'</span><span class="s3">], </span><span class="s1">chunk</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s4">return </span><span class="s1">er</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">isPaused </span><span class="s3">= </span><span class="s4">function </span><span class="s3">() {</span>
  <span class="s4">return this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s0">// backwards compatibility.</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">setEncoding </span><span class="s3">= </span><span class="s4">function </span><span class="s3">(</span><span class="s1">enc</span><span class="s3">) {</span>
  <span class="s4">if </span><span class="s3">(!</span><span class="s1">StringDecoder</span><span class="s3">) </span><span class="s1">StringDecoder </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">'string_decoder/'</span><span class="s3">).</span><span class="s1">StringDecoder</span><span class="s3">;</span>
  <span class="s4">var </span><span class="s1">decoder </span><span class="s3">= </span><span class="s4">new </span><span class="s1">StringDecoder</span><span class="s3">(</span><span class="s1">enc</span><span class="s3">);</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">decoder </span><span class="s3">= </span><span class="s1">decoder</span><span class="s3">;</span>
  <span class="s0">// If setEncoding(null), decoder.encoding equals utf8</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">encoding </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">decoder</span><span class="s3">.</span><span class="s1">encoding</span><span class="s3">;</span>

  <span class="s0">// Iterate over current buffer to convert already stored Buffers:</span>
  <span class="s4">var </span><span class="s1">p </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">.</span><span class="s1">head</span><span class="s3">;</span>
  <span class="s4">var </span><span class="s1">content </span><span class="s3">= </span><span class="s2">''</span><span class="s3">;</span>
  <span class="s4">while </span><span class="s3">(</span><span class="s1">p </span><span class="s3">!== </span><span class="s4">null</span><span class="s3">) {</span>
    <span class="s1">content </span><span class="s3">+= </span><span class="s1">decoder</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">data</span><span class="s3">);</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">next</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">content </span><span class="s3">!== </span><span class="s2">''</span><span class="s3">) </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">content</span><span class="s3">);</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">length </span><span class="s3">= </span><span class="s1">content</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s4">return this</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s0">// Don't raise the hwm &gt; 1GB</span>
<span class="s4">var </span><span class="s1">MAX_HWM </span><span class="s3">= </span><span class="s5">0x40000000</span><span class="s3">;</span>
<span class="s4">function </span><span class="s1">computeNewHighWaterMark</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) {</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&gt;= </span><span class="s1">MAX_HWM</span><span class="s3">) {</span>
    <span class="s0">// TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">MAX_HWM</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
    <span class="s0">// Get the next highest power of 2 to prevent increasing hwm excessively in</span>
    <span class="s0">// tiny amounts</span>
    <span class="s1">n</span><span class="s3">--;</span>
    <span class="s1">n </span><span class="s3">|= </span><span class="s1">n </span><span class="s3">&gt;&gt;&gt; </span><span class="s5">1</span><span class="s3">;</span>
    <span class="s1">n </span><span class="s3">|= </span><span class="s1">n </span><span class="s3">&gt;&gt;&gt; </span><span class="s5">2</span><span class="s3">;</span>
    <span class="s1">n </span><span class="s3">|= </span><span class="s1">n </span><span class="s3">&gt;&gt;&gt; </span><span class="s5">4</span><span class="s3">;</span>
    <span class="s1">n </span><span class="s3">|= </span><span class="s1">n </span><span class="s3">&gt;&gt;&gt; </span><span class="s5">8</span><span class="s3">;</span>
    <span class="s1">n </span><span class="s3">|= </span><span class="s1">n </span><span class="s3">&gt;&gt;&gt; </span><span class="s5">16</span><span class="s3">;</span>
    <span class="s1">n</span><span class="s3">++;</span>
  <span class="s3">}</span>
  <span class="s4">return </span><span class="s1">n</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// This function is designed to be inlinable, so please take care when making</span>
<span class="s0">// changes to the function body.</span>
<span class="s4">function </span><span class="s1">howMuchToRead</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">state</span><span class="s3">) {</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s5">0 </span><span class="s3">|| </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s5">0 </span><span class="s3">&amp;&amp; </span><span class="s1">state</span><span class="s3">.</span><span class="s1">ended</span><span class="s3">) </span><span class="s4">return </span><span class="s5">0</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">objectMode</span><span class="s3">) </span><span class="s4">return </span><span class="s5">1</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">!== </span><span class="s1">n</span><span class="s3">) {</span>
    <span class="s0">// Only flow one buffer at a time</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">&amp;&amp; </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) </span><span class="s4">return </span><span class="s1">state</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">.</span><span class="s1">head</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span><span class="s4">else return </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s0">// If we're asking for more than the current hwm, then raise the hwm.</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&gt; </span><span class="s1">state</span><span class="s3">.</span><span class="s1">highWaterMark</span><span class="s3">) </span><span class="s1">state</span><span class="s3">.</span><span class="s1">highWaterMark </span><span class="s3">= </span><span class="s1">computeNewHighWaterMark</span><span class="s3">(</span><span class="s1">n</span><span class="s3">);</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) </span><span class="s4">return </span><span class="s1">n</span><span class="s3">;</span>
  <span class="s0">// Don't have enough</span>
  <span class="s4">if </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">ended</span><span class="s3">) {</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">needReadable </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
    <span class="s4">return </span><span class="s5">0</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s4">return </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// you can override either this method, or the async _read(n) below.</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">read </span><span class="s3">= </span><span class="s4">function </span><span class="s3">(</span><span class="s1">n</span><span class="s3">) {</span>
  <span class="s1">debug</span><span class="s3">(</span><span class="s2">'read'</span><span class="s3">, </span><span class="s1">n</span><span class="s3">);</span>
  <span class="s1">n </span><span class="s3">= </span><span class="s1">parseInt</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s5">10</span><span class="s3">);</span>
  <span class="s4">var </span><span class="s1">state </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">;</span>
  <span class="s4">var </span><span class="s1">nOrig </span><span class="s3">= </span><span class="s1">n</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">!== </span><span class="s5">0</span><span class="s3">) </span><span class="s1">state</span><span class="s3">.</span><span class="s1">emittedReadable </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>

  <span class="s0">// if we're doing read(0) to trigger a readable event, but we</span>
  <span class="s0">// already have a bunch of data in the buffer, then just trigger</span>
  <span class="s0">// the 'readable' event and move on.</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">=== </span><span class="s5">0 </span><span class="s3">&amp;&amp; </span><span class="s1">state</span><span class="s3">.</span><span class="s1">needReadable </span><span class="s3">&amp;&amp; ((</span><span class="s1">state</span><span class="s3">.</span><span class="s1">highWaterMark </span><span class="s3">!== </span><span class="s5">0 </span><span class="s3">? </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt;= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">highWaterMark </span><span class="s3">: </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">) || </span><span class="s1">state</span><span class="s3">.</span><span class="s1">ended</span><span class="s3">)) {</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'read: emitReadable'</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">ended</span><span class="s3">);</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s5">0 </span><span class="s3">&amp;&amp; </span><span class="s1">state</span><span class="s3">.</span><span class="s1">ended</span><span class="s3">) </span><span class="s1">endReadable</span><span class="s3">(</span><span class="s4">this</span><span class="s3">);</span><span class="s4">else </span><span class="s1">emitReadable</span><span class="s3">(</span><span class="s4">this</span><span class="s3">);</span>
    <span class="s4">return null</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s1">n </span><span class="s3">= </span><span class="s1">howMuchToRead</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">state</span><span class="s3">);</span>

  <span class="s0">// if we've ended, and we're now clear, then finish it up.</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">=== </span><span class="s5">0 </span><span class="s3">&amp;&amp; </span><span class="s1">state</span><span class="s3">.</span><span class="s1">ended</span><span class="s3">) {</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s5">0</span><span class="s3">) </span><span class="s1">endReadable</span><span class="s3">(</span><span class="s4">this</span><span class="s3">);</span>
    <span class="s4">return null</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// All the actual chunk generation logic needs to be</span>
  <span class="s0">// *below* the call to _read.  The reason is that in certain</span>
  <span class="s0">// synthetic stream cases, such as passthrough streams, _read</span>
  <span class="s0">// may be a completely synchronous operation which may change</span>
  <span class="s0">// the state of the read buffer, providing enough data when</span>
  <span class="s0">// before there was *not* enough.</span>
  <span class="s0">//</span>
  <span class="s0">// So, the steps are:</span>
  <span class="s0">// 1. Figure out what the state of things will be after we do</span>
  <span class="s0">// a read from the buffer.</span>
  <span class="s0">//</span>
  <span class="s0">// 2. If that resulting state will trigger a _read, then call _read.</span>
  <span class="s0">// Note that this may be asynchronous, or synchronous.  Yes, it is</span>
  <span class="s0">// deeply ugly to write APIs this way, but that still doesn't mean</span>
  <span class="s0">// that the Readable class should behave improperly, as streams are</span>
  <span class="s0">// designed to be sync/async agnostic.</span>
  <span class="s0">// Take note if the _read call is sync or async (ie, if the read call</span>
  <span class="s0">// has returned yet), so that we know whether or not it's safe to emit</span>
  <span class="s0">// 'readable' etc.</span>
  <span class="s0">//</span>
  <span class="s0">// 3. Actually pull the requested chunks out of the buffer and return.</span>

  <span class="s0">// if we need a readable event, then we need to do some reading.</span>
  <span class="s4">var </span><span class="s1">doRead </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">needReadable</span><span class="s3">;</span>
  <span class="s1">debug</span><span class="s3">(</span><span class="s2">'need readable'</span><span class="s3">, </span><span class="s1">doRead</span><span class="s3">);</span>

  <span class="s0">// if we currently have less than the highWaterMark, then also read some</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s5">0 </span><span class="s3">|| </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s1">state</span><span class="s3">.</span><span class="s1">highWaterMark</span><span class="s3">) {</span>
    <span class="s1">doRead </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'length less than watermark'</span><span class="s3">, </span><span class="s1">doRead</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s0">// however, if we've ended, then there's no point, and if we're already</span>
  <span class="s0">// reading, then it's unnecessary.</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">ended </span><span class="s3">|| </span><span class="s1">state</span><span class="s3">.</span><span class="s1">reading</span><span class="s3">) {</span>
    <span class="s1">doRead </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'reading or ended'</span><span class="s3">, </span><span class="s1">doRead</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">doRead</span><span class="s3">) {</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'do read'</span><span class="s3">);</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">reading </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">sync </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
    <span class="s0">// if the length is currently zero, then we *need* a readable event.</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s5">0</span><span class="s3">) </span><span class="s1">state</span><span class="s3">.</span><span class="s1">needReadable </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
    <span class="s0">// call internal read method</span>
    <span class="s4">this</span><span class="s3">.</span><span class="s1">_read</span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">highWaterMark</span><span class="s3">);</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">sync </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
    <span class="s0">// If _read pushed data synchronously, then `reading` will be false,</span>
    <span class="s0">// and we need to re-evaluate how much data we can return to the user.</span>
    <span class="s4">if </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">reading</span><span class="s3">) </span><span class="s1">n </span><span class="s3">= </span><span class="s1">howMuchToRead</span><span class="s3">(</span><span class="s1">nOrig</span><span class="s3">, </span><span class="s1">state</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s4">var </span><span class="s1">ret</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">) </span><span class="s1">ret </span><span class="s3">= </span><span class="s1">fromList</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">state</span><span class="s3">);</span><span class="s4">else </span><span class="s1">ret </span><span class="s3">= </span><span class="s4">null</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">ret </span><span class="s3">=== </span><span class="s4">null</span><span class="s3">) {</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">needReadable </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&lt;= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">highWaterMark</span><span class="s3">;</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">-= </span><span class="s1">n</span><span class="s3">;</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">awaitDrain </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s5">0</span><span class="s3">) {</span>
    <span class="s0">// If we have nothing in the buffer, then we want to know</span>
    <span class="s0">// as soon as we *do* get something into the buffer.</span>
    <span class="s4">if </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">ended</span><span class="s3">) </span><span class="s1">state</span><span class="s3">.</span><span class="s1">needReadable </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>

    <span class="s0">// If we tried to read() past the EOF, then emit end on the next tick.</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">nOrig </span><span class="s3">!== </span><span class="s1">n </span><span class="s3">&amp;&amp; </span><span class="s1">state</span><span class="s3">.</span><span class="s1">ended</span><span class="s3">) </span><span class="s1">endReadable</span><span class="s3">(</span><span class="s4">this</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">ret </span><span class="s3">!== </span><span class="s4">null</span><span class="s3">) </span><span class="s4">this</span><span class="s3">.</span><span class="s1">emit</span><span class="s3">(</span><span class="s2">'data'</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">);</span>
  <span class="s4">return </span><span class="s1">ret</span><span class="s3">;</span>
<span class="s3">};</span>
<span class="s4">function </span><span class="s1">onEofChunk</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">state</span><span class="s3">) {</span>
  <span class="s1">debug</span><span class="s3">(</span><span class="s2">'onEofChunk'</span><span class="s3">);</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">ended</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">decoder</span><span class="s3">) {</span>
    <span class="s4">var </span><span class="s1">chunk </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">decoder</span><span class="s3">.</span><span class="s1">end</span><span class="s3">();</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">chunk </span><span class="s3">&amp;&amp; </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) {</span>
      <span class="s1">state</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
      <span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">+= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">objectMode </span><span class="s3">? </span><span class="s5">1 </span><span class="s3">: </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
  <span class="s1">state</span><span class="s3">.</span><span class="s1">ended </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">sync</span><span class="s3">) {</span>
    <span class="s0">// if we are sync, wait until next tick to emit the data.</span>
    <span class="s0">// Otherwise we risk emitting data in the flow()</span>
    <span class="s0">// the readable code triggers during a read() call</span>
    <span class="s1">emitReadable</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
    <span class="s0">// emit 'readable' now to make sure it gets picked up.</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">needReadable </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
    <span class="s4">if </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">emittedReadable</span><span class="s3">) {</span>
      <span class="s1">state</span><span class="s3">.</span><span class="s1">emittedReadable </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
      <span class="s1">emitReadable_</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">);</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">// Don't emit readable right away in sync mode, because this can trigger</span>
<span class="s0">// another read() call =&gt; stack overflow.  This way, it might trigger</span>
<span class="s0">// a nextTick recursion warning, but that's not so bad.</span>
<span class="s4">function </span><span class="s1">emitReadable</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">) {</span>
  <span class="s4">var </span><span class="s1">state </span><span class="s3">= </span><span class="s1">stream</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">;</span>
  <span class="s1">debug</span><span class="s3">(</span><span class="s2">'emitReadable'</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">needReadable</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">emittedReadable</span><span class="s3">);</span>
  <span class="s1">state</span><span class="s3">.</span><span class="s1">needReadable </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">emittedReadable</span><span class="s3">) {</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'emitReadable'</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">flowing</span><span class="s3">);</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">emittedReadable </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
    <span class="s1">process</span><span class="s3">.</span><span class="s1">nextTick</span><span class="s3">(</span><span class="s1">emitReadable_</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">);</span>
  <span class="s3">}</span>
<span class="s3">}</span>
<span class="s4">function </span><span class="s1">emitReadable_</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">) {</span>
  <span class="s4">var </span><span class="s1">state </span><span class="s3">= </span><span class="s1">stream</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">;</span>
  <span class="s1">debug</span><span class="s3">(</span><span class="s2">'emitReadable_'</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">destroyed</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">ended</span><span class="s3">);</span>
  <span class="s4">if </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">destroyed </span><span class="s3">&amp;&amp; (</span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">|| </span><span class="s1">state</span><span class="s3">.</span><span class="s1">ended</span><span class="s3">)) {</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">emit</span><span class="s3">(</span><span class="s2">'readable'</span><span class="s3">);</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">emittedReadable </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// The stream needs another readable event if</span>
  <span class="s0">// 1. It is not flowing, as the flow mechanism will take</span>
  <span class="s0">//    care of it.</span>
  <span class="s0">// 2. It is not ended.</span>
  <span class="s0">// 3. It is below the highWaterMark, so we can schedule</span>
  <span class="s0">//    another readable later.</span>
  <span class="s1">state</span><span class="s3">.</span><span class="s1">needReadable </span><span class="s3">= !</span><span class="s1">state</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">&amp;&amp; !</span><span class="s1">state</span><span class="s3">.</span><span class="s1">ended </span><span class="s3">&amp;&amp; </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&lt;= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">highWaterMark</span><span class="s3">;</span>
  <span class="s1">flow</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// at this point, the user has presumably seen the 'readable' event,</span>
<span class="s0">// and called read() to consume some data.  that may have triggered</span>
<span class="s0">// in turn another _read(n) call, in which case reading = true if</span>
<span class="s0">// it's in progress.</span>
<span class="s0">// However, if we're not ended, or reading, and the length &lt; hwm,</span>
<span class="s0">// then go ahead and try to read some more preemptively.</span>
<span class="s4">function </span><span class="s1">maybeReadMore</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">state</span><span class="s3">) {</span>
  <span class="s4">if </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">readingMore</span><span class="s3">) {</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">readingMore </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
    <span class="s1">process</span><span class="s3">.</span><span class="s1">nextTick</span><span class="s3">(</span><span class="s1">maybeReadMore_</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">, </span><span class="s1">state</span><span class="s3">);</span>
  <span class="s3">}</span>
<span class="s3">}</span>
<span class="s4">function </span><span class="s1">maybeReadMore_</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">state</span><span class="s3">) {</span>
  <span class="s0">// Attempt to read more data if we should.</span>
  <span class="s0">//</span>
  <span class="s0">// The conditions for reading more data are (one of):</span>
  <span class="s0">// - Not enough data buffered (state.length &lt; state.highWaterMark). The loop</span>
  <span class="s0">//   is responsible for filling the buffer with enough data if such data</span>
  <span class="s0">//   is available. If highWaterMark is 0 and we are not in the flowing mode</span>
  <span class="s0">//   we should _not_ attempt to buffer any extra data. We'll get more data</span>
  <span class="s0">//   when the stream consumer calls read() instead.</span>
  <span class="s0">// - No data in the buffer, and the stream is in flowing mode. In this mode</span>
  <span class="s0">//   the loop below is responsible for ensuring read() is called. Failing to</span>
  <span class="s0">//   call read here would abort the flow and there's no other mechanism for</span>
  <span class="s0">//   continuing the flow if the stream consumer has just subscribed to the</span>
  <span class="s0">//   'data' event.</span>
  <span class="s0">//</span>
  <span class="s0">// In addition to the above conditions to keep reading data, the following</span>
  <span class="s0">// conditions prevent the data from being read:</span>
  <span class="s0">// - The stream has ended (state.ended).</span>
  <span class="s0">// - There is already a pending 'read' operation (state.reading). This is a</span>
  <span class="s0">//   case where the the stream has called the implementation defined _read()</span>
  <span class="s0">//   method, but they are processing the call asynchronously and have _not_</span>
  <span class="s0">//   called push() with new data. In this case we skip performing more</span>
  <span class="s0">//   read()s. The execution ends in this method again after the _read() ends</span>
  <span class="s0">//   up calling push() with more data.</span>
  <span class="s4">while </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">reading </span><span class="s3">&amp;&amp; !</span><span class="s1">state</span><span class="s3">.</span><span class="s1">ended </span><span class="s3">&amp;&amp; (</span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&lt; </span><span class="s1">state</span><span class="s3">.</span><span class="s1">highWaterMark </span><span class="s3">|| </span><span class="s1">state</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">&amp;&amp; </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s5">0</span><span class="s3">)) {</span>
    <span class="s4">var </span><span class="s1">len </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'maybeReadMore read 0'</span><span class="s3">);</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s5">0</span><span class="s3">);</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">len </span><span class="s3">=== </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length</span><span class="s3">)</span>
      <span class="s0">// didn't get any data, stop spinning.</span>
      <span class="s4">break</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s1">state</span><span class="s3">.</span><span class="s1">readingMore </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// abstract method.  to be overridden in specific implementation classes.</span>
<span class="s0">// call cb(er, data) where data is &lt;= n in length.</span>
<span class="s0">// for virtual (non-string, non-buffer) streams, &quot;length&quot; is somewhat</span>
<span class="s0">// arbitrary, and perhaps not very meaningful.</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">_read </span><span class="s3">= </span><span class="s4">function </span><span class="s3">(</span><span class="s1">n</span><span class="s3">) {</span>
  <span class="s1">errorOrDestroy</span><span class="s3">(</span><span class="s4">this</span><span class="s3">, </span><span class="s4">new </span><span class="s1">ERR_METHOD_NOT_IMPLEMENTED</span><span class="s3">(</span><span class="s2">'_read()'</span><span class="s3">));</span>
<span class="s3">};</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">pipe </span><span class="s3">= </span><span class="s4">function </span><span class="s3">(</span><span class="s1">dest</span><span class="s3">, </span><span class="s1">pipeOpts</span><span class="s3">) {</span>
  <span class="s4">var </span><span class="s1">src </span><span class="s3">= </span><span class="s4">this</span><span class="s3">;</span>
  <span class="s4">var </span><span class="s1">state </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">;</span>
  <span class="s4">switch </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">pipesCount</span><span class="s3">) {</span>
    <span class="s4">case </span><span class="s5">0</span><span class="s3">:</span>
      <span class="s1">state</span><span class="s3">.</span><span class="s1">pipes </span><span class="s3">= </span><span class="s1">dest</span><span class="s3">;</span>
      <span class="s4">break</span><span class="s3">;</span>
    <span class="s4">case </span><span class="s5">1</span><span class="s3">:</span>
      <span class="s1">state</span><span class="s3">.</span><span class="s1">pipes </span><span class="s3">= [</span><span class="s1">state</span><span class="s3">.</span><span class="s1">pipes</span><span class="s3">, </span><span class="s1">dest</span><span class="s3">];</span>
      <span class="s4">break</span><span class="s3">;</span>
    <span class="s4">default</span><span class="s3">:</span>
      <span class="s1">state</span><span class="s3">.</span><span class="s1">pipes</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">dest</span><span class="s3">);</span>
      <span class="s4">break</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s1">state</span><span class="s3">.</span><span class="s1">pipesCount </span><span class="s3">+= </span><span class="s5">1</span><span class="s3">;</span>
  <span class="s1">debug</span><span class="s3">(</span><span class="s2">'pipe count=%d opts=%j'</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">pipesCount</span><span class="s3">, </span><span class="s1">pipeOpts</span><span class="s3">);</span>
  <span class="s4">var </span><span class="s1">doEnd </span><span class="s3">= (!</span><span class="s1">pipeOpts </span><span class="s3">|| </span><span class="s1">pipeOpts</span><span class="s3">.</span><span class="s1">end </span><span class="s3">!== </span><span class="s4">false</span><span class="s3">) &amp;&amp; </span><span class="s1">dest </span><span class="s3">!== </span><span class="s1">process</span><span class="s3">.</span><span class="s1">stdout </span><span class="s3">&amp;&amp; </span><span class="s1">dest </span><span class="s3">!== </span><span class="s1">process</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">;</span>
  <span class="s4">var </span><span class="s1">endFn </span><span class="s3">= </span><span class="s1">doEnd </span><span class="s3">? </span><span class="s1">onend </span><span class="s3">: </span><span class="s1">unpipe</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">endEmitted</span><span class="s3">) </span><span class="s1">process</span><span class="s3">.</span><span class="s1">nextTick</span><span class="s3">(</span><span class="s1">endFn</span><span class="s3">);</span><span class="s4">else </span><span class="s1">src</span><span class="s3">.</span><span class="s1">once</span><span class="s3">(</span><span class="s2">'end'</span><span class="s3">, </span><span class="s1">endFn</span><span class="s3">);</span>
  <span class="s1">dest</span><span class="s3">.</span><span class="s1">on</span><span class="s3">(</span><span class="s2">'unpipe'</span><span class="s3">, </span><span class="s1">onunpipe</span><span class="s3">);</span>
  <span class="s4">function </span><span class="s1">onunpipe</span><span class="s3">(</span><span class="s1">readable</span><span class="s3">, </span><span class="s1">unpipeInfo</span><span class="s3">) {</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'onunpipe'</span><span class="s3">);</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">readable </span><span class="s3">=== </span><span class="s1">src</span><span class="s3">) {</span>
      <span class="s4">if </span><span class="s3">(</span><span class="s1">unpipeInfo </span><span class="s3">&amp;&amp; </span><span class="s1">unpipeInfo</span><span class="s3">.</span><span class="s1">hasUnpiped </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">) {</span>
        <span class="s1">unpipeInfo</span><span class="s3">.</span><span class="s1">hasUnpiped </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
        <span class="s1">cleanup</span><span class="s3">();</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
  <span class="s4">function </span><span class="s1">onend</span><span class="s3">() {</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'onend'</span><span class="s3">);</span>
    <span class="s1">dest</span><span class="s3">.</span><span class="s1">end</span><span class="s3">();</span>
  <span class="s3">}</span>

  <span class="s0">// when the dest drains, it reduces the awaitDrain counter</span>
  <span class="s0">// on the source.  This would be more elegant with a .once()</span>
  <span class="s0">// handler in flow(), but adding and removing repeatedly is</span>
  <span class="s0">// too slow.</span>
  <span class="s4">var </span><span class="s1">ondrain </span><span class="s3">= </span><span class="s1">pipeOnDrain</span><span class="s3">(</span><span class="s1">src</span><span class="s3">);</span>
  <span class="s1">dest</span><span class="s3">.</span><span class="s1">on</span><span class="s3">(</span><span class="s2">'drain'</span><span class="s3">, </span><span class="s1">ondrain</span><span class="s3">);</span>
  <span class="s4">var </span><span class="s1">cleanedUp </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
  <span class="s4">function </span><span class="s1">cleanup</span><span class="s3">() {</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'cleanup'</span><span class="s3">);</span>
    <span class="s0">// cleanup event handlers once the pipe is broken</span>
    <span class="s1">dest</span><span class="s3">.</span><span class="s1">removeListener</span><span class="s3">(</span><span class="s2">'close'</span><span class="s3">, </span><span class="s1">onclose</span><span class="s3">);</span>
    <span class="s1">dest</span><span class="s3">.</span><span class="s1">removeListener</span><span class="s3">(</span><span class="s2">'finish'</span><span class="s3">, </span><span class="s1">onfinish</span><span class="s3">);</span>
    <span class="s1">dest</span><span class="s3">.</span><span class="s1">removeListener</span><span class="s3">(</span><span class="s2">'drain'</span><span class="s3">, </span><span class="s1">ondrain</span><span class="s3">);</span>
    <span class="s1">dest</span><span class="s3">.</span><span class="s1">removeListener</span><span class="s3">(</span><span class="s2">'error'</span><span class="s3">, </span><span class="s1">onerror</span><span class="s3">);</span>
    <span class="s1">dest</span><span class="s3">.</span><span class="s1">removeListener</span><span class="s3">(</span><span class="s2">'unpipe'</span><span class="s3">, </span><span class="s1">onunpipe</span><span class="s3">);</span>
    <span class="s1">src</span><span class="s3">.</span><span class="s1">removeListener</span><span class="s3">(</span><span class="s2">'end'</span><span class="s3">, </span><span class="s1">onend</span><span class="s3">);</span>
    <span class="s1">src</span><span class="s3">.</span><span class="s1">removeListener</span><span class="s3">(</span><span class="s2">'end'</span><span class="s3">, </span><span class="s1">unpipe</span><span class="s3">);</span>
    <span class="s1">src</span><span class="s3">.</span><span class="s1">removeListener</span><span class="s3">(</span><span class="s2">'data'</span><span class="s3">, </span><span class="s1">ondata</span><span class="s3">);</span>
    <span class="s1">cleanedUp </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>

    <span class="s0">// if the reader is waiting for a drain event from this</span>
    <span class="s0">// specific writer, then it would cause it to never start</span>
    <span class="s0">// flowing again.</span>
    <span class="s0">// So, if this is awaiting a drain, then we just call it now.</span>
    <span class="s0">// If we don't know, then assume that we are waiting for one.</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">awaitDrain </span><span class="s3">&amp;&amp; (!</span><span class="s1">dest</span><span class="s3">.</span><span class="s1">_writableState </span><span class="s3">|| </span><span class="s1">dest</span><span class="s3">.</span><span class="s1">_writableState</span><span class="s3">.</span><span class="s1">needDrain</span><span class="s3">)) </span><span class="s1">ondrain</span><span class="s3">();</span>
  <span class="s3">}</span>
  <span class="s1">src</span><span class="s3">.</span><span class="s1">on</span><span class="s3">(</span><span class="s2">'data'</span><span class="s3">, </span><span class="s1">ondata</span><span class="s3">);</span>
  <span class="s4">function </span><span class="s1">ondata</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'ondata'</span><span class="s3">);</span>
    <span class="s4">var </span><span class="s1">ret </span><span class="s3">= </span><span class="s1">dest</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'dest.write'</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">);</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">ret </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">) {</span>
      <span class="s0">// If the user unpiped during `dest.write()`, it is possible</span>
      <span class="s0">// to get stuck in a permanently paused state if that write</span>
      <span class="s0">// also returned false.</span>
      <span class="s0">// =&gt; Check whether `dest` is still a piping destination.</span>
      <span class="s4">if </span><span class="s3">((</span><span class="s1">state</span><span class="s3">.</span><span class="s1">pipesCount </span><span class="s3">=== </span><span class="s5">1 </span><span class="s3">&amp;&amp; </span><span class="s1">state</span><span class="s3">.</span><span class="s1">pipes </span><span class="s3">=== </span><span class="s1">dest </span><span class="s3">|| </span><span class="s1">state</span><span class="s3">.</span><span class="s1">pipesCount </span><span class="s3">&gt; </span><span class="s5">1 </span><span class="s3">&amp;&amp; </span><span class="s1">indexOf</span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">pipes</span><span class="s3">, </span><span class="s1">dest</span><span class="s3">) !== -</span><span class="s5">1</span><span class="s3">) &amp;&amp; !</span><span class="s1">cleanedUp</span><span class="s3">) {</span>
        <span class="s1">debug</span><span class="s3">(</span><span class="s2">'false write response, pause'</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">awaitDrain</span><span class="s3">);</span>
        <span class="s1">state</span><span class="s3">.</span><span class="s1">awaitDrain</span><span class="s3">++;</span>
      <span class="s3">}</span>
      <span class="s1">src</span><span class="s3">.</span><span class="s1">pause</span><span class="s3">();</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s0">// if the dest has an error, then stop piping into it.</span>
  <span class="s0">// however, don't suppress the throwing behavior for this.</span>
  <span class="s4">function </span><span class="s1">onerror</span><span class="s3">(</span><span class="s1">er</span><span class="s3">) {</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'onerror'</span><span class="s3">, </span><span class="s1">er</span><span class="s3">);</span>
    <span class="s1">unpipe</span><span class="s3">();</span>
    <span class="s1">dest</span><span class="s3">.</span><span class="s1">removeListener</span><span class="s3">(</span><span class="s2">'error'</span><span class="s3">, </span><span class="s1">onerror</span><span class="s3">);</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">EElistenerCount</span><span class="s3">(</span><span class="s1">dest</span><span class="s3">, </span><span class="s2">'error'</span><span class="s3">) === </span><span class="s5">0</span><span class="s3">) </span><span class="s1">errorOrDestroy</span><span class="s3">(</span><span class="s1">dest</span><span class="s3">, </span><span class="s1">er</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s0">// Make sure our error handler is attached before userland ones.</span>
  <span class="s1">prependListener</span><span class="s3">(</span><span class="s1">dest</span><span class="s3">, </span><span class="s2">'error'</span><span class="s3">, </span><span class="s1">onerror</span><span class="s3">);</span>

  <span class="s0">// Both close and finish should trigger unpipe, but only once.</span>
  <span class="s4">function </span><span class="s1">onclose</span><span class="s3">() {</span>
    <span class="s1">dest</span><span class="s3">.</span><span class="s1">removeListener</span><span class="s3">(</span><span class="s2">'finish'</span><span class="s3">, </span><span class="s1">onfinish</span><span class="s3">);</span>
    <span class="s1">unpipe</span><span class="s3">();</span>
  <span class="s3">}</span>
  <span class="s1">dest</span><span class="s3">.</span><span class="s1">once</span><span class="s3">(</span><span class="s2">'close'</span><span class="s3">, </span><span class="s1">onclose</span><span class="s3">);</span>
  <span class="s4">function </span><span class="s1">onfinish</span><span class="s3">() {</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'onfinish'</span><span class="s3">);</span>
    <span class="s1">dest</span><span class="s3">.</span><span class="s1">removeListener</span><span class="s3">(</span><span class="s2">'close'</span><span class="s3">, </span><span class="s1">onclose</span><span class="s3">);</span>
    <span class="s1">unpipe</span><span class="s3">();</span>
  <span class="s3">}</span>
  <span class="s1">dest</span><span class="s3">.</span><span class="s1">once</span><span class="s3">(</span><span class="s2">'finish'</span><span class="s3">, </span><span class="s1">onfinish</span><span class="s3">);</span>
  <span class="s4">function </span><span class="s1">unpipe</span><span class="s3">() {</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'unpipe'</span><span class="s3">);</span>
    <span class="s1">src</span><span class="s3">.</span><span class="s1">unpipe</span><span class="s3">(</span><span class="s1">dest</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s0">// tell the dest that it's being piped to</span>
  <span class="s1">dest</span><span class="s3">.</span><span class="s1">emit</span><span class="s3">(</span><span class="s2">'pipe'</span><span class="s3">, </span><span class="s1">src</span><span class="s3">);</span>

  <span class="s0">// start the flow if it hasn't been started already.</span>
  <span class="s4">if </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">flowing</span><span class="s3">) {</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'pipe resume'</span><span class="s3">);</span>
    <span class="s1">src</span><span class="s3">.</span><span class="s1">resume</span><span class="s3">();</span>
  <span class="s3">}</span>
  <span class="s4">return </span><span class="s1">dest</span><span class="s3">;</span>
<span class="s3">};</span>
<span class="s4">function </span><span class="s1">pipeOnDrain</span><span class="s3">(</span><span class="s1">src</span><span class="s3">) {</span>
  <span class="s4">return function </span><span class="s1">pipeOnDrainFunctionResult</span><span class="s3">() {</span>
    <span class="s4">var </span><span class="s1">state </span><span class="s3">= </span><span class="s1">src</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">;</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'pipeOnDrain'</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">awaitDrain</span><span class="s3">);</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">awaitDrain</span><span class="s3">) </span><span class="s1">state</span><span class="s3">.</span><span class="s1">awaitDrain</span><span class="s3">--;</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">awaitDrain </span><span class="s3">=== </span><span class="s5">0 </span><span class="s3">&amp;&amp; </span><span class="s1">EElistenerCount</span><span class="s3">(</span><span class="s1">src</span><span class="s3">, </span><span class="s2">'data'</span><span class="s3">)) {</span>
      <span class="s1">state</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
      <span class="s1">flow</span><span class="s3">(</span><span class="s1">src</span><span class="s3">);</span>
    <span class="s3">}</span>
  <span class="s3">};</span>
<span class="s3">}</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">unpipe </span><span class="s3">= </span><span class="s4">function </span><span class="s3">(</span><span class="s1">dest</span><span class="s3">) {</span>
  <span class="s4">var </span><span class="s1">state </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">;</span>
  <span class="s4">var </span><span class="s1">unpipeInfo </span><span class="s3">= {</span>
    <span class="s1">hasUnpiped</span><span class="s3">: </span><span class="s4">false</span>
  <span class="s3">};</span>

  <span class="s0">// if we're not piping anywhere, then do nothing.</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">pipesCount </span><span class="s3">=== </span><span class="s5">0</span><span class="s3">) </span><span class="s4">return this</span><span class="s3">;</span>

  <span class="s0">// just one destination.  most common case.</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">pipesCount </span><span class="s3">=== </span><span class="s5">1</span><span class="s3">) {</span>
    <span class="s0">// passed in one, but it's not the right one.</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">dest </span><span class="s3">&amp;&amp; </span><span class="s1">dest </span><span class="s3">!== </span><span class="s1">state</span><span class="s3">.</span><span class="s1">pipes</span><span class="s3">) </span><span class="s4">return this</span><span class="s3">;</span>
    <span class="s4">if </span><span class="s3">(!</span><span class="s1">dest</span><span class="s3">) </span><span class="s1">dest </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">pipes</span><span class="s3">;</span>

    <span class="s0">// got a match.</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">pipes </span><span class="s3">= </span><span class="s4">null</span><span class="s3">;</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">pipesCount </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">dest</span><span class="s3">) </span><span class="s1">dest</span><span class="s3">.</span><span class="s1">emit</span><span class="s3">(</span><span class="s2">'unpipe'</span><span class="s3">, </span><span class="s4">this</span><span class="s3">, </span><span class="s1">unpipeInfo</span><span class="s3">);</span>
    <span class="s4">return this</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// slow case. multiple pipe destinations.</span>

  <span class="s4">if </span><span class="s3">(!</span><span class="s1">dest</span><span class="s3">) {</span>
    <span class="s0">// remove all.</span>
    <span class="s4">var </span><span class="s1">dests </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">pipes</span><span class="s3">;</span>
    <span class="s4">var </span><span class="s1">len </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">pipesCount</span><span class="s3">;</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">pipes </span><span class="s3">= </span><span class="s4">null</span><span class="s3">;</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">pipesCount </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
    <span class="s4">for </span><span class="s3">(</span><span class="s4">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) </span><span class="s1">dests</span><span class="s3">[</span><span class="s1">i</span><span class="s3">].</span><span class="s1">emit</span><span class="s3">(</span><span class="s2">'unpipe'</span><span class="s3">, </span><span class="s4">this</span><span class="s3">, {</span>
      <span class="s1">hasUnpiped</span><span class="s3">: </span><span class="s4">false</span>
    <span class="s3">});</span>
    <span class="s4">return this</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// try to find the right one.</span>
  <span class="s4">var </span><span class="s1">index </span><span class="s3">= </span><span class="s1">indexOf</span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">pipes</span><span class="s3">, </span><span class="s1">dest</span><span class="s3">);</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">index </span><span class="s3">=== -</span><span class="s5">1</span><span class="s3">) </span><span class="s4">return this</span><span class="s3">;</span>
  <span class="s1">state</span><span class="s3">.</span><span class="s1">pipes</span><span class="s3">.</span><span class="s1">splice</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s5">1</span><span class="s3">);</span>
  <span class="s1">state</span><span class="s3">.</span><span class="s1">pipesCount </span><span class="s3">-= </span><span class="s5">1</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">pipesCount </span><span class="s3">=== </span><span class="s5">1</span><span class="s3">) </span><span class="s1">state</span><span class="s3">.</span><span class="s1">pipes </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">pipes</span><span class="s3">[</span><span class="s5">0</span><span class="s3">];</span>
  <span class="s1">dest</span><span class="s3">.</span><span class="s1">emit</span><span class="s3">(</span><span class="s2">'unpipe'</span><span class="s3">, </span><span class="s4">this</span><span class="s3">, </span><span class="s1">unpipeInfo</span><span class="s3">);</span>
  <span class="s4">return this</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s0">// set up data events if they are asked for</span>
<span class="s0">// Ensure readable listeners eventually get something</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">on </span><span class="s3">= </span><span class="s4">function </span><span class="s3">(</span><span class="s1">ev</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">) {</span>
  <span class="s4">var </span><span class="s1">res </span><span class="s3">= </span><span class="s1">Stream</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">on</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">, </span><span class="s1">ev</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">);</span>
  <span class="s4">var </span><span class="s1">state </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">ev </span><span class="s3">=== </span><span class="s2">'data'</span><span class="s3">) {</span>
    <span class="s0">// update readableListening so that resume() may be a no-op</span>
    <span class="s0">// a few lines down. This is needed to support once('readable').</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">readableListening </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">listenerCount</span><span class="s3">(</span><span class="s2">'readable'</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">;</span>

    <span class="s0">// Try start flowing on next tick if stream isn't explicitly paused</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">!== </span><span class="s4">false</span><span class="s3">) </span><span class="s4">this</span><span class="s3">.</span><span class="s1">resume</span><span class="s3">();</span>
  <span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">ev </span><span class="s3">=== </span><span class="s2">'readable'</span><span class="s3">) {</span>
    <span class="s4">if </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">endEmitted </span><span class="s3">&amp;&amp; !</span><span class="s1">state</span><span class="s3">.</span><span class="s1">readableListening</span><span class="s3">) {</span>
      <span class="s1">state</span><span class="s3">.</span><span class="s1">readableListening </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">needReadable </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
      <span class="s1">state</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
      <span class="s1">state</span><span class="s3">.</span><span class="s1">emittedReadable </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
      <span class="s1">debug</span><span class="s3">(</span><span class="s2">'on readable'</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">reading</span><span class="s3">);</span>
      <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) {</span>
        <span class="s1">emitReadable</span><span class="s3">(</span><span class="s4">this</span><span class="s3">);</span>
      <span class="s3">} </span><span class="s4">else if </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">reading</span><span class="s3">) {</span>
        <span class="s1">process</span><span class="s3">.</span><span class="s1">nextTick</span><span class="s3">(</span><span class="s1">nReadingNextTick</span><span class="s3">, </span><span class="s4">this</span><span class="s3">);</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
  <span class="s4">return </span><span class="s1">res</span><span class="s3">;</span>
<span class="s3">};</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">addListener </span><span class="s3">= </span><span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">on</span><span class="s3">;</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">removeListener </span><span class="s3">= </span><span class="s4">function </span><span class="s3">(</span><span class="s1">ev</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">) {</span>
  <span class="s4">var </span><span class="s1">res </span><span class="s3">= </span><span class="s1">Stream</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">removeListener</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">, </span><span class="s1">ev</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">);</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">ev </span><span class="s3">=== </span><span class="s2">'readable'</span><span class="s3">) {</span>
    <span class="s0">// We need to check if there is someone still listening to</span>
    <span class="s0">// readable and reset the state. However this needs to happen</span>
    <span class="s0">// after readable has been emitted but before I/O (nextTick) to</span>
    <span class="s0">// support once('readable', fn) cycles. This means that calling</span>
    <span class="s0">// resume within the same tick will have no</span>
    <span class="s0">// effect.</span>
    <span class="s1">process</span><span class="s3">.</span><span class="s1">nextTick</span><span class="s3">(</span><span class="s1">updateReadableListening</span><span class="s3">, </span><span class="s4">this</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s4">return </span><span class="s1">res</span><span class="s3">;</span>
<span class="s3">};</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">removeAllListeners </span><span class="s3">= </span><span class="s4">function </span><span class="s3">(</span><span class="s1">ev</span><span class="s3">) {</span>
  <span class="s4">var </span><span class="s1">res </span><span class="s3">= </span><span class="s1">Stream</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">removeAllListeners</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s4">this</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">);</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">ev </span><span class="s3">=== </span><span class="s2">'readable' </span><span class="s3">|| </span><span class="s1">ev </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
    <span class="s0">// We need to check if there is someone still listening to</span>
    <span class="s0">// readable and reset the state. However this needs to happen</span>
    <span class="s0">// after readable has been emitted but before I/O (nextTick) to</span>
    <span class="s0">// support once('readable', fn) cycles. This means that calling</span>
    <span class="s0">// resume within the same tick will have no</span>
    <span class="s0">// effect.</span>
    <span class="s1">process</span><span class="s3">.</span><span class="s1">nextTick</span><span class="s3">(</span><span class="s1">updateReadableListening</span><span class="s3">, </span><span class="s4">this</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s4">return </span><span class="s1">res</span><span class="s3">;</span>
<span class="s3">};</span>
<span class="s4">function </span><span class="s1">updateReadableListening</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) {</span>
  <span class="s4">var </span><span class="s1">state </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">;</span>
  <span class="s1">state</span><span class="s3">.</span><span class="s1">readableListening </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">listenerCount</span><span class="s3">(</span><span class="s2">'readable'</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">resumeScheduled </span><span class="s3">&amp;&amp; !</span><span class="s1">state</span><span class="s3">.</span><span class="s1">paused</span><span class="s3">) {</span>
    <span class="s0">// flowing needs to be set to true now, otherwise</span>
    <span class="s0">// the upcoming resume will not flow.</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>

    <span class="s0">// crude way to check if we should resume</span>
  <span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">listenerCount</span><span class="s3">(</span><span class="s2">'data'</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">) {</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">resume</span><span class="s3">();</span>
  <span class="s3">}</span>
<span class="s3">}</span>
<span class="s4">function </span><span class="s1">nReadingNextTick</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) {</span>
  <span class="s1">debug</span><span class="s3">(</span><span class="s2">'readable nexttick read 0'</span><span class="s3">);</span>
  <span class="s1">self</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s5">0</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// pause() and resume() are remnants of the legacy readable stream API</span>
<span class="s0">// If the user uses them, then switch into old mode.</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">resume </span><span class="s3">= </span><span class="s4">function </span><span class="s3">() {</span>
  <span class="s4">var </span><span class="s1">state </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">flowing</span><span class="s3">) {</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'resume'</span><span class="s3">);</span>
    <span class="s0">// we flow only if there is no one listening</span>
    <span class="s0">// for readable, but we still have to call</span>
    <span class="s0">// resume()</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">= !</span><span class="s1">state</span><span class="s3">.</span><span class="s1">readableListening</span><span class="s3">;</span>
    <span class="s1">resume</span><span class="s3">(</span><span class="s4">this</span><span class="s3">, </span><span class="s1">state</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s1">state</span><span class="s3">.</span><span class="s1">paused </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
  <span class="s4">return this</span><span class="s3">;</span>
<span class="s3">};</span>
<span class="s4">function </span><span class="s1">resume</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">state</span><span class="s3">) {</span>
  <span class="s4">if </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">resumeScheduled</span><span class="s3">) {</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">resumeScheduled </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
    <span class="s1">process</span><span class="s3">.</span><span class="s1">nextTick</span><span class="s3">(</span><span class="s1">resume_</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">, </span><span class="s1">state</span><span class="s3">);</span>
  <span class="s3">}</span>
<span class="s3">}</span>
<span class="s4">function </span><span class="s1">resume_</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">state</span><span class="s3">) {</span>
  <span class="s1">debug</span><span class="s3">(</span><span class="s2">'resume'</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">reading</span><span class="s3">);</span>
  <span class="s4">if </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">reading</span><span class="s3">) {</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s5">0</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s1">state</span><span class="s3">.</span><span class="s1">resumeScheduled </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
  <span class="s1">stream</span><span class="s3">.</span><span class="s1">emit</span><span class="s3">(</span><span class="s2">'resume'</span><span class="s3">);</span>
  <span class="s1">flow</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">);</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">&amp;&amp; !</span><span class="s1">state</span><span class="s3">.</span><span class="s1">reading</span><span class="s3">) </span><span class="s1">stream</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s5">0</span><span class="s3">);</span>
<span class="s3">}</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">pause </span><span class="s3">= </span><span class="s4">function </span><span class="s3">() {</span>
  <span class="s1">debug</span><span class="s3">(</span><span class="s2">'call pause flowing=%j'</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">flowing</span><span class="s3">);</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">!== </span><span class="s4">false</span><span class="s3">) {</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'pause'</span><span class="s3">);</span>
    <span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s3">.</span><span class="s1">emit</span><span class="s3">(</span><span class="s2">'pause'</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">paused </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
  <span class="s4">return this</span><span class="s3">;</span>
<span class="s3">};</span>
<span class="s4">function </span><span class="s1">flow</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">) {</span>
  <span class="s4">var </span><span class="s1">state </span><span class="s3">= </span><span class="s1">stream</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">;</span>
  <span class="s1">debug</span><span class="s3">(</span><span class="s2">'flow'</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">flowing</span><span class="s3">);</span>
  <span class="s4">while </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">&amp;&amp; </span><span class="s1">stream</span><span class="s3">.</span><span class="s1">read</span><span class="s3">() !== </span><span class="s4">null</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// wrap an old-style stream as the async data source.</span>
<span class="s0">// This is *not* part of the readable stream interface.</span>
<span class="s0">// It is an ugly unfortunate mess of history.</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">wrap </span><span class="s3">= </span><span class="s4">function </span><span class="s3">(</span><span class="s1">stream</span><span class="s3">) {</span>
  <span class="s4">var </span><span class="s1">_this </span><span class="s3">= </span><span class="s4">this</span><span class="s3">;</span>
  <span class="s4">var </span><span class="s1">state </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">;</span>
  <span class="s4">var </span><span class="s1">paused </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
  <span class="s1">stream</span><span class="s3">.</span><span class="s1">on</span><span class="s3">(</span><span class="s2">'end'</span><span class="s3">, </span><span class="s4">function </span><span class="s3">() {</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'wrapped end'</span><span class="s3">);</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">decoder </span><span class="s3">&amp;&amp; !</span><span class="s1">state</span><span class="s3">.</span><span class="s1">ended</span><span class="s3">) {</span>
      <span class="s4">var </span><span class="s1">chunk </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">decoder</span><span class="s3">.</span><span class="s1">end</span><span class="s3">();</span>
      <span class="s4">if </span><span class="s3">(</span><span class="s1">chunk </span><span class="s3">&amp;&amp; </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) </span><span class="s1">_this</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s1">_this</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s4">null</span><span class="s3">);</span>
  <span class="s3">});</span>
  <span class="s1">stream</span><span class="s3">.</span><span class="s1">on</span><span class="s3">(</span><span class="s2">'data'</span><span class="s3">, </span><span class="s4">function </span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'wrapped data'</span><span class="s3">);</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">decoder</span><span class="s3">) </span><span class="s1">chunk </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">decoder</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>

    <span class="s0">// don't skip over falsy values in objectMode</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">objectMode </span><span class="s3">&amp;&amp; (</span><span class="s1">chunk </span><span class="s3">=== </span><span class="s4">null </span><span class="s3">|| </span><span class="s1">chunk </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">)) </span><span class="s4">return</span><span class="s3">;</span><span class="s4">else if </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">objectMode </span><span class="s3">&amp;&amp; (!</span><span class="s1">chunk </span><span class="s3">|| !</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">length</span><span class="s3">)) </span><span class="s4">return</span><span class="s3">;</span>
    <span class="s4">var </span><span class="s1">ret </span><span class="s3">= </span><span class="s1">_this</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
    <span class="s4">if </span><span class="s3">(!</span><span class="s1">ret</span><span class="s3">) {</span>
      <span class="s1">paused </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
      <span class="s1">stream</span><span class="s3">.</span><span class="s1">pause</span><span class="s3">();</span>
    <span class="s3">}</span>
  <span class="s3">});</span>

  <span class="s0">// proxy all the other methods.</span>
  <span class="s0">// important when wrapping filters and duplexes.</span>
  <span class="s4">for </span><span class="s3">(</span><span class="s4">var </span><span class="s1">i </span><span class="s4">in </span><span class="s1">stream</span><span class="s3">) {</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] === </span><span class="s1">undefined </span><span class="s3">&amp;&amp; </span><span class="s4">typeof </span><span class="s1">stream</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] === </span><span class="s2">'function'</span><span class="s3">) {</span>
      <span class="s4">this</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">function </span><span class="s1">methodWrap</span><span class="s3">(</span><span class="s1">method</span><span class="s3">) {</span>
        <span class="s4">return function </span><span class="s1">methodWrapReturnFunction</span><span class="s3">() {</span>
          <span class="s4">return </span><span class="s1">stream</span><span class="s3">[</span><span class="s1">method</span><span class="s3">].</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">);</span>
        <span class="s3">};</span>
      <span class="s3">}(</span><span class="s1">i</span><span class="s3">);</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s0">// proxy certain important events.</span>
  <span class="s4">for </span><span class="s3">(</span><span class="s4">var </span><span class="s1">n </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s1">kProxyEvents</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">n</span><span class="s3">++) {</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">on</span><span class="s3">(</span><span class="s1">kProxyEvents</span><span class="s3">[</span><span class="s1">n</span><span class="s3">], </span><span class="s4">this</span><span class="s3">.</span><span class="s1">emit</span><span class="s3">.</span><span class="s1">bind</span><span class="s3">(</span><span class="s4">this</span><span class="s3">, </span><span class="s1">kProxyEvents</span><span class="s3">[</span><span class="s1">n</span><span class="s3">]));</span>
  <span class="s3">}</span>

  <span class="s0">// when we try to consume some more bytes, simply unpause the</span>
  <span class="s0">// underlying stream.</span>
  <span class="s4">this</span><span class="s3">.</span><span class="s1">_read </span><span class="s3">= </span><span class="s4">function </span><span class="s3">(</span><span class="s1">n</span><span class="s3">) {</span>
    <span class="s1">debug</span><span class="s3">(</span><span class="s2">'wrapped _read'</span><span class="s3">, </span><span class="s1">n</span><span class="s3">);</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">paused</span><span class="s3">) {</span>
      <span class="s1">paused </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
      <span class="s1">stream</span><span class="s3">.</span><span class="s1">resume</span><span class="s3">();</span>
    <span class="s3">}</span>
  <span class="s3">};</span>
  <span class="s4">return this</span><span class="s3">;</span>
<span class="s3">};</span>
<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">Symbol </span><span class="s3">=== </span><span class="s2">'function'</span><span class="s3">) {</span>
  <span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">[</span><span class="s1">Symbol</span><span class="s3">.</span><span class="s1">asyncIterator</span><span class="s3">] = </span><span class="s4">function </span><span class="s3">() {</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">createReadableStreamAsyncIterator </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
      <span class="s1">createReadableStreamAsyncIterator </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">'./internal/streams/async_iterator'</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s4">return </span><span class="s1">createReadableStreamAsyncIterator</span><span class="s3">(</span><span class="s4">this</span><span class="s3">);</span>
  <span class="s3">};</span>
<span class="s3">}</span>
<span class="s1">Object</span><span class="s3">.</span><span class="s1">defineProperty</span><span class="s3">(</span><span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">, </span><span class="s2">'readableHighWaterMark'</span><span class="s3">, {</span>
  <span class="s0">// making it explicit this property is not enumerable</span>
  <span class="s0">// because otherwise some prototype manipulation in</span>
  <span class="s0">// userland will fail</span>
  <span class="s1">enumerable</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
  <span class="s1">get</span><span class="s3">: </span><span class="s4">function </span><span class="s1">get</span><span class="s3">() {</span>
    <span class="s4">return this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">highWaterMark</span><span class="s3">;</span>
  <span class="s3">}</span>
<span class="s3">});</span>
<span class="s1">Object</span><span class="s3">.</span><span class="s1">defineProperty</span><span class="s3">(</span><span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">, </span><span class="s2">'readableBuffer'</span><span class="s3">, {</span>
  <span class="s0">// making it explicit this property is not enumerable</span>
  <span class="s0">// because otherwise some prototype manipulation in</span>
  <span class="s0">// userland will fail</span>
  <span class="s1">enumerable</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
  <span class="s1">get</span><span class="s3">: </span><span class="s4">function </span><span class="s1">get</span><span class="s3">() {</span>
    <span class="s4">return this</span><span class="s3">.</span><span class="s1">_readableState </span><span class="s3">&amp;&amp; </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">;</span>
  <span class="s3">}</span>
<span class="s3">});</span>
<span class="s1">Object</span><span class="s3">.</span><span class="s1">defineProperty</span><span class="s3">(</span><span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">, </span><span class="s2">'readableFlowing'</span><span class="s3">, {</span>
  <span class="s0">// making it explicit this property is not enumerable</span>
  <span class="s0">// because otherwise some prototype manipulation in</span>
  <span class="s0">// userland will fail</span>
  <span class="s1">enumerable</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
  <span class="s1">get</span><span class="s3">: </span><span class="s4">function </span><span class="s1">get</span><span class="s3">() {</span>
    <span class="s4">return this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">flowing</span><span class="s3">;</span>
  <span class="s3">},</span>
  <span class="s1">set</span><span class="s3">: </span><span class="s4">function </span><span class="s1">set</span><span class="s3">(</span><span class="s1">state</span><span class="s3">) {</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">) {</span>
      <span class="s4">this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">flowing </span><span class="s3">= </span><span class="s1">state</span><span class="s3">;</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
<span class="s3">});</span>

<span class="s0">// exposed for testing purposes only.</span>
<span class="s1">Readable</span><span class="s3">.</span><span class="s1">_fromList </span><span class="s3">= </span><span class="s1">fromList</span><span class="s3">;</span>
<span class="s1">Object</span><span class="s3">.</span><span class="s1">defineProperty</span><span class="s3">(</span><span class="s1">Readable</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">, </span><span class="s2">'readableLength'</span><span class="s3">, {</span>
  <span class="s0">// making it explicit this property is not enumerable</span>
  <span class="s0">// because otherwise some prototype manipulation in</span>
  <span class="s0">// userland will fail</span>
  <span class="s1">enumerable</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
  <span class="s1">get</span><span class="s3">: </span><span class="s4">function </span><span class="s1">get</span><span class="s3">() {</span>
    <span class="s4">return this</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s3">}</span>
<span class="s3">});</span>

<span class="s0">// Pluck off n bytes from an array of buffers.</span>
<span class="s0">// Length is the combined lengths of all the buffers in the list.</span>
<span class="s0">// This function is designed to be inlinable, so please take care when making</span>
<span class="s0">// changes to the function body.</span>
<span class="s4">function </span><span class="s1">fromList</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">state</span><span class="s3">) {</span>
  <span class="s0">// nothing buffered</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s5">0</span><span class="s3">) </span><span class="s4">return null</span><span class="s3">;</span>
  <span class="s4">var </span><span class="s1">ret</span><span class="s3">;</span>
  <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">objectMode</span><span class="s3">) </span><span class="s1">ret </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">.</span><span class="s1">shift</span><span class="s3">();</span><span class="s4">else if </span><span class="s3">(!</span><span class="s1">n </span><span class="s3">|| </span><span class="s1">n </span><span class="s3">&gt;= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) {</span>
    <span class="s0">// read it all, truncate the list</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">decoder</span><span class="s3">) </span><span class="s1">ret </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s2">''</span><span class="s3">);</span><span class="s4">else if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s5">1</span><span class="s3">) </span><span class="s1">ret </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">.</span><span class="s1">first</span><span class="s3">();</span><span class="s4">else </span><span class="s1">ret </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">.</span><span class="s1">concat</span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">length</span><span class="s3">);</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
  <span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
    <span class="s0">// read part of list</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">.</span><span class="s1">consume</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">decoder</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s4">return </span><span class="s1">ret</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s4">function </span><span class="s1">endReadable</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">) {</span>
  <span class="s4">var </span><span class="s1">state </span><span class="s3">= </span><span class="s1">stream</span><span class="s3">.</span><span class="s1">_readableState</span><span class="s3">;</span>
  <span class="s1">debug</span><span class="s3">(</span><span class="s2">'endReadable'</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">endEmitted</span><span class="s3">);</span>
  <span class="s4">if </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">endEmitted</span><span class="s3">) {</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">ended </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
    <span class="s1">process</span><span class="s3">.</span><span class="s1">nextTick</span><span class="s3">(</span><span class="s1">endReadableNT</span><span class="s3">, </span><span class="s1">state</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">);</span>
  <span class="s3">}</span>
<span class="s3">}</span>
<span class="s4">function </span><span class="s1">endReadableNT</span><span class="s3">(</span><span class="s1">state</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">) {</span>
  <span class="s1">debug</span><span class="s3">(</span><span class="s2">'endReadableNT'</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">endEmitted</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length</span><span class="s3">);</span>

  <span class="s0">// Check that we didn't get one last unshift.</span>
  <span class="s4">if </span><span class="s3">(!</span><span class="s1">state</span><span class="s3">.</span><span class="s1">endEmitted </span><span class="s3">&amp;&amp; </span><span class="s1">state</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s5">0</span><span class="s3">) {</span>
    <span class="s1">state</span><span class="s3">.</span><span class="s1">endEmitted </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">readable </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">emit</span><span class="s3">(</span><span class="s2">'end'</span><span class="s3">);</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">autoDestroy</span><span class="s3">) {</span>
      <span class="s0">// In case of duplex streams we need a way to detect</span>
      <span class="s0">// if the writable side is ready for autoDestroy as well</span>
      <span class="s4">var </span><span class="s1">wState </span><span class="s3">= </span><span class="s1">stream</span><span class="s3">.</span><span class="s1">_writableState</span><span class="s3">;</span>
      <span class="s4">if </span><span class="s3">(!</span><span class="s1">wState </span><span class="s3">|| </span><span class="s1">wState</span><span class="s3">.</span><span class="s1">autoDestroy </span><span class="s3">&amp;&amp; </span><span class="s1">wState</span><span class="s3">.</span><span class="s1">finished</span><span class="s3">) {</span>
        <span class="s1">stream</span><span class="s3">.</span><span class="s1">destroy</span><span class="s3">();</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
<span class="s3">}</span>
<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">Symbol </span><span class="s3">=== </span><span class="s2">'function'</span><span class="s3">) {</span>
  <span class="s1">Readable</span><span class="s3">.</span><span class="s1">from </span><span class="s3">= </span><span class="s4">function </span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">) {</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">from </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
      <span class="s1">from </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">'./internal/streams/from'</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s4">return </span><span class="s1">from</span><span class="s3">(</span><span class="s1">Readable</span><span class="s3">, </span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">);</span>
  <span class="s3">};</span>
<span class="s3">}</span>
<span class="s4">function </span><span class="s1">indexOf</span><span class="s3">(</span><span class="s1">xs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s4">for </span><span class="s3">(</span><span class="s4">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">l </span><span class="s3">= </span><span class="s1">xs</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">l</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
    <span class="s4">if </span><span class="s3">(</span><span class="s1">xs</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] === </span><span class="s1">x</span><span class="s3">) </span><span class="s4">return </span><span class="s1">i</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s4">return </span><span class="s3">-</span><span class="s5">1</span><span class="s3">;</span>
<span class="s3">}</span></pre>
</body>
</html>