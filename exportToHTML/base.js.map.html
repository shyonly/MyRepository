<html>
<head>
<title>base.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
base.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;File&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;program&quot;</span><span class="s0">,</span><span class="s1">&quot;print&quot;</span><span class="s0">,</span><span class="s1">&quot;interpreter&quot;</span><span class="s0">,</span><span class="s1">&quot;Program&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$directives&quot;</span><span class="s0">,</span><span class="s1">&quot;noIndentInnerCommentsHere&quot;</span><span class="s0">,</span><span class="s1">&quot;printInnerComments&quot;</span><span class="s0">,</span><span class="s1">&quot;directivesLen&quot;</span><span class="s0">,</span><span class="s1">&quot;directives&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$directives$trai&quot;</span><span class="s0">,</span><span class="s1">&quot;newline&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;printSequence&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingCommentsLineOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;BlockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$directives2&quot;</span><span class="s0">,</span><span class="s1">&quot;token&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$directives$trai2&quot;</span><span class="s0">,</span><span class="s1">&quot;indent&quot;</span><span class="s0">,</span><span class="s1">&quot;rightBrace&quot;</span><span class="s0">,</span><span class="s1">&quot;Directive&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;semicolon&quot;</span><span class="s0">,</span><span class="s1">&quot;unescapedSingleQuoteRE&quot;</span><span class="s0">,</span><span class="s1">&quot;unescapedDoubleQuoteRE&quot;</span><span class="s0">,</span><span class="s1">&quot;DirectiveLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;raw&quot;</span><span class="s0">,</span><span class="s1">&quot;getPossibleRaw&quot;</span><span class="s0">,</span><span class="s1">&quot;format&quot;</span><span class="s0">,</span><span class="s1">&quot;minified&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;InterpreterDirective&quot;</span><span class="s0">,</span><span class="s1">&quot;Placeholder&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;expectedNode&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/generators/base.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type Printer from </span><span class="s3">\&quot;</span><span class="s1">../printer.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export function File(this: Printer, node: t.File) {</span><span class="s3">\n  </span><span class="s1">if (node.program) {</span><span class="s3">\n    </span><span class="s1">// Print this here to ensure that Program node 'leadingComments' still</span><span class="s3">\n    </span><span class="s1">// get printed after the hashbang.</span><span class="s3">\n    </span><span class="s1">this.print(node.program.interpreter, node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.print(node.program, node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function Program(this: Printer, node: t.Program) {</span><span class="s3">\n  </span><span class="s1">// An empty Program doesn't have any inner tokens, so</span><span class="s3">\n  </span><span class="s1">// we must explicitly print its inner comments.</span><span class="s3">\n  </span><span class="s1">this.noIndentInnerCommentsHere();</span><span class="s3">\n  </span><span class="s1">this.printInnerComments();</span><span class="s3">\n\n  </span><span class="s1">const directivesLen = node.directives?.length;</span><span class="s3">\n  </span><span class="s1">if (directivesLen) {</span><span class="s3">\n    </span><span class="s1">const newline = node.body.length ? 2 : 1;</span><span class="s3">\n    </span><span class="s1">this.printSequence(node.directives, node, {</span><span class="s3">\n      </span><span class="s1">trailingCommentsLineOffset: newline,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (!node.directives[directivesLen - 1].trailingComments?.length) {</span><span class="s3">\n      </span><span class="s1">this.newline(newline);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.printSequence(node.body, node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function BlockStatement(this: Printer, node: t.BlockStatement) {</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">const directivesLen = node.directives?.length;</span><span class="s3">\n  </span><span class="s1">if (directivesLen) {</span><span class="s3">\n    </span><span class="s1">const newline = node.body.length ? 2 : 1;</span><span class="s3">\n    </span><span class="s1">this.printSequence(node.directives, node, {</span><span class="s3">\n      </span><span class="s1">indent: true,</span><span class="s3">\n      </span><span class="s1">trailingCommentsLineOffset: newline,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (!node.directives[directivesLen - 1].trailingComments?.length) {</span><span class="s3">\n      </span><span class="s1">this.newline(newline);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.printSequence(node.body, node, { indent: true });</span><span class="s3">\n\n  </span><span class="s1">this.rightBrace(node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function Directive(this: Printer, node: t.Directive) {</span><span class="s3">\n  </span><span class="s1">this.print(node.value, node);</span><span class="s3">\n  </span><span class="s1">this.semicolon();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// These regexes match an even number of </span><span class="s3">\\ </span><span class="s1">followed by a quote</span><span class="s3">\n</span><span class="s1">const unescapedSingleQuoteRE = /(?:^|[^</span><span class="s3">\\\\</span><span class="s1">])(?:</span><span class="s3">\\\\\\\\</span><span class="s1">)*'/;</span><span class="s3">\n</span><span class="s1">const unescapedDoubleQuoteRE = /(?:^|[^</span><span class="s3">\\\\</span><span class="s1">])(?:</span><span class="s3">\\\\\\\\</span><span class="s1">)*</span><span class="s3">\&quot;</span><span class="s1">/;</span><span class="s3">\n\n</span><span class="s1">export function DirectiveLiteral(this: Printer, node: t.DirectiveLiteral) {</span><span class="s3">\n  </span><span class="s1">const raw = this.getPossibleRaw(node);</span><span class="s3">\n  </span><span class="s1">if (!this.format.minified &amp;&amp; raw !== undefined) {</span><span class="s3">\n    </span><span class="s1">this.token(raw);</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { value } = node;</span><span class="s3">\n\n  </span><span class="s1">// NOTE: In directives we can't change escapings,</span><span class="s3">\n  </span><span class="s1">// because they change the behavior.</span><span class="s3">\n  </span><span class="s1">// e.g. </span><span class="s3">\&quot;</span><span class="s1">us</span><span class="s3">\\</span><span class="s1">x65 strict</span><span class="s3">\&quot; </span><span class="s1">(</span><span class="s3">\\</span><span class="s1">x65 is e) is not a </span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot; </span><span class="s1">directive.</span><span class="s3">\n\n  </span><span class="s1">if (!unescapedDoubleQuoteRE.test(value)) {</span><span class="s3">\n    </span><span class="s1">this.token(`</span><span class="s3">\&quot;</span><span class="s1">${value}</span><span class="s3">\&quot;</span><span class="s1">`);</span><span class="s3">\n  </span><span class="s1">} else if (!unescapedSingleQuoteRE.test(value)) {</span><span class="s3">\n    </span><span class="s1">this.token(`'${value}'`);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">Malformed AST: it is not possible to print a directive containing</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        \&quot; </span><span class="s1">both unescaped single and double quotes.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function InterpreterDirective(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: t.InterpreterDirective,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">this.token(`#!${node.value}`);</span><span class="s3">\n  </span><span class="s1">this.newline(1, true);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function Placeholder(this: Printer, node: t.Placeholder) {</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">%%</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.print(node.name);</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">%%</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">if (node.expectedNode === </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.semicolon();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>