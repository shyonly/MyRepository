<html>
<head>
<title>caching.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
caching.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_gensync&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_async&quot;</span><span class="s0">,</span><span class="s1">&quot;_util&quot;</span><span class="s0">,</span><span class="s1">&quot;synchronize&quot;</span><span class="s0">,</span><span class="s1">&quot;gen&quot;</span><span class="s0">,</span><span class="s1">&quot;gensync&quot;</span><span class="s0">,</span><span class="s1">&quot;sync&quot;</span><span class="s0">,</span><span class="s1">&quot;genTrue&quot;</span><span class="s0">,</span><span class="s1">&quot;makeWeakCache&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;makeCachedFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;makeWeakCacheSync&quot;</span><span class="s0">,</span><span class="s1">&quot;makeStrongCache&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;makeStrongCacheSync&quot;</span><span class="s0">,</span><span class="s1">&quot;CallCache&quot;</span><span class="s0">,</span><span class="s1">&quot;callCacheSync&quot;</span><span class="s0">,</span><span class="s1">&quot;callCacheAsync&quot;</span><span class="s0">,</span><span class="s1">&quot;futureCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;arg&quot;</span><span class="s0">,</span><span class="s1">&quot;asyncContext&quot;</span><span class="s0">,</span><span class="s1">&quot;isAsync&quot;</span><span class="s0">,</span><span class="s1">&quot;callCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cached&quot;</span><span class="s0">,</span><span class="s1">&quot;getCachedValueOrWait&quot;</span><span class="s0">,</span><span class="s1">&quot;valid&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;CacheConfigurator&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerResult&quot;</span><span class="s0">,</span><span class="s1">&quot;finishLock&quot;</span><span class="s0">,</span><span class="s1">&quot;isIterableIterator&quot;</span><span class="s0">,</span><span class="s1">&quot;onFirstPause&quot;</span><span class="s0">,</span><span class="s1">&quot;setupAsyncLocks&quot;</span><span class="s0">,</span><span class="s1">&quot;updateFunctionCache&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;release&quot;</span><span class="s0">,</span><span class="s1">&quot;getCachedValue&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedValue&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;waitFor&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;config&quot;</span><span class="s0">,</span><span class="s1">&quot;Lock&quot;</span><span class="s0">,</span><span class="s1">&quot;configured&quot;</span><span class="s0">,</span><span class="s1">&quot;forever&quot;</span><span class="s0">,</span><span class="s1">&quot;deactivate&quot;</span><span class="s0">,</span><span class="s1">&quot;mode&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;validator&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;_active&quot;</span><span class="s0">,</span><span class="s1">&quot;_never&quot;</span><span class="s0">,</span><span class="s1">&quot;_forever&quot;</span><span class="s0">,</span><span class="s1">&quot;_invalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;_configured&quot;</span><span class="s0">,</span><span class="s1">&quot;_pairs&quot;</span><span class="s0">,</span><span class="s1">&quot;_data&quot;</span><span class="s0">,</span><span class="s1">&quot;simple&quot;</span><span class="s0">,</span><span class="s1">&quot;makeSimpleConfigurator&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;never&quot;</span><span class="s0">,</span><span class="s1">&quot;using&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeAsync&quot;</span><span class="s0">,</span><span class="s1">&quot;isThenable&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;pairs&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheFn&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;assertSimpleType&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;released&quot;</span><span class="s0">,</span><span class="s1">&quot;_resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/config/caching.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import gensync from </span><span class="s3">\&quot;</span><span class="s1">gensync</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Handler } from </span><span class="s3">\&quot;</span><span class="s1">gensync</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">maybeAsync,</span><span class="s3">\n  </span><span class="s1">isAsync,</span><span class="s3">\n  </span><span class="s1">onFirstPause,</span><span class="s3">\n  </span><span class="s1">waitFor,</span><span class="s3">\n  </span><span class="s1">isThenable,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">../gensync-utils/async.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { isIterableIterator } from </span><span class="s3">\&quot;</span><span class="s1">./util.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export type { CacheConfigurator };</span><span class="s3">\n\n</span><span class="s1">export type SimpleCacheConfigurator = {</span><span class="s3">\n  </span><span class="s1">(forever: boolean): void;</span><span class="s3">\n  </span><span class="s1">&lt;T&gt;(handler: () =&gt; T): T;</span><span class="s3">\n\n  </span><span class="s1">forever: () =&gt; void;</span><span class="s3">\n  </span><span class="s1">never: () =&gt; void;</span><span class="s3">\n  </span><span class="s1">using: &lt;T&gt;(handler: () =&gt; T) =&gt; T;</span><span class="s3">\n  </span><span class="s1">invalidate: &lt;T&gt;(handler: () =&gt; T) =&gt; T;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export type CacheEntry&lt;ResultT, SideChannel&gt; = Array&lt;{</span><span class="s3">\n  </span><span class="s1">value: ResultT;</span><span class="s3">\n  </span><span class="s1">valid: (channel: SideChannel) =&gt; Handler&lt;boolean&gt;;</span><span class="s3">\n</span><span class="s1">}&gt;;</span><span class="s3">\n\n</span><span class="s1">const synchronize = &lt;ArgsT extends unknown[], ResultT&gt;(</span><span class="s3">\n  </span><span class="s1">gen: (...args: ArgsT) =&gt; Handler&lt;ResultT&gt;,</span><span class="s3">\n</span><span class="s1">): ((...args: ArgsT) =&gt; ResultT) =&gt; {</span><span class="s3">\n  </span><span class="s1">return gensync(gen).sync;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// eslint-disable-next-line require-yield</span><span class="s3">\n</span><span class="s1">function* genTrue() {</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function makeWeakCache&lt;ArgT extends object, ResultT, SideChannel&gt;(</span><span class="s3">\n  </span><span class="s1">handler: (</span><span class="s3">\n    </span><span class="s1">arg: ArgT,</span><span class="s3">\n    </span><span class="s1">cache: CacheConfigurator&lt;SideChannel&gt;,</span><span class="s3">\n  </span><span class="s1">) =&gt; Handler&lt;ResultT&gt; | ResultT,</span><span class="s3">\n</span><span class="s1">): (arg: ArgT, data: SideChannel) =&gt; Handler&lt;ResultT&gt; {</span><span class="s3">\n  </span><span class="s1">return makeCachedFunction&lt;ArgT, ResultT, SideChannel&gt;(WeakMap, handler);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function makeWeakCacheSync&lt;ArgT extends object, ResultT, SideChannel&gt;(</span><span class="s3">\n  </span><span class="s1">handler: (arg: ArgT, cache?: CacheConfigurator&lt;SideChannel&gt;) =&gt; ResultT,</span><span class="s3">\n</span><span class="s1">): (arg: ArgT, data?: SideChannel) =&gt; ResultT {</span><span class="s3">\n  </span><span class="s1">return synchronize&lt;[ArgT, SideChannel], ResultT&gt;(</span><span class="s3">\n    </span><span class="s1">makeWeakCache&lt;ArgT, ResultT, SideChannel&gt;(handler),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function makeStrongCache&lt;ArgT, ResultT, SideChannel&gt;(</span><span class="s3">\n  </span><span class="s1">handler: (</span><span class="s3">\n    </span><span class="s1">arg: ArgT,</span><span class="s3">\n    </span><span class="s1">cache: CacheConfigurator&lt;SideChannel&gt;,</span><span class="s3">\n  </span><span class="s1">) =&gt; Handler&lt;ResultT&gt; | ResultT,</span><span class="s3">\n</span><span class="s1">): (arg: ArgT, data: SideChannel) =&gt; Handler&lt;ResultT&gt; {</span><span class="s3">\n  </span><span class="s1">return makeCachedFunction&lt;ArgT, ResultT, SideChannel&gt;(Map, handler);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function makeStrongCacheSync&lt;ArgT, ResultT, SideChannel&gt;(</span><span class="s3">\n  </span><span class="s1">handler: (arg: ArgT, cache?: CacheConfigurator&lt;SideChannel&gt;) =&gt; ResultT,</span><span class="s3">\n</span><span class="s1">): (arg: ArgT, data?: SideChannel) =&gt; ResultT {</span><span class="s3">\n  </span><span class="s1">return synchronize&lt;[ArgT, SideChannel], ResultT&gt;(</span><span class="s3">\n    </span><span class="s1">makeStrongCache&lt;ArgT, ResultT, SideChannel&gt;(handler),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/* NOTE: Part of the logic explained in this comment is explained in the</span><span class="s3">\n </span><span class="s1">*       getCachedValueOrWait and setupAsyncLocks functions.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* &gt; There are only two hard things in Computer Science: cache invalidation and naming things.</span><span class="s3">\n </span><span class="s1">* &gt; -- Phil Karlton</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* I don't know if Phil was also thinking about handling a cache whose invalidation function is</span><span class="s3">\n </span><span class="s1">* defined asynchronously is considered, but it is REALLY hard to do correctly.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The implemented logic (only when gensync is run asynchronously) is the following:</span><span class="s3">\n </span><span class="s1">*   1. If there is a valid cache associated to the current </span><span class="s3">\&quot;</span><span class="s1">arg</span><span class="s3">\&quot; </span><span class="s1">parameter,</span><span class="s3">\n </span><span class="s1">*       a. RETURN the cached value</span><span class="s3">\n </span><span class="s1">*   3. If there is a FinishLock associated to the current </span><span class="s3">\&quot;</span><span class="s1">arg</span><span class="s3">\&quot; </span><span class="s1">parameter representing a valid cache,</span><span class="s3">\n </span><span class="s1">*       a. Wait for that lock to be released</span><span class="s3">\n </span><span class="s1">*       b. RETURN the value associated with that lock</span><span class="s3">\n </span><span class="s1">*   5. Start executing the function to be cached</span><span class="s3">\n </span><span class="s1">*       a. If it pauses on a promise, then</span><span class="s3">\n </span><span class="s1">*           i. Let FinishLock be a new lock</span><span class="s3">\n </span><span class="s1">*          ii. Store FinishLock as associated to the current </span><span class="s3">\&quot;</span><span class="s1">arg</span><span class="s3">\&quot; </span><span class="s1">parameter</span><span class="s3">\n </span><span class="s1">*         iii. Wait for the function to finish executing</span><span class="s3">\n </span><span class="s1">*          iv. Release FinishLock</span><span class="s3">\n </span><span class="s1">*           v. Send the function result to anyone waiting on FinishLock</span><span class="s3">\n </span><span class="s1">*   6. Store the result in the cache</span><span class="s3">\n </span><span class="s1">*   7. RETURN the result</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function makeCachedFunction&lt;ArgT, ResultT, SideChannel&gt;(</span><span class="s3">\n  </span><span class="s1">CallCache: new &lt;Cached&gt;() =&gt; CacheMap&lt;ArgT, Cached, SideChannel&gt;,</span><span class="s3">\n  </span><span class="s1">handler: (</span><span class="s3">\n    </span><span class="s1">arg: ArgT,</span><span class="s3">\n    </span><span class="s1">cache: CacheConfigurator&lt;SideChannel&gt;,</span><span class="s3">\n  </span><span class="s1">) =&gt; Handler&lt;ResultT&gt; | ResultT,</span><span class="s3">\n</span><span class="s1">): (arg: ArgT, data: SideChannel) =&gt; Handler&lt;ResultT&gt; {</span><span class="s3">\n  </span><span class="s1">const callCacheSync = new CallCache&lt;ResultT&gt;();</span><span class="s3">\n  </span><span class="s1">const callCacheAsync = new CallCache&lt;ResultT&gt;();</span><span class="s3">\n  </span><span class="s1">const futureCache = new CallCache&lt;Lock&lt;ResultT&gt;&gt;();</span><span class="s3">\n\n  </span><span class="s1">return function* cachedFunction(arg: ArgT, data: SideChannel) {</span><span class="s3">\n    </span><span class="s1">const asyncContext = yield* isAsync();</span><span class="s3">\n    </span><span class="s1">const callCache = asyncContext ? callCacheAsync : callCacheSync;</span><span class="s3">\n\n    </span><span class="s1">const cached = yield* getCachedValueOrWait&lt;ArgT, ResultT, SideChannel&gt;(</span><span class="s3">\n      </span><span class="s1">asyncContext,</span><span class="s3">\n      </span><span class="s1">callCache,</span><span class="s3">\n      </span><span class="s1">futureCache,</span><span class="s3">\n      </span><span class="s1">arg,</span><span class="s3">\n      </span><span class="s1">data,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (cached.valid) return cached.value;</span><span class="s3">\n\n    </span><span class="s1">const cache = new CacheConfigurator(data);</span><span class="s3">\n\n    </span><span class="s1">const handlerResult: Handler&lt;ResultT&gt; | ResultT = handler(arg, cache);</span><span class="s3">\n\n    </span><span class="s1">let finishLock: Lock&lt;ResultT&gt;;</span><span class="s3">\n    </span><span class="s1">let value: ResultT;</span><span class="s3">\n\n    </span><span class="s1">if (isIterableIterator(handlerResult)) {</span><span class="s3">\n      </span><span class="s1">value = yield* onFirstPause(handlerResult, () =&gt; {</span><span class="s3">\n        </span><span class="s1">finishLock = setupAsyncLocks(cache, futureCache, arg);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">value = handlerResult;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">updateFunctionCache(callCache, cache, arg, value);</span><span class="s3">\n\n    </span><span class="s1">if (finishLock) {</span><span class="s3">\n      </span><span class="s1">futureCache.delete(arg);</span><span class="s3">\n      </span><span class="s1">finishLock.release(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return value;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type CacheMap&lt;ArgT, ResultT, SideChannel&gt; =</span><span class="s3">\n  </span><span class="s1">| Map&lt;ArgT, CacheEntry&lt;ResultT, SideChannel&gt;&gt;</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): add `extends object` constraint to ArgT</span><span class="s3">\n  </span><span class="s1">| WeakMap&lt;ArgT, CacheEntry&lt;ResultT, SideChannel&gt;&gt;;</span><span class="s3">\n\n</span><span class="s1">function* getCachedValue&lt;ArgT, ResultT, SideChannel&gt;(</span><span class="s3">\n  </span><span class="s1">cache: CacheMap&lt;ArgT, ResultT, SideChannel&gt;,</span><span class="s3">\n  </span><span class="s1">arg: ArgT,</span><span class="s3">\n  </span><span class="s1">data: SideChannel,</span><span class="s3">\n</span><span class="s1">): Handler&lt;{ valid: true; value: ResultT } | { valid: false; value: null }&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedValue: CacheEntry&lt;ResultT, SideChannel&gt; | void = cache.get(arg);</span><span class="s3">\n\n  </span><span class="s1">if (cachedValue) {</span><span class="s3">\n    </span><span class="s1">for (const { value, valid } of cachedValue) {</span><span class="s3">\n      </span><span class="s1">if (yield* valid(data)) return { valid: true, value };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { valid: false, value: null };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function* getCachedValueOrWait&lt;ArgT, ResultT, SideChannel&gt;(</span><span class="s3">\n  </span><span class="s1">asyncContext: boolean,</span><span class="s3">\n  </span><span class="s1">callCache: CacheMap&lt;ArgT, ResultT, SideChannel&gt;,</span><span class="s3">\n  </span><span class="s1">futureCache: CacheMap&lt;ArgT, Lock&lt;ResultT&gt;, SideChannel&gt;,</span><span class="s3">\n  </span><span class="s1">arg: ArgT,</span><span class="s3">\n  </span><span class="s1">data: SideChannel,</span><span class="s3">\n</span><span class="s1">): Handler&lt;{ valid: true; value: ResultT } | { valid: false; value: null }&gt; {</span><span class="s3">\n  </span><span class="s1">const cached = yield* getCachedValue(callCache, arg, data);</span><span class="s3">\n  </span><span class="s1">if (cached.valid) {</span><span class="s3">\n    </span><span class="s1">return cached;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (asyncContext) {</span><span class="s3">\n    </span><span class="s1">const cached = yield* getCachedValue(futureCache, arg, data);</span><span class="s3">\n    </span><span class="s1">if (cached.valid) {</span><span class="s3">\n      </span><span class="s1">const value = yield* waitFor&lt;ResultT&gt;(cached.value.promise);</span><span class="s3">\n      </span><span class="s1">return { valid: true, value };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { valid: false, value: null };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function setupAsyncLocks&lt;ArgT, ResultT, SideChannel&gt;(</span><span class="s3">\n  </span><span class="s1">config: CacheConfigurator&lt;SideChannel&gt;,</span><span class="s3">\n  </span><span class="s1">futureCache: CacheMap&lt;ArgT, Lock&lt;ResultT&gt;, SideChannel&gt;,</span><span class="s3">\n  </span><span class="s1">arg: ArgT,</span><span class="s3">\n</span><span class="s1">): Lock&lt;ResultT&gt; {</span><span class="s3">\n  </span><span class="s1">const finishLock = new Lock&lt;ResultT&gt;();</span><span class="s3">\n\n  </span><span class="s1">updateFunctionCache(futureCache, config, arg, finishLock);</span><span class="s3">\n\n  </span><span class="s1">return finishLock;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function updateFunctionCache&lt;</span><span class="s3">\n  </span><span class="s1">ArgT,</span><span class="s3">\n  </span><span class="s1">ResultT,</span><span class="s3">\n  </span><span class="s1">SideChannel,</span><span class="s3">\n  </span><span class="s1">Cache extends CacheMap&lt;ArgT, ResultT, SideChannel&gt;,</span><span class="s3">\n</span><span class="s1">&gt;(</span><span class="s3">\n  </span><span class="s1">cache: Cache,</span><span class="s3">\n  </span><span class="s1">config: CacheConfigurator&lt;SideChannel&gt;,</span><span class="s3">\n  </span><span class="s1">arg: ArgT,</span><span class="s3">\n  </span><span class="s1">value: ResultT,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!config.configured()) config.forever();</span><span class="s3">\n\n  </span><span class="s1">let cachedValue: CacheEntry&lt;ResultT, SideChannel&gt; | void = cache.get(arg);</span><span class="s3">\n\n  </span><span class="s1">config.deactivate();</span><span class="s3">\n\n  </span><span class="s1">switch (config.mode()) {</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">forever</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">cachedValue = [{ value, valid: genTrue }];</span><span class="s3">\n      </span><span class="s1">cache.set(arg, cachedValue);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">invalidate</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">cachedValue = [{ value, valid: config.validator() }];</span><span class="s3">\n      </span><span class="s1">cache.set(arg, cachedValue);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">if (cachedValue) {</span><span class="s3">\n        </span><span class="s1">cachedValue.push({ value, valid: config.validator() });</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">cachedValue = [{ value, valid: config.validator() }];</span><span class="s3">\n        </span><span class="s1">cache.set(arg, cachedValue);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class CacheConfigurator&lt;SideChannel = void&gt; {</span><span class="s3">\n  </span><span class="s1">_active: boolean = true;</span><span class="s3">\n  </span><span class="s1">_never: boolean = false;</span><span class="s3">\n  </span><span class="s1">_forever: boolean = false;</span><span class="s3">\n  </span><span class="s1">_invalidate: boolean = false;</span><span class="s3">\n\n  </span><span class="s1">_configured: boolean = false;</span><span class="s3">\n\n  </span><span class="s1">_pairs: Array&lt;</span><span class="s3">\n    </span><span class="s1">[cachedValue: unknown, handler: (data: SideChannel) =&gt; Handler&lt;unknown&gt;]</span><span class="s3">\n  </span><span class="s1">&gt; = [];</span><span class="s3">\n\n  </span><span class="s1">_data: SideChannel;</span><span class="s3">\n\n  </span><span class="s1">constructor(data: SideChannel) {</span><span class="s3">\n    </span><span class="s1">this._data = data;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">simple() {</span><span class="s3">\n    </span><span class="s1">return makeSimpleConfigurator(this);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">mode() {</span><span class="s3">\n    </span><span class="s1">if (this._never) return </span><span class="s3">\&quot;</span><span class="s1">never</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">if (this._forever) return </span><span class="s3">\&quot;</span><span class="s1">forever</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">if (this._invalidate) return </span><span class="s3">\&quot;</span><span class="s1">invalidate</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">forever() {</span><span class="s3">\n    </span><span class="s1">if (!this._active) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Cannot change caching after evaluation has completed.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this._never) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Caching has already been configured with .never()</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._forever = true;</span><span class="s3">\n    </span><span class="s1">this._configured = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">never() {</span><span class="s3">\n    </span><span class="s1">if (!this._active) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Cannot change caching after evaluation has completed.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this._forever) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Caching has already been configured with .forever()</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._never = true;</span><span class="s3">\n    </span><span class="s1">this._configured = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">using&lt;T&gt;(handler: (data: SideChannel) =&gt; T): T {</span><span class="s3">\n    </span><span class="s1">if (!this._active) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Cannot change caching after evaluation has completed.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this._never || this._forever) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        \&quot;</span><span class="s1">Caching has already been configured with .never or .forever()</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._configured = true;</span><span class="s3">\n\n    </span><span class="s1">const key = handler(this._data);</span><span class="s3">\n\n    </span><span class="s1">const fn = maybeAsync(</span><span class="s3">\n      </span><span class="s1">handler,</span><span class="s3">\n      </span><span class="s1">`You appear to be using an async cache handler, but Babel has been called synchronously`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (isThenable(key)) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): improve function return type annotation</span><span class="s3">\n      </span><span class="s1">return key.then((key: unknown) =&gt; {</span><span class="s3">\n        </span><span class="s1">this._pairs.push([key, fn]);</span><span class="s3">\n        </span><span class="s1">return key;</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._pairs.push([key, fn]);</span><span class="s3">\n    </span><span class="s1">return key;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">invalidate&lt;T&gt;(handler: (data: SideChannel) =&gt; T): T {</span><span class="s3">\n    </span><span class="s1">this._invalidate = true;</span><span class="s3">\n    </span><span class="s1">return this.using(handler);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">validator(): (data: SideChannel) =&gt; Handler&lt;boolean&gt; {</span><span class="s3">\n    </span><span class="s1">const pairs = this._pairs;</span><span class="s3">\n    </span><span class="s1">return function* (data: SideChannel) {</span><span class="s3">\n      </span><span class="s1">for (const [key, fn] of pairs) {</span><span class="s3">\n        </span><span class="s1">if (key !== (yield* fn(data))) return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">deactivate() {</span><span class="s3">\n    </span><span class="s1">this._active = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">configured() {</span><span class="s3">\n    </span><span class="s1">return this._configured;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function makeSimpleConfigurator(</span><span class="s3">\n  </span><span class="s1">cache: CacheConfigurator&lt;any&gt;,</span><span class="s3">\n</span><span class="s1">): SimpleCacheConfigurator {</span><span class="s3">\n  </span><span class="s1">function cacheFn(val: any) {</span><span class="s3">\n    </span><span class="s1">if (typeof val === </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (val) cache.forever();</span><span class="s3">\n      </span><span class="s1">else cache.never();</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return cache.using(() =&gt; assertSimpleType(val()));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">cacheFn.forever = () =&gt; cache.forever();</span><span class="s3">\n  </span><span class="s1">cacheFn.never = () =&gt; cache.never();</span><span class="s3">\n  </span><span class="s1">cacheFn.using = (cb: { (): SimpleType }) =&gt;</span><span class="s3">\n    </span><span class="s1">cache.using(() =&gt; assertSimpleType(cb()));</span><span class="s3">\n  </span><span class="s1">cacheFn.invalidate = (cb: { (): SimpleType }) =&gt;</span><span class="s3">\n    </span><span class="s1">cache.invalidate(() =&gt; assertSimpleType(cb()));</span><span class="s3">\n\n  </span><span class="s1">return cacheFn as any;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Types are limited here so that in the future these values can be used</span><span class="s3">\n</span><span class="s1">// as part of Babel's caching logic.</span><span class="s3">\n</span><span class="s1">export type SimpleType =</span><span class="s3">\n  </span><span class="s1">| string</span><span class="s3">\n  </span><span class="s1">| boolean</span><span class="s3">\n  </span><span class="s1">| number</span><span class="s3">\n  </span><span class="s1">| null</span><span class="s3">\n  </span><span class="s1">| void</span><span class="s3">\n  </span><span class="s1">| Promise&lt;SimpleType&gt;;</span><span class="s3">\n</span><span class="s1">export function assertSimpleType(value: unknown): SimpleType {</span><span class="s3">\n  </span><span class="s1">if (isThenable(value)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`You appear to be using an async cache handler, ` +</span><span class="s3">\n        </span><span class="s1">`which your current version of Babel does not support. ` +</span><span class="s3">\n        </span><span class="s1">`We may add support for this in the future, ` +</span><span class="s3">\n        </span><span class="s1">`but if you're on the most recent version of @babel/core and still ` +</span><span class="s3">\n        </span><span class="s1">`seeing this error, then you'll need to synchronously handle your caching logic.`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">value != null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof value !== </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof value !== </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof value !== </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">Cache keys must be either string, boolean, number, null, or undefined.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error Type 'unknown' is not assignable to type 'SimpleType'. This can be removed</span><span class="s3">\n  </span><span class="s1">// when strictNullCheck is enabled</span><span class="s3">\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class Lock&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">released: boolean = false;</span><span class="s3">\n  </span><span class="s1">promise: Promise&lt;T&gt;;</span><span class="s3">\n  </span><span class="s1">_resolve: (value: T) =&gt; void;</span><span class="s3">\n\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">this.promise = new Promise(resolve =&gt; {</span><span class="s3">\n      </span><span class="s1">this._resolve = resolve;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">release(value: T) {</span><span class="s3">\n    </span><span class="s1">this.released = true;</span><span class="s3">\n    </span><span class="s1">this._resolve(value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>