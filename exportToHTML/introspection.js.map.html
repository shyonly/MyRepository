<html>
<head>
<title>introspection.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
introspection.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;STATEMENT_OR_BLOCK_KEYS&quot;</span><span class="s0">,</span><span class="s1">&quot;VISITOR_KEYS&quot;</span><span class="s0">,</span><span class="s1">&quot;isBlockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isStringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isType&quot;</span><span class="s0">,</span><span class="s1">&quot;matchesPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;_matchesPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;allowPartial&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;is&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;isnt&quot;</span><span class="s0">,</span><span class="s1">&quot;equals&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;isNodeType&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;canHaveVariableDeclarationOrExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isFor&quot;</span><span class="s0">,</span><span class="s1">&quot;canSwapBetweenExpressionAndStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;replacement&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isCompletionRecord&quot;</span><span class="s0">,</span><span class="s1">&quot;allowInsideFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;first&quot;</span><span class="s0">,</span><span class="s1">&quot;container&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;isProgram&quot;</span><span class="s0">,</span><span class="s1">&quot;isDoExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatementOrBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;isLabeledStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;referencesImport&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleSource&quot;</span><span class="s0">,</span><span class="s1">&quot;importName&quot;</span><span class="s0">,</span><span class="s1">&quot;isReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptionalMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;binding&quot;</span><span class="s0">,</span><span class="s1">&quot;getBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;isImportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;isImportDefaultSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isImportNamespaceSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isImportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;imported&quot;</span><span class="s0">,</span><span class="s1">&quot;getSource&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;hub&quot;</span><span class="s0">,</span><span class="s1">&quot;getCode&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;willIMaybeExecuteBefore&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;_guessExecutionStatusRelativeTo&quot;</span><span class="s0">,</span><span class="s1">&quot;getOuterFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;getFunctionParent&quot;</span><span class="s0">,</span><span class="s1">&quot;getProgramParent&quot;</span><span class="s0">,</span><span class="s1">&quot;isExecutionUncertain&quot;</span><span class="s0">,</span><span class="s1">&quot;isExecutionUncertainInList&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;maxIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;parentKey&quot;</span><span class="s0">,</span><span class="s1">&quot;SYMBOL_CHECKING&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;_guessExecutionStatusRelativeToCached&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;base&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;funcParent&quot;</span><span class="s0">,</span><span class="s1">&quot;this&quot;</span><span class="s0">,</span><span class="s1">&quot;_guessExecutionStatusRelativeToDifferentFunctionsCached&quot;</span><span class="s0">,</span><span class="s1">&quot;getAncestry&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;commonPath&quot;</span><span class="s0">,</span><span class="s1">&quot;commonIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;divergence&quot;</span><span class="s0">,</span><span class="s1">&quot;listKey&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;keyPosition&quot;</span><span class="s0">,</span><span class="s1">&quot;_guessExecutionStatusRelativeToDifferentFunctionsInternal&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;references&quot;</span><span class="s0">,</span><span class="s1">&quot;referencePaths&quot;</span><span class="s0">,</span><span class="s1">&quot;allStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;childOfFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeMap&quot;</span><span class="s0">,</span><span class="s1">&quot;cached&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;dangerous&quot;</span><span class="s0">,</span><span class="s1">&quot;resolved&quot;</span><span class="s0">,</span><span class="s1">&quot;_resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;constant&quot;</span><span class="s0">,</span><span class="s1">&quot;ret&quot;</span><span class="s0">,</span><span class="s1">&quot;isTypeCastExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;targetKey&quot;</span><span class="s0">,</span><span class="s1">&quot;toComputedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;targetName&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;isProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrayExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isNaN&quot;</span><span class="s0">,</span><span class="s1">&quot;elems&quot;</span><span class="s0">,</span><span class="s1">&quot;elem&quot;</span><span class="s0">,</span><span class="s1">&quot;isConstantExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isRegExpLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isTemplateLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;isBinaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isInStrictMode&quot;</span><span class="s0">,</span><span class="s1">&quot;strictParent&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceType&quot;</span><span class="s0">,</span><span class="s1">&quot;isClass&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;directive&quot;</span><span class="s0">,</span><span class="s1">&quot;directives&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/path/introspection.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// This file contains methods responsible for introspecting the current path for certain values.</span><span class="s3">\n\n</span><span class="s1">import type NodePath from </span><span class="s3">\&quot;</span><span class="s1">./index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">STATEMENT_OR_BLOCK_KEYS,</span><span class="s3">\n  </span><span class="s1">VISITOR_KEYS,</span><span class="s3">\n  </span><span class="s1">isBlockStatement,</span><span class="s3">\n  </span><span class="s1">isExpression,</span><span class="s3">\n  </span><span class="s1">isIdentifier,</span><span class="s3">\n  </span><span class="s1">isLiteral,</span><span class="s3">\n  </span><span class="s1">isStringLiteral,</span><span class="s3">\n  </span><span class="s1">isType,</span><span class="s3">\n  </span><span class="s1">matchesPattern as _matchesPattern,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Match the current node if it matches the provided `pattern`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* For example, given the match `React.createClass` it would match the</span><span class="s3">\n </span><span class="s1">* parsed nodes of `React.createClass` and `React[</span><span class="s3">\&quot;</span><span class="s1">createClass</span><span class="s3">\&quot;</span><span class="s1">]`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function matchesPattern(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">pattern: string,</span><span class="s3">\n  </span><span class="s1">allowPartial?: boolean,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return _matchesPattern(this.node, pattern, allowPartial);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check whether we have the input `key`. If the `key` references an array then we check</span><span class="s3">\n </span><span class="s1">* if the array has any items, otherwise we just check if it's falsy.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function has&lt;N extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;N&gt;,</span><span class="s3">\n  </span><span class="s1">key: keyof N,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const val = this.node &amp;&amp; this.node[key];</span><span class="s3">\n  </span><span class="s1">if (val &amp;&amp; Array.isArray(val)) {</span><span class="s3">\n    </span><span class="s1">return !!val.length;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return !!val;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Description</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function isStatic(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">return this.scope.isStatic(this.node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Alias of `has`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export const is = has;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Opposite of `has`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function isnt&lt;N extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;N&gt;,</span><span class="s3">\n  </span><span class="s1">key: keyof N,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return !this.has(key);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check whether the path node `key` strict equals `value`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function equals&lt;N extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;N&gt;,</span><span class="s3">\n  </span><span class="s1">key: keyof N,</span><span class="s3">\n  </span><span class="s1">value: any,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return this.node[key] === value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check the type against our stored internal type of the node. This is handy when a node has</span><span class="s3">\n </span><span class="s1">* been removed yet we still internally know the type and need it to calculate node replacement.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function isNodeType(this: NodePath, type: string): boolean {</span><span class="s3">\n  </span><span class="s1">return isType(this.type, type);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This checks whether or not we're in one of the following positions:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   for (KEY in right);</span><span class="s3">\n </span><span class="s1">*   for (KEY;;);</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This is because these spots allow VariableDeclarations AND normal expressions so we need</span><span class="s3">\n </span><span class="s1">* to tell the path replacement that it's ok to replace this with an expression.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function canHaveVariableDeclarationOrExpression(this: NodePath) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">(this.key === </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot; </span><span class="s1">|| this.key === </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; this.parentPath.isFor()</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This checks whether we are swapping an arrow function's body between an</span><span class="s3">\n </span><span class="s1">* expression and a block statement (or vice versa).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This is because arrow functions may implicitly return an expression, which</span><span class="s3">\n </span><span class="s1">* is the same as containing a block statement.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function canSwapBetweenExpressionAndStatement(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">replacement: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">if (this.key !== </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot; </span><span class="s1">|| !this.parentPath.isArrowFunctionExpression()) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.isExpression()) {</span><span class="s3">\n    </span><span class="s1">return isBlockStatement(replacement);</span><span class="s3">\n  </span><span class="s1">} else if (this.isBlockStatement()) {</span><span class="s3">\n    </span><span class="s1">return isExpression(replacement);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check whether the current path references a completion record</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function isCompletionRecord(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">allowInsideFunction?: boolean,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">let path = this;</span><span class="s3">\n  </span><span class="s1">let first = true;</span><span class="s3">\n\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">const { type, container } = path;</span><span class="s3">\n\n    </span><span class="s1">// we're in a function so can't be a completion record</span><span class="s3">\n    </span><span class="s1">if (!first &amp;&amp; (path.isFunction() || type === </span><span class="s3">\&quot;</span><span class="s1">StaticBlock</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">return !!allowInsideFunction;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">first = false;</span><span class="s3">\n\n    </span><span class="s1">// check to see if we're the last item in the container and if we are</span><span class="s3">\n    </span><span class="s1">// we're a completion record!</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(container) &amp;&amp; path.key !== container.length - 1) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} while (</span><span class="s3">\n    </span><span class="s1">(path = path.parentPath) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!path.isProgram() &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!path.isDoExpression()</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check whether or not the current `key` allows either a single statement or block statement</span><span class="s3">\n </span><span class="s1">* so we can explode it if necessary.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function isStatementOrBlock(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">this.parentPath.isLabeledStatement() ||</span><span class="s3">\n    </span><span class="s1">isBlockStatement(this.container as t.Node)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return STATEMENT_OR_BLOCK_KEYS.includes(this.key as string);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check if the currently assigned path references the `importName` of `moduleSource`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function referencesImport(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">moduleSource: string,</span><span class="s3">\n  </span><span class="s1">importName: string,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">if (!this.isReferencedIdentifier()) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(this.isJSXMemberExpression() &amp;&amp;</span><span class="s3">\n        </span><span class="s1">this.node.property.name === importName) ||</span><span class="s3">\n      </span><span class="s1">((this.isMemberExpression() || this.isOptionalMemberExpression()) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(this.node.computed</span><span class="s3">\n          </span><span class="s1">? isStringLiteral(this.node.property, { value: importName })</span><span class="s3">\n          </span><span class="s1">: (this.node.property as t.Identifier).name === importName))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const object = (</span><span class="s3">\n        </span><span class="s1">this as NodePath&lt;t.MemberExpression | t.OptionalMemberExpression&gt;</span><span class="s3">\n      </span><span class="s1">).get(</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">object.isReferencedIdentifier() &amp;&amp;</span><span class="s3">\n        </span><span class="s1">object.referencesImport(moduleSource, </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const binding = this.scope.getBinding((this.node as t.Identifier).name);</span><span class="s3">\n  </span><span class="s1">if (!binding || binding.kind !== </span><span class="s3">\&quot;</span><span class="s1">module</span><span class="s3">\&quot;</span><span class="s1">) return false;</span><span class="s3">\n\n  </span><span class="s1">const path = binding.path;</span><span class="s3">\n  </span><span class="s1">const parent = path.parentPath;</span><span class="s3">\n  </span><span class="s1">if (!parent.isImportDeclaration()) return false;</span><span class="s3">\n\n  </span><span class="s1">// check moduleSource</span><span class="s3">\n  </span><span class="s1">if (parent.node.source.value === moduleSource) {</span><span class="s3">\n    </span><span class="s1">if (!importName) return true;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (path.isImportDefaultSpecifier() &amp;&amp; importName === </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (path.isImportNamespaceSpecifier() &amp;&amp; importName === </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">path.isImportSpecifier() &amp;&amp;</span><span class="s3">\n    </span><span class="s1">isIdentifier(path.node.imported, { name: importName })</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the source code associated with this node.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function getSource(this: NodePath): string {</span><span class="s3">\n  </span><span class="s1">const node = this.node;</span><span class="s3">\n  </span><span class="s1">if (node.end) {</span><span class="s3">\n    </span><span class="s1">const code = this.hub.getCode();</span><span class="s3">\n    </span><span class="s1">if (code) return code.slice(node.start, node.end);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function willIMaybeExecuteBefore(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">target: NodePath,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return this._guessExecutionStatusRelativeTo(target) !== </span><span class="s3">\&quot;</span><span class="s1">after</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getOuterFunction(path: NodePath) {</span><span class="s3">\n  </span><span class="s1">return path.isProgram()</span><span class="s3">\n    </span><span class="s1">? path</span><span class="s3">\n    </span><span class="s1">: (</span><span class="s3">\n        </span><span class="s1">path.parentPath.scope.getFunctionParent() ||</span><span class="s3">\n        </span><span class="s1">path.parentPath.scope.getProgramParent()</span><span class="s3">\n      </span><span class="s1">).path;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isExecutionUncertain(type: t.Node[</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">], key: string) {</span><span class="s3">\n  </span><span class="s1">switch (type) {</span><span class="s3">\n    </span><span class="s1">// a &amp;&amp; FOO</span><span class="s3">\n    </span><span class="s1">// a || FOO</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">LogicalExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return key === </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">// a ? FOO : FOO</span><span class="s3">\n    </span><span class="s1">// if (a) FOO; else FOO;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ConditionalExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">IfStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return key === </span><span class="s3">\&quot;</span><span class="s1">consequent</span><span class="s3">\&quot; </span><span class="s1">|| key === </span><span class="s3">\&quot;</span><span class="s1">alternate</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">// while (a) FOO;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">WhileStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">DoWhileStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ForInStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ForOfStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return key === </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">// for (a; b; FOO) FOO;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ForStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return key === </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot; </span><span class="s1">|| key === </span><span class="s3">\&quot;</span><span class="s1">update</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">// switch (a) { FOO }</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">SwitchStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return key === </span><span class="s3">\&quot;</span><span class="s1">cases</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">// try { a } catch FOO finally { b }</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TryStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return key === </span><span class="s3">\&quot;</span><span class="s1">handler</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">// var [ x = FOO ]</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return key === </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">// a?.[FOO]</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">OptionalMemberExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return key === </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">// a?.(FOO)</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">OptionalCallExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return key === </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isExecutionUncertainInList(paths: NodePath[], maxIndex: number) {</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; maxIndex; i++) {</span><span class="s3">\n    </span><span class="s1">const path = paths[i];</span><span class="s3">\n    </span><span class="s1">if (isExecutionUncertain(path.parent.type, path.parentKey)) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// TODO(Babel 8)</span><span class="s3">\n</span><span class="s1">// This can be { before: boolean, after: boolean, unknown: boolean }.</span><span class="s3">\n</span><span class="s1">// This allows transforms like the tdz one to treat cases when the status</span><span class="s3">\n</span><span class="s1">// is both before and unknown/after like if it were before.</span><span class="s3">\n</span><span class="s1">type RelativeExecutionStatus = </span><span class="s3">\&quot;</span><span class="s1">before</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">after</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">unknown</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// Used to avoid infinite recursion in cases like</span><span class="s3">\n</span><span class="s1">//   function f() { if (false) f(); }</span><span class="s3">\n</span><span class="s1">//   f();</span><span class="s3">\n</span><span class="s1">// It also works with indirect recursion.</span><span class="s3">\n</span><span class="s1">const SYMBOL_CHECKING = Symbol();</span><span class="s3">\n\n</span><span class="s1">type ExecutionStatusCache = Map&lt;</span><span class="s3">\n  </span><span class="s1">t.Node,</span><span class="s3">\n  </span><span class="s1">Map&lt;t.Node, RelativeExecutionStatus | typeof SYMBOL_CHECKING&gt;</span><span class="s3">\n</span><span class="s1">&gt;;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Given a `target` check the execution status of it relative to the current path.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">Execution status</span><span class="s3">\&quot; </span><span class="s1">simply refers to where or not we **think** this will execute</span><span class="s3">\n </span><span class="s1">* before or after the input `target` element.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function _guessExecutionStatusRelativeTo(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">target: NodePath,</span><span class="s3">\n</span><span class="s1">): RelativeExecutionStatus {</span><span class="s3">\n  </span><span class="s1">return _guessExecutionStatusRelativeToCached(this, target, new Map());</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function _guessExecutionStatusRelativeToCached(</span><span class="s3">\n  </span><span class="s1">base: NodePath,</span><span class="s3">\n  </span><span class="s1">target: NodePath,</span><span class="s3">\n  </span><span class="s1">cache: ExecutionStatusCache,</span><span class="s3">\n</span><span class="s1">): RelativeExecutionStatus {</span><span class="s3">\n  </span><span class="s1">// check if the two paths are in different functions, we can't track execution of these</span><span class="s3">\n  </span><span class="s1">const funcParent = {</span><span class="s3">\n    </span><span class="s1">this: getOuterFunction(base),</span><span class="s3">\n    </span><span class="s1">target: getOuterFunction(target),</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// here we check the `node` equality as sometimes we may have different paths for the</span><span class="s3">\n  </span><span class="s1">// same node due to path thrashing</span><span class="s3">\n  </span><span class="s1">if (funcParent.target.node !== funcParent.this.node) {</span><span class="s3">\n    </span><span class="s1">return _guessExecutionStatusRelativeToDifferentFunctionsCached(</span><span class="s3">\n      </span><span class="s1">base,</span><span class="s3">\n      </span><span class="s1">funcParent.target,</span><span class="s3">\n      </span><span class="s1">cache,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const paths = {</span><span class="s3">\n    </span><span class="s1">target: target.getAncestry(),</span><span class="s3">\n    </span><span class="s1">this: base.getAncestry(),</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// If this is an ancestor of the target path,</span><span class="s3">\n  </span><span class="s1">// e.g. f(g); where this is f and target is g.</span><span class="s3">\n  </span><span class="s1">if (paths.target.indexOf(base) &gt;= 0) return </span><span class="s3">\&quot;</span><span class="s1">after</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">if (paths.this.indexOf(target) &gt;= 0) return </span><span class="s3">\&quot;</span><span class="s1">before</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n  </span><span class="s1">// get ancestor where the branches intersect</span><span class="s3">\n  </span><span class="s1">let commonPath;</span><span class="s3">\n  </span><span class="s1">const commonIndex = { target: 0, this: 0 };</span><span class="s3">\n\n  </span><span class="s1">while (!commonPath &amp;&amp; commonIndex.this &lt; paths.this.length) {</span><span class="s3">\n    </span><span class="s1">const path = paths.this[commonIndex.this];</span><span class="s3">\n    </span><span class="s1">commonIndex.target = paths.target.indexOf(path);</span><span class="s3">\n    </span><span class="s1">if (commonIndex.target &gt;= 0) {</span><span class="s3">\n      </span><span class="s1">commonPath = path;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">commonIndex.this++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!commonPath) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">Internal Babel error - The two compared nodes</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        \&quot; </span><span class="s1">don't appear to belong to the same program.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">isExecutionUncertainInList(paths.this, commonIndex.this - 1) ||</span><span class="s3">\n    </span><span class="s1">isExecutionUncertainInList(paths.target, commonIndex.target - 1)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">unknown</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const divergence = {</span><span class="s3">\n    </span><span class="s1">this: paths.this[commonIndex.this - 1],</span><span class="s3">\n    </span><span class="s1">target: paths.target[commonIndex.target - 1],</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// container list so let's see which one is after the other</span><span class="s3">\n  </span><span class="s1">// e.g. [ THIS, TARGET ]</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">divergence.target.listKey &amp;&amp;</span><span class="s3">\n    </span><span class="s1">divergence.this.listKey &amp;&amp;</span><span class="s3">\n    </span><span class="s1">divergence.target.container === divergence.this.container</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return divergence.target.key &gt; divergence.this.key ? </span><span class="s3">\&quot;</span><span class="s1">before</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">after</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// otherwise we're associated by a parent node, check which key comes before the other</span><span class="s3">\n  </span><span class="s1">const keys = VISITOR_KEYS[commonPath.type];</span><span class="s3">\n  </span><span class="s1">const keyPosition = {</span><span class="s3">\n    </span><span class="s1">this: keys.indexOf(divergence.this.parentKey),</span><span class="s3">\n    </span><span class="s1">target: keys.indexOf(divergence.target.parentKey),</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return keyPosition.target &gt; keyPosition.this ? </span><span class="s3">\&quot;</span><span class="s1">before</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">after</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function _guessExecutionStatusRelativeToDifferentFunctionsInternal(</span><span class="s3">\n  </span><span class="s1">base: NodePath,</span><span class="s3">\n  </span><span class="s1">target: NodePath,</span><span class="s3">\n  </span><span class="s1">cache: ExecutionStatusCache,</span><span class="s3">\n</span><span class="s1">): RelativeExecutionStatus {</span><span class="s3">\n  </span><span class="s1">if (!target.isFunctionDeclaration()) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">_guessExecutionStatusRelativeToCached(base, target, cache) === </span><span class="s3">\&quot;</span><span class="s1">before</span><span class="s3">\&quot;\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">before</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">unknown</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">} else if (target.parentPath.isExportDeclaration()) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">unknown</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// so we're in a completely different function, if this is a function declaration</span><span class="s3">\n  </span><span class="s1">// then we can be a bit smarter and handle cases where the function is either</span><span class="s3">\n  </span><span class="s1">// a. not called at all (part of an export)</span><span class="s3">\n  </span><span class="s1">// b. called directly</span><span class="s3">\n  </span><span class="s1">const binding = target.scope.getBinding(target.node.id.name);</span><span class="s3">\n\n  </span><span class="s1">// no references!</span><span class="s3">\n  </span><span class="s1">if (!binding.references) return </span><span class="s3">\&quot;</span><span class="s1">before</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n  </span><span class="s1">const referencePaths: Array&lt;NodePath&gt; = binding.referencePaths;</span><span class="s3">\n\n  </span><span class="s1">let allStatus;</span><span class="s3">\n\n  </span><span class="s1">// verify that all the calls have the same execution status</span><span class="s3">\n  </span><span class="s1">for (const path of referencePaths) {</span><span class="s3">\n    </span><span class="s1">// if a reference is a child of the function we're checking against then we can</span><span class="s3">\n    </span><span class="s1">// safely ignore it</span><span class="s3">\n    </span><span class="s1">const childOfFunction = !!path.find(path =&gt; path.node === target.node);</span><span class="s3">\n    </span><span class="s1">if (childOfFunction) continue;</span><span class="s3">\n\n    </span><span class="s1">if (path.key !== </span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot; </span><span class="s1">|| !path.parentPath.isCallExpression()) {</span><span class="s3">\n      </span><span class="s1">// This function is passed as a reference, so we don't</span><span class="s3">\n      </span><span class="s1">// know when it will be called.</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">unknown</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const status = _guessExecutionStatusRelativeToCached(base, path, cache);</span><span class="s3">\n\n    </span><span class="s1">if (allStatus &amp;&amp; allStatus !== status) {</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">unknown</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">allStatus = status;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return allStatus;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function _guessExecutionStatusRelativeToDifferentFunctionsCached(</span><span class="s3">\n  </span><span class="s1">base: NodePath,</span><span class="s3">\n  </span><span class="s1">target: NodePath,</span><span class="s3">\n  </span><span class="s1">cache: ExecutionStatusCache,</span><span class="s3">\n</span><span class="s1">): RelativeExecutionStatus {</span><span class="s3">\n  </span><span class="s1">let nodeMap = cache.get(base.node);</span><span class="s3">\n  </span><span class="s1">let cached;</span><span class="s3">\n\n  </span><span class="s1">if (!nodeMap) {</span><span class="s3">\n    </span><span class="s1">cache.set(base.node, (nodeMap = new Map()));</span><span class="s3">\n  </span><span class="s1">} else if ((cached = nodeMap.get(target.node))) {</span><span class="s3">\n    </span><span class="s1">if (cached === SYMBOL_CHECKING) {</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">unknown</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return cached;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">nodeMap.set(target.node, SYMBOL_CHECKING);</span><span class="s3">\n\n  </span><span class="s1">const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(</span><span class="s3">\n    </span><span class="s1">base,</span><span class="s3">\n    </span><span class="s1">target,</span><span class="s3">\n    </span><span class="s1">cache,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">nodeMap.set(target.node, result);</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Resolve a </span><span class="s3">\&quot;</span><span class="s1">pointer</span><span class="s3">\&quot; </span><span class="s1">`NodePath` to it's absolute path.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function resolve(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">dangerous?: boolean,</span><span class="s3">\n  </span><span class="s1">resolved?: NodePath[],</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return this._resolve(dangerous, resolved) || this;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _resolve(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">dangerous?: boolean,</span><span class="s3">\n  </span><span class="s1">resolved?: NodePath[],</span><span class="s3">\n</span><span class="s1">): NodePath | undefined | null {</span><span class="s3">\n  </span><span class="s1">// detect infinite recursion</span><span class="s3">\n  </span><span class="s1">// todo: possibly have a max length on this just to be safe</span><span class="s3">\n  </span><span class="s1">if (resolved &amp;&amp; resolved.indexOf(this) &gt;= 0) return;</span><span class="s3">\n\n  </span><span class="s1">// we store all the paths we've </span><span class="s3">\&quot;</span><span class="s1">resolved</span><span class="s3">\&quot; </span><span class="s1">in this array to prevent infinite recursion</span><span class="s3">\n  </span><span class="s1">resolved = resolved || [];</span><span class="s3">\n  </span><span class="s1">resolved.push(this);</span><span class="s3">\n\n  </span><span class="s1">if (this.isVariableDeclarator()) {</span><span class="s3">\n    </span><span class="s1">if (this.get(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">).isIdentifier()) {</span><span class="s3">\n      </span><span class="s1">return this.get(</span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">).resolve(dangerous, resolved);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// otherwise it's a request for a pattern and that's a bit more tricky</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (this.isReferencedIdentifier()) {</span><span class="s3">\n    </span><span class="s1">const binding = this.scope.getBinding(this.node.name);</span><span class="s3">\n    </span><span class="s1">if (!binding) return;</span><span class="s3">\n\n    </span><span class="s1">// reassigned so we can't really resolve it</span><span class="s3">\n    </span><span class="s1">if (!binding.constant) return;</span><span class="s3">\n\n    </span><span class="s1">// todo - lookup module in dependency graph</span><span class="s3">\n    </span><span class="s1">if (binding.kind === </span><span class="s3">\&quot;</span><span class="s1">module</span><span class="s3">\&quot;</span><span class="s1">) return;</span><span class="s3">\n\n    </span><span class="s1">if (binding.path !== this) {</span><span class="s3">\n      </span><span class="s1">const ret = binding.path.resolve(dangerous, resolved);</span><span class="s3">\n      </span><span class="s1">// If the identifier resolves to parent node then we can't really resolve it.</span><span class="s3">\n      </span><span class="s1">if (this.find(parent =&gt; parent.node === ret.node)) return;</span><span class="s3">\n      </span><span class="s1">return ret;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (this.isTypeCastExpression()) {</span><span class="s3">\n    </span><span class="s1">// @ ts-ignore todo: babel-types</span><span class="s3">\n    </span><span class="s1">return this.get(</span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">).resolve(dangerous, resolved);</span><span class="s3">\n  </span><span class="s1">} else if (dangerous &amp;&amp; this.isMemberExpression()) {</span><span class="s3">\n    </span><span class="s1">// this is dangerous, as non-direct target assignments will mutate it's state</span><span class="s3">\n    </span><span class="s1">// making this resolution inaccurate</span><span class="s3">\n\n    </span><span class="s1">const targetKey = this.toComputedKey();</span><span class="s3">\n    </span><span class="s1">if (!isLiteral(targetKey)) return;</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): NullLiteral</span><span class="s3">\n    </span><span class="s1">const targetName = targetKey.value;</span><span class="s3">\n\n    </span><span class="s1">const target = this.get(</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">).resolve(dangerous, resolved);</span><span class="s3">\n\n    </span><span class="s1">if (target.isObjectExpression()) {</span><span class="s3">\n      </span><span class="s1">const props = target.get(</span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">for (const prop of props as any[]) {</span><span class="s3">\n        </span><span class="s1">if (!prop.isProperty()) continue;</span><span class="s3">\n\n        </span><span class="s1">const key = prop.get(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">// { foo: obj }</span><span class="s3">\n        </span><span class="s1">let match =</span><span class="s3">\n          </span><span class="s1">prop.isnt(</span><span class="s3">\&quot;</span><span class="s1">computed</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; key.isIdentifier({ name: targetName });</span><span class="s3">\n\n        </span><span class="s1">// { </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">obj</span><span class="s3">\&quot; </span><span class="s1">} or { [</span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">]: </span><span class="s3">\&quot;</span><span class="s1">obj</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">match = match || key.isLiteral({ value: targetName });</span><span class="s3">\n\n        </span><span class="s1">if (match) return prop.get(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">).resolve(dangerous, resolved);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (target.isArrayExpression() &amp;&amp; !isNaN(+targetName)) {</span><span class="s3">\n      </span><span class="s1">const elems = target.get(</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const elem = elems[targetName];</span><span class="s3">\n      </span><span class="s1">if (elem) return elem.resolve(dangerous, resolved);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isConstantExpression(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">if (this.isIdentifier()) {</span><span class="s3">\n    </span><span class="s1">const binding = this.scope.getBinding(this.node.name);</span><span class="s3">\n    </span><span class="s1">if (!binding) return false;</span><span class="s3">\n    </span><span class="s1">return binding.constant;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.isLiteral()) {</span><span class="s3">\n    </span><span class="s1">if (this.isRegExpLiteral()) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.isTemplateLiteral()) {</span><span class="s3">\n      </span><span class="s1">return this.get(</span><span class="s3">\&quot;</span><span class="s1">expressions</span><span class="s3">\&quot;</span><span class="s1">).every(expression =&gt;</span><span class="s3">\n        </span><span class="s1">expression.isConstantExpression(),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.isUnaryExpression()) {</span><span class="s3">\n    </span><span class="s1">if (this.node.operator !== </span><span class="s3">\&quot;</span><span class="s1">void</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.get(</span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">).isConstantExpression();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.isBinaryExpression()) {</span><span class="s3">\n    </span><span class="s1">const { operator } = this.node;</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">operator !== </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n      </span><span class="s1">operator !== </span><span class="s3">\&quot;</span><span class="s1">instanceof</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">).isConstantExpression() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">).isConstantExpression()</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isInStrictMode(this: NodePath) {</span><span class="s3">\n  </span><span class="s1">const start = this.isProgram() ? this : this.parentPath;</span><span class="s3">\n\n  </span><span class="s1">const strictParent = start.find(path =&gt; {</span><span class="s3">\n    </span><span class="s1">if (path.isProgram({ sourceType: </span><span class="s3">\&quot;</span><span class="s1">module</span><span class="s3">\&quot; </span><span class="s1">})) return true;</span><span class="s3">\n\n    </span><span class="s1">if (path.isClass()) return true;</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">path.isArrowFunctionExpression() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).isBlockStatement()</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let body: t.BlockStatement | t.Program;</span><span class="s3">\n    </span><span class="s1">if (path.isFunction()) {</span><span class="s3">\n      </span><span class="s1">body = path.node.body as t.BlockStatement;</span><span class="s3">\n    </span><span class="s1">} else if (path.isProgram()) {</span><span class="s3">\n      </span><span class="s1">body = path.node;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const directive of body.directives) {</span><span class="s3">\n      </span><span class="s1">if (directive.value.value === </span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return !!strictParent;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>