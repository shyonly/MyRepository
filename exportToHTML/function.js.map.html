<html>
<head>
<title>function.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
function.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;function.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/function.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;AACA,mCAAwD;AAExD;;GAEG;AACH,0BAA0B;AAC1B,MAAM,uBAAuB,GAC3B;IACE,GAAG;QACD,YAAY;IACd,CAAC;CACF,CAAC,GAAG,CAAC;KACH,QAAQ,EAAE;KACV,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC;AAEvB,MAAM,iBAAiB,GAAG;IACxB,QAAQ,EAAE,WAAW;IACrB,iBAAiB,EAAE,YAAY;IAC/B,aAAa,EAAE,iBAAiB;IAChC,sBAAsB,EAAE,kBAAkB;CAC3C,CAAC;AAEF,MAAM,eAAe,GAAG;IACtB,QAAQ,EAAE,EAAE;IACZ,iBAAiB,EAAE,GAAG;IACtB,aAAa,EAAE,QAAQ;IACvB,sBAAsB,EAAE,SAAS;CAClC,CAAC;AAEF,MAAM,wBAAwB,GAAG,IAAI,GAAG,CACtC,CACE,8DAA8D;IAC9D,mCAAmC,CACpC,CAAC,KAAK,CAAC,GAAG,CAAC,CACb,CAAC;AAEF;;GAEG;AACU,QAAA,eAAe,GAAG,IAAI,OAAO,EAAmC,CAAC;AAE9E;;GAEG;AACI,MAAM,gBAAgB,GAAa,CAAC,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,EAAE,EAAE;IACjE,MAAM,IAAI,GAAG,OAAO,GAAG,KAAK,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,SAAS,CAAC;IAEvD,2EAA2E;IAC3E,IAAI,IAAI,KAAK,SAAS;QAAE,uBAAe,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;IAEhD,OAAO,IAAI,cAAc,CAAC,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC,SAAS,EAAE,CAAC;AAC/D,CAAC,CAAC;AAPW,QAAA,gBAAgB,oBAO3B;AAEF;;GAEG;AACH,SAAgB,cAAc,CAAC,QAAgB;IAC7C,IAAI,KAAyB,CAAC;IAE9B,KAAK,MAAM,IAAI,IAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;QAChD,MAAM,CAAC,GAAG,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAChC,IAAI,CAAC,CAAC;YAAE,OAAO,QAAQ,CAAC,CAAC,6BAA6B;QAEtD,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAEhB,IAAI,KAAK,KAAK,SAAS;YAAE,KAAK,GAAG,GAAG,CAAC;aAChC,IAAI,GAAG,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM;YAAE,KAAK,GAAG,GAAG,CAAC;KACjD;IAED,OAAO,KAAK,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,KAAK,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;AACpE,CAAC;AAdD,wCAcC;AAED;;GAEG;AACH,MAAa,cAAc;IAUzB,YACS,EAAmC,EACnC,MAAc,EACd,IAAU,EACV,GAAY;QAHZ,OAAE,GAAF,EAAE,CAAiC;QACnC,WAAM,GAAN,MAAM,CAAQ;QACd,SAAI,GAAJ,IAAI,CAAM;QACV,QAAG,GAAH,GAAG,CAAS;QAPrB,QAAG,GAAG,CAAC,CAAC;QACR,eAAU,GAAG,KAAK,CAAC;QAQjB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QACrD,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC,WAAW,CAAC,IAAsC,CAAC;QACpE,IAAI,CAAC,QAAQ,GAAG,GAAG,KAAK,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,gBAAQ,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QAC7D,IAAI,CAAC,SAAS;YACZ,GAAG,KAAK,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,QAAQ,IAAI,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QACnE,IAAI,CAAC,iBAAiB;YACpB,GAAG,KAAK,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,KAAK,EAAE,IAAI,IAAI,CAAC,EAAE,CAAC,IAAI,KAAK,GAAG,CAAC;IAC5E,CAAC;IAED,SAAS;QACP,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;QAE9B,qEAAqE;QACrE,uEAAuE;QACvE,IAAI,CAAC,KAAK,EAAE;YACV,OAAO,GAAG,IAAI,CAAC,SAAS,QAAQ,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;SAC5D;QAED,OAAO,cAAc,CAAC,KAAK,CAAC,CAAC;IAC/B,CAAC;IAED,SAAS;QACP,IAAI,IAAI,CAAC,iBAAiB,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YAC9C,OAAO,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC;SACrD;QAED,OAAO,IAAI,CAAC,SAAS,GAAG,iBAAiB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACzD,CAAC;IAED,QAAQ;QACN,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;YACnD,6BAA6B;YAC7B,OAAO,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC;SACvC;QAED,qCAAqC;QACrC,IAAI,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE;YAChB,MAAM,MAAM,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACvC,IAAI,MAAM;gBAAE,OAAO,MAAM,CAAC;SAC3B;QAED,6BAA6B;QAC7B,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC;QACzB,IAAI,IAAI,CAAC,aAAa,EAAE,KAAK,OAAO;YAAE,OAAO,IAAI,CAAC,QAAQ,CAAC;QAC3D,IAAI,CAAC,GAAG,GAAG,OAAO,CAAC;QAEnB,IAAI,IAAI,CAAC,oBAAoB,EAAE,EAAE;YAC/B,MAAM,MAAM,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACvC,IAAI,MAAM;gBAAE,OAAO,MAAM,CAAC;YAE1B,IAAI,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC;YAEtB,QAAQ,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,EAAE;gBACvC,KAAK,WAAW;oBACd,IAAI,IAAI,CAAC,iBAAiB,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;wBAC9C,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC;qBACnB;gBACH,KAAK,IAAI;oBACP,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,KAAK,IAAI,EAAE;wBAC9C,OAAO,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC;qBACvC;oBAED,IAAI,CAAC,GAAG,GAAG,MAAM,CAAC;gBACpB,KAAK,GAAG,CAAC;gBACT,KAAK,GAAG,CAAC;gBACT,KAAK,IAAI;oBACP,OAAO,IAAI,CAAC,SAAS,EAAE,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;aAC5D;SACF;IACH,CAAC;IAED;;;;;OAKG;IACH,gBAAgB;QACd,IAAI,uBAAuB,EAAE;YAC3B,oEAAoE;YACpE,OAAO;SACR;QAED,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC;QACrB,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAEnE,IAAI,MAAM,KAAK,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE;YAC3B,IAAI,CAAC,GAAG,IAAI,MAAM,CAAC,MAAM,CAAC;YAE1B,IACE,IAAI,CAAC,aAAa,EAAE,KAAK,IAAI;gBAC7B,IAAI,CAAC,aAAa,EAAE,KAAK,IAAI;gBAC7B,IAAI,CAAC,GAAG,KAAK,IAAI,CAAC,QAAQ,CAAC,MAAM,EACjC;gBACA,kEAAkE;gBAClE,iEAAiE;gBACjE,IAAI,IAAI,CAAC,iBAAiB,IAAI,CAAC,2BAAmB,CAAC,MAAM,CAAC,EAAE;oBAC1D,KAAK,IAAI,MAAM,CAAC,MAAM,CAAC;iBACxB;gBAED,OAAO,IAAI,CAAC,SAAS,EAAE,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;aACvD;SACF;QAED,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC;IACnB,CAAC;IAED;;;;OAIG;IACH,oBAAoB;QAClB,IAAI,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC;QAEvB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;QAExB,QAAQ,IAAI,CAAC,MAAM,EAAE;YACnB,KAAK,eAAe;gBAClB,IAAI,IAAI,CAAC,aAAa,EAAE,KAAK,OAAO;oBAAE,OAAO,KAAK,CAAC;gBAEnD,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC;YACrB,KAAK,UAAU;gBACb,IAAI,IAAI,CAAC,aAAa,EAAE,KAAK,UAAU,EAAE;oBACvC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;iBACxB;qBAAM;oBACL,IAAI,CAAC,GAAG,GAAG,OAAO,CAAC;iBACpB;gBACD,OAAO,IAAI,CAAC;YACd,KAAK,wBAAwB;gBAC3B,IAAI,IAAI,CAAC,aAAa,EAAE,KAAK,OAAO;oBAAE,OAAO,KAAK,CAAC;YACrD,KAAK,mBAAmB;gBACtB,IAAI,KAAK,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;gBAEjC,IAAI,KAAK,KAAK,UAAU,EAAE;oBACxB,KAAK,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;oBAC7B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;iBACxB;gBAED,OAAO,KAAK,KAAK,GAAG,CAAC;SACxB;IACH,CAAC;IAED;;;;;;;;;;;;;OAaG;IACH,aAAa,CAAC,aAAsB;QAClC,MAAM,CAAC,GAAG,IAAI,CAAC,YAAY,CACzB,iDAAiD,CAClD,CAAC;QAEF,IAAI,CAAC,CAAC;YAAE,OAAO;QAEf,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC;QACzB,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAEzB,IAAI,KAAK;YAAE,OAAO,aAAa,IAAI,KAAK,CAAC;QAEzC,QAAQ,KAAK,EAAE;YACb,KAAK,GAAG;gBACN,OAAO,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;YAC3C,KAAK,GAAG;gBACN,OAAO,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;YAC3C,KAAK,GAAG;gBACN,OAAO,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;YAC3C,KAAK,GAAG;gBACN,OAAO,IAAI,CAAC,eAAe,EAAE,CAAC;YAChC,KAAK,GAAG;gBACN,OAAO,IAAI,CAAC,aAAa,CAAC,mBAAmB,EAAE,GAAG,CAAC,CAAC;YACtD,KAAK,GAAG;gBACN,OAAO,IAAI,CAAC,aAAa,CAAC,mBAAmB,EAAE,GAAG,CAAC,CAAC;SACvD;QAED,OAAO,KAAK,CAAC;IACf,CAAC;IAED,kBAAkB,CAAC,UAAkB,EAAE,QAAgB;QACrD,IAAI,eAAe,GAAG,IAAI,CAAC;QAE3B,SAAS;YACP,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;YACnC,IAAI,KAAK,KAAK,QAAQ;gBAAE,OAAO,UAAU,GAAG,QAAQ,CAAC;YACrD,IAAI,CAAC,KAAK,IAAI,KAAK,KAAK,GAAG,IAAI,KAAK,KAAK,GAAG,IAAI,KAAK,KAAK,GAAG;gBAAE,OAAO;YAEtE,IACE,KAAK,KAAK,GAAG;gBACb,eAAe;gBACf,IAAI,CAAC,YAAY,CAAC,iDAAiD,CAAC,EACpE;gBACA,eAAe,GAAG,KAAK,CAAC;gBACxB,IAAI,CAAC,iBAAiB,EAAE,CAAC;aAC1B;iBAAM;gBACL,eAAe,GAAG,wBAAwB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;aACvD;SACF;IACH,CAAC;IAED,YAAY,CAAC,EAAU;QACrB,MAAM,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;QAClD,IAAI,CAAC;YAAE,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;QAC/B,OAAO,CAAC,CAAC;IACX,CAAC;IAED;;;OAGG;IACH,aAAa,CAAC,EAAU,EAAE,KAAa;QACrC,MAAM,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;QAClD,IAAI,CAAC,CAAC;YAAE,OAAO;QACf,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;QACxB,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACzB,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;OAEG;IACH,eAAe;QACb,SAAS;YACP,IAAI,CAAC,YAAY,CAAC,2BAA2B,CAAC,CAAC;YAE/C,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,EAAE;gBACnC,IAAI,CAAC,GAAG,EAAE,CAAC;gBACX,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBACzB,OAAO,GAAG,CAAC;aACZ;YAED,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,KAAK,IAAI,EAAE;gBAC9C,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;gBACd,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBAEzB,IAAI,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE,GAAG,CAAC;oBAAE,SAAS;aACjD;YAED,OAAO;SACR;IACH,CAAC;IAED;;OAEG;IACH,iBAAiB;QACf,IAAI,CAAC,YAAY,CAAC,+BAA+B,CAAC,CAAC;IACrD,CAAC;CACF;AAhRD,wCAgRC&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { Next, ToString } from </span><span class="s3">\&quot;</span><span class="s1">./types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { quoteKey, isValidVariableName } from </span><span class="s3">\&quot;</span><span class="s1">./quote</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Used in function stringification.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* istanbul ignore next */</span><span class="s3">\n</span><span class="s1">const METHOD_NAMES_ARE_QUOTED =</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    \&quot; \&quot;</span><span class="s1">() {</span><span class="s3">\n      </span><span class="s1">/* Empty. */</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}[</span><span class="s3">\&quot; \&quot;</span><span class="s1">]</span><span class="s3">\n    </span><span class="s1">.toString()</span><span class="s3">\n    </span><span class="s1">.charAt(0) === '</span><span class="s3">\&quot;</span><span class="s1">';</span><span class="s3">\n\n</span><span class="s1">const FUNCTION_PREFIXES = {</span><span class="s3">\n  </span><span class="s1">Function: </span><span class="s3">\&quot;</span><span class="s1">function </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">GeneratorFunction: </span><span class="s3">\&quot;</span><span class="s1">function* </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">AsyncFunction: </span><span class="s3">\&quot;</span><span class="s1">async function </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">AsyncGeneratorFunction: </span><span class="s3">\&quot;</span><span class="s1">async function* </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const METHOD_PREFIXES = {</span><span class="s3">\n  </span><span class="s1">Function: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">GeneratorFunction: </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">AsyncFunction: </span><span class="s3">\&quot;</span><span class="s1">async </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">AsyncGeneratorFunction: </span><span class="s3">\&quot;</span><span class="s1">async *</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const TOKENS_PRECEDING_REGEXPS = new Set(</span><span class="s3">\n  </span><span class="s1">(</span><span class="s3">\n    \&quot;</span><span class="s1">case delete else in instanceof new return throw typeof void </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot;</span><span class="s1">, ; : + - ! ~ &amp; | ^ * / % &lt; &gt; ? =</span><span class="s3">\&quot;\n  </span><span class="s1">).split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Track function parser usage.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const USED_METHOD_KEY = new WeakSet&lt;(...args: unknown[]) =&gt; unknown&gt;();</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Stringify a function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const functionToString: ToString = (fn, space, next, key) =&gt; {</span><span class="s3">\n  </span><span class="s1">const name = typeof key === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? key : undefined;</span><span class="s3">\n\n  </span><span class="s1">// Track in function parser for object stringify to avoid duplicate output.</span><span class="s3">\n  </span><span class="s1">if (name !== undefined) USED_METHOD_KEY.add(fn);</span><span class="s3">\n\n  </span><span class="s1">return new FunctionParser(fn, space, next, name).stringify();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Rewrite a stringified function to remove initial indentation.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function dedentFunction(fnString: string) {</span><span class="s3">\n  </span><span class="s1">let found: string | undefined;</span><span class="s3">\n\n  </span><span class="s1">for (const line of fnString.split(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">).slice(1)) {</span><span class="s3">\n    </span><span class="s1">const m = /^[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">t]+/.exec(line);</span><span class="s3">\n    </span><span class="s1">if (!m) return fnString; // Early exit without indent.</span><span class="s3">\n\n    </span><span class="s1">const [str] = m;</span><span class="s3">\n\n    </span><span class="s1">if (found === undefined) found = str;</span><span class="s3">\n    </span><span class="s1">else if (str.length &lt; found.length) found = str;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return found ? fnString.split(`</span><span class="s3">\\</span><span class="s1">n${found}`).join(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">) : fnString;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Function parser and stringify.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class FunctionParser {</span><span class="s3">\n  </span><span class="s1">fnString: string;</span><span class="s3">\n  </span><span class="s1">fnType: keyof typeof FUNCTION_PREFIXES;</span><span class="s3">\n  </span><span class="s1">keyQuote: string | undefined;</span><span class="s3">\n  </span><span class="s1">keyPrefix: string;</span><span class="s3">\n  </span><span class="s1">isMethodCandidate: boolean;</span><span class="s3">\n\n  </span><span class="s1">pos = 0;</span><span class="s3">\n  </span><span class="s1">hadKeyword = false;</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">public fn: (...args: unknown[]) =&gt; unknown,</span><span class="s3">\n    </span><span class="s1">public indent: string,</span><span class="s3">\n    </span><span class="s1">public next: Next,</span><span class="s3">\n    </span><span class="s1">public key?: string</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.fnString = Function.prototype.toString.call(fn);</span><span class="s3">\n    </span><span class="s1">this.fnType = fn.constructor.name as keyof typeof FUNCTION_PREFIXES;</span><span class="s3">\n    </span><span class="s1">this.keyQuote = key === undefined ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: quoteKey(key, next);</span><span class="s3">\n    </span><span class="s1">this.keyPrefix =</span><span class="s3">\n      </span><span class="s1">key === undefined ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: `${this.keyQuote}:${indent ? </span><span class="s3">\&quot; \&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">}`;</span><span class="s3">\n    </span><span class="s1">this.isMethodCandidate =</span><span class="s3">\n      </span><span class="s1">key === undefined ? false : this.fn.name === </span><span class="s3">\&quot;\&quot; </span><span class="s1">|| this.fn.name === key;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">stringify() {</span><span class="s3">\n    </span><span class="s1">const value = this.tryParse();</span><span class="s3">\n\n    </span><span class="s1">// If we can't stringify this function, return a void expression; for</span><span class="s3">\n    </span><span class="s1">// bonus help with debugging, include the function as a string literal.</span><span class="s3">\n    </span><span class="s1">if (!value) {</span><span class="s3">\n      </span><span class="s1">return `${this.keyPrefix}void ${this.next(this.fnString)}`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return dedentFunction(value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getPrefix() {</span><span class="s3">\n    </span><span class="s1">if (this.isMethodCandidate &amp;&amp; !this.hadKeyword) {</span><span class="s3">\n      </span><span class="s1">return METHOD_PREFIXES[this.fnType] + this.keyQuote;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.keyPrefix + FUNCTION_PREFIXES[this.fnType];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">tryParse() {</span><span class="s3">\n    </span><span class="s1">if (this.fnString[this.fnString.length - 1] !== </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Must be an arrow function.</span><span class="s3">\n      </span><span class="s1">return this.keyPrefix + this.fnString;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Attempt to remove function prefix.</span><span class="s3">\n    </span><span class="s1">if (this.fn.name) {</span><span class="s3">\n      </span><span class="s1">const result = this.tryStrippingName();</span><span class="s3">\n      </span><span class="s1">if (result) return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Support class expressions.</span><span class="s3">\n    </span><span class="s1">const prevPos = this.pos;</span><span class="s3">\n    </span><span class="s1">if (this.consumeSyntax() === </span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">) return this.fnString;</span><span class="s3">\n    </span><span class="s1">this.pos = prevPos;</span><span class="s3">\n\n    </span><span class="s1">if (this.tryParsePrefixTokens()) {</span><span class="s3">\n      </span><span class="s1">const result = this.tryStrippingName();</span><span class="s3">\n      </span><span class="s1">if (result) return result;</span><span class="s3">\n\n      </span><span class="s1">let offset = this.pos;</span><span class="s3">\n\n      </span><span class="s1">switch (this.consumeSyntax(</span><span class="s3">\&quot;</span><span class="s1">WORD_LIKE</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">WORD_LIKE</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n          </span><span class="s1">if (this.isMethodCandidate &amp;&amp; !this.hadKeyword) {</span><span class="s3">\n            </span><span class="s1">offset = this.pos;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">()</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n          </span><span class="s1">if (this.fnString.substr(this.pos, 2) === </span><span class="s3">\&quot;</span><span class="s1">=&gt;</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">return this.keyPrefix + this.fnString;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">this.pos = offset;</span><span class="s3">\n        </span><span class="s1">case '</span><span class="s3">\&quot;</span><span class="s1">':</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">[]</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n          </span><span class="s1">return this.getPrefix() + this.fnString.substr(this.pos);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Attempt to parse the function from the current position by first stripping</span><span class="s3">\n   </span><span class="s1">* the function's name from the front. This is not a fool-proof method on all</span><span class="s3">\n   </span><span class="s1">* JavaScript engines, but yields good results on Node.js 4 (and slightly</span><span class="s3">\n   </span><span class="s1">* less good results on Node.js 6 and 8).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">tryStrippingName() {</span><span class="s3">\n    </span><span class="s1">if (METHOD_NAMES_ARE_QUOTED) {</span><span class="s3">\n      </span><span class="s1">// ... then this approach is unnecessary and yields false positives.</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let start = this.pos;</span><span class="s3">\n    </span><span class="s1">const prefix = this.fnString.substr(this.pos, this.fn.name.length);</span><span class="s3">\n\n    </span><span class="s1">if (prefix === this.fn.name) {</span><span class="s3">\n      </span><span class="s1">this.pos += prefix.length;</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">this.consumeSyntax() === </span><span class="s3">\&quot;</span><span class="s1">()</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">this.consumeSyntax() === </span><span class="s3">\&quot;</span><span class="s1">{}</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">this.pos === this.fnString.length</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// Don't include the function's name if it will be included in the</span><span class="s3">\n        </span><span class="s1">// prefix, or if it's invalid as a name in a function expression.</span><span class="s3">\n        </span><span class="s1">if (this.isMethodCandidate || !isValidVariableName(prefix)) {</span><span class="s3">\n          </span><span class="s1">start += prefix.length;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return this.getPrefix() + this.fnString.substr(start);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.pos = start;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Attempt to advance the parser past the keywords expected to be at the</span><span class="s3">\n   </span><span class="s1">* start of this function's definition. This method sets `this.hadKeyword`</span><span class="s3">\n   </span><span class="s1">* based on whether or not a `function` keyword is consumed.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">tryParsePrefixTokens(): boolean {</span><span class="s3">\n    </span><span class="s1">let posPrev = this.pos;</span><span class="s3">\n\n    </span><span class="s1">this.hadKeyword = false;</span><span class="s3">\n\n    </span><span class="s1">switch (this.fnType) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">AsyncFunction</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">if (this.consumeSyntax() !== </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">) return false;</span><span class="s3">\n\n        </span><span class="s1">posPrev = this.pos;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Function</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">if (this.consumeSyntax() === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">this.hadKeyword = true;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">this.pos = posPrev;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">AsyncGeneratorFunction</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">if (this.consumeSyntax() !== </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">) return false;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">GeneratorFunction</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">let token = this.consumeSyntax();</span><span class="s3">\n\n        </span><span class="s1">if (token === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">token = this.consumeSyntax();</span><span class="s3">\n          </span><span class="s1">this.hadKeyword = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return token === </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Advance the parser past one element of JavaScript syntax. This could be a</span><span class="s3">\n   </span><span class="s1">* matched pair of delimiters, like braces or parentheses, or an atomic unit</span><span class="s3">\n   </span><span class="s1">* like a keyword, variable, or operator. Return a normalized string</span><span class="s3">\n   </span><span class="s1">* representation of the element parsed--for example, returns '{}' for a</span><span class="s3">\n   </span><span class="s1">* matched pair of braces. Comments and whitespace are skipped.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* (This isn't a full parser, so the token scanning logic used here is as</span><span class="s3">\n   </span><span class="s1">* simple as it can be. As a consequence, some things that are one token in</span><span class="s3">\n   </span><span class="s1">* JavaScript, like decimal number literals or most multi-character operators</span><span class="s3">\n   </span><span class="s1">* like '&amp;&amp;', are split into more than one token here. However, awareness of</span><span class="s3">\n   </span><span class="s1">* some multi-character sequences like '=&gt;' is necessary, so we match the few</span><span class="s3">\n   </span><span class="s1">* of them that we care about.)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">consumeSyntax(wordLikeToken?: string) {</span><span class="s3">\n    </span><span class="s1">const m = this.consumeMatch(</span><span class="s3">\n      </span><span class="s1">/^(?:([A-Za-z_0-9$</span><span class="s3">\\</span><span class="s1">xA0-</span><span class="s3">\\</span><span class="s1">uFFFF]+)|=&gt;|</span><span class="s3">\\</span><span class="s1">+</span><span class="s3">\\</span><span class="s1">+|</span><span class="s3">\\</span><span class="s1">-</span><span class="s3">\\</span><span class="s1">-|.)/</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (!m) return;</span><span class="s3">\n\n    </span><span class="s1">const [token, match] = m;</span><span class="s3">\n    </span><span class="s1">this.consumeWhitespace();</span><span class="s3">\n\n    </span><span class="s1">if (match) return wordLikeToken || match;</span><span class="s3">\n\n    </span><span class="s1">switch (token) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return this.consumeSyntaxUntil(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return this.consumeSyntaxUntil(</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return this.consumeSyntaxUntil(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return this.consumeTemplate();</span><span class="s3">\n      </span><span class="s1">case '</span><span class="s3">\&quot;</span><span class="s1">':</span><span class="s3">\n        </span><span class="s1">return this.consumeRegExp(/^(?:[^</span><span class="s3">\\\\\&quot;</span><span class="s1">]|</span><span class="s3">\\\\</span><span class="s1">.)*</span><span class="s3">\&quot;</span><span class="s1">/, '</span><span class="s3">\&quot;</span><span class="s1">');</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return this.consumeRegExp(/^(?:[^</span><span class="s3">\\\\</span><span class="s1">']|</span><span class="s3">\\\\</span><span class="s1">.)*'/, </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return token;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">consumeSyntaxUntil(startToken: string, endToken: string): string | undefined {</span><span class="s3">\n    </span><span class="s1">let isRegExpAllowed = true;</span><span class="s3">\n\n    </span><span class="s1">for (;;) {</span><span class="s3">\n      </span><span class="s1">const token = this.consumeSyntax();</span><span class="s3">\n      </span><span class="s1">if (token === endToken) return startToken + endToken;</span><span class="s3">\n      </span><span class="s1">if (!token || token === </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">|| token === </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot; </span><span class="s1">|| token === </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) return;</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">token === </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">isRegExpAllowed &amp;&amp;</span><span class="s3">\n        </span><span class="s1">this.consumeMatch(/^(?:</span><span class="s3">\\\\</span><span class="s1">.|[^</span><span class="s3">\\\\\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">n[]|</span><span class="s3">\\</span><span class="s1">[(?:</span><span class="s3">\\\\</span><span class="s1">.|[^</span><span class="s3">\\</span><span class="s1">]])*</span><span class="s3">\\</span><span class="s1">])+</span><span class="s3">\\</span><span class="s1">/[a-z]*/)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">isRegExpAllowed = false;</span><span class="s3">\n        </span><span class="s1">this.consumeWhitespace();</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">isRegExpAllowed = TOKENS_PRECEDING_REGEXPS.has(token);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">consumeMatch(re: RegExp) {</span><span class="s3">\n    </span><span class="s1">const m = re.exec(this.fnString.substr(this.pos));</span><span class="s3">\n    </span><span class="s1">if (m) this.pos += m[0].length;</span><span class="s3">\n    </span><span class="s1">return m;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Advance the parser past an arbitrary regular expression. Return `token`,</span><span class="s3">\n   </span><span class="s1">* or the match object of the regexp.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">consumeRegExp(re: RegExp, token: string): string | undefined {</span><span class="s3">\n    </span><span class="s1">const m = re.exec(this.fnString.substr(this.pos));</span><span class="s3">\n    </span><span class="s1">if (!m) return;</span><span class="s3">\n    </span><span class="s1">this.pos += m[0].length;</span><span class="s3">\n    </span><span class="s1">this.consumeWhitespace();</span><span class="s3">\n    </span><span class="s1">return token;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Advance the parser past a template string.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">consumeTemplate() {</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n      </span><span class="s1">this.consumeMatch(/^(?:[^`$</span><span class="s3">\\\\</span><span class="s1">]|</span><span class="s3">\\\\</span><span class="s1">.|</span><span class="s3">\\</span><span class="s1">$(?!{))*/);</span><span class="s3">\n\n      </span><span class="s1">if (this.fnString[this.pos] === </span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">this.pos++;</span><span class="s3">\n        </span><span class="s1">this.consumeWhitespace();</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (this.fnString.substr(this.pos, 2) === </span><span class="s3">\&quot;</span><span class="s1">${</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">this.pos += 2;</span><span class="s3">\n        </span><span class="s1">this.consumeWhitespace();</span><span class="s3">\n\n        </span><span class="s1">if (this.consumeSyntaxUntil(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">)) continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Advance the parser past any whitespace or comments.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">consumeWhitespace() {</span><span class="s3">\n    </span><span class="s1">this.consumeMatch(/^(?:</span><span class="s3">\\</span><span class="s1">s|</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/.*|</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">*[^]*?</span><span class="s3">\\</span><span class="s1">*</span><span class="s3">\\</span><span class="s1">/)*/);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">]}</span></pre>
</body>
</html>