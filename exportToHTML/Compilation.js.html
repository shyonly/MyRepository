<html>
<head>
<title>Compilation.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #bcbec4;}
.s4 { color: #cf8e6d;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #67a37c; font-style: italic;}
.s7 { color: #2aacb8;}
.s8 { color: #42c3d4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Compilation.js</font>
</center></td></tr></table>
<pre><span class="s0">/* 
    MIT License http://www.opensource.org/licenses/mit-license.php 
    Author Tobias Koppers @sokra 
*/</span>

<span class="s2">&quot;use strict&quot;</span><span class="s3">;</span>

<span class="s4">const </span><span class="s1">asyncLib </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;neo-async&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{</span>
	<span class="s1">HookMap</span><span class="s3">,</span>
	<span class="s1">SyncHook</span><span class="s3">,</span>
	<span class="s1">SyncBailHook</span><span class="s3">,</span>
	<span class="s1">SyncWaterfallHook</span><span class="s3">,</span>
	<span class="s1">AsyncSeriesHook</span><span class="s3">,</span>
	<span class="s1">AsyncSeriesBailHook</span><span class="s3">,</span>
	<span class="s1">AsyncParallelHook</span>
<span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;tapable&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">util </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;util&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">CachedSource </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;webpack-sources&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">MultiItemCache </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./CacheFacade&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">Chunk </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./Chunk&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">ChunkGraph </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./ChunkGraph&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">ChunkGroup </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./ChunkGroup&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">ChunkRenderError </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./ChunkRenderError&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">ChunkTemplate </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./ChunkTemplate&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">CodeGenerationError </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./CodeGenerationError&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">CodeGenerationResults </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./CodeGenerationResults&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">Dependency </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./Dependency&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">DependencyTemplates </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./DependencyTemplates&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">Entrypoint </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./Entrypoint&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">ErrorHelpers </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./ErrorHelpers&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">FileSystemInfo </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./FileSystemInfo&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{</span>
	<span class="s1">connectChunkGroupAndChunk</span><span class="s3">,</span>
	<span class="s1">connectChunkGroupParentAndChild</span>
<span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./GraphHelpers&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{</span>
	<span class="s1">makeWebpackError</span><span class="s3">,</span>
	<span class="s1">tryRunOrWebpackError</span>
<span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./HookWebpackError&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">MainTemplate </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./MainTemplate&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">Module </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./Module&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">ModuleDependencyError </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./ModuleDependencyError&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">ModuleDependencyWarning </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./ModuleDependencyWarning&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">ModuleGraph </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./ModuleGraph&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">ModuleHashingError </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./ModuleHashingError&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">ModuleNotFoundError </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./ModuleNotFoundError&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">ModuleProfile </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./ModuleProfile&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">ModuleRestoreError </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./ModuleRestoreError&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">ModuleStoreError </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./ModuleStoreError&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">ModuleTemplate </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./ModuleTemplate&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">WEBPACK_MODULE_TYPE_RUNTIME </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./ModuleTypeConstants&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">RuntimeGlobals </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./RuntimeGlobals&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">RuntimeTemplate </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./RuntimeTemplate&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">Stats </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./Stats&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">WebpackError </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./WebpackError&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">buildChunkGraph </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./buildChunkGraph&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">BuildCycleError </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./errors/BuildCycleError&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">Logger</span><span class="s3">, </span><span class="s1">LogType </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./logging/Logger&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">StatsFactory </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./stats/StatsFactory&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">StatsPrinter </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./stats/StatsPrinter&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">equals</span><span class="s3">: </span><span class="s1">arrayEquals </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/ArrayHelpers&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">AsyncQueue </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/AsyncQueue&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">LazySet </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/LazySet&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">getOrInsert </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/MapHelpers&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">WeakTupleMap </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/WeakTupleMap&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">cachedCleverMerge </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/cleverMerge&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{</span>
	<span class="s1">compareLocations</span><span class="s3">,</span>
	<span class="s1">concatComparators</span><span class="s3">,</span>
	<span class="s1">compareSelect</span><span class="s3">,</span>
	<span class="s1">compareIds</span><span class="s3">,</span>
	<span class="s1">compareStringsNumeric</span><span class="s3">,</span>
	<span class="s1">compareModulesByIdentifier</span>
<span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/comparators&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">createHash </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/createHash&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{</span>
	<span class="s1">arrayToSetDeprecation</span><span class="s3">,</span>
	<span class="s1">soonFrozenObjectDeprecation</span><span class="s3">,</span>
	<span class="s1">createFakeHook</span>
<span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/deprecation&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">processAsyncTree </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/processAsyncTree&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">getRuntimeKey </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/runtime&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">isSourceEqual </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/source&quot;</span><span class="s3">);</span>

<span class="s5">/** </span><span class="s6">@template </span><span class="s5">T @typedef {import(&quot;tapable&quot;).AsArray&lt;T&gt;} AsArray&lt;T&gt; */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;webpack-sources&quot;).Source} Source */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../declarations/WebpackOptions&quot;).EntryDescriptionNormalized} EntryDescription */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../declarations/WebpackOptions&quot;).OutputNormalized} OutputOptions */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../declarations/WebpackOptions&quot;).StatsOptions} StatsOptions */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../declarations/WebpackOptions&quot;).WebpackPluginFunction} WebpackPluginFunction */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../declarations/WebpackOptions&quot;).WebpackPluginInstance} WebpackPluginInstance */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./AsyncDependenciesBlock&quot;)} AsyncDependenciesBlock */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./Cache&quot;)} Cache */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./CacheFacade&quot;)} CacheFacade */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./ChunkGroup&quot;).ChunkGroupOptions} ChunkGroupOptions */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./Compiler&quot;)} Compiler */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./Compiler&quot;).CompilationParams} CompilationParams */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./DependenciesBlock&quot;)} DependenciesBlock */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./Dependency&quot;).DependencyLocation} DependencyLocation */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./Dependency&quot;).ReferencedExport} ReferencedExport */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./DependencyTemplate&quot;)} DependencyTemplate */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./Entrypoint&quot;).EntryOptions} EntryOptions */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./Module&quot;).CodeGenerationResult} CodeGenerationResult */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./ModuleFactory&quot;)} ModuleFactory */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./ModuleFactory&quot;).ModuleFactoryCreateDataContextInfo} ModuleFactoryCreateDataContextInfo */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./ModuleFactory&quot;).ModuleFactoryResult} ModuleFactoryResult */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./RequestShortener&quot;)} RequestShortener */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./RuntimeModule&quot;)} RuntimeModule */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./Template&quot;).RenderManifestEntry} RenderManifestEntry */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./Template&quot;).RenderManifestOptions} RenderManifestOptions */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./stats/DefaultStatsFactoryPlugin&quot;).StatsAsset} StatsAsset */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./stats/DefaultStatsFactoryPlugin&quot;).StatsError} StatsError */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./stats/DefaultStatsFactoryPlugin&quot;).StatsModule} StatsModule */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./util/Hash&quot;)} Hash */</span>
<span class="s5">/** </span><span class="s6">@template </span><span class="s5">T @typedef {import(&quot;./util/deprecation&quot;).FakeHook&lt;T&gt;} FakeHook&lt;T&gt; */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./util/runtime&quot;).RuntimeSpec} RuntimeSpec */</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@callback </span><span class="s5">Callback</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{(WebpackError | null)=} err</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@callback </span><span class="s5">ModuleCallback</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{(WebpackError | null)=} err</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module=} result</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@callback </span><span class="s5">ModuleFactoryResultCallback</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{(WebpackError | null)=} err</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleFactoryResult=} result</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@callback </span><span class="s5">ModuleOrFactoryResultCallback</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{(WebpackError | null)=} err</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module | ModuleFactoryResult=} result</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@callback </span><span class="s5">ExecuteModuleCallback</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{(WebpackError | null)=} err</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ExecuteModuleResult=} result</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@callback </span><span class="s5">DepBlockVarDependenciesCallback</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Dependency} dependency</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{any}</span>
 <span class="s5">*/</span>

<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{new (...args: any[]) =&gt; Dependency} DepConstructor */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{Record&lt;string, Source&gt;} CompilationAssets */</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} AvailableModulesChunkGroupMapping</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ChunkGroup} chunkGroup</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Set&lt;Module&gt;} availableModules</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} needCopy</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} DependenciesBlockLike</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Dependency[]} dependencies</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{AsyncDependenciesBlock[]} blocks</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} ChunkPathData</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string|number} id</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} name</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} hash</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{function(number): string=} hashWithLength</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{(Record&lt;string, string&gt;)=} contentHash</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{(Record&lt;string, (length: number) =&gt; string&gt;)=} contentHashWithLength</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} ChunkHashContext</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{CodeGenerationResults} codeGenerationResults results of code generation</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{RuntimeTemplate} runtimeTemplate the runtime template</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ModuleGraph} moduleGraph the module graph</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ChunkGraph} chunkGraph the chunk graph</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} RuntimeRequirementsContext</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ChunkGraph} chunkGraph the chunk graph</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{CodeGenerationResults} codeGenerationResults the code generation results</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} ExecuteModuleOptions</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{EntryOptions=} entryOptions</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} ExecuteModuleResult</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{any} exports</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} cacheable</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Map&lt;string, { source: Source, info: AssetInfo }&gt;} assets</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{LazySet&lt;string&gt;} fileDependencies</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{LazySet&lt;string&gt;} contextDependencies</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{LazySet&lt;string&gt;} missingDependencies</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{LazySet&lt;string&gt;} buildDependencies</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} ExecuteModuleArgument</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Module} module</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{{ id: string, exports: any, loaded: boolean }=} moduleObject</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{any} preparedInfo</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{CodeGenerationResult} codeGenerationResult</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} ExecuteModuleContext</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Map&lt;string, { source: Source, info: AssetInfo }&gt;} assets</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Chunk} chunk</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ChunkGraph} chunkGraph</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{function(string): any=} __webpack_require__</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} EntryData</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Dependency[]} dependencies dependencies of the entrypoint that should be evaluated at startup</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Dependency[]} includeDependencies dependencies of the entrypoint that should be included but not evaluated</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{EntryOptions} options options of the entrypoint</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} LogEntry</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} type</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{any[]} args</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number} time</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string[]=} trace</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} KnownAssetInfo</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean=} immutable true, if the asset can be long term cached forever (contains a hash)</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean=} minimized whether the asset is minimized</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string | string[]=} fullhash the value(s) of the full hash used for this asset</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string | string[]=} chunkhash the value(s) of the chunk hash used for this asset</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string | string[]=} modulehash the value(s) of the module hash used for this asset</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string | string[]=} contenthash the value(s) of the content hash used for this asset</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} sourceFilename when asset was created from a source file (potentially transformed), the original filename relative to compilation context</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number=} size size in bytes, only set after asset has been emitted</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean=} development true, when asset is only used for development and doesn't count towards user-facing assets</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean=} hotModuleReplacement true, when asset ships data for updating an existing application (HMR)</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean=} javascriptModule true, when asset is javascript and an ESM</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Record&lt;string, string | string[]&gt;=} related object of pointers to other assets, keyed by type of relation (only points from parent to child)</span>
 <span class="s5">*/</span>

<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{KnownAssetInfo &amp; Record&lt;string, any&gt;} AssetInfo */</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} Asset</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} name the filename of the asset</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Source} source source of the asset</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{AssetInfo} info info about the asset</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} ModulePathData</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string|number} id</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} hash</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{function(number): string=} hashWithLength</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} PathData</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ChunkGraph=} chunkGraph</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} hash</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{function(number): string=} hashWithLength</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{(Chunk|ChunkPathData)=} chunk</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{(Module|ModulePathData)=} module</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{RuntimeSpec=} runtime</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} filename</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} basename</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} query</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} contentHashType</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} contentHash</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{function(number): string=} contentHashWithLength</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean=} noChunkHash</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} url</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} KnownNormalizedStatsOptions</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} context</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{RequestShortener} requestShortener</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} chunksSort</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} modulesSort</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} chunkModulesSort</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} nestedModulesSort</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} assetsSort</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} ids</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} cachedAssets</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} groupAssetsByEmitStatus</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} groupAssetsByPath</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} groupAssetsByExtension</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number} assetsSpace</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{((value: string, asset: StatsAsset) =&gt; boolean)[]} excludeAssets</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{((name: string, module: StatsModule, type: &quot;module&quot; | &quot;chunk&quot; | &quot;root-of-chunk&quot; | &quot;nested&quot;) =&gt; boolean)[]} excludeModules</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{((warning: StatsError, textValue: string) =&gt; boolean)[]} warningsFilter</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} cachedModules</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} orphanModules</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} dependentModules</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} runtimeModules</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} groupModulesByCacheStatus</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} groupModulesByLayer</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} groupModulesByAttributes</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} groupModulesByPath</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} groupModulesByExtension</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} groupModulesByType</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean | &quot;auto&quot;} entrypoints</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} chunkGroups</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} chunkGroupAuxiliary</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} chunkGroupChildren</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number} chunkGroupMaxAssets</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number} modulesSpace</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number} chunkModulesSpace</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number} nestedModulesSpace</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{false|&quot;none&quot;|&quot;error&quot;|&quot;warn&quot;|&quot;info&quot;|&quot;log&quot;|&quot;verbose&quot;} logging</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{((value: string) =&gt; boolean)[]} loggingDebug</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} loggingTrace</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{any} _env</span>
 <span class="s5">*/</span>

<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{KnownNormalizedStatsOptions &amp; Omit&lt;StatsOptions, keyof KnownNormalizedStatsOptions&gt; &amp; Record&lt;string, any&gt;} NormalizedStatsOptions */</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} KnownCreateStatsOptionsContext</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean=} forToString</span>
 <span class="s5">*/</span>

<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{KnownCreateStatsOptionsContext &amp; Record&lt;string, any&gt;} CreateStatsOptionsContext */</span>

<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AssetInfo} */</span>
<span class="s4">const </span><span class="s1">EMPTY_ASSET_INFO </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">freeze</span><span class="s3">({});</span>

<span class="s4">const </span><span class="s1">esmDependencyCategory </span><span class="s3">= </span><span class="s2">&quot;esm&quot;</span><span class="s3">;</span>
<span class="s0">// TODO webpack 6: remove</span>
<span class="s4">const </span><span class="s1">deprecatedNormalModuleLoaderHook </span><span class="s3">= </span><span class="s1">util</span><span class="s3">.</span><span class="s1">deprecate</span><span class="s3">(</span>
	<span class="s1">compilation </span><span class="s3">=&gt; {</span>
		<span class="s4">return </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./NormalModule&quot;</span><span class="s3">).</span><span class="s1">getCompilationHooks</span><span class="s3">(</span><span class="s1">compilation</span><span class="s3">).</span><span class="s1">loader</span><span class="s3">;</span>
	<span class="s3">},</span>
	<span class="s2">&quot;Compilation.hooks.normalModuleLoader was moved to NormalModule.getCompilationHooks(compilation).loader&quot;</span><span class="s3">,</span>
	<span class="s2">&quot;DEP_WEBPACK_COMPILATION_NORMAL_MODULE_LOADER_HOOK&quot;</span>
<span class="s3">);</span>

<span class="s0">// TODO webpack 6: remove</span>
<span class="s4">const </span><span class="s1">defineRemovedModuleTemplates </span><span class="s3">= </span><span class="s1">moduleTemplates </span><span class="s3">=&gt; {</span>
	<span class="s1">Object</span><span class="s3">.</span><span class="s1">defineProperties</span><span class="s3">(</span><span class="s1">moduleTemplates</span><span class="s3">, {</span>
		<span class="s1">asset</span><span class="s3">: {</span>
			<span class="s1">enumerable</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
			<span class="s1">configurable</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
			<span class="s1">get</span><span class="s3">: () =&gt; {</span>
				<span class="s4">throw new </span><span class="s1">WebpackError</span><span class="s3">(</span>
					<span class="s2">&quot;Compilation.moduleTemplates.asset has been removed&quot;</span>
				<span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">},</span>
		<span class="s1">webassembly</span><span class="s3">: {</span>
			<span class="s1">enumerable</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
			<span class="s1">configurable</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
			<span class="s1">get</span><span class="s3">: () =&gt; {</span>
				<span class="s4">throw new </span><span class="s1">WebpackError</span><span class="s3">(</span>
					<span class="s2">&quot;Compilation.moduleTemplates.webassembly has been removed&quot;</span>
				<span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
	<span class="s3">});</span>
	<span class="s1">moduleTemplates </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s4">const </span><span class="s1">byId </span><span class="s3">= </span><span class="s1">compareSelect</span><span class="s3">(</span>
	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} c chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number | string} id</span>
	 <span class="s5">*/ </span><span class="s1">c </span><span class="s3">=&gt; </span><span class="s1">c</span><span class="s3">.</span><span class="s1">id</span><span class="s3">,</span>
	<span class="s1">compareIds</span>
<span class="s3">);</span>

<span class="s4">const </span><span class="s1">byNameOrHash </span><span class="s3">= </span><span class="s1">concatComparators</span><span class="s3">(</span>
	<span class="s1">compareSelect</span><span class="s3">(</span>
		<span class="s5">/**</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Compilation} c compilation</span>
		 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} name</span>
		 <span class="s5">*/</span>
		<span class="s1">c </span><span class="s3">=&gt; </span><span class="s1">c</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,</span>
		<span class="s1">compareIds</span>
	<span class="s3">),</span>
	<span class="s1">compareSelect</span><span class="s3">(</span>
		<span class="s5">/**</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Compilation} c compilation</span>
		 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} hash</span>
		 <span class="s5">*/ </span><span class="s1">c </span><span class="s3">=&gt; </span><span class="s1">c</span><span class="s3">.</span><span class="s1">fullHash</span><span class="s3">,</span>
		<span class="s1">compareIds</span>
	<span class="s3">)</span>
<span class="s3">);</span>

<span class="s4">const </span><span class="s1">byMessage </span><span class="s3">= </span><span class="s1">compareSelect</span><span class="s3">(</span><span class="s1">err </span><span class="s3">=&gt; </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">err</span><span class="s3">.</span><span class="s1">message</span><span class="s3">}</span><span class="s2">`</span><span class="s3">, </span><span class="s1">compareStringsNumeric</span><span class="s3">);</span>

<span class="s4">const </span><span class="s1">byModule </span><span class="s3">= </span><span class="s1">compareSelect</span><span class="s3">(</span>
	<span class="s1">err </span><span class="s3">=&gt; (</span><span class="s1">err</span><span class="s3">.</span><span class="s1">module </span><span class="s3">&amp;&amp; </span><span class="s1">err</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">()) || </span><span class="s2">&quot;&quot;</span><span class="s3">,</span>
	<span class="s1">compareStringsNumeric</span>
<span class="s3">);</span>

<span class="s4">const </span><span class="s1">byLocation </span><span class="s3">= </span><span class="s1">compareSelect</span><span class="s3">(</span><span class="s1">err </span><span class="s3">=&gt; </span><span class="s1">err</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">, </span><span class="s1">compareLocations</span><span class="s3">);</span>

<span class="s4">const </span><span class="s1">compareErrors </span><span class="s3">= </span><span class="s1">concatComparators</span><span class="s3">(</span><span class="s1">byModule</span><span class="s3">, </span><span class="s1">byLocation</span><span class="s3">, </span><span class="s1">byMessage</span><span class="s3">);</span>

<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WeakMap&lt;Dependency, Module &amp; { restoreFromUnsafeCache: Function } | null&gt;} */</span>
<span class="s4">const </span><span class="s1">unsafeCacheDependencies </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>

<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WeakMap&lt;Module &amp; { restoreFromUnsafeCache: Function }, object&gt;} */</span>
<span class="s4">const </span><span class="s1">unsafeCacheData </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>

<span class="s4">class </span><span class="s1">Compilation </span><span class="s3">{</span>
	<span class="s5">/**</span>
	 <span class="s5">* Creates an instance of Compilation.</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Compiler} compiler the compiler which created the compilation</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{CompilationParams} params the compilation parameters</span>
	 <span class="s5">*/</span>
	<span class="s1">constructor</span><span class="s3">(</span><span class="s1">compiler</span><span class="s3">, </span><span class="s1">params</span><span class="s3">) {</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_backCompat </span><span class="s3">= </span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">_backCompat</span><span class="s3">;</span>

		<span class="s4">const </span><span class="s1">getNormalModuleLoader </span><span class="s3">= () =&gt; </span><span class="s1">deprecatedNormalModuleLoaderHook</span><span class="s3">(</span><span class="s4">this</span><span class="s3">);</span>
		<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{{ additionalAssets?: true | Function }} ProcessAssetsAdditionalOptions */</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AsyncSeriesHook&lt;[CompilationAssets], ProcessAssetsAdditionalOptions&gt;} */</span>
		<span class="s4">const </span><span class="s1">processAssetsHook </span><span class="s3">= </span><span class="s4">new </span><span class="s1">AsyncSeriesHook</span><span class="s3">([</span><span class="s2">&quot;assets&quot;</span><span class="s3">]);</span>

		<span class="s4">let </span><span class="s1">savedAssets </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s4">const </span><span class="s1">popNewAssets </span><span class="s3">= </span><span class="s1">assets </span><span class="s3">=&gt; {</span>
			<span class="s4">let </span><span class="s1">newAssets </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">file of Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">assets</span><span class="s3">)) {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">savedAssets</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">file</span><span class="s3">)) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">newAssets </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
					<span class="s1">newAssets </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s4">null</span><span class="s3">);</span>
				<span class="s3">}</span>
				<span class="s1">newAssets</span><span class="s3">[</span><span class="s1">file</span><span class="s3">] = </span><span class="s1">assets</span><span class="s3">[</span><span class="s1">file</span><span class="s3">];</span>
				<span class="s1">savedAssets</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">file</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">return </span><span class="s1">newAssets</span><span class="s3">;</span>
		<span class="s3">};</span>
		<span class="s1">processAssetsHook</span><span class="s3">.</span><span class="s1">intercept</span><span class="s3">({</span>
			<span class="s1">name</span><span class="s3">: </span><span class="s2">&quot;Compilation&quot;</span><span class="s3">,</span>
			<span class="s1">call</span><span class="s3">: () =&gt; {</span>
				<span class="s1">savedAssets </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">));</span>
			<span class="s3">},</span>
			<span class="s1">register</span><span class="s3">: </span><span class="s1">tap </span><span class="s3">=&gt; {</span>
				<span class="s4">const </span><span class="s3">{ </span><span class="s1">type</span><span class="s3">, </span><span class="s1">name </span><span class="s3">} = </span><span class="s1">tap</span><span class="s3">;</span>
				<span class="s4">const </span><span class="s3">{ </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">additionalAssets</span><span class="s3">, </span><span class="s1">...remainingTap </span><span class="s3">} = </span><span class="s1">tap</span><span class="s3">;</span>
				<span class="s4">const </span><span class="s1">additionalAssetsFn </span><span class="s3">=</span>
					<span class="s1">additionalAssets </span><span class="s3">=== </span><span class="s4">true </span><span class="s3">? </span><span class="s1">fn </span><span class="s3">: </span><span class="s1">additionalAssets</span><span class="s3">;</span>
				<span class="s4">const </span><span class="s1">processedAssets </span><span class="s3">= </span><span class="s1">additionalAssetsFn </span><span class="s3">? </span><span class="s4">new </span><span class="s1">WeakSet</span><span class="s3">() : </span><span class="s1">undefined</span><span class="s3">;</span>
				<span class="s4">switch </span><span class="s3">(</span><span class="s1">type</span><span class="s3">) {</span>
					<span class="s4">case </span><span class="s2">&quot;sync&quot;</span><span class="s3">:</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">additionalAssetsFn</span><span class="s3">) {</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">processAdditionalAssets</span><span class="s3">.</span><span class="s1">tap</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">assets </span><span class="s3">=&gt; {</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">processedAssets</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">))</span>
									<span class="s1">additionalAssetsFn</span><span class="s3">(</span><span class="s1">assets</span><span class="s3">);</span>
							<span class="s3">});</span>
						<span class="s3">}</span>
						<span class="s4">return </span><span class="s3">{</span>
							<span class="s1">...remainingTap</span><span class="s3">,</span>
							<span class="s1">type</span><span class="s3">: </span><span class="s2">&quot;async&quot;</span><span class="s3">,</span>
							<span class="s1">fn</span><span class="s3">: (</span><span class="s1">assets</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) =&gt; {</span>
								<span class="s4">try </span><span class="s3">{</span>
									<span class="s1">fn</span><span class="s3">(</span><span class="s1">assets</span><span class="s3">);</span>
								<span class="s3">} </span><span class="s4">catch </span><span class="s3">(</span><span class="s1">e</span><span class="s3">) {</span>
									<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">e</span><span class="s3">);</span>
								<span class="s3">}</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">processedAssets </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">)</span>
									<span class="s1">processedAssets</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">);</span>
								<span class="s4">const </span><span class="s1">newAssets </span><span class="s3">= </span><span class="s1">popNewAssets</span><span class="s3">(</span><span class="s1">assets</span><span class="s3">);</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">newAssets </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
									<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">processAdditionalAssets</span><span class="s3">.</span><span class="s1">callAsync</span><span class="s3">(</span>
										<span class="s1">newAssets</span><span class="s3">,</span>
										<span class="s1">callback</span>
									<span class="s3">);</span>
									<span class="s4">return</span><span class="s3">;</span>
								<span class="s3">}</span>
								<span class="s1">callback</span><span class="s3">();</span>
							<span class="s3">}</span>
						<span class="s3">};</span>
					<span class="s4">case </span><span class="s2">&quot;async&quot;</span><span class="s3">:</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">additionalAssetsFn</span><span class="s3">) {</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">processAdditionalAssets</span><span class="s3">.</span><span class="s1">tapAsync</span><span class="s3">(</span>
								<span class="s1">name</span><span class="s3">,</span>
								<span class="s3">(</span><span class="s1">assets</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) =&gt; {</span>
									<span class="s4">if </span><span class="s3">(</span><span class="s1">processedAssets</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">))</span>
										<span class="s4">return </span><span class="s1">additionalAssetsFn</span><span class="s3">(</span><span class="s1">assets</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">);</span>
									<span class="s1">callback</span><span class="s3">();</span>
								<span class="s3">}</span>
							<span class="s3">);</span>
						<span class="s3">}</span>
						<span class="s4">return </span><span class="s3">{</span>
							<span class="s1">...remainingTap</span><span class="s3">,</span>
							<span class="s1">fn</span><span class="s3">: (</span><span class="s1">assets</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) =&gt; {</span>
								<span class="s1">fn</span><span class="s3">(</span><span class="s1">assets</span><span class="s3">, </span><span class="s1">err </span><span class="s3">=&gt; {</span>
									<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) </span><span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
									<span class="s4">if </span><span class="s3">(</span><span class="s1">processedAssets </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">)</span>
										<span class="s1">processedAssets</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">);</span>
									<span class="s4">const </span><span class="s1">newAssets </span><span class="s3">= </span><span class="s1">popNewAssets</span><span class="s3">(</span><span class="s1">assets</span><span class="s3">);</span>
									<span class="s4">if </span><span class="s3">(</span><span class="s1">newAssets </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
										<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">processAdditionalAssets</span><span class="s3">.</span><span class="s1">callAsync</span><span class="s3">(</span>
											<span class="s1">newAssets</span><span class="s3">,</span>
											<span class="s1">callback</span>
										<span class="s3">);</span>
										<span class="s4">return</span><span class="s3">;</span>
									<span class="s3">}</span>
									<span class="s1">callback</span><span class="s3">();</span>
								<span class="s3">});</span>
							<span class="s3">}</span>
						<span class="s3">};</span>
					<span class="s4">case </span><span class="s2">&quot;promise&quot;</span><span class="s3">:</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">additionalAssetsFn</span><span class="s3">) {</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">processAdditionalAssets</span><span class="s3">.</span><span class="s1">tapPromise</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">assets </span><span class="s3">=&gt; {</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">processedAssets</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">))</span>
									<span class="s4">return </span><span class="s1">additionalAssetsFn</span><span class="s3">(</span><span class="s1">assets</span><span class="s3">);</span>
								<span class="s4">return </span><span class="s1">Promise</span><span class="s3">.</span><span class="s1">resolve</span><span class="s3">();</span>
							<span class="s3">});</span>
						<span class="s3">}</span>
						<span class="s4">return </span><span class="s3">{</span>
							<span class="s1">...remainingTap</span><span class="s3">,</span>
							<span class="s1">fn</span><span class="s3">: </span><span class="s1">assets </span><span class="s3">=&gt; {</span>
								<span class="s4">const </span><span class="s1">p </span><span class="s3">= </span><span class="s1">fn</span><span class="s3">(</span><span class="s1">assets</span><span class="s3">);</span>
								<span class="s4">if </span><span class="s3">(!</span><span class="s1">p </span><span class="s3">|| !</span><span class="s1">p</span><span class="s3">.</span><span class="s1">then</span><span class="s3">) </span><span class="s4">return </span><span class="s1">p</span><span class="s3">;</span>
								<span class="s4">return </span><span class="s1">p</span><span class="s3">.</span><span class="s1">then</span><span class="s3">(() =&gt; {</span>
									<span class="s4">if </span><span class="s3">(</span><span class="s1">processedAssets </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">)</span>
										<span class="s1">processedAssets</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">);</span>
									<span class="s4">const </span><span class="s1">newAssets </span><span class="s3">= </span><span class="s1">popNewAssets</span><span class="s3">(</span><span class="s1">assets</span><span class="s3">);</span>
									<span class="s4">if </span><span class="s3">(</span><span class="s1">newAssets </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
										<span class="s4">return this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">processAdditionalAssets</span><span class="s3">.</span><span class="s1">promise</span><span class="s3">(</span>
											<span class="s1">newAssets</span>
										<span class="s3">);</span>
									<span class="s3">}</span>
								<span class="s3">});</span>
							<span class="s3">}</span>
						<span class="s3">};</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">});</span>

		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[CompilationAssets]&gt;} */</span>
		<span class="s4">const </span><span class="s1">afterProcessAssetsHook </span><span class="s3">= </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;assets&quot;</span><span class="s3">]);</span>

		<span class="s5">/**</span>
		 <span class="s5">* </span><span class="s6">@template </span><span class="s5">T</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} name name of the hook</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} stage new stage</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{function(): AsArray&lt;T&gt;} getArgs get old hook function args</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string=} code deprecation code (not deprecated when unset)</span>
		 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{FakeHook&lt;Pick&lt;AsyncSeriesHook&lt;T&gt;, &quot;tap&quot; | &quot;tapAsync&quot; | &quot;tapPromise&quot; | &quot;name&quot;&gt;&gt;} fake hook which redirects</span>
		 <span class="s5">*/</span>
		<span class="s4">const </span><span class="s1">createProcessAssetsHook </span><span class="s3">= (</span><span class="s1">name</span><span class="s3">, </span><span class="s1">stage</span><span class="s3">, </span><span class="s1">getArgs</span><span class="s3">, </span><span class="s1">code</span><span class="s3">) =&gt; {</span>
			<span class="s4">if </span><span class="s3">(!</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_backCompat </span><span class="s3">&amp;&amp; </span><span class="s1">code</span><span class="s3">) </span><span class="s4">return </span><span class="s1">undefined</span><span class="s3">;</span>
			<span class="s4">const </span><span class="s1">errorMessage </span><span class="s3">=</span>
				<span class="s1">reason </span><span class="s3">=&gt; </span><span class="s2">`Can't automatically convert plugin using Compilation.hooks.</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">} </span><span class="s2">to Compilation.hooks.processAssets because </span><span class="s1">$</span><span class="s3">{</span><span class="s1">reason</span><span class="s3">}</span><span class="s2">. 
BREAKING CHANGE: Asset processing hooks in Compilation has been merged into a single Compilation.hooks.processAssets hook.`</span><span class="s3">;</span>
			<span class="s4">const </span><span class="s1">getOptions </span><span class="s3">= </span><span class="s1">options </span><span class="s3">=&gt; {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">options </span><span class="s3">=== </span><span class="s2">&quot;string&quot;</span><span class="s3">) </span><span class="s1">options </span><span class="s3">= { </span><span class="s1">name</span><span class="s3">: </span><span class="s1">options </span><span class="s3">};</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">stage</span><span class="s3">) {</span>
					<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span><span class="s1">errorMessage</span><span class="s3">(</span><span class="s2">&quot;it's using the 'stage' option&quot;</span><span class="s3">));</span>
				<span class="s3">}</span>
				<span class="s4">return </span><span class="s3">{ </span><span class="s1">...options</span><span class="s3">, </span><span class="s1">stage</span><span class="s3">: </span><span class="s1">stage </span><span class="s3">};</span>
			<span class="s3">};</span>
			<span class="s4">return </span><span class="s1">createFakeHook</span><span class="s3">(</span>
				<span class="s3">{</span>
					<span class="s1">name</span><span class="s3">,</span>
					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AsyncSeriesHook&lt;T&gt;[&quot;intercept&quot;]} */</span>
					<span class="s1">intercept</span><span class="s3">(</span><span class="s1">interceptor</span><span class="s3">) {</span>
						<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span><span class="s1">errorMessage</span><span class="s3">(</span><span class="s2">&quot;it's using 'intercept'&quot;</span><span class="s3">));</span>
					<span class="s3">},</span>
					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AsyncSeriesHook&lt;T&gt;[&quot;tap&quot;]} */</span>
					<span class="s1">tap</span><span class="s3">: (</span><span class="s1">options</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">) =&gt; {</span>
						<span class="s1">processAssetsHook</span><span class="s3">.</span><span class="s1">tap</span><span class="s3">(</span><span class="s1">getOptions</span><span class="s3">(</span><span class="s1">options</span><span class="s3">), () =&gt; </span><span class="s1">fn</span><span class="s3">(</span><span class="s1">...getArgs</span><span class="s3">()));</span>
					<span class="s3">},</span>
					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AsyncSeriesHook&lt;T&gt;[&quot;tapAsync&quot;]} */</span>
					<span class="s1">tapAsync</span><span class="s3">: (</span><span class="s1">options</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">) =&gt; {</span>
						<span class="s1">processAssetsHook</span><span class="s3">.</span><span class="s1">tapAsync</span><span class="s3">(</span>
							<span class="s1">getOptions</span><span class="s3">(</span><span class="s1">options</span><span class="s3">),</span>
							<span class="s3">(</span><span class="s1">assets</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) =&gt;</span>
								<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{any} */ </span><span class="s3">(</span><span class="s1">fn</span><span class="s3">)(</span><span class="s1">...getArgs</span><span class="s3">(), </span><span class="s1">callback</span><span class="s3">)</span>
						<span class="s3">);</span>
					<span class="s3">},</span>
					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AsyncSeriesHook&lt;T&gt;[&quot;tapPromise&quot;]} */</span>
					<span class="s1">tapPromise</span><span class="s3">: (</span><span class="s1">options</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">) =&gt; {</span>
						<span class="s1">processAssetsHook</span><span class="s3">.</span><span class="s1">tapPromise</span><span class="s3">(</span><span class="s1">getOptions</span><span class="s3">(</span><span class="s1">options</span><span class="s3">), () =&gt;</span>
							<span class="s1">fn</span><span class="s3">(</span><span class="s1">...getArgs</span><span class="s3">())</span>
						<span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">},</span>
				<span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">} </span><span class="s2">is deprecated (use Compilation.hooks.processAssets instead and use one of Compilation.PROCESS_ASSETS_STAGE_* as stage option)`</span><span class="s3">,</span>
				<span class="s1">code</span>
			<span class="s3">);</span>
		<span class="s3">};</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">freeze</span><span class="s3">({</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Module]&gt;} */</span>
			<span class="s1">buildModule</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;module&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Module]&gt;} */</span>
			<span class="s1">rebuildModule</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;module&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Module, WebpackError]&gt;} */</span>
			<span class="s1">failedModule</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;module&quot;</span><span class="s3">, </span><span class="s2">&quot;error&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Module]&gt;} */</span>
			<span class="s1">succeedModule</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;module&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Module]&gt;} */</span>
			<span class="s1">stillValidModule</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;module&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Dependency, EntryOptions]&gt;} */</span>
			<span class="s1">addEntry</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;entry&quot;</span><span class="s3">, </span><span class="s2">&quot;options&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Dependency, EntryOptions, Error]&gt;} */</span>
			<span class="s1">failedEntry</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;entry&quot;</span><span class="s3">, </span><span class="s2">&quot;options&quot;</span><span class="s3">, </span><span class="s2">&quot;error&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Dependency, EntryOptions, Module]&gt;} */</span>
			<span class="s1">succeedEntry</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;entry&quot;</span><span class="s3">, </span><span class="s2">&quot;options&quot;</span><span class="s3">, </span><span class="s2">&quot;module&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncWaterfallHook&lt;[(string[] | ReferencedExport)[], Dependency, RuntimeSpec]&gt;} */</span>
			<span class="s1">dependencyReferencedExports</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncWaterfallHook</span><span class="s3">([</span>
				<span class="s2">&quot;referencedExports&quot;</span><span class="s3">,</span>
				<span class="s2">&quot;dependency&quot;</span><span class="s3">,</span>
				<span class="s2">&quot;runtime&quot;</span>
			<span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[ExecuteModuleArgument, ExecuteModuleContext]&gt;} */</span>
			<span class="s1">executeModule</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;options&quot;</span><span class="s3">, </span><span class="s2">&quot;context&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AsyncParallelHook&lt;[ExecuteModuleArgument, ExecuteModuleContext]&gt;} */</span>
			<span class="s1">prepareModuleExecution</span><span class="s3">: </span><span class="s4">new </span><span class="s1">AsyncParallelHook</span><span class="s3">([</span><span class="s2">&quot;options&quot;</span><span class="s3">, </span><span class="s2">&quot;context&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AsyncSeriesHook&lt;[Iterable&lt;Module&gt;]&gt;} */</span>
			<span class="s1">finishModules</span><span class="s3">: </span><span class="s4">new </span><span class="s1">AsyncSeriesHook</span><span class="s3">([</span><span class="s2">&quot;modules&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AsyncSeriesHook&lt;[Module]&gt;} */</span>
			<span class="s1">finishRebuildingModule</span><span class="s3">: </span><span class="s4">new </span><span class="s1">AsyncSeriesHook</span><span class="s3">([</span><span class="s2">&quot;module&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[]&gt;} */</span>
			<span class="s1">unseal</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[]&gt;} */</span>
			<span class="s1">seal</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[]&gt;} */</span>
			<span class="s1">beforeChunks</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([]),</span>
			<span class="s5">/**</span>
			 <span class="s5">* The `afterChunks` hook is called directly after the chunks and module graph have</span>
			 <span class="s5">* been created and before the chunks and modules have been optimized. This hook is useful to</span>
			 <span class="s5">* inspect, analyze, and/or modify the chunk graph.</span>
			 <span class="s5">* </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Chunk&gt;]&gt;}</span>
			 <span class="s5">*/</span>
			<span class="s1">afterChunks</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;chunks&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncBailHook&lt;[Iterable&lt;Module&gt;]&gt;} */</span>
			<span class="s1">optimizeDependencies</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncBailHook</span><span class="s3">([</span><span class="s2">&quot;modules&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Module&gt;]&gt;} */</span>
			<span class="s1">afterOptimizeDependencies</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;modules&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[]&gt;} */</span>
			<span class="s1">optimize</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncBailHook&lt;[Iterable&lt;Module&gt;]&gt;} */</span>
			<span class="s1">optimizeModules</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncBailHook</span><span class="s3">([</span><span class="s2">&quot;modules&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Module&gt;]&gt;} */</span>
			<span class="s1">afterOptimizeModules</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;modules&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncBailHook&lt;[Iterable&lt;Chunk&gt;, ChunkGroup[]]&gt;} */</span>
			<span class="s1">optimizeChunks</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncBailHook</span><span class="s3">([</span><span class="s2">&quot;chunks&quot;</span><span class="s3">, </span><span class="s2">&quot;chunkGroups&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Chunk&gt;, ChunkGroup[]]&gt;} */</span>
			<span class="s1">afterOptimizeChunks</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;chunks&quot;</span><span class="s3">, </span><span class="s2">&quot;chunkGroups&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AsyncSeriesHook&lt;[Iterable&lt;Chunk&gt;, Iterable&lt;Module&gt;]&gt;} */</span>
			<span class="s1">optimizeTree</span><span class="s3">: </span><span class="s4">new </span><span class="s1">AsyncSeriesHook</span><span class="s3">([</span><span class="s2">&quot;chunks&quot;</span><span class="s3">, </span><span class="s2">&quot;modules&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Chunk&gt;, Iterable&lt;Module&gt;]&gt;} */</span>
			<span class="s1">afterOptimizeTree</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;chunks&quot;</span><span class="s3">, </span><span class="s2">&quot;modules&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AsyncSeriesBailHook&lt;[Iterable&lt;Chunk&gt;, Iterable&lt;Module&gt;]&gt;} */</span>
			<span class="s1">optimizeChunkModules</span><span class="s3">: </span><span class="s4">new </span><span class="s1">AsyncSeriesBailHook</span><span class="s3">([</span><span class="s2">&quot;chunks&quot;</span><span class="s3">, </span><span class="s2">&quot;modules&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Chunk&gt;, Iterable&lt;Module&gt;]&gt;} */</span>
			<span class="s1">afterOptimizeChunkModules</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;chunks&quot;</span><span class="s3">, </span><span class="s2">&quot;modules&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncBailHook&lt;[], boolean | undefined&gt;} */</span>
			<span class="s1">shouldRecord</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncBailHook</span><span class="s3">([]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Chunk, Set&lt;string&gt;, RuntimeRequirementsContext]&gt;} */</span>
			<span class="s1">additionalChunkRuntimeRequirements</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span>
				<span class="s2">&quot;chunk&quot;</span><span class="s3">,</span>
				<span class="s2">&quot;runtimeRequirements&quot;</span><span class="s3">,</span>
				<span class="s2">&quot;context&quot;</span>
			<span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{HookMap&lt;SyncBailHook&lt;[Chunk, Set&lt;string&gt;, RuntimeRequirementsContext]&gt;&gt;} */</span>
			<span class="s1">runtimeRequirementInChunk</span><span class="s3">: </span><span class="s4">new </span><span class="s1">HookMap</span><span class="s3">(</span>
				<span class="s3">() =&gt; </span><span class="s4">new </span><span class="s1">SyncBailHook</span><span class="s3">([</span><span class="s2">&quot;chunk&quot;</span><span class="s3">, </span><span class="s2">&quot;runtimeRequirements&quot;</span><span class="s3">, </span><span class="s2">&quot;context&quot;</span><span class="s3">])</span>
			<span class="s3">),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Module, Set&lt;string&gt;, RuntimeRequirementsContext]&gt;} */</span>
			<span class="s1">additionalModuleRuntimeRequirements</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span>
				<span class="s2">&quot;module&quot;</span><span class="s3">,</span>
				<span class="s2">&quot;runtimeRequirements&quot;</span><span class="s3">,</span>
				<span class="s2">&quot;context&quot;</span>
			<span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{HookMap&lt;SyncBailHook&lt;[Module, Set&lt;string&gt;, RuntimeRequirementsContext]&gt;&gt;} */</span>
			<span class="s1">runtimeRequirementInModule</span><span class="s3">: </span><span class="s4">new </span><span class="s1">HookMap</span><span class="s3">(</span>
				<span class="s3">() =&gt; </span><span class="s4">new </span><span class="s1">SyncBailHook</span><span class="s3">([</span><span class="s2">&quot;module&quot;</span><span class="s3">, </span><span class="s2">&quot;runtimeRequirements&quot;</span><span class="s3">, </span><span class="s2">&quot;context&quot;</span><span class="s3">])</span>
			<span class="s3">),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Chunk, Set&lt;string&gt;, RuntimeRequirementsContext]&gt;} */</span>
			<span class="s1">additionalTreeRuntimeRequirements</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span>
				<span class="s2">&quot;chunk&quot;</span><span class="s3">,</span>
				<span class="s2">&quot;runtimeRequirements&quot;</span><span class="s3">,</span>
				<span class="s2">&quot;context&quot;</span>
			<span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{HookMap&lt;SyncBailHook&lt;[Chunk, Set&lt;string&gt;, RuntimeRequirementsContext]&gt;&gt;} */</span>
			<span class="s1">runtimeRequirementInTree</span><span class="s3">: </span><span class="s4">new </span><span class="s1">HookMap</span><span class="s3">(</span>
				<span class="s3">() =&gt; </span><span class="s4">new </span><span class="s1">SyncBailHook</span><span class="s3">([</span><span class="s2">&quot;chunk&quot;</span><span class="s3">, </span><span class="s2">&quot;runtimeRequirements&quot;</span><span class="s3">, </span><span class="s2">&quot;context&quot;</span><span class="s3">])</span>
			<span class="s3">),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[RuntimeModule, Chunk]&gt;} */</span>
			<span class="s1">runtimeModule</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;module&quot;</span><span class="s3">, </span><span class="s2">&quot;chunk&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Module&gt;, any]&gt;} */</span>
			<span class="s1">reviveModules</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;modules&quot;</span><span class="s3">, </span><span class="s2">&quot;records&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Module&gt;]&gt;} */</span>
			<span class="s1">beforeModuleIds</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;modules&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Module&gt;]&gt;} */</span>
			<span class="s1">moduleIds</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;modules&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Module&gt;]&gt;} */</span>
			<span class="s1">optimizeModuleIds</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;modules&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Module&gt;]&gt;} */</span>
			<span class="s1">afterOptimizeModuleIds</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;modules&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Chunk&gt;, any]&gt;} */</span>
			<span class="s1">reviveChunks</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;chunks&quot;</span><span class="s3">, </span><span class="s2">&quot;records&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Chunk&gt;]&gt;} */</span>
			<span class="s1">beforeChunkIds</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;chunks&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Chunk&gt;]&gt;} */</span>
			<span class="s1">chunkIds</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;chunks&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Chunk&gt;]&gt;} */</span>
			<span class="s1">optimizeChunkIds</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;chunks&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Chunk&gt;]&gt;} */</span>
			<span class="s1">afterOptimizeChunkIds</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;chunks&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Module&gt;, any]&gt;} */</span>
			<span class="s1">recordModules</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;modules&quot;</span><span class="s3">, </span><span class="s2">&quot;records&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Chunk&gt;, any]&gt;} */</span>
			<span class="s1">recordChunks</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;chunks&quot;</span><span class="s3">, </span><span class="s2">&quot;records&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Iterable&lt;Module&gt;]&gt;} */</span>
			<span class="s1">optimizeCodeGeneration</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;modules&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[]&gt;} */</span>
			<span class="s1">beforeModuleHash</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[]&gt;} */</span>
			<span class="s1">afterModuleHash</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[]&gt;} */</span>
			<span class="s1">beforeCodeGeneration</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[]&gt;} */</span>
			<span class="s1">afterCodeGeneration</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[]&gt;} */</span>
			<span class="s1">beforeRuntimeRequirements</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[]&gt;} */</span>
			<span class="s1">afterRuntimeRequirements</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[]&gt;} */</span>
			<span class="s1">beforeHash</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Chunk]&gt;} */</span>
			<span class="s1">contentHash</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;chunk&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[]&gt;} */</span>
			<span class="s1">afterHash</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[any]&gt;} */</span>
			<span class="s1">recordHash</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;records&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Compilation, any]&gt;} */</span>
			<span class="s1">record</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;compilation&quot;</span><span class="s3">, </span><span class="s2">&quot;records&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[]&gt;} */</span>
			<span class="s1">beforeModuleAssets</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncBailHook&lt;[], boolean&gt;} */</span>
			<span class="s1">shouldGenerateChunkAssets</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncBailHook</span><span class="s3">([]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[]&gt;} */</span>
			<span class="s1">beforeChunkAssets</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([]),</span>
			<span class="s0">// TODO webpack 6 remove</span>
			<span class="s5">/** </span><span class="s6">@deprecated </span><span class="s5">*/</span>
			<span class="s1">additionalChunkAssets</span><span class="s3">: </span><span class="s1">createProcessAssetsHook</span><span class="s3">(</span>
				<span class="s2">&quot;additionalChunkAssets&quot;</span><span class="s3">,</span>
				<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_ADDITIONAL</span><span class="s3">,</span>
				<span class="s3">() =&gt; [</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">],</span>
				<span class="s2">&quot;DEP_WEBPACK_COMPILATION_ADDITIONAL_CHUNK_ASSETS&quot;</span>
			<span class="s3">),</span>

			<span class="s0">// TODO webpack 6 deprecate</span>
			<span class="s5">/** </span><span class="s6">@deprecated </span><span class="s5">*/</span>
			<span class="s1">additionalAssets</span><span class="s3">: </span><span class="s1">createProcessAssetsHook</span><span class="s3">(</span>
				<span class="s2">&quot;additionalAssets&quot;</span><span class="s3">,</span>
				<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_ADDITIONAL</span><span class="s3">,</span>
				<span class="s3">() =&gt; []</span>
			<span class="s3">),</span>
			<span class="s0">// TODO webpack 6 remove</span>
			<span class="s5">/** </span><span class="s6">@deprecated </span><span class="s5">*/</span>
			<span class="s1">optimizeChunkAssets</span><span class="s3">: </span><span class="s1">createProcessAssetsHook</span><span class="s3">(</span>
				<span class="s2">&quot;optimizeChunkAssets&quot;</span><span class="s3">,</span>
				<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_OPTIMIZE</span><span class="s3">,</span>
				<span class="s3">() =&gt; [</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">],</span>
				<span class="s2">&quot;DEP_WEBPACK_COMPILATION_OPTIMIZE_CHUNK_ASSETS&quot;</span>
			<span class="s3">),</span>
			<span class="s0">// TODO webpack 6 remove</span>
			<span class="s5">/** </span><span class="s6">@deprecated </span><span class="s5">*/</span>
			<span class="s1">afterOptimizeChunkAssets</span><span class="s3">: </span><span class="s1">createProcessAssetsHook</span><span class="s3">(</span>
				<span class="s2">&quot;afterOptimizeChunkAssets&quot;</span><span class="s3">,</span>
				<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_OPTIMIZE </span><span class="s3">+ </span><span class="s7">1</span><span class="s3">,</span>
				<span class="s3">() =&gt; [</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">],</span>
				<span class="s2">&quot;DEP_WEBPACK_COMPILATION_AFTER_OPTIMIZE_CHUNK_ASSETS&quot;</span>
			<span class="s3">),</span>
			<span class="s0">// TODO webpack 6 deprecate</span>
			<span class="s5">/** </span><span class="s6">@deprecated </span><span class="s5">*/</span>
			<span class="s1">optimizeAssets</span><span class="s3">: </span><span class="s1">processAssetsHook</span><span class="s3">,</span>
			<span class="s0">// TODO webpack 6 deprecate</span>
			<span class="s5">/** </span><span class="s6">@deprecated </span><span class="s5">*/</span>
			<span class="s1">afterOptimizeAssets</span><span class="s3">: </span><span class="s1">afterProcessAssetsHook</span><span class="s3">,</span>

			<span class="s1">processAssets</span><span class="s3">: </span><span class="s1">processAssetsHook</span><span class="s3">,</span>
			<span class="s1">afterProcessAssets</span><span class="s3">: </span><span class="s1">afterProcessAssetsHook</span><span class="s3">,</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AsyncSeriesHook&lt;[CompilationAssets]&gt;} */</span>
			<span class="s1">processAdditionalAssets</span><span class="s3">: </span><span class="s4">new </span><span class="s1">AsyncSeriesHook</span><span class="s3">([</span><span class="s2">&quot;assets&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncBailHook&lt;[], boolean&gt;} */</span>
			<span class="s1">needAdditionalSeal</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncBailHook</span><span class="s3">([]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AsyncSeriesHook&lt;[]&gt;} */</span>
			<span class="s1">afterSeal</span><span class="s3">: </span><span class="s4">new </span><span class="s1">AsyncSeriesHook</span><span class="s3">([]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncWaterfallHook&lt;[RenderManifestEntry[], RenderManifestOptions]&gt;} */</span>
			<span class="s1">renderManifest</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncWaterfallHook</span><span class="s3">([</span><span class="s2">&quot;result&quot;</span><span class="s3">, </span><span class="s2">&quot;options&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Hash]&gt;} */</span>
			<span class="s1">fullHash</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;hash&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Chunk, Hash, ChunkHashContext]&gt;} */</span>
			<span class="s1">chunkHash</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;chunk&quot;</span><span class="s3">, </span><span class="s2">&quot;chunkHash&quot;</span><span class="s3">, </span><span class="s2">&quot;ChunkHashContext&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Module, string]&gt;} */</span>
			<span class="s1">moduleAsset</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;module&quot;</span><span class="s3">, </span><span class="s2">&quot;filename&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Chunk, string]&gt;} */</span>
			<span class="s1">chunkAsset</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;chunk&quot;</span><span class="s3">, </span><span class="s2">&quot;filename&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncWaterfallHook&lt;[string, object, AssetInfo]&gt;} */</span>
			<span class="s1">assetPath</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncWaterfallHook</span><span class="s3">([</span><span class="s2">&quot;path&quot;</span><span class="s3">, </span><span class="s2">&quot;options&quot;</span><span class="s3">, </span><span class="s2">&quot;assetInfo&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncBailHook&lt;[], boolean&gt;} */</span>
			<span class="s1">needAdditionalPass</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncBailHook</span><span class="s3">([]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Compiler, string, number]&gt;} */</span>
			<span class="s1">childCompiler</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span>
				<span class="s2">&quot;childCompiler&quot;</span><span class="s3">,</span>
				<span class="s2">&quot;compilerName&quot;</span><span class="s3">,</span>
				<span class="s2">&quot;compilerIndex&quot;</span>
			<span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncBailHook&lt;[string, LogEntry], true&gt;} */</span>
			<span class="s1">log</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncBailHook</span><span class="s3">([</span><span class="s2">&quot;origin&quot;</span><span class="s3">, </span><span class="s2">&quot;logEntry&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncWaterfallHook&lt;[WebpackError[]]&gt;} */</span>
			<span class="s1">processWarnings</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncWaterfallHook</span><span class="s3">([</span><span class="s2">&quot;warnings&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncWaterfallHook&lt;[WebpackError[]]&gt;} */</span>
			<span class="s1">processErrors</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncWaterfallHook</span><span class="s3">([</span><span class="s2">&quot;errors&quot;</span><span class="s3">]),</span>

			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{HookMap&lt;SyncHook&lt;[Partial&lt;NormalizedStatsOptions&gt;, CreateStatsOptionsContext]&gt;&gt;} */</span>
			<span class="s1">statsPreset</span><span class="s3">: </span><span class="s4">new </span><span class="s1">HookMap</span><span class="s3">(() =&gt; </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;options&quot;</span><span class="s3">, </span><span class="s2">&quot;context&quot;</span><span class="s3">])),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[Partial&lt;NormalizedStatsOptions&gt;, CreateStatsOptionsContext]&gt;} */</span>
			<span class="s1">statsNormalize</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;options&quot;</span><span class="s3">, </span><span class="s2">&quot;context&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[StatsFactory, NormalizedStatsOptions]&gt;} */</span>
			<span class="s1">statsFactory</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;statsFactory&quot;</span><span class="s3">, </span><span class="s2">&quot;options&quot;</span><span class="s3">]),</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SyncHook&lt;[StatsPrinter, NormalizedStatsOptions]&gt;} */</span>
			<span class="s1">statsPrinter</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncHook</span><span class="s3">([</span><span class="s2">&quot;statsPrinter&quot;</span><span class="s3">, </span><span class="s2">&quot;options&quot;</span><span class="s3">]),</span>

			<span class="s1">get normalModuleLoader</span><span class="s3">() {</span>
				<span class="s4">return </span><span class="s1">getNormalModuleLoader</span><span class="s3">();</span>
			<span class="s3">}</span>
		<span class="s3">});</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string=} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">startTime </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">endTime </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Compiler} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">compiler </span><span class="s3">= </span><span class="s1">compiler</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">resolverFactory </span><span class="s3">= </span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">resolverFactory</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">inputFileSystem </span><span class="s3">= </span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">inputFileSystem</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">fileSystemInfo </span><span class="s3">= </span><span class="s4">new </span><span class="s1">FileSystemInfo</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">inputFileSystem</span><span class="s3">, {</span>
			<span class="s1">managedPaths</span><span class="s3">: </span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">managedPaths</span><span class="s3">,</span>
			<span class="s1">immutablePaths</span><span class="s3">: </span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">immutablePaths</span><span class="s3">,</span>
			<span class="s1">logger</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">getLogger</span><span class="s3">(</span><span class="s2">&quot;webpack.FileSystemInfo&quot;</span><span class="s3">),</span>
			<span class="s1">hashFunction</span><span class="s3">: </span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">output</span><span class="s3">.</span><span class="s1">hashFunction</span>
		<span class="s3">});</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">fileTimestamps</span><span class="s3">) {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">fileSystemInfo</span><span class="s3">.</span><span class="s1">addFileTimestamps</span><span class="s3">(</span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">fileTimestamps</span><span class="s3">, </span><span class="s4">true</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">contextTimestamps</span><span class="s3">) {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">fileSystemInfo</span><span class="s3">.</span><span class="s1">addContextTimestamps</span><span class="s3">(</span>
				<span class="s1">compiler</span><span class="s3">.</span><span class="s1">contextTimestamps</span><span class="s3">,</span>
				<span class="s4">true</span>
			<span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, string | Set&lt;string&gt;&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">valueCacheVersions </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">requestShortener </span><span class="s3">= </span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">requestShortener</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">compilerPath </span><span class="s3">= </span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">compilerPath</span><span class="s3">;</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">getLogger</span><span class="s3">(</span><span class="s2">&quot;webpack.Compilation&quot;</span><span class="s3">);</span>

		<span class="s4">const </span><span class="s1">options </span><span class="s3">= </span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">options</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">options </span><span class="s3">= </span><span class="s1">options</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">outputOptions </span><span class="s3">= </span><span class="s1">options </span><span class="s3">&amp;&amp; </span><span class="s1">options</span><span class="s3">.</span><span class="s1">output</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{boolean} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">bail </span><span class="s3">= (</span><span class="s1">options </span><span class="s3">&amp;&amp; </span><span class="s1">options</span><span class="s3">.</span><span class="s1">bail</span><span class="s3">) || </span><span class="s4">false</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{boolean} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">profile </span><span class="s3">= (</span><span class="s1">options </span><span class="s3">&amp;&amp; </span><span class="s1">options</span><span class="s3">.</span><span class="s1">profile</span><span class="s3">) || </span><span class="s4">false</span><span class="s3">;</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">params </span><span class="s3">= </span><span class="s1">params</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">mainTemplate </span><span class="s3">= </span><span class="s4">new </span><span class="s1">MainTemplate</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">outputOptions</span><span class="s3">, </span><span class="s4">this</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">chunkTemplate </span><span class="s3">= </span><span class="s4">new </span><span class="s1">ChunkTemplate</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">outputOptions</span><span class="s3">, </span><span class="s4">this</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">runtimeTemplate </span><span class="s3">= </span><span class="s4">new </span><span class="s1">RuntimeTemplate</span><span class="s3">(</span>
			<span class="s4">this</span><span class="s3">,</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">outputOptions</span><span class="s3">,</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">requestShortener</span>
		<span class="s3">);</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{{javascript: ModuleTemplate}} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleTemplates </span><span class="s3">= {</span>
			<span class="s1">javascript</span><span class="s3">: </span><span class="s4">new </span><span class="s1">ModuleTemplate</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">runtimeTemplate</span><span class="s3">, </span><span class="s4">this</span><span class="s3">)</span>
		<span class="s3">};</span>
		<span class="s1">defineRemovedModuleTemplates</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleTemplates</span><span class="s3">);</span>

		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;Module, WeakTupleMap&lt;any, any&gt;&gt; | undefined} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleMemCaches </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;Module, WeakTupleMap&lt;any, any&gt;&gt; | undefined} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleMemCaches2 </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph </span><span class="s3">= </span><span class="s4">new </span><span class="s1">ModuleGraph</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ChunkGraph} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{CodeGenerationResults} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">codeGenerationResults </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>

		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AsyncQueue&lt;Module, Module, Module&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">processDependenciesQueue </span><span class="s3">= </span><span class="s4">new </span><span class="s1">AsyncQueue</span><span class="s3">({</span>
			<span class="s1">name</span><span class="s3">: </span><span class="s2">&quot;processDependencies&quot;</span><span class="s3">,</span>
			<span class="s1">parallelism</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">parallelism </span><span class="s3">|| </span><span class="s7">100</span><span class="s3">,</span>
			<span class="s1">processor</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_processModuleDependencies</span><span class="s3">.</span><span class="s1">bind</span><span class="s3">(</span><span class="s4">this</span><span class="s3">)</span>
		<span class="s3">});</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AsyncQueue&lt;Module, string, Module&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">addModuleQueue </span><span class="s3">= </span><span class="s4">new </span><span class="s1">AsyncQueue</span><span class="s3">({</span>
			<span class="s1">name</span><span class="s3">: </span><span class="s2">&quot;addModule&quot;</span><span class="s3">,</span>
			<span class="s1">parent</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">processDependenciesQueue</span><span class="s3">,</span>
			<span class="s1">getKey</span><span class="s3">: </span><span class="s1">module </span><span class="s3">=&gt; </span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">(),</span>
			<span class="s1">processor</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_addModule</span><span class="s3">.</span><span class="s1">bind</span><span class="s3">(</span><span class="s4">this</span><span class="s3">)</span>
		<span class="s3">});</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AsyncQueue&lt;FactorizeModuleOptions, string, Module | ModuleFactoryResult&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">factorizeQueue </span><span class="s3">= </span><span class="s4">new </span><span class="s1">AsyncQueue</span><span class="s3">({</span>
			<span class="s1">name</span><span class="s3">: </span><span class="s2">&quot;factorize&quot;</span><span class="s3">,</span>
			<span class="s1">parent</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">addModuleQueue</span><span class="s3">,</span>
			<span class="s1">processor</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_factorizeModule</span><span class="s3">.</span><span class="s1">bind</span><span class="s3">(</span><span class="s4">this</span><span class="s3">)</span>
		<span class="s3">});</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AsyncQueue&lt;Module, Module, Module&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">buildQueue </span><span class="s3">= </span><span class="s4">new </span><span class="s1">AsyncQueue</span><span class="s3">({</span>
			<span class="s1">name</span><span class="s3">: </span><span class="s2">&quot;build&quot;</span><span class="s3">,</span>
			<span class="s1">parent</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">factorizeQueue</span><span class="s3">,</span>
			<span class="s1">processor</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_buildModule</span><span class="s3">.</span><span class="s1">bind</span><span class="s3">(</span><span class="s4">this</span><span class="s3">)</span>
		<span class="s3">});</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AsyncQueue&lt;Module, Module, Module&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">rebuildQueue </span><span class="s3">= </span><span class="s4">new </span><span class="s1">AsyncQueue</span><span class="s3">({</span>
			<span class="s1">name</span><span class="s3">: </span><span class="s2">&quot;rebuild&quot;</span><span class="s3">,</span>
			<span class="s1">parallelism</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">parallelism </span><span class="s3">|| </span><span class="s7">100</span><span class="s3">,</span>
			<span class="s1">processor</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_rebuildModule</span><span class="s3">.</span><span class="s1">bind</span><span class="s3">(</span><span class="s4">this</span><span class="s3">)</span>
		<span class="s3">});</span>

		<span class="s5">/**</span>
		 <span class="s5">* Modules in value are building during the build of Module in key.</span>
		 <span class="s5">* Means value blocking key from finishing.</span>
		 <span class="s5">* Needed to detect build cycles.</span>
		 <span class="s5">* </span><span class="s6">@type </span><span class="s5">{WeakMap&lt;Module, Set&lt;Module&gt;&gt;}</span>
		 <span class="s5">*/</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">creatingModuleDuringBuild </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>

		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, EntryData&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">entries </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{EntryData} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">globalEntry </span><span class="s3">= {</span>
			<span class="s1">dependencies</span><span class="s3">: [],</span>
			<span class="s1">includeDependencies</span><span class="s3">: [],</span>
			<span class="s1">options</span><span class="s3">: {</span>
				<span class="s1">name</span><span class="s3">: </span><span class="s1">undefined</span>
			<span class="s3">}</span>
		<span class="s3">};</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, Entrypoint&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">entrypoints </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Entrypoint[]} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">asyncEntrypoints </span><span class="s3">= [];</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;Chunk&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">chunks </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ChunkGroup[]} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGroups </span><span class="s3">= [];</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, ChunkGroup&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">namedChunkGroups </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, Chunk&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">namedChunks </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;Module&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">modules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_backCompat</span><span class="s3">) {</span>
			<span class="s1">arrayToSetDeprecation</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">, </span><span class="s2">&quot;Compilation.chunks&quot;</span><span class="s3">);</span>
			<span class="s1">arrayToSetDeprecation</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">, </span><span class="s2">&quot;Compilation.modules&quot;</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s5">/** </span><span class="s6">@private </span><span class="s5">@type {Map&lt;string, Module&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_modules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">records </span><span class="s3">= </span><span class="s4">null</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string[]} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">additionalChunkAssets </span><span class="s3">= [];</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{CompilationAssets} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">assets </span><span class="s3">= {};</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, AssetInfo&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">assetsInfo </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, Map&lt;string, Set&lt;string&gt;&gt;&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_assetsRelatedIn </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WebpackError[]} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">errors </span><span class="s3">= [];</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WebpackError[]} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">warnings </span><span class="s3">= [];</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Compilation[]} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">children </span><span class="s3">= [];</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, LogEntry[]&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logging </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;DepConstructor, ModuleFactory&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">dependencyFactories </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{DependencyTemplates} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">dependencyTemplates </span><span class="s3">= </span><span class="s4">new </span><span class="s1">DependencyTemplates</span><span class="s3">(</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">outputOptions</span><span class="s3">.</span><span class="s1">hashFunction</span>
		<span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">childrenCounters </span><span class="s3">= {};</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;number|string&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">usedChunkIds </span><span class="s3">= </span><span class="s4">null</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;number&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">usedModuleIds </span><span class="s3">= </span><span class="s4">null</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{boolean} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">needAdditionalPass </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;Module &amp; { restoreFromUnsafeCache: Function }&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_restoredUnsafeCacheModuleEntries </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, Module &amp; { restoreFromUnsafeCache: Function }&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_restoredUnsafeCacheEntries </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WeakSet&lt;Module&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">builtModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakSet</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WeakSet&lt;Module&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">codeGeneratedModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakSet</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WeakSet&lt;Module&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">buildTimeExecutedModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakSet</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@private </span><span class="s5">@type {Map&lt;Module, Callback[]&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_rebuildingModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;string&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">emittedAssets </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;string&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">comparedForEmitAssets </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{LazySet&lt;string&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">fileDependencies </span><span class="s3">= </span><span class="s4">new </span><span class="s1">LazySet</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{LazySet&lt;string&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">contextDependencies </span><span class="s3">= </span><span class="s4">new </span><span class="s1">LazySet</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{LazySet&lt;string&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">missingDependencies </span><span class="s3">= </span><span class="s4">new </span><span class="s1">LazySet</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{LazySet&lt;string&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">buildDependencies </span><span class="s3">= </span><span class="s4">new </span><span class="s1">LazySet</span><span class="s3">();</span>
		<span class="s0">// TODO webpack 6 remove</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">compilationDependencies </span><span class="s3">= {</span>
			<span class="s1">add</span><span class="s3">: </span><span class="s1">util</span><span class="s3">.</span><span class="s1">deprecate</span><span class="s3">(</span>
				<span class="s1">item </span><span class="s3">=&gt; </span><span class="s4">this</span><span class="s3">.</span><span class="s1">fileDependencies</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">item</span><span class="s3">),</span>
				<span class="s2">&quot;Compilation.compilationDependencies is deprecated (used Compilation.fileDependencies instead)&quot;</span><span class="s3">,</span>
				<span class="s2">&quot;DEP_WEBPACK_COMPILATION_COMPILATION_DEPENDENCIES&quot;</span>
			<span class="s3">)</span>
		<span class="s3">};</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">_modulesCache </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">getCache</span><span class="s3">(</span><span class="s2">&quot;Compilation/modules&quot;</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_assetsCache </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">getCache</span><span class="s3">(</span><span class="s2">&quot;Compilation/assets&quot;</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_codeGenerationCache </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">getCache</span><span class="s3">(</span><span class="s2">&quot;Compilation/codeGeneration&quot;</span><span class="s3">);</span>

		<span class="s4">const </span><span class="s1">unsafeCache </span><span class="s3">= </span><span class="s1">options</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">unsafeCache</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_unsafeCache </span><span class="s3">= !!</span><span class="s1">unsafeCache</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_unsafeCachePredicate </span><span class="s3">=</span>
			<span class="s4">typeof </span><span class="s1">unsafeCache </span><span class="s3">=== </span><span class="s2">&quot;function&quot; </span><span class="s3">? </span><span class="s1">unsafeCache </span><span class="s3">: () =&gt; </span><span class="s4">true</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s1">getStats</span><span class="s3">() {</span>
		<span class="s4">return new </span><span class="s1">Stats</span><span class="s3">(</span><span class="s4">this</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{StatsOptions | string} optionsOrPreset stats option value</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{CreateStatsOptionsContext} context context</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{NormalizedStatsOptions} normalized options</span>
	 <span class="s5">*/</span>
	<span class="s1">createStatsOptions</span><span class="s3">(</span><span class="s1">optionsOrPreset</span><span class="s3">, </span><span class="s1">context </span><span class="s3">= {}) {</span>
		<span class="s4">if </span><span class="s3">(</span>
			<span class="s4">typeof </span><span class="s1">optionsOrPreset </span><span class="s3">=== </span><span class="s2">&quot;boolean&quot; </span><span class="s3">||</span>
			<span class="s4">typeof </span><span class="s1">optionsOrPreset </span><span class="s3">=== </span><span class="s2">&quot;string&quot;</span>
		<span class="s3">) {</span>
			<span class="s1">optionsOrPreset </span><span class="s3">= { </span><span class="s1">preset</span><span class="s3">: </span><span class="s1">optionsOrPreset </span><span class="s3">};</span>
		<span class="s3">}</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">optionsOrPreset </span><span class="s3">=== </span><span class="s2">&quot;object&quot; </span><span class="s3">&amp;&amp; </span><span class="s1">optionsOrPreset </span><span class="s3">!== </span><span class="s4">null</span><span class="s3">) {</span>
			<span class="s0">// We use this method of shallow cloning this object to include</span>
			<span class="s0">// properties in the prototype chain</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Partial&lt;NormalizedStatsOptions&gt;} */</span>
			<span class="s4">const </span><span class="s1">options </span><span class="s3">= {};</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">key </span><span class="s4">in </span><span class="s1">optionsOrPreset</span><span class="s3">) {</span>
				<span class="s1">options</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">optionsOrPreset</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">preset </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">statsPreset</span><span class="s3">.</span><span class="s1">for</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">preset</span><span class="s3">).</span><span class="s1">call</span><span class="s3">(</span><span class="s1">options</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">statsNormalize</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">options</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
			<span class="s4">return </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{NormalizedStatsOptions} */ </span><span class="s3">(</span><span class="s1">options</span><span class="s3">);</span>
		<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Partial&lt;NormalizedStatsOptions&gt;} */</span>
			<span class="s4">const </span><span class="s1">options </span><span class="s3">= {};</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">statsNormalize</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">options</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
			<span class="s4">return </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{NormalizedStatsOptions} */ </span><span class="s3">(</span><span class="s1">options</span><span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s1">createStatsFactory</span><span class="s3">(</span><span class="s1">options</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">statsFactory </span><span class="s3">= </span><span class="s4">new </span><span class="s1">StatsFactory</span><span class="s3">();</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">statsFactory</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">statsFactory</span><span class="s3">, </span><span class="s1">options</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">statsFactory</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s1">createStatsPrinter</span><span class="s3">(</span><span class="s1">options</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">statsPrinter </span><span class="s3">= </span><span class="s4">new </span><span class="s1">StatsPrinter</span><span class="s3">();</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">statsPrinter</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">statsPrinter</span><span class="s3">, </span><span class="s1">options</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">statsPrinter</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} name cache name</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{CacheFacade} the cache facade instance</span>
	 <span class="s5">*/</span>
	<span class="s1">getCache</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) {</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">getCache</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string | (function(): string)} name name of the logger, or function called once to get the logger name</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Logger} a logger with that name</span>
	 <span class="s5">*/</span>
	<span class="s1">getLogger</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(!</span><span class="s1">name</span><span class="s3">) {</span>
			<span class="s4">throw new </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s2">&quot;Compilation.getLogger(name) called without a name&quot;</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{LogEntry[] | undefined} */</span>
		<span class="s4">let </span><span class="s1">logEntries</span><span class="s3">;</span>
		<span class="s4">return new </span><span class="s1">Logger</span><span class="s3">(</span>
			<span class="s3">(</span><span class="s1">type</span><span class="s3">, </span><span class="s1">args</span><span class="s3">) =&gt; {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">name </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
					<span class="s1">name </span><span class="s3">= </span><span class="s1">name</span><span class="s3">();</span>
					<span class="s4">if </span><span class="s3">(!</span><span class="s1">name</span><span class="s3">) {</span>
						<span class="s4">throw new </span><span class="s1">TypeError</span><span class="s3">(</span>
							<span class="s2">&quot;Compilation.getLogger(name) called with a function not returning a name&quot;</span>
						<span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
				<span class="s4">let </span><span class="s1">trace</span><span class="s3">;</span>
				<span class="s4">switch </span><span class="s3">(</span><span class="s1">type</span><span class="s3">) {</span>
					<span class="s4">case </span><span class="s1">LogType</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">:</span>
					<span class="s4">case </span><span class="s1">LogType</span><span class="s3">.</span><span class="s1">error</span><span class="s3">:</span>
					<span class="s4">case </span><span class="s1">LogType</span><span class="s3">.</span><span class="s1">trace</span><span class="s3">:</span>
						<span class="s1">trace </span><span class="s3">= </span><span class="s1">ErrorHelpers</span><span class="s3">.</span><span class="s1">cutOffLoaderExecution</span><span class="s3">(</span><span class="s4">new </span><span class="s1">Error</span><span class="s3">(</span><span class="s2">&quot;Trace&quot;</span><span class="s3">).</span><span class="s1">stack</span><span class="s3">)</span>
							<span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s2">&quot;</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s3">)</span>
							<span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">3</span><span class="s3">);</span>
						<span class="s4">break</span><span class="s3">;</span>
				<span class="s3">}</span>
				<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{LogEntry} */</span>
				<span class="s4">const </span><span class="s1">logEntry </span><span class="s3">= {</span>
					<span class="s1">time</span><span class="s3">: </span><span class="s1">Date</span><span class="s3">.</span><span class="s1">now</span><span class="s3">(),</span>
					<span class="s1">type</span><span class="s3">,</span>
					<span class="s1">args</span><span class="s3">,</span>
					<span class="s1">trace</span>
				<span class="s3">};</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">logEntry</span><span class="s3">) === </span><span class="s1">undefined</span><span class="s3">) {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">logEntry</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s1">LogType</span><span class="s3">.</span><span class="s1">profileEnd</span><span class="s3">) {</span>
						<span class="s0">// eslint-disable-next-line node/no-unsupported-features/node-builtins</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">console</span><span class="s3">.</span><span class="s1">profileEnd </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
							<span class="s0">// eslint-disable-next-line node/no-unsupported-features/node-builtins</span>
							<span class="s1">console</span><span class="s3">.</span><span class="s1">profileEnd</span><span class="s3">(</span><span class="s2">`[</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">] </span><span class="s1">$</span><span class="s3">{</span><span class="s1">logEntry</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s7">0</span><span class="s3">]}</span><span class="s2">`</span><span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">logEntries </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
						<span class="s1">logEntries </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">logging</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">logEntries </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
							<span class="s1">logEntries </span><span class="s3">= [];</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">logging</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">logEntries</span><span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
					<span class="s1">logEntries</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">logEntry</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">logEntry</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s1">LogType</span><span class="s3">.</span><span class="s1">profile</span><span class="s3">) {</span>
						<span class="s0">// eslint-disable-next-line node/no-unsupported-features/node-builtins</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">console</span><span class="s3">.</span><span class="s1">profile </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
							<span class="s0">// eslint-disable-next-line node/no-unsupported-features/node-builtins</span>
							<span class="s1">console</span><span class="s3">.</span><span class="s1">profile</span><span class="s3">(</span><span class="s2">`[</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">] </span><span class="s1">$</span><span class="s3">{</span><span class="s1">logEntry</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s7">0</span><span class="s3">]}</span><span class="s2">`</span><span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
			<span class="s3">},</span>
			<span class="s1">childName </span><span class="s3">=&gt; {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">name </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">childName </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
						<span class="s4">return this</span><span class="s3">.</span><span class="s1">getLogger</span><span class="s3">(() =&gt; {</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">name </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
								<span class="s1">name </span><span class="s3">= </span><span class="s1">name</span><span class="s3">();</span>
								<span class="s4">if </span><span class="s3">(!</span><span class="s1">name</span><span class="s3">) {</span>
									<span class="s4">throw new </span><span class="s1">TypeError</span><span class="s3">(</span>
										<span class="s2">&quot;Compilation.getLogger(name) called with a function not returning a name&quot;</span>
									<span class="s3">);</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">childName </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
								<span class="s1">childName </span><span class="s3">= </span><span class="s1">childName</span><span class="s3">();</span>
								<span class="s4">if </span><span class="s3">(!</span><span class="s1">childName</span><span class="s3">) {</span>
									<span class="s4">throw new </span><span class="s1">TypeError</span><span class="s3">(</span>
										<span class="s2">&quot;Logger.getChildLogger(name) called with a function not returning a name&quot;</span>
									<span class="s3">);</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
							<span class="s4">return </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">/</span><span class="s1">$</span><span class="s3">{</span><span class="s1">childName</span><span class="s3">}</span><span class="s2">`</span><span class="s3">;</span>
						<span class="s3">});</span>
					<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
						<span class="s4">return this</span><span class="s3">.</span><span class="s1">getLogger</span><span class="s3">(() =&gt; {</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">name </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
								<span class="s1">name </span><span class="s3">= </span><span class="s1">name</span><span class="s3">();</span>
								<span class="s4">if </span><span class="s3">(!</span><span class="s1">name</span><span class="s3">) {</span>
									<span class="s4">throw new </span><span class="s1">TypeError</span><span class="s3">(</span>
										<span class="s2">&quot;Compilation.getLogger(name) called with a function not returning a name&quot;</span>
									<span class="s3">);</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
							<span class="s4">return </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">/</span><span class="s1">$</span><span class="s3">{</span><span class="s1">childName</span><span class="s3">}</span><span class="s2">`</span><span class="s3">;</span>
						<span class="s3">});</span>
					<span class="s3">}</span>
				<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">childName </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
						<span class="s4">return this</span><span class="s3">.</span><span class="s1">getLogger</span><span class="s3">(() =&gt; {</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">childName </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
								<span class="s1">childName </span><span class="s3">= </span><span class="s1">childName</span><span class="s3">();</span>
								<span class="s4">if </span><span class="s3">(!</span><span class="s1">childName</span><span class="s3">) {</span>
									<span class="s4">throw new </span><span class="s1">TypeError</span><span class="s3">(</span>
										<span class="s2">&quot;Logger.getChildLogger(name) called with a function not returning a name&quot;</span>
									<span class="s3">);</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
							<span class="s4">return </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">/</span><span class="s1">$</span><span class="s3">{</span><span class="s1">childName</span><span class="s3">}</span><span class="s2">`</span><span class="s3">;</span>
						<span class="s3">});</span>
					<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
						<span class="s4">return this</span><span class="s3">.</span><span class="s1">getLogger</span><span class="s3">(</span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">/</span><span class="s1">$</span><span class="s3">{</span><span class="s1">childName</span><span class="s3">}</span><span class="s2">`</span><span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module module to be added that was created</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleCallback} callback returns the module in the compilation,</span>
	 <span class="s5">* it could be the passed one (if new), or an already existing in the compilation</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">addModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">addModuleQueue</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module module to be added that was created</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleCallback} callback returns the module in the compilation,</span>
	 <span class="s5">* it could be the passed one (if new), or an already existing in the compilation</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">_addModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">identifier </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">();</span>
		<span class="s4">const </span><span class="s1">alreadyAddedModule </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_modules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">alreadyAddedModule</span><span class="s3">) {</span>
			<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s4">null</span><span class="s3">, </span><span class="s1">alreadyAddedModule</span><span class="s3">);</span>
		<span class="s3">}</span>

		<span class="s4">const </span><span class="s1">currentProfile </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">profile</span>
			<span class="s3">? </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getProfile</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)</span>
			<span class="s3">: </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">currentProfile </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s1">currentProfile</span><span class="s3">.</span><span class="s1">markRestoringStart</span><span class="s3">();</span>
		<span class="s3">}</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">_modulesCache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">, </span><span class="s4">null</span><span class="s3">, (</span><span class="s1">err</span><span class="s3">, </span><span class="s1">cacheModule</span><span class="s3">) =&gt; {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) </span><span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s4">new </span><span class="s1">ModuleRestoreError</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">err</span><span class="s3">));</span>

			<span class="s4">if </span><span class="s3">(</span><span class="s1">currentProfile </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s1">currentProfile</span><span class="s3">.</span><span class="s1">markRestoringEnd</span><span class="s3">();</span>
				<span class="s1">currentProfile</span><span class="s3">.</span><span class="s1">markIntegrationStart</span><span class="s3">();</span>
			<span class="s3">}</span>

			<span class="s4">if </span><span class="s3">(</span><span class="s1">cacheModule</span><span class="s3">) {</span>
				<span class="s1">cacheModule</span><span class="s3">.</span><span class="s1">updateCacheModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>

				<span class="s1">module </span><span class="s3">= </span><span class="s1">cacheModule</span><span class="s3">;</span>
			<span class="s3">}</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">_modules</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_backCompat</span><span class="s3">)</span>
				<span class="s1">ModuleGraph</span><span class="s3">.</span><span class="s1">setModuleGraphForModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">currentProfile </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s1">currentProfile</span><span class="s3">.</span><span class="s1">markIntegrationEnd</span><span class="s3">();</span>
			<span class="s3">}</span>
			<span class="s1">callback</span><span class="s3">(</span><span class="s4">null</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
		<span class="s3">});</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* Fetches a module from a compilation by its identifier</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module provided</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Module} the module requested</span>
	 <span class="s5">*/</span>
	<span class="s1">getModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">identifier </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">();</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">_modules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* Attempts to search for a module by its identifier</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} identifier identifier (usually path) for module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Module|undefined} attempt to search for module and return it, else undefined</span>
	 <span class="s5">*/</span>
	<span class="s1">findModule</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">) {</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">_modules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* Schedules a build of the module object</span>
	 <span class="s5">*</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module module to be built</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleCallback} callback the callback</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">buildModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">buildQueue</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* Builds the module object</span>
	 <span class="s5">*</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module module to be built</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleCallback} callback the callback</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">_buildModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">currentProfile </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">profile</span>
			<span class="s3">? </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getProfile</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)</span>
			<span class="s3">: </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">currentProfile </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s1">currentProfile</span><span class="s3">.</span><span class="s1">markBuildingStart</span><span class="s3">();</span>
		<span class="s3">}</span>

		<span class="s1">module</span><span class="s3">.</span><span class="s1">needBuild</span><span class="s3">(</span>
			<span class="s3">{</span>
				<span class="s1">compilation</span><span class="s3">: </span><span class="s4">this</span><span class="s3">,</span>
				<span class="s1">fileSystemInfo</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">fileSystemInfo</span><span class="s3">,</span>
				<span class="s1">valueCacheVersions</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">valueCacheVersions</span>
			<span class="s3">},</span>
			<span class="s3">(</span><span class="s1">err</span><span class="s3">, </span><span class="s1">needBuild</span><span class="s3">) =&gt; {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) </span><span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>

				<span class="s4">if </span><span class="s3">(!</span><span class="s1">needBuild</span><span class="s3">) {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">currentProfile </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
						<span class="s1">currentProfile</span><span class="s3">.</span><span class="s1">markBuildingEnd</span><span class="s3">();</span>
					<span class="s3">}</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">stillValidModule</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
					<span class="s4">return </span><span class="s1">callback</span><span class="s3">();</span>
				<span class="s3">}</span>

				<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">buildModule</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">builtModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
				<span class="s1">module</span><span class="s3">.</span><span class="s1">build</span><span class="s3">(</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">,</span>
					<span class="s4">this</span><span class="s3">,</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">resolverFactory</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s2">&quot;normal&quot;</span><span class="s3">, </span><span class="s1">module</span><span class="s3">.</span><span class="s1">resolveOptions</span><span class="s3">),</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">inputFileSystem</span><span class="s3">,</span>
					<span class="s1">err </span><span class="s3">=&gt; {</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">currentProfile </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
							<span class="s1">currentProfile</span><span class="s3">.</span><span class="s1">markBuildingEnd</span><span class="s3">();</span>
						<span class="s3">}</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">failedModule</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">err</span><span class="s3">);</span>
							<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
						<span class="s3">}</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">currentProfile </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
							<span class="s1">currentProfile</span><span class="s3">.</span><span class="s1">markStoringStart</span><span class="s3">();</span>
						<span class="s3">}</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">_modulesCache</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">(), </span><span class="s4">null</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">err </span><span class="s3">=&gt; {</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">currentProfile </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
								<span class="s1">currentProfile</span><span class="s3">.</span><span class="s1">markStoringEnd</span><span class="s3">();</span>
							<span class="s3">}</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
								<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">failedModule</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">err</span><span class="s3">);</span>
								<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s4">new </span><span class="s1">ModuleStoreError</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">err</span><span class="s3">));</span>
							<span class="s3">}</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">succeedModule</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
							<span class="s4">return </span><span class="s1">callback</span><span class="s3">();</span>
						<span class="s3">});</span>
					<span class="s3">}</span>
				<span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module to be processed for deps</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleCallback} callback callback to be triggered</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">processModuleDependencies</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">processDependenciesQueue</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module to be processed for deps</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">processModuleDependenciesNonRecursive</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">processDependenciesBlock </span><span class="s3">= </span><span class="s1">block </span><span class="s3">=&gt; {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">dependencies</span><span class="s3">) {</span>
				<span class="s4">let </span><span class="s1">i </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">dep of block</span><span class="s3">.</span><span class="s1">dependencies</span><span class="s3">) {</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">setParents</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">i</span><span class="s3">++);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">) {</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">b of block</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">) </span><span class="s1">processDependenciesBlock</span><span class="s3">(</span><span class="s1">b</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">};</span>

		<span class="s1">processDependenciesBlock</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module to be processed for deps</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleCallback} callback callback to be triggered</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">_processModuleDependencies</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Array&lt;{factory: ModuleFactory, dependencies: Dependency[], context: string|undefined, originModule: Module|null}&gt;} */</span>
		<span class="s4">const </span><span class="s1">sortedDependencies </span><span class="s3">= [];</span>

		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{DependenciesBlock} */</span>
		<span class="s4">let </span><span class="s1">currentBlock</span><span class="s3">;</span>

		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;ModuleFactory, Map&lt;string, Dependency[]&gt;&gt;} */</span>
		<span class="s4">let </span><span class="s1">dependencies</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{DepConstructor} */</span>
		<span class="s4">let </span><span class="s1">factoryCacheKey</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ModuleFactory} */</span>
		<span class="s4">let </span><span class="s1">factoryCacheKey2</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, Dependency[]&gt;} */</span>
		<span class="s4">let </span><span class="s1">factoryCacheValue</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */</span>
		<span class="s4">let </span><span class="s1">listCacheKey1</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */</span>
		<span class="s4">let </span><span class="s1">listCacheKey2</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Dependency[]} */</span>
		<span class="s4">let </span><span class="s1">listCacheValue</span><span class="s3">;</span>

		<span class="s4">let </span><span class="s1">inProgressSorting </span><span class="s3">= </span><span class="s7">1</span><span class="s3">;</span>
		<span class="s4">let </span><span class="s1">inProgressTransitive </span><span class="s3">= </span><span class="s7">1</span><span class="s3">;</span>

		<span class="s4">const </span><span class="s1">onDependenciesSorted </span><span class="s3">= </span><span class="s1">err </span><span class="s3">=&gt; {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) </span><span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>

			<span class="s0">// early exit without changing parallelism back and forth</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">sortedDependencies</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s7">0 </span><span class="s3">&amp;&amp; </span><span class="s1">inProgressTransitive </span><span class="s3">=== </span><span class="s7">1</span><span class="s3">) {</span>
				<span class="s4">return </span><span class="s1">callback</span><span class="s3">();</span>
			<span class="s3">}</span>

			<span class="s0">// This is nested so we need to allow one additional task</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">processDependenciesQueue</span><span class="s3">.</span><span class="s1">increaseParallelism</span><span class="s3">();</span>

			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">item of sortedDependencies</span><span class="s3">) {</span>
				<span class="s1">inProgressTransitive</span><span class="s3">++;</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">handleModuleCreation</span><span class="s3">(</span><span class="s1">item</span><span class="s3">, </span><span class="s1">err </span><span class="s3">=&gt; {</span>
					<span class="s0">// In V8, the Error objects keep a reference to the functions on the stack. These warnings &amp;</span>
					<span class="s0">// errors are created inside closures that keep a reference to the Compilation, so errors are</span>
					<span class="s0">// leaking the Compilation object.</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">err </span><span class="s3">&amp;&amp; </span><span class="s4">this</span><span class="s3">.</span><span class="s1">bail</span><span class="s3">) {</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">inProgressTransitive </span><span class="s3">&lt;= </span><span class="s7">0</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
						<span class="s1">inProgressTransitive </span><span class="s3">= -</span><span class="s7">1</span><span class="s3">;</span>
						<span class="s0">// eslint-disable-next-line no-self-assign</span>
						<span class="s1">err</span><span class="s3">.</span><span class="s1">stack </span><span class="s3">= </span><span class="s1">err</span><span class="s3">.</span><span class="s1">stack</span><span class="s3">;</span>
						<span class="s1">onTransitiveTasksFinished</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
						<span class="s4">return</span><span class="s3">;</span>
					<span class="s3">}</span>
					<span class="s4">if </span><span class="s3">(--</span><span class="s1">inProgressTransitive </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) </span><span class="s1">onTransitiveTasksFinished</span><span class="s3">();</span>
				<span class="s3">});</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(--</span><span class="s1">inProgressTransitive </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) </span><span class="s1">onTransitiveTasksFinished</span><span class="s3">();</span>
		<span class="s3">};</span>

		<span class="s4">const </span><span class="s1">onTransitiveTasksFinished </span><span class="s3">= </span><span class="s1">err </span><span class="s3">=&gt; {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) </span><span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">processDependenciesQueue</span><span class="s3">.</span><span class="s1">decreaseParallelism</span><span class="s3">();</span>

			<span class="s4">return </span><span class="s1">callback</span><span class="s3">();</span>
		<span class="s3">};</span>

		<span class="s5">/**</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Dependency} dep dependency</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} index index in block</span>
		 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
		 <span class="s5">*/</span>
		<span class="s4">const </span><span class="s1">processDependency </span><span class="s3">= (</span><span class="s1">dep</span><span class="s3">, </span><span class="s1">index</span><span class="s3">) =&gt; {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">setParents</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">, </span><span class="s1">currentBlock</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">index</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_unsafeCache</span><span class="s3">) {</span>
				<span class="s4">try </span><span class="s3">{</span>
					<span class="s4">const </span><span class="s1">unsafeCachedModule </span><span class="s3">= </span><span class="s1">unsafeCacheDependencies</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">unsafeCachedModule </span><span class="s3">=== </span><span class="s4">null</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">unsafeCachedModule </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
						<span class="s4">if </span><span class="s3">(</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">_restoredUnsafeCacheModuleEntries</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">unsafeCachedModule</span><span class="s3">)</span>
						<span class="s3">) {</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">_handleExistingModuleFromUnsafeCache</span><span class="s3">(</span>
								<span class="s1">module</span><span class="s3">,</span>
								<span class="s1">dep</span><span class="s3">,</span>
								<span class="s1">unsafeCachedModule</span>
							<span class="s3">);</span>
							<span class="s4">return</span><span class="s3">;</span>
						<span class="s3">}</span>
						<span class="s4">const </span><span class="s1">identifier </span><span class="s3">= </span><span class="s1">unsafeCachedModule</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">();</span>
						<span class="s4">const </span><span class="s1">cachedModule </span><span class="s3">=</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">_restoredUnsafeCacheEntries</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">);</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">cachedModule </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
							<span class="s0">// update unsafe cache to new module</span>
							<span class="s1">unsafeCacheDependencies</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">, </span><span class="s1">cachedModule</span><span class="s3">);</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">_handleExistingModuleFromUnsafeCache</span><span class="s3">(</span>
								<span class="s1">module</span><span class="s3">,</span>
								<span class="s1">dep</span><span class="s3">,</span>
								<span class="s1">cachedModule</span>
							<span class="s3">);</span>
							<span class="s4">return</span><span class="s3">;</span>
						<span class="s3">}</span>
						<span class="s1">inProgressSorting</span><span class="s3">++;</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">_modulesCache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">, </span><span class="s4">null</span><span class="s3">, (</span><span class="s1">err</span><span class="s3">, </span><span class="s1">cachedModule</span><span class="s3">) =&gt; {</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">inProgressSorting </span><span class="s3">&lt;= </span><span class="s7">0</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
								<span class="s1">inProgressSorting </span><span class="s3">= -</span><span class="s7">1</span><span class="s3">;</span>
								<span class="s1">onDependenciesSorted</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
								<span class="s4">return</span><span class="s3">;</span>
							<span class="s3">}</span>
							<span class="s4">try </span><span class="s3">{</span>
								<span class="s4">if </span><span class="s3">(!</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_restoredUnsafeCacheEntries</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">)) {</span>
									<span class="s4">const </span><span class="s1">data </span><span class="s3">= </span><span class="s1">unsafeCacheData</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">cachedModule</span><span class="s3">);</span>
									<span class="s4">if </span><span class="s3">(</span><span class="s1">data </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
										<span class="s1">processDependencyForResolving</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">);</span>
										<span class="s4">if </span><span class="s3">(--</span><span class="s1">inProgressSorting </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) </span><span class="s1">onDependenciesSorted</span><span class="s3">();</span>
										<span class="s4">return</span><span class="s3">;</span>
									<span class="s3">}</span>
									<span class="s4">if </span><span class="s3">(</span><span class="s1">cachedModule </span><span class="s3">!== </span><span class="s1">unsafeCachedModule</span><span class="s3">) {</span>
										<span class="s1">unsafeCacheDependencies</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">, </span><span class="s1">cachedModule</span><span class="s3">);</span>
									<span class="s3">}</span>
									<span class="s1">cachedModule</span><span class="s3">.</span><span class="s1">restoreFromUnsafeCache</span><span class="s3">(</span>
										<span class="s1">data</span><span class="s3">,</span>
										<span class="s4">this</span><span class="s3">.</span><span class="s1">params</span><span class="s3">.</span><span class="s1">normalModuleFactory</span><span class="s3">,</span>
										<span class="s4">this</span><span class="s3">.</span><span class="s1">params</span>
									<span class="s3">);</span>
									<span class="s4">this</span><span class="s3">.</span><span class="s1">_restoredUnsafeCacheEntries</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span>
										<span class="s1">identifier</span><span class="s3">,</span>
										<span class="s1">cachedModule</span>
									<span class="s3">);</span>
									<span class="s4">this</span><span class="s3">.</span><span class="s1">_restoredUnsafeCacheModuleEntries</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">cachedModule</span><span class="s3">);</span>
									<span class="s4">if </span><span class="s3">(!</span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">cachedModule</span><span class="s3">)) {</span>
										<span class="s1">inProgressTransitive</span><span class="s3">++;</span>
										<span class="s4">this</span><span class="s3">.</span><span class="s1">_handleNewModuleFromUnsafeCache</span><span class="s3">(</span>
											<span class="s1">module</span><span class="s3">,</span>
											<span class="s1">dep</span><span class="s3">,</span>
											<span class="s1">cachedModule</span><span class="s3">,</span>
											<span class="s1">err </span><span class="s3">=&gt; {</span>
												<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
													<span class="s4">if </span><span class="s3">(</span><span class="s1">inProgressTransitive </span><span class="s3">&lt;= </span><span class="s7">0</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
													<span class="s1">inProgressTransitive </span><span class="s3">= -</span><span class="s7">1</span><span class="s3">;</span>
													<span class="s1">onTransitiveTasksFinished</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
												<span class="s3">}</span>
												<span class="s4">if </span><span class="s3">(--</span><span class="s1">inProgressTransitive </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">)</span>
													<span class="s4">return </span><span class="s1">onTransitiveTasksFinished</span><span class="s3">();</span>
											<span class="s3">}</span>
										<span class="s3">);</span>
										<span class="s4">if </span><span class="s3">(--</span><span class="s1">inProgressSorting </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) </span><span class="s1">onDependenciesSorted</span><span class="s3">();</span>
										<span class="s4">return</span><span class="s3">;</span>
									<span class="s3">}</span>
								<span class="s3">}</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">unsafeCachedModule </span><span class="s3">!== </span><span class="s1">cachedModule</span><span class="s3">) {</span>
									<span class="s1">unsafeCacheDependencies</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">, </span><span class="s1">cachedModule</span><span class="s3">);</span>
								<span class="s3">}</span>
								<span class="s4">this</span><span class="s3">.</span><span class="s1">_handleExistingModuleFromUnsafeCache</span><span class="s3">(</span>
									<span class="s1">module</span><span class="s3">,</span>
									<span class="s1">dep</span><span class="s3">,</span>
									<span class="s1">cachedModule</span>
								<span class="s3">); </span><span class="s0">// a3</span>
							<span class="s3">} </span><span class="s4">catch </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">inProgressSorting </span><span class="s3">&lt;= </span><span class="s7">0</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
								<span class="s1">inProgressSorting </span><span class="s3">= -</span><span class="s7">1</span><span class="s3">;</span>
								<span class="s1">onDependenciesSorted</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
								<span class="s4">return</span><span class="s3">;</span>
							<span class="s3">}</span>
							<span class="s4">if </span><span class="s3">(--</span><span class="s1">inProgressSorting </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) </span><span class="s1">onDependenciesSorted</span><span class="s3">();</span>
						<span class="s3">});</span>
						<span class="s4">return</span><span class="s3">;</span>
					<span class="s3">}</span>
				<span class="s3">} </span><span class="s4">catch </span><span class="s3">(</span><span class="s1">e</span><span class="s3">) {</span>
					<span class="s1">console</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s1">e</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
			<span class="s1">processDependencyForResolving</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">);</span>
		<span class="s3">};</span>

		<span class="s5">/**</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Dependency} dep dependency</span>
		 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
		 <span class="s5">*/</span>
		<span class="s4">const </span><span class="s1">processDependencyForResolving </span><span class="s3">= </span><span class="s1">dep </span><span class="s3">=&gt; {</span>
			<span class="s4">const </span><span class="s1">resourceIdent </span><span class="s3">= </span><span class="s1">dep</span><span class="s3">.</span><span class="s1">getResourceIdentifier</span><span class="s3">();</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">resourceIdent </span><span class="s3">!== </span><span class="s1">undefined </span><span class="s3">&amp;&amp; </span><span class="s1">resourceIdent </span><span class="s3">!== </span><span class="s4">null</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">category </span><span class="s3">= </span><span class="s1">dep</span><span class="s3">.</span><span class="s1">category</span><span class="s3">;</span>
				<span class="s4">const </span><span class="s1">constructor </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{DepConstructor} */ </span><span class="s3">(</span><span class="s1">dep</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">factoryCacheKey </span><span class="s3">=== </span><span class="s1">constructor</span><span class="s3">) {</span>
					<span class="s0">// Fast path 1: same constructor as prev item</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">listCacheKey1 </span><span class="s3">=== </span><span class="s1">category </span><span class="s3">&amp;&amp; </span><span class="s1">listCacheKey2 </span><span class="s3">=== </span><span class="s1">resourceIdent</span><span class="s3">) {</span>
						<span class="s0">// Super fast path 1: also same resource</span>
						<span class="s1">listCacheValue</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">);</span>
						<span class="s4">return</span><span class="s3">;</span>
					<span class="s3">}</span>
				<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
					<span class="s4">const </span><span class="s1">factory </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">dependencyFactories</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">constructor</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">factory </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
						<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
							<span class="s2">`No module factory available for dependency type: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">constructor</span><span class="s3">.</span><span class="s1">name</span><span class="s3">}</span><span class="s2">`</span>
						<span class="s3">);</span>
					<span class="s3">}</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">factoryCacheKey2 </span><span class="s3">=== </span><span class="s1">factory</span><span class="s3">) {</span>
						<span class="s0">// Fast path 2: same factory as prev item</span>
						<span class="s1">factoryCacheKey </span><span class="s3">= </span><span class="s1">constructor</span><span class="s3">;</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">listCacheKey1 </span><span class="s3">=== </span><span class="s1">category </span><span class="s3">&amp;&amp; </span><span class="s1">listCacheKey2 </span><span class="s3">=== </span><span class="s1">resourceIdent</span><span class="s3">) {</span>
							<span class="s0">// Super fast path 2: also same resource</span>
							<span class="s1">listCacheValue</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">);</span>
							<span class="s4">return</span><span class="s3">;</span>
						<span class="s3">}</span>
					<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
						<span class="s0">// Slow path</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">factoryCacheKey2 </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
							<span class="s0">// Archive last cache entry</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">dependencies </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s1">dependencies </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
							<span class="s1">dependencies</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">factoryCacheKey2</span><span class="s3">, </span><span class="s1">factoryCacheValue</span><span class="s3">);</span>
							<span class="s1">factoryCacheValue </span><span class="s3">= </span><span class="s1">dependencies</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">factory</span><span class="s3">);</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">factoryCacheValue </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
								<span class="s1">factoryCacheValue </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
							<span class="s3">}</span>
						<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
							<span class="s1">factoryCacheValue </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
						<span class="s3">}</span>
						<span class="s1">factoryCacheKey </span><span class="s3">= </span><span class="s1">constructor</span><span class="s3">;</span>
						<span class="s1">factoryCacheKey2 </span><span class="s3">= </span><span class="s1">factory</span><span class="s3">;</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
				<span class="s0">// Here webpack is using heuristic that assumes</span>
				<span class="s0">// mostly esm dependencies would be used</span>
				<span class="s0">// so we don't allocate extra string for them</span>
				<span class="s4">const </span><span class="s1">cacheKey </span><span class="s3">=</span>
					<span class="s1">category </span><span class="s3">=== </span><span class="s1">esmDependencyCategory</span>
						<span class="s3">? </span><span class="s1">resourceIdent</span>
						<span class="s3">: </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">category</span><span class="s3">}</span><span class="s1">$</span><span class="s3">{</span><span class="s1">resourceIdent</span><span class="s3">}</span><span class="s2">`</span><span class="s3">;</span>
				<span class="s4">let </span><span class="s1">list </span><span class="s3">= </span><span class="s1">factoryCacheValue</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">cacheKey</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">list </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
					<span class="s1">factoryCacheValue</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">cacheKey</span><span class="s3">, (</span><span class="s1">list </span><span class="s3">= []));</span>
					<span class="s1">sortedDependencies</span><span class="s3">.</span><span class="s1">push</span><span class="s3">({</span>
						<span class="s1">factory</span><span class="s3">: </span><span class="s1">factoryCacheKey2</span><span class="s3">,</span>
						<span class="s1">dependencies</span><span class="s3">: </span><span class="s1">list</span><span class="s3">,</span>
						<span class="s1">context</span><span class="s3">: </span><span class="s1">dep</span><span class="s3">.</span><span class="s1">getContext</span><span class="s3">(),</span>
						<span class="s1">originModule</span><span class="s3">: </span><span class="s1">module</span>
					<span class="s3">});</span>
				<span class="s3">}</span>
				<span class="s1">list</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">);</span>
				<span class="s1">listCacheKey1 </span><span class="s3">= </span><span class="s1">category</span><span class="s3">;</span>
				<span class="s1">listCacheKey2 </span><span class="s3">= </span><span class="s1">resourceIdent</span><span class="s3">;</span>
				<span class="s1">listCacheValue </span><span class="s3">= </span><span class="s1">list</span><span class="s3">;</span>
			<span class="s3">}</span>
		<span class="s3">};</span>

		<span class="s4">try </span><span class="s3">{</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{DependenciesBlock[]} */</span>
			<span class="s4">const </span><span class="s1">queue </span><span class="s3">= [</span><span class="s1">module</span><span class="s3">];</span>
			<span class="s4">do </span><span class="s3">{</span>
				<span class="s4">const </span><span class="s1">block </span><span class="s3">= </span><span class="s1">queue</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">();</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">dependencies</span><span class="s3">) {</span>
					<span class="s1">currentBlock </span><span class="s3">= </span><span class="s1">block</span><span class="s3">;</span>
					<span class="s4">let </span><span class="s1">i </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">dep of block</span><span class="s3">.</span><span class="s1">dependencies</span><span class="s3">) </span><span class="s1">processDependency</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">, </span><span class="s1">i</span><span class="s3">++);</span>
				<span class="s3">}</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">) {</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">b of block</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">) </span><span class="s1">queue</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">b</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">} </span><span class="s4">while </span><span class="s3">(</span><span class="s1">queue</span><span class="s3">.</span><span class="s1">length </span><span class="s3">!== </span><span class="s7">0</span><span class="s3">);</span>
		<span class="s3">} </span><span class="s4">catch </span><span class="s3">(</span><span class="s1">e</span><span class="s3">) {</span>
			<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">e</span><span class="s3">);</span>
		<span class="s3">}</span>

		<span class="s4">if </span><span class="s3">(--</span><span class="s1">inProgressSorting </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) </span><span class="s1">onDependenciesSorted</span><span class="s3">();</span>
	<span class="s3">}</span>

	<span class="s1">_handleNewModuleFromUnsafeCache</span><span class="s3">(</span><span class="s1">originModule</span><span class="s3">, </span><span class="s1">dependency</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">moduleGraph </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">;</span>

		<span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">setResolvedModule</span><span class="s3">(</span><span class="s1">originModule</span><span class="s3">, </span><span class="s1">dependency</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>

		<span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">setIssuerIfUnset</span><span class="s3">(</span>
			<span class="s1">module</span><span class="s3">,</span>
			<span class="s1">originModule </span><span class="s3">!== </span><span class="s1">undefined </span><span class="s3">? </span><span class="s1">originModule </span><span class="s3">: </span><span class="s4">null</span>
		<span class="s3">);</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">_modules</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">(), </span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_backCompat</span><span class="s3">)</span>
			<span class="s1">ModuleGraph</span><span class="s3">.</span><span class="s1">setModuleGraphForModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">);</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">_handleModuleBuildAndDependencies</span><span class="s3">(</span>
			<span class="s1">originModule</span><span class="s3">,</span>
			<span class="s1">module</span><span class="s3">,</span>
			<span class="s4">true</span><span class="s3">,</span>
			<span class="s1">callback</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s1">_handleExistingModuleFromUnsafeCache</span><span class="s3">(</span><span class="s1">originModule</span><span class="s3">, </span><span class="s1">dependency</span><span class="s3">, </span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">moduleGraph </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">;</span>

		<span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">setResolvedModule</span><span class="s3">(</span><span class="s1">originModule</span><span class="s3">, </span><span class="s1">dependency</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} HandleModuleCreationOptions</span>
	 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ModuleFactory} factory</span>
	 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Dependency[]} dependencies</span>
	 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Module | null} originModule</span>
	 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Partial&lt;ModuleFactoryCreateDataContextInfo&gt;=} contextInfo</span>
	 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} context</span>
	 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean=} recursive recurse into dependencies of the created module</span>
	 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean=} connectOrigin connect the resolved module with the origin module</span>
	 <span class="s5">*/</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{HandleModuleCreationOptions} options options object</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleCallback} callback callback</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">handleModuleCreation</span><span class="s3">(</span>
		<span class="s3">{</span>
			<span class="s1">factory</span><span class="s3">,</span>
			<span class="s1">dependencies</span><span class="s3">,</span>
			<span class="s1">originModule</span><span class="s3">,</span>
			<span class="s1">contextInfo</span><span class="s3">,</span>
			<span class="s1">context</span><span class="s3">,</span>
			<span class="s1">recursive </span><span class="s3">= </span><span class="s4">true</span><span class="s3">,</span>
			<span class="s1">connectOrigin </span><span class="s3">= </span><span class="s1">recursive</span>
		<span class="s3">},</span>
		<span class="s1">callback</span>
	<span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">moduleGraph </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">;</span>

		<span class="s4">const </span><span class="s1">currentProfile </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">profile </span><span class="s3">? </span><span class="s4">new </span><span class="s1">ModuleProfile</span><span class="s3">() : </span><span class="s1">undefined</span><span class="s3">;</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">factorizeModule</span><span class="s3">(</span>
			<span class="s3">{</span>
				<span class="s1">currentProfile</span><span class="s3">,</span>
				<span class="s1">factory</span><span class="s3">,</span>
				<span class="s1">dependencies</span><span class="s3">,</span>
				<span class="s1">factoryResult</span><span class="s3">: </span><span class="s4">true</span><span class="s3">,</span>
				<span class="s1">originModule</span><span class="s3">,</span>
				<span class="s1">contextInfo</span><span class="s3">,</span>
				<span class="s1">context</span>
			<span class="s3">},</span>
			<span class="s3">(</span><span class="s1">err</span><span class="s3">, </span><span class="s1">factoryResult</span><span class="s3">) =&gt; {</span>
				<span class="s4">const </span><span class="s1">applyFactoryResultDependencies </span><span class="s3">= () =&gt; {</span>
					<span class="s4">const </span><span class="s3">{ </span><span class="s1">fileDependencies</span><span class="s3">, </span><span class="s1">contextDependencies</span><span class="s3">, </span><span class="s1">missingDependencies </span><span class="s3">} =</span>
						<span class="s1">factoryResult</span><span class="s3">;</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">fileDependencies</span><span class="s3">) {</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">fileDependencies</span><span class="s3">.</span><span class="s1">addAll</span><span class="s3">(</span><span class="s1">fileDependencies</span><span class="s3">);</span>
					<span class="s3">}</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">contextDependencies</span><span class="s3">) {</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">contextDependencies</span><span class="s3">.</span><span class="s1">addAll</span><span class="s3">(</span><span class="s1">contextDependencies</span><span class="s3">);</span>
					<span class="s3">}</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">missingDependencies</span><span class="s3">) {</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">missingDependencies</span><span class="s3">.</span><span class="s1">addAll</span><span class="s3">(</span><span class="s1">missingDependencies</span><span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">};</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">factoryResult</span><span class="s3">) </span><span class="s1">applyFactoryResultDependencies</span><span class="s3">();</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">dependencies</span><span class="s3">.</span><span class="s1">every</span><span class="s3">(</span><span class="s1">d </span><span class="s3">=&gt; </span><span class="s1">d</span><span class="s3">.</span><span class="s1">optional</span><span class="s3">)) {</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
						<span class="s4">return </span><span class="s1">callback</span><span class="s3">();</span>
					<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
						<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">}</span>

				<span class="s4">const </span><span class="s1">newModule </span><span class="s3">= </span><span class="s1">factoryResult</span><span class="s3">.</span><span class="s1">module</span><span class="s3">;</span>

				<span class="s4">if </span><span class="s3">(!</span><span class="s1">newModule</span><span class="s3">) {</span>
					<span class="s1">applyFactoryResultDependencies</span><span class="s3">();</span>
					<span class="s4">return </span><span class="s1">callback</span><span class="s3">();</span>
				<span class="s3">}</span>

				<span class="s4">if </span><span class="s3">(</span><span class="s1">currentProfile </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
					<span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">setProfile</span><span class="s3">(</span><span class="s1">newModule</span><span class="s3">, </span><span class="s1">currentProfile</span><span class="s3">);</span>
				<span class="s3">}</span>

				<span class="s4">this</span><span class="s3">.</span><span class="s1">addModule</span><span class="s3">(</span><span class="s1">newModule</span><span class="s3">, (</span><span class="s1">err</span><span class="s3">, </span><span class="s1">module</span><span class="s3">) =&gt; {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
						<span class="s1">applyFactoryResultDependencies</span><span class="s3">();</span>
						<span class="s4">if </span><span class="s3">(!</span><span class="s1">err</span><span class="s3">.</span><span class="s1">module</span><span class="s3">) {</span>
							<span class="s1">err</span><span class="s3">.</span><span class="s1">module </span><span class="s3">= </span><span class="s1">module</span><span class="s3">;</span>
						<span class="s3">}</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>

						<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
					<span class="s3">}</span>

					<span class="s4">if </span><span class="s3">(</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">_unsafeCache </span><span class="s3">&amp;&amp;</span>
						<span class="s1">factoryResult</span><span class="s3">.</span><span class="s1">cacheable </span><span class="s3">!== </span><span class="s4">false </span><span class="s3">&amp;&amp;</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{any} */ </span><span class="s3">(</span><span class="s1">module</span><span class="s3">).</span><span class="s1">restoreFromUnsafeCache </span><span class="s3">&amp;&amp;</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">_unsafeCachePredicate</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)</span>
					<span class="s3">) {</span>
						<span class="s4">const </span><span class="s1">unsafeCacheableModule </span><span class="s3">=</span>
							<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Module &amp; { restoreFromUnsafeCache: Function }} */ </span><span class="s3">(</span>
								<span class="s1">module</span>
							<span class="s3">);</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">let </span><span class="s1">i </span><span class="s3">= </span><span class="s7">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">dependencies</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
							<span class="s4">const </span><span class="s1">dependency </span><span class="s3">= </span><span class="s1">dependencies</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
							<span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">setResolvedModule</span><span class="s3">(</span>
								<span class="s1">connectOrigin </span><span class="s3">? </span><span class="s1">originModule </span><span class="s3">: </span><span class="s4">null</span><span class="s3">,</span>
								<span class="s1">dependency</span><span class="s3">,</span>
								<span class="s1">unsafeCacheableModule</span>
							<span class="s3">);</span>
							<span class="s1">unsafeCacheDependencies</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">dependency</span><span class="s3">, </span><span class="s1">unsafeCacheableModule</span><span class="s3">);</span>
						<span class="s3">}</span>
						<span class="s4">if </span><span class="s3">(!</span><span class="s1">unsafeCacheData</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">unsafeCacheableModule</span><span class="s3">)) {</span>
							<span class="s1">unsafeCacheData</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span>
								<span class="s1">unsafeCacheableModule</span><span class="s3">,</span>
								<span class="s1">unsafeCacheableModule</span><span class="s3">.</span><span class="s1">getUnsafeCacheData</span><span class="s3">()</span>
							<span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
						<span class="s1">applyFactoryResultDependencies</span><span class="s3">();</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">let </span><span class="s1">i </span><span class="s3">= </span><span class="s7">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">dependencies</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
							<span class="s4">const </span><span class="s1">dependency </span><span class="s3">= </span><span class="s1">dependencies</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
							<span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">setResolvedModule</span><span class="s3">(</span>
								<span class="s1">connectOrigin </span><span class="s3">? </span><span class="s1">originModule </span><span class="s3">: </span><span class="s4">null</span><span class="s3">,</span>
								<span class="s1">dependency</span><span class="s3">,</span>
								<span class="s1">module</span>
							<span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">}</span>

					<span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">setIssuerIfUnset</span><span class="s3">(</span>
						<span class="s1">module</span><span class="s3">,</span>
						<span class="s1">originModule </span><span class="s3">!== </span><span class="s1">undefined </span><span class="s3">? </span><span class="s1">originModule </span><span class="s3">: </span><span class="s4">null</span>
					<span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">module </span><span class="s3">!== </span><span class="s1">newModule</span><span class="s3">) {</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">currentProfile </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
							<span class="s4">const </span><span class="s1">otherProfile </span><span class="s3">= </span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getProfile</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">otherProfile </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
								<span class="s1">currentProfile</span><span class="s3">.</span><span class="s1">mergeInto</span><span class="s3">(</span><span class="s1">otherProfile</span><span class="s3">);</span>
							<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
								<span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">setProfile</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">currentProfile</span><span class="s3">);</span>
							<span class="s3">}</span>
						<span class="s3">}</span>
					<span class="s3">}</span>

					<span class="s4">this</span><span class="s3">.</span><span class="s1">_handleModuleBuildAndDependencies</span><span class="s3">(</span>
						<span class="s1">originModule</span><span class="s3">,</span>
						<span class="s1">module</span><span class="s3">,</span>
						<span class="s1">recursive</span><span class="s3">,</span>
						<span class="s1">callback</span>
					<span class="s3">);</span>
				<span class="s3">});</span>
			<span class="s3">}</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s1">_handleModuleBuildAndDependencies</span><span class="s3">(</span><span class="s1">originModule</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">recursive</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s0">// Check for cycles when build is trigger inside another build</span>
		<span class="s4">let </span><span class="s1">creatingModuleDuringBuildSet </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(!</span><span class="s1">recursive </span><span class="s3">&amp;&amp; </span><span class="s4">this</span><span class="s3">.</span><span class="s1">buildQueue</span><span class="s3">.</span><span class="s1">isProcessing</span><span class="s3">(</span><span class="s1">originModule</span><span class="s3">)) {</span>
			<span class="s0">// Track build dependency</span>
			<span class="s1">creatingModuleDuringBuildSet </span><span class="s3">=</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">creatingModuleDuringBuild</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">originModule</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">creatingModuleDuringBuildSet </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s1">creatingModuleDuringBuildSet </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">creatingModuleDuringBuild</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span>
					<span class="s1">originModule</span><span class="s3">,</span>
					<span class="s1">creatingModuleDuringBuildSet</span>
				<span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s1">creatingModuleDuringBuildSet</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>

			<span class="s0">// When building is blocked by another module</span>
			<span class="s0">// search for a cycle, cancel the cycle by throwing</span>
			<span class="s0">// an error (otherwise this would deadlock)</span>
			<span class="s4">const </span><span class="s1">blockReasons </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">creatingModuleDuringBuild</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">blockReasons </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">set </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">blockReasons</span><span class="s3">);</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">item of set</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">blockReasons </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">creatingModuleDuringBuild</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">item</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">blockReasons </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">m of blockReasons</span><span class="s3">) {</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">m </span><span class="s3">=== </span><span class="s1">module</span><span class="s3">) {</span>
								<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s4">new </span><span class="s1">BuildCycleError</span><span class="s3">(</span><span class="s1">module</span><span class="s3">));</span>
							<span class="s3">}</span>
							<span class="s1">set</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">m</span><span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">buildModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">err </span><span class="s3">=&gt; {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">creatingModuleDuringBuildSet </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s1">creatingModuleDuringBuildSet</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s1">err</span><span class="s3">.</span><span class="s1">module</span><span class="s3">) {</span>
					<span class="s1">err</span><span class="s3">.</span><span class="s1">module </span><span class="s3">= </span><span class="s1">module</span><span class="s3">;</span>
				<span class="s3">}</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>

				<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
			<span class="s3">}</span>

			<span class="s4">if </span><span class="s3">(!</span><span class="s1">recursive</span><span class="s3">) {</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">processModuleDependenciesNonRecursive</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
				<span class="s1">callback</span><span class="s3">(</span><span class="s4">null</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
				<span class="s4">return</span><span class="s3">;</span>
			<span class="s3">}</span>

			<span class="s0">// This avoids deadlocks for circular dependencies</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">processDependenciesQueue</span><span class="s3">.</span><span class="s1">isProcessing</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
				<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s4">null</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
			<span class="s3">}</span>

			<span class="s4">this</span><span class="s3">.</span><span class="s1">processModuleDependencies</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">err </span><span class="s3">=&gt; {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
					<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
				<span class="s3">}</span>
				<span class="s1">callback</span><span class="s3">(</span><span class="s4">null</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
			<span class="s3">});</span>
		<span class="s3">});</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{FactorizeModuleOptions} options options object</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleOrFactoryResultCallback} callback callback</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">_factorizeModule</span><span class="s3">(</span>
		<span class="s3">{</span>
			<span class="s1">currentProfile</span><span class="s3">,</span>
			<span class="s1">factory</span><span class="s3">,</span>
			<span class="s1">dependencies</span><span class="s3">,</span>
			<span class="s1">originModule</span><span class="s3">,</span>
			<span class="s1">factoryResult</span><span class="s3">,</span>
			<span class="s1">contextInfo</span><span class="s3">,</span>
			<span class="s1">context</span>
		<span class="s3">},</span>
		<span class="s1">callback</span>
	<span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">currentProfile </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s1">currentProfile</span><span class="s3">.</span><span class="s1">markFactoryStart</span><span class="s3">();</span>
		<span class="s3">}</span>
		<span class="s1">factory</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span>
			<span class="s3">{</span>
				<span class="s1">contextInfo</span><span class="s3">: {</span>
					<span class="s1">issuer</span><span class="s3">: </span><span class="s1">originModule </span><span class="s3">? </span><span class="s1">originModule</span><span class="s3">.</span><span class="s1">nameForCondition</span><span class="s3">() : </span><span class="s2">&quot;&quot;</span><span class="s3">,</span>
					<span class="s1">issuerLayer</span><span class="s3">: </span><span class="s1">originModule </span><span class="s3">? </span><span class="s1">originModule</span><span class="s3">.</span><span class="s1">layer </span><span class="s3">: </span><span class="s4">null</span><span class="s3">,</span>
					<span class="s1">compiler</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,</span>
					<span class="s1">...contextInfo</span>
				<span class="s3">},</span>
				<span class="s1">resolveOptions</span><span class="s3">: </span><span class="s1">originModule </span><span class="s3">? </span><span class="s1">originModule</span><span class="s3">.</span><span class="s1">resolveOptions </span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
				<span class="s1">context</span><span class="s3">: </span><span class="s1">context</span>
					<span class="s3">? </span><span class="s1">context</span>
					<span class="s3">: </span><span class="s1">originModule</span>
					<span class="s3">? </span><span class="s1">originModule</span><span class="s3">.</span><span class="s1">context</span>
					<span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">context</span><span class="s3">,</span>
				<span class="s1">dependencies</span><span class="s3">: </span><span class="s1">dependencies</span>
			<span class="s3">},</span>
			<span class="s3">(</span><span class="s1">err</span><span class="s3">, </span><span class="s1">result</span><span class="s3">) =&gt; {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">result</span><span class="s3">) {</span>
					<span class="s0">// TODO webpack 6: remove</span>
					<span class="s0">// For backward-compat</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">result</span><span class="s3">.</span><span class="s1">module </span><span class="s3">=== </span><span class="s1">undefined </span><span class="s3">&amp;&amp; </span><span class="s1">result </span><span class="s4">instanceof </span><span class="s1">Module</span><span class="s3">) {</span>
						<span class="s1">result </span><span class="s3">= {</span>
							<span class="s1">module</span><span class="s3">: </span><span class="s1">result</span>
						<span class="s3">};</span>
					<span class="s3">}</span>
					<span class="s4">if </span><span class="s3">(!</span><span class="s1">factoryResult</span><span class="s3">) {</span>
						<span class="s4">const </span><span class="s3">{</span>
							<span class="s1">fileDependencies</span><span class="s3">,</span>
							<span class="s1">contextDependencies</span><span class="s3">,</span>
							<span class="s1">missingDependencies</span>
						<span class="s3">} = </span><span class="s1">result</span><span class="s3">;</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">fileDependencies</span><span class="s3">) {</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">fileDependencies</span><span class="s3">.</span><span class="s1">addAll</span><span class="s3">(</span><span class="s1">fileDependencies</span><span class="s3">);</span>
						<span class="s3">}</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">contextDependencies</span><span class="s3">) {</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">contextDependencies</span><span class="s3">.</span><span class="s1">addAll</span><span class="s3">(</span><span class="s1">contextDependencies</span><span class="s3">);</span>
						<span class="s3">}</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">missingDependencies</span><span class="s3">) {</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">missingDependencies</span><span class="s3">.</span><span class="s1">addAll</span><span class="s3">(</span><span class="s1">missingDependencies</span><span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">notFoundError </span><span class="s3">= </span><span class="s4">new </span><span class="s1">ModuleNotFoundError</span><span class="s3">(</span>
						<span class="s1">originModule</span><span class="s3">,</span>
						<span class="s1">err</span><span class="s3">,</span>
						<span class="s1">dependencies</span><span class="s3">.</span><span class="s1">map</span><span class="s3">(</span><span class="s1">d </span><span class="s3">=&gt; </span><span class="s1">d</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">).</span><span class="s1">filter</span><span class="s3">(</span><span class="s1">Boolean</span><span class="s3">)[</span><span class="s7">0</span><span class="s3">]</span>
					<span class="s3">);</span>
					<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">notFoundError</span><span class="s3">, </span><span class="s1">factoryResult </span><span class="s3">? </span><span class="s1">result </span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">);</span>
				<span class="s3">}</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s1">result</span><span class="s3">) {</span>
					<span class="s4">return </span><span class="s1">callback</span><span class="s3">();</span>
				<span class="s3">}</span>

				<span class="s4">if </span><span class="s3">(</span><span class="s1">currentProfile </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
					<span class="s1">currentProfile</span><span class="s3">.</span><span class="s1">markFactoryEnd</span><span class="s3">();</span>
				<span class="s3">}</span>

				<span class="s1">callback</span><span class="s3">(</span><span class="s4">null</span><span class="s3">, </span><span class="s1">factoryResult </span><span class="s3">? </span><span class="s1">result </span><span class="s3">: </span><span class="s1">result</span><span class="s3">.</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} context context string path</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Dependency} dependency dependency used to create Module chain</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleCallback} callback callback for when module chain is complete</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void} will throw if dependency instance is not a valid Dependency</span>
	 <span class="s5">*/</span>
	<span class="s1">addModuleChain</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">dependency</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">addModuleTree</span><span class="s3">({ </span><span class="s1">context</span><span class="s3">, </span><span class="s1">dependency </span><span class="s3">}, </span><span class="s1">callback</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Object} options options</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} options.context context string path</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Dependency} options.dependency dependency used to create Module chain</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Partial&lt;ModuleFactoryCreateDataContextInfo&gt;=} options.contextInfo additional context info for the root module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleCallback} callback callback for when module chain is complete</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void} will throw if dependency instance is not a valid Dependency</span>
	 <span class="s5">*/</span>
	<span class="s1">addModuleTree</span><span class="s3">({ </span><span class="s1">context</span><span class="s3">, </span><span class="s1">dependency</span><span class="s3">, </span><span class="s1">contextInfo </span><span class="s3">}, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(</span>
			<span class="s4">typeof </span><span class="s1">dependency </span><span class="s3">!== </span><span class="s2">&quot;object&quot; </span><span class="s3">||</span>
			<span class="s1">dependency </span><span class="s3">=== </span><span class="s4">null </span><span class="s3">||</span>
			<span class="s3">!</span><span class="s1">dependency</span><span class="s3">.</span><span class="s1">constructor</span>
		<span class="s3">) {</span>
			<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span>
				<span class="s4">new </span><span class="s1">WebpackError</span><span class="s3">(</span><span class="s2">&quot;Parameter 'dependency' must be a Dependency&quot;</span><span class="s3">)</span>
			<span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">const </span><span class="s1">Dep </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{DepConstructor} */ </span><span class="s3">(</span><span class="s1">dependency</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">moduleFactory </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">dependencyFactories</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">Dep</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(!</span><span class="s1">moduleFactory</span><span class="s3">) {</span>
			<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span>
				<span class="s4">new </span><span class="s1">WebpackError</span><span class="s3">(</span>
					<span class="s2">`No dependency factory available for this dependency type: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">dependency</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">.</span><span class="s1">name</span><span class="s3">}</span><span class="s2">`</span>
				<span class="s3">)</span>
			<span class="s3">);</span>
		<span class="s3">}</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">handleModuleCreation</span><span class="s3">(</span>
			<span class="s3">{</span>
				<span class="s1">factory</span><span class="s3">: </span><span class="s1">moduleFactory</span><span class="s3">,</span>
				<span class="s1">dependencies</span><span class="s3">: [</span><span class="s1">dependency</span><span class="s3">],</span>
				<span class="s1">originModule</span><span class="s3">: </span><span class="s4">null</span><span class="s3">,</span>
				<span class="s1">contextInfo</span><span class="s3">,</span>
				<span class="s1">context</span>
			<span class="s3">},</span>
			<span class="s3">(</span><span class="s1">err</span><span class="s3">, </span><span class="s1">result</span><span class="s3">) =&gt; {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">err </span><span class="s3">&amp;&amp; </span><span class="s4">this</span><span class="s3">.</span><span class="s1">bail</span><span class="s3">) {</span>
					<span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">buildQueue</span><span class="s3">.</span><span class="s1">stop</span><span class="s3">();</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">rebuildQueue</span><span class="s3">.</span><span class="s1">stop</span><span class="s3">();</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">processDependenciesQueue</span><span class="s3">.</span><span class="s1">stop</span><span class="s3">();</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">factorizeQueue</span><span class="s3">.</span><span class="s1">stop</span><span class="s3">();</span>
				<span class="s3">} </span><span class="s4">else if </span><span class="s3">(!</span><span class="s1">err </span><span class="s3">&amp;&amp; </span><span class="s1">result</span><span class="s3">) {</span>
					<span class="s1">callback</span><span class="s3">(</span><span class="s4">null</span><span class="s3">, </span><span class="s1">result</span><span class="s3">);</span>
				<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
					<span class="s1">callback</span><span class="s3">();</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} context context path for entry</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Dependency} entry entry dependency that should be followed</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string | EntryOptions} optionsOrName options or deprecated name of entry</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleCallback} callback callback function</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void} returns</span>
	 <span class="s5">*/</span>
	<span class="s1">addEntry</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">entry</span><span class="s3">, </span><span class="s1">optionsOrName</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s0">// TODO webpack 6 remove</span>
		<span class="s4">const </span><span class="s1">options </span><span class="s3">=</span>
			<span class="s4">typeof </span><span class="s1">optionsOrName </span><span class="s3">=== </span><span class="s2">&quot;object&quot;</span>
				<span class="s3">? </span><span class="s1">optionsOrName</span>
				<span class="s3">: { </span><span class="s1">name</span><span class="s3">: </span><span class="s1">optionsOrName </span><span class="s3">};</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">_addEntryItem</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">entry</span><span class="s3">, </span><span class="s2">&quot;dependencies&quot;</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} context context path for entry</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Dependency} dependency dependency that should be followed</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{EntryOptions} options options</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleCallback} callback callback function</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void} returns</span>
	 <span class="s5">*/</span>
	<span class="s1">addInclude</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">dependency</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_addEntryItem</span><span class="s3">(</span>
			<span class="s1">context</span><span class="s3">,</span>
			<span class="s1">dependency</span><span class="s3">,</span>
			<span class="s2">&quot;includeDependencies&quot;</span><span class="s3">,</span>
			<span class="s1">options</span><span class="s3">,</span>
			<span class="s1">callback</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} context context path for entry</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Dependency} entry entry dependency that should be followed</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{&quot;dependencies&quot; | &quot;includeDependencies&quot;} target type of entry</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{EntryOptions} options options</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleCallback} callback callback function</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void} returns</span>
	 <span class="s5">*/</span>
	<span class="s1">_addEntryItem</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">entry</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s3">{ </span><span class="s1">name </span><span class="s3">} = </span><span class="s1">options</span><span class="s3">;</span>
		<span class="s4">let </span><span class="s1">entryData </span><span class="s3">=</span>
			<span class="s1">name </span><span class="s3">!== </span><span class="s1">undefined </span><span class="s3">? </span><span class="s4">this</span><span class="s3">.</span><span class="s1">entries</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) : </span><span class="s4">this</span><span class="s3">.</span><span class="s1">globalEntry</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">entryData </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s1">entryData </span><span class="s3">= {</span>
				<span class="s1">dependencies</span><span class="s3">: [],</span>
				<span class="s1">includeDependencies</span><span class="s3">: [],</span>
				<span class="s1">options</span><span class="s3">: {</span>
					<span class="s1">name</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
					<span class="s1">...options</span>
				<span class="s3">}</span>
			<span class="s3">};</span>
			<span class="s1">entryData</span><span class="s3">[</span><span class="s1">target</span><span class="s3">].</span><span class="s1">push</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">);</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">entries</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">entryData</span><span class="s3">);</span>
		<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
			<span class="s1">entryData</span><span class="s3">[</span><span class="s1">target</span><span class="s3">].</span><span class="s1">push</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">);</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">key of Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">options</span><span class="s3">)) {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">options</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] === </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">entryData</span><span class="s3">.</span><span class="s1">options</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] === </span><span class="s1">options</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s4">if </span><span class="s3">(</span>
					<span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">entryData</span><span class="s3">.</span><span class="s1">options</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]) &amp;&amp;</span>
					<span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">options</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]) &amp;&amp;</span>
					<span class="s1">arrayEquals</span><span class="s3">(</span><span class="s1">entryData</span><span class="s3">.</span><span class="s1">options</span><span class="s3">[</span><span class="s1">key</span><span class="s3">], </span><span class="s1">options</span><span class="s3">[</span><span class="s1">key</span><span class="s3">])</span>
				<span class="s3">) {</span>
					<span class="s4">continue</span><span class="s3">;</span>
				<span class="s3">}</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">entryData</span><span class="s3">.</span><span class="s1">options</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] === </span><span class="s1">undefined</span><span class="s3">) {</span>
					<span class="s1">entryData</span><span class="s3">.</span><span class="s1">options</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">options</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
				<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
					<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span>
						<span class="s4">new </span><span class="s1">WebpackError</span><span class="s3">(</span>
							<span class="s2">`Conflicting entry option </span><span class="s1">$</span><span class="s3">{</span><span class="s1">key</span><span class="s3">} </span><span class="s2">= </span><span class="s1">$</span><span class="s3">{</span><span class="s1">entryData</span><span class="s3">.</span><span class="s1">options</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]} </span><span class="s2">vs </span><span class="s1">$</span><span class="s3">{</span><span class="s1">options</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]}</span><span class="s2">`</span>
						<span class="s3">)</span>
					<span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">addEntry</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">, </span><span class="s1">options</span><span class="s3">);</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">addModuleTree</span><span class="s3">(</span>
			<span class="s3">{</span>
				<span class="s1">context</span><span class="s3">,</span>
				<span class="s1">dependency</span><span class="s3">: </span><span class="s1">entry</span><span class="s3">,</span>
				<span class="s1">contextInfo</span><span class="s3">: </span><span class="s1">entryData</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">layer</span>
					<span class="s3">? { </span><span class="s1">issuerLayer</span><span class="s3">: </span><span class="s1">entryData</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">layer </span><span class="s3">}</span>
					<span class="s3">: </span><span class="s1">undefined</span>
			<span class="s3">},</span>
			<span class="s3">(</span><span class="s1">err</span><span class="s3">, </span><span class="s1">module</span><span class="s3">) =&gt; {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">failedEntry</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">err</span><span class="s3">);</span>
					<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
				<span class="s3">}</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">succeedEntry</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
				<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s4">null</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module module to be rebuilt</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleCallback} callback callback when module finishes rebuilding</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">rebuildModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">rebuildQueue</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module module to be rebuilt</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleCallback} callback callback when module finishes rebuilding</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">_rebuildModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">rebuildModule</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">oldDependencies </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">dependencies</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">();</span>
		<span class="s4">const </span><span class="s1">oldBlocks </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">();</span>
		<span class="s1">module</span><span class="s3">.</span><span class="s1">invalidateBuild</span><span class="s3">();</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">buildQueue</span><span class="s3">.</span><span class="s1">invalidate</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">buildModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">err </span><span class="s3">=&gt; {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
				<span class="s4">return this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">finishRebuildingModule</span><span class="s3">.</span><span class="s1">callAsync</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">err2 </span><span class="s3">=&gt; {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">err2</span><span class="s3">) {</span>
						<span class="s1">callback</span><span class="s3">(</span>
							<span class="s1">makeWebpackError</span><span class="s3">(</span><span class="s1">err2</span><span class="s3">, </span><span class="s2">&quot;Compilation.hooks.finishRebuildingModule&quot;</span><span class="s3">)</span>
						<span class="s3">);</span>
						<span class="s4">return</span><span class="s3">;</span>
					<span class="s3">}</span>
					<span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
				<span class="s3">});</span>
			<span class="s3">}</span>

			<span class="s4">this</span><span class="s3">.</span><span class="s1">processDependenciesQueue</span><span class="s3">.</span><span class="s1">invalidate</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">unfreeze</span><span class="s3">();</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">processModuleDependencies</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">err </span><span class="s3">=&gt; {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) </span><span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">removeReasonsOfDependencyBlock</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, {</span>
					<span class="s1">dependencies</span><span class="s3">: </span><span class="s1">oldDependencies</span><span class="s3">,</span>
					<span class="s1">blocks</span><span class="s3">: </span><span class="s1">oldBlocks</span>
				<span class="s3">});</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">finishRebuildingModule</span><span class="s3">.</span><span class="s1">callAsync</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">err2 </span><span class="s3">=&gt; {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">err2</span><span class="s3">) {</span>
						<span class="s1">callback</span><span class="s3">(</span>
							<span class="s1">makeWebpackError</span><span class="s3">(</span><span class="s1">err2</span><span class="s3">, </span><span class="s2">&quot;Compilation.hooks.finishRebuildingModule&quot;</span><span class="s3">)</span>
						<span class="s3">);</span>
						<span class="s4">return</span><span class="s3">;</span>
					<span class="s3">}</span>
					<span class="s1">callback</span><span class="s3">(</span><span class="s4">null</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
				<span class="s3">});</span>
			<span class="s3">});</span>
		<span class="s3">});</span>
	<span class="s3">}</span>

	<span class="s1">_computeAffectedModules</span><span class="s3">(</span><span class="s1">modules</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">moduleMemCacheCache </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">moduleMemCaches</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(!</span><span class="s1">moduleMemCacheCache</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(!</span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleMemCaches</span><span class="s3">) {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleMemCaches </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">setModuleMemCaches</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleMemCaches</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">const </span><span class="s3">{ </span><span class="s1">moduleGraph</span><span class="s3">, </span><span class="s1">moduleMemCaches </span><span class="s3">} = </span><span class="s4">this</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">affectedModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s4">const </span><span class="s1">infectedModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s4">let </span><span class="s1">statNew </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s4">let </span><span class="s1">statChanged </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s4">let </span><span class="s1">statUnchanged </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s4">let </span><span class="s1">statReferencesChanged </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s4">let </span><span class="s1">statWithoutBuild </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>

		<span class="s4">const </span><span class="s1">computeReferences </span><span class="s3">= </span><span class="s1">module </span><span class="s3">=&gt; {</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WeakMap&lt;Dependency, Module&gt;} */</span>
			<span class="s4">let </span><span class="s1">references </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">connection of moduleGraph</span><span class="s3">.</span><span class="s1">getOutgoingConnections</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
				<span class="s4">const </span><span class="s1">d </span><span class="s3">= </span><span class="s1">connection</span><span class="s3">.</span><span class="s1">dependency</span><span class="s3">;</span>
				<span class="s4">const </span><span class="s1">m </span><span class="s3">= </span><span class="s1">connection</span><span class="s3">.</span><span class="s1">module</span><span class="s3">;</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s1">d </span><span class="s3">|| !</span><span class="s1">m </span><span class="s3">|| </span><span class="s1">unsafeCacheDependencies</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">d</span><span class="s3">)) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">references </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s1">references </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>
				<span class="s1">references</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">d</span><span class="s3">, </span><span class="s1">m</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">return </span><span class="s1">references</span><span class="s3">;</span>
		<span class="s3">};</span>

		<span class="s5">/**</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{WeakMap&lt;Dependency, Module&gt;} references references</span>
		 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true, when the references differ</span>
		 <span class="s5">*/</span>
		<span class="s4">const </span><span class="s1">compareReferences </span><span class="s3">= (</span><span class="s1">module</span><span class="s3">, </span><span class="s1">references</span><span class="s3">) =&gt; {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">references </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">return true</span><span class="s3">;</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">connection of moduleGraph</span><span class="s3">.</span><span class="s1">getOutgoingConnections</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
				<span class="s4">const </span><span class="s1">d </span><span class="s3">= </span><span class="s1">connection</span><span class="s3">.</span><span class="s1">dependency</span><span class="s3">;</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s1">d</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s4">const </span><span class="s1">entry </span><span class="s3">= </span><span class="s1">references</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">d</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">entry </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">entry </span><span class="s3">!== </span><span class="s1">connection</span><span class="s3">.</span><span class="s1">module</span><span class="s3">) </span><span class="s4">return false</span><span class="s3">;</span>
			<span class="s3">}</span>
			<span class="s4">return true</span><span class="s3">;</span>
		<span class="s3">};</span>

		<span class="s4">const </span><span class="s1">modulesWithoutCache </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">modules</span><span class="s3">);</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span><span class="s1">module</span><span class="s3">, </span><span class="s1">cachedMemCache</span><span class="s3">] </span><span class="s1">of moduleMemCacheCache</span><span class="s3">) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">modulesWithoutCache</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
				<span class="s4">const </span><span class="s1">buildInfo </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">;</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">buildInfo</span><span class="s3">) {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">cachedMemCache</span><span class="s3">.</span><span class="s1">buildInfo </span><span class="s3">!== </span><span class="s1">buildInfo</span><span class="s3">) {</span>
						<span class="s0">// use a new one</span>
						<span class="s4">const </span><span class="s1">memCache </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakTupleMap</span><span class="s3">();</span>
						<span class="s1">moduleMemCaches</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">memCache</span><span class="s3">);</span>
						<span class="s1">affectedModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
						<span class="s1">cachedMemCache</span><span class="s3">.</span><span class="s1">buildInfo </span><span class="s3">= </span><span class="s1">buildInfo</span><span class="s3">;</span>
						<span class="s1">cachedMemCache</span><span class="s3">.</span><span class="s1">references </span><span class="s3">= </span><span class="s1">computeReferences</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
						<span class="s1">cachedMemCache</span><span class="s3">.</span><span class="s1">memCache </span><span class="s3">= </span><span class="s1">memCache</span><span class="s3">;</span>
						<span class="s1">statChanged</span><span class="s3">++;</span>
					<span class="s3">} </span><span class="s4">else if </span><span class="s3">(!</span><span class="s1">compareReferences</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">cachedMemCache</span><span class="s3">.</span><span class="s1">references</span><span class="s3">)) {</span>
						<span class="s0">// use a new one</span>
						<span class="s4">const </span><span class="s1">memCache </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakTupleMap</span><span class="s3">();</span>
						<span class="s1">moduleMemCaches</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">memCache</span><span class="s3">);</span>
						<span class="s1">affectedModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
						<span class="s1">cachedMemCache</span><span class="s3">.</span><span class="s1">references </span><span class="s3">= </span><span class="s1">computeReferences</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
						<span class="s1">cachedMemCache</span><span class="s3">.</span><span class="s1">memCache </span><span class="s3">= </span><span class="s1">memCache</span><span class="s3">;</span>
						<span class="s1">statReferencesChanged</span><span class="s3">++;</span>
					<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
						<span class="s0">// keep the old mem cache</span>
						<span class="s1">moduleMemCaches</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">cachedMemCache</span><span class="s3">.</span><span class="s1">memCache</span><span class="s3">);</span>
						<span class="s1">statUnchanged</span><span class="s3">++;</span>
					<span class="s3">}</span>
				<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
					<span class="s1">infectedModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
					<span class="s1">moduleMemCacheCache</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
					<span class="s1">statWithoutBuild</span><span class="s3">++;</span>
				<span class="s3">}</span>
				<span class="s1">modulesWithoutCache</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
				<span class="s1">moduleMemCacheCache</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of modulesWithoutCache</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">buildInfo </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">;</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">buildInfo</span><span class="s3">) {</span>
				<span class="s0">// create a new entry</span>
				<span class="s4">const </span><span class="s1">memCache </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakTupleMap</span><span class="s3">();</span>
				<span class="s1">moduleMemCacheCache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, {</span>
					<span class="s1">buildInfo</span><span class="s3">,</span>
					<span class="s1">references</span><span class="s3">: </span><span class="s1">computeReferences</span><span class="s3">(</span><span class="s1">module</span><span class="s3">),</span>
					<span class="s1">memCache</span>
				<span class="s3">});</span>
				<span class="s1">moduleMemCaches</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">memCache</span><span class="s3">);</span>
				<span class="s1">affectedModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
				<span class="s1">statNew</span><span class="s3">++;</span>
			<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
				<span class="s1">infectedModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
				<span class="s1">statWithoutBuild</span><span class="s3">++;</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">const </span><span class="s1">reduceAffectType </span><span class="s3">= </span><span class="s1">connections </span><span class="s3">=&gt; {</span>
			<span class="s4">let </span><span class="s1">affected </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">{ </span><span class="s1">dependency </span><span class="s3">} </span><span class="s1">of connections</span><span class="s3">) {</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s1">dependency</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s4">const </span><span class="s1">type </span><span class="s3">= </span><span class="s1">dependency</span><span class="s3">.</span><span class="s1">couldAffectReferencingModule</span><span class="s3">();</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">type </span><span class="s3">=== </span><span class="s1">Dependency</span><span class="s3">.</span><span class="s1">TRANSITIVE</span><span class="s3">) </span><span class="s4">return </span><span class="s1">Dependency</span><span class="s3">.</span><span class="s1">TRANSITIVE</span><span class="s3">;</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s1">affected </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
			<span class="s3">}</span>
			<span class="s4">return </span><span class="s1">affected</span><span class="s3">;</span>
		<span class="s3">};</span>
		<span class="s4">const </span><span class="s1">directOnlyInfectedModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of infectedModules</span><span class="s3">) {</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span>
				<span class="s1">referencingModule</span><span class="s3">,</span>
				<span class="s1">connections</span>
			<span class="s3">] </span><span class="s1">of moduleGraph</span><span class="s3">.</span><span class="s1">getIncomingConnectionsByOriginModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s1">referencingModule</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">infectedModules</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">referencingModule</span><span class="s3">)) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s4">const </span><span class="s1">type </span><span class="s3">= </span><span class="s1">reduceAffectType</span><span class="s3">(</span><span class="s1">connections</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s1">type</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">true</span><span class="s3">) {</span>
					<span class="s1">directOnlyInfectedModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">referencingModule</span><span class="s3">);</span>
				<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
					<span class="s1">infectedModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">referencingModule</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of directOnlyInfectedModules</span><span class="s3">) </span><span class="s1">infectedModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">directOnlyAffectModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of affectedModules</span><span class="s3">) {</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span>
				<span class="s1">referencingModule</span><span class="s3">,</span>
				<span class="s1">connections</span>
			<span class="s3">] </span><span class="s1">of moduleGraph</span><span class="s3">.</span><span class="s1">getIncomingConnectionsByOriginModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s1">referencingModule</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">infectedModules</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">referencingModule</span><span class="s3">)) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">affectedModules</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">referencingModule</span><span class="s3">)) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s4">const </span><span class="s1">type </span><span class="s3">= </span><span class="s1">reduceAffectType</span><span class="s3">(</span><span class="s1">connections</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s1">type</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">true</span><span class="s3">) {</span>
					<span class="s1">directOnlyAffectModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">referencingModule</span><span class="s3">);</span>
				<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
					<span class="s1">affectedModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">referencingModule</span><span class="s3">);</span>
				<span class="s3">}</span>
				<span class="s4">const </span><span class="s1">memCache </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakTupleMap</span><span class="s3">();</span>
				<span class="s4">const </span><span class="s1">cache </span><span class="s3">= </span><span class="s1">moduleMemCacheCache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">referencingModule</span><span class="s3">);</span>
				<span class="s1">cache</span><span class="s3">.</span><span class="s1">memCache </span><span class="s3">= </span><span class="s1">memCache</span><span class="s3">;</span>
				<span class="s1">moduleMemCaches</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">referencingModule</span><span class="s3">, </span><span class="s1">memCache</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of directOnlyAffectModules</span><span class="s3">) </span><span class="s1">affectedModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span>
			<span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span>
				<span class="s3">(</span><span class="s7">100 </span><span class="s3">* (</span><span class="s1">affectedModules</span><span class="s3">.</span><span class="s1">size </span><span class="s3">+ </span><span class="s1">infectedModules</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)) /</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size</span>
			<span class="s3">)}</span><span class="s2">% (</span><span class="s1">$</span><span class="s3">{</span><span class="s1">affectedModules</span><span class="s3">.</span><span class="s1">size</span><span class="s3">} </span><span class="s2">affected + </span><span class="s1">$</span><span class="s3">{</span>
				<span class="s1">infectedModules</span><span class="s3">.</span><span class="s1">size</span>
			<span class="s3">} </span><span class="s2">infected of </span><span class="s1">$</span><span class="s3">{</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size</span>
			<span class="s3">}</span><span class="s2">) modules flagged as affected (</span><span class="s1">$</span><span class="s3">{</span><span class="s1">statNew</span><span class="s3">} </span><span class="s2">new modules, </span><span class="s1">$</span><span class="s3">{</span><span class="s1">statChanged</span><span class="s3">} </span><span class="s2">changed, </span><span class="s1">$</span><span class="s3">{</span><span class="s1">statReferencesChanged</span><span class="s3">} </span><span class="s2">references changed, </span><span class="s1">$</span><span class="s3">{</span><span class="s1">statUnchanged</span><span class="s3">} </span><span class="s2">unchanged, </span><span class="s1">$</span><span class="s3">{</span><span class="s1">statWithoutBuild</span><span class="s3">} </span><span class="s2">were not built)`</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s1">_computeAffectedModulesWithChunkGraph</span><span class="s3">() {</span>
		<span class="s4">const </span><span class="s3">{ </span><span class="s1">moduleMemCaches </span><span class="s3">} = </span><span class="s4">this</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(!</span><span class="s1">moduleMemCaches</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">moduleMemCaches2 </span><span class="s3">= (</span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleMemCaches2 </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">());</span>
		<span class="s4">const </span><span class="s3">{ </span><span class="s1">moduleGraph</span><span class="s3">, </span><span class="s1">chunkGraph </span><span class="s3">} = </span><span class="s4">this</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">key </span><span class="s3">= </span><span class="s2">&quot;memCache2&quot;</span><span class="s3">;</span>
		<span class="s4">let </span><span class="s1">statUnchanged </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s4">let </span><span class="s1">statChanged </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s4">let </span><span class="s1">statNew </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s5">/**</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module module</span>
		 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{{ id: string | number, modules?: Map&lt;Module, string | number | undefined&gt;, blocks?: (string | number)[] }} references</span>
		 <span class="s5">*/</span>
		<span class="s4">const </span><span class="s1">computeReferences </span><span class="s3">= </span><span class="s1">module </span><span class="s3">=&gt; {</span>
			<span class="s4">const </span><span class="s1">id </span><span class="s3">= </span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getModuleId</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;Module, string | number | undefined&gt;} */</span>
			<span class="s4">let </span><span class="s1">modules </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{(string | number)[] | undefined} */</span>
			<span class="s4">let </span><span class="s1">blocks </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
			<span class="s4">const </span><span class="s1">outgoing </span><span class="s3">= </span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getOutgoingConnectionsByModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">outgoing </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">m of outgoing</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()) {</span>
					<span class="s4">if </span><span class="s3">(!</span><span class="s1">m</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">modules </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s1">modules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
					<span class="s1">modules</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getModuleId</span><span class="s3">(</span><span class="s1">m</span><span class="s3">));</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
				<span class="s1">blocks </span><span class="s3">= [];</span>
				<span class="s4">const </span><span class="s1">queue </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">);</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">block of queue</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">chunkGroup </span><span class="s3">= </span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getBlockChunkGroup</span><span class="s3">(</span><span class="s1">block</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">chunkGroup</span><span class="s3">) {</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of chunkGroup</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">) {</span>
							<span class="s1">blocks</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">id</span><span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
						<span class="s1">blocks</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s4">null</span><span class="s3">);</span>
					<span class="s3">}</span>
					<span class="s1">queue</span><span class="s3">.</span><span class="s1">push</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">queue</span><span class="s3">, </span><span class="s1">block</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
			<span class="s4">return </span><span class="s3">{ </span><span class="s1">id</span><span class="s3">, </span><span class="s1">modules</span><span class="s3">, </span><span class="s1">blocks </span><span class="s3">};</span>
		<span class="s3">};</span>
		<span class="s5">/**</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module module</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Object} references references</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string | number} references.id id</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Map&lt;Module, string | number&gt;=} references.modules modules</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{(string | number)[]=} references.blocks blocks</span>
		 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} ok?</span>
		 <span class="s5">*/</span>
		<span class="s4">const </span><span class="s1">compareReferences </span><span class="s3">= (</span><span class="s1">module</span><span class="s3">, { </span><span class="s1">id</span><span class="s3">, </span><span class="s1">modules</span><span class="s3">, </span><span class="s1">blocks </span><span class="s3">}) =&gt; {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">id </span><span class="s3">!== </span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getModuleId</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) </span><span class="s4">return false</span><span class="s3">;</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">modules </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span><span class="s1">module</span><span class="s3">, </span><span class="s1">id</span><span class="s3">] </span><span class="s1">of modules</span><span class="s3">) {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getModuleId</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) !== </span><span class="s1">id</span><span class="s3">) </span><span class="s4">return false</span><span class="s3">;</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">blocks </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">queue </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">);</span>
				<span class="s4">let </span><span class="s1">i </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">block of queue</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">chunkGroup </span><span class="s3">= </span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getBlockChunkGroup</span><span class="s3">(</span><span class="s1">block</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">chunkGroup</span><span class="s3">) {</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of chunkGroup</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">) {</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">&gt;= </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">length </span><span class="s3">|| </span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">i</span><span class="s3">++] !== </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">id</span><span class="s3">) </span><span class="s4">return false</span><span class="s3">;</span>
						<span class="s3">}</span>
					<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">&gt;= </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">length </span><span class="s3">|| </span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">i</span><span class="s3">++] !== </span><span class="s4">null</span><span class="s3">) </span><span class="s4">return false</span><span class="s3">;</span>
					<span class="s3">}</span>
					<span class="s1">queue</span><span class="s3">.</span><span class="s1">push</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">queue</span><span class="s3">, </span><span class="s1">block</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">);</span>
				<span class="s3">}</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">!== </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) </span><span class="s4">return false</span><span class="s3">;</span>
			<span class="s3">}</span>
			<span class="s4">return true</span><span class="s3">;</span>
		<span class="s3">};</span>

		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span><span class="s1">module</span><span class="s3">, </span><span class="s1">memCache</span><span class="s3">] </span><span class="s1">of moduleMemCaches</span><span class="s3">) {</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{{ references: { id: string | number, modules?: Map&lt;Module, string | number | undefined&gt;, blocks?: (string | number)[]}, memCache: WeakTupleMap&lt;any[], any&gt; }} */</span>
			<span class="s4">const </span><span class="s1">cache </span><span class="s3">= </span><span class="s1">memCache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">cache </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">memCache2 </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakTupleMap</span><span class="s3">();</span>
				<span class="s1">memCache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, {</span>
					<span class="s1">references</span><span class="s3">: </span><span class="s1">computeReferences</span><span class="s3">(</span><span class="s1">module</span><span class="s3">),</span>
					<span class="s1">memCache</span><span class="s3">: </span><span class="s1">memCache2</span>
				<span class="s3">});</span>
				<span class="s1">moduleMemCaches2</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">memCache2</span><span class="s3">);</span>
				<span class="s1">statNew</span><span class="s3">++;</span>
			<span class="s3">} </span><span class="s4">else if </span><span class="s3">(!</span><span class="s1">compareReferences</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">cache</span><span class="s3">.</span><span class="s1">references</span><span class="s3">)) {</span>
				<span class="s4">const </span><span class="s1">memCache </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakTupleMap</span><span class="s3">();</span>
				<span class="s1">cache</span><span class="s3">.</span><span class="s1">references </span><span class="s3">= </span><span class="s1">computeReferences</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
				<span class="s1">cache</span><span class="s3">.</span><span class="s1">memCache </span><span class="s3">= </span><span class="s1">memCache</span><span class="s3">;</span>
				<span class="s1">moduleMemCaches2</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">memCache</span><span class="s3">);</span>
				<span class="s1">statChanged</span><span class="s3">++;</span>
			<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
				<span class="s1">moduleMemCaches2</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">cache</span><span class="s3">.</span><span class="s1">memCache</span><span class="s3">);</span>
				<span class="s1">statUnchanged</span><span class="s3">++;</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span>
			<span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span>
				<span class="s3">(</span><span class="s7">100 </span><span class="s3">* </span><span class="s1">statChanged</span><span class="s3">) / (</span><span class="s1">statNew </span><span class="s3">+ </span><span class="s1">statChanged </span><span class="s3">+ </span><span class="s1">statUnchanged</span><span class="s3">)</span>
			<span class="s3">)}</span><span class="s2">% modules flagged as affected by chunk graph (</span><span class="s1">$</span><span class="s3">{</span><span class="s1">statNew</span><span class="s3">} </span><span class="s2">new modules, </span><span class="s1">$</span><span class="s3">{</span><span class="s1">statChanged</span><span class="s3">} </span><span class="s2">changed, </span><span class="s1">$</span><span class="s3">{</span><span class="s1">statUnchanged</span><span class="s3">} </span><span class="s2">unchanged)`</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s1">finish</span><span class="s3">(</span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">factorizeQueue</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">profile</span><span class="s3">) {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;finish module profiles&quot;</span><span class="s3">);</span>
			<span class="s4">const </span><span class="s1">ParallelismFactorCalculator </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/ParallelismFactorCalculator&quot;</span><span class="s3">);</span>
			<span class="s4">const </span><span class="s1">p </span><span class="s3">= </span><span class="s4">new </span><span class="s1">ParallelismFactorCalculator</span><span class="s3">();</span>
			<span class="s4">const </span><span class="s1">moduleGraph </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">;</span>
			<span class="s4">const </span><span class="s1">modulesWithProfiles </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">profile </span><span class="s3">= </span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getProfile</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s1">profile</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s1">modulesWithProfiles</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">profile</span><span class="s3">);</span>
				<span class="s1">p</span><span class="s3">.</span><span class="s1">range</span><span class="s3">(</span>
					<span class="s1">profile</span><span class="s3">.</span><span class="s1">buildingStartTime</span><span class="s3">,</span>
					<span class="s1">profile</span><span class="s3">.</span><span class="s1">buildingEndTime</span><span class="s3">,</span>
					<span class="s1">f </span><span class="s3">=&gt; (</span><span class="s1">profile</span><span class="s3">.</span><span class="s1">buildingParallelismFactor </span><span class="s3">= </span><span class="s1">f</span><span class="s3">)</span>
				<span class="s3">);</span>
				<span class="s1">p</span><span class="s3">.</span><span class="s1">range</span><span class="s3">(</span>
					<span class="s1">profile</span><span class="s3">.</span><span class="s1">factoryStartTime</span><span class="s3">,</span>
					<span class="s1">profile</span><span class="s3">.</span><span class="s1">factoryEndTime</span><span class="s3">,</span>
					<span class="s1">f </span><span class="s3">=&gt; (</span><span class="s1">profile</span><span class="s3">.</span><span class="s1">factoryParallelismFactor </span><span class="s3">= </span><span class="s1">f</span><span class="s3">)</span>
				<span class="s3">);</span>
				<span class="s1">p</span><span class="s3">.</span><span class="s1">range</span><span class="s3">(</span>
					<span class="s1">profile</span><span class="s3">.</span><span class="s1">integrationStartTime</span><span class="s3">,</span>
					<span class="s1">profile</span><span class="s3">.</span><span class="s1">integrationEndTime</span><span class="s3">,</span>
					<span class="s1">f </span><span class="s3">=&gt; (</span><span class="s1">profile</span><span class="s3">.</span><span class="s1">integrationParallelismFactor </span><span class="s3">= </span><span class="s1">f</span><span class="s3">)</span>
				<span class="s3">);</span>
				<span class="s1">p</span><span class="s3">.</span><span class="s1">range</span><span class="s3">(</span>
					<span class="s1">profile</span><span class="s3">.</span><span class="s1">storingStartTime</span><span class="s3">,</span>
					<span class="s1">profile</span><span class="s3">.</span><span class="s1">storingEndTime</span><span class="s3">,</span>
					<span class="s1">f </span><span class="s3">=&gt; (</span><span class="s1">profile</span><span class="s3">.</span><span class="s1">storingParallelismFactor </span><span class="s3">= </span><span class="s1">f</span><span class="s3">)</span>
				<span class="s3">);</span>
				<span class="s1">p</span><span class="s3">.</span><span class="s1">range</span><span class="s3">(</span>
					<span class="s1">profile</span><span class="s3">.</span><span class="s1">restoringStartTime</span><span class="s3">,</span>
					<span class="s1">profile</span><span class="s3">.</span><span class="s1">restoringEndTime</span><span class="s3">,</span>
					<span class="s1">f </span><span class="s3">=&gt; (</span><span class="s1">profile</span><span class="s3">.</span><span class="s1">restoringParallelismFactor </span><span class="s3">= </span><span class="s1">f</span><span class="s3">)</span>
				<span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">profile</span><span class="s3">.</span><span class="s1">additionalFactoryTimes</span><span class="s3">) {</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">{ </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end </span><span class="s3">} </span><span class="s1">of profile</span><span class="s3">.</span><span class="s1">additionalFactoryTimes</span><span class="s3">) {</span>
						<span class="s4">const </span><span class="s1">influence </span><span class="s3">= (</span><span class="s1">end </span><span class="s3">- </span><span class="s1">start</span><span class="s3">) / </span><span class="s1">profile</span><span class="s3">.</span><span class="s1">additionalFactories</span><span class="s3">;</span>
						<span class="s1">p</span><span class="s3">.</span><span class="s1">range</span><span class="s3">(</span>
							<span class="s1">start</span><span class="s3">,</span>
							<span class="s1">end</span><span class="s3">,</span>
							<span class="s1">f </span><span class="s3">=&gt;</span>
								<span class="s3">(</span><span class="s1">profile</span><span class="s3">.</span><span class="s1">additionalFactoriesParallelismFactor </span><span class="s3">+= </span><span class="s1">f </span><span class="s3">* </span><span class="s1">influence</span><span class="s3">)</span>
						<span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
			<span class="s1">p</span><span class="s3">.</span><span class="s1">calculate</span><span class="s3">();</span>

			<span class="s4">const </span><span class="s1">logger </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">getLogger</span><span class="s3">(</span><span class="s2">&quot;webpack.Compilation.ModuleProfile&quot;</span><span class="s3">);</span>
			<span class="s0">// Avoid coverage problems due indirect changes</span>
			<span class="s0">/* istanbul ignore next */</span>
			<span class="s4">const </span><span class="s1">logByValue </span><span class="s3">= (</span><span class="s1">value</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">) =&gt; {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">value </span><span class="s3">&gt; </span><span class="s7">1000</span><span class="s3">) {</span>
					<span class="s1">logger</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">);</span>
				<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">value </span><span class="s3">&gt; </span><span class="s7">500</span><span class="s3">) {</span>
					<span class="s1">logger</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">);</span>
				<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">value </span><span class="s3">&gt; </span><span class="s7">200</span><span class="s3">) {</span>
					<span class="s1">logger</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">);</span>
				<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">value </span><span class="s3">&gt; </span><span class="s7">30</span><span class="s3">) {</span>
					<span class="s1">logger</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">);</span>
				<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
					<span class="s1">logger</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">};</span>
			<span class="s4">const </span><span class="s1">logNormalSummary </span><span class="s3">= (</span><span class="s1">category</span><span class="s3">, </span><span class="s1">getDuration</span><span class="s3">, </span><span class="s1">getParallelism</span><span class="s3">) =&gt; {</span>
				<span class="s4">let </span><span class="s1">sum </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
				<span class="s4">let </span><span class="s1">max </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span><span class="s1">module</span><span class="s3">, </span><span class="s1">profile</span><span class="s3">] </span><span class="s1">of modulesWithProfiles</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">p </span><span class="s3">= </span><span class="s1">getParallelism</span><span class="s3">(</span><span class="s1">profile</span><span class="s3">);</span>
					<span class="s4">const </span><span class="s1">d </span><span class="s3">= </span><span class="s1">getDuration</span><span class="s3">(</span><span class="s1">profile</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">d </span><span class="s3">=== </span><span class="s7">0 </span><span class="s3">|| </span><span class="s1">p </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
					<span class="s4">const </span><span class="s1">t </span><span class="s3">= </span><span class="s1">d </span><span class="s3">/ </span><span class="s1">p</span><span class="s3">;</span>
					<span class="s1">sum </span><span class="s3">+= </span><span class="s1">t</span><span class="s3">;</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">t </span><span class="s3">&lt;= </span><span class="s7">10</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
					<span class="s1">logByValue</span><span class="s3">(</span>
						<span class="s1">t</span><span class="s3">,</span>
						<span class="s2">` | </span><span class="s1">$</span><span class="s3">{</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">t</span><span class="s3">)} </span><span class="s2">ms</span><span class="s1">$</span><span class="s3">{</span>
							<span class="s1">p </span><span class="s3">&gt;= </span><span class="s7">1.1 </span><span class="s3">? </span><span class="s2">` (parallelism </span><span class="s1">$</span><span class="s3">{</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">p </span><span class="s3">* </span><span class="s7">10</span><span class="s3">) / </span><span class="s7">10</span><span class="s3">}</span><span class="s2">)` </span><span class="s3">: </span><span class="s2">&quot;&quot;</span>
						<span class="s3">} </span><span class="s1">$</span><span class="s3">{</span><span class="s1">category</span><span class="s3">} </span><span class="s2">&gt; </span><span class="s1">$</span><span class="s3">{</span><span class="s1">module</span><span class="s3">.</span><span class="s1">readableIdentifier</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">requestShortener</span><span class="s3">)}</span><span class="s2">`</span>
					<span class="s3">);</span>
					<span class="s1">max </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">max</span><span class="s3">, </span><span class="s1">t</span><span class="s3">);</span>
				<span class="s3">}</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">sum </span><span class="s3">&lt;= </span><span class="s7">10</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
				<span class="s1">logByValue</span><span class="s3">(</span>
					<span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">sum </span><span class="s3">/ </span><span class="s7">10</span><span class="s3">, </span><span class="s1">max</span><span class="s3">),</span>
					<span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">sum</span><span class="s3">)} </span><span class="s2">ms </span><span class="s1">$</span><span class="s3">{</span><span class="s1">category</span><span class="s3">}</span><span class="s2">`</span>
				<span class="s3">);</span>
			<span class="s3">};</span>
			<span class="s4">const </span><span class="s1">logByLoadersSummary </span><span class="s3">= (</span><span class="s1">category</span><span class="s3">, </span><span class="s1">getDuration</span><span class="s3">, </span><span class="s1">getParallelism</span><span class="s3">) =&gt; {</span>
				<span class="s4">const </span><span class="s1">map </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span><span class="s1">module</span><span class="s3">, </span><span class="s1">profile</span><span class="s3">] </span><span class="s1">of modulesWithProfiles</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">list </span><span class="s3">= </span><span class="s1">getOrInsert</span><span class="s3">(</span>
						<span class="s1">map</span><span class="s3">,</span>
						<span class="s1">module</span><span class="s3">.</span><span class="s1">type </span><span class="s3">+ </span><span class="s2">&quot;!&quot; </span><span class="s3">+ </span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">().</span><span class="s1">replace</span><span class="s3">(</span><span class="s8">/(!|^)[^!]*$/</span><span class="s3">, </span><span class="s2">&quot;&quot;</span><span class="s3">),</span>
						<span class="s3">() =&gt; []</span>
					<span class="s3">);</span>
					<span class="s1">list</span><span class="s3">.</span><span class="s1">push</span><span class="s3">({ </span><span class="s1">module</span><span class="s3">, </span><span class="s1">profile </span><span class="s3">});</span>
				<span class="s3">}</span>

				<span class="s4">let </span><span class="s1">sum </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
				<span class="s4">let </span><span class="s1">max </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span><span class="s1">key</span><span class="s3">, </span><span class="s1">modules</span><span class="s3">] </span><span class="s1">of map</span><span class="s3">) {</span>
					<span class="s4">let </span><span class="s1">innerSum </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
					<span class="s4">let </span><span class="s1">innerMax </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">{ </span><span class="s1">module</span><span class="s3">, </span><span class="s1">profile </span><span class="s3">} </span><span class="s1">of modules</span><span class="s3">) {</span>
						<span class="s4">const </span><span class="s1">p </span><span class="s3">= </span><span class="s1">getParallelism</span><span class="s3">(</span><span class="s1">profile</span><span class="s3">);</span>
						<span class="s4">const </span><span class="s1">d </span><span class="s3">= </span><span class="s1">getDuration</span><span class="s3">(</span><span class="s1">profile</span><span class="s3">);</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">d </span><span class="s3">=== </span><span class="s7">0 </span><span class="s3">|| </span><span class="s1">p </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
						<span class="s4">const </span><span class="s1">t </span><span class="s3">= </span><span class="s1">d </span><span class="s3">/ </span><span class="s1">p</span><span class="s3">;</span>
						<span class="s1">innerSum </span><span class="s3">+= </span><span class="s1">t</span><span class="s3">;</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">t </span><span class="s3">&lt;= </span><span class="s7">10</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
						<span class="s1">logByValue</span><span class="s3">(</span>
							<span class="s1">t</span><span class="s3">,</span>
							<span class="s2">` |  | </span><span class="s1">$</span><span class="s3">{</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">t</span><span class="s3">)} </span><span class="s2">ms</span><span class="s1">$</span><span class="s3">{</span>
								<span class="s1">p </span><span class="s3">&gt;= </span><span class="s7">1.1 </span><span class="s3">? </span><span class="s2">` (parallelism </span><span class="s1">$</span><span class="s3">{</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">p </span><span class="s3">* </span><span class="s7">10</span><span class="s3">) / </span><span class="s7">10</span><span class="s3">}</span><span class="s2">)` </span><span class="s3">: </span><span class="s2">&quot;&quot;</span>
							<span class="s3">} </span><span class="s1">$</span><span class="s3">{</span><span class="s1">category</span><span class="s3">} </span><span class="s2">&gt; </span><span class="s1">$</span><span class="s3">{</span><span class="s1">module</span><span class="s3">.</span><span class="s1">readableIdentifier</span><span class="s3">(</span>
								<span class="s4">this</span><span class="s3">.</span><span class="s1">requestShortener</span>
							<span class="s3">)}</span><span class="s2">`</span>
						<span class="s3">);</span>
						<span class="s1">innerMax </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">innerMax</span><span class="s3">, </span><span class="s1">t</span><span class="s3">);</span>
					<span class="s3">}</span>
					<span class="s1">sum </span><span class="s3">+= </span><span class="s1">innerSum</span><span class="s3">;</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">innerSum </span><span class="s3">&lt;= </span><span class="s7">10</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
					<span class="s4">const </span><span class="s1">idx </span><span class="s3">= </span><span class="s1">key</span><span class="s3">.</span><span class="s1">indexOf</span><span class="s3">(</span><span class="s2">&quot;!&quot;</span><span class="s3">);</span>
					<span class="s4">const </span><span class="s1">loaders </span><span class="s3">= </span><span class="s1">key</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">idx </span><span class="s3">+ </span><span class="s7">1</span><span class="s3">);</span>
					<span class="s4">const </span><span class="s1">moduleType </span><span class="s3">= </span><span class="s1">key</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">0</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">);</span>
					<span class="s4">const </span><span class="s1">t </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">innerSum </span><span class="s3">/ </span><span class="s7">10</span><span class="s3">, </span><span class="s1">innerMax</span><span class="s3">);</span>
					<span class="s1">logByValue</span><span class="s3">(</span>
						<span class="s1">t</span><span class="s3">,</span>
						<span class="s2">` | </span><span class="s1">$</span><span class="s3">{</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">innerSum</span><span class="s3">)} </span><span class="s2">ms </span><span class="s1">$</span><span class="s3">{</span><span class="s1">category</span><span class="s3">} </span><span class="s2">&gt; </span><span class="s1">$</span><span class="s3">{</span>
							<span class="s1">loaders</span>
								<span class="s3">? </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span>
										<span class="s1">modules</span><span class="s3">.</span><span class="s1">length</span>
								  <span class="s3">} </span><span class="s2">x </span><span class="s1">$</span><span class="s3">{</span><span class="s1">moduleType</span><span class="s3">} </span><span class="s2">with </span><span class="s1">$</span><span class="s3">{</span><span class="s4">this</span><span class="s3">.</span><span class="s1">requestShortener</span><span class="s3">.</span><span class="s1">shorten</span><span class="s3">(</span>
										<span class="s1">loaders</span>
								  <span class="s3">)}</span><span class="s2">`</span>
								<span class="s3">: </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">length</span><span class="s3">} </span><span class="s2">x </span><span class="s1">$</span><span class="s3">{</span><span class="s1">moduleType</span><span class="s3">}</span><span class="s2">`</span>
						<span class="s3">}</span><span class="s2">`</span>
					<span class="s3">);</span>
					<span class="s1">max </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">max</span><span class="s3">, </span><span class="s1">t</span><span class="s3">);</span>
				<span class="s3">}</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">sum </span><span class="s3">&lt;= </span><span class="s7">10</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
				<span class="s1">logByValue</span><span class="s3">(</span>
					<span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">sum </span><span class="s3">/ </span><span class="s7">10</span><span class="s3">, </span><span class="s1">max</span><span class="s3">),</span>
					<span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">sum</span><span class="s3">)} </span><span class="s2">ms </span><span class="s1">$</span><span class="s3">{</span><span class="s1">category</span><span class="s3">}</span><span class="s2">`</span>
				<span class="s3">);</span>
			<span class="s3">};</span>
			<span class="s1">logNormalSummary</span><span class="s3">(</span>
				<span class="s2">&quot;resolve to new modules&quot;</span><span class="s3">,</span>
				<span class="s1">p </span><span class="s3">=&gt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">factory</span><span class="s3">,</span>
				<span class="s1">p </span><span class="s3">=&gt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">factoryParallelismFactor</span>
			<span class="s3">);</span>
			<span class="s1">logNormalSummary</span><span class="s3">(</span>
				<span class="s2">&quot;resolve to existing modules&quot;</span><span class="s3">,</span>
				<span class="s1">p </span><span class="s3">=&gt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">additionalFactories</span><span class="s3">,</span>
				<span class="s1">p </span><span class="s3">=&gt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">additionalFactoriesParallelismFactor</span>
			<span class="s3">);</span>
			<span class="s1">logNormalSummary</span><span class="s3">(</span>
				<span class="s2">&quot;integrate modules&quot;</span><span class="s3">,</span>
				<span class="s1">p </span><span class="s3">=&gt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">restoring</span><span class="s3">,</span>
				<span class="s1">p </span><span class="s3">=&gt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">restoringParallelismFactor</span>
			<span class="s3">);</span>
			<span class="s1">logByLoadersSummary</span><span class="s3">(</span>
				<span class="s2">&quot;build modules&quot;</span><span class="s3">,</span>
				<span class="s1">p </span><span class="s3">=&gt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">building</span><span class="s3">,</span>
				<span class="s1">p </span><span class="s3">=&gt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">buildingParallelismFactor</span>
			<span class="s3">);</span>
			<span class="s1">logNormalSummary</span><span class="s3">(</span>
				<span class="s2">&quot;store modules&quot;</span><span class="s3">,</span>
				<span class="s1">p </span><span class="s3">=&gt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">storing</span><span class="s3">,</span>
				<span class="s1">p </span><span class="s3">=&gt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">storingParallelismFactor</span>
			<span class="s3">);</span>
			<span class="s1">logNormalSummary</span><span class="s3">(</span>
				<span class="s2">&quot;restore modules&quot;</span><span class="s3">,</span>
				<span class="s1">p </span><span class="s3">=&gt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">restoring</span><span class="s3">,</span>
				<span class="s1">p </span><span class="s3">=&gt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">restoringParallelismFactor</span>
			<span class="s3">);</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;finish module profiles&quot;</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;compute affected modules&quot;</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_computeAffectedModules</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;compute affected modules&quot;</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;finish modules&quot;</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s3">{ </span><span class="s1">modules</span><span class="s3">, </span><span class="s1">moduleMemCaches </span><span class="s3">} = </span><span class="s4">this</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">finishModules</span><span class="s3">.</span><span class="s1">callAsync</span><span class="s3">(</span><span class="s1">modules</span><span class="s3">, </span><span class="s1">err </span><span class="s3">=&gt; {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;finish modules&quot;</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) </span><span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>

			<span class="s0">// extract warnings and errors from modules</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">freeze</span><span class="s3">(</span><span class="s2">&quot;dependency errors&quot;</span><span class="s3">);</span>
			<span class="s0">// TODO keep a cacheToken (= {}) for each module in the graph</span>
			<span class="s0">// create a new one per compilation and flag all updated files</span>
			<span class="s0">// and parents with it</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;report dependency errors and warnings&quot;</span><span class="s3">);</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of modules</span><span class="s3">) {</span>
				<span class="s0">// TODO only run for modules with changed cacheToken</span>
				<span class="s0">// global WeakMap&lt;CacheToken, WeakSet&lt;Module&gt;&gt; to keep modules without errors/warnings</span>
				<span class="s4">const </span><span class="s1">memCache </span><span class="s3">= </span><span class="s1">moduleMemCaches </span><span class="s3">&amp;&amp; </span><span class="s1">moduleMemCaches</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">memCache </span><span class="s3">&amp;&amp; </span><span class="s1">memCache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s2">&quot;noWarningsOrErrors&quot;</span><span class="s3">)) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s4">let </span><span class="s1">hasProblems </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">reportDependencyErrorsAndWarnings</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, [</span>
					<span class="s1">module</span>
				<span class="s3">]);</span>
				<span class="s4">const </span><span class="s1">errors </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">getErrors</span><span class="s3">();</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">errors </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">error of errors</span><span class="s3">) {</span>
						<span class="s4">if </span><span class="s3">(!</span><span class="s1">error</span><span class="s3">.</span><span class="s1">module</span><span class="s3">) {</span>
							<span class="s1">error</span><span class="s3">.</span><span class="s1">module </span><span class="s3">= </span><span class="s1">module</span><span class="s3">;</span>
						<span class="s3">}</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">error</span><span class="s3">);</span>
						<span class="s1">hasProblems </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
				<span class="s4">const </span><span class="s1">warnings </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">getWarnings</span><span class="s3">();</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">warnings </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">warning of warnings</span><span class="s3">) {</span>
						<span class="s4">if </span><span class="s3">(!</span><span class="s1">warning</span><span class="s3">.</span><span class="s1">module</span><span class="s3">) {</span>
							<span class="s1">warning</span><span class="s3">.</span><span class="s1">module </span><span class="s3">= </span><span class="s1">module</span><span class="s3">;</span>
						<span class="s3">}</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">warning</span><span class="s3">);</span>
						<span class="s1">hasProblems </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s1">hasProblems </span><span class="s3">&amp;&amp; </span><span class="s1">memCache</span><span class="s3">) </span><span class="s1">memCache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s2">&quot;noWarningsOrErrors&quot;</span><span class="s3">, </span><span class="s4">true</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">unfreeze</span><span class="s3">();</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;report dependency errors and warnings&quot;</span><span class="s3">);</span>

			<span class="s1">callback</span><span class="s3">();</span>
		<span class="s3">});</span>
	<span class="s3">}</span>

	<span class="s1">unseal</span><span class="s3">() {</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">unseal</span><span class="s3">.</span><span class="s1">call</span><span class="s3">();</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGroups</span><span class="s3">.</span><span class="s1">length </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">namedChunks</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">namedChunkGroups</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">entrypoints</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">additionalChunkAssets</span><span class="s3">.</span><span class="s1">length </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">assets </span><span class="s3">= {};</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">assetsInfo</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">removeAllModuleAttributes</span><span class="s3">();</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">unfreeze</span><span class="s3">();</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleMemCaches2 </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Callback} callback signals when the call finishes</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">seal</span><span class="s3">(</span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">finalCallback </span><span class="s3">= </span><span class="s1">err </span><span class="s3">=&gt; {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">factorizeQueue</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">buildQueue</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">rebuildQueue</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">processDependenciesQueue</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">addModuleQueue</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
			<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
		<span class="s3">};</span>
		<span class="s4">const </span><span class="s1">chunkGraph </span><span class="s3">= </span><span class="s4">new </span><span class="s1">ChunkGraph</span><span class="s3">(</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">,</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">outputOptions</span><span class="s3">.</span><span class="s1">hashFunction</span>
		<span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph </span><span class="s3">= </span><span class="s1">chunkGraph</span><span class="s3">;</span>

		<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_backCompat</span><span class="s3">) {</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
				<span class="s1">ChunkGraph</span><span class="s3">.</span><span class="s1">setChunkGraphForModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">chunkGraph</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">seal</span><span class="s3">.</span><span class="s1">call</span><span class="s3">();</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;optimize dependencies&quot;</span><span class="s3">);</span>
		<span class="s4">while </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">optimizeDependencies</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">)) {</span>
			<span class="s0">/* empty */</span>
		<span class="s3">}</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">afterOptimizeDependencies</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;optimize dependencies&quot;</span><span class="s3">);</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;create chunks&quot;</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">beforeChunks</span><span class="s3">.</span><span class="s1">call</span><span class="s3">();</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">freeze</span><span class="s3">(</span><span class="s2">&quot;seal&quot;</span><span class="s3">);</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;Entrypoint, Module[]&gt;} */</span>
		<span class="s4">const </span><span class="s1">chunkGraphInit </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span><span class="s1">name</span><span class="s3">, { </span><span class="s1">dependencies</span><span class="s3">, </span><span class="s1">includeDependencies</span><span class="s3">, </span><span class="s1">options </span><span class="s3">}] </span><span class="s1">of </span><span class="s4">this</span>
			<span class="s3">.</span><span class="s1">entries</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">chunk </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">addChunk</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">) {</span>
				<span class="s1">chunk</span><span class="s3">.</span><span class="s1">filenameTemplate </span><span class="s3">= </span><span class="s1">options</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">;</span>
			<span class="s3">}</span>
			<span class="s4">const </span><span class="s1">entrypoint </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Entrypoint</span><span class="s3">(</span><span class="s1">options</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(!</span><span class="s1">options</span><span class="s3">.</span><span class="s1">dependOn </span><span class="s3">&amp;&amp; !</span><span class="s1">options</span><span class="s3">.</span><span class="s1">runtime</span><span class="s3">) {</span>
				<span class="s1">entrypoint</span><span class="s3">.</span><span class="s1">setRuntimeChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s1">entrypoint</span><span class="s3">.</span><span class="s1">setEntrypointChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">namedChunkGroups</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">entrypoint</span><span class="s3">);</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">entrypoints</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">entrypoint</span><span class="s3">);</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGroups</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">entrypoint</span><span class="s3">);</span>
			<span class="s1">connectChunkGroupAndChunk</span><span class="s3">(</span><span class="s1">entrypoint</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">);</span>

			<span class="s4">const </span><span class="s1">entryModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">dep of </span><span class="s3">[</span><span class="s1">...</span><span class="s4">this</span><span class="s3">.</span><span class="s1">globalEntry</span><span class="s3">.</span><span class="s1">dependencies</span><span class="s3">, </span><span class="s1">...dependencies</span><span class="s3">]) {</span>
				<span class="s1">entrypoint</span><span class="s3">.</span><span class="s1">addOrigin</span><span class="s3">(</span><span class="s4">null</span><span class="s3">, { </span><span class="s1">name </span><span class="s3">}, </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{any} */ </span><span class="s3">(</span><span class="s1">dep</span><span class="s3">).</span><span class="s1">request</span><span class="s3">);</span>

				<span class="s4">const </span><span class="s1">module </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getModule</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
					<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">connectChunkAndEntryModule</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">entrypoint</span><span class="s3">);</span>
					<span class="s1">entryModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
					<span class="s4">const </span><span class="s1">modulesList </span><span class="s3">= </span><span class="s1">chunkGraphInit</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">entrypoint</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">modulesList </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
						<span class="s1">chunkGraphInit</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">entrypoint</span><span class="s3">, [</span><span class="s1">module</span><span class="s3">]);</span>
					<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
						<span class="s1">modulesList</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
			<span class="s3">}</span>

			<span class="s4">this</span><span class="s3">.</span><span class="s1">assignDepths</span><span class="s3">(</span><span class="s1">entryModules</span><span class="s3">);</span>

			<span class="s4">const </span><span class="s1">mapAndSort </span><span class="s3">= </span><span class="s1">deps </span><span class="s3">=&gt;</span>
				<span class="s1">deps</span>
					<span class="s3">.</span><span class="s1">map</span><span class="s3">(</span><span class="s1">dep </span><span class="s3">=&gt; </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getModule</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">))</span>
					<span class="s3">.</span><span class="s1">filter</span><span class="s3">(</span><span class="s1">Boolean</span><span class="s3">)</span>
					<span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">compareModulesByIdentifier</span><span class="s3">);</span>
			<span class="s4">const </span><span class="s1">includedModules </span><span class="s3">= [</span>
				<span class="s1">...mapAndSort</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">globalEntry</span><span class="s3">.</span><span class="s1">includeDependencies</span><span class="s3">),</span>
				<span class="s1">...mapAndSort</span><span class="s3">(</span><span class="s1">includeDependencies</span><span class="s3">)</span>
			<span class="s3">];</span>

			<span class="s4">let </span><span class="s1">modulesList </span><span class="s3">= </span><span class="s1">chunkGraphInit</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">entrypoint</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">modulesList </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s1">chunkGraphInit</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">entrypoint</span><span class="s3">, (</span><span class="s1">modulesList </span><span class="s3">= []));</span>
			<span class="s3">}</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of includedModules</span><span class="s3">) {</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">assignDepth</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
				<span class="s1">modulesList</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s4">const </span><span class="s1">runtimeChunks </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s1">outer</span><span class="s3">: </span><span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span>
			<span class="s1">name</span><span class="s3">,</span>
			<span class="s3">{</span>
				<span class="s1">options</span><span class="s3">: { </span><span class="s1">dependOn</span><span class="s3">, </span><span class="s1">runtime </span><span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">] </span><span class="s1">of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">entries</span><span class="s3">) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">dependOn </span><span class="s3">&amp;&amp; </span><span class="s1">runtime</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">err </span><span class="s3">=</span>
					<span class="s4">new </span><span class="s1">WebpackError</span><span class="s3">(</span><span class="s2">`Entrypoint '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">' has 'dependOn' and 'runtime' specified. This is not valid. 
Entrypoints that depend on other entrypoints do not have their own runtime. 
They will use the runtime(s) from referenced entrypoints instead. 
Remove the 'runtime' option from the entrypoint.`</span><span class="s3">);</span>
				<span class="s4">const </span><span class="s1">entry </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">entrypoints</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
				<span class="s1">err</span><span class="s3">.</span><span class="s1">chunk </span><span class="s3">= </span><span class="s1">entry</span><span class="s3">.</span><span class="s1">getEntrypointChunk</span><span class="s3">();</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">dependOn</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">entry </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">entrypoints</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
				<span class="s4">const </span><span class="s1">referencedChunks </span><span class="s3">= </span><span class="s1">entry</span>
					<span class="s3">.</span><span class="s1">getEntrypointChunk</span><span class="s3">()</span>
					<span class="s3">.</span><span class="s1">getAllReferencedChunks</span><span class="s3">();</span>
				<span class="s4">const </span><span class="s1">dependOnEntries </span><span class="s3">= [];</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">dep of dependOn</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">dependency </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">entrypoints</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(!</span><span class="s1">dependency</span><span class="s3">) {</span>
						<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
							<span class="s2">`Entry </span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">} </span><span class="s2">depends on </span><span class="s1">$</span><span class="s3">{</span><span class="s1">dep</span><span class="s3">}</span><span class="s2">, but this entry was not found`</span>
						<span class="s3">);</span>
					<span class="s3">}</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">referencedChunks</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">dependency</span><span class="s3">.</span><span class="s1">getEntrypointChunk</span><span class="s3">())) {</span>
						<span class="s4">const </span><span class="s1">err </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WebpackError</span><span class="s3">(</span>
							<span class="s2">`Entrypoints '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">' and '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">dep</span><span class="s3">}</span><span class="s2">' use 'dependOn' to depend on each other in a circular way.`</span>
						<span class="s3">);</span>
						<span class="s4">const </span><span class="s1">entryChunk </span><span class="s3">= </span><span class="s1">entry</span><span class="s3">.</span><span class="s1">getEntrypointChunk</span><span class="s3">();</span>
						<span class="s1">err</span><span class="s3">.</span><span class="s1">chunk </span><span class="s3">= </span><span class="s1">entryChunk</span><span class="s3">;</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
						<span class="s1">entry</span><span class="s3">.</span><span class="s1">setRuntimeChunk</span><span class="s3">(</span><span class="s1">entryChunk</span><span class="s3">);</span>
						<span class="s4">continue </span><span class="s1">outer</span><span class="s3">;</span>
					<span class="s3">}</span>
					<span class="s1">dependOnEntries</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">dependency</span><span class="s3">);</span>
				<span class="s3">}</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">dependency of dependOnEntries</span><span class="s3">) {</span>
					<span class="s1">connectChunkGroupParentAndChild</span><span class="s3">(</span><span class="s1">dependency</span><span class="s3">, </span><span class="s1">entry</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">entry </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">entrypoints</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
				<span class="s4">let </span><span class="s1">chunk </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">namedChunks</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
					<span class="s4">if </span><span class="s3">(!</span><span class="s1">runtimeChunks</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">)) {</span>
						<span class="s4">const </span><span class="s1">err </span><span class="s3">=</span>
							<span class="s4">new </span><span class="s1">WebpackError</span><span class="s3">(</span><span class="s2">`Entrypoint '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">' has a 'runtime' option which points to another entrypoint named '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">runtime</span><span class="s3">}</span><span class="s2">'. 
It's not valid to use other entrypoints as runtime chunk. 
Did you mean to use 'dependOn: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">JSON</span><span class="s3">.</span><span class="s1">stringify</span><span class="s3">(</span>
								<span class="s1">runtime</span>
							<span class="s3">)}</span><span class="s2">' instead to allow using entrypoint '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">' within the runtime of entrypoint '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">runtime</span><span class="s3">}</span><span class="s2">'? For this '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">runtime</span><span class="s3">}</span><span class="s2">' must always be loaded when '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">' is used. 
Or do you want to use the entrypoints '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">' and '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">runtime</span><span class="s3">}</span><span class="s2">' independently on the same page with a shared runtime? In this case give them both the same value for the 'runtime' option. It must be a name not already used by an entrypoint.`</span><span class="s3">);</span>
						<span class="s4">const </span><span class="s1">entryChunk </span><span class="s3">= </span><span class="s1">entry</span><span class="s3">.</span><span class="s1">getEntrypointChunk</span><span class="s3">();</span>
						<span class="s1">err</span><span class="s3">.</span><span class="s1">chunk </span><span class="s3">= </span><span class="s1">entryChunk</span><span class="s3">;</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
						<span class="s1">entry</span><span class="s3">.</span><span class="s1">setRuntimeChunk</span><span class="s3">(</span><span class="s1">entryChunk</span><span class="s3">);</span>
						<span class="s4">continue</span><span class="s3">;</span>
					<span class="s3">}</span>
				<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
					<span class="s1">chunk </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">addChunk</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">);</span>
					<span class="s1">chunk</span><span class="s3">.</span><span class="s1">preventIntegration </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
					<span class="s1">runtimeChunks</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
				<span class="s3">}</span>
				<span class="s1">entry</span><span class="s3">.</span><span class="s1">unshiftChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
				<span class="s1">chunk</span><span class="s3">.</span><span class="s1">addGroup</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">);</span>
				<span class="s1">entry</span><span class="s3">.</span><span class="s1">setRuntimeChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s1">buildChunkGraph</span><span class="s3">(</span><span class="s4">this</span><span class="s3">, </span><span class="s1">chunkGraphInit</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">afterChunks</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;create chunks&quot;</span><span class="s3">);</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;optimize&quot;</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">optimize</span><span class="s3">.</span><span class="s1">call</span><span class="s3">();</span>

		<span class="s4">while </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">optimizeModules</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">)) {</span>
			<span class="s0">/* empty */</span>
		<span class="s3">}</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">afterOptimizeModules</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">);</span>

		<span class="s4">while </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">optimizeChunks</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGroups</span><span class="s3">)) {</span>
			<span class="s0">/* empty */</span>
		<span class="s3">}</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">afterOptimizeChunks</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGroups</span><span class="s3">);</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">optimizeTree</span><span class="s3">.</span><span class="s1">callAsync</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">, </span><span class="s1">err </span><span class="s3">=&gt; {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
				<span class="s4">return </span><span class="s1">finalCallback</span><span class="s3">(</span>
					<span class="s1">makeWebpackError</span><span class="s3">(</span><span class="s1">err</span><span class="s3">, </span><span class="s2">&quot;Compilation.hooks.optimizeTree&quot;</span><span class="s3">)</span>
				<span class="s3">);</span>
			<span class="s3">}</span>

			<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">afterOptimizeTree</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">);</span>

			<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">optimizeChunkModules</span><span class="s3">.</span><span class="s1">callAsync</span><span class="s3">(</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">,</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">,</span>
				<span class="s1">err </span><span class="s3">=&gt; {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
						<span class="s4">return </span><span class="s1">finalCallback</span><span class="s3">(</span>
							<span class="s1">makeWebpackError</span><span class="s3">(</span><span class="s1">err</span><span class="s3">, </span><span class="s2">&quot;Compilation.hooks.optimizeChunkModules&quot;</span><span class="s3">)</span>
						<span class="s3">);</span>
					<span class="s3">}</span>

					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">afterOptimizeChunkModules</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">);</span>

					<span class="s4">const </span><span class="s1">shouldRecord </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">shouldRecord</span><span class="s3">.</span><span class="s1">call</span><span class="s3">() !== </span><span class="s4">false</span><span class="s3">;</span>

					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">reviveModules</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">records</span><span class="s3">);</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">beforeModuleIds</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">);</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">moduleIds</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">);</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">optimizeModuleIds</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">);</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">afterOptimizeModuleIds</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">);</span>

					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">reviveChunks</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">records</span><span class="s3">);</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">beforeChunkIds</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">);</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">chunkIds</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">);</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">optimizeChunkIds</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">);</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">afterOptimizeChunkIds</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">);</span>

					<span class="s4">this</span><span class="s3">.</span><span class="s1">assignRuntimeIds</span><span class="s3">();</span>

					<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;compute affected modules with chunk graph&quot;</span><span class="s3">);</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">_computeAffectedModulesWithChunkGraph</span><span class="s3">();</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;compute affected modules with chunk graph&quot;</span><span class="s3">);</span>

					<span class="s4">this</span><span class="s3">.</span><span class="s1">sortItemsWithChunkIds</span><span class="s3">();</span>

					<span class="s4">if </span><span class="s3">(</span><span class="s1">shouldRecord</span><span class="s3">) {</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">recordModules</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">records</span><span class="s3">);</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">recordChunks</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">records</span><span class="s3">);</span>
					<span class="s3">}</span>

					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">optimizeCodeGeneration</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">);</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;optimize&quot;</span><span class="s3">);</span>

					<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;module hashing&quot;</span><span class="s3">);</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">beforeModuleHash</span><span class="s3">.</span><span class="s1">call</span><span class="s3">();</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">createModuleHashes</span><span class="s3">();</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">afterModuleHash</span><span class="s3">.</span><span class="s1">call</span><span class="s3">();</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;module hashing&quot;</span><span class="s3">);</span>

					<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;code generation&quot;</span><span class="s3">);</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">beforeCodeGeneration</span><span class="s3">.</span><span class="s1">call</span><span class="s3">();</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">codeGeneration</span><span class="s3">(</span><span class="s1">err </span><span class="s3">=&gt; {</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
							<span class="s4">return </span><span class="s1">finalCallback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
						<span class="s3">}</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">afterCodeGeneration</span><span class="s3">.</span><span class="s1">call</span><span class="s3">();</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;code generation&quot;</span><span class="s3">);</span>

						<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;runtime requirements&quot;</span><span class="s3">);</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">beforeRuntimeRequirements</span><span class="s3">.</span><span class="s1">call</span><span class="s3">();</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">processRuntimeRequirements</span><span class="s3">();</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">afterRuntimeRequirements</span><span class="s3">.</span><span class="s1">call</span><span class="s3">();</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;runtime requirements&quot;</span><span class="s3">);</span>

						<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;hashing&quot;</span><span class="s3">);</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">beforeHash</span><span class="s3">.</span><span class="s1">call</span><span class="s3">();</span>
						<span class="s4">const </span><span class="s1">codeGenerationJobs </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">createHash</span><span class="s3">();</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">afterHash</span><span class="s3">.</span><span class="s1">call</span><span class="s3">();</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;hashing&quot;</span><span class="s3">);</span>

						<span class="s4">this</span><span class="s3">.</span><span class="s1">_runCodeGenerationJobs</span><span class="s3">(</span><span class="s1">codeGenerationJobs</span><span class="s3">, </span><span class="s1">err </span><span class="s3">=&gt; {</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
								<span class="s4">return </span><span class="s1">finalCallback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
							<span class="s3">}</span>

							<span class="s4">if </span><span class="s3">(</span><span class="s1">shouldRecord</span><span class="s3">) {</span>
								<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;record hash&quot;</span><span class="s3">);</span>
								<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">recordHash</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">records</span><span class="s3">);</span>
								<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;record hash&quot;</span><span class="s3">);</span>
							<span class="s3">}</span>

							<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;module assets&quot;</span><span class="s3">);</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">clearAssets</span><span class="s3">();</span>

							<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">beforeModuleAssets</span><span class="s3">.</span><span class="s1">call</span><span class="s3">();</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">createModuleAssets</span><span class="s3">();</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;module assets&quot;</span><span class="s3">);</span>

							<span class="s4">const </span><span class="s1">cont </span><span class="s3">= () =&gt; {</span>
								<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;process assets&quot;</span><span class="s3">);</span>
								<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">processAssets</span><span class="s3">.</span><span class="s1">callAsync</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">, </span><span class="s1">err </span><span class="s3">=&gt; {</span>
									<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
										<span class="s4">return </span><span class="s1">finalCallback</span><span class="s3">(</span>
											<span class="s1">makeWebpackError</span><span class="s3">(</span><span class="s1">err</span><span class="s3">, </span><span class="s2">&quot;Compilation.hooks.processAssets&quot;</span><span class="s3">)</span>
										<span class="s3">);</span>
									<span class="s3">}</span>
									<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">afterProcessAssets</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">);</span>
									<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;process assets&quot;</span><span class="s3">);</span>
									<span class="s4">this</span><span class="s3">.</span><span class="s1">assets </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_backCompat</span>
										<span class="s3">? </span><span class="s1">soonFrozenObjectDeprecation</span><span class="s3">(</span>
												<span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">,</span>
												<span class="s2">&quot;Compilation.assets&quot;</span><span class="s3">,</span>
												<span class="s2">&quot;DEP_WEBPACK_COMPILATION_ASSETS&quot;</span><span class="s3">,</span>
												<span class="s2">`BREAKING CHANGE: No more changes should happen to Compilation.assets after sealing the Compilation. 
    Do changes to assets earlier, e. g. in Compilation.hooks.processAssets. 
    Make sure to select an appropriate stage from Compilation.PROCESS_ASSETS_STAGE_*.`</span>
										  <span class="s3">)</span>
										<span class="s3">: </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">freeze</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">);</span>

									<span class="s4">this</span><span class="s3">.</span><span class="s1">summarizeDependencies</span><span class="s3">();</span>
									<span class="s4">if </span><span class="s3">(</span><span class="s1">shouldRecord</span><span class="s3">) {</span>
										<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">record</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">records</span><span class="s3">);</span>
									<span class="s3">}</span>

									<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">needAdditionalSeal</span><span class="s3">.</span><span class="s1">call</span><span class="s3">()) {</span>
										<span class="s4">this</span><span class="s3">.</span><span class="s1">unseal</span><span class="s3">();</span>
										<span class="s4">return this</span><span class="s3">.</span><span class="s1">seal</span><span class="s3">(</span><span class="s1">callback</span><span class="s3">);</span>
									<span class="s3">}</span>
									<span class="s4">return this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">afterSeal</span><span class="s3">.</span><span class="s1">callAsync</span><span class="s3">(</span><span class="s1">err </span><span class="s3">=&gt; {</span>
										<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
											<span class="s4">return </span><span class="s1">finalCallback</span><span class="s3">(</span>
												<span class="s1">makeWebpackError</span><span class="s3">(</span><span class="s1">err</span><span class="s3">, </span><span class="s2">&quot;Compilation.hooks.afterSeal&quot;</span><span class="s3">)</span>
											<span class="s3">);</span>
										<span class="s3">}</span>
										<span class="s4">this</span><span class="s3">.</span><span class="s1">fileSystemInfo</span><span class="s3">.</span><span class="s1">logStatistics</span><span class="s3">();</span>
										<span class="s1">finalCallback</span><span class="s3">();</span>
									<span class="s3">});</span>
								<span class="s3">});</span>
							<span class="s3">};</span>

							<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;create chunk assets&quot;</span><span class="s3">);</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">shouldGenerateChunkAssets</span><span class="s3">.</span><span class="s1">call</span><span class="s3">() !== </span><span class="s4">false</span><span class="s3">) {</span>
								<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">beforeChunkAssets</span><span class="s3">.</span><span class="s1">call</span><span class="s3">();</span>
								<span class="s4">this</span><span class="s3">.</span><span class="s1">createChunkAssets</span><span class="s3">(</span><span class="s1">err </span><span class="s3">=&gt; {</span>
									<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;create chunk assets&quot;</span><span class="s3">);</span>
									<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
										<span class="s4">return </span><span class="s1">finalCallback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
									<span class="s3">}</span>
									<span class="s1">cont</span><span class="s3">();</span>
								<span class="s3">});</span>
							<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
								<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;create chunk assets&quot;</span><span class="s3">);</span>
								<span class="s1">cont</span><span class="s3">();</span>
							<span class="s3">}</span>
						<span class="s3">});</span>
					<span class="s3">});</span>
				<span class="s3">}</span>
			<span class="s3">);</span>
		<span class="s3">});</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module module to report from</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{DependenciesBlock[]} blocks blocks to report from</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true, when it has warnings or errors</span>
	 <span class="s5">*/</span>
	<span class="s1">reportDependencyErrorsAndWarnings</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">blocks</span><span class="s3">) {</span>
		<span class="s4">let </span><span class="s1">hasProblems </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">let </span><span class="s1">indexBlock </span><span class="s3">= </span><span class="s7">0</span><span class="s3">; </span><span class="s1">indexBlock </span><span class="s3">&lt; </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">indexBlock</span><span class="s3">++) {</span>
			<span class="s4">const </span><span class="s1">block </span><span class="s3">= </span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">indexBlock</span><span class="s3">];</span>
			<span class="s4">const </span><span class="s1">dependencies </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">dependencies</span><span class="s3">;</span>

			<span class="s4">for </span><span class="s3">(</span><span class="s4">let </span><span class="s1">indexDep </span><span class="s3">= </span><span class="s7">0</span><span class="s3">; </span><span class="s1">indexDep </span><span class="s3">&lt; </span><span class="s1">dependencies</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">indexDep</span><span class="s3">++) {</span>
				<span class="s4">const </span><span class="s1">d </span><span class="s3">= </span><span class="s1">dependencies</span><span class="s3">[</span><span class="s1">indexDep</span><span class="s3">];</span>

				<span class="s4">const </span><span class="s1">warnings </span><span class="s3">= </span><span class="s1">d</span><span class="s3">.</span><span class="s1">getWarnings</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">warnings</span><span class="s3">) {</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">let </span><span class="s1">indexWar </span><span class="s3">= </span><span class="s7">0</span><span class="s3">; </span><span class="s1">indexWar </span><span class="s3">&lt; </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">indexWar</span><span class="s3">++) {</span>
						<span class="s4">const </span><span class="s1">w </span><span class="s3">= </span><span class="s1">warnings</span><span class="s3">[</span><span class="s1">indexWar</span><span class="s3">];</span>

						<span class="s4">const </span><span class="s1">warning </span><span class="s3">= </span><span class="s4">new </span><span class="s1">ModuleDependencyWarning</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">d</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">);</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">warning</span><span class="s3">);</span>
						<span class="s1">hasProblems </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
				<span class="s4">const </span><span class="s1">errors </span><span class="s3">= </span><span class="s1">d</span><span class="s3">.</span><span class="s1">getErrors</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">errors</span><span class="s3">) {</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">let </span><span class="s1">indexErr </span><span class="s3">= </span><span class="s7">0</span><span class="s3">; </span><span class="s1">indexErr </span><span class="s3">&lt; </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">indexErr</span><span class="s3">++) {</span>
						<span class="s4">const </span><span class="s1">e </span><span class="s3">= </span><span class="s1">errors</span><span class="s3">[</span><span class="s1">indexErr</span><span class="s3">];</span>

						<span class="s4">const </span><span class="s1">error </span><span class="s3">= </span><span class="s4">new </span><span class="s1">ModuleDependencyError</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">d</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">);</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">error</span><span class="s3">);</span>
						<span class="s1">hasProblems </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
			<span class="s3">}</span>

			<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">reportDependencyErrorsAndWarnings</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">block</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">))</span>
				<span class="s1">hasProblems </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
		<span class="s3">}</span>
		<span class="s4">return </span><span class="s1">hasProblems</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s1">codeGeneration</span><span class="s3">(</span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s3">{ </span><span class="s1">chunkGraph </span><span class="s3">} = </span><span class="s4">this</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">codeGenerationResults </span><span class="s3">= </span><span class="s4">new </span><span class="s1">CodeGenerationResults</span><span class="s3">(</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">outputOptions</span><span class="s3">.</span><span class="s1">hashFunction</span>
		<span class="s3">);</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */</span>
		<span class="s4">const </span><span class="s1">jobs </span><span class="s3">= [];</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">runtimes </span><span class="s3">= </span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getModuleRuntimes</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">runtimes</span><span class="s3">.</span><span class="s1">size </span><span class="s3">=== </span><span class="s7">1</span><span class="s3">) {</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">runtime of runtimes</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">hash </span><span class="s3">= </span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getModuleHash</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">);</span>
					<span class="s1">jobs</span><span class="s3">.</span><span class="s1">push</span><span class="s3">({ </span><span class="s1">module</span><span class="s3">, </span><span class="s1">hash</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">, </span><span class="s1">runtimes</span><span class="s3">: [</span><span class="s1">runtime</span><span class="s3">] });</span>
				<span class="s3">}</span>
			<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">runtimes</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s7">1</span><span class="s3">) {</span>
				<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, { runtimes: RuntimeSpec[] }&gt;} */</span>
				<span class="s4">const </span><span class="s1">map </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">runtime of runtimes</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">hash </span><span class="s3">= </span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getModuleHash</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">);</span>
					<span class="s4">const </span><span class="s1">job </span><span class="s3">= </span><span class="s1">map</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">hash</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">job </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
						<span class="s4">const </span><span class="s1">newJob </span><span class="s3">= { </span><span class="s1">module</span><span class="s3">, </span><span class="s1">hash</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">, </span><span class="s1">runtimes</span><span class="s3">: [</span><span class="s1">runtime</span><span class="s3">] };</span>
						<span class="s1">jobs</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">newJob</span><span class="s3">);</span>
						<span class="s1">map</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">hash</span><span class="s3">, </span><span class="s1">newJob</span><span class="s3">);</span>
					<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
						<span class="s1">job</span><span class="s3">.</span><span class="s1">runtimes</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">_runCodeGenerationJobs</span><span class="s3">(</span><span class="s1">jobs</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s1">_runCodeGenerationJobs</span><span class="s3">(</span><span class="s1">jobs</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">jobs</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) {</span>
			<span class="s4">return </span><span class="s1">callback</span><span class="s3">();</span>
		<span class="s3">}</span>
		<span class="s4">let </span><span class="s1">statModulesFromCache </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s4">let </span><span class="s1">statModulesGenerated </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s3">{ </span><span class="s1">chunkGraph</span><span class="s3">, </span><span class="s1">moduleGraph</span><span class="s3">, </span><span class="s1">dependencyTemplates</span><span class="s3">, </span><span class="s1">runtimeTemplate </span><span class="s3">} =</span>
			<span class="s4">this</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">results </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">codeGenerationResults</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WebpackError[]} */</span>
		<span class="s4">const </span><span class="s1">errors </span><span class="s3">= [];</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;Module&gt; | undefined} */</span>
		<span class="s4">let </span><span class="s1">notCodeGeneratedModules </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">runIteration </span><span class="s3">= () =&gt; {</span>
			<span class="s4">let </span><span class="s1">delayedJobs </span><span class="s3">= [];</span>
			<span class="s4">let </span><span class="s1">delayedModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
			<span class="s1">asyncLib</span><span class="s3">.</span><span class="s1">eachLimit</span><span class="s3">(</span>
				<span class="s1">jobs</span><span class="s3">,</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">parallelism</span><span class="s3">,</span>
				<span class="s3">(</span><span class="s1">job</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) =&gt; {</span>
					<span class="s4">const </span><span class="s3">{ </span><span class="s1">module </span><span class="s3">} = </span><span class="s1">job</span><span class="s3">;</span>
					<span class="s4">const </span><span class="s3">{ </span><span class="s1">codeGenerationDependencies </span><span class="s3">} = </span><span class="s1">module</span><span class="s3">;</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">codeGenerationDependencies </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
						<span class="s4">if </span><span class="s3">(</span>
							<span class="s1">notCodeGeneratedModules </span><span class="s3">=== </span><span class="s1">undefined </span><span class="s3">||</span>
							<span class="s1">codeGenerationDependencies</span><span class="s3">.</span><span class="s1">some</span><span class="s3">(</span><span class="s1">dep </span><span class="s3">=&gt; {</span>
								<span class="s4">const </span><span class="s1">referencedModule </span><span class="s3">= </span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getModule</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">);</span>
								<span class="s4">return </span><span class="s1">notCodeGeneratedModules</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">referencedModule</span><span class="s3">);</span>
							<span class="s3">})</span>
						<span class="s3">) {</span>
							<span class="s1">delayedJobs</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">job</span><span class="s3">);</span>
							<span class="s1">delayedModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
							<span class="s4">return </span><span class="s1">callback</span><span class="s3">();</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
					<span class="s4">const </span><span class="s3">{ </span><span class="s1">hash</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">, </span><span class="s1">runtimes </span><span class="s3">} = </span><span class="s1">job</span><span class="s3">;</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">_codeGenerationModule</span><span class="s3">(</span>
						<span class="s1">module</span><span class="s3">,</span>
						<span class="s1">runtime</span><span class="s3">,</span>
						<span class="s1">runtimes</span><span class="s3">,</span>
						<span class="s1">hash</span><span class="s3">,</span>
						<span class="s1">dependencyTemplates</span><span class="s3">,</span>
						<span class="s1">chunkGraph</span><span class="s3">,</span>
						<span class="s1">moduleGraph</span><span class="s3">,</span>
						<span class="s1">runtimeTemplate</span><span class="s3">,</span>
						<span class="s1">errors</span><span class="s3">,</span>
						<span class="s1">results</span><span class="s3">,</span>
						<span class="s3">(</span><span class="s1">err</span><span class="s3">, </span><span class="s1">codeGenerated</span><span class="s3">) =&gt; {</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">codeGenerated</span><span class="s3">) </span><span class="s1">statModulesGenerated</span><span class="s3">++;</span>
							<span class="s4">else </span><span class="s1">statModulesFromCache</span><span class="s3">++;</span>
							<span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">);</span>
				<span class="s3">},</span>
				<span class="s1">err </span><span class="s3">=&gt; {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) </span><span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">delayedJobs</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">delayedJobs</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s1">jobs</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) {</span>
							<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span>
								<span class="s4">new </span><span class="s1">Error</span><span class="s3">(</span>
									<span class="s2">`Unable to make progress during code generation because of circular code generation dependency: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span>
										<span class="s1">delayedModules</span><span class="s3">,</span>
										<span class="s1">m </span><span class="s3">=&gt; </span><span class="s1">m</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">()</span>
									<span class="s3">).</span><span class="s1">join</span><span class="s3">(</span><span class="s2">&quot;, &quot;</span><span class="s3">)}</span><span class="s2">`</span>
								<span class="s3">)</span>
							<span class="s3">);</span>
						<span class="s3">}</span>
						<span class="s1">jobs </span><span class="s3">= </span><span class="s1">delayedJobs</span><span class="s3">;</span>
						<span class="s1">delayedJobs </span><span class="s3">= [];</span>
						<span class="s1">notCodeGeneratedModules </span><span class="s3">= </span><span class="s1">delayedModules</span><span class="s3">;</span>
						<span class="s1">delayedModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
						<span class="s4">return </span><span class="s1">runIteration</span><span class="s3">();</span>
					<span class="s3">}</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
						<span class="s1">errors</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span>
							<span class="s1">compareSelect</span><span class="s3">(</span><span class="s1">err </span><span class="s3">=&gt; </span><span class="s1">err</span><span class="s3">.</span><span class="s1">module</span><span class="s3">, </span><span class="s1">compareModulesByIdentifier</span><span class="s3">)</span>
						<span class="s3">);</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">error of errors</span><span class="s3">) {</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">error</span><span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span>
						<span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span>
							<span class="s3">(</span><span class="s7">100 </span><span class="s3">* </span><span class="s1">statModulesGenerated</span><span class="s3">) /</span>
								<span class="s3">(</span><span class="s1">statModulesGenerated </span><span class="s3">+ </span><span class="s1">statModulesFromCache</span><span class="s3">)</span>
						<span class="s3">)}</span><span class="s2">% code generated (</span><span class="s1">$</span><span class="s3">{</span><span class="s1">statModulesGenerated</span><span class="s3">} </span><span class="s2">generated, </span><span class="s1">$</span><span class="s3">{</span><span class="s1">statModulesFromCache</span><span class="s3">} </span><span class="s2">from cache)`</span>
					<span class="s3">);</span>
					<span class="s1">callback</span><span class="s3">();</span>
				<span class="s3">}</span>
			<span class="s3">);</span>
		<span class="s3">};</span>
		<span class="s1">runIteration</span><span class="s3">();</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime runtime</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec[]} runtimes runtimes</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} hash hash</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{DependencyTemplates} dependencyTemplates dependencyTemplates</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunkGraph} chunkGraph chunkGraph</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleGraph} moduleGraph moduleGraph</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeTemplate} runtimeTemplate runtimeTemplate</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{WebpackError[]} errors errors</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{CodeGenerationResults} results results</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{function((WebpackError | null)=, boolean=): void} callback callback</span>
	 <span class="s5">*/</span>
	<span class="s1">_codeGenerationModule</span><span class="s3">(</span>
		<span class="s1">module</span><span class="s3">,</span>
		<span class="s1">runtime</span><span class="s3">,</span>
		<span class="s1">runtimes</span><span class="s3">,</span>
		<span class="s1">hash</span><span class="s3">,</span>
		<span class="s1">dependencyTemplates</span><span class="s3">,</span>
		<span class="s1">chunkGraph</span><span class="s3">,</span>
		<span class="s1">moduleGraph</span><span class="s3">,</span>
		<span class="s1">runtimeTemplate</span><span class="s3">,</span>
		<span class="s1">errors</span><span class="s3">,</span>
		<span class="s1">results</span><span class="s3">,</span>
		<span class="s1">callback</span>
	<span class="s3">) {</span>
		<span class="s4">let </span><span class="s1">codeGenerated </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">cache </span><span class="s3">= </span><span class="s4">new </span><span class="s1">MultiItemCache</span><span class="s3">(</span>
			<span class="s1">runtimes</span><span class="s3">.</span><span class="s1">map</span><span class="s3">(</span><span class="s1">runtime </span><span class="s3">=&gt;</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">_codeGenerationCache</span><span class="s3">.</span><span class="s1">getItemCache</span><span class="s3">(</span>
					<span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">()}</span><span class="s2">|</span><span class="s1">$</span><span class="s3">{</span><span class="s1">getRuntimeKey</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">)}</span><span class="s2">`</span><span class="s3">,</span>
					<span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">hash</span><span class="s3">}</span><span class="s2">|</span><span class="s1">$</span><span class="s3">{</span><span class="s1">dependencyTemplates</span><span class="s3">.</span><span class="s1">getHash</span><span class="s3">()}</span><span class="s2">`</span>
				<span class="s3">)</span>
			<span class="s3">)</span>
		<span class="s3">);</span>
		<span class="s1">cache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">((</span><span class="s1">err</span><span class="s3">, </span><span class="s1">cachedResult</span><span class="s3">) =&gt; {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) </span><span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
			<span class="s4">let </span><span class="s1">result</span><span class="s3">;</span>
			<span class="s4">if </span><span class="s3">(!</span><span class="s1">cachedResult</span><span class="s3">) {</span>
				<span class="s4">try </span><span class="s3">{</span>
					<span class="s1">codeGenerated </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">codeGeneratedModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
					<span class="s1">result </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">codeGeneration</span><span class="s3">({</span>
						<span class="s1">chunkGraph</span><span class="s3">,</span>
						<span class="s1">moduleGraph</span><span class="s3">,</span>
						<span class="s1">dependencyTemplates</span><span class="s3">,</span>
						<span class="s1">runtimeTemplate</span><span class="s3">,</span>
						<span class="s1">runtime</span><span class="s3">,</span>
						<span class="s1">codeGenerationResults</span><span class="s3">: </span><span class="s1">results</span><span class="s3">,</span>
						<span class="s1">compilation</span><span class="s3">: </span><span class="s4">this</span>
					<span class="s3">});</span>
				<span class="s3">} </span><span class="s4">catch </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
					<span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s4">new </span><span class="s1">CodeGenerationError</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">err</span><span class="s3">));</span>
					<span class="s1">result </span><span class="s3">= </span><span class="s1">cachedResult </span><span class="s3">= {</span>
						<span class="s1">sources</span><span class="s3">: </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">(),</span>
						<span class="s1">runtimeRequirements</span><span class="s3">: </span><span class="s4">null</span>
					<span class="s3">};</span>
				<span class="s3">}</span>
			<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
				<span class="s1">result </span><span class="s3">= </span><span class="s1">cachedResult</span><span class="s3">;</span>
			<span class="s3">}</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">runtime of runtimes</span><span class="s3">) {</span>
				<span class="s1">results</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">, </span><span class="s1">result</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(!</span><span class="s1">cachedResult</span><span class="s3">) {</span>
				<span class="s1">cache</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">err </span><span class="s3">=&gt; </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">, </span><span class="s1">codeGenerated</span><span class="s3">));</span>
			<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
				<span class="s1">callback</span><span class="s3">(</span><span class="s4">null</span><span class="s3">, </span><span class="s1">codeGenerated</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">});</span>
	<span class="s3">}</span>

	<span class="s1">_getChunkGraphEntries</span><span class="s3">() {</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;Chunk&gt;} */</span>
		<span class="s4">const </span><span class="s1">treeEntries </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">ep of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">entrypoints</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()) {</span>
			<span class="s4">const </span><span class="s1">chunk </span><span class="s3">= </span><span class="s1">ep</span><span class="s3">.</span><span class="s1">getRuntimeChunk</span><span class="s3">();</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) </span><span class="s1">treeEntries</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">ep of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">asyncEntrypoints</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">chunk </span><span class="s3">= </span><span class="s1">ep</span><span class="s3">.</span><span class="s1">getRuntimeChunk</span><span class="s3">();</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) </span><span class="s1">treeEntries</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">return </span><span class="s1">treeEntries</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Object} options options</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunkGraph=} options.chunkGraph the chunk graph</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Iterable&lt;Module&gt;=} options.modules modules</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Iterable&lt;Chunk&gt;=} options.chunks chunks</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{CodeGenerationResults=} options.codeGenerationResults codeGenerationResults</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Iterable&lt;Chunk&gt;=} options.chunkGraphEntries chunkGraphEntries</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">processRuntimeRequirements</span><span class="s3">({</span>
		<span class="s1">chunkGraph </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph</span><span class="s3">,</span>
		<span class="s1">modules </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">,</span>
		<span class="s1">chunks </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">,</span>
		<span class="s1">codeGenerationResults </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">codeGenerationResults</span><span class="s3">,</span>
		<span class="s1">chunkGraphEntries </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphEntries</span><span class="s3">()</span>
	<span class="s3">} = {}) {</span>
		<span class="s4">const </span><span class="s1">context </span><span class="s3">= { </span><span class="s1">chunkGraph</span><span class="s3">, </span><span class="s1">codeGenerationResults </span><span class="s3">};</span>
		<span class="s4">const </span><span class="s3">{ </span><span class="s1">moduleMemCaches2 </span><span class="s3">} = </span><span class="s4">this</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;runtime requirements.modules&quot;</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">additionalModuleRuntimeRequirements </span><span class="s3">=</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">additionalModuleRuntimeRequirements</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">runtimeRequirementInModule </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">runtimeRequirementInModule</span><span class="s3">;</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of modules</span><span class="s3">) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getNumberOfModuleChunks</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) &gt; </span><span class="s7">0</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">memCache </span><span class="s3">= </span><span class="s1">moduleMemCaches2 </span><span class="s3">&amp;&amp; </span><span class="s1">moduleMemCaches2</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">runtime of chunkGraph</span><span class="s3">.</span><span class="s1">getModuleRuntimes</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">memCache</span><span class="s3">) {</span>
						<span class="s4">const </span><span class="s1">cached </span><span class="s3">= </span><span class="s1">memCache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span>
							<span class="s2">`moduleRuntimeRequirements-</span><span class="s1">$</span><span class="s3">{</span><span class="s1">getRuntimeKey</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">)}</span><span class="s2">`</span>
						<span class="s3">);</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">cached </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">cached </span><span class="s3">!== </span><span class="s4">null</span><span class="s3">) {</span>
								<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">addModuleRuntimeRequirements</span><span class="s3">(</span>
									<span class="s1">module</span><span class="s3">,</span>
									<span class="s1">runtime</span><span class="s3">,</span>
									<span class="s1">cached</span><span class="s3">,</span>
									<span class="s4">false</span>
								<span class="s3">);</span>
							<span class="s3">}</span>
							<span class="s4">continue</span><span class="s3">;</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
					<span class="s4">let </span><span class="s1">set</span><span class="s3">;</span>
					<span class="s4">const </span><span class="s1">runtimeRequirements </span><span class="s3">=</span>
						<span class="s1">codeGenerationResults</span><span class="s3">.</span><span class="s1">getRuntimeRequirements</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">runtimeRequirements </span><span class="s3">&amp;&amp; </span><span class="s1">runtimeRequirements</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
						<span class="s1">set </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">runtimeRequirements</span><span class="s3">);</span>
					<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">additionalModuleRuntimeRequirements</span><span class="s3">.</span><span class="s1">isUsed</span><span class="s3">()) {</span>
						<span class="s1">set </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
					<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">memCache</span><span class="s3">) {</span>
							<span class="s1">memCache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span>
								<span class="s2">`moduleRuntimeRequirements-</span><span class="s1">$</span><span class="s3">{</span><span class="s1">getRuntimeKey</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">)}</span><span class="s2">`</span><span class="s3">,</span>
								<span class="s4">null</span>
							<span class="s3">);</span>
						<span class="s3">}</span>
						<span class="s4">continue</span><span class="s3">;</span>
					<span class="s3">}</span>
					<span class="s1">additionalModuleRuntimeRequirements</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">set</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>

					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">r of set</span><span class="s3">) {</span>
						<span class="s4">const </span><span class="s1">hook </span><span class="s3">= </span><span class="s1">runtimeRequirementInModule</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">r</span><span class="s3">);</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">hook </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s1">hook</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">set</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
					<span class="s3">}</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">set</span><span class="s3">.</span><span class="s1">size </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) {</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">memCache</span><span class="s3">) {</span>
							<span class="s1">memCache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span>
								<span class="s2">`moduleRuntimeRequirements-</span><span class="s1">$</span><span class="s3">{</span><span class="s1">getRuntimeKey</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">)}</span><span class="s2">`</span><span class="s3">,</span>
								<span class="s4">null</span>
							<span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">memCache</span><span class="s3">) {</span>
							<span class="s1">memCache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span>
								<span class="s2">`moduleRuntimeRequirements-</span><span class="s1">$</span><span class="s3">{</span><span class="s1">getRuntimeKey</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">)}</span><span class="s2">`</span><span class="s3">,</span>
								<span class="s1">set</span>
							<span class="s3">);</span>
							<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">addModuleRuntimeRequirements</span><span class="s3">(</span>
								<span class="s1">module</span><span class="s3">,</span>
								<span class="s1">runtime</span><span class="s3">,</span>
								<span class="s1">set</span><span class="s3">,</span>
								<span class="s4">false</span>
							<span class="s3">);</span>
						<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
							<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">addModuleRuntimeRequirements</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">, </span><span class="s1">set</span><span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;runtime requirements.modules&quot;</span><span class="s3">);</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;runtime requirements.chunks&quot;</span><span class="s3">);</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of chunks</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">set </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of chunkGraph</span><span class="s3">.</span><span class="s1">getChunkModulesIterable</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">)) {</span>
				<span class="s4">const </span><span class="s1">runtimeRequirements </span><span class="s3">= </span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getModuleRuntimeRequirements</span><span class="s3">(</span>
					<span class="s1">module</span><span class="s3">,</span>
					<span class="s1">chunk</span><span class="s3">.</span><span class="s1">runtime</span>
				<span class="s3">);</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">r of runtimeRequirements</span><span class="s3">) </span><span class="s1">set</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">r</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">additionalChunkRuntimeRequirements</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">set</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>

			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">r of set</span><span class="s3">) {</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">runtimeRequirementInChunk</span><span class="s3">.</span><span class="s1">for</span><span class="s3">(</span><span class="s1">r</span><span class="s3">).</span><span class="s1">call</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">set</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
			<span class="s3">}</span>

			<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">addChunkRuntimeRequirements</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">set</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;runtime requirements.chunks&quot;</span><span class="s3">);</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;runtime requirements.entries&quot;</span><span class="s3">);</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">treeEntry of chunkGraphEntries</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">set </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of treeEntry</span><span class="s3">.</span><span class="s1">getAllReferencedChunks</span><span class="s3">()) {</span>
				<span class="s4">const </span><span class="s1">runtimeRequirements </span><span class="s3">=</span>
					<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getChunkRuntimeRequirements</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">r of runtimeRequirements</span><span class="s3">) </span><span class="s1">set</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">r</span><span class="s3">);</span>
			<span class="s3">}</span>

			<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">additionalTreeRuntimeRequirements</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span>
				<span class="s1">treeEntry</span><span class="s3">,</span>
				<span class="s1">set</span><span class="s3">,</span>
				<span class="s1">context</span>
			<span class="s3">);</span>

			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">r of set</span><span class="s3">) {</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">runtimeRequirementInTree</span>
					<span class="s3">.</span><span class="s1">for</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>
					<span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">treeEntry</span><span class="s3">, </span><span class="s1">set</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
			<span class="s3">}</span>

			<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">addTreeRuntimeRequirements</span><span class="s3">(</span><span class="s1">treeEntry</span><span class="s3">, </span><span class="s1">set</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;runtime requirements.entries&quot;</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s0">// TODO webpack 6 make chunkGraph argument non-optional</span>
	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk target chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeModule} module runtime module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunkGraph} chunkGraph the chunk graph</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">addRuntimeModule</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">chunkGraph </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph</span><span class="s3">) {</span>
		<span class="s0">// Deprecated ModuleGraph association</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_backCompat</span><span class="s3">)</span>
			<span class="s1">ModuleGraph</span><span class="s3">.</span><span class="s1">setModuleGraphForModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">);</span>

		<span class="s0">// add it to the list</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_modules</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">(), </span><span class="s1">module</span><span class="s3">);</span>

		<span class="s0">// connect to the chunk graph</span>
		<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">connectChunkAndModule</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
		<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">connectChunkAndRuntimeModule</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">fullHash</span><span class="s3">) {</span>
			<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">addFullHashModuleToChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
		<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">dependentHash</span><span class="s3">) {</span>
			<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">addDependentHashModuleToChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
		<span class="s3">}</span>

		<span class="s0">// attach runtime module</span>
		<span class="s1">module</span><span class="s3">.</span><span class="s1">attach</span><span class="s3">(</span><span class="s4">this</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">chunkGraph</span><span class="s3">);</span>

		<span class="s0">// Setup internals</span>
		<span class="s4">const </span><span class="s1">exportsInfo </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getExportsInfo</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s1">exportsInfo</span><span class="s3">.</span><span class="s1">setHasProvideInfo</span><span class="s3">();</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">runtime </span><span class="s3">=== </span><span class="s2">&quot;string&quot;</span><span class="s3">) {</span>
			<span class="s1">exportsInfo</span><span class="s3">.</span><span class="s1">setUsedForSideEffectsOnly</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">runtime</span><span class="s3">);</span>
		<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">runtime </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s1">exportsInfo</span><span class="s3">.</span><span class="s1">setUsedForSideEffectsOnly</span><span class="s3">(</span><span class="s1">undefined</span><span class="s3">);</span>
		<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">runtime of chunk</span><span class="s3">.</span><span class="s1">runtime</span><span class="s3">) {</span>
				<span class="s1">exportsInfo</span><span class="s3">.</span><span class="s1">setUsedForSideEffectsOnly</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">addModuleRuntimeRequirements</span><span class="s3">(</span>
			<span class="s1">module</span><span class="s3">,</span>
			<span class="s1">chunk</span><span class="s3">.</span><span class="s1">runtime</span><span class="s3">,</span>
			<span class="s4">new </span><span class="s1">Set</span><span class="s3">([</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">requireScope</span><span class="s3">])</span>
		<span class="s3">);</span>

		<span class="s0">// runtime modules don't need ids</span>
		<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">setModuleId</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s2">&quot;&quot;</span><span class="s3">);</span>

		<span class="s0">// Call hook</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">runtimeModule</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* If `module` is passed, `loc` and `request` must also be passed.</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string | ChunkGroupOptions} groupOptions options for the chunk group</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module=} module the module the references the chunk group</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{DependencyLocation=} loc the location from with the chunk group is referenced (inside of module)</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string=} request the request from which the the chunk group is referenced</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ChunkGroup} the new or existing chunk group</span>
	 <span class="s5">*/</span>
	<span class="s1">addChunkInGroup</span><span class="s3">(</span><span class="s1">groupOptions</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">request</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">groupOptions </span><span class="s3">=== </span><span class="s2">&quot;string&quot;</span><span class="s3">) {</span>
			<span class="s1">groupOptions </span><span class="s3">= { </span><span class="s1">name</span><span class="s3">: </span><span class="s1">groupOptions </span><span class="s3">};</span>
		<span class="s3">}</span>
		<span class="s4">const </span><span class="s1">name </span><span class="s3">= </span><span class="s1">groupOptions</span><span class="s3">.</span><span class="s1">name</span><span class="s3">;</span>

		<span class="s4">if </span><span class="s3">(</span><span class="s1">name</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">chunkGroup </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">namedChunkGroups</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">chunkGroup </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s1">chunkGroup</span><span class="s3">.</span><span class="s1">addOptions</span><span class="s3">(</span><span class="s1">groupOptions</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
					<span class="s1">chunkGroup</span><span class="s3">.</span><span class="s1">addOrigin</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">request</span><span class="s3">);</span>
				<span class="s3">}</span>
				<span class="s4">return </span><span class="s1">chunkGroup</span><span class="s3">;</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s4">const </span><span class="s1">chunkGroup </span><span class="s3">= </span><span class="s4">new </span><span class="s1">ChunkGroup</span><span class="s3">(</span><span class="s1">groupOptions</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">module</span><span class="s3">) </span><span class="s1">chunkGroup</span><span class="s3">.</span><span class="s1">addOrigin</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">request</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">chunk </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">addChunk</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>

		<span class="s1">connectChunkGroupAndChunk</span><span class="s3">(</span><span class="s1">chunkGroup</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">);</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGroups</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">chunkGroup</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">name</span><span class="s3">) {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">namedChunkGroups</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">chunkGroup</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">return </span><span class="s1">chunkGroup</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{EntryOptions} options options for the entrypoint</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module the references the chunk group</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{DependencyLocation} loc the location from with the chunk group is referenced (inside of module)</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} request the request from which the the chunk group is referenced</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Entrypoint} the new or existing entrypoint</span>
	 <span class="s5">*/</span>
	<span class="s1">addAsyncEntrypoint</span><span class="s3">(</span><span class="s1">options</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">request</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">name </span><span class="s3">= </span><span class="s1">options</span><span class="s3">.</span><span class="s1">name</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">name</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">entrypoint </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">namedChunkGroups</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">entrypoint </span><span class="s4">instanceof </span><span class="s1">Entrypoint</span><span class="s3">) {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">entrypoint </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
						<span class="s1">entrypoint</span><span class="s3">.</span><span class="s1">addOrigin</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">request</span><span class="s3">);</span>
					<span class="s3">}</span>
					<span class="s4">return </span><span class="s1">entrypoint</span><span class="s3">;</span>
				<span class="s3">}</span>
			<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">entrypoint</span><span class="s3">) {</span>
				<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
					<span class="s2">`Cannot add an async entrypoint with the name '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">', because there is already an chunk group with this name`</span>
				<span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s4">const </span><span class="s1">chunk </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">addChunk</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">) {</span>
			<span class="s1">chunk</span><span class="s3">.</span><span class="s1">filenameTemplate </span><span class="s3">= </span><span class="s1">options</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">;</span>
		<span class="s3">}</span>
		<span class="s4">const </span><span class="s1">entrypoint </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Entrypoint</span><span class="s3">(</span><span class="s1">options</span><span class="s3">, </span><span class="s4">false</span><span class="s3">);</span>
		<span class="s1">entrypoint</span><span class="s3">.</span><span class="s1">setRuntimeChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s1">entrypoint</span><span class="s3">.</span><span class="s1">setEntrypointChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">name</span><span class="s3">) {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">namedChunkGroups</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">entrypoint</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGroups</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">entrypoint</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">asyncEntrypoints</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">entrypoint</span><span class="s3">);</span>
		<span class="s1">connectChunkGroupAndChunk</span><span class="s3">(</span><span class="s1">entrypoint</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
			<span class="s1">entrypoint</span><span class="s3">.</span><span class="s1">addOrigin</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">request</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">return </span><span class="s1">entrypoint</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* This method first looks to see if a name is provided for a new chunk,</span>
	 <span class="s5">* and first looks to see if any named chunks already exist and reuse that chunk instead.</span>
	 <span class="s5">*</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string=} name optional chunk name to be provided</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Chunk} create a chunk (invoked during seal event)</span>
	 <span class="s5">*/</span>
	<span class="s1">addChunk</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">name</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">chunk </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">namedChunks</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">chunk </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s4">return </span><span class="s1">chunk</span><span class="s3">;</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s4">const </span><span class="s1">chunk </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Chunk</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_backCompat</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_backCompat</span><span class="s3">)</span>
			<span class="s1">ChunkGraph</span><span class="s3">.</span><span class="s1">setChunkGraphForChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">name</span><span class="s3">) {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">namedChunks</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">return </span><span class="s1">chunk</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@deprecated</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module module to assign depth</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">assignDepth</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">moduleGraph </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">;</span>

		<span class="s4">const </span><span class="s1">queue </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">([</span><span class="s1">module</span><span class="s3">]);</span>
		<span class="s4">let </span><span class="s1">depth</span><span class="s3">;</span>

		<span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">setDepth</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s7">0</span><span class="s3">);</span>

		<span class="s5">/**</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module module for processing</span>
		 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
		 <span class="s5">*/</span>
		<span class="s4">const </span><span class="s1">processModule </span><span class="s3">= </span><span class="s1">module </span><span class="s3">=&gt; {</span>
			<span class="s4">if </span><span class="s3">(!</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">setDepthIfLower</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">depth</span><span class="s3">)) </span><span class="s4">return</span><span class="s3">;</span>
			<span class="s1">queue</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s3">};</span>

		<span class="s4">for </span><span class="s3">(</span><span class="s1">module of queue</span><span class="s3">) {</span>
			<span class="s1">queue</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s1">depth </span><span class="s3">= </span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getDepth</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) + </span><span class="s7">1</span><span class="s3">;</span>

			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">connection of moduleGraph</span><span class="s3">.</span><span class="s1">getOutgoingConnections</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
				<span class="s4">const </span><span class="s1">refModule </span><span class="s3">= </span><span class="s1">connection</span><span class="s3">.</span><span class="s1">module</span><span class="s3">;</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">refModule</span><span class="s3">) {</span>
					<span class="s1">processModule</span><span class="s3">(</span><span class="s1">refModule</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Set&lt;Module&gt;} modules module to assign depth</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">assignDepths</span><span class="s3">(</span><span class="s1">modules</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">moduleGraph </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">;</span>

		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;Module | number&gt;} */</span>
		<span class="s4">const </span><span class="s1">queue </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">modules</span><span class="s3">);</span>
		<span class="s1">queue</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s7">1</span><span class="s3">);</span>
		<span class="s4">let </span><span class="s1">depth </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>

		<span class="s4">let </span><span class="s1">i </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of queue</span><span class="s3">) {</span>
			<span class="s1">i</span><span class="s3">++;</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">module </span><span class="s3">=== </span><span class="s2">&quot;number&quot;</span><span class="s3">) {</span>
				<span class="s1">depth </span><span class="s3">= </span><span class="s1">module</span><span class="s3">;</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">queue</span><span class="s3">.</span><span class="s1">size </span><span class="s3">=== </span><span class="s1">i</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
				<span class="s1">queue</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">depth </span><span class="s3">+ </span><span class="s7">1</span><span class="s3">);</span>
			<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
				<span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">setDepth</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">depth</span><span class="s3">);</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">{ </span><span class="s1">module</span><span class="s3">: </span><span class="s1">refModule </span><span class="s3">} </span><span class="s1">of moduleGraph</span><span class="s3">.</span><span class="s1">getOutgoingConnections</span><span class="s3">(</span>
					<span class="s1">module</span>
				<span class="s3">)) {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">refModule</span><span class="s3">) {</span>
						<span class="s1">queue</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">refModule</span><span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Dependency} dependency the dependency</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime the runtime</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{(string[] | ReferencedExport)[]} referenced exports</span>
	 <span class="s5">*/</span>
	<span class="s1">getDependencyReferencedExports</span><span class="s3">(</span><span class="s1">dependency</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">referencedExports </span><span class="s3">= </span><span class="s1">dependency</span><span class="s3">.</span><span class="s1">getReferencedExports</span><span class="s3">(</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">,</span>
			<span class="s1">runtime</span>
		<span class="s3">);</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">dependencyReferencedExports</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span>
			<span class="s1">referencedExports</span><span class="s3">,</span>
			<span class="s1">dependency</span><span class="s3">,</span>
			<span class="s1">runtime</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">*</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module module relationship for removal</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{DependenciesBlockLike} block //TODO: good description</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">removeReasonsOfDependencyBlock</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">block</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">) {</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">b of block</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">) {</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">removeReasonsOfDependencyBlock</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">b</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">if </span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">dependencies</span><span class="s3">) {</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">dep of block</span><span class="s3">.</span><span class="s1">dependencies</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">originalModule </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getModule</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">originalModule</span><span class="s3">) {</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">removeConnection</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">);</span>

					<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph</span><span class="s3">) {</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getModuleChunks</span><span class="s3">(</span>
							<span class="s1">originalModule</span>
						<span class="s3">)) {</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">patchChunksAfterReasonRemoval</span><span class="s3">(</span><span class="s1">originalModule</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module module to patch tie</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk chunk to patch tie</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">patchChunksAfterReasonRemoval</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(!</span><span class="s1">module</span><span class="s3">.</span><span class="s1">hasReasons</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">runtime</span><span class="s3">)) {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">removeReasonsOfDependencyBlock</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">if </span><span class="s3">(!</span><span class="s1">module</span><span class="s3">.</span><span class="s1">hasReasonForChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph</span><span class="s3">)) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">isModuleInChunk</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">)) {</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">disconnectChunkAndModule</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">removeChunkFromDependencies</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">*</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{DependenciesBlock} block block tie for Chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk chunk to remove from dep</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">removeChunkFromDependencies</span><span class="s3">(</span><span class="s1">block</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s5">/**</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Dependency} d dependency to (maybe) patch up</span>
		 <span class="s5">*/</span>
		<span class="s4">const </span><span class="s1">iteratorDependency </span><span class="s3">= </span><span class="s1">d </span><span class="s3">=&gt; {</span>
			<span class="s4">const </span><span class="s1">depModule </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getModule</span><span class="s3">(</span><span class="s1">d</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(!</span><span class="s1">depModule</span><span class="s3">) {</span>
				<span class="s4">return</span><span class="s3">;</span>
			<span class="s3">}</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">patchChunksAfterReasonRemoval</span><span class="s3">(</span><span class="s1">depModule</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s3">};</span>

		<span class="s4">const </span><span class="s1">blocks </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">;</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">let </span><span class="s1">indexBlock </span><span class="s3">= </span><span class="s7">0</span><span class="s3">; </span><span class="s1">indexBlock </span><span class="s3">&lt; </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">indexBlock</span><span class="s3">++) {</span>
			<span class="s4">const </span><span class="s1">asyncBlock </span><span class="s3">= </span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">indexBlock</span><span class="s3">];</span>
			<span class="s4">const </span><span class="s1">chunkGroup </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getBlockChunkGroup</span><span class="s3">(</span><span class="s1">asyncBlock</span><span class="s3">);</span>
			<span class="s0">// Grab all chunks from the first Block's AsyncDepBlock</span>
			<span class="s4">const </span><span class="s1">chunks </span><span class="s3">= </span><span class="s1">chunkGroup</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">;</span>
			<span class="s0">// For each chunk in chunkGroup</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">let </span><span class="s1">indexChunk </span><span class="s3">= </span><span class="s7">0</span><span class="s3">; </span><span class="s1">indexChunk </span><span class="s3">&lt; </span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">indexChunk</span><span class="s3">++) {</span>
				<span class="s4">const </span><span class="s1">iteratedChunk </span><span class="s3">= </span><span class="s1">chunks</span><span class="s3">[</span><span class="s1">indexChunk</span><span class="s3">];</span>
				<span class="s1">chunkGroup</span><span class="s3">.</span><span class="s1">removeChunk</span><span class="s3">(</span><span class="s1">iteratedChunk</span><span class="s3">);</span>
				<span class="s0">// Recurse</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">removeChunkFromDependencies</span><span class="s3">(</span><span class="s1">block</span><span class="s3">, </span><span class="s1">iteratedChunk</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">if </span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">dependencies</span><span class="s3">) {</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">dep of block</span><span class="s3">.</span><span class="s1">dependencies</span><span class="s3">) </span><span class="s1">iteratorDependency</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s1">assignRuntimeIds</span><span class="s3">() {</span>
		<span class="s4">const </span><span class="s3">{ </span><span class="s1">chunkGraph </span><span class="s3">} = </span><span class="s4">this</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">processEntrypoint </span><span class="s3">= </span><span class="s1">ep </span><span class="s3">=&gt; {</span>
			<span class="s4">const </span><span class="s1">runtime </span><span class="s3">= </span><span class="s1">ep</span><span class="s3">.</span><span class="s1">options</span><span class="s3">.</span><span class="s1">runtime </span><span class="s3">|| </span><span class="s1">ep</span><span class="s3">.</span><span class="s1">name</span><span class="s3">;</span>
			<span class="s4">const </span><span class="s1">chunk </span><span class="s3">= </span><span class="s1">ep</span><span class="s3">.</span><span class="s1">getRuntimeChunk</span><span class="s3">();</span>
			<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">setRuntimeId</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">id</span><span class="s3">);</span>
		<span class="s3">};</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">ep of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">entrypoints</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()) {</span>
			<span class="s1">processEntrypoint</span><span class="s3">(</span><span class="s1">ep</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">ep of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">asyncEntrypoints</span><span class="s3">) {</span>
			<span class="s1">processEntrypoint</span><span class="s3">(</span><span class="s1">ep</span><span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s1">sortItemsWithChunkIds</span><span class="s3">() {</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunkGroup of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGroups</span><span class="s3">) {</span>
			<span class="s1">chunkGroup</span><span class="s3">.</span><span class="s1">sortItems</span><span class="s3">();</span>
		<span class="s3">}</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">compareErrors</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">compareErrors</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">children</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">byNameOrHash</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s1">summarizeDependencies</span><span class="s3">() {</span>
		<span class="s4">for </span><span class="s3">(</span>
			<span class="s4">let </span><span class="s1">indexChildren </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
			<span class="s1">indexChildren </span><span class="s3">&lt; </span><span class="s4">this</span><span class="s3">.</span><span class="s1">children</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
			<span class="s1">indexChildren</span><span class="s3">++</span>
		<span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">child </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">children</span><span class="s3">[</span><span class="s1">indexChildren</span><span class="s3">];</span>

			<span class="s4">this</span><span class="s3">.</span><span class="s1">fileDependencies</span><span class="s3">.</span><span class="s1">addAll</span><span class="s3">(</span><span class="s1">child</span><span class="s3">.</span><span class="s1">fileDependencies</span><span class="s3">);</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">contextDependencies</span><span class="s3">.</span><span class="s1">addAll</span><span class="s3">(</span><span class="s1">child</span><span class="s3">.</span><span class="s1">contextDependencies</span><span class="s3">);</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">missingDependencies</span><span class="s3">.</span><span class="s1">addAll</span><span class="s3">(</span><span class="s1">child</span><span class="s3">.</span><span class="s1">missingDependencies</span><span class="s3">);</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">buildDependencies</span><span class="s3">.</span><span class="s1">addAll</span><span class="s3">(</span><span class="s1">child</span><span class="s3">.</span><span class="s1">buildDependencies</span><span class="s3">);</span>
		<span class="s3">}</span>

		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
			<span class="s1">module</span><span class="s3">.</span><span class="s1">addCacheDependencies</span><span class="s3">(</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">fileDependencies</span><span class="s3">,</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">contextDependencies</span><span class="s3">,</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">missingDependencies</span><span class="s3">,</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">buildDependencies</span>
			<span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s1">createModuleHashes</span><span class="s3">() {</span>
		<span class="s4">let </span><span class="s1">statModulesHashed </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s4">let </span><span class="s1">statModulesFromCache </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s3">{ </span><span class="s1">chunkGraph</span><span class="s3">, </span><span class="s1">runtimeTemplate</span><span class="s3">, </span><span class="s1">moduleMemCaches2 </span><span class="s3">} = </span><span class="s4">this</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s3">{ </span><span class="s1">hashFunction</span><span class="s3">, </span><span class="s1">hashDigest</span><span class="s3">, </span><span class="s1">hashDigestLength </span><span class="s3">} = </span><span class="s4">this</span><span class="s3">.</span><span class="s1">outputOptions</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">errors </span><span class="s3">= [];</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">memCache </span><span class="s3">= </span><span class="s1">moduleMemCaches2 </span><span class="s3">&amp;&amp; </span><span class="s1">moduleMemCaches2</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">runtime of chunkGraph</span><span class="s3">.</span><span class="s1">getModuleRuntimes</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">memCache</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">digest </span><span class="s3">= </span><span class="s1">memCache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s2">`moduleHash-</span><span class="s1">$</span><span class="s3">{</span><span class="s1">getRuntimeKey</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">)}</span><span class="s2">`</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">digest </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
						<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">setModuleHashes</span><span class="s3">(</span>
							<span class="s1">module</span><span class="s3">,</span>
							<span class="s1">runtime</span><span class="s3">,</span>
							<span class="s1">digest</span><span class="s3">,</span>
							<span class="s1">digest</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">0</span><span class="s3">, </span><span class="s1">hashDigestLength</span><span class="s3">)</span>
						<span class="s3">);</span>
						<span class="s1">statModulesFromCache</span><span class="s3">++;</span>
						<span class="s4">continue</span><span class="s3">;</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
				<span class="s1">statModulesHashed</span><span class="s3">++;</span>
				<span class="s4">const </span><span class="s1">digest </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_createModuleHash</span><span class="s3">(</span>
					<span class="s1">module</span><span class="s3">,</span>
					<span class="s1">chunkGraph</span><span class="s3">,</span>
					<span class="s1">runtime</span><span class="s3">,</span>
					<span class="s1">hashFunction</span><span class="s3">,</span>
					<span class="s1">runtimeTemplate</span><span class="s3">,</span>
					<span class="s1">hashDigest</span><span class="s3">,</span>
					<span class="s1">hashDigestLength</span><span class="s3">,</span>
					<span class="s1">errors</span>
				<span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">memCache</span><span class="s3">) {</span>
					<span class="s1">memCache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s2">`moduleHash-</span><span class="s1">$</span><span class="s3">{</span><span class="s1">getRuntimeKey</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">)}</span><span class="s2">`</span><span class="s3">, </span><span class="s1">digest</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
			<span class="s1">errors</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">compareSelect</span><span class="s3">(</span><span class="s1">err </span><span class="s3">=&gt; </span><span class="s1">err</span><span class="s3">.</span><span class="s1">module</span><span class="s3">, </span><span class="s1">compareModulesByIdentifier</span><span class="s3">));</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">error of errors</span><span class="s3">) {</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">error</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span>
			<span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">statModulesHashed</span><span class="s3">} </span><span class="s2">modules hashed, </span><span class="s1">$</span><span class="s3">{</span><span class="s1">statModulesFromCache</span><span class="s3">} </span><span class="s2">from cache (</span><span class="s1">$</span><span class="s3">{</span>
				<span class="s1">Math</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span>
					<span class="s3">(</span><span class="s7">100 </span><span class="s3">* (</span><span class="s1">statModulesHashed </span><span class="s3">+ </span><span class="s1">statModulesFromCache</span><span class="s3">)) / </span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size</span>
				<span class="s3">) / </span><span class="s7">100</span>
			<span class="s3">} </span><span class="s2">variants per module in average)`</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s1">_createModuleHash</span><span class="s3">(</span>
		<span class="s1">module</span><span class="s3">,</span>
		<span class="s1">chunkGraph</span><span class="s3">,</span>
		<span class="s1">runtime</span><span class="s3">,</span>
		<span class="s1">hashFunction</span><span class="s3">,</span>
		<span class="s1">runtimeTemplate</span><span class="s3">,</span>
		<span class="s1">hashDigest</span><span class="s3">,</span>
		<span class="s1">hashDigestLength</span><span class="s3">,</span>
		<span class="s1">errors</span>
	<span class="s3">) {</span>
		<span class="s4">let </span><span class="s1">moduleHashDigest</span><span class="s3">;</span>
		<span class="s4">try </span><span class="s3">{</span>
			<span class="s4">const </span><span class="s1">moduleHash </span><span class="s3">= </span><span class="s1">createHash</span><span class="s3">(</span><span class="s1">hashFunction</span><span class="s3">);</span>
			<span class="s1">module</span><span class="s3">.</span><span class="s1">updateHash</span><span class="s3">(</span><span class="s1">moduleHash</span><span class="s3">, {</span>
				<span class="s1">chunkGraph</span><span class="s3">,</span>
				<span class="s1">runtime</span><span class="s3">,</span>
				<span class="s1">runtimeTemplate</span>
			<span class="s3">});</span>
			<span class="s1">moduleHashDigest </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */ </span><span class="s3">(</span><span class="s1">moduleHash</span><span class="s3">.</span><span class="s1">digest</span><span class="s3">(</span><span class="s1">hashDigest</span><span class="s3">));</span>
		<span class="s3">} </span><span class="s4">catch </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
			<span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s4">new </span><span class="s1">ModuleHashingError</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">err</span><span class="s3">));</span>
			<span class="s1">moduleHashDigest </span><span class="s3">= </span><span class="s2">&quot;XXXXXX&quot;</span><span class="s3">;</span>
		<span class="s3">}</span>
		<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">setModuleHashes</span><span class="s3">(</span>
			<span class="s1">module</span><span class="s3">,</span>
			<span class="s1">runtime</span><span class="s3">,</span>
			<span class="s1">moduleHashDigest</span><span class="s3">,</span>
			<span class="s1">moduleHashDigest</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">0</span><span class="s3">, </span><span class="s1">hashDigestLength</span><span class="s3">)</span>
		<span class="s3">);</span>
		<span class="s4">return </span><span class="s1">moduleHashDigest</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s1">createHash</span><span class="s3">() {</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;hashing: initialize hash&quot;</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">chunkGraph </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">runtimeTemplate </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">runtimeTemplate</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">outputOptions </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">outputOptions</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">hashFunction </span><span class="s3">= </span><span class="s1">outputOptions</span><span class="s3">.</span><span class="s1">hashFunction</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">hashDigest </span><span class="s3">= </span><span class="s1">outputOptions</span><span class="s3">.</span><span class="s1">hashDigest</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">hashDigestLength </span><span class="s3">= </span><span class="s1">outputOptions</span><span class="s3">.</span><span class="s1">hashDigestLength</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">hash </span><span class="s3">= </span><span class="s1">createHash</span><span class="s3">(</span><span class="s1">hashFunction</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">outputOptions</span><span class="s3">.</span><span class="s1">hashSalt</span><span class="s3">) {</span>
			<span class="s1">hash</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">outputOptions</span><span class="s3">.</span><span class="s1">hashSalt</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;hashing: initialize hash&quot;</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">children</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;hashing: hash child compilations&quot;</span><span class="s3">);</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">child of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">children</span><span class="s3">) {</span>
				<span class="s1">hash</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">child</span><span class="s3">.</span><span class="s1">hash</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;hashing: hash child compilations&quot;</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;hashing: hash warnings&quot;</span><span class="s3">);</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">warning of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">warnings</span><span class="s3">) {</span>
				<span class="s1">hash</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">warning</span><span class="s3">.</span><span class="s1">message</span><span class="s3">}</span><span class="s2">`</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;hashing: hash warnings&quot;</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;hashing: hash errors&quot;</span><span class="s3">);</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">error of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">) {</span>
				<span class="s1">hash</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">error</span><span class="s3">.</span><span class="s1">message</span><span class="s3">}</span><span class="s2">`</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;hashing: hash errors&quot;</span><span class="s3">);</span>
		<span class="s3">}</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;hashing: sort chunks&quot;</span><span class="s3">);</span>
		<span class="s0">/* 
         * all non-runtime chunks need to be hashes first, 
         * since runtime chunk might use their hashes. 
         * runtime chunks need to be hashed in the correct order 
         * since they may depend on each other (for async entrypoints). 
         * So we put all non-runtime chunks first and hash them in any order. 
         * And order runtime chunks according to referenced between each other. 
         * Chunks need to be in deterministic order since we add hashes to full chunk 
         * during these hashing. 
         */</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Chunk[]} */</span>
		<span class="s4">const </span><span class="s1">unorderedRuntimeChunks </span><span class="s3">= [];</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Chunk[]} */</span>
		<span class="s4">const </span><span class="s1">otherChunks </span><span class="s3">= [];</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">c of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">c</span><span class="s3">.</span><span class="s1">hasRuntime</span><span class="s3">()) {</span>
				<span class="s1">unorderedRuntimeChunks</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">c</span><span class="s3">);</span>
			<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
				<span class="s1">otherChunks</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">c</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s1">unorderedRuntimeChunks</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">byId</span><span class="s3">);</span>
		<span class="s1">otherChunks</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">byId</span><span class="s3">);</span>

		<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;Chunk, RuntimeChunkInfo&gt;} */</span>
		<span class="s4">const </span><span class="s1">runtimeChunksMap </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of unorderedRuntimeChunks</span><span class="s3">) {</span>
			<span class="s1">runtimeChunksMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, {</span>
				<span class="s1">chunk</span><span class="s3">,</span>
				<span class="s1">referencedBy</span><span class="s3">: [],</span>
				<span class="s1">remaining</span><span class="s3">: </span><span class="s7">0</span>
			<span class="s3">});</span>
		<span class="s3">}</span>
		<span class="s4">let </span><span class="s1">remaining </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">info of runtimeChunksMap</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()) {</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">other of </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span>
				<span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">getAllReferencedAsyncEntrypoints</span><span class="s3">()).</span><span class="s1">map</span><span class="s3">(</span>
					<span class="s1">e </span><span class="s3">=&gt; </span><span class="s1">e</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">[</span><span class="s1">e</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s7">1</span><span class="s3">]</span>
				<span class="s3">)</span>
			<span class="s3">)) {</span>
				<span class="s4">const </span><span class="s1">otherInfo </span><span class="s3">= </span><span class="s1">runtimeChunksMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">other</span><span class="s3">);</span>
				<span class="s1">otherInfo</span><span class="s3">.</span><span class="s1">referencedBy</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">info</span><span class="s3">);</span>
				<span class="s1">info</span><span class="s3">.</span><span class="s1">remaining</span><span class="s3">++;</span>
				<span class="s1">remaining</span><span class="s3">++;</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Chunk[]} */</span>
		<span class="s4">const </span><span class="s1">runtimeChunks </span><span class="s3">= [];</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">info of runtimeChunksMap</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">remaining </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) {</span>
				<span class="s1">runtimeChunks</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">chunk</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s0">// If there are any references between chunks</span>
		<span class="s0">// make sure to follow these chains</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">remaining </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">readyChunks </span><span class="s3">= [];</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of runtimeChunks</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">hasFullHashModules </span><span class="s3">=</span>
					<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getNumberOfChunkFullHashModules</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) !== </span><span class="s7">0</span><span class="s3">;</span>
				<span class="s4">const </span><span class="s1">info </span><span class="s3">= </span><span class="s1">runtimeChunksMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">otherInfo of info</span><span class="s3">.</span><span class="s1">referencedBy</span><span class="s3">) {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">hasFullHashModules</span><span class="s3">) {</span>
						<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">upgradeDependentToFullHashModules</span><span class="s3">(</span><span class="s1">otherInfo</span><span class="s3">.</span><span class="s1">chunk</span><span class="s3">);</span>
					<span class="s3">}</span>
					<span class="s1">remaining</span><span class="s3">--;</span>
					<span class="s4">if </span><span class="s3">(--</span><span class="s1">otherInfo</span><span class="s3">.</span><span class="s1">remaining </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) {</span>
						<span class="s1">readyChunks</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">otherInfo</span><span class="s3">.</span><span class="s1">chunk</span><span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">readyChunks</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
					<span class="s0">// This ensures deterministic ordering, since referencedBy is non-deterministic</span>
					<span class="s1">readyChunks</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">byId</span><span class="s3">);</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">c of readyChunks</span><span class="s3">) </span><span class="s1">runtimeChunks</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">c</span><span class="s3">);</span>
					<span class="s1">readyChunks</span><span class="s3">.</span><span class="s1">length </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s0">// If there are still remaining references we have cycles and want to create a warning</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">remaining </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
			<span class="s4">let </span><span class="s1">circularRuntimeChunkInfo </span><span class="s3">= [];</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">info of runtimeChunksMap</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()) {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">remaining </span><span class="s3">!== </span><span class="s7">0</span><span class="s3">) {</span>
					<span class="s1">circularRuntimeChunkInfo</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">info</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
			<span class="s1">circularRuntimeChunkInfo</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">compareSelect</span><span class="s3">(</span><span class="s1">i </span><span class="s3">=&gt; </span><span class="s1">i</span><span class="s3">.</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">byId</span><span class="s3">));</span>
			<span class="s4">const </span><span class="s1">err </span><span class="s3">=</span>
				<span class="s4">new </span><span class="s1">WebpackError</span><span class="s3">(</span><span class="s2">`Circular dependency between chunks with runtime (</span><span class="s1">$</span><span class="s3">{</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span>
					<span class="s1">circularRuntimeChunkInfo</span><span class="s3">,</span>
					<span class="s1">c </span><span class="s3">=&gt; </span><span class="s1">c</span><span class="s3">.</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">name </span><span class="s3">|| </span><span class="s1">c</span><span class="s3">.</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">id</span>
				<span class="s3">).</span><span class="s1">join</span><span class="s3">(</span><span class="s2">&quot;, &quot;</span><span class="s3">)}</span><span class="s2">) 
This prevents using hashes of each other and should be avoided.`</span><span class="s3">);</span>
			<span class="s1">err</span><span class="s3">.</span><span class="s1">chunk </span><span class="s3">= </span><span class="s1">circularRuntimeChunkInfo</span><span class="s3">[</span><span class="s7">0</span><span class="s3">].</span><span class="s1">chunk</span><span class="s3">;</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">i of circularRuntimeChunkInfo</span><span class="s3">) </span><span class="s1">runtimeChunks</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">i</span><span class="s3">.</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;hashing: sort chunks&quot;</span><span class="s3">);</span>

		<span class="s4">const </span><span class="s1">fullHashChunks </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */</span>
		<span class="s4">const </span><span class="s1">codeGenerationJobs </span><span class="s3">= [];</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, Map&lt;Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}&gt;&gt;} */</span>
		<span class="s4">const </span><span class="s1">codeGenerationJobsMap </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s4">const </span><span class="s1">errors </span><span class="s3">= [];</span>

		<span class="s4">const </span><span class="s1">processChunk </span><span class="s3">= </span><span class="s1">chunk </span><span class="s3">=&gt; {</span>
			<span class="s0">// Last minute module hash generation for modules that depend on chunk hashes</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;hashing: hash runtime modules&quot;</span><span class="s3">);</span>
			<span class="s4">const </span><span class="s1">runtime </span><span class="s3">= </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">runtime</span><span class="s3">;</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of chunkGraph</span><span class="s3">.</span><span class="s1">getChunkModulesIterable</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">)) {</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">hasModuleHashes</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">)) {</span>
					<span class="s4">const </span><span class="s1">hash </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_createModuleHash</span><span class="s3">(</span>
						<span class="s1">module</span><span class="s3">,</span>
						<span class="s1">chunkGraph</span><span class="s3">,</span>
						<span class="s1">runtime</span><span class="s3">,</span>
						<span class="s1">hashFunction</span><span class="s3">,</span>
						<span class="s1">runtimeTemplate</span><span class="s3">,</span>
						<span class="s1">hashDigest</span><span class="s3">,</span>
						<span class="s1">hashDigestLength</span><span class="s3">,</span>
						<span class="s1">errors</span>
					<span class="s3">);</span>
					<span class="s4">let </span><span class="s1">hashMap </span><span class="s3">= </span><span class="s1">codeGenerationJobsMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">hash</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">hashMap</span><span class="s3">) {</span>
						<span class="s4">const </span><span class="s1">moduleJob </span><span class="s3">= </span><span class="s1">hashMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">moduleJob</span><span class="s3">) {</span>
							<span class="s1">moduleJob</span><span class="s3">.</span><span class="s1">runtimes</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">);</span>
							<span class="s4">continue</span><span class="s3">;</span>
						<span class="s3">}</span>
					<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
						<span class="s1">hashMap </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
						<span class="s1">codeGenerationJobsMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">hash</span><span class="s3">, </span><span class="s1">hashMap</span><span class="s3">);</span>
					<span class="s3">}</span>
					<span class="s4">const </span><span class="s1">job </span><span class="s3">= {</span>
						<span class="s1">module</span><span class="s3">,</span>
						<span class="s1">hash</span><span class="s3">,</span>
						<span class="s1">runtime</span><span class="s3">,</span>
						<span class="s1">runtimes</span><span class="s3">: [</span><span class="s1">runtime</span><span class="s3">]</span>
					<span class="s3">};</span>
					<span class="s1">hashMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">job</span><span class="s3">);</span>
					<span class="s1">codeGenerationJobs</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">job</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeAggregate</span><span class="s3">(</span><span class="s2">&quot;hashing: hash runtime modules&quot;</span><span class="s3">);</span>
			<span class="s4">try </span><span class="s3">{</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;hashing: hash chunks&quot;</span><span class="s3">);</span>
				<span class="s4">const </span><span class="s1">chunkHash </span><span class="s3">= </span><span class="s1">createHash</span><span class="s3">(</span><span class="s1">hashFunction</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">outputOptions</span><span class="s3">.</span><span class="s1">hashSalt</span><span class="s3">) {</span>
					<span class="s1">chunkHash</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">outputOptions</span><span class="s3">.</span><span class="s1">hashSalt</span><span class="s3">);</span>
				<span class="s3">}</span>
				<span class="s1">chunk</span><span class="s3">.</span><span class="s1">updateHash</span><span class="s3">(</span><span class="s1">chunkHash</span><span class="s3">, </span><span class="s1">chunkGraph</span><span class="s3">);</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">chunkHash</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">chunkHash</span><span class="s3">, {</span>
					<span class="s1">chunkGraph</span><span class="s3">,</span>
					<span class="s1">codeGenerationResults</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">codeGenerationResults</span><span class="s3">,</span>
					<span class="s1">moduleGraph</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">,</span>
					<span class="s1">runtimeTemplate</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">runtimeTemplate</span>
				<span class="s3">});</span>
				<span class="s4">const </span><span class="s1">chunkHashDigest </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */ </span><span class="s3">(</span>
					<span class="s1">chunkHash</span><span class="s3">.</span><span class="s1">digest</span><span class="s3">(</span><span class="s1">hashDigest</span><span class="s3">)</span>
				<span class="s3">);</span>
				<span class="s1">hash</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">chunkHashDigest</span><span class="s3">);</span>
				<span class="s1">chunk</span><span class="s3">.</span><span class="s1">hash </span><span class="s3">= </span><span class="s1">chunkHashDigest</span><span class="s3">;</span>
				<span class="s1">chunk</span><span class="s3">.</span><span class="s1">renderedHash </span><span class="s3">= </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">hash</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">0</span><span class="s3">, </span><span class="s1">hashDigestLength</span><span class="s3">);</span>
				<span class="s4">const </span><span class="s1">fullHashModules </span><span class="s3">=</span>
					<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getChunkFullHashModulesIterable</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">fullHashModules</span><span class="s3">) {</span>
					<span class="s1">fullHashChunks</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
				<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">contentHash</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">} </span><span class="s4">catch </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s4">new </span><span class="s1">ChunkRenderError</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s2">&quot;&quot;</span><span class="s3">, </span><span class="s1">err</span><span class="s3">));</span>
			<span class="s3">}</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeAggregate</span><span class="s3">(</span><span class="s2">&quot;hashing: hash chunks&quot;</span><span class="s3">);</span>
		<span class="s3">};</span>
		<span class="s1">otherChunks</span><span class="s3">.</span><span class="s1">forEach</span><span class="s3">(</span><span class="s1">processChunk</span><span class="s3">);</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of runtimeChunks</span><span class="s3">) </span><span class="s1">processChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
			<span class="s1">errors</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">compareSelect</span><span class="s3">(</span><span class="s1">err </span><span class="s3">=&gt; </span><span class="s1">err</span><span class="s3">.</span><span class="s1">module</span><span class="s3">, </span><span class="s1">compareModulesByIdentifier</span><span class="s3">));</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">error of errors</span><span class="s3">) {</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">error</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeAggregateEnd</span><span class="s3">(</span><span class="s2">&quot;hashing: hash runtime modules&quot;</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeAggregateEnd</span><span class="s3">(</span><span class="s2">&quot;hashing: hash chunks&quot;</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;hashing: hash digest&quot;</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">fullHash</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">hash</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">fullHash </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */ </span><span class="s3">(</span><span class="s1">hash</span><span class="s3">.</span><span class="s1">digest</span><span class="s3">(</span><span class="s1">hashDigest</span><span class="s3">));</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">hash </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">fullHash</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">0</span><span class="s3">, </span><span class="s1">hashDigestLength</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;hashing: hash digest&quot;</span><span class="s3">);</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">time</span><span class="s3">(</span><span class="s2">&quot;hashing: process full hash modules&quot;</span><span class="s3">);</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of fullHashChunks</span><span class="s3">) {</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of chunkGraph</span><span class="s3">.</span><span class="s1">getChunkFullHashModulesIterable</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">)) {</span>
				<span class="s4">const </span><span class="s1">moduleHash </span><span class="s3">= </span><span class="s1">createHash</span><span class="s3">(</span><span class="s1">hashFunction</span><span class="s3">);</span>
				<span class="s1">module</span><span class="s3">.</span><span class="s1">updateHash</span><span class="s3">(</span><span class="s1">moduleHash</span><span class="s3">, {</span>
					<span class="s1">chunkGraph</span><span class="s3">,</span>
					<span class="s1">runtime</span><span class="s3">: </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">runtime</span><span class="s3">,</span>
					<span class="s1">runtimeTemplate</span>
				<span class="s3">});</span>
				<span class="s4">const </span><span class="s1">moduleHashDigest </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */ </span><span class="s3">(</span>
					<span class="s1">moduleHash</span><span class="s3">.</span><span class="s1">digest</span><span class="s3">(</span><span class="s1">hashDigest</span><span class="s3">)</span>
				<span class="s3">);</span>
				<span class="s4">const </span><span class="s1">oldHash </span><span class="s3">= </span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getModuleHash</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">runtime</span><span class="s3">);</span>
				<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">setModuleHashes</span><span class="s3">(</span>
					<span class="s1">module</span><span class="s3">,</span>
					<span class="s1">chunk</span><span class="s3">.</span><span class="s1">runtime</span><span class="s3">,</span>
					<span class="s1">moduleHashDigest</span><span class="s3">,</span>
					<span class="s1">moduleHashDigest</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">0</span><span class="s3">, </span><span class="s1">hashDigestLength</span><span class="s3">)</span>
				<span class="s3">);</span>
				<span class="s1">codeGenerationJobsMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">oldHash</span><span class="s3">).</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">).</span><span class="s1">hash </span><span class="s3">= </span><span class="s1">moduleHashDigest</span><span class="s3">;</span>
			<span class="s3">}</span>
			<span class="s4">const </span><span class="s1">chunkHash </span><span class="s3">= </span><span class="s1">createHash</span><span class="s3">(</span><span class="s1">hashFunction</span><span class="s3">);</span>
			<span class="s1">chunkHash</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">hash</span><span class="s3">);</span>
			<span class="s1">chunkHash</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">hash</span><span class="s3">);</span>
			<span class="s4">const </span><span class="s1">chunkHashDigest </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */ </span><span class="s3">(</span>
				<span class="s1">chunkHash</span><span class="s3">.</span><span class="s1">digest</span><span class="s3">(</span><span class="s1">hashDigest</span><span class="s3">)</span>
			<span class="s3">);</span>
			<span class="s1">chunk</span><span class="s3">.</span><span class="s1">hash </span><span class="s3">= </span><span class="s1">chunkHashDigest</span><span class="s3">;</span>
			<span class="s1">chunk</span><span class="s3">.</span><span class="s1">renderedHash </span><span class="s3">= </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">hash</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">0</span><span class="s3">, </span><span class="s1">hashDigestLength</span><span class="s3">);</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">contentHash</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">logger</span><span class="s3">.</span><span class="s1">timeEnd</span><span class="s3">(</span><span class="s2">&quot;hashing: process full hash modules&quot;</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">codeGenerationJobs</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} file file name</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Source} source asset source</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{AssetInfo} assetInfo extra asset information</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">emitAsset</span><span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s1">source</span><span class="s3">, </span><span class="s1">assetInfo </span><span class="s3">= {}) {</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">file</span><span class="s3">]) {</span>
			<span class="s4">if </span><span class="s3">(!</span><span class="s1">isSourceEqual</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">file</span><span class="s3">], </span><span class="s1">source</span><span class="s3">)) {</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span>
					<span class="s4">new </span><span class="s1">WebpackError</span><span class="s3">(</span>
						<span class="s2">`Conflict: Multiple assets emit different content to the same filename </span><span class="s1">$</span><span class="s3">{</span><span class="s1">file</span><span class="s3">}</span><span class="s1">$</span><span class="s3">{</span>
							<span class="s1">assetInfo</span><span class="s3">.</span><span class="s1">sourceFilename</span>
								<span class="s3">? </span><span class="s2">`. Original source </span><span class="s1">$</span><span class="s3">{</span><span class="s1">assetInfo</span><span class="s3">.</span><span class="s1">sourceFilename</span><span class="s3">}</span><span class="s2">`</span>
								<span class="s3">: </span><span class="s2">&quot;&quot;</span>
						<span class="s3">}</span><span class="s2">`</span>
					<span class="s3">)</span>
				<span class="s3">);</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">file</span><span class="s3">] = </span><span class="s1">source</span><span class="s3">;</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">_setAssetInfo</span><span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s1">assetInfo</span><span class="s3">);</span>
				<span class="s4">return</span><span class="s3">;</span>
			<span class="s3">}</span>
			<span class="s4">const </span><span class="s1">oldInfo </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">assetsInfo</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">file</span><span class="s3">);</span>
			<span class="s4">const </span><span class="s1">newInfo </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">assign</span><span class="s3">({}, </span><span class="s1">oldInfo</span><span class="s3">, </span><span class="s1">assetInfo</span><span class="s3">);</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">_setAssetInfo</span><span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s1">newInfo</span><span class="s3">, </span><span class="s1">oldInfo</span><span class="s3">);</span>
			<span class="s4">return</span><span class="s3">;</span>
		<span class="s3">}</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">file</span><span class="s3">] = </span><span class="s1">source</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_setAssetInfo</span><span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s1">assetInfo</span><span class="s3">, </span><span class="s1">undefined</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s1">_setAssetInfo</span><span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s1">newInfo</span><span class="s3">, </span><span class="s1">oldInfo </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">assetsInfo</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">file</span><span class="s3">)) {</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">newInfo </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">assetsInfo</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">file</span><span class="s3">);</span>
		<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">assetsInfo</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s1">newInfo</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">const </span><span class="s1">oldRelated </span><span class="s3">= </span><span class="s1">oldInfo </span><span class="s3">&amp;&amp; </span><span class="s1">oldInfo</span><span class="s3">.</span><span class="s1">related</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">newRelated </span><span class="s3">= </span><span class="s1">newInfo </span><span class="s3">&amp;&amp; </span><span class="s1">newInfo</span><span class="s3">.</span><span class="s1">related</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">oldRelated</span><span class="s3">) {</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">key of Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">oldRelated</span><span class="s3">)) {</span>
				<span class="s4">const </span><span class="s1">remove </span><span class="s3">= </span><span class="s1">name </span><span class="s3">=&gt; {</span>
					<span class="s4">const </span><span class="s1">relatedIn </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_assetsRelatedIn</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">relatedIn </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
					<span class="s4">const </span><span class="s1">entry </span><span class="s3">= </span><span class="s1">relatedIn</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">entry </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
					<span class="s1">entry</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">file</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">entry</span><span class="s3">.</span><span class="s1">size </span><span class="s3">!== </span><span class="s7">0</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
					<span class="s1">relatedIn</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">relatedIn</span><span class="s3">.</span><span class="s1">size </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_assetsRelatedIn</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
				<span class="s3">};</span>
				<span class="s4">const </span><span class="s1">entry </span><span class="s3">= </span><span class="s1">oldRelated</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">)) {</span>
					<span class="s1">entry</span><span class="s3">.</span><span class="s1">forEach</span><span class="s3">(</span><span class="s1">remove</span><span class="s3">);</span>
				<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">entry</span><span class="s3">) {</span>
					<span class="s1">remove</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">newRelated</span><span class="s3">) {</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">key of Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">newRelated</span><span class="s3">)) {</span>
				<span class="s4">const </span><span class="s1">add </span><span class="s3">= </span><span class="s1">name </span><span class="s3">=&gt; {</span>
					<span class="s4">let </span><span class="s1">relatedIn </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_assetsRelatedIn</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">relatedIn </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">_assetsRelatedIn</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, (</span><span class="s1">relatedIn </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">()));</span>
					<span class="s3">}</span>
					<span class="s4">let </span><span class="s1">entry </span><span class="s3">= </span><span class="s1">relatedIn</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">entry </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
						<span class="s1">relatedIn</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, (</span><span class="s1">entry </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">()));</span>
					<span class="s3">}</span>
					<span class="s1">entry</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">file</span><span class="s3">);</span>
				<span class="s3">};</span>
				<span class="s4">const </span><span class="s1">entry </span><span class="s3">= </span><span class="s1">newRelated</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">)) {</span>
					<span class="s1">entry</span><span class="s3">.</span><span class="s1">forEach</span><span class="s3">(</span><span class="s1">add</span><span class="s3">);</span>
				<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">entry</span><span class="s3">) {</span>
					<span class="s1">add</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} file file name</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Source | function(Source): Source} newSourceOrFunction new asset source or function converting old to new</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{AssetInfo | function(AssetInfo | undefined): AssetInfo} assetInfoUpdateOrFunction new asset info or function converting old to new</span>
	 <span class="s5">*/</span>
	<span class="s1">updateAsset</span><span class="s3">(</span>
		<span class="s1">file</span><span class="s3">,</span>
		<span class="s1">newSourceOrFunction</span><span class="s3">,</span>
		<span class="s1">assetInfoUpdateOrFunction </span><span class="s3">= </span><span class="s1">undefined</span>
	<span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(!</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">file</span><span class="s3">]) {</span>
			<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
				<span class="s2">`Called Compilation.updateAsset for not existing filename </span><span class="s1">$</span><span class="s3">{</span><span class="s1">file</span><span class="s3">}</span><span class="s2">`</span>
			<span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">newSourceOrFunction </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">file</span><span class="s3">] = </span><span class="s1">newSourceOrFunction</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">file</span><span class="s3">]);</span>
		<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">file</span><span class="s3">] = </span><span class="s1">newSourceOrFunction</span><span class="s3">;</span>
		<span class="s3">}</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">assetInfoUpdateOrFunction </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">oldInfo </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">assetsInfo</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">file</span><span class="s3">) || </span><span class="s1">EMPTY_ASSET_INFO</span><span class="s3">;</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s4">typeof </span><span class="s1">assetInfoUpdateOrFunction </span><span class="s3">=== </span><span class="s2">&quot;function&quot;</span><span class="s3">) {</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">_setAssetInfo</span><span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s1">assetInfoUpdateOrFunction</span><span class="s3">(</span><span class="s1">oldInfo</span><span class="s3">), </span><span class="s1">oldInfo</span><span class="s3">);</span>
			<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">_setAssetInfo</span><span class="s3">(</span>
					<span class="s1">file</span><span class="s3">,</span>
					<span class="s1">cachedCleverMerge</span><span class="s3">(</span><span class="s1">oldInfo</span><span class="s3">, </span><span class="s1">assetInfoUpdateOrFunction</span><span class="s3">),</span>
					<span class="s1">oldInfo</span>
				<span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s1">renameAsset</span><span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s1">newFile</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">source </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">file</span><span class="s3">];</span>
		<span class="s4">if </span><span class="s3">(!</span><span class="s1">source</span><span class="s3">) {</span>
			<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
				<span class="s2">`Called Compilation.renameAsset for not existing filename </span><span class="s1">$</span><span class="s3">{</span><span class="s1">file</span><span class="s3">}</span><span class="s2">`</span>
			<span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">newFile</span><span class="s3">]) {</span>
			<span class="s4">if </span><span class="s3">(!</span><span class="s1">isSourceEqual</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">file</span><span class="s3">], </span><span class="s1">source</span><span class="s3">)) {</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span>
					<span class="s4">new </span><span class="s1">WebpackError</span><span class="s3">(</span>
						<span class="s2">`Conflict: Called Compilation.renameAsset for already existing filename </span><span class="s1">$</span><span class="s3">{</span><span class="s1">newFile</span><span class="s3">} </span><span class="s2">with different content`</span>
					<span class="s3">)</span>
				<span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s4">const </span><span class="s1">assetInfo </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">assetsInfo</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">file</span><span class="s3">);</span>
		<span class="s0">// Update related in all other assets</span>
		<span class="s4">const </span><span class="s1">relatedInInfo </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_assetsRelatedIn</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">file</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">relatedInInfo</span><span class="s3">) {</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span><span class="s1">key</span><span class="s3">, </span><span class="s1">assets</span><span class="s3">] </span><span class="s1">of relatedInInfo</span><span class="s3">) {</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">name of assets</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">info </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">assetsInfo</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(!</span><span class="s1">info</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
					<span class="s4">const </span><span class="s1">related </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">related</span><span class="s3">;</span>
					<span class="s4">if </span><span class="s3">(!</span><span class="s1">related</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
					<span class="s4">const </span><span class="s1">entry </span><span class="s3">= </span><span class="s1">related</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
					<span class="s4">let </span><span class="s1">newEntry</span><span class="s3">;</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">)) {</span>
						<span class="s1">newEntry </span><span class="s3">= </span><span class="s1">entry</span><span class="s3">.</span><span class="s1">map</span><span class="s3">(</span><span class="s1">x </span><span class="s3">=&gt; (</span><span class="s1">x </span><span class="s3">=== </span><span class="s1">file </span><span class="s3">? </span><span class="s1">newFile </span><span class="s3">: </span><span class="s1">x</span><span class="s3">));</span>
					<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">entry </span><span class="s3">=== </span><span class="s1">file</span><span class="s3">) {</span>
						<span class="s1">newEntry </span><span class="s3">= </span><span class="s1">newFile</span><span class="s3">;</span>
					<span class="s3">} </span><span class="s4">else continue</span><span class="s3">;</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">assetsInfo</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, {</span>
						<span class="s1">...info</span><span class="s3">,</span>
						<span class="s1">related</span><span class="s3">: {</span>
							<span class="s1">...related</span><span class="s3">,</span>
							<span class="s3">[</span><span class="s1">key</span><span class="s3">]: </span><span class="s1">newEntry</span>
						<span class="s3">}</span>
					<span class="s3">});</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_setAssetInfo</span><span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s1">undefined</span><span class="s3">, </span><span class="s1">assetInfo</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_setAssetInfo</span><span class="s3">(</span><span class="s1">newFile</span><span class="s3">, </span><span class="s1">assetInfo</span><span class="s3">);</span>
		<span class="s4">delete this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">file</span><span class="s3">];</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">newFile</span><span class="s3">] = </span><span class="s1">source</span><span class="s3">;</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">) {</span>
			<span class="s3">{</span>
				<span class="s4">const </span><span class="s1">size </span><span class="s3">= </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">files</span><span class="s3">.</span><span class="s1">size</span><span class="s3">;</span>
				<span class="s1">chunk</span><span class="s3">.</span><span class="s1">files</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">file</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">size </span><span class="s3">!== </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">files</span><span class="s3">.</span><span class="s1">size</span><span class="s3">) {</span>
					<span class="s1">chunk</span><span class="s3">.</span><span class="s1">files</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">newFile</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
			<span class="s3">{</span>
				<span class="s4">const </span><span class="s1">size </span><span class="s3">= </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">auxiliaryFiles</span><span class="s3">.</span><span class="s1">size</span><span class="s3">;</span>
				<span class="s1">chunk</span><span class="s3">.</span><span class="s1">auxiliaryFiles</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">file</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">size </span><span class="s3">!== </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">auxiliaryFiles</span><span class="s3">.</span><span class="s1">size</span><span class="s3">) {</span>
					<span class="s1">chunk</span><span class="s3">.</span><span class="s1">auxiliaryFiles</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">newFile</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} file file name</span>
	 <span class="s5">*/</span>
	<span class="s1">deleteAsset</span><span class="s3">(</span><span class="s1">file</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(!</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">file</span><span class="s3">]) {</span>
			<span class="s4">return</span><span class="s3">;</span>
		<span class="s3">}</span>
		<span class="s4">delete this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">file</span><span class="s3">];</span>
		<span class="s4">const </span><span class="s1">assetInfo </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">assetsInfo</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">file</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_setAssetInfo</span><span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s1">undefined</span><span class="s3">, </span><span class="s1">assetInfo</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">related </span><span class="s3">= </span><span class="s1">assetInfo </span><span class="s3">&amp;&amp; </span><span class="s1">assetInfo</span><span class="s3">.</span><span class="s1">related</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">related</span><span class="s3">) {</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">key of Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">related</span><span class="s3">)) {</span>
				<span class="s4">const </span><span class="s1">checkUsedAndDelete </span><span class="s3">= </span><span class="s1">file </span><span class="s3">=&gt; {</span>
					<span class="s4">if </span><span class="s3">(!</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_assetsRelatedIn</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">file</span><span class="s3">)) {</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">deleteAsset</span><span class="s3">(</span><span class="s1">file</span><span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">};</span>
				<span class="s4">const </span><span class="s1">items </span><span class="s3">= </span><span class="s1">related</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">items</span><span class="s3">)) {</span>
					<span class="s1">items</span><span class="s3">.</span><span class="s1">forEach</span><span class="s3">(</span><span class="s1">checkUsedAndDelete</span><span class="s3">);</span>
				<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">items</span><span class="s3">) {</span>
					<span class="s1">checkUsedAndDelete</span><span class="s3">(</span><span class="s1">items</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s0">// TODO If this becomes a performance problem</span>
		<span class="s0">// store a reverse mapping from asset to chunk</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">) {</span>
			<span class="s1">chunk</span><span class="s3">.</span><span class="s1">files</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">file</span><span class="s3">);</span>
			<span class="s1">chunk</span><span class="s3">.</span><span class="s1">auxiliaryFiles</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">file</span><span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s1">getAssets</span><span class="s3">() {</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Readonly&lt;Asset&gt;[]} */</span>
		<span class="s4">const </span><span class="s1">array </span><span class="s3">= [];</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">assetName of Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">)) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">Object</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">hasOwnProperty</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">, </span><span class="s1">assetName</span><span class="s3">)) {</span>
				<span class="s1">array</span><span class="s3">.</span><span class="s1">push</span><span class="s3">({</span>
					<span class="s1">name</span><span class="s3">: </span><span class="s1">assetName</span><span class="s3">,</span>
					<span class="s1">source</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">assetName</span><span class="s3">],</span>
					<span class="s1">info</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">assetsInfo</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">assetName</span><span class="s3">) || </span><span class="s1">EMPTY_ASSET_INFO</span>
				<span class="s3">});</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s4">return </span><span class="s1">array</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} name the name of the asset</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Readonly&lt;Asset&gt; | undefined} the asset or undefined when not found</span>
	 <span class="s5">*/</span>
	<span class="s1">getAsset</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(!</span><span class="s1">Object</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">hasOwnProperty</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">, </span><span class="s1">name</span><span class="s3">))</span>
			<span class="s4">return </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s4">return </span><span class="s3">{</span>
			<span class="s1">name</span><span class="s3">,</span>
			<span class="s1">source</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">name</span><span class="s3">],</span>
			<span class="s1">info</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">assetsInfo</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) || </span><span class="s1">EMPTY_ASSET_INFO</span>
		<span class="s3">};</span>
	<span class="s3">}</span>

	<span class="s1">clearAssets</span><span class="s3">() {</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">) {</span>
			<span class="s1">chunk</span><span class="s3">.</span><span class="s1">files</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
			<span class="s1">chunk</span><span class="s3">.</span><span class="s1">auxiliaryFiles</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s1">createModuleAssets</span><span class="s3">() {</span>
		<span class="s4">const </span><span class="s3">{ </span><span class="s1">chunkGraph </span><span class="s3">} = </span><span class="s4">this</span><span class="s3">;</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">assetsInfo </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">.</span><span class="s1">assetsInfo</span><span class="s3">;</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">assetName of Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">)) {</span>
					<span class="s4">const </span><span class="s1">fileName </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">getPath</span><span class="s3">(</span><span class="s1">assetName</span><span class="s3">, {</span>
						<span class="s1">chunkGraph</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph</span><span class="s3">,</span>
						<span class="s1">module</span>
					<span class="s3">});</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of chunkGraph</span><span class="s3">.</span><span class="s1">getModuleChunksIterable</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
						<span class="s1">chunk</span><span class="s3">.</span><span class="s1">auxiliaryFiles</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">fileName</span><span class="s3">);</span>
					<span class="s3">}</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">emitAsset</span><span class="s3">(</span>
						<span class="s1">fileName</span><span class="s3">,</span>
						<span class="s1">module</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">[</span><span class="s1">assetName</span><span class="s3">],</span>
						<span class="s1">assetsInfo </span><span class="s3">? </span><span class="s1">assetsInfo</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">assetName</span><span class="s3">) : </span><span class="s1">undefined</span>
					<span class="s3">);</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">moduleAsset</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">fileName</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RenderManifestOptions} options options object</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{RenderManifestEntry[]} manifest entries</span>
	 <span class="s5">*/</span>
	<span class="s1">getRenderManifest</span><span class="s3">(</span><span class="s1">options</span><span class="s3">) {</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">renderManifest</span><span class="s3">.</span><span class="s1">call</span><span class="s3">([], </span><span class="s1">options</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Callback} callback signals when the call finishes</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">createChunkAssets</span><span class="s3">(</span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">outputOptions </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">outputOptions</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">cachedSourceMap </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, {hash: string, source: Source, chunk: Chunk}&gt;} */</span>
		<span class="s4">const </span><span class="s1">alreadyWrittenFiles </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>

		<span class="s1">asyncLib</span><span class="s3">.</span><span class="s1">forEachLimit</span><span class="s3">(</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">,</span>
			<span class="s7">15</span><span class="s3">,</span>
			<span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) =&gt; {</span>
				<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{RenderManifestEntry[]} */</span>
				<span class="s4">let </span><span class="s1">manifest</span><span class="s3">;</span>
				<span class="s4">try </span><span class="s3">{</span>
					<span class="s1">manifest </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">getRenderManifest</span><span class="s3">({</span>
						<span class="s1">chunk</span><span class="s3">,</span>
						<span class="s1">hash</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">hash</span><span class="s3">,</span>
						<span class="s1">fullHash</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">fullHash</span><span class="s3">,</span>
						<span class="s1">outputOptions</span><span class="s3">,</span>
						<span class="s1">codeGenerationResults</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">codeGenerationResults</span><span class="s3">,</span>
						<span class="s1">moduleTemplates</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleTemplates</span><span class="s3">,</span>
						<span class="s1">dependencyTemplates</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">dependencyTemplates</span><span class="s3">,</span>
						<span class="s1">chunkGraph</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph</span><span class="s3">,</span>
						<span class="s1">moduleGraph</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">,</span>
						<span class="s1">runtimeTemplate</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">runtimeTemplate</span>
					<span class="s3">});</span>
				<span class="s3">} </span><span class="s4">catch </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s4">new </span><span class="s1">ChunkRenderError</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s2">&quot;&quot;</span><span class="s3">, </span><span class="s1">err</span><span class="s3">));</span>
					<span class="s4">return </span><span class="s1">callback</span><span class="s3">();</span>
				<span class="s3">}</span>
				<span class="s1">asyncLib</span><span class="s3">.</span><span class="s1">forEach</span><span class="s3">(</span>
					<span class="s1">manifest</span><span class="s3">,</span>
					<span class="s3">(</span><span class="s1">fileManifest</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) =&gt; {</span>
						<span class="s4">const </span><span class="s1">ident </span><span class="s3">= </span><span class="s1">fileManifest</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">;</span>
						<span class="s4">const </span><span class="s1">usedHash </span><span class="s3">= </span><span class="s1">fileManifest</span><span class="s3">.</span><span class="s1">hash</span><span class="s3">;</span>

						<span class="s4">const </span><span class="s1">assetCacheItem </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_assetsCache</span><span class="s3">.</span><span class="s1">getItemCache</span><span class="s3">(</span>
							<span class="s1">ident</span><span class="s3">,</span>
							<span class="s1">usedHash</span>
						<span class="s3">);</span>

						<span class="s1">assetCacheItem</span><span class="s3">.</span><span class="s1">get</span><span class="s3">((</span><span class="s1">err</span><span class="s3">, </span><span class="s1">sourceFromCache</span><span class="s3">) =&gt; {</span>
							<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string | function(PathData, AssetInfo=): string} */</span>
							<span class="s4">let </span><span class="s1">filenameTemplate</span><span class="s3">;</span>
							<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */</span>
							<span class="s4">let </span><span class="s1">file</span><span class="s3">;</span>
							<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{AssetInfo} */</span>
							<span class="s4">let </span><span class="s1">assetInfo</span><span class="s3">;</span>

							<span class="s4">let </span><span class="s1">inTry </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
							<span class="s4">const </span><span class="s1">errorAndCallback </span><span class="s3">= </span><span class="s1">err </span><span class="s3">=&gt; {</span>
								<span class="s4">const </span><span class="s1">filename </span><span class="s3">=</span>
									<span class="s1">file </span><span class="s3">||</span>
									<span class="s3">(</span><span class="s4">typeof </span><span class="s1">file </span><span class="s3">=== </span><span class="s2">&quot;string&quot;</span>
										<span class="s3">? </span><span class="s1">file</span>
										<span class="s3">: </span><span class="s4">typeof </span><span class="s1">filenameTemplate </span><span class="s3">=== </span><span class="s2">&quot;string&quot;</span>
										<span class="s3">? </span><span class="s1">filenameTemplate</span>
										<span class="s3">: </span><span class="s2">&quot;&quot;</span><span class="s3">);</span>

								<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s4">new </span><span class="s1">ChunkRenderError</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">, </span><span class="s1">err</span><span class="s3">));</span>
								<span class="s1">inTry </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
								<span class="s4">return </span><span class="s1">callback</span><span class="s3">();</span>
							<span class="s3">};</span>

							<span class="s4">try </span><span class="s3">{</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s2">&quot;filename&quot; </span><span class="s4">in </span><span class="s1">fileManifest</span><span class="s3">) {</span>
									<span class="s1">file </span><span class="s3">= </span><span class="s1">fileManifest</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">;</span>
									<span class="s1">assetInfo </span><span class="s3">= </span><span class="s1">fileManifest</span><span class="s3">.</span><span class="s1">info</span><span class="s3">;</span>
								<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
									<span class="s1">filenameTemplate </span><span class="s3">= </span><span class="s1">fileManifest</span><span class="s3">.</span><span class="s1">filenameTemplate</span><span class="s3">;</span>
									<span class="s4">const </span><span class="s1">pathAndInfo </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">getPathWithInfo</span><span class="s3">(</span>
										<span class="s1">filenameTemplate</span><span class="s3">,</span>
										<span class="s1">fileManifest</span><span class="s3">.</span><span class="s1">pathOptions</span>
									<span class="s3">);</span>
									<span class="s1">file </span><span class="s3">= </span><span class="s1">pathAndInfo</span><span class="s3">.</span><span class="s1">path</span><span class="s3">;</span>
									<span class="s1">assetInfo </span><span class="s3">= </span><span class="s1">fileManifest</span><span class="s3">.</span><span class="s1">info</span>
										<span class="s3">? {</span>
												<span class="s1">...pathAndInfo</span><span class="s3">.</span><span class="s1">info</span><span class="s3">,</span>
												<span class="s1">...fileManifest</span><span class="s3">.</span><span class="s1">info</span>
										  <span class="s3">}</span>
										<span class="s3">: </span><span class="s1">pathAndInfo</span><span class="s3">.</span><span class="s1">info</span><span class="s3">;</span>
								<span class="s3">}</span>

								<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
									<span class="s4">return </span><span class="s1">errorAndCallback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
								<span class="s3">}</span>

								<span class="s4">let </span><span class="s1">source </span><span class="s3">= </span><span class="s1">sourceFromCache</span><span class="s3">;</span>

								<span class="s0">// check if the same filename was already written by another chunk</span>
								<span class="s4">const </span><span class="s1">alreadyWritten </span><span class="s3">= </span><span class="s1">alreadyWrittenFiles</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">file</span><span class="s3">);</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">alreadyWritten </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
									<span class="s4">if </span><span class="s3">(</span><span class="s1">alreadyWritten</span><span class="s3">.</span><span class="s1">hash </span><span class="s3">!== </span><span class="s1">usedHash</span><span class="s3">) {</span>
										<span class="s1">inTry </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
										<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span>
											<span class="s4">new </span><span class="s1">WebpackError</span><span class="s3">(</span>
												<span class="s2">`Conflict: Multiple chunks emit assets to the same filename </span><span class="s1">$</span><span class="s3">{</span><span class="s1">file</span><span class="s3">}</span><span class="s2">` </span><span class="s3">+</span>
													<span class="s2">` (chunks </span><span class="s1">$</span><span class="s3">{</span><span class="s1">alreadyWritten</span><span class="s3">.</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">id</span><span class="s3">} </span><span class="s2">and </span><span class="s1">$</span><span class="s3">{</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">id</span><span class="s3">}</span><span class="s2">)`</span>
											<span class="s3">)</span>
										<span class="s3">);</span>
									<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
										<span class="s1">source </span><span class="s3">= </span><span class="s1">alreadyWritten</span><span class="s3">.</span><span class="s1">source</span><span class="s3">;</span>
									<span class="s3">}</span>
								<span class="s3">} </span><span class="s4">else if </span><span class="s3">(!</span><span class="s1">source</span><span class="s3">) {</span>
									<span class="s0">// render the asset</span>
									<span class="s1">source </span><span class="s3">= </span><span class="s1">fileManifest</span><span class="s3">.</span><span class="s1">render</span><span class="s3">();</span>

									<span class="s0">// Ensure that source is a cached source to avoid additional cost because of repeated access</span>
									<span class="s4">if </span><span class="s3">(!(</span><span class="s1">source </span><span class="s4">instanceof </span><span class="s1">CachedSource</span><span class="s3">)) {</span>
										<span class="s4">const </span><span class="s1">cacheEntry </span><span class="s3">= </span><span class="s1">cachedSourceMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">source</span><span class="s3">);</span>
										<span class="s4">if </span><span class="s3">(</span><span class="s1">cacheEntry</span><span class="s3">) {</span>
											<span class="s1">source </span><span class="s3">= </span><span class="s1">cacheEntry</span><span class="s3">;</span>
										<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
											<span class="s4">const </span><span class="s1">cachedSource </span><span class="s3">= </span><span class="s4">new </span><span class="s1">CachedSource</span><span class="s3">(</span><span class="s1">source</span><span class="s3">);</span>
											<span class="s1">cachedSourceMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s1">cachedSource</span><span class="s3">);</span>
											<span class="s1">source </span><span class="s3">= </span><span class="s1">cachedSource</span><span class="s3">;</span>
										<span class="s3">}</span>
									<span class="s3">}</span>
								<span class="s3">}</span>
								<span class="s4">this</span><span class="s3">.</span><span class="s1">emitAsset</span><span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s1">source</span><span class="s3">, </span><span class="s1">assetInfo</span><span class="s3">);</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">fileManifest</span><span class="s3">.</span><span class="s1">auxiliary</span><span class="s3">) {</span>
									<span class="s1">chunk</span><span class="s3">.</span><span class="s1">auxiliaryFiles</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">file</span><span class="s3">);</span>
								<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
									<span class="s1">chunk</span><span class="s3">.</span><span class="s1">files</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">file</span><span class="s3">);</span>
								<span class="s3">}</span>
								<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">chunkAsset</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">file</span><span class="s3">);</span>
								<span class="s1">alreadyWrittenFiles</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">file</span><span class="s3">, {</span>
									<span class="s1">hash</span><span class="s3">: </span><span class="s1">usedHash</span><span class="s3">,</span>
									<span class="s1">source</span><span class="s3">,</span>
									<span class="s1">chunk</span>
								<span class="s3">});</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">source </span><span class="s3">!== </span><span class="s1">sourceFromCache</span><span class="s3">) {</span>
									<span class="s1">assetCacheItem</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s1">err </span><span class="s3">=&gt; {</span>
										<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) </span><span class="s4">return </span><span class="s1">errorAndCallback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
										<span class="s1">inTry </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
										<span class="s4">return </span><span class="s1">callback</span><span class="s3">();</span>
									<span class="s3">});</span>
								<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
									<span class="s1">inTry </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
									<span class="s1">callback</span><span class="s3">();</span>
								<span class="s3">}</span>
							<span class="s3">} </span><span class="s4">catch </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
								<span class="s4">if </span><span class="s3">(!</span><span class="s1">inTry</span><span class="s3">) </span><span class="s4">throw </span><span class="s1">err</span><span class="s3">;</span>
								<span class="s1">errorAndCallback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
							<span class="s3">}</span>
						<span class="s3">});</span>
					<span class="s3">},</span>
					<span class="s1">callback</span>
				<span class="s3">);</span>
			<span class="s3">},</span>
			<span class="s1">callback</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string | function(PathData, AssetInfo=): string} filename used to get asset path with hash</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{PathData} data context data</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} interpolated path</span>
	 <span class="s5">*/</span>
	<span class="s1">getPath</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">data </span><span class="s3">= {}) {</span>
		<span class="s4">if </span><span class="s3">(!</span><span class="s1">data</span><span class="s3">.</span><span class="s1">hash</span><span class="s3">) {</span>
			<span class="s1">data </span><span class="s3">= {</span>
				<span class="s1">hash</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">hash</span><span class="s3">,</span>
				<span class="s1">...data</span>
			<span class="s3">};</span>
		<span class="s3">}</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">getAssetPath</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">data</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string | function(PathData, AssetInfo=): string} filename used to get asset path with hash</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{PathData} data context data</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{{ path: string, info: AssetInfo }} interpolated path and asset info</span>
	 <span class="s5">*/</span>
	<span class="s1">getPathWithInfo</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">data </span><span class="s3">= {}) {</span>
		<span class="s4">if </span><span class="s3">(!</span><span class="s1">data</span><span class="s3">.</span><span class="s1">hash</span><span class="s3">) {</span>
			<span class="s1">data </span><span class="s3">= {</span>
				<span class="s1">hash</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">hash</span><span class="s3">,</span>
				<span class="s1">...data</span>
			<span class="s3">};</span>
		<span class="s3">}</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">getAssetPathWithInfo</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">data</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string | function(PathData, AssetInfo=): string} filename used to get asset path with hash</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{PathData} data context data</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} interpolated path</span>
	 <span class="s5">*/</span>
	<span class="s1">getAssetPath</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">data</span><span class="s3">) {</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">assetPath</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span>
			<span class="s4">typeof </span><span class="s1">filename </span><span class="s3">=== </span><span class="s2">&quot;function&quot; </span><span class="s3">? </span><span class="s1">filename</span><span class="s3">(</span><span class="s1">data</span><span class="s3">) : </span><span class="s1">filename</span><span class="s3">,</span>
			<span class="s1">data</span><span class="s3">,</span>
			<span class="s1">undefined</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string | function(PathData, AssetInfo=): string} filename used to get asset path with hash</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{PathData} data context data</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{{ path: string, info: AssetInfo }} interpolated path and asset info</span>
	 <span class="s5">*/</span>
	<span class="s1">getAssetPathWithInfo</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">data</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">assetInfo </span><span class="s3">= {};</span>
		<span class="s0">// TODO webpack 5: refactor assetPath hook to receive { path, info } object</span>
		<span class="s4">const </span><span class="s1">newPath </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">assetPath</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span>
			<span class="s4">typeof </span><span class="s1">filename </span><span class="s3">=== </span><span class="s2">&quot;function&quot; </span><span class="s3">? </span><span class="s1">filename</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">assetInfo</span><span class="s3">) : </span><span class="s1">filename</span><span class="s3">,</span>
			<span class="s1">data</span><span class="s3">,</span>
			<span class="s1">assetInfo</span>
		<span class="s3">);</span>
		<span class="s4">return </span><span class="s3">{ </span><span class="s1">path</span><span class="s3">: </span><span class="s1">newPath</span><span class="s3">, </span><span class="s1">info</span><span class="s3">: </span><span class="s1">assetInfo </span><span class="s3">};</span>
	<span class="s3">}</span>

	<span class="s1">getWarnings</span><span class="s3">() {</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">processWarnings</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">warnings</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s1">getErrors</span><span class="s3">() {</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">processErrors</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* This function allows you to run another instance of webpack inside of webpack however as</span>
	 <span class="s5">* a child with different settings and configurations (if desired) applied. It copies all hooks, plugins</span>
	 <span class="s5">* from parent (or top level compiler) and creates a child Compilation</span>
	 <span class="s5">*</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} name name of the child compiler</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{OutputOptions=} outputOptions // Need to convert config schema to types for this</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Array&lt;WebpackPluginInstance | WebpackPluginFunction&gt;=} plugins webpack plugins that will be applied</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Compiler} creates a child Compiler instance</span>
	 <span class="s5">*/</span>
	<span class="s1">createChildCompiler</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">outputOptions</span><span class="s3">, </span><span class="s1">plugins</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">idx </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">childrenCounters</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] || </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">childrenCounters</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">idx </span><span class="s3">+ </span><span class="s7">1</span><span class="s3">;</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">createChildCompiler</span><span class="s3">(</span>
			<span class="s4">this</span><span class="s3">,</span>
			<span class="s1">name</span><span class="s3">,</span>
			<span class="s1">idx</span><span class="s3">,</span>
			<span class="s1">outputOptions</span><span class="s3">,</span>
			<span class="s1">plugins</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ExecuteModuleOptions} options options</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ExecuteModuleCallback} callback callback</span>
	 <span class="s5">*/</span>
	<span class="s1">executeModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s0">// Aggregate all referenced modules and ensure they are ready</span>
		<span class="s4">const </span><span class="s1">modules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">([</span><span class="s1">module</span><span class="s3">]);</span>
		<span class="s1">processAsyncTree</span><span class="s3">(</span>
			<span class="s1">modules</span><span class="s3">,</span>
			<span class="s7">10</span><span class="s3">,</span>
			<span class="s5">/**</span>
			 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
			 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{function(Module): void} push push more jobs</span>
			 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Callback} callback callback</span>
			 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
			 <span class="s5">*/</span>
			<span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">push</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) =&gt; {</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">buildQueue</span><span class="s3">.</span><span class="s1">waitFor</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">err </span><span class="s3">=&gt; {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) </span><span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">processDependenciesQueue</span><span class="s3">.</span><span class="s1">waitFor</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">err </span><span class="s3">=&gt; {</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) </span><span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">{ </span><span class="s1">module</span><span class="s3">: </span><span class="s1">m </span><span class="s3">} </span><span class="s1">of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getOutgoingConnections</span><span class="s3">(</span>
							<span class="s1">module</span>
						<span class="s3">)) {</span>
							<span class="s4">const </span><span class="s1">size </span><span class="s3">= </span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size</span><span class="s3">;</span>
							<span class="s1">modules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">m</span><span class="s3">);</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size </span><span class="s3">!== </span><span class="s1">size</span><span class="s3">) </span><span class="s1">push</span><span class="s3">(</span><span class="s1">m</span><span class="s3">);</span>
						<span class="s3">}</span>
						<span class="s1">callback</span><span class="s3">();</span>
					<span class="s3">});</span>
				<span class="s3">});</span>
			<span class="s3">},</span>
			<span class="s1">err </span><span class="s3">=&gt; {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) </span><span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>

				<span class="s0">// Create new chunk graph, chunk and entrypoint for the build time execution</span>
				<span class="s4">const </span><span class="s1">chunkGraph </span><span class="s3">= </span><span class="s4">new </span><span class="s1">ChunkGraph</span><span class="s3">(</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">,</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">outputOptions</span><span class="s3">.</span><span class="s1">hashFunction</span>
				<span class="s3">);</span>
				<span class="s4">const </span><span class="s1">runtime </span><span class="s3">= </span><span class="s2">&quot;build time&quot;</span><span class="s3">;</span>
				<span class="s4">const </span><span class="s3">{ </span><span class="s1">hashFunction</span><span class="s3">, </span><span class="s1">hashDigest</span><span class="s3">, </span><span class="s1">hashDigestLength </span><span class="s3">} =</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">outputOptions</span><span class="s3">;</span>
				<span class="s4">const </span><span class="s1">runtimeTemplate </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">runtimeTemplate</span><span class="s3">;</span>

				<span class="s4">const </span><span class="s1">chunk </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Chunk</span><span class="s3">(</span><span class="s2">&quot;build time chunk&quot;</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_backCompat</span><span class="s3">);</span>
				<span class="s1">chunk</span><span class="s3">.</span><span class="s1">id </span><span class="s3">= </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">name</span><span class="s3">;</span>
				<span class="s1">chunk</span><span class="s3">.</span><span class="s1">ids </span><span class="s3">= [</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">id</span><span class="s3">];</span>
				<span class="s1">chunk</span><span class="s3">.</span><span class="s1">runtime </span><span class="s3">= </span><span class="s1">runtime</span><span class="s3">;</span>

				<span class="s4">const </span><span class="s1">entrypoint </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Entrypoint</span><span class="s3">({</span>
					<span class="s1">runtime</span><span class="s3">,</span>
					<span class="s1">chunkLoading</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
					<span class="s1">...options</span><span class="s3">.</span><span class="s1">entryOptions</span>
				<span class="s3">});</span>
				<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">connectChunkAndEntryModule</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">entrypoint</span><span class="s3">);</span>
				<span class="s1">connectChunkGroupAndChunk</span><span class="s3">(</span><span class="s1">entrypoint</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">);</span>
				<span class="s1">entrypoint</span><span class="s3">.</span><span class="s1">setRuntimeChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
				<span class="s1">entrypoint</span><span class="s3">.</span><span class="s1">setEntrypointChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>

				<span class="s4">const </span><span class="s1">chunks </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">([</span><span class="s1">chunk</span><span class="s3">]);</span>

				<span class="s0">// Assign ids to modules and modules to the chunk</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of modules</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">id </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">();</span>
					<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">setModuleId</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">id</span><span class="s3">);</span>
					<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">connectChunkAndModule</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
				<span class="s3">}</span>

				<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WebpackError[]} */</span>
				<span class="s4">const </span><span class="s1">errors </span><span class="s3">= [];</span>

				<span class="s0">// Hash modules</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of modules</span><span class="s3">) {</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">_createModuleHash</span><span class="s3">(</span>
						<span class="s1">module</span><span class="s3">,</span>
						<span class="s1">chunkGraph</span><span class="s3">,</span>
						<span class="s1">runtime</span><span class="s3">,</span>
						<span class="s1">hashFunction</span><span class="s3">,</span>
						<span class="s1">runtimeTemplate</span><span class="s3">,</span>
						<span class="s1">hashDigest</span><span class="s3">,</span>
						<span class="s1">hashDigestLength</span><span class="s3">,</span>
						<span class="s1">errors</span>
					<span class="s3">);</span>
				<span class="s3">}</span>

				<span class="s4">const </span><span class="s1">codeGenerationResults </span><span class="s3">= </span><span class="s4">new </span><span class="s1">CodeGenerationResults</span><span class="s3">(</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">outputOptions</span><span class="s3">.</span><span class="s1">hashFunction</span>
				<span class="s3">);</span>
				<span class="s5">/**</span>
				 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
				 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Callback} callback callback</span>
				 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
				 <span class="s5">*/</span>
				<span class="s4">const </span><span class="s1">codeGen </span><span class="s3">= (</span><span class="s1">module</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) =&gt; {</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">_codeGenerationModule</span><span class="s3">(</span>
						<span class="s1">module</span><span class="s3">,</span>
						<span class="s1">runtime</span><span class="s3">,</span>
						<span class="s3">[</span><span class="s1">runtime</span><span class="s3">],</span>
						<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getModuleHash</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">),</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">dependencyTemplates</span><span class="s3">,</span>
						<span class="s1">chunkGraph</span><span class="s3">,</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">,</span>
						<span class="s1">runtimeTemplate</span><span class="s3">,</span>
						<span class="s1">errors</span><span class="s3">,</span>
						<span class="s1">codeGenerationResults</span><span class="s3">,</span>
						<span class="s3">(</span><span class="s1">err</span><span class="s3">, </span><span class="s1">codeGenerated</span><span class="s3">) =&gt; {</span>
							<span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">);</span>
				<span class="s3">};</span>

				<span class="s4">const </span><span class="s1">reportErrors </span><span class="s3">= () =&gt; {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
						<span class="s1">errors</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span>
							<span class="s1">compareSelect</span><span class="s3">(</span><span class="s1">err </span><span class="s3">=&gt; </span><span class="s1">err</span><span class="s3">.</span><span class="s1">module</span><span class="s3">, </span><span class="s1">compareModulesByIdentifier</span><span class="s3">)</span>
						<span class="s3">);</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">error of errors</span><span class="s3">) {</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">error</span><span class="s3">);</span>
						<span class="s3">}</span>
						<span class="s1">errors</span><span class="s3">.</span><span class="s1">length </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
					<span class="s3">}</span>
				<span class="s3">};</span>

				<span class="s0">// Generate code for all aggregated modules</span>
				<span class="s1">asyncLib</span><span class="s3">.</span><span class="s1">eachLimit</span><span class="s3">(</span><span class="s1">modules</span><span class="s3">, </span><span class="s7">10</span><span class="s3">, </span><span class="s1">codeGen</span><span class="s3">, </span><span class="s1">err </span><span class="s3">=&gt; {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) </span><span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
					<span class="s1">reportErrors</span><span class="s3">();</span>

					<span class="s0">// for backward-compat temporary set the chunk graph</span>
					<span class="s0">// TODO webpack 6</span>
					<span class="s4">const </span><span class="s1">old </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph</span><span class="s3">;</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph </span><span class="s3">= </span><span class="s1">chunkGraph</span><span class="s3">;</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">processRuntimeRequirements</span><span class="s3">({</span>
						<span class="s1">chunkGraph</span><span class="s3">,</span>
						<span class="s1">modules</span><span class="s3">,</span>
						<span class="s1">chunks</span><span class="s3">,</span>
						<span class="s1">codeGenerationResults</span><span class="s3">,</span>
						<span class="s1">chunkGraphEntries</span><span class="s3">: </span><span class="s1">chunks</span>
					<span class="s3">});</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph </span><span class="s3">= </span><span class="s1">old</span><span class="s3">;</span>

					<span class="s4">const </span><span class="s1">runtimeModules </span><span class="s3">=</span>
						<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getChunkRuntimeModulesIterable</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>

					<span class="s0">// Hash runtime modules</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of runtimeModules</span><span class="s3">) {</span>
						<span class="s1">modules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">_createModuleHash</span><span class="s3">(</span>
							<span class="s1">module</span><span class="s3">,</span>
							<span class="s1">chunkGraph</span><span class="s3">,</span>
							<span class="s1">runtime</span><span class="s3">,</span>
							<span class="s1">hashFunction</span><span class="s3">,</span>
							<span class="s1">runtimeTemplate</span><span class="s3">,</span>
							<span class="s1">hashDigest</span><span class="s3">,</span>
							<span class="s1">hashDigestLength</span>
						<span class="s3">);</span>
					<span class="s3">}</span>

					<span class="s0">// Generate code for all runtime modules</span>
					<span class="s1">asyncLib</span><span class="s3">.</span><span class="s1">eachLimit</span><span class="s3">(</span><span class="s1">runtimeModules</span><span class="s3">, </span><span class="s7">10</span><span class="s3">, </span><span class="s1">codeGen</span><span class="s3">, </span><span class="s1">err </span><span class="s3">=&gt; {</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) </span><span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
						<span class="s1">reportErrors</span><span class="s3">();</span>

						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;Module, ExecuteModuleArgument&gt;} */</span>
						<span class="s4">const </span><span class="s1">moduleArgumentsMap </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, ExecuteModuleArgument&gt;} */</span>
						<span class="s4">const </span><span class="s1">moduleArgumentsById </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>

						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ExecuteModuleResult[&quot;fileDependencies&quot;]} */</span>
						<span class="s4">const </span><span class="s1">fileDependencies </span><span class="s3">= </span><span class="s4">new </span><span class="s1">LazySet</span><span class="s3">();</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ExecuteModuleResult[&quot;contextDependencies&quot;]} */</span>
						<span class="s4">const </span><span class="s1">contextDependencies </span><span class="s3">= </span><span class="s4">new </span><span class="s1">LazySet</span><span class="s3">();</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ExecuteModuleResult[&quot;missingDependencies&quot;]} */</span>
						<span class="s4">const </span><span class="s1">missingDependencies </span><span class="s3">= </span><span class="s4">new </span><span class="s1">LazySet</span><span class="s3">();</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ExecuteModuleResult[&quot;buildDependencies&quot;]} */</span>
						<span class="s4">const </span><span class="s1">buildDependencies </span><span class="s3">= </span><span class="s4">new </span><span class="s1">LazySet</span><span class="s3">();</span>

						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ExecuteModuleResult[&quot;assets&quot;]} */</span>
						<span class="s4">const </span><span class="s1">assets </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>

						<span class="s4">let </span><span class="s1">cacheable </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>

						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ExecuteModuleContext} */</span>
						<span class="s4">const </span><span class="s1">context </span><span class="s3">= {</span>
							<span class="s1">assets</span><span class="s3">,</span>
							<span class="s1">__webpack_require__</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
							<span class="s1">chunk</span><span class="s3">,</span>
							<span class="s1">chunkGraph</span>
						<span class="s3">};</span>

						<span class="s0">// Prepare execution</span>
						<span class="s1">asyncLib</span><span class="s3">.</span><span class="s1">eachLimit</span><span class="s3">(</span>
							<span class="s1">modules</span><span class="s3">,</span>
							<span class="s7">10</span><span class="s3">,</span>
							<span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) =&gt; {</span>
								<span class="s4">const </span><span class="s1">codeGenerationResult </span><span class="s3">= </span><span class="s1">codeGenerationResults</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span>
									<span class="s1">module</span><span class="s3">,</span>
									<span class="s1">runtime</span>
								<span class="s3">);</span>
								<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ExecuteModuleArgument} */</span>
								<span class="s4">const </span><span class="s1">moduleArgument </span><span class="s3">= {</span>
									<span class="s1">module</span><span class="s3">,</span>
									<span class="s1">codeGenerationResult</span><span class="s3">,</span>
									<span class="s1">preparedInfo</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
									<span class="s1">moduleObject</span><span class="s3">: </span><span class="s1">undefined</span>
								<span class="s3">};</span>
								<span class="s1">moduleArgumentsMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">moduleArgument</span><span class="s3">);</span>
								<span class="s1">moduleArgumentsById</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">(), </span><span class="s1">moduleArgument</span><span class="s3">);</span>
								<span class="s1">module</span><span class="s3">.</span><span class="s1">addCacheDependencies</span><span class="s3">(</span>
									<span class="s1">fileDependencies</span><span class="s3">,</span>
									<span class="s1">contextDependencies</span><span class="s3">,</span>
									<span class="s1">missingDependencies</span><span class="s3">,</span>
									<span class="s1">buildDependencies</span>
								<span class="s3">);</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">.</span><span class="s1">cacheable </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">) {</span>
									<span class="s1">cacheable </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
								<span class="s3">}</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">buildInfo </span><span class="s3">&amp;&amp; </span><span class="s1">module</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">.</span><span class="s1">assets</span><span class="s3">) {</span>
									<span class="s4">const </span><span class="s3">{ </span><span class="s1">assets</span><span class="s3">: </span><span class="s1">moduleAssets</span><span class="s3">, </span><span class="s1">assetsInfo </span><span class="s3">} = </span><span class="s1">module</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">;</span>
									<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">assetName of Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">moduleAssets</span><span class="s3">)) {</span>
										<span class="s1">assets</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">assetName</span><span class="s3">, {</span>
											<span class="s1">source</span><span class="s3">: </span><span class="s1">moduleAssets</span><span class="s3">[</span><span class="s1">assetName</span><span class="s3">],</span>
											<span class="s1">info</span><span class="s3">: </span><span class="s1">assetsInfo </span><span class="s3">? </span><span class="s1">assetsInfo</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">assetName</span><span class="s3">) : </span><span class="s1">undefined</span>
										<span class="s3">});</span>
									<span class="s3">}</span>
								<span class="s3">}</span>
								<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">prepareModuleExecution</span><span class="s3">.</span><span class="s1">callAsync</span><span class="s3">(</span>
									<span class="s1">moduleArgument</span><span class="s3">,</span>
									<span class="s1">context</span><span class="s3">,</span>
									<span class="s1">callback</span>
								<span class="s3">);</span>
							<span class="s3">},</span>
							<span class="s1">err </span><span class="s3">=&gt; {</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) </span><span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>

								<span class="s4">let </span><span class="s1">exports</span><span class="s3">;</span>
								<span class="s4">try </span><span class="s3">{</span>
									<span class="s4">const </span><span class="s3">{</span>
										<span class="s1">strictModuleErrorHandling</span><span class="s3">,</span>
										<span class="s1">strictModuleExceptionHandling</span>
									<span class="s3">} = </span><span class="s4">this</span><span class="s3">.</span><span class="s1">outputOptions</span><span class="s3">;</span>
									<span class="s4">const </span><span class="s1">__webpack_require__ </span><span class="s3">= </span><span class="s1">id </span><span class="s3">=&gt; {</span>
										<span class="s4">const </span><span class="s1">cached </span><span class="s3">= </span><span class="s1">moduleCache</span><span class="s3">[</span><span class="s1">id</span><span class="s3">];</span>
										<span class="s4">if </span><span class="s3">(</span><span class="s1">cached </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
											<span class="s4">if </span><span class="s3">(</span><span class="s1">cached</span><span class="s3">.</span><span class="s1">error</span><span class="s3">) </span><span class="s4">throw </span><span class="s1">cached</span><span class="s3">.</span><span class="s1">error</span><span class="s3">;</span>
											<span class="s4">return </span><span class="s1">cached</span><span class="s3">.</span><span class="s1">exports</span><span class="s3">;</span>
										<span class="s3">}</span>
										<span class="s4">const </span><span class="s1">moduleArgument </span><span class="s3">= </span><span class="s1">moduleArgumentsById</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">id</span><span class="s3">);</span>
										<span class="s4">return </span><span class="s1">__webpack_require_module__</span><span class="s3">(</span><span class="s1">moduleArgument</span><span class="s3">, </span><span class="s1">id</span><span class="s3">);</span>
									<span class="s3">};</span>
									<span class="s4">const </span><span class="s1">interceptModuleExecution </span><span class="s3">= (</span><span class="s1">__webpack_require__</span><span class="s3">[</span>
										<span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">interceptModuleExecution</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span>
											<span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">require</span><span class="s3">}</span><span class="s2">.`</span><span class="s3">,</span>
											<span class="s2">&quot;&quot;</span>
										<span class="s3">)</span>
									<span class="s3">] = []);</span>
									<span class="s4">const </span><span class="s1">moduleCache </span><span class="s3">= (</span><span class="s1">__webpack_require__</span><span class="s3">[</span>
										<span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">moduleCache</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span>
											<span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">require</span><span class="s3">}</span><span class="s2">.`</span><span class="s3">,</span>
											<span class="s2">&quot;&quot;</span>
										<span class="s3">)</span>
									<span class="s3">] = {});</span>

									<span class="s1">context</span><span class="s3">.</span><span class="s1">__webpack_require__ </span><span class="s3">= </span><span class="s1">__webpack_require__</span><span class="s3">;</span>

									<span class="s5">/**</span>
									 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ExecuteModuleArgument} moduleArgument the module argument</span>
									 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string=} id id</span>
									 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{any} exports</span>
									 <span class="s5">*/</span>
									<span class="s4">const </span><span class="s1">__webpack_require_module__ </span><span class="s3">= (</span><span class="s1">moduleArgument</span><span class="s3">, </span><span class="s1">id</span><span class="s3">) =&gt; {</span>
										<span class="s4">var </span><span class="s1">execOptions </span><span class="s3">= {</span>
											<span class="s1">id</span><span class="s3">,</span>
											<span class="s1">module</span><span class="s3">: {</span>
												<span class="s1">id</span><span class="s3">,</span>
												<span class="s1">exports</span><span class="s3">: {},</span>
												<span class="s1">loaded</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
												<span class="s1">error</span><span class="s3">: </span><span class="s1">undefined</span>
											<span class="s3">},</span>
											<span class="s1">require</span><span class="s3">: </span><span class="s1">__webpack_require__</span>
										<span class="s3">};</span>
										<span class="s1">interceptModuleExecution</span><span class="s3">.</span><span class="s1">forEach</span><span class="s3">(</span><span class="s1">handler </span><span class="s3">=&gt;</span>
											<span class="s1">handler</span><span class="s3">(</span><span class="s1">execOptions</span><span class="s3">)</span>
										<span class="s3">);</span>
										<span class="s4">const </span><span class="s1">module </span><span class="s3">= </span><span class="s1">moduleArgument</span><span class="s3">.</span><span class="s1">module</span><span class="s3">;</span>
										<span class="s4">this</span><span class="s3">.</span><span class="s1">buildTimeExecutedModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
										<span class="s4">const </span><span class="s1">moduleObject </span><span class="s3">= </span><span class="s1">execOptions</span><span class="s3">.</span><span class="s1">module</span><span class="s3">;</span>
										<span class="s1">moduleArgument</span><span class="s3">.</span><span class="s1">moduleObject </span><span class="s3">= </span><span class="s1">moduleObject</span><span class="s3">;</span>
										<span class="s4">try </span><span class="s3">{</span>
											<span class="s4">if </span><span class="s3">(</span><span class="s1">id</span><span class="s3">) </span><span class="s1">moduleCache</span><span class="s3">[</span><span class="s1">id</span><span class="s3">] = </span><span class="s1">moduleObject</span><span class="s3">;</span>

											<span class="s1">tryRunOrWebpackError</span><span class="s3">(</span>
												<span class="s3">() =&gt;</span>
													<span class="s4">this</span><span class="s3">.</span><span class="s1">hooks</span><span class="s3">.</span><span class="s1">executeModule</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span>
														<span class="s1">moduleArgument</span><span class="s3">,</span>
														<span class="s1">context</span>
													<span class="s3">),</span>
												<span class="s2">&quot;Compilation.hooks.executeModule&quot;</span>
											<span class="s3">);</span>
											<span class="s1">moduleObject</span><span class="s3">.</span><span class="s1">loaded </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
											<span class="s4">return </span><span class="s1">moduleObject</span><span class="s3">.</span><span class="s1">exports</span><span class="s3">;</span>
										<span class="s3">} </span><span class="s4">catch </span><span class="s3">(</span><span class="s1">e</span><span class="s3">) {</span>
											<span class="s4">if </span><span class="s3">(</span><span class="s1">strictModuleExceptionHandling</span><span class="s3">) {</span>
												<span class="s4">if </span><span class="s3">(</span><span class="s1">id</span><span class="s3">) </span><span class="s4">delete </span><span class="s1">moduleCache</span><span class="s3">[</span><span class="s1">id</span><span class="s3">];</span>
											<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">strictModuleErrorHandling</span><span class="s3">) {</span>
												<span class="s1">moduleObject</span><span class="s3">.</span><span class="s1">error </span><span class="s3">= </span><span class="s1">e</span><span class="s3">;</span>
											<span class="s3">}</span>
											<span class="s4">if </span><span class="s3">(!</span><span class="s1">e</span><span class="s3">.</span><span class="s1">module</span><span class="s3">) </span><span class="s1">e</span><span class="s3">.</span><span class="s1">module </span><span class="s3">= </span><span class="s1">module</span><span class="s3">;</span>
											<span class="s4">throw </span><span class="s1">e</span><span class="s3">;</span>
										<span class="s3">}</span>
									<span class="s3">};</span>

									<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">runtimeModule of chunkGraph</span><span class="s3">.</span><span class="s1">getChunkRuntimeModulesInOrder</span><span class="s3">(</span>
										<span class="s1">chunk</span>
									<span class="s3">)) {</span>
										<span class="s1">__webpack_require_module__</span><span class="s3">(</span>
											<span class="s1">moduleArgumentsMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">runtimeModule</span><span class="s3">)</span>
										<span class="s3">);</span>
									<span class="s3">}</span>
									<span class="s1">exports </span><span class="s3">= </span><span class="s1">__webpack_require__</span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">());</span>
								<span class="s3">} </span><span class="s4">catch </span><span class="s3">(</span><span class="s1">e</span><span class="s3">) {</span>
									<span class="s4">const </span><span class="s1">err </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WebpackError</span><span class="s3">(</span>
										<span class="s2">`Execution of module code from module graph (</span><span class="s1">$</span><span class="s3">{</span><span class="s1">module</span><span class="s3">.</span><span class="s1">readableIdentifier</span><span class="s3">(</span>
											<span class="s4">this</span><span class="s3">.</span><span class="s1">requestShortener</span>
										<span class="s3">)}</span><span class="s2">) failed: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">e</span><span class="s3">.</span><span class="s1">message</span><span class="s3">}</span><span class="s2">`</span>
									<span class="s3">);</span>
									<span class="s1">err</span><span class="s3">.</span><span class="s1">stack </span><span class="s3">= </span><span class="s1">e</span><span class="s3">.</span><span class="s1">stack</span><span class="s3">;</span>
									<span class="s1">err</span><span class="s3">.</span><span class="s1">module </span><span class="s3">= </span><span class="s1">e</span><span class="s3">.</span><span class="s1">module</span><span class="s3">;</span>
									<span class="s4">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">err</span><span class="s3">);</span>
								<span class="s3">}</span>

								<span class="s1">callback</span><span class="s3">(</span><span class="s4">null</span><span class="s3">, {</span>
									<span class="s1">exports</span><span class="s3">,</span>
									<span class="s1">assets</span><span class="s3">,</span>
									<span class="s1">cacheable</span><span class="s3">,</span>
									<span class="s1">fileDependencies</span><span class="s3">,</span>
									<span class="s1">contextDependencies</span><span class="s3">,</span>
									<span class="s1">missingDependencies</span><span class="s3">,</span>
									<span class="s1">buildDependencies</span>
								<span class="s3">});</span>
							<span class="s3">}</span>
						<span class="s3">);</span>
					<span class="s3">});</span>
				<span class="s3">});</span>
			<span class="s3">}</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s1">checkConstraints</span><span class="s3">() {</span>
		<span class="s4">const </span><span class="s1">chunkGraph </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGraph</span><span class="s3">;</span>

		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;number|string&gt;} */</span>
		<span class="s4">const </span><span class="s1">usedIds </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>

		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s1">WEBPACK_MODULE_TYPE_RUNTIME</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
			<span class="s4">const </span><span class="s1">moduleId </span><span class="s3">= </span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getModuleId</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">moduleId </span><span class="s3">=== </span><span class="s4">null</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">usedIds</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">moduleId</span><span class="s3">)) {</span>
				<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span><span class="s2">`checkConstraints: duplicate module id </span><span class="s1">$</span><span class="s3">{</span><span class="s1">moduleId</span><span class="s3">}</span><span class="s2">`</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s1">usedIds</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">moduleId</span><span class="s3">);</span>
		<span class="s3">}</span>

		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">) {</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of chunkGraph</span><span class="s3">.</span><span class="s1">getChunkModulesIterable</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">)) {</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
					<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
						<span class="s2">&quot;checkConstraints: module in chunk but not in compilation &quot; </span><span class="s3">+</span>
							<span class="s2">` </span><span class="s1">$</span><span class="s3">{</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">debugId</span><span class="s3">} </span><span class="s1">$</span><span class="s3">{</span><span class="s1">module</span><span class="s3">.</span><span class="s1">debugId</span><span class="s3">}</span><span class="s2">`</span>
					<span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of chunkGraph</span><span class="s3">.</span><span class="s1">getChunkEntryModulesIterable</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">)) {</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s4">this</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
					<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
						<span class="s2">&quot;checkConstraints: entry module in chunk but not in compilation &quot; </span><span class="s3">+</span>
							<span class="s2">` </span><span class="s1">$</span><span class="s3">{</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">debugId</span><span class="s3">} </span><span class="s1">$</span><span class="s3">{</span><span class="s1">module</span><span class="s3">.</span><span class="s1">debugId</span><span class="s3">}</span><span class="s2">`</span>
					<span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunkGroup of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">chunkGroups</span><span class="s3">) {</span>
			<span class="s1">chunkGroup</span><span class="s3">.</span><span class="s1">checkConstraints</span><span class="s3">();</span>
		<span class="s3">}</span>
	<span class="s3">}</span>
<span class="s3">}</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} FactorizeModuleOptions</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ModuleProfile} currentProfile</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ModuleFactory} factory</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Dependency[]} dependencies</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean=} factoryResult return full ModuleFactoryResult instead of only module</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Module | null} originModule</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Partial&lt;ModuleFactoryCreateDataContextInfo&gt;=} contextInfo</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} context</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{FactorizeModuleOptions} options options object</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleCallback | ModuleFactoryResultCallback} callback callback</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
 <span class="s5">*/</span>

<span class="s0">// Workaround for typescript as it doesn't support function overloading in jsdoc within a class</span>
<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">factorizeModule </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{{</span>
	<span class="s5">(options: FactorizeModuleOptions &amp; { factoryResult?: false }, callback: ModuleCallback): void;</span>
	<span class="s5">(options: FactorizeModuleOptions &amp; { factoryResult: true }, callback: ModuleFactoryResultCallback): void;</span>
<span class="s5">}} */ </span><span class="s3">(</span>
	<span class="s4">function </span><span class="s3">(</span><span class="s1">options</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">factorizeQueue</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">options</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">);</span>
	<span class="s3">}</span>
<span class="s3">);</span>

<span class="s0">// Hide from typescript</span>
<span class="s4">const </span><span class="s1">compilationPrototype </span><span class="s3">= </span><span class="s1">Compilation</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">;</span>

<span class="s0">// TODO webpack 6 remove</span>
<span class="s1">Object</span><span class="s3">.</span><span class="s1">defineProperty</span><span class="s3">(</span><span class="s1">compilationPrototype</span><span class="s3">, </span><span class="s2">&quot;modifyHash&quot;</span><span class="s3">, {</span>
	<span class="s1">writable</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
	<span class="s1">enumerable</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
	<span class="s1">configurable</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
	<span class="s1">value</span><span class="s3">: () =&gt; {</span>
		<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
			<span class="s2">&quot;Compilation.modifyHash was removed in favor of Compilation.hooks.fullHash&quot;</span>
		<span class="s3">);</span>
	<span class="s3">}</span>
<span class="s3">});</span>

<span class="s0">// TODO webpack 6 remove</span>
<span class="s1">Object</span><span class="s3">.</span><span class="s1">defineProperty</span><span class="s3">(</span><span class="s1">compilationPrototype</span><span class="s3">, </span><span class="s2">&quot;cache&quot;</span><span class="s3">, {</span>
	<span class="s1">enumerable</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
	<span class="s1">configurable</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
	<span class="s1">get</span><span class="s3">: </span><span class="s1">util</span><span class="s3">.</span><span class="s1">deprecate</span><span class="s3">(</span>
		<span class="s5">/**</span>
		 <span class="s5">* </span><span class="s6">@this </span><span class="s5">{Compilation} the compilation</span>
		 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Cache} the cache</span>
		 <span class="s5">*/</span>
		<span class="s4">function </span><span class="s3">() {</span>
			<span class="s4">return this</span><span class="s3">.</span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">cache</span><span class="s3">;</span>
		<span class="s3">},</span>
		<span class="s2">&quot;Compilation.cache was removed in favor of Compilation.getCache()&quot;</span><span class="s3">,</span>
		<span class="s2">&quot;DEP_WEBPACK_COMPILATION_CACHE&quot;</span>
	<span class="s3">),</span>
	<span class="s1">set</span><span class="s3">: </span><span class="s1">util</span><span class="s3">.</span><span class="s1">deprecate</span><span class="s3">(</span>
		<span class="s1">v </span><span class="s3">=&gt; {},</span>
		<span class="s2">&quot;Compilation.cache was removed in favor of Compilation.getCache()&quot;</span><span class="s3">,</span>
		<span class="s2">&quot;DEP_WEBPACK_COMPILATION_CACHE&quot;</span>
	<span class="s3">)</span>
<span class="s3">});</span>

<span class="s5">/**</span>
 <span class="s5">* Add additional assets to the compilation.</span>
 <span class="s5">*/</span>
<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_ADDITIONAL </span><span class="s3">= -</span><span class="s7">2000</span><span class="s3">;</span>

<span class="s5">/**</span>
 <span class="s5">* Basic preprocessing of assets.</span>
 <span class="s5">*/</span>
<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_PRE_PROCESS </span><span class="s3">= -</span><span class="s7">1000</span><span class="s3">;</span>

<span class="s5">/**</span>
 <span class="s5">* Derive new assets from existing assets.</span>
 <span class="s5">* Existing assets should not be treated as complete.</span>
 <span class="s5">*/</span>
<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_DERIVED </span><span class="s3">= -</span><span class="s7">200</span><span class="s3">;</span>

<span class="s5">/**</span>
 <span class="s5">* Add additional sections to existing assets, like a banner or initialization code.</span>
 <span class="s5">*/</span>
<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_ADDITIONS </span><span class="s3">= -</span><span class="s7">100</span><span class="s3">;</span>

<span class="s5">/**</span>
 <span class="s5">* Optimize existing assets in a general way.</span>
 <span class="s5">*/</span>
<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_OPTIMIZE </span><span class="s3">= </span><span class="s7">100</span><span class="s3">;</span>

<span class="s5">/**</span>
 <span class="s5">* Optimize the count of existing assets, e. g. by merging them.</span>
 <span class="s5">* Only assets of the same type should be merged.</span>
 <span class="s5">* For assets of different types see PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE.</span>
 <span class="s5">*/</span>
<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT </span><span class="s3">= </span><span class="s7">200</span><span class="s3">;</span>

<span class="s5">/**</span>
 <span class="s5">* Optimize the compatibility of existing assets, e. g. add polyfills or vendor-prefixes.</span>
 <span class="s5">*/</span>
<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY </span><span class="s3">= </span><span class="s7">300</span><span class="s3">;</span>

<span class="s5">/**</span>
 <span class="s5">* Optimize the size of existing assets, e. g. by minimizing or omitting whitespace.</span>
 <span class="s5">*/</span>
<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE </span><span class="s3">= </span><span class="s7">400</span><span class="s3">;</span>

<span class="s5">/**</span>
 <span class="s5">* Add development tooling to assets, e. g. by extracting a SourceMap.</span>
 <span class="s5">*/</span>
<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_DEV_TOOLING </span><span class="s3">= </span><span class="s7">500</span><span class="s3">;</span>

<span class="s5">/**</span>
 <span class="s5">* Optimize the count of existing assets, e. g. by inlining assets of into other assets.</span>
 <span class="s5">* Only assets of different types should be inlined.</span>
 <span class="s5">* For assets of the same type see PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT.</span>
 <span class="s5">*/</span>
<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE </span><span class="s3">= </span><span class="s7">700</span><span class="s3">;</span>

<span class="s5">/**</span>
 <span class="s5">* Summarize the list of existing assets</span>
 <span class="s5">* e. g. creating an assets manifest of Service Workers.</span>
 <span class="s5">*/</span>
<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_SUMMARIZE </span><span class="s3">= </span><span class="s7">1000</span><span class="s3">;</span>

<span class="s5">/**</span>
 <span class="s5">* Optimize the hashes of the assets, e. g. by generating real hashes of the asset content.</span>
 <span class="s5">*/</span>
<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_OPTIMIZE_HASH </span><span class="s3">= </span><span class="s7">2500</span><span class="s3">;</span>

<span class="s5">/**</span>
 <span class="s5">* Optimize the transfer of existing assets, e. g. by preparing a compressed (gzip) file as separate asset.</span>
 <span class="s5">*/</span>
<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER </span><span class="s3">= </span><span class="s7">3000</span><span class="s3">;</span>

<span class="s5">/**</span>
 <span class="s5">* Analyse existing assets.</span>
 <span class="s5">*/</span>
<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_ANALYSE </span><span class="s3">= </span><span class="s7">4000</span><span class="s3">;</span>

<span class="s5">/**</span>
 <span class="s5">* Creating assets for reporting purposes.</span>
 <span class="s5">*/</span>
<span class="s1">Compilation</span><span class="s3">.</span><span class="s1">PROCESS_ASSETS_STAGE_REPORT </span><span class="s3">= </span><span class="s7">5000</span><span class="s3">;</span>

<span class="s1">module</span><span class="s3">.</span><span class="s1">exports </span><span class="s3">= </span><span class="s1">Compilation</span><span class="s3">;</span>
</pre>
</body>
</html>