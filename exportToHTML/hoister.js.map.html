<html>
<head>
<title>hoister.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
hoister.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_t2&quot;</span><span class="s0">,</span><span class="s1">&quot;react&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxExpressionContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;referenceVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isCompatTag&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;breakOnScopePaths&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;binding&quot;</span><span class="s0">,</span><span class="s1">&quot;getBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;violation&quot;</span><span class="s0">,</span><span class="s1">&quot;constantViolations&quot;</span><span class="s0">,</span><span class="s1">&quot;mutableBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;stop&quot;</span><span class="s0">,</span><span class="s1">&quot;bindings&quot;</span><span class="s0">,</span><span class="s1">&quot;PathHoister&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;scopes&quot;</span><span class="s0">,</span><span class="s1">&quot;attachAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;isCompatibleScope&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingIdentifierEquals&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;getCompatibleScopes&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;getAttachmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;_getAttachmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;targetScope&quot;</span><span class="s0">,</span><span class="s1">&quot;isProgram&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;parentKey&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingParentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;getAttachmentParentForPath&quot;</span><span class="s0">,</span><span class="s1">&quot;violationPath&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnParamBindings&quot;</span><span class="s0">,</span><span class="s1">&quot;bodies&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;_blockHoist&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextScopeAttachmentParent&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;container&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;constant&quot;</span><span class="s0">,</span><span class="s1">&quot;run&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;attachTo&quot;</span><span class="s0">,</span><span class="s1">&quot;getFunctionParent&quot;</span><span class="s0">,</span><span class="s1">&quot;uid&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;declarator&quot;</span><span class="s0">,</span><span class="s1">&quot;insertFn&quot;</span><span class="s0">,</span><span class="s1">&quot;attached&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXElement&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/path/lib/hoister.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { react } from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">cloneNode,</span><span class="s3">\n  </span><span class="s1">jsxExpressionContainer,</span><span class="s3">\n  </span><span class="s1">variableDeclaration,</span><span class="s3">\n  </span><span class="s1">variableDeclarator,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type Scope from </span><span class="s3">\&quot;</span><span class="s1">../../scope/index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type NodePath from </span><span class="s3">\&quot;</span><span class="s1">../index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type Binding from </span><span class="s3">\&quot;</span><span class="s1">../../scope/binding.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Visitor } from </span><span class="s3">\&quot;</span><span class="s1">../../types.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const referenceVisitor: Visitor&lt;PathHoister&gt; = {</span><span class="s3">\n  </span><span class="s1">// This visitor looks for bindings to establish a topmost scope for hoisting.</span><span class="s3">\n  </span><span class="s1">ReferencedIdentifier(path, state) {</span><span class="s3">\n    </span><span class="s1">// Don't hoist regular JSX identifiers ('div', 'span', etc).</span><span class="s3">\n    </span><span class="s1">// We do have to consider member expressions for hoisting (e.g. `this.component`)</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">path.isJSXIdentifier() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">react.isCompatTag(path.node.name) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!path.parentPath.isJSXMemberExpression()</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the identifier refers to `this`, we need to break on the closest non-arrow scope.</span><span class="s3">\n    </span><span class="s1">if (path.node.name === </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">let scope = path.scope;</span><span class="s3">\n      </span><span class="s1">do {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">scope.path.isFunction() &amp;&amp;</span><span class="s3">\n          </span><span class="s1">!scope.path.isArrowFunctionExpression()</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} while ((scope = scope.parent));</span><span class="s3">\n      </span><span class="s1">if (scope) state.breakOnScopePaths.push(scope.path);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// direct references that we need to track to hoist this to the highest scope we can</span><span class="s3">\n    </span><span class="s1">const binding = path.scope.getBinding(path.node.name);</span><span class="s3">\n    </span><span class="s1">if (!binding) return;</span><span class="s3">\n\n    </span><span class="s1">// we can handle reassignments only if they happen in the same scope as the declaration</span><span class="s3">\n    </span><span class="s1">for (const violation of binding.constantViolations) {</span><span class="s3">\n      </span><span class="s1">if (violation.scope !== binding.path.scope) {</span><span class="s3">\n        </span><span class="s1">state.mutableBinding = true;</span><span class="s3">\n        </span><span class="s1">path.stop();</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// this binding isn't accessible from the parent scope so we can safely ignore it</span><span class="s3">\n    </span><span class="s1">// eg. it's in a closure etc</span><span class="s3">\n    </span><span class="s1">if (binding !== state.scope.getBinding(path.node.name)) return;</span><span class="s3">\n\n    </span><span class="s1">state.bindings[path.node.name] = binding;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default class PathHoister&lt;T extends t.Node = t.Node&gt; {</span><span class="s3">\n  </span><span class="s1">breakOnScopePaths: NodePath[];</span><span class="s3">\n  </span><span class="s1">bindings: { [k: string]: Binding };</span><span class="s3">\n  </span><span class="s1">mutableBinding: boolean;</span><span class="s3">\n  </span><span class="s1">private scopes: Scope[];</span><span class="s3">\n  </span><span class="s1">scope: Scope;</span><span class="s3">\n  </span><span class="s1">private path: NodePath&lt;T&gt;;</span><span class="s3">\n  </span><span class="s1">private attachAfter: boolean;</span><span class="s3">\n\n  </span><span class="s1">constructor(path: NodePath&lt;T&gt;, scope: Scope) {</span><span class="s3">\n    </span><span class="s1">// Storage for scopes we can't hoist above.</span><span class="s3">\n    </span><span class="s1">this.breakOnScopePaths = [];</span><span class="s3">\n    </span><span class="s1">// Storage for bindings that may affect what path we can hoist to.</span><span class="s3">\n    </span><span class="s1">this.bindings = {};</span><span class="s3">\n    </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot; </span><span class="s1">if the current path contains a reference to a binding whose</span><span class="s3">\n    </span><span class="s1">// value can change and thus can't be safely hoisted.</span><span class="s3">\n    </span><span class="s1">this.mutableBinding = false;</span><span class="s3">\n    </span><span class="s1">// Storage for eligible scopes.</span><span class="s3">\n    </span><span class="s1">this.scopes = [];</span><span class="s3">\n    </span><span class="s1">// Our original scope and path.</span><span class="s3">\n    </span><span class="s1">this.scope = scope;</span><span class="s3">\n    </span><span class="s1">this.path = path;</span><span class="s3">\n    </span><span class="s1">// By default, we attach as far up as we can; but if we're trying</span><span class="s3">\n    </span><span class="s1">// to avoid referencing a binding, we may have to go after.</span><span class="s3">\n    </span><span class="s1">this.attachAfter = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// A scope is compatible if all required bindings are reachable.</span><span class="s3">\n  </span><span class="s1">isCompatibleScope(scope: Scope) {</span><span class="s3">\n    </span><span class="s1">for (const key of Object.keys(this.bindings)) {</span><span class="s3">\n      </span><span class="s1">const binding = this.bindings[key];</span><span class="s3">\n      </span><span class="s1">if (!scope.bindingIdentifierEquals(key, binding.identifier)) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Look through all scopes and push compatible ones.</span><span class="s3">\n  </span><span class="s1">getCompatibleScopes() {</span><span class="s3">\n    </span><span class="s1">let scope = this.path.scope;</span><span class="s3">\n    </span><span class="s1">do {</span><span class="s3">\n      </span><span class="s1">if (this.isCompatibleScope(scope)) {</span><span class="s3">\n        </span><span class="s1">this.scopes.push(scope);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// deopt: These scopes are set in the visitor on const violations</span><span class="s3">\n      </span><span class="s1">if (this.breakOnScopePaths.indexOf(scope.path) &gt;= 0) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} while ((scope = scope.parent));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getAttachmentPath() {</span><span class="s3">\n    </span><span class="s1">let path = this._getAttachmentPath();</span><span class="s3">\n    </span><span class="s1">if (!path) return;</span><span class="s3">\n\n    </span><span class="s1">let targetScope = path.scope;</span><span class="s3">\n\n    </span><span class="s1">// don't allow paths that have their own lexical environments to pollute</span><span class="s3">\n    </span><span class="s1">if (targetScope.path === path) {</span><span class="s3">\n      </span><span class="s1">targetScope = path.scope.parent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// avoid hoisting to a scope that contains bindings that are executed after our attachment path</span><span class="s3">\n    </span><span class="s1">if (targetScope.path.isProgram() || targetScope.path.isFunction()) {</span><span class="s3">\n      </span><span class="s1">for (const name of Object.keys(this.bindings)) {</span><span class="s3">\n        </span><span class="s1">// check binding is a direct child of this paths scope</span><span class="s3">\n        </span><span class="s1">if (!targetScope.hasOwnBinding(name)) continue;</span><span class="s3">\n\n        </span><span class="s1">const binding = this.bindings[name];</span><span class="s3">\n\n        </span><span class="s1">// allow parameter references and expressions in params (like destructuring rest)</span><span class="s3">\n        </span><span class="s1">if (binding.kind === </span><span class="s3">\&quot;</span><span class="s1">param</span><span class="s3">\&quot; </span><span class="s1">|| binding.path.parentKey === </span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// For each binding, get its attachment parent. This gives us an idea of where we might</span><span class="s3">\n        </span><span class="s1">// introduce conflicts.</span><span class="s3">\n        </span><span class="s1">const bindingParentPath = this.getAttachmentParentForPath(binding.path);</span><span class="s3">\n\n        </span><span class="s1">// If the binding's attachment appears at or after our attachment point, then we move after it.</span><span class="s3">\n        </span><span class="s1">if (bindingParentPath.key &gt;= path.key) {</span><span class="s3">\n          </span><span class="s1">this.attachAfter = true;</span><span class="s3">\n          </span><span class="s1">path = binding.path;</span><span class="s3">\n\n          </span><span class="s1">// We also move past any constant violations.</span><span class="s3">\n          </span><span class="s1">for (const violationPath of binding.constantViolations) {</span><span class="s3">\n            </span><span class="s1">if (this.getAttachmentParentForPath(violationPath).key &gt; path.key) {</span><span class="s3">\n              </span><span class="s1">path = violationPath;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return path;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_getAttachmentPath() {</span><span class="s3">\n    </span><span class="s1">const scopes = this.scopes;</span><span class="s3">\n\n    </span><span class="s1">const scope = scopes.pop();</span><span class="s3">\n    </span><span class="s1">// deopt: no compatible scopes</span><span class="s3">\n    </span><span class="s1">if (!scope) return;</span><span class="s3">\n\n    </span><span class="s1">if (scope.path.isFunction()) {</span><span class="s3">\n      </span><span class="s1">if (this.hasOwnParamBindings(scope)) {</span><span class="s3">\n        </span><span class="s1">// deopt: should ignore this scope since it's ourselves</span><span class="s3">\n        </span><span class="s1">if (this.scope === scope) return;</span><span class="s3">\n\n        </span><span class="s1">// needs to be attached to the body</span><span class="s3">\n        </span><span class="s1">const bodies = scope.path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">) as NodePath[];</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; bodies.length; i++) {</span><span class="s3">\n          </span><span class="s1">// Don't attach to something that's going to get hoisted,</span><span class="s3">\n          </span><span class="s1">// like a default parameter</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): avoid mutating the node, introducing new fields</span><span class="s3">\n          </span><span class="s1">if (bodies[i].node._blockHoist) continue;</span><span class="s3">\n          </span><span class="s1">return bodies[i];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// deopt: If here, no attachment path found</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// doesn't need to be be attached to this scope</span><span class="s3">\n        </span><span class="s1">return this.getNextScopeAttachmentParent();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (scope.path.isProgram()) {</span><span class="s3">\n      </span><span class="s1">return this.getNextScopeAttachmentParent();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getNextScopeAttachmentParent() {</span><span class="s3">\n    </span><span class="s1">const scope = this.scopes.pop();</span><span class="s3">\n    </span><span class="s1">if (scope) return this.getAttachmentParentForPath(scope.path);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Find an attachment for this path.</span><span class="s3">\n  </span><span class="s1">getAttachmentParentForPath(path: NodePath) {</span><span class="s3">\n    </span><span class="s1">do {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">// Beginning of the scope</span><span class="s3">\n        </span><span class="s1">!path.parentPath ||</span><span class="s3">\n        </span><span class="s1">// Has siblings and is a statement</span><span class="s3">\n        </span><span class="s1">(Array.isArray(path.container) &amp;&amp; path.isStatement())</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return path;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} while ((path = path.parentPath));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Returns true if a scope has param bindings.</span><span class="s3">\n  </span><span class="s1">hasOwnParamBindings(scope: Scope) {</span><span class="s3">\n    </span><span class="s1">for (const name of Object.keys(this.bindings)) {</span><span class="s3">\n      </span><span class="s1">if (!scope.hasOwnBinding(name)) continue;</span><span class="s3">\n\n      </span><span class="s1">const binding = this.bindings[name];</span><span class="s3">\n      </span><span class="s1">// Ensure constant; without it we could place behind a reassignment</span><span class="s3">\n      </span><span class="s1">if (binding.kind === </span><span class="s3">\&quot;</span><span class="s1">param</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; binding.constant) return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">run(): NodePath&lt;t.Expression&gt; | undefined {</span><span class="s3">\n    </span><span class="s1">this.path.traverse(referenceVisitor, this);</span><span class="s3">\n\n    </span><span class="s1">if (this.mutableBinding) return;</span><span class="s3">\n\n    </span><span class="s1">this.getCompatibleScopes();</span><span class="s3">\n\n    </span><span class="s1">const attachTo = this.getAttachmentPath();</span><span class="s3">\n    </span><span class="s1">if (!attachTo) return;</span><span class="s3">\n\n    </span><span class="s1">// don't bother hoisting to the same function as this will cause multiple branches to be</span><span class="s3">\n    </span><span class="s1">// evaluated more than once leading to a bad optimisation</span><span class="s3">\n    </span><span class="s1">if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;</span><span class="s3">\n\n    </span><span class="s1">// generate declaration and insert it to our point</span><span class="s3">\n    </span><span class="s1">let uid: t.Identifier | t.JSXExpressionContainer =</span><span class="s3">\n      </span><span class="s1">attachTo.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">ref</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): more specific type for this.path</span><span class="s3">\n    </span><span class="s1">const declarator = variableDeclarator(uid, this.path.node);</span><span class="s3">\n\n    </span><span class="s1">const insertFn = this.attachAfter ? </span><span class="s3">\&quot;</span><span class="s1">insertAfter</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">insertBefore</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">const [attached] = attachTo[insertFn]([</span><span class="s3">\n      </span><span class="s1">attachTo.isVariableDeclarator()</span><span class="s3">\n        </span><span class="s1">? declarator</span><span class="s3">\n        </span><span class="s1">: variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">, [declarator]),</span><span class="s3">\n    </span><span class="s1">]);</span><span class="s3">\n\n    </span><span class="s1">const parent = this.path.parentPath;</span><span class="s3">\n    </span><span class="s1">if (parent.isJSXElement() &amp;&amp; this.path.container === parent.node.children) {</span><span class="s3">\n      </span><span class="s1">// turning the `span` in `&lt;div&gt;&lt;span /&gt;&lt;/div&gt;` to an expression so we need to wrap it with</span><span class="s3">\n      </span><span class="s1">// an expression container</span><span class="s3">\n      </span><span class="s1">uid = jsxExpressionContainer(uid);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.path.replaceWith(cloneNode(uid));</span><span class="s3">\n\n    </span><span class="s1">return attachTo.isVariableDeclarator()</span><span class="s3">\n      </span><span class="s1">? attached.get(</span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">: attached.get(</span><span class="s3">\&quot;</span><span class="s1">declarations.0.init</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>