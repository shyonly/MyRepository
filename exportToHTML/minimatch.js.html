<html>
<head>
<title>minimatch.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #6aab73;}
.s4 { color: #7a7e85;}
.s5 { color: #42c3d4;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
minimatch.js</font>
</center></td></tr></table>
<pre><span class="s0">module</span><span class="s1">.</span><span class="s0">exports </span><span class="s1">= </span><span class="s0">minimatch</span>
<span class="s0">minimatch</span><span class="s1">.</span><span class="s0">Minimatch </span><span class="s1">= </span><span class="s0">Minimatch</span>

<span class="s2">var </span><span class="s0">path </span><span class="s1">= (</span><span class="s2">function </span><span class="s1">() { </span><span class="s2">try </span><span class="s1">{ </span><span class="s2">return </span><span class="s0">require</span><span class="s1">(</span><span class="s3">'path'</span><span class="s1">) } </span><span class="s2">catch </span><span class="s1">(</span><span class="s0">e</span><span class="s1">) {}}()) || {</span>
  <span class="s0">sep</span><span class="s1">: </span><span class="s3">'/'</span>
<span class="s1">}</span>
<span class="s0">minimatch</span><span class="s1">.</span><span class="s0">sep </span><span class="s1">= </span><span class="s0">path</span><span class="s1">.</span><span class="s0">sep</span>

<span class="s2">var </span><span class="s0">GLOBSTAR </span><span class="s1">= </span><span class="s0">minimatch</span><span class="s1">.</span><span class="s0">GLOBSTAR </span><span class="s1">= </span><span class="s0">Minimatch</span><span class="s1">.</span><span class="s0">GLOBSTAR </span><span class="s1">= {}</span>
<span class="s2">var </span><span class="s0">expand </span><span class="s1">= </span><span class="s0">require</span><span class="s1">(</span><span class="s3">'brace-expansion'</span><span class="s1">)</span>

<span class="s2">var </span><span class="s0">plTypes </span><span class="s1">= {</span>
  <span class="s3">'!'</span><span class="s1">: { </span><span class="s0">open</span><span class="s1">: </span><span class="s3">'(?:(?!(?:'</span><span class="s1">, </span><span class="s0">close</span><span class="s1">: </span><span class="s3">'))[^/]*?)'</span><span class="s1">},</span>
  <span class="s3">'?'</span><span class="s1">: { </span><span class="s0">open</span><span class="s1">: </span><span class="s3">'(?:'</span><span class="s1">, </span><span class="s0">close</span><span class="s1">: </span><span class="s3">')?' </span><span class="s1">},</span>
  <span class="s3">'+'</span><span class="s1">: { </span><span class="s0">open</span><span class="s1">: </span><span class="s3">'(?:'</span><span class="s1">, </span><span class="s0">close</span><span class="s1">: </span><span class="s3">')+' </span><span class="s1">},</span>
  <span class="s3">'*'</span><span class="s1">: { </span><span class="s0">open</span><span class="s1">: </span><span class="s3">'(?:'</span><span class="s1">, </span><span class="s0">close</span><span class="s1">: </span><span class="s3">')*' </span><span class="s1">},</span>
  <span class="s3">'@'</span><span class="s1">: { </span><span class="s0">open</span><span class="s1">: </span><span class="s3">'(?:'</span><span class="s1">, </span><span class="s0">close</span><span class="s1">: </span><span class="s3">')' </span><span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">// any single thing other than /</span>
<span class="s4">// don't need to escape / when using new RegExp()</span>
<span class="s2">var </span><span class="s0">qmark </span><span class="s1">= </span><span class="s3">'[^/]'</span>

<span class="s4">// * =&gt; any number of characters</span>
<span class="s2">var </span><span class="s0">star </span><span class="s1">= </span><span class="s0">qmark </span><span class="s1">+ </span><span class="s3">'*?'</span>

<span class="s4">// ** when dots are allowed.  Anything goes, except .. and .</span>
<span class="s4">// not (^ or / followed by one or two dots followed by $ or /),</span>
<span class="s4">// followed by anything, any number of times.</span>
<span class="s2">var </span><span class="s0">twoStarDot </span><span class="s1">= </span><span class="s3">'(?:(?!(?:</span><span class="s2">\\\/</span><span class="s3">|^)(?:</span><span class="s2">\\</span><span class="s3">.{1,2})($|</span><span class="s2">\\\/</span><span class="s3">)).)*?'</span>

<span class="s4">// not a ^ or / followed by a dot,</span>
<span class="s4">// followed by anything, any number of times.</span>
<span class="s2">var </span><span class="s0">twoStarNoDot </span><span class="s1">= </span><span class="s3">'(?:(?!(?:</span><span class="s2">\\\/</span><span class="s3">|^)</span><span class="s2">\\</span><span class="s3">.).)*?'</span>

<span class="s4">// characters that need to be escaped in RegExp.</span>
<span class="s2">var </span><span class="s0">reSpecials </span><span class="s1">= </span><span class="s0">charSet</span><span class="s1">(</span><span class="s3">'().*{}+?[]^$</span><span class="s2">\\</span><span class="s3">!'</span><span class="s1">)</span>

<span class="s4">// &quot;abc&quot; -&gt; { a:true, b:true, c:true }</span>
<span class="s2">function </span><span class="s0">charSet </span><span class="s1">(</span><span class="s0">s</span><span class="s1">) {</span>
  <span class="s2">return </span><span class="s0">s</span><span class="s1">.</span><span class="s0">split</span><span class="s1">(</span><span class="s3">''</span><span class="s1">).</span><span class="s0">reduce</span><span class="s1">(</span><span class="s2">function </span><span class="s1">(</span><span class="s0">set</span><span class="s1">, </span><span class="s0">c</span><span class="s1">) {</span>
    <span class="s0">set</span><span class="s1">[</span><span class="s0">c</span><span class="s1">] = </span><span class="s2">true</span>
    <span class="s2">return </span><span class="s0">set</span>
  <span class="s1">}, {})</span>
<span class="s1">}</span>

<span class="s4">// normalizes slashes.</span>
<span class="s2">var </span><span class="s0">slashSplit </span><span class="s1">= </span><span class="s5">/\/+/</span>

<span class="s0">minimatch</span><span class="s1">.</span><span class="s0">filter </span><span class="s1">= </span><span class="s0">filter</span>
<span class="s2">function </span><span class="s0">filter </span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">) {</span>
  <span class="s0">options </span><span class="s1">= </span><span class="s0">options </span><span class="s1">|| {}</span>
  <span class="s2">return function </span><span class="s1">(</span><span class="s0">p</span><span class="s1">, </span><span class="s0">i</span><span class="s1">, </span><span class="s0">list</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">minimatch</span><span class="s1">(</span><span class="s0">p</span><span class="s1">, </span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">)</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s0">ext </span><span class="s1">(</span><span class="s0">a</span><span class="s1">, </span><span class="s0">b</span><span class="s1">) {</span>
  <span class="s0">b </span><span class="s1">= </span><span class="s0">b </span><span class="s1">|| {}</span>
  <span class="s2">var </span><span class="s0">t </span><span class="s1">= {}</span>
  <span class="s0">Object</span><span class="s1">.</span><span class="s0">keys</span><span class="s1">(</span><span class="s0">a</span><span class="s1">).</span><span class="s0">forEach</span><span class="s1">(</span><span class="s2">function </span><span class="s1">(</span><span class="s0">k</span><span class="s1">) {</span>
    <span class="s0">t</span><span class="s1">[</span><span class="s0">k</span><span class="s1">] = </span><span class="s0">a</span><span class="s1">[</span><span class="s0">k</span><span class="s1">]</span>
  <span class="s1">})</span>
  <span class="s0">Object</span><span class="s1">.</span><span class="s0">keys</span><span class="s1">(</span><span class="s0">b</span><span class="s1">).</span><span class="s0">forEach</span><span class="s1">(</span><span class="s2">function </span><span class="s1">(</span><span class="s0">k</span><span class="s1">) {</span>
    <span class="s0">t</span><span class="s1">[</span><span class="s0">k</span><span class="s1">] = </span><span class="s0">b</span><span class="s1">[</span><span class="s0">k</span><span class="s1">]</span>
  <span class="s1">})</span>
  <span class="s2">return </span><span class="s0">t</span>
<span class="s1">}</span>

<span class="s0">minimatch</span><span class="s1">.</span><span class="s0">defaults </span><span class="s1">= </span><span class="s2">function </span><span class="s1">(</span><span class="s0">def</span><span class="s1">) {</span>
  <span class="s2">if </span><span class="s1">(!</span><span class="s0">def </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s0">def </span><span class="s1">!== </span><span class="s3">'object' </span><span class="s1">|| !</span><span class="s0">Object</span><span class="s1">.</span><span class="s0">keys</span><span class="s1">(</span><span class="s0">def</span><span class="s1">).</span><span class="s0">length</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">minimatch</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s0">orig </span><span class="s1">= </span><span class="s0">minimatch</span>

  <span class="s2">var </span><span class="s0">m </span><span class="s1">= </span><span class="s2">function </span><span class="s0">minimatch </span><span class="s1">(</span><span class="s0">p</span><span class="s1">, </span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">orig</span><span class="s1">(</span><span class="s0">p</span><span class="s1">, </span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">ext</span><span class="s1">(</span><span class="s0">def</span><span class="s1">, </span><span class="s0">options</span><span class="s1">))</span>
  <span class="s1">}</span>

  <span class="s0">m</span><span class="s1">.</span><span class="s0">Minimatch </span><span class="s1">= </span><span class="s2">function </span><span class="s0">Minimatch </span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">) {</span>
    <span class="s2">return new </span><span class="s0">orig</span><span class="s1">.</span><span class="s0">Minimatch</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">ext</span><span class="s1">(</span><span class="s0">def</span><span class="s1">, </span><span class="s0">options</span><span class="s1">))</span>
  <span class="s1">}</span>
  <span class="s0">m</span><span class="s1">.</span><span class="s0">Minimatch</span><span class="s1">.</span><span class="s0">defaults </span><span class="s1">= </span><span class="s2">function </span><span class="s0">defaults </span><span class="s1">(</span><span class="s0">options</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">orig</span><span class="s1">.</span><span class="s0">defaults</span><span class="s1">(</span><span class="s0">ext</span><span class="s1">(</span><span class="s0">def</span><span class="s1">, </span><span class="s0">options</span><span class="s1">)).</span><span class="s0">Minimatch</span>
  <span class="s1">}</span>

  <span class="s0">m</span><span class="s1">.</span><span class="s0">filter </span><span class="s1">= </span><span class="s2">function </span><span class="s0">filter </span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">orig</span><span class="s1">.</span><span class="s0">filter</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">ext</span><span class="s1">(</span><span class="s0">def</span><span class="s1">, </span><span class="s0">options</span><span class="s1">))</span>
  <span class="s1">}</span>

  <span class="s0">m</span><span class="s1">.</span><span class="s0">defaults </span><span class="s1">= </span><span class="s2">function </span><span class="s0">defaults </span><span class="s1">(</span><span class="s0">options</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">orig</span><span class="s1">.</span><span class="s0">defaults</span><span class="s1">(</span><span class="s0">ext</span><span class="s1">(</span><span class="s0">def</span><span class="s1">, </span><span class="s0">options</span><span class="s1">))</span>
  <span class="s1">}</span>

  <span class="s0">m</span><span class="s1">.</span><span class="s0">makeRe </span><span class="s1">= </span><span class="s2">function </span><span class="s0">makeRe </span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">orig</span><span class="s1">.</span><span class="s0">makeRe</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">ext</span><span class="s1">(</span><span class="s0">def</span><span class="s1">, </span><span class="s0">options</span><span class="s1">))</span>
  <span class="s1">}</span>

  <span class="s0">m</span><span class="s1">.</span><span class="s0">braceExpand </span><span class="s1">= </span><span class="s2">function </span><span class="s0">braceExpand </span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">orig</span><span class="s1">.</span><span class="s0">braceExpand</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">ext</span><span class="s1">(</span><span class="s0">def</span><span class="s1">, </span><span class="s0">options</span><span class="s1">))</span>
  <span class="s1">}</span>

  <span class="s0">m</span><span class="s1">.</span><span class="s0">match </span><span class="s1">= </span><span class="s2">function </span><span class="s1">(</span><span class="s0">list</span><span class="s1">, </span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">orig</span><span class="s1">.</span><span class="s0">match</span><span class="s1">(</span><span class="s0">list</span><span class="s1">, </span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">ext</span><span class="s1">(</span><span class="s0">def</span><span class="s1">, </span><span class="s0">options</span><span class="s1">))</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s0">m</span>
<span class="s1">}</span>

<span class="s0">Minimatch</span><span class="s1">.</span><span class="s0">defaults </span><span class="s1">= </span><span class="s2">function </span><span class="s1">(</span><span class="s0">def</span><span class="s1">) {</span>
  <span class="s2">return </span><span class="s0">minimatch</span><span class="s1">.</span><span class="s0">defaults</span><span class="s1">(</span><span class="s0">def</span><span class="s1">).</span><span class="s0">Minimatch</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s0">minimatch </span><span class="s1">(</span><span class="s0">p</span><span class="s1">, </span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">) {</span>
  <span class="s0">assertValidPattern</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">)</span>

  <span class="s2">if </span><span class="s1">(!</span><span class="s0">options</span><span class="s1">) </span><span class="s0">options </span><span class="s1">= {}</span>

  <span class="s4">// shortcut: comments match nothing.</span>
  <span class="s2">if </span><span class="s1">(!</span><span class="s0">options</span><span class="s1">.</span><span class="s0">nocomment </span><span class="s1">&amp;&amp; </span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">charAt</span><span class="s1">(</span><span class="s6">0</span><span class="s1">) === </span><span class="s3">'#'</span><span class="s1">) {</span>
    <span class="s2">return false</span>
  <span class="s1">}</span>

  <span class="s2">return new </span><span class="s0">Minimatch</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">).</span><span class="s0">match</span><span class="s1">(</span><span class="s0">p</span><span class="s1">)</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s0">Minimatch </span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">) {</span>
  <span class="s2">if </span><span class="s1">(!(</span><span class="s2">this instanceof </span><span class="s0">Minimatch</span><span class="s1">)) {</span>
    <span class="s2">return new </span><span class="s0">Minimatch</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s0">assertValidPattern</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">)</span>

  <span class="s2">if </span><span class="s1">(!</span><span class="s0">options</span><span class="s1">) </span><span class="s0">options </span><span class="s1">= {}</span>

  <span class="s0">pattern </span><span class="s1">= </span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">trim</span><span class="s1">()</span>

  <span class="s4">// windows support: need to use /, not \</span>
  <span class="s2">if </span><span class="s1">(!</span><span class="s0">options</span><span class="s1">.</span><span class="s0">allowWindowsEscape </span><span class="s1">&amp;&amp; </span><span class="s0">path</span><span class="s1">.</span><span class="s0">sep </span><span class="s1">!== </span><span class="s3">'/'</span><span class="s1">) {</span>
    <span class="s0">pattern </span><span class="s1">= </span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">split</span><span class="s1">(</span><span class="s0">path</span><span class="s1">.</span><span class="s0">sep</span><span class="s1">).</span><span class="s0">join</span><span class="s1">(</span><span class="s3">'/'</span><span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s2">this</span><span class="s1">.</span><span class="s0">options </span><span class="s1">= </span><span class="s0">options</span>
  <span class="s2">this</span><span class="s1">.</span><span class="s0">set </span><span class="s1">= []</span>
  <span class="s2">this</span><span class="s1">.</span><span class="s0">pattern </span><span class="s1">= </span><span class="s0">pattern</span>
  <span class="s2">this</span><span class="s1">.</span><span class="s0">regexp </span><span class="s1">= </span><span class="s2">null</span>
  <span class="s2">this</span><span class="s1">.</span><span class="s0">negate </span><span class="s1">= </span><span class="s2">false</span>
  <span class="s2">this</span><span class="s1">.</span><span class="s0">comment </span><span class="s1">= </span><span class="s2">false</span>
  <span class="s2">this</span><span class="s1">.</span><span class="s0">empty </span><span class="s1">= </span><span class="s2">false</span>
  <span class="s2">this</span><span class="s1">.</span><span class="s0">partial </span><span class="s1">= !!</span><span class="s0">options</span><span class="s1">.</span><span class="s0">partial</span>

  <span class="s4">// make the set of regexps etc.</span>
  <span class="s2">this</span><span class="s1">.</span><span class="s0">make</span><span class="s1">()</span>
<span class="s1">}</span>

<span class="s0">Minimatch</span><span class="s1">.</span><span class="s0">prototype</span><span class="s1">.</span><span class="s0">debug </span><span class="s1">= </span><span class="s2">function </span><span class="s1">() {}</span>

<span class="s0">Minimatch</span><span class="s1">.</span><span class="s0">prototype</span><span class="s1">.</span><span class="s0">make </span><span class="s1">= </span><span class="s0">make</span>
<span class="s2">function </span><span class="s0">make </span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s0">pattern </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">pattern</span>
  <span class="s2">var </span><span class="s0">options </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">options</span>

  <span class="s4">// empty patterns and comments match nothing.</span>
  <span class="s2">if </span><span class="s1">(!</span><span class="s0">options</span><span class="s1">.</span><span class="s0">nocomment </span><span class="s1">&amp;&amp; </span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">charAt</span><span class="s1">(</span><span class="s6">0</span><span class="s1">) === </span><span class="s3">'#'</span><span class="s1">) {</span>
    <span class="s2">this</span><span class="s1">.</span><span class="s0">comment </span><span class="s1">= </span><span class="s2">true</span>
    <span class="s2">return</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!</span><span class="s0">pattern</span><span class="s1">) {</span>
    <span class="s2">this</span><span class="s1">.</span><span class="s0">empty </span><span class="s1">= </span><span class="s2">true</span>
    <span class="s2">return</span>
  <span class="s1">}</span>

  <span class="s4">// step 1: figure out negation, etc.</span>
  <span class="s2">this</span><span class="s1">.</span><span class="s0">parseNegate</span><span class="s1">()</span>

  <span class="s4">// step 2: expand braces</span>
  <span class="s2">var </span><span class="s0">set </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">globSet </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">braceExpand</span><span class="s1">()</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s0">options</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">) </span><span class="s2">this</span><span class="s1">.</span><span class="s0">debug </span><span class="s1">= </span><span class="s2">function </span><span class="s0">debug</span><span class="s1">() { </span><span class="s0">console</span><span class="s1">.</span><span class="s0">error</span><span class="s1">.</span><span class="s0">apply</span><span class="s1">(</span><span class="s0">console</span><span class="s1">, </span><span class="s0">arguments</span><span class="s1">) }</span>

  <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">set</span><span class="s1">)</span>

  <span class="s4">// step 3: now we have a set, so turn each one into a series of path-portion</span>
  <span class="s4">// matching patterns.</span>
  <span class="s4">// These will be regexps, except in the case of &quot;**&quot;, which is</span>
  <span class="s4">// set to the GLOBSTAR object for globstar behavior,</span>
  <span class="s4">// and will not contain any / characters</span>
  <span class="s0">set </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">globParts </span><span class="s1">= </span><span class="s0">set</span><span class="s1">.</span><span class="s0">map</span><span class="s1">(</span><span class="s2">function </span><span class="s1">(</span><span class="s0">s</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">s</span><span class="s1">.</span><span class="s0">split</span><span class="s1">(</span><span class="s0">slashSplit</span><span class="s1">)</span>
  <span class="s1">})</span>

  <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">set</span><span class="s1">)</span>

  <span class="s4">// glob --&gt; regexps</span>
  <span class="s0">set </span><span class="s1">= </span><span class="s0">set</span><span class="s1">.</span><span class="s0">map</span><span class="s1">(</span><span class="s2">function </span><span class="s1">(</span><span class="s0">s</span><span class="s1">, </span><span class="s0">si</span><span class="s1">, </span><span class="s0">set</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">s</span><span class="s1">.</span><span class="s0">map</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s0">parse</span><span class="s1">, </span><span class="s2">this</span><span class="s1">)</span>
  <span class="s1">}, </span><span class="s2">this</span><span class="s1">)</span>

  <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">set</span><span class="s1">)</span>

  <span class="s4">// filter out everything that didn't compile properly.</span>
  <span class="s0">set </span><span class="s1">= </span><span class="s0">set</span><span class="s1">.</span><span class="s0">filter</span><span class="s1">(</span><span class="s2">function </span><span class="s1">(</span><span class="s0">s</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">s</span><span class="s1">.</span><span class="s0">indexOf</span><span class="s1">(</span><span class="s2">false</span><span class="s1">) === -</span><span class="s6">1</span>
  <span class="s1">})</span>

  <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">set</span><span class="s1">)</span>

  <span class="s2">this</span><span class="s1">.</span><span class="s0">set </span><span class="s1">= </span><span class="s0">set</span>
<span class="s1">}</span>

<span class="s0">Minimatch</span><span class="s1">.</span><span class="s0">prototype</span><span class="s1">.</span><span class="s0">parseNegate </span><span class="s1">= </span><span class="s0">parseNegate</span>
<span class="s2">function </span><span class="s0">parseNegate </span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s0">pattern </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">pattern</span>
  <span class="s2">var </span><span class="s0">negate </span><span class="s1">= </span><span class="s2">false</span>
  <span class="s2">var </span><span class="s0">options </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">options</span>
  <span class="s2">var </span><span class="s0">negateOffset </span><span class="s1">= </span><span class="s6">0</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s0">options</span><span class="s1">.</span><span class="s0">nonegate</span><span class="s1">) </span><span class="s2">return</span>

  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s0">i </span><span class="s1">= </span><span class="s6">0</span><span class="s1">, </span><span class="s0">l </span><span class="s1">= </span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">length</span>
    <span class="s1">; </span><span class="s0">i </span><span class="s1">&lt; </span><span class="s0">l </span><span class="s1">&amp;&amp; </span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">charAt</span><span class="s1">(</span><span class="s0">i</span><span class="s1">) === </span><span class="s3">'!'</span>
    <span class="s1">; </span><span class="s0">i</span><span class="s1">++) {</span>
    <span class="s0">negate </span><span class="s1">= !</span><span class="s0">negate</span>
    <span class="s0">negateOffset</span><span class="s1">++</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s0">negateOffset</span><span class="s1">) </span><span class="s2">this</span><span class="s1">.</span><span class="s0">pattern </span><span class="s1">= </span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">substr</span><span class="s1">(</span><span class="s0">negateOffset</span><span class="s1">)</span>
  <span class="s2">this</span><span class="s1">.</span><span class="s0">negate </span><span class="s1">= </span><span class="s0">negate</span>
<span class="s1">}</span>

<span class="s4">// Brace expansion:</span>
<span class="s4">// a{b,c}d -&gt; abd acd</span>
<span class="s4">// a{b,}c -&gt; abc ac</span>
<span class="s4">// a{0..3}d -&gt; a0d a1d a2d a3d</span>
<span class="s4">// a{b,c{d,e}f}g -&gt; abg acdfg acefg</span>
<span class="s4">// a{b,c}d{e,f}g -&gt; abdeg acdeg abdeg abdfg</span>
<span class="s4">//</span>
<span class="s4">// Invalid sets are not expanded.</span>
<span class="s4">// a{2..}b -&gt; a{2..}b</span>
<span class="s4">// a{b}c -&gt; a{b}c</span>
<span class="s0">minimatch</span><span class="s1">.</span><span class="s0">braceExpand </span><span class="s1">= </span><span class="s2">function </span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">) {</span>
  <span class="s2">return </span><span class="s0">braceExpand</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">)</span>
<span class="s1">}</span>

<span class="s0">Minimatch</span><span class="s1">.</span><span class="s0">prototype</span><span class="s1">.</span><span class="s0">braceExpand </span><span class="s1">= </span><span class="s0">braceExpand</span>

<span class="s2">function </span><span class="s0">braceExpand </span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">) {</span>
  <span class="s2">if </span><span class="s1">(!</span><span class="s0">options</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this instanceof </span><span class="s0">Minimatch</span><span class="s1">) {</span>
      <span class="s0">options </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">options</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">options </span><span class="s1">= {}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">pattern </span><span class="s1">= </span><span class="s2">typeof </span><span class="s0">pattern </span><span class="s1">=== </span><span class="s3">'undefined'</span>
    <span class="s1">? </span><span class="s2">this</span><span class="s1">.</span><span class="s0">pattern </span><span class="s1">: </span><span class="s0">pattern</span>

  <span class="s0">assertValidPattern</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">)</span>

  <span class="s4">// Thanks to Yeting Li &lt;https://github.com/yetingli&gt; for</span>
  <span class="s4">// improving this regexp to avoid a ReDOS vulnerability.</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s0">options</span><span class="s1">.</span><span class="s0">nobrace </span><span class="s1">|| !</span><span class="s5">/\{(?:(?!\{).)*\}/</span><span class="s1">.</span><span class="s0">test</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">)) {</span>
    <span class="s4">// shortcut. no need to expand.</span>
    <span class="s2">return </span><span class="s1">[</span><span class="s0">pattern</span><span class="s1">]</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s0">expand</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">)</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s0">MAX_PATTERN_LENGTH </span><span class="s1">= </span><span class="s6">1024 </span><span class="s1">* </span><span class="s6">64</span>
<span class="s2">var </span><span class="s0">assertValidPattern </span><span class="s1">= </span><span class="s2">function </span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s0">pattern </span><span class="s1">!== </span><span class="s3">'string'</span><span class="s1">) {</span>
    <span class="s2">throw new </span><span class="s0">TypeError</span><span class="s1">(</span><span class="s3">'invalid pattern'</span><span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">length </span><span class="s1">&gt; </span><span class="s0">MAX_PATTERN_LENGTH</span><span class="s1">) {</span>
    <span class="s2">throw new </span><span class="s0">TypeError</span><span class="s1">(</span><span class="s3">'pattern is too long'</span><span class="s1">)</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">// parse a component of the expanded set.</span>
<span class="s4">// At this point, no pattern may contain &quot;/&quot; in it</span>
<span class="s4">// so we're going to return a 2d array, where each entry is the full</span>
<span class="s4">// pattern, split on '/', and then turned into a regular expression.</span>
<span class="s4">// A regexp is made at the end which joins each array with an</span>
<span class="s4">// escaped /, and another full one which joins each regexp with |.</span>
<span class="s4">//</span>
<span class="s4">// Following the lead of Bash 4.1, note that &quot;**&quot; only has special meaning</span>
<span class="s4">// when it is the *only* thing in a path portion.  Otherwise, any series</span>
<span class="s4">// of * is equivalent to a single *.  Globstar behavior is enabled by</span>
<span class="s4">// default, and can be disabled by setting options.noglobstar.</span>
<span class="s0">Minimatch</span><span class="s1">.</span><span class="s0">prototype</span><span class="s1">.</span><span class="s0">parse </span><span class="s1">= </span><span class="s0">parse</span>
<span class="s2">var </span><span class="s0">SUBPARSE </span><span class="s1">= {}</span>
<span class="s2">function </span><span class="s0">parse </span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">isSub</span><span class="s1">) {</span>
  <span class="s0">assertValidPattern</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">)</span>

  <span class="s2">var </span><span class="s0">options </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">options</span>

  <span class="s4">// shortcuts</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s0">pattern </span><span class="s1">=== </span><span class="s3">'**'</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s0">options</span><span class="s1">.</span><span class="s0">noglobstar</span><span class="s1">)</span>
      <span class="s2">return </span><span class="s0">GLOBSTAR</span>
    <span class="s2">else</span>
      <span class="s0">pattern </span><span class="s1">= </span><span class="s3">'*'</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s0">pattern </span><span class="s1">=== </span><span class="s3">''</span><span class="s1">) </span><span class="s2">return </span><span class="s3">''</span>

  <span class="s2">var </span><span class="s0">re </span><span class="s1">= </span><span class="s3">''</span>
  <span class="s2">var </span><span class="s0">hasMagic </span><span class="s1">= !!</span><span class="s0">options</span><span class="s1">.</span><span class="s0">nocase</span>
  <span class="s2">var </span><span class="s0">escaping </span><span class="s1">= </span><span class="s2">false</span>
  <span class="s4">// ? =&gt; one single character</span>
  <span class="s2">var </span><span class="s0">patternListStack </span><span class="s1">= []</span>
  <span class="s2">var </span><span class="s0">negativeLists </span><span class="s1">= []</span>
  <span class="s2">var </span><span class="s0">stateChar</span>
  <span class="s2">var </span><span class="s0">inClass </span><span class="s1">= </span><span class="s2">false</span>
  <span class="s2">var </span><span class="s0">reClassStart </span><span class="s1">= -</span><span class="s6">1</span>
  <span class="s2">var </span><span class="s0">classStart </span><span class="s1">= -</span><span class="s6">1</span>
  <span class="s4">// . and .. never match anything that doesn't start with .,</span>
  <span class="s4">// even when options.dot is set.</span>
  <span class="s2">var </span><span class="s0">patternStart </span><span class="s1">= </span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">charAt</span><span class="s1">(</span><span class="s6">0</span><span class="s1">) === </span><span class="s3">'.' </span><span class="s1">? </span><span class="s3">'' </span><span class="s4">// anything</span>
  <span class="s4">// not (start or / followed by . or .. followed by / or end)</span>
  <span class="s1">: </span><span class="s0">options</span><span class="s1">.</span><span class="s0">dot </span><span class="s1">? </span><span class="s3">'(?!(?:^|</span><span class="s2">\\\/</span><span class="s3">)</span><span class="s2">\\</span><span class="s3">.{1,2}(?:$|</span><span class="s2">\\\/</span><span class="s3">))'</span>
  <span class="s1">: </span><span class="s3">'(?!</span><span class="s2">\\</span><span class="s3">.)'</span>
  <span class="s2">var </span><span class="s0">self </span><span class="s1">= </span><span class="s2">this</span>

  <span class="s2">function </span><span class="s0">clearStateChar </span><span class="s1">() {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s0">stateChar</span><span class="s1">) {</span>
      <span class="s4">// we had some state-tracking character</span>
      <span class="s4">// that wasn't consumed by this pass.</span>
      <span class="s2">switch </span><span class="s1">(</span><span class="s0">stateChar</span><span class="s1">) {</span>
        <span class="s2">case </span><span class="s3">'*'</span><span class="s1">:</span>
          <span class="s0">re </span><span class="s1">+= </span><span class="s0">star</span>
          <span class="s0">hasMagic </span><span class="s1">= </span><span class="s2">true</span>
        <span class="s2">break</span>
        <span class="s2">case </span><span class="s3">'?'</span><span class="s1">:</span>
          <span class="s0">re </span><span class="s1">+= </span><span class="s0">qmark</span>
          <span class="s0">hasMagic </span><span class="s1">= </span><span class="s2">true</span>
        <span class="s2">break</span>
        <span class="s2">default</span><span class="s1">:</span>
          <span class="s0">re </span><span class="s1">+= </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">' </span><span class="s1">+ </span><span class="s0">stateChar</span>
        <span class="s2">break</span>
      <span class="s1">}</span>
      <span class="s0">self</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'clearStateChar %j %j'</span><span class="s1">, </span><span class="s0">stateChar</span><span class="s1">, </span><span class="s0">re</span><span class="s1">)</span>
      <span class="s0">stateChar </span><span class="s1">= </span><span class="s2">false</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s0">i </span><span class="s1">= </span><span class="s6">0</span><span class="s1">, </span><span class="s0">len </span><span class="s1">= </span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">length</span><span class="s1">, </span><span class="s0">c</span>
    <span class="s1">; (</span><span class="s0">i </span><span class="s1">&lt; </span><span class="s0">len</span><span class="s1">) &amp;&amp; (</span><span class="s0">c </span><span class="s1">= </span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">charAt</span><span class="s1">(</span><span class="s0">i</span><span class="s1">))</span>
    <span class="s1">; </span><span class="s0">i</span><span class="s1">++) {</span>
    <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'%s</span><span class="s2">\t</span><span class="s3">%s %s %j'</span><span class="s1">, </span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">i</span><span class="s1">, </span><span class="s0">re</span><span class="s1">, </span><span class="s0">c</span><span class="s1">)</span>

    <span class="s4">// skip over any that are escaped.</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s0">escaping </span><span class="s1">&amp;&amp; </span><span class="s0">reSpecials</span><span class="s1">[</span><span class="s0">c</span><span class="s1">]) {</span>
      <span class="s0">re </span><span class="s1">+= </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">' </span><span class="s1">+ </span><span class="s0">c</span>
      <span class="s0">escaping </span><span class="s1">= </span><span class="s2">false</span>
      <span class="s2">continue</span>
    <span class="s1">}</span>

    <span class="s2">switch </span><span class="s1">(</span><span class="s0">c</span><span class="s1">) {</span>
      <span class="s4">/* istanbul ignore next */</span>
      <span class="s2">case </span><span class="s3">'/'</span><span class="s1">: {</span>
        <span class="s4">// completely not allowed, even escaped.</span>
        <span class="s4">// Should already be path-split by now.</span>
        <span class="s2">return false</span>
      <span class="s1">}</span>

      <span class="s2">case </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s1">:</span>
        <span class="s0">clearStateChar</span><span class="s1">()</span>
        <span class="s0">escaping </span><span class="s1">= </span><span class="s2">true</span>
      <span class="s2">continue</span>

      <span class="s4">// the various stateChar values</span>
      <span class="s4">// for the &quot;extglob&quot; stuff.</span>
      <span class="s2">case </span><span class="s3">'?'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s3">'*'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s3">'+'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s3">'@'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s3">'!'</span><span class="s1">:</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'%s</span><span class="s2">\t</span><span class="s3">%s %s %j &lt;-- stateChar'</span><span class="s1">, </span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">i</span><span class="s1">, </span><span class="s0">re</span><span class="s1">, </span><span class="s0">c</span><span class="s1">)</span>

        <span class="s4">// all of those are literals inside a class, except that</span>
        <span class="s4">// the glob [!a] means [^a] in regexp</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">inClass</span><span class="s1">) {</span>
          <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'  in class'</span><span class="s1">)</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s0">c </span><span class="s1">=== </span><span class="s3">'!' </span><span class="s1">&amp;&amp; </span><span class="s0">i </span><span class="s1">=== </span><span class="s0">classStart </span><span class="s1">+ </span><span class="s6">1</span><span class="s1">) </span><span class="s0">c </span><span class="s1">= </span><span class="s3">'^'</span>
          <span class="s0">re </span><span class="s1">+= </span><span class="s0">c</span>
          <span class="s2">continue</span>
        <span class="s1">}</span>

        <span class="s4">// if we already have a stateChar, then it means</span>
        <span class="s4">// that there was something like ** or +? in there.</span>
        <span class="s4">// Handle the stateChar, then proceed with this one.</span>
        <span class="s0">self</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'call clearStateChar %j'</span><span class="s1">, </span><span class="s0">stateChar</span><span class="s1">)</span>
        <span class="s0">clearStateChar</span><span class="s1">()</span>
        <span class="s0">stateChar </span><span class="s1">= </span><span class="s0">c</span>
        <span class="s4">// if extglob is disabled, then +(asdf|foo) isn't a thing.</span>
        <span class="s4">// just clear the statechar *now*, rather than even diving into</span>
        <span class="s4">// the patternList stuff.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">options</span><span class="s1">.</span><span class="s0">noext</span><span class="s1">) </span><span class="s0">clearStateChar</span><span class="s1">()</span>
      <span class="s2">continue</span>

      <span class="s2">case </span><span class="s3">'('</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">inClass</span><span class="s1">) {</span>
          <span class="s0">re </span><span class="s1">+= </span><span class="s3">'('</span>
          <span class="s2">continue</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(!</span><span class="s0">stateChar</span><span class="s1">) {</span>
          <span class="s0">re </span><span class="s1">+= </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">('</span>
          <span class="s2">continue</span>
        <span class="s1">}</span>

        <span class="s0">patternListStack</span><span class="s1">.</span><span class="s0">push</span><span class="s1">({</span>
          <span class="s0">type</span><span class="s1">: </span><span class="s0">stateChar</span><span class="s1">,</span>
          <span class="s0">start</span><span class="s1">: </span><span class="s0">i </span><span class="s1">- </span><span class="s6">1</span><span class="s1">,</span>
          <span class="s0">reStart</span><span class="s1">: </span><span class="s0">re</span><span class="s1">.</span><span class="s0">length</span><span class="s1">,</span>
          <span class="s0">open</span><span class="s1">: </span><span class="s0">plTypes</span><span class="s1">[</span><span class="s0">stateChar</span><span class="s1">].</span><span class="s0">open</span><span class="s1">,</span>
          <span class="s0">close</span><span class="s1">: </span><span class="s0">plTypes</span><span class="s1">[</span><span class="s0">stateChar</span><span class="s1">].</span><span class="s0">close</span>
        <span class="s1">})</span>
        <span class="s4">// negation is (?:(?!js)[^/]*)</span>
        <span class="s0">re </span><span class="s1">+= </span><span class="s0">stateChar </span><span class="s1">=== </span><span class="s3">'!' </span><span class="s1">? </span><span class="s3">'(?:(?!(?:' </span><span class="s1">: </span><span class="s3">'(?:'</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'plType %j %j'</span><span class="s1">, </span><span class="s0">stateChar</span><span class="s1">, </span><span class="s0">re</span><span class="s1">)</span>
        <span class="s0">stateChar </span><span class="s1">= </span><span class="s2">false</span>
      <span class="s2">continue</span>

      <span class="s2">case </span><span class="s3">')'</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">inClass </span><span class="s1">|| !</span><span class="s0">patternListStack</span><span class="s1">.</span><span class="s0">length</span><span class="s1">) {</span>
          <span class="s0">re </span><span class="s1">+= </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">)'</span>
          <span class="s2">continue</span>
        <span class="s1">}</span>

        <span class="s0">clearStateChar</span><span class="s1">()</span>
        <span class="s0">hasMagic </span><span class="s1">= </span><span class="s2">true</span>
        <span class="s2">var </span><span class="s0">pl </span><span class="s1">= </span><span class="s0">patternListStack</span><span class="s1">.</span><span class="s0">pop</span><span class="s1">()</span>
        <span class="s4">// negation is (?:(?!js)[^/]*)</span>
        <span class="s4">// The others are (?:&lt;pattern&gt;)&lt;type&gt;</span>
        <span class="s0">re </span><span class="s1">+= </span><span class="s0">pl</span><span class="s1">.</span><span class="s0">close</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">pl</span><span class="s1">.</span><span class="s0">type </span><span class="s1">=== </span><span class="s3">'!'</span><span class="s1">) {</span>
          <span class="s0">negativeLists</span><span class="s1">.</span><span class="s0">push</span><span class="s1">(</span><span class="s0">pl</span><span class="s1">)</span>
        <span class="s1">}</span>
        <span class="s0">pl</span><span class="s1">.</span><span class="s0">reEnd </span><span class="s1">= </span><span class="s0">re</span><span class="s1">.</span><span class="s0">length</span>
      <span class="s2">continue</span>

      <span class="s2">case </span><span class="s3">'|'</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">inClass </span><span class="s1">|| !</span><span class="s0">patternListStack</span><span class="s1">.</span><span class="s0">length </span><span class="s1">|| </span><span class="s0">escaping</span><span class="s1">) {</span>
          <span class="s0">re </span><span class="s1">+= </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">|'</span>
          <span class="s0">escaping </span><span class="s1">= </span><span class="s2">false</span>
          <span class="s2">continue</span>
        <span class="s1">}</span>

        <span class="s0">clearStateChar</span><span class="s1">()</span>
        <span class="s0">re </span><span class="s1">+= </span><span class="s3">'|'</span>
      <span class="s2">continue</span>

      <span class="s4">// these are mostly the same in regexp and glob</span>
      <span class="s2">case </span><span class="s3">'['</span><span class="s1">:</span>
        <span class="s4">// swallow any state-tracking char before the [</span>
        <span class="s0">clearStateChar</span><span class="s1">()</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s0">inClass</span><span class="s1">) {</span>
          <span class="s0">re </span><span class="s1">+= </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">' </span><span class="s1">+ </span><span class="s0">c</span>
          <span class="s2">continue</span>
        <span class="s1">}</span>

        <span class="s0">inClass </span><span class="s1">= </span><span class="s2">true</span>
        <span class="s0">classStart </span><span class="s1">= </span><span class="s0">i</span>
        <span class="s0">reClassStart </span><span class="s1">= </span><span class="s0">re</span><span class="s1">.</span><span class="s0">length</span>
        <span class="s0">re </span><span class="s1">+= </span><span class="s0">c</span>
      <span class="s2">continue</span>

      <span class="s2">case </span><span class="s3">']'</span><span class="s1">:</span>
        <span class="s4">//  a right bracket shall lose its special</span>
        <span class="s4">//  meaning and represent itself in</span>
        <span class="s4">//  a bracket expression if it occurs</span>
        <span class="s4">//  first in the list.  -- POSIX.2 2.8.3.2</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">i </span><span class="s1">=== </span><span class="s0">classStart </span><span class="s1">+ </span><span class="s6">1 </span><span class="s1">|| !</span><span class="s0">inClass</span><span class="s1">) {</span>
          <span class="s0">re </span><span class="s1">+= </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">' </span><span class="s1">+ </span><span class="s0">c</span>
          <span class="s0">escaping </span><span class="s1">= </span><span class="s2">false</span>
          <span class="s2">continue</span>
        <span class="s1">}</span>

        <span class="s4">// handle the case where we left a class open.</span>
        <span class="s4">// &quot;[z-a]&quot; is valid, equivalent to &quot;\[z-a\]&quot;</span>
        <span class="s4">// split where the last [ was, make sure we don't have</span>
        <span class="s4">// an invalid re. if so, re-walk the contents of the</span>
        <span class="s4">// would-be class to re-translate any characters that</span>
        <span class="s4">// were passed through as-is</span>
        <span class="s4">// TODO: It would probably be faster to determine this</span>
        <span class="s4">// without a try/catch and a new RegExp, but it's tricky</span>
        <span class="s4">// to do safely.  For now, this is safe and works.</span>
        <span class="s2">var </span><span class="s0">cs </span><span class="s1">= </span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">substring</span><span class="s1">(</span><span class="s0">classStart </span><span class="s1">+ </span><span class="s6">1</span><span class="s1">, </span><span class="s0">i</span><span class="s1">)</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s0">RegExp</span><span class="s1">(</span><span class="s3">'[' </span><span class="s1">+ </span><span class="s0">cs </span><span class="s1">+ </span><span class="s3">']'</span><span class="s1">)</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(</span><span class="s0">er</span><span class="s1">) {</span>
          <span class="s4">// not a valid class!</span>
          <span class="s2">var </span><span class="s0">sp </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">parse</span><span class="s1">(</span><span class="s0">cs</span><span class="s1">, </span><span class="s0">SUBPARSE</span><span class="s1">)</span>
          <span class="s0">re </span><span class="s1">= </span><span class="s0">re</span><span class="s1">.</span><span class="s0">substr</span><span class="s1">(</span><span class="s6">0</span><span class="s1">, </span><span class="s0">reClassStart</span><span class="s1">) + </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">[' </span><span class="s1">+ </span><span class="s0">sp</span><span class="s1">[</span><span class="s6">0</span><span class="s1">] + </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">]'</span>
          <span class="s0">hasMagic </span><span class="s1">= </span><span class="s0">hasMagic </span><span class="s1">|| </span><span class="s0">sp</span><span class="s1">[</span><span class="s6">1</span><span class="s1">]</span>
          <span class="s0">inClass </span><span class="s1">= </span><span class="s2">false</span>
          <span class="s2">continue</span>
        <span class="s1">}</span>

        <span class="s4">// finish up the class.</span>
        <span class="s0">hasMagic </span><span class="s1">= </span><span class="s2">true</span>
        <span class="s0">inClass </span><span class="s1">= </span><span class="s2">false</span>
        <span class="s0">re </span><span class="s1">+= </span><span class="s0">c</span>
      <span class="s2">continue</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s4">// swallow any state char that wasn't consumed</span>
        <span class="s0">clearStateChar</span><span class="s1">()</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s0">escaping</span><span class="s1">) {</span>
          <span class="s4">// no need</span>
          <span class="s0">escaping </span><span class="s1">= </span><span class="s2">false</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s0">reSpecials</span><span class="s1">[</span><span class="s0">c</span><span class="s1">]</span>
          <span class="s1">&amp;&amp; !(</span><span class="s0">c </span><span class="s1">=== </span><span class="s3">'^' </span><span class="s1">&amp;&amp; </span><span class="s0">inClass</span><span class="s1">)) {</span>
          <span class="s0">re </span><span class="s1">+= </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span>
        <span class="s1">}</span>

        <span class="s0">re </span><span class="s1">+= </span><span class="s0">c</span>

    <span class="s1">} </span><span class="s4">// switch</span>
  <span class="s1">} </span><span class="s4">// for</span>

  <span class="s4">// handle the case where we left a class open.</span>
  <span class="s4">// &quot;[abc&quot; is valid, equivalent to &quot;\[abc&quot;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s0">inClass</span><span class="s1">) {</span>
    <span class="s4">// split where the last [ was, and escape it</span>
    <span class="s4">// this is a huge pita.  We now have to re-walk</span>
    <span class="s4">// the contents of the would-be class to re-translate</span>
    <span class="s4">// any characters that were passed through as-is</span>
    <span class="s0">cs </span><span class="s1">= </span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">substr</span><span class="s1">(</span><span class="s0">classStart </span><span class="s1">+ </span><span class="s6">1</span><span class="s1">)</span>
    <span class="s0">sp </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">parse</span><span class="s1">(</span><span class="s0">cs</span><span class="s1">, </span><span class="s0">SUBPARSE</span><span class="s1">)</span>
    <span class="s0">re </span><span class="s1">= </span><span class="s0">re</span><span class="s1">.</span><span class="s0">substr</span><span class="s1">(</span><span class="s6">0</span><span class="s1">, </span><span class="s0">reClassStart</span><span class="s1">) + </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">[' </span><span class="s1">+ </span><span class="s0">sp</span><span class="s1">[</span><span class="s6">0</span><span class="s1">]</span>
    <span class="s0">hasMagic </span><span class="s1">= </span><span class="s0">hasMagic </span><span class="s1">|| </span><span class="s0">sp</span><span class="s1">[</span><span class="s6">1</span><span class="s1">]</span>
  <span class="s1">}</span>

  <span class="s4">// handle the case where we had a +( thing at the *end*</span>
  <span class="s4">// of the pattern.</span>
  <span class="s4">// each pattern list stack adds 3 chars, and we need to go through</span>
  <span class="s4">// and escape any | chars that were passed through as-is for the regexp.</span>
  <span class="s4">// Go through and escape them, taking care not to double-escape any</span>
  <span class="s4">// | chars that were already escaped.</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s0">pl </span><span class="s1">= </span><span class="s0">patternListStack</span><span class="s1">.</span><span class="s0">pop</span><span class="s1">(); </span><span class="s0">pl</span><span class="s1">; </span><span class="s0">pl </span><span class="s1">= </span><span class="s0">patternListStack</span><span class="s1">.</span><span class="s0">pop</span><span class="s1">()) {</span>
    <span class="s2">var </span><span class="s0">tail </span><span class="s1">= </span><span class="s0">re</span><span class="s1">.</span><span class="s0">slice</span><span class="s1">(</span><span class="s0">pl</span><span class="s1">.</span><span class="s0">reStart </span><span class="s1">+ </span><span class="s0">pl</span><span class="s1">.</span><span class="s0">open</span><span class="s1">.</span><span class="s0">length</span><span class="s1">)</span>
    <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'setting tail'</span><span class="s1">, </span><span class="s0">re</span><span class="s1">, </span><span class="s0">pl</span><span class="s1">)</span>
    <span class="s4">// maybe some even number of \, then maybe 1 \, followed by a |</span>
    <span class="s0">tail </span><span class="s1">= </span><span class="s0">tail</span><span class="s1">.</span><span class="s0">replace</span><span class="s1">(</span><span class="s5">/((?:\\{2}){0,64})(\\?)\|/g</span><span class="s1">, </span><span class="s2">function </span><span class="s1">(</span><span class="s0">_</span><span class="s1">, </span><span class="s0">$1</span><span class="s1">, </span><span class="s0">$2</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(!</span><span class="s0">$2</span><span class="s1">) {</span>
        <span class="s4">// the | isn't already escaped, so escape it.</span>
        <span class="s0">$2 </span><span class="s1">= </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span>
      <span class="s1">}</span>

      <span class="s4">// need to escape all those slashes *again*, without escaping the</span>
      <span class="s4">// one that we need for escaping the | character.  As it works out,</span>
      <span class="s4">// escaping an even number of slashes can be done by simply repeating</span>
      <span class="s4">// it exactly after itself.  That's why this trick works.</span>
      <span class="s4">//</span>
      <span class="s4">// I am sorry that you have to see this.</span>
      <span class="s2">return </span><span class="s0">$1 </span><span class="s1">+ </span><span class="s0">$1 </span><span class="s1">+ </span><span class="s0">$2 </span><span class="s1">+ </span><span class="s3">'|'</span>
    <span class="s1">})</span>

    <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'tail=%j</span><span class="s2">\n   </span><span class="s3">%s'</span><span class="s1">, </span><span class="s0">tail</span><span class="s1">, </span><span class="s0">tail</span><span class="s1">, </span><span class="s0">pl</span><span class="s1">, </span><span class="s0">re</span><span class="s1">)</span>
    <span class="s2">var </span><span class="s0">t </span><span class="s1">= </span><span class="s0">pl</span><span class="s1">.</span><span class="s0">type </span><span class="s1">=== </span><span class="s3">'*' </span><span class="s1">? </span><span class="s0">star</span>
      <span class="s1">: </span><span class="s0">pl</span><span class="s1">.</span><span class="s0">type </span><span class="s1">=== </span><span class="s3">'?' </span><span class="s1">? </span><span class="s0">qmark</span>
      <span class="s1">: </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">' </span><span class="s1">+ </span><span class="s0">pl</span><span class="s1">.</span><span class="s0">type</span>

    <span class="s0">hasMagic </span><span class="s1">= </span><span class="s2">true</span>
    <span class="s0">re </span><span class="s1">= </span><span class="s0">re</span><span class="s1">.</span><span class="s0">slice</span><span class="s1">(</span><span class="s6">0</span><span class="s1">, </span><span class="s0">pl</span><span class="s1">.</span><span class="s0">reStart</span><span class="s1">) + </span><span class="s0">t </span><span class="s1">+ </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">(' </span><span class="s1">+ </span><span class="s0">tail</span>
  <span class="s1">}</span>

  <span class="s4">// handle trailing things that only matter at the very end.</span>
  <span class="s0">clearStateChar</span><span class="s1">()</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s0">escaping</span><span class="s1">) {</span>
    <span class="s4">// trailing \\</span>
    <span class="s0">re </span><span class="s1">+= </span><span class="s3">'</span><span class="s2">\\\\</span><span class="s3">'</span>
  <span class="s1">}</span>

  <span class="s4">// only need to apply the nodot start if the re starts with</span>
  <span class="s4">// something that could conceivably capture a dot</span>
  <span class="s2">var </span><span class="s0">addPatternStart </span><span class="s1">= </span><span class="s2">false</span>
  <span class="s2">switch </span><span class="s1">(</span><span class="s0">re</span><span class="s1">.</span><span class="s0">charAt</span><span class="s1">(</span><span class="s6">0</span><span class="s1">)) {</span>
    <span class="s2">case </span><span class="s3">'['</span><span class="s1">: </span><span class="s2">case </span><span class="s3">'.'</span><span class="s1">: </span><span class="s2">case </span><span class="s3">'('</span><span class="s1">: </span><span class="s0">addPatternStart </span><span class="s1">= </span><span class="s2">true</span>
  <span class="s1">}</span>

  <span class="s4">// Hack to work around lack of negative lookbehind in JS</span>
  <span class="s4">// A pattern like: *.!(x).!(y|z) needs to ensure that a name</span>
  <span class="s4">// like 'a.xyz.yz' doesn't match.  So, the first negative</span>
  <span class="s4">// lookahead, has to look ALL the way ahead, to the end of</span>
  <span class="s4">// the pattern.</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s0">n </span><span class="s1">= </span><span class="s0">negativeLists</span><span class="s1">.</span><span class="s0">length </span><span class="s1">- </span><span class="s6">1</span><span class="s1">; </span><span class="s0">n </span><span class="s1">&gt; -</span><span class="s6">1</span><span class="s1">; </span><span class="s0">n</span><span class="s1">--) {</span>
    <span class="s2">var </span><span class="s0">nl </span><span class="s1">= </span><span class="s0">negativeLists</span><span class="s1">[</span><span class="s0">n</span><span class="s1">]</span>

    <span class="s2">var </span><span class="s0">nlBefore </span><span class="s1">= </span><span class="s0">re</span><span class="s1">.</span><span class="s0">slice</span><span class="s1">(</span><span class="s6">0</span><span class="s1">, </span><span class="s0">nl</span><span class="s1">.</span><span class="s0">reStart</span><span class="s1">)</span>
    <span class="s2">var </span><span class="s0">nlFirst </span><span class="s1">= </span><span class="s0">re</span><span class="s1">.</span><span class="s0">slice</span><span class="s1">(</span><span class="s0">nl</span><span class="s1">.</span><span class="s0">reStart</span><span class="s1">, </span><span class="s0">nl</span><span class="s1">.</span><span class="s0">reEnd </span><span class="s1">- </span><span class="s6">8</span><span class="s1">)</span>
    <span class="s2">var </span><span class="s0">nlLast </span><span class="s1">= </span><span class="s0">re</span><span class="s1">.</span><span class="s0">slice</span><span class="s1">(</span><span class="s0">nl</span><span class="s1">.</span><span class="s0">reEnd </span><span class="s1">- </span><span class="s6">8</span><span class="s1">, </span><span class="s0">nl</span><span class="s1">.</span><span class="s0">reEnd</span><span class="s1">)</span>
    <span class="s2">var </span><span class="s0">nlAfter </span><span class="s1">= </span><span class="s0">re</span><span class="s1">.</span><span class="s0">slice</span><span class="s1">(</span><span class="s0">nl</span><span class="s1">.</span><span class="s0">reEnd</span><span class="s1">)</span>

    <span class="s0">nlLast </span><span class="s1">+= </span><span class="s0">nlAfter</span>

    <span class="s4">// Handle nested stuff like *(*.js|!(*.json)), where open parens</span>
    <span class="s4">// mean that we should *not* include the ) in the bit that is considered</span>
    <span class="s4">// &quot;after&quot; the negated section.</span>
    <span class="s2">var </span><span class="s0">openParensBefore </span><span class="s1">= </span><span class="s0">nlBefore</span><span class="s1">.</span><span class="s0">split</span><span class="s1">(</span><span class="s3">'('</span><span class="s1">).</span><span class="s0">length </span><span class="s1">- </span><span class="s6">1</span>
    <span class="s2">var </span><span class="s0">cleanAfter </span><span class="s1">= </span><span class="s0">nlAfter</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s0">i </span><span class="s1">= </span><span class="s6">0</span><span class="s1">; </span><span class="s0">i </span><span class="s1">&lt; </span><span class="s0">openParensBefore</span><span class="s1">; </span><span class="s0">i</span><span class="s1">++) {</span>
      <span class="s0">cleanAfter </span><span class="s1">= </span><span class="s0">cleanAfter</span><span class="s1">.</span><span class="s0">replace</span><span class="s1">(</span><span class="s5">/\)[+*?]?/</span><span class="s1">, </span><span class="s3">''</span><span class="s1">)</span>
    <span class="s1">}</span>
    <span class="s0">nlAfter </span><span class="s1">= </span><span class="s0">cleanAfter</span>

    <span class="s2">var </span><span class="s0">dollar </span><span class="s1">= </span><span class="s3">''</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s0">nlAfter </span><span class="s1">=== </span><span class="s3">'' </span><span class="s1">&amp;&amp; </span><span class="s0">isSub </span><span class="s1">!== </span><span class="s0">SUBPARSE</span><span class="s1">) {</span>
      <span class="s0">dollar </span><span class="s1">= </span><span class="s3">'$'</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s0">newRe </span><span class="s1">= </span><span class="s0">nlBefore </span><span class="s1">+ </span><span class="s0">nlFirst </span><span class="s1">+ </span><span class="s0">nlAfter </span><span class="s1">+ </span><span class="s0">dollar </span><span class="s1">+ </span><span class="s0">nlLast</span>
    <span class="s0">re </span><span class="s1">= </span><span class="s0">newRe</span>
  <span class="s1">}</span>

  <span class="s4">// if the re is not &quot;&quot; at this point, then we need to make sure</span>
  <span class="s4">// it doesn't match against an empty path part.</span>
  <span class="s4">// Otherwise a/* will match a/, which it should not.</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s0">re </span><span class="s1">!== </span><span class="s3">'' </span><span class="s1">&amp;&amp; </span><span class="s0">hasMagic</span><span class="s1">) {</span>
    <span class="s0">re </span><span class="s1">= </span><span class="s3">'(?=.)' </span><span class="s1">+ </span><span class="s0">re</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s0">addPatternStart</span><span class="s1">) {</span>
    <span class="s0">re </span><span class="s1">= </span><span class="s0">patternStart </span><span class="s1">+ </span><span class="s0">re</span>
  <span class="s1">}</span>

  <span class="s4">// parsing just a piece of a larger pattern.</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s0">isSub </span><span class="s1">=== </span><span class="s0">SUBPARSE</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">[</span><span class="s0">re</span><span class="s1">, </span><span class="s0">hasMagic</span><span class="s1">]</span>
  <span class="s1">}</span>

  <span class="s4">// skip the regexp for non-magical patterns</span>
  <span class="s4">// unescape anything in it, though, so that it'll be</span>
  <span class="s4">// an exact match against a file etc.</span>
  <span class="s2">if </span><span class="s1">(!</span><span class="s0">hasMagic</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">globUnescape</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s0">flags </span><span class="s1">= </span><span class="s0">options</span><span class="s1">.</span><span class="s0">nocase </span><span class="s1">? </span><span class="s3">'i' </span><span class="s1">: </span><span class="s3">''</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s2">var </span><span class="s0">regExp </span><span class="s1">= </span><span class="s2">new </span><span class="s0">RegExp</span><span class="s1">(</span><span class="s3">'^' </span><span class="s1">+ </span><span class="s0">re </span><span class="s1">+ </span><span class="s3">'$'</span><span class="s1">, </span><span class="s0">flags</span><span class="s1">)</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(</span><span class="s0">er</span><span class="s1">) </span><span class="s4">/* istanbul ignore next - should be impossible */ </span><span class="s1">{</span>
    <span class="s4">// If it was an invalid regular expression, then it can't match</span>
    <span class="s4">// anything.  This trick looks for a character after the end of</span>
    <span class="s4">// the string, which is of course impossible, except in multi-line</span>
    <span class="s4">// mode, but it's not a /m regex.</span>
    <span class="s2">return new </span><span class="s0">RegExp</span><span class="s1">(</span><span class="s3">'$.'</span><span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s0">regExp</span><span class="s1">.</span><span class="s0">_glob </span><span class="s1">= </span><span class="s0">pattern</span>
  <span class="s0">regExp</span><span class="s1">.</span><span class="s0">_src </span><span class="s1">= </span><span class="s0">re</span>

  <span class="s2">return </span><span class="s0">regExp</span>
<span class="s1">}</span>

<span class="s0">minimatch</span><span class="s1">.</span><span class="s0">makeRe </span><span class="s1">= </span><span class="s2">function </span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">) {</span>
  <span class="s2">return new </span><span class="s0">Minimatch</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options </span><span class="s1">|| {}).</span><span class="s0">makeRe</span><span class="s1">()</span>
<span class="s1">}</span>

<span class="s0">Minimatch</span><span class="s1">.</span><span class="s0">prototype</span><span class="s1">.</span><span class="s0">makeRe </span><span class="s1">= </span><span class="s0">makeRe</span>
<span class="s2">function </span><span class="s0">makeRe </span><span class="s1">() {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s0">regexp </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.</span><span class="s0">regexp </span><span class="s1">=== </span><span class="s2">false</span><span class="s1">) </span><span class="s2">return this</span><span class="s1">.</span><span class="s0">regexp</span>

  <span class="s4">// at this point, this.set is a 2d array of partial</span>
  <span class="s4">// pattern strings, or &quot;**&quot;.</span>
  <span class="s4">//</span>
  <span class="s4">// It's better to use .match().  This function shouldn't</span>
  <span class="s4">// be used, really, but it's pretty convenient sometimes,</span>
  <span class="s4">// when you just want to work with a regex.</span>
  <span class="s2">var </span><span class="s0">set </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">set</span>

  <span class="s2">if </span><span class="s1">(!</span><span class="s0">set</span><span class="s1">.</span><span class="s0">length</span><span class="s1">) {</span>
    <span class="s2">this</span><span class="s1">.</span><span class="s0">regexp </span><span class="s1">= </span><span class="s2">false</span>
    <span class="s2">return this</span><span class="s1">.</span><span class="s0">regexp</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s0">options </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">options</span>

  <span class="s2">var </span><span class="s0">twoStar </span><span class="s1">= </span><span class="s0">options</span><span class="s1">.</span><span class="s0">noglobstar </span><span class="s1">? </span><span class="s0">star</span>
    <span class="s1">: </span><span class="s0">options</span><span class="s1">.</span><span class="s0">dot </span><span class="s1">? </span><span class="s0">twoStarDot</span>
    <span class="s1">: </span><span class="s0">twoStarNoDot</span>
  <span class="s2">var </span><span class="s0">flags </span><span class="s1">= </span><span class="s0">options</span><span class="s1">.</span><span class="s0">nocase </span><span class="s1">? </span><span class="s3">'i' </span><span class="s1">: </span><span class="s3">''</span>

  <span class="s2">var </span><span class="s0">re </span><span class="s1">= </span><span class="s0">set</span><span class="s1">.</span><span class="s0">map</span><span class="s1">(</span><span class="s2">function </span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">map</span><span class="s1">(</span><span class="s2">function </span><span class="s1">(</span><span class="s0">p</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">(</span><span class="s0">p </span><span class="s1">=== </span><span class="s0">GLOBSTAR</span><span class="s1">) ? </span><span class="s0">twoStar</span>
      <span class="s1">: (</span><span class="s2">typeof </span><span class="s0">p </span><span class="s1">=== </span><span class="s3">'string'</span><span class="s1">) ? </span><span class="s0">regExpEscape</span><span class="s1">(</span><span class="s0">p</span><span class="s1">)</span>
      <span class="s1">: </span><span class="s0">p</span><span class="s1">.</span><span class="s0">_src</span>
    <span class="s1">}).</span><span class="s0">join</span><span class="s1">(</span><span class="s3">'</span><span class="s2">\\\/</span><span class="s3">'</span><span class="s1">)</span>
  <span class="s1">}).</span><span class="s0">join</span><span class="s1">(</span><span class="s3">'|'</span><span class="s1">)</span>

  <span class="s4">// must match entire pattern</span>
  <span class="s4">// ending in a * or ** will make it less strict.</span>
  <span class="s0">re </span><span class="s1">= </span><span class="s3">'^(?:' </span><span class="s1">+ </span><span class="s0">re </span><span class="s1">+ </span><span class="s3">')$'</span>

  <span class="s4">// can match anything, as long as it's not this.</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s0">negate</span><span class="s1">) </span><span class="s0">re </span><span class="s1">= </span><span class="s3">'^(?!' </span><span class="s1">+ </span><span class="s0">re </span><span class="s1">+ </span><span class="s3">').*$'</span>

  <span class="s2">try </span><span class="s1">{</span>
    <span class="s2">this</span><span class="s1">.</span><span class="s0">regexp </span><span class="s1">= </span><span class="s2">new </span><span class="s0">RegExp</span><span class="s1">(</span><span class="s0">re</span><span class="s1">, </span><span class="s0">flags</span><span class="s1">)</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(</span><span class="s0">ex</span><span class="s1">) </span><span class="s4">/* istanbul ignore next - should be impossible */ </span><span class="s1">{</span>
    <span class="s2">this</span><span class="s1">.</span><span class="s0">regexp </span><span class="s1">= </span><span class="s2">false</span>
  <span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.</span><span class="s0">regexp</span>
<span class="s1">}</span>

<span class="s0">minimatch</span><span class="s1">.</span><span class="s0">match </span><span class="s1">= </span><span class="s2">function </span><span class="s1">(</span><span class="s0">list</span><span class="s1">, </span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">) {</span>
  <span class="s0">options </span><span class="s1">= </span><span class="s0">options </span><span class="s1">|| {}</span>
  <span class="s2">var </span><span class="s0">mm </span><span class="s1">= </span><span class="s2">new </span><span class="s0">Minimatch</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">options</span><span class="s1">)</span>
  <span class="s0">list </span><span class="s1">= </span><span class="s0">list</span><span class="s1">.</span><span class="s0">filter</span><span class="s1">(</span><span class="s2">function </span><span class="s1">(</span><span class="s0">f</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">mm</span><span class="s1">.</span><span class="s0">match</span><span class="s1">(</span><span class="s0">f</span><span class="s1">)</span>
  <span class="s1">})</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s0">mm</span><span class="s1">.</span><span class="s0">options</span><span class="s1">.</span><span class="s0">nonull </span><span class="s1">&amp;&amp; !</span><span class="s0">list</span><span class="s1">.</span><span class="s0">length</span><span class="s1">) {</span>
    <span class="s0">list</span><span class="s1">.</span><span class="s0">push</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">)</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s0">list</span>
<span class="s1">}</span>

<span class="s0">Minimatch</span><span class="s1">.</span><span class="s0">prototype</span><span class="s1">.</span><span class="s0">match </span><span class="s1">= </span><span class="s2">function </span><span class="s0">match </span><span class="s1">(</span><span class="s0">f</span><span class="s1">, </span><span class="s0">partial</span><span class="s1">) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s0">partial </span><span class="s1">=== </span><span class="s3">'undefined'</span><span class="s1">) </span><span class="s0">partial </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">partial</span>
  <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'match'</span><span class="s1">, </span><span class="s0">f</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.</span><span class="s0">pattern</span><span class="s1">)</span>
  <span class="s4">// short-circuit in the case of busted things.</span>
  <span class="s4">// comments, etc.</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s0">comment</span><span class="s1">) </span><span class="s2">return false</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s0">empty</span><span class="s1">) </span><span class="s2">return </span><span class="s0">f </span><span class="s1">=== </span><span class="s3">''</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s0">f </span><span class="s1">=== </span><span class="s3">'/' </span><span class="s1">&amp;&amp; </span><span class="s0">partial</span><span class="s1">) </span><span class="s2">return true</span>

  <span class="s2">var </span><span class="s0">options </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">options</span>

  <span class="s4">// windows: need to use /, not \</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s0">path</span><span class="s1">.</span><span class="s0">sep </span><span class="s1">!== </span><span class="s3">'/'</span><span class="s1">) {</span>
    <span class="s0">f </span><span class="s1">= </span><span class="s0">f</span><span class="s1">.</span><span class="s0">split</span><span class="s1">(</span><span class="s0">path</span><span class="s1">.</span><span class="s0">sep</span><span class="s1">).</span><span class="s0">join</span><span class="s1">(</span><span class="s3">'/'</span><span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s4">// treat the test path as a set of pathparts.</span>
  <span class="s0">f </span><span class="s1">= </span><span class="s0">f</span><span class="s1">.</span><span class="s0">split</span><span class="s1">(</span><span class="s0">slashSplit</span><span class="s1">)</span>
  <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s0">pattern</span><span class="s1">, </span><span class="s3">'split'</span><span class="s1">, </span><span class="s0">f</span><span class="s1">)</span>

  <span class="s4">// just ONE of the pattern sets in this.set needs to match</span>
  <span class="s4">// in order for it to be valid.  If negating, then just one</span>
  <span class="s4">// match means that we have failed.</span>
  <span class="s4">// Either way, return on the first hit.</span>

  <span class="s2">var </span><span class="s0">set </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">set</span>
  <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s0">pattern</span><span class="s1">, </span><span class="s3">'set'</span><span class="s1">, </span><span class="s0">set</span><span class="s1">)</span>

  <span class="s4">// Find the basename of the path by looking for the last non-empty segment</span>
  <span class="s2">var </span><span class="s0">filename</span>
  <span class="s2">var </span><span class="s0">i</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s0">i </span><span class="s1">= </span><span class="s0">f</span><span class="s1">.</span><span class="s0">length </span><span class="s1">- </span><span class="s6">1</span><span class="s1">; </span><span class="s0">i </span><span class="s1">&gt;= </span><span class="s6">0</span><span class="s1">; </span><span class="s0">i</span><span class="s1">--) {</span>
    <span class="s0">filename </span><span class="s1">= </span><span class="s0">f</span><span class="s1">[</span><span class="s0">i</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s0">filename</span><span class="s1">) </span><span class="s2">break</span>
  <span class="s1">}</span>

  <span class="s2">for </span><span class="s1">(</span><span class="s0">i </span><span class="s1">= </span><span class="s6">0</span><span class="s1">; </span><span class="s0">i </span><span class="s1">&lt; </span><span class="s0">set</span><span class="s1">.</span><span class="s0">length</span><span class="s1">; </span><span class="s0">i</span><span class="s1">++) {</span>
    <span class="s2">var </span><span class="s0">pattern </span><span class="s1">= </span><span class="s0">set</span><span class="s1">[</span><span class="s0">i</span><span class="s1">]</span>
    <span class="s2">var </span><span class="s0">file </span><span class="s1">= </span><span class="s0">f</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s0">options</span><span class="s1">.</span><span class="s0">matchBase </span><span class="s1">&amp;&amp; </span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">length </span><span class="s1">=== </span><span class="s6">1</span><span class="s1">) {</span>
      <span class="s0">file </span><span class="s1">= [</span><span class="s0">filename</span><span class="s1">]</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s0">hit </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">matchOne</span><span class="s1">(</span><span class="s0">file</span><span class="s1">, </span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">partial</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s0">hit</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s0">options</span><span class="s1">.</span><span class="s0">flipNegate</span><span class="s1">) </span><span class="s2">return true</span>
      <span class="s2">return </span><span class="s1">!</span><span class="s2">this</span><span class="s1">.</span><span class="s0">negate</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">// didn't get any hits.  this is success if it's a negative</span>
  <span class="s4">// pattern, failure otherwise.</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s0">options</span><span class="s1">.</span><span class="s0">flipNegate</span><span class="s1">) </span><span class="s2">return false</span>
  <span class="s2">return this</span><span class="s1">.</span><span class="s0">negate</span>
<span class="s1">}</span>

<span class="s4">// set partial to true to test if, for example,</span>
<span class="s4">// &quot;/a/b&quot; matches the start of &quot;/*/b/*/d&quot;</span>
<span class="s4">// Partial means, if you run out of file before you run</span>
<span class="s4">// out of pattern, then that's fine, as long as all</span>
<span class="s4">// the parts match.</span>
<span class="s0">Minimatch</span><span class="s1">.</span><span class="s0">prototype</span><span class="s1">.</span><span class="s0">matchOne </span><span class="s1">= </span><span class="s2">function </span><span class="s1">(</span><span class="s0">file</span><span class="s1">, </span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">partial</span><span class="s1">) {</span>
  <span class="s2">var </span><span class="s0">options </span><span class="s1">= </span><span class="s2">this</span><span class="s1">.</span><span class="s0">options</span>

  <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'matchOne'</span><span class="s1">,</span>
    <span class="s1">{ </span><span class="s3">'this'</span><span class="s1">: </span><span class="s2">this</span><span class="s1">, </span><span class="s0">file</span><span class="s1">: </span><span class="s0">file</span><span class="s1">, </span><span class="s0">pattern</span><span class="s1">: </span><span class="s0">pattern </span><span class="s1">})</span>

  <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'matchOne'</span><span class="s1">, </span><span class="s0">file</span><span class="s1">.</span><span class="s0">length</span><span class="s1">, </span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">length</span><span class="s1">)</span>

  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s0">fi </span><span class="s1">= </span><span class="s6">0</span><span class="s1">,</span>
      <span class="s0">pi </span><span class="s1">= </span><span class="s6">0</span><span class="s1">,</span>
      <span class="s0">fl </span><span class="s1">= </span><span class="s0">file</span><span class="s1">.</span><span class="s0">length</span><span class="s1">,</span>
      <span class="s0">pl </span><span class="s1">= </span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">length</span>
      <span class="s1">; (</span><span class="s0">fi </span><span class="s1">&lt; </span><span class="s0">fl</span><span class="s1">) &amp;&amp; (</span><span class="s0">pi </span><span class="s1">&lt; </span><span class="s0">pl</span><span class="s1">)</span>
      <span class="s1">; </span><span class="s0">fi</span><span class="s1">++, </span><span class="s0">pi</span><span class="s1">++) {</span>
    <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'matchOne loop'</span><span class="s1">)</span>
    <span class="s2">var </span><span class="s0">p </span><span class="s1">= </span><span class="s0">pattern</span><span class="s1">[</span><span class="s0">pi</span><span class="s1">]</span>
    <span class="s2">var </span><span class="s0">f </span><span class="s1">= </span><span class="s0">file</span><span class="s1">[</span><span class="s0">fi</span><span class="s1">]</span>

    <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">p</span><span class="s1">, </span><span class="s0">f</span><span class="s1">)</span>

    <span class="s4">// should be impossible.</span>
    <span class="s4">// some invalid regexp stuff in the set.</span>
    <span class="s4">/* istanbul ignore if */</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s0">p </span><span class="s1">=== </span><span class="s2">false</span><span class="s1">) </span><span class="s2">return false</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s0">p </span><span class="s1">=== </span><span class="s0">GLOBSTAR</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'GLOBSTAR'</span><span class="s1">, [</span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">p</span><span class="s1">, </span><span class="s0">f</span><span class="s1">])</span>

      <span class="s4">// &quot;**&quot;</span>
      <span class="s4">// a/**/b/**/c would match the following:</span>
      <span class="s4">// a/b/x/y/z/c</span>
      <span class="s4">// a/x/y/z/b/c</span>
      <span class="s4">// a/b/x/b/x/c</span>
      <span class="s4">// a/b/c</span>
      <span class="s4">// To do this, take the rest of the pattern after</span>
      <span class="s4">// the **, and see if it would match the file remainder.</span>
      <span class="s4">// If so, return success.</span>
      <span class="s4">// If not, the ** &quot;swallows&quot; a segment, and try again.</span>
      <span class="s4">// This is recursively awful.</span>
      <span class="s4">//</span>
      <span class="s4">// a/**/b/**/c matching a/b/x/y/z/c</span>
      <span class="s4">// - a matches a</span>
      <span class="s4">// - doublestar</span>
      <span class="s4">//   - matchOne(b/x/y/z/c, b/**/c)</span>
      <span class="s4">//     - b matches b</span>
      <span class="s4">//     - doublestar</span>
      <span class="s4">//       - matchOne(x/y/z/c, c) -&gt; no</span>
      <span class="s4">//       - matchOne(y/z/c, c) -&gt; no</span>
      <span class="s4">//       - matchOne(z/c, c) -&gt; no</span>
      <span class="s4">//       - matchOne(c, c) yes, hit</span>
      <span class="s2">var </span><span class="s0">fr </span><span class="s1">= </span><span class="s0">fi</span>
      <span class="s2">var </span><span class="s0">pr </span><span class="s1">= </span><span class="s0">pi </span><span class="s1">+ </span><span class="s6">1</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s0">pr </span><span class="s1">=== </span><span class="s0">pl</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'** at the end'</span><span class="s1">)</span>
        <span class="s4">// a ** at the end will just swallow the rest.</span>
        <span class="s4">// We have found a match.</span>
        <span class="s4">// however, it will not swallow /.x, unless</span>
        <span class="s4">// options.dot is set.</span>
        <span class="s4">// . and .. are *never* matched by **, for explosively</span>
        <span class="s4">// exponential reasons.</span>
        <span class="s2">for </span><span class="s1">(; </span><span class="s0">fi </span><span class="s1">&lt; </span><span class="s0">fl</span><span class="s1">; </span><span class="s0">fi</span><span class="s1">++) {</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s0">file</span><span class="s1">[</span><span class="s0">fi</span><span class="s1">] === </span><span class="s3">'.' </span><span class="s1">|| </span><span class="s0">file</span><span class="s1">[</span><span class="s0">fi</span><span class="s1">] === </span><span class="s3">'..' </span><span class="s1">||</span>
            <span class="s1">(!</span><span class="s0">options</span><span class="s1">.</span><span class="s0">dot </span><span class="s1">&amp;&amp; </span><span class="s0">file</span><span class="s1">[</span><span class="s0">fi</span><span class="s1">].</span><span class="s0">charAt</span><span class="s1">(</span><span class="s6">0</span><span class="s1">) === </span><span class="s3">'.'</span><span class="s1">)) </span><span class="s2">return false</span>
        <span class="s1">}</span>
        <span class="s2">return true</span>
      <span class="s1">}</span>

      <span class="s4">// ok, let's see if we can swallow whatever we can.</span>
      <span class="s2">while </span><span class="s1">(</span><span class="s0">fr </span><span class="s1">&lt; </span><span class="s0">fl</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s0">swallowee </span><span class="s1">= </span><span class="s0">file</span><span class="s1">[</span><span class="s0">fr</span><span class="s1">]</span>

        <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">globstar while'</span><span class="s1">, </span><span class="s0">file</span><span class="s1">, </span><span class="s0">fr</span><span class="s1">, </span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">pr</span><span class="s1">, </span><span class="s0">swallowee</span><span class="s1">)</span>

        <span class="s4">// XXX remove this slice.  Just pass the start index.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s0">matchOne</span><span class="s1">(</span><span class="s0">file</span><span class="s1">.</span><span class="s0">slice</span><span class="s1">(</span><span class="s0">fr</span><span class="s1">), </span><span class="s0">pattern</span><span class="s1">.</span><span class="s0">slice</span><span class="s1">(</span><span class="s0">pr</span><span class="s1">), </span><span class="s0">partial</span><span class="s1">)) {</span>
          <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'globstar found match!'</span><span class="s1">, </span><span class="s0">fr</span><span class="s1">, </span><span class="s0">fl</span><span class="s1">, </span><span class="s0">swallowee</span><span class="s1">)</span>
          <span class="s4">// found a match.</span>
          <span class="s2">return true</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s4">// can't swallow &quot;.&quot; or &quot;..&quot; ever.</span>
          <span class="s4">// can only swallow &quot;.foo&quot; when explicitly asked.</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s0">swallowee </span><span class="s1">=== </span><span class="s3">'.' </span><span class="s1">|| </span><span class="s0">swallowee </span><span class="s1">=== </span><span class="s3">'..' </span><span class="s1">||</span>
            <span class="s1">(!</span><span class="s0">options</span><span class="s1">.</span><span class="s0">dot </span><span class="s1">&amp;&amp; </span><span class="s0">swallowee</span><span class="s1">.</span><span class="s0">charAt</span><span class="s1">(</span><span class="s6">0</span><span class="s1">) === </span><span class="s3">'.'</span><span class="s1">)) {</span>
            <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'dot detected!'</span><span class="s1">, </span><span class="s0">file</span><span class="s1">, </span><span class="s0">fr</span><span class="s1">, </span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">pr</span><span class="s1">)</span>
            <span class="s2">break</span>
          <span class="s1">}</span>

          <span class="s4">// ** swallows a segment, and continue.</span>
          <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'globstar swallow a segment, and continue'</span><span class="s1">)</span>
          <span class="s0">fr</span><span class="s1">++</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s4">// no match was found.</span>
      <span class="s4">// However, in partial mode, we can't say this is necessarily over.</span>
      <span class="s4">// If there's more *pattern* left, then</span>
      <span class="s4">/* istanbul ignore if */</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s0">partial</span><span class="s1">) {</span>
        <span class="s4">// ran out of file</span>
        <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">&gt;&gt;&gt; no match, partial?'</span><span class="s1">, </span><span class="s0">file</span><span class="s1">, </span><span class="s0">fr</span><span class="s1">, </span><span class="s0">pattern</span><span class="s1">, </span><span class="s0">pr</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">fr </span><span class="s1">=== </span><span class="s0">fl</span><span class="s1">) </span><span class="s2">return true</span>
      <span class="s1">}</span>
      <span class="s2">return false</span>
    <span class="s1">}</span>

    <span class="s4">// something other than **</span>
    <span class="s4">// non-magic patterns just have to match exactly</span>
    <span class="s4">// patterns with magic have been turned into regexps.</span>
    <span class="s2">var </span><span class="s0">hit</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s0">p </span><span class="s1">=== </span><span class="s3">'string'</span><span class="s1">) {</span>
      <span class="s0">hit </span><span class="s1">= </span><span class="s0">f </span><span class="s1">=== </span><span class="s0">p</span>
      <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'string match'</span><span class="s1">, </span><span class="s0">p</span><span class="s1">, </span><span class="s0">f</span><span class="s1">, </span><span class="s0">hit</span><span class="s1">)</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">hit </span><span class="s1">= </span><span class="s0">f</span><span class="s1">.</span><span class="s0">match</span><span class="s1">(</span><span class="s0">p</span><span class="s1">)</span>
      <span class="s2">this</span><span class="s1">.</span><span class="s0">debug</span><span class="s1">(</span><span class="s3">'pattern match'</span><span class="s1">, </span><span class="s0">p</span><span class="s1">, </span><span class="s0">f</span><span class="s1">, </span><span class="s0">hit</span><span class="s1">)</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!</span><span class="s0">hit</span><span class="s1">) </span><span class="s2">return false</span>
  <span class="s1">}</span>

  <span class="s4">// Note: ending in / means that we'll get a final &quot;&quot;</span>
  <span class="s4">// at the end of the pattern.  This can only match a</span>
  <span class="s4">// corresponding &quot;&quot; at the end of the file.</span>
  <span class="s4">// If the file ends in /, then it can only match a</span>
  <span class="s4">// a pattern that ends in /, unless the pattern just</span>
  <span class="s4">// doesn't have any more for it. But, a/b/ should *not*</span>
  <span class="s4">// match &quot;a/b/*&quot;, even though &quot;&quot; matches against the</span>
  <span class="s4">// [^/]*? pattern, except in partial mode, where it might</span>
  <span class="s4">// simply not be reached yet.</span>
  <span class="s4">// However, a/b/ should still satisfy a/*</span>

  <span class="s4">// now either we fell off the end of the pattern, or we're done.</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s0">fi </span><span class="s1">=== </span><span class="s0">fl </span><span class="s1">&amp;&amp; </span><span class="s0">pi </span><span class="s1">=== </span><span class="s0">pl</span><span class="s1">) {</span>
    <span class="s4">// ran out of pattern and filename at the same time.</span>
    <span class="s4">// an exact hit!</span>
    <span class="s2">return true</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s0">fi </span><span class="s1">=== </span><span class="s0">fl</span><span class="s1">) {</span>
    <span class="s4">// ran out of file, but still had pattern left.</span>
    <span class="s4">// this is ok if we're doing the match as part of</span>
    <span class="s4">// a glob fs traversal.</span>
    <span class="s2">return </span><span class="s0">partial</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s4">/* istanbul ignore else */ </span><span class="s2">if </span><span class="s1">(</span><span class="s0">pi </span><span class="s1">=== </span><span class="s0">pl</span><span class="s1">) {</span>
    <span class="s4">// ran out of pattern, still have file left.</span>
    <span class="s4">// this is only acceptable if we're on the very last</span>
    <span class="s4">// empty segment of a file with a trailing slash.</span>
    <span class="s4">// a/* should match a/b/</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s0">fi </span><span class="s1">=== </span><span class="s0">fl </span><span class="s1">- </span><span class="s6">1</span><span class="s1">) &amp;&amp; (</span><span class="s0">file</span><span class="s1">[</span><span class="s0">fi</span><span class="s1">] === </span><span class="s3">''</span><span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s4">// should be unreachable.</span>
  <span class="s4">/* istanbul ignore next */</span>
  <span class="s2">throw new </span><span class="s0">Error</span><span class="s1">(</span><span class="s3">'wtf?'</span><span class="s1">)</span>
<span class="s1">}</span>

<span class="s4">// replace stuff like \* with *</span>
<span class="s2">function </span><span class="s0">globUnescape </span><span class="s1">(</span><span class="s0">s</span><span class="s1">) {</span>
  <span class="s2">return </span><span class="s0">s</span><span class="s1">.</span><span class="s0">replace</span><span class="s1">(</span><span class="s5">/\\(.)/g</span><span class="s1">, </span><span class="s3">'$1'</span><span class="s1">)</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s0">regExpEscape </span><span class="s1">(</span><span class="s0">s</span><span class="s1">) {</span>
  <span class="s2">return </span><span class="s0">s</span><span class="s1">.</span><span class="s0">replace</span><span class="s1">(</span><span class="s5">/[-[\]{}()*+?.,\\^$|#\s]/g</span><span class="s1">, </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">$&amp;'</span><span class="s1">)</span>
<span class="s1">}</span>
</pre>
</body>
</html>