<html>
<head>
<title>removal-hooks.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
removal-hooks.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;hooks&quot;</span><span class="s0">,</span><span class="s1">&quot;self&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;removeParent&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;isWhile&quot;</span><span class="s0">,</span><span class="s1">&quot;isSwitchCase&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isLabeledStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;listKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;declarations&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;isSequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;expressions&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;isBinary&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;isIfStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isLoop&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/path/lib/removal-hooks.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// this file contains hooks that handle ancestry cleanup of parent nodes when removing children</span><span class="s3">\n\n</span><span class="s1">import type NodePath from </span><span class="s3">\&quot;</span><span class="s1">../index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Pre hooks should be used for either rejecting removal or delegating removal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export const hooks = [</span><span class="s3">\n  </span><span class="s1">function (self: NodePath, parent: NodePath) {</span><span class="s3">\n    </span><span class="s1">const removeParent =</span><span class="s3">\n      </span><span class="s1">// while (NODE);</span><span class="s3">\n      </span><span class="s1">// removing the test of a while/switch, we can either just remove it entirely *or* turn the</span><span class="s3">\n      </span><span class="s1">// `test` into `true` unlikely that the latter will ever be what's wanted so we just remove</span><span class="s3">\n      </span><span class="s1">// the loop to avoid infinite recursion</span><span class="s3">\n      </span><span class="s1">(self.key === </span><span class="s3">\&quot;</span><span class="s1">test</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; (parent.isWhile() || parent.isSwitchCase())) ||</span><span class="s3">\n      </span><span class="s1">// export NODE;</span><span class="s3">\n      </span><span class="s1">// just remove a declaration for an export as this is no longer valid</span><span class="s3">\n      </span><span class="s1">(self.key === </span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parent.isExportDeclaration()) ||</span><span class="s3">\n      </span><span class="s1">// label: NODE</span><span class="s3">\n      </span><span class="s1">// stray labeled statement with no body</span><span class="s3">\n      </span><span class="s1">(self.key === </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parent.isLabeledStatement()) ||</span><span class="s3">\n      </span><span class="s1">// let NODE;</span><span class="s3">\n      </span><span class="s1">// remove an entire declaration if there are no declarators left</span><span class="s3">\n      </span><span class="s1">(self.listKey === </span><span class="s3">\&quot;</span><span class="s1">declarations</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">parent.isVariableDeclaration() &amp;&amp;</span><span class="s3">\n        </span><span class="s1">parent.node.declarations.length === 1) ||</span><span class="s3">\n      </span><span class="s1">// NODE;</span><span class="s3">\n      </span><span class="s1">// remove the entire expression statement if there's no expression</span><span class="s3">\n      </span><span class="s1">(self.key === </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parent.isExpressionStatement());</span><span class="s3">\n\n    </span><span class="s1">if (removeParent) {</span><span class="s3">\n      </span><span class="s1">parent.remove();</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">function (self: NodePath, parent: NodePath) {</span><span class="s3">\n    </span><span class="s1">if (parent.isSequenceExpression() &amp;&amp; parent.node.expressions.length === 1) {</span><span class="s3">\n      </span><span class="s1">// (node, NODE);</span><span class="s3">\n      </span><span class="s1">// we've just removed the second element of a sequence expression so let's turn that sequence</span><span class="s3">\n      </span><span class="s1">// expression into a regular expression</span><span class="s3">\n      </span><span class="s1">parent.replaceWith(parent.node.expressions[0]);</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">function (self: NodePath, parent: NodePath) {</span><span class="s3">\n    </span><span class="s1">if (parent.isBinary()) {</span><span class="s3">\n      </span><span class="s1">// left + NODE;</span><span class="s3">\n      </span><span class="s1">// NODE + right;</span><span class="s3">\n      </span><span class="s1">// we're in a binary expression, better remove it and replace it with the last expression</span><span class="s3">\n      </span><span class="s1">if (self.key === </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">parent.replaceWith(parent.node.right);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// key === </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;\n        </span><span class="s1">parent.replaceWith(parent.node.left);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">function (self: NodePath, parent: NodePath) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(parent.isIfStatement() &amp;&amp; self.key === </span><span class="s3">\&quot;</span><span class="s1">consequent</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n      </span><span class="s1">(self.key === </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">(parent.isLoop() || parent.isArrowFunctionExpression()))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">self.replaceWith({</span><span class="s3">\n        </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">BlockStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">body: [],</span><span class="s3">\n      </span><span class="s1">} as t.BlockStatement);</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAQO,MAAMA,KAAK,GAAG,CACnB,UAAUC,IAAc,EAAEC,MAAgB,EAAE;EAC1C,MAAMC,YAAY,GAKfF,IAAI,CAACG,GAAG,KAAK,MAAM,KAAKF,MAAM,CAACG,OAAO,CAAC,CAAC,IAAIH,MAAM,CAACI,YAAY,CAAC,CAAC,CAAC,IAGlEL,IAAI,CAACG,GAAG,KAAK,aAAa,IAAIF,MAAM,CAACK,mBAAmB,CAAC,CAAE,IAG3DN,IAAI,CAACG,GAAG,KAAK,MAAM,IAAIF,MAAM,CAACM,kBAAkB,CAAC,CAAE,IAGnDP,IAAI,CAACQ,OAAO,KAAK,cAAc,IAC9BP,MAAM,CAACQ,qBAAqB,CAAC,CAAC,IAC9BR,MAAM,CAACS,IAAI,CAACC,YAAY,CAACC,MAAM,KAAK,CAAE,IAGvCZ,IAAI,CAACG,GAAG,KAAK,YAAY,IAAIF,MAAM,CAACY,qBAAqB,CAAC,CAAE;EAE/D,IAAIX,YAAY,EAAE;IAChBD,MAAM,CAACa,MAAM,CAAC,CAAC;IACf,OAAO,IAAI;EACb;AACF,CAAC,EAED,UAAUd,IAAc,EAAEC,MAAgB,EAAE;EAC1C,IAAIA,MAAM,CAACc,oBAAoB,CAAC,CAAC,IAAId,MAAM,CAACS,IAAI,CAACM,WAAW,CAACJ,MAAM,KAAK,CAAC,EAAE;IAIzEX,MAAM,CAACgB,WAAW,CAAChB,MAAM,CAACS,IAAI,CAACM,WAAW,CAAC,CAAC,CAAC,CAAC;IAC9C,OAAO,IAAI;EACb;AACF,CAAC,EAED,UAAUhB,IAAc,EAAEC,MAAgB,EAAE;EAC1C,IAAIA,MAAM,CAACiB,QAAQ,CAAC,CAAC,EAAE;IAIrB,IAAIlB,IAAI,CAACG,GAAG,KAAK,MAAM,EAAE;MACvBF,MAAM,CAACgB,WAAW,CAAChB,MAAM,CAACS,IAAI,CAACS,KAAK,CAAC;IACvC,CAAC,MAAM;MAELlB,MAAM,CAACgB,WAAW,CAAChB,MAAM,CAACS,IAAI,CAACU,IAAI,CAAC;IACtC;IACA,OAAO,IAAI;EACb;AACF,CAAC,EAED,UAAUpB,IAAc,EAAEC,MAAgB,EAAE;EAC1C,IACGA,MAAM,CAACoB,aAAa,CAAC,CAAC,IAAIrB,IAAI,CAACG,GAAG,KAAK,YAAY,IACnDH,IAAI,CAACG,GAAG,KAAK,MAAM,KACjBF,MAAM,CAACqB,MAAM,CAAC,CAAC,IAAIrB,MAAM,CAACsB,yBAAyB,CAAC,CAAC,CAAE,EAC1D;IACAvB,IAAI,CAACiB,WAAW,CAAC;MACfO,IAAI,EAAE,gBAAgB;MACtBC,IAAI,EAAE;IACR,CAAqB,CAAC;IACtB,OAAO,IAAI;EACb;AACF,CAAC,CACF;AAACC,OAAA,CAAA3B,KAAA,GAAAA,KAAA&quot;</span><span class="s0">}</span></pre>
</body>
</html>