<html>
<head>
<title>printer.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
printer.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;generatorFunctions&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassBody&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSInterfaceBody&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSEnumDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;SCIENTIFIC_NOTATION&quot;</span><span class="s0">,</span><span class="s1">&quot;ZERO_DECIMAL_INTEGER&quot;</span><span class="s0">,</span><span class="s1">&quot;NON_DECIMAL_LITERAL&quot;</span><span class="s0">,</span><span class="s1">&quot;PURE_ANNOTATION_RE&quot;</span><span class="s0">,</span><span class="s1">&quot;HAS_NEWLINE&quot;</span><span class="s0">,</span><span class="s1">&quot;HAS_BlOCK_COMMENT_END&quot;</span><span class="s0">,</span><span class="s1">&quot;needsParens&quot;</span><span class="s0">,</span><span class="s1">&quot;Printer&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;format&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;inForStatementInitCounter&quot;</span><span class="s0">,</span><span class="s1">&quot;_printStack&quot;</span><span class="s0">,</span><span class="s1">&quot;_indent&quot;</span><span class="s0">,</span><span class="s1">&quot;_indentChar&quot;</span><span class="s0">,</span><span class="s1">&quot;_indentRepeat&quot;</span><span class="s0">,</span><span class="s1">&quot;_insideAux&quot;</span><span class="s0">,</span><span class="s1">&quot;_parenPushNewlineState&quot;</span><span class="s0">,</span><span class="s1">&quot;_noLineTerminator&quot;</span><span class="s0">,</span><span class="s1">&quot;_printAuxAfterOnNextUserNode&quot;</span><span class="s0">,</span><span class="s1">&quot;_printedComments&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;_endsWithInteger&quot;</span><span class="s0">,</span><span class="s1">&quot;_endsWithWord&quot;</span><span class="s0">,</span><span class="s1">&quot;_lastCommentLine&quot;</span><span class="s0">,</span><span class="s1">&quot;_endsWithInnerRaw&quot;</span><span class="s0">,</span><span class="s1">&quot;_indentInnerComments&quot;</span><span class="s0">,</span><span class="s1">&quot;_buf&quot;</span><span class="s0">,</span><span class="s1">&quot;Buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;indent&quot;</span><span class="s0">,</span><span class="s1">&quot;style&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;_inputMap&quot;</span><span class="s0">,</span><span class="s1">&quot;generate&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;print&quot;</span><span class="s0">,</span><span class="s1">&quot;_maybeAddAuxComment&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;compact&quot;</span><span class="s0">,</span><span class="s1">&quot;concise&quot;</span><span class="s0">,</span><span class="s1">&quot;dedent&quot;</span><span class="s0">,</span><span class="s1">&quot;semicolon&quot;</span><span class="s0">,</span><span class="s1">&quot;force&quot;</span><span class="s0">,</span><span class="s1">&quot;_appendChar&quot;</span><span class="s0">,</span><span class="s1">&quot;_queue&quot;</span><span class="s0">,</span><span class="s1">&quot;rightBrace&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;minified&quot;</span><span class="s0">,</span><span class="s1">&quot;removeLastSemicolon&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceWithOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;token&quot;</span><span class="s0">,</span><span class="s1">&quot;rightParens&quot;</span><span class="s0">,</span><span class="s1">&quot;space&quot;</span><span class="s0">,</span><span class="s1">&quot;_space&quot;</span><span class="s0">,</span><span class="s1">&quot;hasContent&quot;</span><span class="s0">,</span><span class="s1">&quot;lastCp&quot;</span><span class="s0">,</span><span class="s1">&quot;getLastChar&quot;</span><span class="s0">,</span><span class="s1">&quot;word&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;noLineTerminatorAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;_maybePrintInnerComments&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;_append&quot;</span><span class="s0">,</span><span class="s1">&quot;number&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;isInteger&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;lastChar&quot;</span><span class="s0">,</span><span class="s1">&quot;strFirst&quot;</span><span class="s0">,</span><span class="s1">&quot;tokenChar&quot;</span><span class="s0">,</span><span class="s1">&quot;char&quot;</span><span class="s0">,</span><span class="s1">&quot;newline&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;retainLines&quot;</span><span class="s0">,</span><span class="s1">&quot;getNewlineCount&quot;</span><span class="s0">,</span><span class="s1">&quot;j&quot;</span><span class="s0">,</span><span class="s1">&quot;_newline&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWithCharAndNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;removeTrailingNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;exactSource&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;_catchUp&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;columnOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;withSource&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceIdentifierName&quot;</span><span class="s0">,</span><span class="s1">&quot;identifierName&quot;</span><span class="s0">,</span><span class="s1">&quot;pos&quot;</span><span class="s0">,</span><span class="s1">&quot;_canMarkIdName&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcePosition&quot;</span><span class="s0">,</span><span class="s1">&quot;_sourcePosition&quot;</span><span class="s0">,</span><span class="s1">&quot;identifierNamePos&quot;</span><span class="s0">,</span><span class="s1">&quot;_maybeAddParen&quot;</span><span class="s0">,</span><span class="s1">&quot;_maybeIndent&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;_maybeAddParenChar&quot;</span><span class="s0">,</span><span class="s1">&quot;appendChar&quot;</span><span class="s0">,</span><span class="s1">&quot;queue&quot;</span><span class="s0">,</span><span class="s1">&quot;firstChar&quot;</span><span class="s0">,</span><span class="s1">&quot;queueIndentation&quot;</span><span class="s0">,</span><span class="s1">&quot;_getIndent&quot;</span><span class="s0">,</span><span class="s1">&quot;_shouldIndent&quot;</span><span class="s0">,</span><span class="s1">&quot;parenPushNewlineState&quot;</span><span class="s0">,</span><span class="s1">&quot;printed&quot;</span><span class="s0">,</span><span class="s1">&quot;len&quot;</span><span class="s0">,</span><span class="s1">&quot;cha&quot;</span><span class="s0">,</span><span class="s1">&quot;chaPost&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;catchUp&quot;</span><span class="s0">,</span><span class="s1">&quot;line&quot;</span><span class="s0">,</span><span class="s1">&quot;count&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentLine&quot;</span><span class="s0">,</span><span class="s1">&quot;_loc$prop&quot;</span><span class="s0">,</span><span class="s1">&quot;printTerminatorless&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;isLabel&quot;</span><span class="s0">,</span><span class="s1">&quot;terminatorState&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingCommentsLineOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;forceParens&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$extra&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeType&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;oldConcise&quot;</span><span class="s0">,</span><span class="s1">&quot;_compact&quot;</span><span class="s0">,</span><span class="s1">&quot;printMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferenceError&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;oldInAux&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldPrintParens&quot;</span><span class="s0">,</span><span class="s1">&quot;retainFunctionParens&quot;</span><span class="s0">,</span><span class="s1">&quot;extra&quot;</span><span class="s0">,</span><span class="s1">&quot;parenthesized&quot;</span><span class="s0">,</span><span class="s1">&quot;_printLeadingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;_printTrailingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;enteredPositionlessNode&quot;</span><span class="s0">,</span><span class="s1">&quot;_printAuxBeforeComment&quot;</span><span class="s0">,</span><span class="s1">&quot;_printAuxAfterComment&quot;</span><span class="s0">,</span><span class="s1">&quot;comment&quot;</span><span class="s0">,</span><span class="s1">&quot;auxiliaryCommentBefore&quot;</span><span class="s0">,</span><span class="s1">&quot;_printComment&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;auxiliaryCommentAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;getPossibleRaw&quot;</span><span class="s0">,</span><span class="s1">&quot;raw&quot;</span><span class="s0">,</span><span class="s1">&quot;rawValue&quot;</span><span class="s0">,</span><span class="s1">&quot;printJoin&quot;</span><span class="s0">,</span><span class="s1">&quot;nodes&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">,</span><span class="s1">&quot;_nodes$0$loc&quot;</span><span class="s0">,</span><span class="s1">&quot;startLine&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;newlineOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;addNewlines&quot;</span><span class="s0">,</span><span class="s1">&quot;nextNodeStartLine&quot;</span><span class="s0">,</span><span class="s1">&quot;separator&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;_printNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;_nextNode$loc&quot;</span><span class="s0">,</span><span class="s1">&quot;nextNode&quot;</span><span class="s0">,</span><span class="s1">&quot;printAndIndentOnComments&quot;</span><span class="s0">,</span><span class="s1">&quot;leadingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;printBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;lineOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;innerComments&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;_printComments&quot;</span><span class="s0">,</span><span class="s1">&quot;comments&quot;</span><span class="s0">,</span><span class="s1">&quot;printInnerComments&quot;</span><span class="s0">,</span><span class="s1">&quot;hasSpace&quot;</span><span class="s0">,</span><span class="s1">&quot;printedCommentsCount&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;noIndentInnerCommentsHere&quot;</span><span class="s0">,</span><span class="s1">&quot;printSequence&quot;</span><span class="s0">,</span><span class="s1">&quot;_opts$indent&quot;</span><span class="s0">,</span><span class="s1">&quot;printList&quot;</span><span class="s0">,</span><span class="s1">&quot;items&quot;</span><span class="s0">,</span><span class="s1">&quot;commaSeparator&quot;</span><span class="s0">,</span><span class="s1">&quot;newLine&quot;</span><span class="s0">,</span><span class="s1">&quot;lastCommentLine&quot;</span><span class="s0">,</span><span class="s1">&quot;offset&quot;</span><span class="s0">,</span><span class="s1">&quot;_shouldPrintComment&quot;</span><span class="s0">,</span><span class="s1">&quot;ignore&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldPrintComment&quot;</span><span class="s0">,</span><span class="s1">&quot;skipNewLines&quot;</span><span class="s0">,</span><span class="s1">&quot;noLineTerminator&quot;</span><span class="s0">,</span><span class="s1">&quot;isBlockComment&quot;</span><span class="s0">,</span><span class="s1">&quot;printNewLines&quot;</span><span class="s0">,</span><span class="s1">&quot;lastCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;adjustMultilineComment&quot;</span><span class="s0">,</span><span class="s1">&quot;_comment$loc&quot;</span><span class="s0">,</span><span class="s1">&quot;column&quot;</span><span class="s0">,</span><span class="s1">&quot;newlineRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;indentSize&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentColumn&quot;</span><span class="s0">,</span><span class="s1">&quot;repeat&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;hasLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeStartLine&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeEndLine&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;lastLine&quot;</span><span class="s0">,</span><span class="s1">&quot;leadingCommentNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldPrint&quot;</span><span class="s0">,</span><span class="s1">&quot;commentStartLine&quot;</span><span class="s0">,</span><span class="s1">&quot;commentEndLine&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;min&quot;</span><span class="s0">,</span><span class="s1">&quot;singleLine&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldSkipNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;properties&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;Noop&quot;</span><span class="s0">,</span><span class="s1">&quot;_default&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/printer.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import Buffer, { type Pos } from </span><span class="s3">\&quot;</span><span class="s1">./buffer.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Loc } from </span><span class="s3">\&quot;</span><span class="s1">./buffer.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import * as n from </span><span class="s3">\&quot;</span><span class="s1">./node/index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isFunction,</span><span class="s3">\n  </span><span class="s1">isStatement,</span><span class="s3">\n  </span><span class="s1">isClassBody,</span><span class="s3">\n  </span><span class="s1">isTSInterfaceBody,</span><span class="s3">\n  </span><span class="s1">isTSEnumDeclaration,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">RecordAndTuplePluginOptions,</span><span class="s3">\n  </span><span class="s1">PipelineOperatorPluginOptions,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/parser</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Opts as jsescOptions } from </span><span class="s3">\&quot;</span><span class="s1">jsesc</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import * as generatorFunctions from </span><span class="s3">\&quot;</span><span class="s1">./generators/index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type SourceMap from </span><span class="s3">\&quot;</span><span class="s1">./source-map.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import * as charCodes from </span><span class="s3">\&quot;</span><span class="s1">charcodes</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { TraceMap } from </span><span class="s3">\&quot;</span><span class="s1">@jridgewell/trace-mapping</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const SCIENTIFIC_NOTATION = /e/i;</span><span class="s3">\n</span><span class="s1">const ZERO_DECIMAL_INTEGER = /</span><span class="s3">\\</span><span class="s1">.0+$/;</span><span class="s3">\n</span><span class="s1">const NON_DECIMAL_LITERAL = /^0[box]/;</span><span class="s3">\n</span><span class="s1">const PURE_ANNOTATION_RE = /^</span><span class="s3">\\</span><span class="s1">s*[@#]__PURE__</span><span class="s3">\\</span><span class="s1">s*$/;</span><span class="s3">\n</span><span class="s1">const HAS_NEWLINE = /[</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">u2028</span><span class="s3">\\</span><span class="s1">u2029]/;</span><span class="s3">\n</span><span class="s1">const HAS_BlOCK_COMMENT_END = /</span><span class="s3">\\</span><span class="s1">*</span><span class="s3">\\</span><span class="s1">//;</span><span class="s3">\n\n</span><span class="s1">const { needsParens } = n;</span><span class="s3">\n\n</span><span class="s1">const enum COMMENT_TYPE {</span><span class="s3">\n  </span><span class="s1">LEADING,</span><span class="s3">\n  </span><span class="s1">INNER,</span><span class="s3">\n  </span><span class="s1">TRAILING,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const enum COMMENT_SKIP_NEWLINE {</span><span class="s3">\n  </span><span class="s1">DEFAULT,</span><span class="s3">\n  </span><span class="s1">ALL,</span><span class="s3">\n  </span><span class="s1">LEADING,</span><span class="s3">\n  </span><span class="s1">TRAILING,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const enum PRINT_COMMENT_HINT {</span><span class="s3">\n  </span><span class="s1">SKIP,</span><span class="s3">\n  </span><span class="s1">ALLOW,</span><span class="s3">\n  </span><span class="s1">DEFER,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type Format = {</span><span class="s3">\n  </span><span class="s1">shouldPrintComment: (comment: string) =&gt; boolean;</span><span class="s3">\n  </span><span class="s1">retainLines: boolean;</span><span class="s3">\n  </span><span class="s1">retainFunctionParens: boolean;</span><span class="s3">\n  </span><span class="s1">comments: boolean;</span><span class="s3">\n  </span><span class="s1">auxiliaryCommentBefore: string;</span><span class="s3">\n  </span><span class="s1">auxiliaryCommentAfter: string;</span><span class="s3">\n  </span><span class="s1">compact: boolean | </span><span class="s3">\&quot;</span><span class="s1">auto</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">minified: boolean;</span><span class="s3">\n  </span><span class="s1">concise: boolean;</span><span class="s3">\n  </span><span class="s1">indent: {</span><span class="s3">\n    </span><span class="s1">adjustMultilineComment: boolean;</span><span class="s3">\n    </span><span class="s1">style: string;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">recordAndTupleSyntaxType: RecordAndTuplePluginOptions[</span><span class="s3">\&quot;</span><span class="s1">syntaxType</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">jsescOption: jsescOptions;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated Removed in Babel 8, use `jsescOption` instead</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">jsonCompatibleStrings?: boolean;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* For use with the Hack-style pipe operator.</span><span class="s3">\n   </span><span class="s1">* Changes what token is used for pipe bodies’ topic references.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">topicToken?: PipelineOperatorPluginOptions[</span><span class="s3">\&quot;</span><span class="s1">topicToken</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated Removed in Babel 8</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">decoratorsBeforeExport?: boolean;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The import attributes syntax style:</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">with</span><span class="s3">\&quot;        </span><span class="s1">: `import { a } from </span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot; </span><span class="s1">with { type: </span><span class="s3">\&quot;</span><span class="s1">json</span><span class="s3">\&quot; </span><span class="s1">};`</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">assert</span><span class="s3">\&quot;      </span><span class="s1">: `import { a } from </span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot; </span><span class="s1">assert { type: </span><span class="s3">\&quot;</span><span class="s1">json</span><span class="s3">\&quot; </span><span class="s1">};`</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">with-legacy</span><span class="s3">\&quot; </span><span class="s1">: `import { a } from </span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot; </span><span class="s1">with type: </span><span class="s3">\&quot;</span><span class="s1">json</span><span class="s3">\&quot;</span><span class="s1">;`</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">importAttributesKeyword?: </span><span class="s3">\&quot;</span><span class="s1">with</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">assert</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">with-legacy</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">interface AddNewlinesOptions {</span><span class="s3">\n  </span><span class="s1">addNewlines(leading: boolean, node: t.Node): number;</span><span class="s3">\n  </span><span class="s1">nextNodeStartLine: number;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface PrintSequenceOptions extends Partial&lt;AddNewlinesOptions&gt; {</span><span class="s3">\n  </span><span class="s1">statement?: boolean;</span><span class="s3">\n  </span><span class="s1">indent?: boolean;</span><span class="s3">\n  </span><span class="s1">trailingCommentsLineOffset?: number;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface PrintListOptions {</span><span class="s3">\n  </span><span class="s1">separator?: (this: Printer) =&gt; void;</span><span class="s3">\n  </span><span class="s1">iterator?: (node: t.Node, index: number) =&gt; void;</span><span class="s3">\n  </span><span class="s1">statement?: boolean;</span><span class="s3">\n  </span><span class="s1">indent?: boolean;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PrintJoinOptions = PrintListOptions &amp; PrintSequenceOptions;</span><span class="s3">\n</span><span class="s1">class Printer {</span><span class="s3">\n  </span><span class="s1">constructor(format: Format, map: SourceMap) {</span><span class="s3">\n    </span><span class="s1">this.format = format;</span><span class="s3">\n    </span><span class="s1">this._buf = new Buffer(map);</span><span class="s3">\n\n    </span><span class="s1">this._indentChar = format.indent.style.charCodeAt(0);</span><span class="s3">\n    </span><span class="s1">this._indentRepeat = format.indent.style.length;</span><span class="s3">\n\n    </span><span class="s1">this._inputMap = map?._inputMap;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">declare _inputMap: TraceMap;</span><span class="s3">\n\n  </span><span class="s1">declare format: Format;</span><span class="s3">\n  </span><span class="s1">inForStatementInitCounter: number = 0;</span><span class="s3">\n\n  </span><span class="s1">declare _buf: Buffer;</span><span class="s3">\n  </span><span class="s1">_printStack: Array&lt;t.Node&gt; = [];</span><span class="s3">\n  </span><span class="s1">_indent: number = 0;</span><span class="s3">\n  </span><span class="s1">_indentChar: number = 0;</span><span class="s3">\n  </span><span class="s1">_indentRepeat: number = 0;</span><span class="s3">\n  </span><span class="s1">_insideAux: boolean = false;</span><span class="s3">\n  </span><span class="s1">_parenPushNewlineState: { printed: boolean } | null = null;</span><span class="s3">\n  </span><span class="s1">_noLineTerminator: boolean = false;</span><span class="s3">\n  </span><span class="s1">_printAuxAfterOnNextUserNode: boolean = false;</span><span class="s3">\n  </span><span class="s1">_printedComments = new Set&lt;t.Comment&gt;();</span><span class="s3">\n  </span><span class="s1">_endsWithInteger = false;</span><span class="s3">\n  </span><span class="s1">_endsWithWord = false;</span><span class="s3">\n  </span><span class="s1">_lastCommentLine = 0;</span><span class="s3">\n  </span><span class="s1">_endsWithInnerRaw: boolean = false;</span><span class="s3">\n  </span><span class="s1">_indentInnerComments: boolean = true;</span><span class="s3">\n\n  </span><span class="s1">generate(ast: t.Node) {</span><span class="s3">\n    </span><span class="s1">this.print(ast);</span><span class="s3">\n    </span><span class="s1">this._maybeAddAuxComment();</span><span class="s3">\n\n    </span><span class="s1">return this._buf.get();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Increment indent size.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">indent(): void {</span><span class="s3">\n    </span><span class="s1">if (this.format.compact || this.format.concise) return;</span><span class="s3">\n\n    </span><span class="s1">this._indent++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Decrement indent size.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">dedent(): void {</span><span class="s3">\n    </span><span class="s1">if (this.format.compact || this.format.concise) return;</span><span class="s3">\n\n    </span><span class="s1">this._indent--;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Add a semicolon to the buffer.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">semicolon(force: boolean = false): void {</span><span class="s3">\n    </span><span class="s1">this._maybeAddAuxComment();</span><span class="s3">\n    </span><span class="s1">if (force) {</span><span class="s3">\n      </span><span class="s1">this._appendChar(charCodes.semicolon);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this._queue(charCodes.semicolon);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._noLineTerminator = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Add a right brace to the buffer.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">rightBrace(node: t.Node): void {</span><span class="s3">\n    </span><span class="s1">if (this.format.minified) {</span><span class="s3">\n      </span><span class="s1">this._buf.removeLastSemicolon();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.sourceWithOffset(</span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">, node.loc, -1);</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">rightParens(node: t.Node): void {</span><span class="s3">\n    </span><span class="s1">this.sourceWithOffset(</span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">, node.loc, -1);</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Add a space to the buffer unless it is compact.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">space(force: boolean = false): void {</span><span class="s3">\n    </span><span class="s1">if (this.format.compact) return;</span><span class="s3">\n\n    </span><span class="s1">if (force) {</span><span class="s3">\n      </span><span class="s1">this._space();</span><span class="s3">\n    </span><span class="s1">} else if (this._buf.hasContent()) {</span><span class="s3">\n      </span><span class="s1">const lastCp = this.getLastChar();</span><span class="s3">\n      </span><span class="s1">if (lastCp !== charCodes.space &amp;&amp; lastCp !== charCodes.lineFeed) {</span><span class="s3">\n        </span><span class="s1">this._space();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Writes a token that can't be safely parsed without taking whitespace into account.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">word(str: string, noLineTerminatorAfter: boolean = false): void {</span><span class="s3">\n    </span><span class="s1">this._maybePrintInnerComments();</span><span class="s3">\n\n    </span><span class="s1">// prevent concatenating words and creating // comment out of division and regex</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this._endsWithWord ||</span><span class="s3">\n      </span><span class="s1">(str.charCodeAt(0) === charCodes.slash &amp;&amp; this.endsWith(charCodes.slash))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this._space();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._maybeAddAuxComment();</span><span class="s3">\n    </span><span class="s1">this._append(str, false);</span><span class="s3">\n\n    </span><span class="s1">this._endsWithWord = true;</span><span class="s3">\n    </span><span class="s1">this._noLineTerminator = noLineTerminatorAfter;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Writes a number token so that we can validate if it is an integer.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">number(str: string): void {</span><span class="s3">\n    </span><span class="s1">this.word(str);</span><span class="s3">\n\n    </span><span class="s1">// Integer tokens need special handling because they cannot have '.'s inserted</span><span class="s3">\n    </span><span class="s1">// immediately after them.</span><span class="s3">\n    </span><span class="s1">this._endsWithInteger =</span><span class="s3">\n      </span><span class="s1">Number.isInteger(+str) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!NON_DECIMAL_LITERAL.test(str) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!SCIENTIFIC_NOTATION.test(str) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!ZERO_DECIMAL_INTEGER.test(str) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">str.charCodeAt(str.length - 1) !== charCodes.dot;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Writes a simple token.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">token(str: string, maybeNewline = false): void {</span><span class="s3">\n    </span><span class="s1">this._maybePrintInnerComments();</span><span class="s3">\n\n    </span><span class="s1">const lastChar = this.getLastChar();</span><span class="s3">\n    </span><span class="s1">const strFirst = str.charCodeAt(0);</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(lastChar === charCodes.exclamationMark &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// space is mandatory to avoid outputting &lt;!--</span><span class="s3">\n        </span><span class="s1">// http://javascript.spec.whatwg.org/#comment-syntax</span><span class="s3">\n        </span><span class="s1">(str === </span><span class="s3">\&quot;</span><span class="s1">--</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n          </span><span class="s1">// Needs spaces to avoid changing a! == 0 to a!== 0</span><span class="s3">\n          </span><span class="s1">strFirst === charCodes.equalsTo)) ||</span><span class="s3">\n      </span><span class="s1">// Need spaces for operators of the same kind to avoid: `a+++b`</span><span class="s3">\n      </span><span class="s1">(strFirst === charCodes.plusSign &amp;&amp; lastChar === charCodes.plusSign) ||</span><span class="s3">\n      </span><span class="s1">(strFirst === charCodes.dash &amp;&amp; lastChar === charCodes.dash) ||</span><span class="s3">\n      </span><span class="s1">// Needs spaces to avoid changing '34' to '34.', which would still be a valid number.</span><span class="s3">\n      </span><span class="s1">(strFirst === charCodes.dot &amp;&amp; this._endsWithInteger)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this._space();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._maybeAddAuxComment();</span><span class="s3">\n    </span><span class="s1">this._append(str, maybeNewline);</span><span class="s3">\n    </span><span class="s1">this._noLineTerminator = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">tokenChar(char: number): void {</span><span class="s3">\n    </span><span class="s1">this._maybePrintInnerComments();</span><span class="s3">\n\n    </span><span class="s1">const lastChar = this.getLastChar();</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// Need spaces for operators of the same kind to avoid: `a+++b`</span><span class="s3">\n      </span><span class="s1">(char === charCodes.plusSign &amp;&amp; lastChar === charCodes.plusSign) ||</span><span class="s3">\n      </span><span class="s1">(char === charCodes.dash &amp;&amp; lastChar === charCodes.dash) ||</span><span class="s3">\n      </span><span class="s1">// Needs spaces to avoid changing '34' to '34.', which would still be a valid number.</span><span class="s3">\n      </span><span class="s1">(char === charCodes.dot &amp;&amp; this._endsWithInteger)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this._space();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._maybeAddAuxComment();</span><span class="s3">\n    </span><span class="s1">this._appendChar(char);</span><span class="s3">\n    </span><span class="s1">this._noLineTerminator = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Add a newline (or many newlines), maintaining formatting.</span><span class="s3">\n   </span><span class="s1">* This function checks the number of newlines in the queue and subtracts them.</span><span class="s3">\n   </span><span class="s1">* It currently has some limitations.</span><span class="s3">\n   </span><span class="s1">* @see {Buffer#getNewlineCount}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">newline(i: number = 1, force?: boolean): void {</span><span class="s3">\n    </span><span class="s1">if (i &lt;= 0) return;</span><span class="s3">\n\n    </span><span class="s1">if (!force) {</span><span class="s3">\n      </span><span class="s1">if (this.format.retainLines || this.format.compact) return;</span><span class="s3">\n\n      </span><span class="s1">if (this.format.concise) {</span><span class="s3">\n        </span><span class="s1">this.space();</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (i &gt; 2) i = 2; // Max two lines</span><span class="s3">\n\n    </span><span class="s1">i -= this._buf.getNewlineCount();</span><span class="s3">\n\n    </span><span class="s1">for (let j = 0; j &lt; i; j++) {</span><span class="s3">\n      </span><span class="s1">this._newline();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">endsWith(char: number): boolean {</span><span class="s3">\n    </span><span class="s1">return this.getLastChar() === char;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getLastChar(): number {</span><span class="s3">\n    </span><span class="s1">return this._buf.getLastChar();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">endsWithCharAndNewline(): number {</span><span class="s3">\n    </span><span class="s1">return this._buf.endsWithCharAndNewline();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">removeTrailingNewline(): void {</span><span class="s3">\n    </span><span class="s1">this._buf.removeTrailingNewline();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">exactSource(loc: Loc | undefined, cb: () =&gt; void) {</span><span class="s3">\n    </span><span class="s1">if (!loc) {</span><span class="s3">\n      </span><span class="s1">cb();</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._catchUp(</span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot;</span><span class="s1">, loc);</span><span class="s3">\n\n    </span><span class="s1">this._buf.exactSource(loc, cb);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">source(prop: </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">, loc: Loc | undefined): void {</span><span class="s3">\n    </span><span class="s1">if (!loc) return;</span><span class="s3">\n\n    </span><span class="s1">this._catchUp(prop, loc);</span><span class="s3">\n\n    </span><span class="s1">this._buf.source(prop, loc);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">sourceWithOffset(</span><span class="s3">\n    </span><span class="s1">prop: </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">loc: Loc | undefined,</span><span class="s3">\n    </span><span class="s1">columnOffset: number,</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">if (!loc) return;</span><span class="s3">\n\n    </span><span class="s1">this._catchUp(prop, loc);</span><span class="s3">\n\n    </span><span class="s1">this._buf.sourceWithOffset(prop, loc, columnOffset);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">withSource(</span><span class="s3">\n    </span><span class="s1">prop: </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">loc: Loc | undefined,</span><span class="s3">\n    </span><span class="s1">cb: () =&gt; void,</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">if (!loc) {</span><span class="s3">\n      </span><span class="s1">cb();</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._catchUp(prop, loc);</span><span class="s3">\n\n    </span><span class="s1">this._buf.withSource(prop, loc, cb);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">sourceIdentifierName(identifierName: string, pos?: Pos): void {</span><span class="s3">\n    </span><span class="s1">if (!this._buf._canMarkIdName) return;</span><span class="s3">\n\n    </span><span class="s1">const sourcePosition = this._buf._sourcePosition;</span><span class="s3">\n    </span><span class="s1">sourcePosition.identifierNamePos = pos;</span><span class="s3">\n    </span><span class="s1">sourcePosition.identifierName = identifierName;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_space(): void {</span><span class="s3">\n    </span><span class="s1">this._queue(charCodes.space);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_newline(): void {</span><span class="s3">\n    </span><span class="s1">this._queue(charCodes.lineFeed);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_append(str: string, maybeNewline: boolean): void {</span><span class="s3">\n    </span><span class="s1">this._maybeAddParen(str);</span><span class="s3">\n    </span><span class="s1">this._maybeIndent(str.charCodeAt(0));</span><span class="s3">\n\n    </span><span class="s1">this._buf.append(str, maybeNewline);</span><span class="s3">\n\n    </span><span class="s1">this._endsWithWord = false;</span><span class="s3">\n    </span><span class="s1">this._endsWithInteger = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_appendChar(char: number): void {</span><span class="s3">\n    </span><span class="s1">this._maybeAddParenChar(char);</span><span class="s3">\n    </span><span class="s1">this._maybeIndent(char);</span><span class="s3">\n\n    </span><span class="s1">this._buf.appendChar(char);</span><span class="s3">\n\n    </span><span class="s1">this._endsWithWord = false;</span><span class="s3">\n    </span><span class="s1">this._endsWithInteger = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_queue(char: number) {</span><span class="s3">\n    </span><span class="s1">this._maybeAddParenChar(char);</span><span class="s3">\n    </span><span class="s1">this._maybeIndent(char);</span><span class="s3">\n\n    </span><span class="s1">this._buf.queue(char);</span><span class="s3">\n\n    </span><span class="s1">this._endsWithWord = false;</span><span class="s3">\n    </span><span class="s1">this._endsWithInteger = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_maybeIndent(firstChar: number): void {</span><span class="s3">\n    </span><span class="s1">// we've got a newline before us so prepend on the indentation</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this._indent &amp;&amp;</span><span class="s3">\n      </span><span class="s1">firstChar !== charCodes.lineFeed &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.endsWith(charCodes.lineFeed)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this._buf.queueIndentation(this._indentChar, this._getIndent());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_shouldIndent(firstChar: number) {</span><span class="s3">\n    </span><span class="s1">// we've got a newline before us so prepend on the indentation</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this._indent &amp;&amp;</span><span class="s3">\n      </span><span class="s1">firstChar !== charCodes.lineFeed &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.endsWith(charCodes.lineFeed)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_maybeAddParenChar(char: number): void {</span><span class="s3">\n    </span><span class="s1">// see startTerminatorless() instance method</span><span class="s3">\n    </span><span class="s1">const parenPushNewlineState = this._parenPushNewlineState;</span><span class="s3">\n    </span><span class="s1">if (!parenPushNewlineState) return;</span><span class="s3">\n\n    </span><span class="s1">// This function does two things:</span><span class="s3">\n    </span><span class="s1">// - If needed, prints a parenthesis</span><span class="s3">\n    </span><span class="s1">// - If the currently printed string removes the need for the paren,</span><span class="s3">\n    </span><span class="s1">//   it resets the _parenPushNewlineState field.</span><span class="s3">\n    </span><span class="s1">//   Almost everything removes the need for a paren, except for</span><span class="s3">\n    </span><span class="s1">//   comments and whitespaces.</span><span class="s3">\n\n    </span><span class="s1">if (char === charCodes.space) {</span><span class="s3">\n      </span><span class="s1">// Whitespaces only, the parentheses might still be needed.</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Check for newline or comment.</span><span class="s3">\n    </span><span class="s1">if (char !== charCodes.lineFeed) {</span><span class="s3">\n      </span><span class="s1">this._parenPushNewlineState = null;</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.indent();</span><span class="s3">\n    </span><span class="s1">parenPushNewlineState.printed = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_maybeAddParen(str: string): void {</span><span class="s3">\n    </span><span class="s1">// see startTerminatorless() instance method</span><span class="s3">\n    </span><span class="s1">const parenPushNewlineState = this._parenPushNewlineState;</span><span class="s3">\n    </span><span class="s1">if (!parenPushNewlineState) return;</span><span class="s3">\n\n    </span><span class="s1">// This function does two things:</span><span class="s3">\n    </span><span class="s1">// - If needed, prints a parenthesis</span><span class="s3">\n    </span><span class="s1">// - If the currently printed string removes the need for the paren,</span><span class="s3">\n    </span><span class="s1">//   it resets the _parenPushNewlineState field.</span><span class="s3">\n    </span><span class="s1">//   Almost everything removes the need for a paren, except for</span><span class="s3">\n    </span><span class="s1">//   comments and whitespaces.</span><span class="s3">\n\n    </span><span class="s1">const len = str.length;</span><span class="s3">\n\n    </span><span class="s1">let i;</span><span class="s3">\n    </span><span class="s1">for (i = 0; i &lt; len &amp;&amp; str.charCodeAt(i) === charCodes.space; i++) continue;</span><span class="s3">\n    </span><span class="s1">if (i === len) {</span><span class="s3">\n      </span><span class="s1">// Whitespaces only, the parentheses might still be needed.</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Check for newline or comment.</span><span class="s3">\n    </span><span class="s1">const cha = str.charCodeAt(i);</span><span class="s3">\n    </span><span class="s1">if (cha !== charCodes.lineFeed) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">// This is not a comment (it doesn't start with /)</span><span class="s3">\n        </span><span class="s1">cha !== charCodes.slash ||</span><span class="s3">\n        </span><span class="s1">// This is not a comment (it's a / operator)</span><span class="s3">\n        </span><span class="s1">i + 1 === len</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// After a normal token, the parentheses aren't needed anymore</span><span class="s3">\n        </span><span class="s1">this._parenPushNewlineState = null;</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const chaPost = str.charCodeAt(i + 1);</span><span class="s3">\n\n      </span><span class="s1">if (chaPost === charCodes.asterisk) {</span><span class="s3">\n        </span><span class="s1">// This is a block comment</span><span class="s3">\n\n        </span><span class="s1">if (PURE_ANNOTATION_RE.test(str.slice(i + 2, len - 2))) {</span><span class="s3">\n          </span><span class="s1">// We avoid printing newlines after #__PURE__ comments (we treat</span><span class="s3">\n          </span><span class="s1">// then as unary operators), but we must keep the old</span><span class="s3">\n          </span><span class="s1">// parenPushNewlineState because, if a newline was forbidden, it is</span><span class="s3">\n          </span><span class="s1">// still forbidden after the comment.</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// NOTE: code flow continues from here to after these if/elses</span><span class="s3">\n      </span><span class="s1">} else if (chaPost !== charCodes.slash) {</span><span class="s3">\n        </span><span class="s1">// This is neither a block comment, nor a line comment.</span><span class="s3">\n        </span><span class="s1">// After a normal token, the parentheses aren't needed anymore</span><span class="s3">\n        </span><span class="s1">this._parenPushNewlineState = null;</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.indent();</span><span class="s3">\n    </span><span class="s1">parenPushNewlineState.printed = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">catchUp(line: number) {</span><span class="s3">\n    </span><span class="s1">if (!this.format.retainLines) return;</span><span class="s3">\n\n    </span><span class="s1">// catch up to this nodes newline if we're behind</span><span class="s3">\n    </span><span class="s1">const count = line - this._buf.getCurrentLine();</span><span class="s3">\n\n    </span><span class="s1">for (let i = 0; i &lt; count; i++) {</span><span class="s3">\n      </span><span class="s1">this._newline();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_catchUp(prop: </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">, loc?: Loc) {</span><span class="s3">\n    </span><span class="s1">if (!this.format.retainLines) return;</span><span class="s3">\n\n    </span><span class="s1">// catch up to this nodes newline if we're behind</span><span class="s3">\n    </span><span class="s1">const line = loc?.[prop]?.line;</span><span class="s3">\n    </span><span class="s1">if (line != null) {</span><span class="s3">\n      </span><span class="s1">const count = line - this._buf.getCurrentLine();</span><span class="s3">\n\n      </span><span class="s1">for (let i = 0; i &lt; count; i++) {</span><span class="s3">\n        </span><span class="s1">this._newline();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Get the current indent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">_getIndent(): number {</span><span class="s3">\n    </span><span class="s1">return this._indentRepeat * this._indent;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">printTerminatorless(node: t.Node, parent: t.Node, isLabel: boolean) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set some state that will be modified if a newline has been inserted before any</span><span class="s3">\n     </span><span class="s1">* non-space characters.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* This is to prevent breaking semantics for terminatorless separator nodes. eg:</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">*   return foo;</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* returns `foo`. But if we do:</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">*   return</span><span class="s3">\n     </span><span class="s1">*   foo;</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">*  `undefined` will be returned and not `foo` due to the terminator.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (isLabel) {</span><span class="s3">\n      </span><span class="s1">this._noLineTerminator = true;</span><span class="s3">\n      </span><span class="s1">this.print(node, parent);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const terminatorState = {</span><span class="s3">\n        </span><span class="s1">printed: false,</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">this._parenPushNewlineState = terminatorState;</span><span class="s3">\n      </span><span class="s1">this.print(node, parent);</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* Print an ending parentheses if a starting one has been printed.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">if (terminatorState.printed) {</span><span class="s3">\n        </span><span class="s1">this.dedent();</span><span class="s3">\n        </span><span class="s1">this.newline();</span><span class="s3">\n        </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">print(</span><span class="s3">\n    </span><span class="s1">node: t.Node | null,</span><span class="s3">\n    </span><span class="s1">parent?: t.Node,</span><span class="s3">\n    </span><span class="s1">noLineTerminatorAfter?: boolean,</span><span class="s3">\n    </span><span class="s1">// trailingCommentsLineOffset also used to check if called from printJoin</span><span class="s3">\n    </span><span class="s1">// it will be ignored if `noLineTerminatorAfter||this._noLineTerminator`</span><span class="s3">\n    </span><span class="s1">trailingCommentsLineOffset?: number,</span><span class="s3">\n    </span><span class="s1">forceParens?: boolean,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!node) return;</span><span class="s3">\n\n    </span><span class="s1">this._endsWithInnerRaw = false;</span><span class="s3">\n\n    </span><span class="s1">const nodeType = node.type;</span><span class="s3">\n    </span><span class="s1">const format = this.format;</span><span class="s3">\n\n    </span><span class="s1">const oldConcise = format.concise;</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error document _compact AST properties</span><span class="s3">\n      </span><span class="s1">node._compact</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">format.concise = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const printMethod =</span><span class="s3">\n      </span><span class="s1">this[</span><span class="s3">\n        </span><span class="s1">nodeType as Exclude&lt;</span><span class="s3">\n          </span><span class="s1">t.Node[</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n          </span><span class="s1">// removed</span><span class="s3">\n          </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">Noop</span><span class="s3">\&quot;\n          </span><span class="s1">// renamed</span><span class="s3">\n          </span><span class="s1">| t.DeprecatedAliases[</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">&gt;</span><span class="s3">\n      </span><span class="s1">];</span><span class="s3">\n    </span><span class="s1">if (printMethod === undefined) {</span><span class="s3">\n      </span><span class="s1">throw new ReferenceError(</span><span class="s3">\n        </span><span class="s1">`unknown node of type ${JSON.stringify(</span><span class="s3">\n          </span><span class="s1">nodeType,</span><span class="s3">\n        </span><span class="s1">)} with constructor ${JSON.stringify(node.constructor.name)}`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._printStack.push(node);</span><span class="s3">\n\n    </span><span class="s1">const oldInAux = this._insideAux;</span><span class="s3">\n    </span><span class="s1">this._insideAux = node.loc == undefined;</span><span class="s3">\n    </span><span class="s1">this._maybeAddAuxComment(this._insideAux &amp;&amp; !oldInAux);</span><span class="s3">\n\n    </span><span class="s1">const shouldPrintParens =</span><span class="s3">\n      </span><span class="s1">forceParens ||</span><span class="s3">\n      </span><span class="s1">(format.retainFunctionParens &amp;&amp;</span><span class="s3">\n        </span><span class="s1">nodeType === </span><span class="s3">\&quot;</span><span class="s1">FunctionExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">node.extra?.parenthesized) ||</span><span class="s3">\n      </span><span class="s1">needsParens(node, parent, this._printStack);</span><span class="s3">\n\n    </span><span class="s1">if (shouldPrintParens) {</span><span class="s3">\n      </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">this._endsWithInnerRaw = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._lastCommentLine = 0;</span><span class="s3">\n\n    </span><span class="s1">this._printLeadingComments(node, parent);</span><span class="s3">\n\n    </span><span class="s1">const loc = nodeType === </span><span class="s3">\&quot;</span><span class="s1">Program</span><span class="s3">\&quot; </span><span class="s1">|| nodeType === </span><span class="s3">\&quot;</span><span class="s1">File</span><span class="s3">\&quot; </span><span class="s1">? null : node.loc;</span><span class="s3">\n\n    </span><span class="s1">this.exactSource(loc, printMethod.bind(this, node, parent));</span><span class="s3">\n\n    </span><span class="s1">if (shouldPrintParens) {</span><span class="s3">\n      </span><span class="s1">this._printTrailingComments(node, parent);</span><span class="s3">\n      </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">this._noLineTerminator = noLineTerminatorAfter;</span><span class="s3">\n    </span><span class="s1">} else if (noLineTerminatorAfter &amp;&amp; !this._noLineTerminator) {</span><span class="s3">\n      </span><span class="s1">this._noLineTerminator = true;</span><span class="s3">\n      </span><span class="s1">this._printTrailingComments(node, parent);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this._printTrailingComments(node, parent, trailingCommentsLineOffset);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// end</span><span class="s3">\n    </span><span class="s1">this._printStack.pop();</span><span class="s3">\n\n    </span><span class="s1">format.concise = oldConcise;</span><span class="s3">\n    </span><span class="s1">this._insideAux = oldInAux;</span><span class="s3">\n\n    </span><span class="s1">this._endsWithInnerRaw = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_maybeAddAuxComment(enteredPositionlessNode?: boolean) {</span><span class="s3">\n    </span><span class="s1">if (enteredPositionlessNode) this._printAuxBeforeComment();</span><span class="s3">\n    </span><span class="s1">if (!this._insideAux) this._printAuxAfterComment();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_printAuxBeforeComment() {</span><span class="s3">\n    </span><span class="s1">if (this._printAuxAfterOnNextUserNode) return;</span><span class="s3">\n    </span><span class="s1">this._printAuxAfterOnNextUserNode = true;</span><span class="s3">\n\n    </span><span class="s1">const comment = this.format.auxiliaryCommentBefore;</span><span class="s3">\n    </span><span class="s1">if (comment) {</span><span class="s3">\n      </span><span class="s1">this._printComment(</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">CommentBlock</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">value: comment,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">COMMENT_SKIP_NEWLINE.DEFAULT,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_printAuxAfterComment() {</span><span class="s3">\n    </span><span class="s1">if (!this._printAuxAfterOnNextUserNode) return;</span><span class="s3">\n    </span><span class="s1">this._printAuxAfterOnNextUserNode = false;</span><span class="s3">\n\n    </span><span class="s1">const comment = this.format.auxiliaryCommentAfter;</span><span class="s3">\n    </span><span class="s1">if (comment) {</span><span class="s3">\n      </span><span class="s1">this._printComment(</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">CommentBlock</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">value: comment,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">COMMENT_SKIP_NEWLINE.DEFAULT,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getPossibleRaw(</span><span class="s3">\n    </span><span class="s1">node:</span><span class="s3">\n      </span><span class="s1">| t.StringLiteral</span><span class="s3">\n      </span><span class="s1">| t.NumericLiteral</span><span class="s3">\n      </span><span class="s1">| t.BigIntLiteral</span><span class="s3">\n      </span><span class="s1">| t.DecimalLiteral</span><span class="s3">\n      </span><span class="s1">| t.DirectiveLiteral</span><span class="s3">\n      </span><span class="s1">| t.JSXText,</span><span class="s3">\n  </span><span class="s1">): string | undefined {</span><span class="s3">\n    </span><span class="s1">const extra = node.extra;</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">extra?.raw != null &amp;&amp;</span><span class="s3">\n      </span><span class="s1">extra.rawValue != null &amp;&amp;</span><span class="s3">\n      </span><span class="s1">node.value === extra.rawValue</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error: The extra.raw of these AST node types must be a string</span><span class="s3">\n      </span><span class="s1">return extra.raw;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">printJoin(</span><span class="s3">\n    </span><span class="s1">nodes: Array&lt;t.Node&gt; | undefined | null,</span><span class="s3">\n    </span><span class="s1">parent: t.Node,</span><span class="s3">\n    </span><span class="s1">opts: PrintJoinOptions = {},</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!nodes?.length) return;</span><span class="s3">\n\n    </span><span class="s1">let { indent } = opts;</span><span class="s3">\n\n    </span><span class="s1">if (indent == null &amp;&amp; this.format.retainLines) {</span><span class="s3">\n      </span><span class="s1">const startLine = nodes[0].loc?.start.line;</span><span class="s3">\n      </span><span class="s1">if (startLine != null &amp;&amp; startLine !== this._buf.getCurrentLine()) {</span><span class="s3">\n        </span><span class="s1">indent = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (indent) this.indent();</span><span class="s3">\n\n    </span><span class="s1">const newlineOpts: AddNewlinesOptions = {</span><span class="s3">\n      </span><span class="s1">addNewlines: opts.addNewlines,</span><span class="s3">\n      </span><span class="s1">nextNodeStartLine: 0,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">const separator = opts.separator ? opts.separator.bind(this) : null;</span><span class="s3">\n\n    </span><span class="s1">const len = nodes.length;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n      </span><span class="s1">const node = nodes[i];</span><span class="s3">\n      </span><span class="s1">if (!node) continue;</span><span class="s3">\n\n      </span><span class="s1">if (opts.statement) this._printNewline(i === 0, newlineOpts);</span><span class="s3">\n\n      </span><span class="s1">this.print(node, parent, undefined, opts.trailingCommentsLineOffset || 0);</span><span class="s3">\n\n      </span><span class="s1">opts.iterator?.(node, i);</span><span class="s3">\n\n      </span><span class="s1">if (i &lt; len - 1) separator?.();</span><span class="s3">\n\n      </span><span class="s1">if (opts.statement) {</span><span class="s3">\n        </span><span class="s1">if (i + 1 === len) {</span><span class="s3">\n          </span><span class="s1">this.newline(1);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const nextNode = nodes[i + 1];</span><span class="s3">\n          </span><span class="s1">newlineOpts.nextNodeStartLine = nextNode.loc?.start.line || 0;</span><span class="s3">\n\n          </span><span class="s1">this._printNewline(true, newlineOpts);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (indent) this.dedent();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">printAndIndentOnComments(node: t.Node, parent: t.Node) {</span><span class="s3">\n    </span><span class="s1">const indent = node.leadingComments &amp;&amp; node.leadingComments.length &gt; 0;</span><span class="s3">\n    </span><span class="s1">if (indent) this.indent();</span><span class="s3">\n    </span><span class="s1">this.print(node, parent);</span><span class="s3">\n    </span><span class="s1">if (indent) this.dedent();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">printBlock(parent: Extract&lt;t.Node, { body: t.Statement }&gt;) {</span><span class="s3">\n    </span><span class="s1">const node = parent.body;</span><span class="s3">\n\n    </span><span class="s1">if (node.type !== </span><span class="s3">\&quot;</span><span class="s1">EmptyStatement</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.print(node, parent);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_printTrailingComments(node: t.Node, parent?: t.Node, lineOffset?: number) {</span><span class="s3">\n    </span><span class="s1">const { innerComments, trailingComments } = node;</span><span class="s3">\n    </span><span class="s1">// We print inner comments here, so that if for some reason they couldn't</span><span class="s3">\n    </span><span class="s1">// be printed in earlier locations they are still printed *somewhere*,</span><span class="s3">\n    </span><span class="s1">// even if at the end of the node.</span><span class="s3">\n    </span><span class="s1">if (innerComments?.length) {</span><span class="s3">\n      </span><span class="s1">this._printComments(</span><span class="s3">\n        </span><span class="s1">COMMENT_TYPE.TRAILING,</span><span class="s3">\n        </span><span class="s1">innerComments,</span><span class="s3">\n        </span><span class="s1">node,</span><span class="s3">\n        </span><span class="s1">parent,</span><span class="s3">\n        </span><span class="s1">lineOffset,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (trailingComments?.length) {</span><span class="s3">\n      </span><span class="s1">this._printComments(</span><span class="s3">\n        </span><span class="s1">COMMENT_TYPE.TRAILING,</span><span class="s3">\n        </span><span class="s1">trailingComments,</span><span class="s3">\n        </span><span class="s1">node,</span><span class="s3">\n        </span><span class="s1">parent,</span><span class="s3">\n        </span><span class="s1">lineOffset,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_printLeadingComments(node: t.Node, parent: t.Node) {</span><span class="s3">\n    </span><span class="s1">const comments = node.leadingComments;</span><span class="s3">\n    </span><span class="s1">if (!comments?.length) return;</span><span class="s3">\n    </span><span class="s1">this._printComments(COMMENT_TYPE.LEADING, comments, node, parent);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_maybePrintInnerComments() {</span><span class="s3">\n    </span><span class="s1">if (this._endsWithInnerRaw) this.printInnerComments();</span><span class="s3">\n    </span><span class="s1">this._endsWithInnerRaw = true;</span><span class="s3">\n    </span><span class="s1">this._indentInnerComments = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">printInnerComments() {</span><span class="s3">\n    </span><span class="s1">const node = this._printStack[this._printStack.length - 1];</span><span class="s3">\n    </span><span class="s1">const comments = node.innerComments;</span><span class="s3">\n    </span><span class="s1">if (!comments?.length) return;</span><span class="s3">\n\n    </span><span class="s1">const hasSpace = this.endsWith(charCodes.space);</span><span class="s3">\n    </span><span class="s1">const indent = this._indentInnerComments;</span><span class="s3">\n    </span><span class="s1">const printedCommentsCount = this._printedComments.size;</span><span class="s3">\n    </span><span class="s1">if (indent) this.indent();</span><span class="s3">\n    </span><span class="s1">this._printComments(COMMENT_TYPE.INNER, comments, node);</span><span class="s3">\n    </span><span class="s1">if (hasSpace &amp;&amp; printedCommentsCount !== this._printedComments.size) {</span><span class="s3">\n      </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (indent) this.dedent();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">noIndentInnerCommentsHere() {</span><span class="s3">\n    </span><span class="s1">this._indentInnerComments = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">printSequence(</span><span class="s3">\n    </span><span class="s1">nodes: t.Node[],</span><span class="s3">\n    </span><span class="s1">parent: t.Node,</span><span class="s3">\n    </span><span class="s1">opts: PrintSequenceOptions = {},</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">opts.statement = true;</span><span class="s3">\n    </span><span class="s1">opts.indent ??= false;</span><span class="s3">\n    </span><span class="s1">this.printJoin(nodes, parent, opts);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">printList(items: t.Node[], parent: t.Node, opts: PrintListOptions = {}) {</span><span class="s3">\n    </span><span class="s1">if (opts.separator == null) {</span><span class="s3">\n      </span><span class="s1">opts.separator = commaSeparator;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.printJoin(items, parent, opts);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_printNewline(newLine: boolean, opts: AddNewlinesOptions) {</span><span class="s3">\n    </span><span class="s1">const format = this.format;</span><span class="s3">\n\n    </span><span class="s1">// Fast path since 'this.newline' does nothing when not tracking lines.</span><span class="s3">\n    </span><span class="s1">if (format.retainLines || format.compact) return;</span><span class="s3">\n\n    </span><span class="s1">// Fast path for concise since 'this.newline' just inserts a space when</span><span class="s3">\n    </span><span class="s1">// concise formatting is in use.</span><span class="s3">\n    </span><span class="s1">if (format.concise) {</span><span class="s3">\n      </span><span class="s1">this.space();</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!newLine) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const startLine = opts.nextNodeStartLine;</span><span class="s3">\n    </span><span class="s1">const lastCommentLine = this._lastCommentLine;</span><span class="s3">\n    </span><span class="s1">if (startLine &gt; 0 &amp;&amp; lastCommentLine &gt; 0) {</span><span class="s3">\n      </span><span class="s1">const offset = startLine - lastCommentLine;</span><span class="s3">\n      </span><span class="s1">if (offset &gt;= 0) {</span><span class="s3">\n        </span><span class="s1">this.newline(offset || 1);</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// don't add newlines at the beginning of the file</span><span class="s3">\n    </span><span class="s1">if (this._buf.hasContent()) {</span><span class="s3">\n      </span><span class="s1">// Here is the logic of the original line wrapping according to the node layout, we are not using it now.</span><span class="s3">\n      </span><span class="s1">// We currently add at most one newline to each node in the list, ignoring `opts.addNewlines`.</span><span class="s3">\n\n      </span><span class="s1">// let lines = 0;</span><span class="s3">\n      </span><span class="s1">// if (!leading) lines++; // always include at least a single line after</span><span class="s3">\n      </span><span class="s1">// if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;</span><span class="s3">\n\n      </span><span class="s1">// const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;</span><span class="s3">\n      </span><span class="s1">// if (needs(node, parent)) lines++;</span><span class="s3">\n\n      </span><span class="s1">// this.newline(Math.min(2, lines));</span><span class="s3">\n\n      </span><span class="s1">this.newline(1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Returns `PRINT_COMMENT_HINT.DEFER` if the comment cannot be printed in this position due to</span><span class="s3">\n  </span><span class="s1">// line terminators, signaling that the print comments loop can stop and</span><span class="s3">\n  </span><span class="s1">// resume printing comments at the next possible position. This happens when</span><span class="s3">\n  </span><span class="s1">// printing inner comments, since if we have an inner comment with a multiline</span><span class="s3">\n  </span><span class="s1">// there is at least one inner position where line terminators are allowed.</span><span class="s3">\n  </span><span class="s1">_shouldPrintComment(comment: t.Comment): PRINT_COMMENT_HINT {</span><span class="s3">\n    </span><span class="s1">// Some plugins (such as flow-strip-types) use this to mark comments as removed using the AST-root 'comments' property,</span><span class="s3">\n    </span><span class="s1">// where they can't manually mutate the AST node comment lists.</span><span class="s3">\n    </span><span class="s1">if (comment.ignore) return PRINT_COMMENT_HINT.SKIP;</span><span class="s3">\n\n    </span><span class="s1">if (this._printedComments.has(comment)) return PRINT_COMMENT_HINT.SKIP;</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this._noLineTerminator &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(HAS_NEWLINE.test(comment.value) ||</span><span class="s3">\n        </span><span class="s1">HAS_BlOCK_COMMENT_END.test(comment.value))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return PRINT_COMMENT_HINT.DEFER;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._printedComments.add(comment);</span><span class="s3">\n\n    </span><span class="s1">if (!this.format.shouldPrintComment(comment.value)) {</span><span class="s3">\n      </span><span class="s1">return PRINT_COMMENT_HINT.SKIP;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return PRINT_COMMENT_HINT.ALLOW;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_printComment(comment: t.Comment, skipNewLines: COMMENT_SKIP_NEWLINE) {</span><span class="s3">\n    </span><span class="s1">const noLineTerminator = this._noLineTerminator;</span><span class="s3">\n    </span><span class="s1">const isBlockComment = comment.type === </span><span class="s3">\&quot;</span><span class="s1">CommentBlock</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">// Add a newline before and after a block comment, unless explicitly</span><span class="s3">\n    </span><span class="s1">// disallowed</span><span class="s3">\n    </span><span class="s1">const printNewLines =</span><span class="s3">\n      </span><span class="s1">isBlockComment &amp;&amp;</span><span class="s3">\n      </span><span class="s1">skipNewLines !== COMMENT_SKIP_NEWLINE.ALL &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!this._noLineTerminator;</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">printNewLines &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this._buf.hasContent() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">skipNewLines !== COMMENT_SKIP_NEWLINE.LEADING</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this.newline(1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const lastCharCode = this.getLastChar();</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">lastCharCode !== charCodes.leftSquareBracket &amp;&amp;</span><span class="s3">\n      </span><span class="s1">lastCharCode !== charCodes.leftCurlyBrace</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let val;</span><span class="s3">\n    </span><span class="s1">if (isBlockComment) {</span><span class="s3">\n      </span><span class="s1">val = `/*${comment.value}*/`;</span><span class="s3">\n      </span><span class="s1">if (this.format.indent.adjustMultilineComment) {</span><span class="s3">\n        </span><span class="s1">const offset = comment.loc?.start.column;</span><span class="s3">\n        </span><span class="s1">if (offset) {</span><span class="s3">\n          </span><span class="s1">const newlineRegex = new RegExp(</span><span class="s3">\&quot;\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s{1,</span><span class="s3">\&quot; </span><span class="s1">+ offset + </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">val = val.replace(newlineRegex, </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">let indentSize = this.format.retainLines</span><span class="s3">\n          </span><span class="s1">? 0</span><span class="s3">\n          </span><span class="s1">: this._buf.getCurrentColumn();</span><span class="s3">\n\n        </span><span class="s1">if (this._shouldIndent(charCodes.slash) || this.format.retainLines) {</span><span class="s3">\n          </span><span class="s1">indentSize += this._getIndent();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">val = val.replace(/</span><span class="s3">\\</span><span class="s1">n(?!$)/g, `</span><span class="s3">\\</span><span class="s1">n${</span><span class="s3">\&quot; \&quot;</span><span class="s1">.repeat(indentSize)}`);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (!noLineTerminator) {</span><span class="s3">\n      </span><span class="s1">val = `//${comment.value}`;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// It was a single-line comment, so it's guaranteed to not</span><span class="s3">\n      </span><span class="s1">// contain newlines and it can be safely printed as a block</span><span class="s3">\n      </span><span class="s1">// comment.</span><span class="s3">\n      </span><span class="s1">val = `/*${comment.value}*/`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Avoid creating //* comments</span><span class="s3">\n    </span><span class="s1">if (this.endsWith(charCodes.slash)) this._space();</span><span class="s3">\n\n    </span><span class="s1">this.source(</span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot;</span><span class="s1">, comment.loc);</span><span class="s3">\n    </span><span class="s1">this._append(val, isBlockComment);</span><span class="s3">\n\n    </span><span class="s1">if (!isBlockComment &amp;&amp; !noLineTerminator) {</span><span class="s3">\n      </span><span class="s1">this.newline(1, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (printNewLines &amp;&amp; skipNewLines !== COMMENT_SKIP_NEWLINE.TRAILING) {</span><span class="s3">\n      </span><span class="s1">this.newline(1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_printComments(</span><span class="s3">\n    </span><span class="s1">type: COMMENT_TYPE,</span><span class="s3">\n    </span><span class="s1">comments: readonly t.Comment[],</span><span class="s3">\n    </span><span class="s1">node: t.Node,</span><span class="s3">\n    </span><span class="s1">parent?: t.Node,</span><span class="s3">\n    </span><span class="s1">lineOffset: number = 0,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const nodeLoc = node.loc;</span><span class="s3">\n    </span><span class="s1">const len = comments.length;</span><span class="s3">\n    </span><span class="s1">let hasLoc = !!nodeLoc;</span><span class="s3">\n    </span><span class="s1">const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;</span><span class="s3">\n    </span><span class="s1">const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;</span><span class="s3">\n    </span><span class="s1">let lastLine = 0;</span><span class="s3">\n    </span><span class="s1">let leadingCommentNewline = 0;</span><span class="s3">\n\n    </span><span class="s1">const maybeNewline = this._noLineTerminator</span><span class="s3">\n      </span><span class="s1">? function () {}</span><span class="s3">\n      </span><span class="s1">: this.newline.bind(this);</span><span class="s3">\n\n    </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n      </span><span class="s1">const comment = comments[i];</span><span class="s3">\n\n      </span><span class="s1">const shouldPrint = this._shouldPrintComment(comment);</span><span class="s3">\n      </span><span class="s1">if (shouldPrint === PRINT_COMMENT_HINT.DEFER) {</span><span class="s3">\n        </span><span class="s1">hasLoc = false;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (hasLoc &amp;&amp; comment.loc &amp;&amp; shouldPrint === PRINT_COMMENT_HINT.ALLOW) {</span><span class="s3">\n        </span><span class="s1">const commentStartLine = comment.loc.start.line;</span><span class="s3">\n        </span><span class="s1">const commentEndLine = comment.loc.end.line;</span><span class="s3">\n        </span><span class="s1">if (type === COMMENT_TYPE.LEADING) {</span><span class="s3">\n          </span><span class="s1">let offset = 0;</span><span class="s3">\n          </span><span class="s1">if (i === 0) {</span><span class="s3">\n            </span><span class="s1">// Because currently we cannot handle blank lines before leading comments,</span><span class="s3">\n            </span><span class="s1">// we always wrap before and after multi-line comments.</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">this._buf.hasContent() &amp;&amp;</span><span class="s3">\n              </span><span class="s1">(comment.type === </span><span class="s3">\&quot;</span><span class="s1">CommentLine</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n                </span><span class="s1">commentStartLine != commentEndLine)</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">offset = leadingCommentNewline = 1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">offset = commentStartLine - lastLine;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">lastLine = commentEndLine;</span><span class="s3">\n\n          </span><span class="s1">maybeNewline(offset);</span><span class="s3">\n          </span><span class="s1">this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);</span><span class="s3">\n\n          </span><span class="s1">if (i + 1 === len) {</span><span class="s3">\n            </span><span class="s1">maybeNewline(</span><span class="s3">\n              </span><span class="s1">Math.max(nodeStartLine - lastLine, leadingCommentNewline),</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">lastLine = nodeStartLine;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (type === COMMENT_TYPE.INNER) {</span><span class="s3">\n          </span><span class="s1">const offset =</span><span class="s3">\n            </span><span class="s1">commentStartLine - (i === 0 ? nodeStartLine : lastLine);</span><span class="s3">\n          </span><span class="s1">lastLine = commentEndLine;</span><span class="s3">\n\n          </span><span class="s1">maybeNewline(offset);</span><span class="s3">\n          </span><span class="s1">this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);</span><span class="s3">\n\n          </span><span class="s1">if (i + 1 === len) {</span><span class="s3">\n            </span><span class="s1">maybeNewline(Math.min(1, nodeEndLine - lastLine)); // TODO: Improve here when inner comments processing is stronger</span><span class="s3">\n            </span><span class="s1">lastLine = nodeEndLine;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const offset =</span><span class="s3">\n            </span><span class="s1">commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);</span><span class="s3">\n          </span><span class="s1">lastLine = commentEndLine;</span><span class="s3">\n\n          </span><span class="s1">maybeNewline(offset);</span><span class="s3">\n          </span><span class="s1">this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">hasLoc = false;</span><span class="s3">\n        </span><span class="s1">if (shouldPrint !== PRINT_COMMENT_HINT.ALLOW) {</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (len === 1) {</span><span class="s3">\n          </span><span class="s1">const singleLine = comment.loc</span><span class="s3">\n            </span><span class="s1">? comment.loc.start.line === comment.loc.end.line</span><span class="s3">\n            </span><span class="s1">: !HAS_NEWLINE.test(comment.value);</span><span class="s3">\n\n          </span><span class="s1">const shouldSkipNewline =</span><span class="s3">\n            </span><span class="s1">singleLine &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!isStatement(node) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!isClassBody(parent) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!isTSInterfaceBody(parent) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!isTSEnumDeclaration(parent);</span><span class="s3">\n\n          </span><span class="s1">if (type === COMMENT_TYPE.LEADING) {</span><span class="s3">\n            </span><span class="s1">this._printComment(</span><span class="s3">\n              </span><span class="s1">comment,</span><span class="s3">\n              </span><span class="s1">(shouldSkipNewline &amp;&amp; node.type !== </span><span class="s3">\&quot;</span><span class="s1">ObjectExpression</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n                </span><span class="s1">(singleLine &amp;&amp; isFunction(parent, { body: node }))</span><span class="s3">\n                </span><span class="s1">? COMMENT_SKIP_NEWLINE.ALL</span><span class="s3">\n                </span><span class="s1">: COMMENT_SKIP_NEWLINE.DEFAULT,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">} else if (shouldSkipNewline &amp;&amp; type === COMMENT_TYPE.TRAILING) {</span><span class="s3">\n            </span><span class="s1">this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (</span><span class="s3">\n          </span><span class="s1">type === COMMENT_TYPE.INNER &amp;&amp;</span><span class="s3">\n          </span><span class="s1">!(node.type === </span><span class="s3">\&quot;</span><span class="s1">ObjectExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; node.properties.length &gt; 1) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">node.type !== </span><span class="s3">\&quot;</span><span class="s1">ClassBody</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n          </span><span class="s1">node.type !== </span><span class="s3">\&quot;</span><span class="s1">TSInterfaceBody</span><span class="s3">\&quot;\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// class X {</span><span class="s3">\n          </span><span class="s1">//   /*:: a: number*/</span><span class="s3">\n          </span><span class="s1">//   /*:: b: ?string*/</span><span class="s3">\n          </span><span class="s1">// }</span><span class="s3">\n\n          </span><span class="s1">this._printComment(</span><span class="s3">\n            </span><span class="s1">comment,</span><span class="s3">\n            </span><span class="s1">i === 0</span><span class="s3">\n              </span><span class="s1">? COMMENT_SKIP_NEWLINE.LEADING</span><span class="s3">\n              </span><span class="s1">: i === len - 1</span><span class="s3">\n              </span><span class="s1">? COMMENT_SKIP_NEWLINE.TRAILING</span><span class="s3">\n              </span><span class="s1">: COMMENT_SKIP_NEWLINE.DEFAULT,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (type === COMMENT_TYPE.TRAILING &amp;&amp; hasLoc &amp;&amp; lastLine) {</span><span class="s3">\n      </span><span class="s1">this._lastCommentLine = lastLine;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Expose the node type functions and helpers on the prototype for easy usage.</span><span class="s3">\n</span><span class="s1">Object.assign(Printer.prototype, generatorFunctions);</span><span class="s3">\n\n</span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n  </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) Babel 7 has Noop print method</span><span class="s3">\n  </span><span class="s1">Printer.prototype.Noop = function Noop(this: Printer) {};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type GeneratorFunctions = typeof generatorFunctions;</span><span class="s3">\n</span><span class="s1">interface Printer extends GeneratorFunctions {}</span><span class="s3">\n</span><span class="s1">export default Printer;</span><span class="s3">\n\n</span><span class="s1">function commaSeparator(this: Printer) {</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>