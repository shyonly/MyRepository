<html>
<head>
<title>set-array.mjs.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
set-array.mjs.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;set-array.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/set-array.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Gets the index associated with `key` in the backing array, if it is already present.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let get: (strarr: SetArray, key: string) =&gt; number | undefined;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Puts `key` into the backing array, if it is not already present. Returns</span><span class="s3">\n </span><span class="s1">* the index of the `key` in the backing array.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let put: (strarr: SetArray, key: string) =&gt; number;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Pops the last added item out of the SetArray.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let pop: (strarr: SetArray) =&gt; void;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the</span><span class="s3">\n </span><span class="s1">* index of the `key` in the backing array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This is designed to allow synchronizing a second array with the contents of the backing array,</span><span class="s3">\n </span><span class="s1">* like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,</span><span class="s3">\n </span><span class="s1">* and there are never duplicates.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class SetArray {</span><span class="s3">\n  </span><span class="s1">private declare _indexes: { [key: string]: number | undefined };</span><span class="s3">\n  </span><span class="s1">declare array: readonly string[];</span><span class="s3">\n\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">this._indexes = { __proto__: null } as any;</span><span class="s3">\n    </span><span class="s1">this.array = [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">get = (strarr, key) =&gt; strarr._indexes[key];</span><span class="s3">\n\n    </span><span class="s1">put = (strarr, key) =&gt; {</span><span class="s3">\n      </span><span class="s1">// The key may or may not be present. If it is present, it's a number.</span><span class="s3">\n      </span><span class="s1">const index = get(strarr, key);</span><span class="s3">\n      </span><span class="s1">if (index !== undefined) return index;</span><span class="s3">\n\n      </span><span class="s1">const { array, _indexes: indexes } = strarr;</span><span class="s3">\n\n      </span><span class="s1">return (indexes[key] = (array as string[]).push(key) - 1);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">pop = (strarr) =&gt; {</span><span class="s3">\n      </span><span class="s1">const { array, _indexes: indexes } = strarr;</span><span class="s3">\n      </span><span class="s1">if (array.length === 0) return;</span><span class="s3">\n\n      </span><span class="s1">const last = (array as string[]).pop()!;</span><span class="s3">\n      </span><span class="s1">indexes[last] = undefined;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;IAGW,IAA2D;AAEtE;;;;IAIW,IAA+C;AAE1D;;;IAGW,IAAgC;AAE3C;;;;;;;;MAQa,QAAQ;IAInB;QACE,IAAI,CAAC,QAAQ,GAAG,EAAE,SAAS,EAAE,IAAI,EAAS,CAAC;QAC3C,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;KACjB;CAuBF;AArBC;IACE,GAAG,GAAG,CAAC,MAAM,EAAE,GAAG,KAAK,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;IAE5C,GAAG,GAAG,CAAC,MAAM,EAAE,GAAG;;QAEhB,MAAM,KAAK,GAAG,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;QAC/B,IAAI,KAAK,KAAK,SAAS;YAAE,OAAO,KAAK,CAAC;QAEtC,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,EAAE,GAAG,MAAM,CAAC;QAE5C,QAAQ,OAAO,CAAC,GAAG,CAAC,GAAI,KAAkB,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;KAC3D,CAAC;IAEF,GAAG,GAAG,CAAC,MAAM;QACX,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,EAAE,GAAG,MAAM,CAAC;QAC5C,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC;YAAE,OAAO;QAE/B,MAAM,IAAI,GAAI,KAAkB,CAAC,GAAG,EAAG,CAAC;QACxC,OAAO,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC;KAC3B,CAAC;AACJ,CAAC,GAAA;;;;&quot;</span><span class="s0">}</span></pre>
</body>
</html>