<html>
<head>
<title>toStatement.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
toStatement.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_index&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_index2&quot;</span><span class="s0">,</span><span class="s1">&quot;_default&quot;</span><span class="s0">,</span><span class="s1">&quot;toStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;ignore&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;mustHaveId&quot;</span><span class="s0">,</span><span class="s1">&quot;newType&quot;</span><span class="s0">,</span><span class="s1">&quot;isClass&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/converters/toStatement.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">isStatement,</span><span class="s3">\n  </span><span class="s1">isFunction,</span><span class="s3">\n  </span><span class="s1">isClass,</span><span class="s3">\n  </span><span class="s1">isAssignmentExpression,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">../validators/generated/index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { expressionStatement } from </span><span class="s3">\&quot;</span><span class="s1">../builders/generated/index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">../index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export default toStatement as {</span><span class="s3">\n  </span><span class="s1">(node: t.AssignmentExpression, ignore?: boolean): t.ExpressionStatement;</span><span class="s3">\n\n  </span><span class="s1">&lt;T extends t.Statement&gt;(node: T, ignore: false): T;</span><span class="s3">\n  </span><span class="s1">&lt;T extends t.Statement&gt;(node: T, ignore?: boolean): T | false;</span><span class="s3">\n\n  </span><span class="s1">(node: t.Class, ignore: false): t.ClassDeclaration;</span><span class="s3">\n  </span><span class="s1">(node: t.Class, ignore?: boolean): t.ClassDeclaration | false;</span><span class="s3">\n\n  </span><span class="s1">(node: t.Function, ignore: false): t.FunctionDeclaration;</span><span class="s3">\n  </span><span class="s1">(node: t.Function, ignore?: boolean): t.FunctionDeclaration | false;</span><span class="s3">\n\n  </span><span class="s1">(node: t.Node, ignore: false): t.Statement;</span><span class="s3">\n  </span><span class="s1">(node: t.Node, ignore?: boolean): t.Statement | false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function toStatement(node: t.Node, ignore?: boolean): t.Statement | false {</span><span class="s3">\n  </span><span class="s1">if (isStatement(node)) {</span><span class="s3">\n    </span><span class="s1">return node;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let mustHaveId = false;</span><span class="s3">\n  </span><span class="s1">let newType;</span><span class="s3">\n\n  </span><span class="s1">if (isClass(node)) {</span><span class="s3">\n    </span><span class="s1">mustHaveId = true;</span><span class="s3">\n    </span><span class="s1">newType = </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot; </span><span class="s1">as const;</span><span class="s3">\n  </span><span class="s1">} else if (isFunction(node)) {</span><span class="s3">\n    </span><span class="s1">mustHaveId = true;</span><span class="s3">\n    </span><span class="s1">newType = </span><span class="s3">\&quot;</span><span class="s1">FunctionDeclaration</span><span class="s3">\&quot; </span><span class="s1">as const;</span><span class="s3">\n  </span><span class="s1">} else if (isAssignmentExpression(node)) {</span><span class="s3">\n    </span><span class="s1">return expressionStatement(node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): node.id might be missing</span><span class="s3">\n  </span><span class="s1">if (mustHaveId &amp;&amp; !node.id) {</span><span class="s3">\n    </span><span class="s1">newType = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!newType) {</span><span class="s3">\n    </span><span class="s1">if (ignore) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">throw new Error(`cannot turn ${node.type} to a statement`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error manipulating node.type</span><span class="s3">\n  </span><span class="s1">node.type = newType;</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) refactor to avoid type unsafe mutations like reassigning node type above</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA,IAAAA,MAAA,GAAAC,OAAA;AAMA,IAAAC,OAAA,GAAAD,OAAA;AAAqE,IAAAE,QAAA,GAGtDC,WAAW;AAAAC,OAAA,CAAAC,OAAA,GAAAH,QAAA;AAgB1B,SAASC,WAAWA,CAACG,IAAY,EAAEC,MAAgB,EAAuB;EACxE,IAAI,IAAAC,kBAAW,EAACF,IAAI,CAAC,EAAE;IACrB,OAAOA,IAAI;EACb;EAEA,IAAIG,UAAU,GAAG,KAAK;EACtB,IAAIC,OAAO;EAEX,IAAI,IAAAC,cAAO,EAACL,IAAI,CAAC,EAAE;IACjBG,UAAU,GAAG,IAAI;IACjBC,OAAO,GAAG,kBAA2B;EACvC,CAAC,MAAM,IAAI,IAAAE,iBAAU,EAACN,IAAI,CAAC,EAAE;IAC3BG,UAAU,GAAG,IAAI;IACjBC,OAAO,GAAG,qBAA8B;EAC1C,CAAC,MAAM,IAAI,IAAAG,6BAAsB,EAACP,IAAI,CAAC,EAAE;IACvC,OAAO,IAAAQ,2BAAmB,EAACR,IAAI,CAAC;EAClC;EAGA,IAAIG,UAAU,IAAI,CAACH,IAAI,CAACS,EAAE,EAAE;IAC1BL,OAAO,GAAG,KAAK;EACjB;EAEA,IAAI,CAACA,OAAO,EAAE;IACZ,IAAIH,MAAM,EAAE;MACV,OAAO,KAAK;IACd,CAAC,MAAM;MACL,MAAM,IAAIS,KAAK,CAAE,eAAcV,IAAI,CAACW,IAAK,iBAAgB,CAAC;IAC5D;EACF;EAGAX,IAAI,CAACW,IAAI,GAAGP,OAAO;EAGnB,OAAOJ,IAAI;AACb&quot;</span><span class="s0">}</span></pre>
</body>
</html>