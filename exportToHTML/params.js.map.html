<html>
<head>
<title>params.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
params.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_shadowUtils&quot;</span><span class="s0">,</span><span class="s1">&quot;buildDefaultParam&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;buildLooseDefaultParam&quot;</span><span class="s0">,</span><span class="s1">&quot;buildLooseDestructuredDefaultParam&quot;</span><span class="s0">,</span><span class="s1">&quot;buildSafeArgumentsAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;convertFunctionParams&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreFunctionLength&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldTransformParam&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceRestElement&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;isSimpleParameterList&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;shadowedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;collectShadowedParamsNames&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;needsOuterBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;iifeVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;firstOptionalIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;transformedRestNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;paramIsAssignmentPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignmentPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;isMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;undefinedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;buildUndefinedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;ASSIGNMENT_IDENTIFIER&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFAULT_VALUE&quot;</span><span class="s0">,</span><span class="s1">&quot;UNDEFINED&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrayPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;paramName&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;PARAMETER_NAME&quot;</span><span class="s0">,</span><span class="s1">&quot;defNode&quot;</span><span class="s0">,</span><span class="s1">&quot;VARIABLE_NAME&quot;</span><span class="s0">,</span><span class="s1">&quot;ARGUMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;numericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;uid&quot;</span><span class="s0">,</span><span class="s1">&quot;typeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;transformedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;generator&quot;</span><span class="s0">,</span><span class="s1">&quot;buildScopeIIFE&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyPath&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowPath&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionToExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;unshiftContainer&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/params.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { template, types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">iifeVisitor,</span><span class="s3">\n  </span><span class="s1">collectShadowedParamsNames,</span><span class="s3">\n  </span><span class="s1">buildScopeIIFE,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./shadow-utils.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const buildDefaultParam = template.statement(`</span><span class="s3">\n  </span><span class="s1">let VARIABLE_NAME =</span><span class="s3">\n    </span><span class="s1">arguments.length &gt; ARGUMENT_KEY &amp;&amp; arguments[ARGUMENT_KEY] !== undefined ?</span><span class="s3">\n      </span><span class="s1">arguments[ARGUMENT_KEY]</span><span class="s3">\n    </span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">DEFAULT_VALUE;</span><span class="s3">\n</span><span class="s1">`);</span><span class="s3">\n\n</span><span class="s1">const buildLooseDefaultParam = template.statement(`</span><span class="s3">\n  </span><span class="s1">if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {</span><span class="s3">\n    </span><span class="s1">ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">`);</span><span class="s3">\n\n</span><span class="s1">const buildLooseDestructuredDefaultParam = template.statement(`</span><span class="s3">\n  </span><span class="s1">let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;</span><span class="s3">\n</span><span class="s1">`);</span><span class="s3">\n\n</span><span class="s1">const buildSafeArgumentsAccess = template.statement(`</span><span class="s3">\n  </span><span class="s1">let $0 = arguments.length &gt; $1 ? arguments[$1] : undefined;</span><span class="s3">\n</span><span class="s1">`);</span><span class="s3">\n\n</span><span class="s1">// last 2 parameters are optional -- they are used by transform-object-rest-spread/src/index.js</span><span class="s3">\n</span><span class="s1">export default function convertFunctionParams(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Function&gt;,</span><span class="s3">\n  </span><span class="s1">ignoreFunctionLength: boolean | void,</span><span class="s3">\n  </span><span class="s1">shouldTransformParam?: (index: number) =&gt; boolean,</span><span class="s3">\n  </span><span class="s1">replaceRestElement?: (</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;t.Function&gt;,</span><span class="s3">\n    </span><span class="s1">paramPath: NodePath&lt;t.Function[</span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">][number]&gt;,</span><span class="s3">\n    </span><span class="s1">transformedRestNodes: t.Statement[],</span><span class="s3">\n  </span><span class="s1">) =&gt; void,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const params = path.get(</span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">const isSimpleParameterList = params.every(param =&gt; param.isIdentifier());</span><span class="s3">\n  </span><span class="s1">if (isSimpleParameterList) return false;</span><span class="s3">\n\n  </span><span class="s1">const { node, scope } = path;</span><span class="s3">\n\n  </span><span class="s1">const body = [];</span><span class="s3">\n  </span><span class="s1">const shadowedParams = new Set&lt;string&gt;();</span><span class="s3">\n\n  </span><span class="s1">for (const param of params) {</span><span class="s3">\n    </span><span class="s1">collectShadowedParamsNames(param, scope, shadowedParams);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const state = {</span><span class="s3">\n    </span><span class="s1">needsOuterBinding: false,</span><span class="s3">\n    </span><span class="s1">scope,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">if (shadowedParams.size === 0) {</span><span class="s3">\n    </span><span class="s1">for (const param of params) {</span><span class="s3">\n      </span><span class="s1">if (!param.isIdentifier()) param.traverse(iifeVisitor, state);</span><span class="s3">\n      </span><span class="s1">if (state.needsOuterBinding) break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let firstOptionalIndex = null;</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; params.length; i++) {</span><span class="s3">\n    </span><span class="s1">const param = params[i];</span><span class="s3">\n\n    </span><span class="s1">if (shouldTransformParam &amp;&amp; !shouldTransformParam(i)) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const transformedRestNodes: t.Statement[] = [];</span><span class="s3">\n    </span><span class="s1">if (replaceRestElement) {</span><span class="s3">\n      </span><span class="s1">replaceRestElement(path, param, transformedRestNodes);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const paramIsAssignmentPattern = param.isAssignmentPattern();</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">paramIsAssignmentPattern &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(ignoreFunctionLength || t.isMethod(node, { kind: </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot; </span><span class="s1">}))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const left = param.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const right = param.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">const undefinedNode = scope.buildUndefinedNode();</span><span class="s3">\n\n      </span><span class="s1">if (left.isIdentifier()) {</span><span class="s3">\n        </span><span class="s1">body.push(</span><span class="s3">\n          </span><span class="s1">buildLooseDefaultParam({</span><span class="s3">\n            </span><span class="s1">ASSIGNMENT_IDENTIFIER: t.cloneNode(left.node),</span><span class="s3">\n            </span><span class="s1">DEFAULT_VALUE: right.node,</span><span class="s3">\n            </span><span class="s1">UNDEFINED: undefinedNode,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">param.replaceWith(left.node);</span><span class="s3">\n      </span><span class="s1">} else if (left.isObjectPattern() || left.isArrayPattern()) {</span><span class="s3">\n        </span><span class="s1">const paramName = scope.generateUidIdentifier();</span><span class="s3">\n        </span><span class="s1">body.push(</span><span class="s3">\n          </span><span class="s1">buildLooseDestructuredDefaultParam({</span><span class="s3">\n            </span><span class="s1">ASSIGNMENT_IDENTIFIER: left.node,</span><span class="s3">\n            </span><span class="s1">DEFAULT_VALUE: right.node,</span><span class="s3">\n            </span><span class="s1">PARAMETER_NAME: t.cloneNode(paramName),</span><span class="s3">\n            </span><span class="s1">UNDEFINED: undefinedNode,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">param.replaceWith(paramName);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (paramIsAssignmentPattern) {</span><span class="s3">\n      </span><span class="s1">if (firstOptionalIndex === null) firstOptionalIndex = i;</span><span class="s3">\n\n      </span><span class="s1">const left = param.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const right = param.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">const defNode = buildDefaultParam({</span><span class="s3">\n        </span><span class="s1">VARIABLE_NAME: left.node,</span><span class="s3">\n        </span><span class="s1">DEFAULT_VALUE: right.node,</span><span class="s3">\n        </span><span class="s1">ARGUMENT_KEY: t.numericLiteral(i),</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">body.push(defNode);</span><span class="s3">\n    </span><span class="s1">} else if (firstOptionalIndex !== null) {</span><span class="s3">\n      </span><span class="s1">const defNode = buildSafeArgumentsAccess([</span><span class="s3">\n        </span><span class="s1">param.node,</span><span class="s3">\n        </span><span class="s1">t.numericLiteral(i),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">body.push(defNode);</span><span class="s3">\n    </span><span class="s1">} else if (param.isObjectPattern() || param.isArrayPattern()) {</span><span class="s3">\n      </span><span class="s1">const uid = path.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">ref</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">uid.typeAnnotation = param.node.typeAnnotation;</span><span class="s3">\n\n      </span><span class="s1">const defNode = t.variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n        </span><span class="s1">t.variableDeclarator(param.node, uid),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">body.push(defNode);</span><span class="s3">\n\n      </span><span class="s1">param.replaceWith(t.cloneNode(uid));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (transformedRestNodes) {</span><span class="s3">\n      </span><span class="s1">for (const transformedNode of transformedRestNodes) {</span><span class="s3">\n        </span><span class="s1">body.push(transformedNode);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// we need to cut off all trailing parameters</span><span class="s3">\n  </span><span class="s1">if (firstOptionalIndex !== null) {</span><span class="s3">\n    </span><span class="s1">node.params = node.params.slice(0, firstOptionalIndex);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// ensure it's a block, useful for arrow functions</span><span class="s3">\n  </span><span class="s1">path.ensureBlock();</span><span class="s3">\n\n  </span><span class="s1">const { async, generator } = node;</span><span class="s3">\n  </span><span class="s1">if (generator || state.needsOuterBinding || shadowedParams.size &gt; 0) {</span><span class="s3">\n    </span><span class="s1">body.push(buildScopeIIFE(shadowedParams, path.node.body));</span><span class="s3">\n\n    </span><span class="s1">path.set(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, t.blockStatement(body as t.Statement[]));</span><span class="s3">\n\n    </span><span class="s1">// We inject an arrow and then transform it to a normal function, to be</span><span class="s3">\n    </span><span class="s1">// sure that we correctly handle this and arguments.</span><span class="s3">\n    </span><span class="s1">const bodyPath = path.get(</span><span class="s3">\&quot;</span><span class="s1">body.body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const arrowPath = bodyPath[bodyPath.length - 1].get(</span><span class="s3">\n      \&quot;</span><span class="s1">argument.callee</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">) as NodePath&lt;t.ArrowFunctionExpression&gt;;</span><span class="s3">\n\n    </span><span class="s1">// This is an IIFE, so we don't need to worry about the noNewArrows assumption</span><span class="s3">\n    </span><span class="s1">arrowPath.arrowFunctionToExpression();</span><span class="s3">\n\n    </span><span class="s1">arrowPath.node.generator = generator;</span><span class="s3">\n    </span><span class="s1">arrowPath.node.async = async;</span><span class="s3">\n\n    </span><span class="s1">node.generator = false;</span><span class="s3">\n    </span><span class="s1">node.async = false;</span><span class="s3">\n    </span><span class="s1">if (async) {</span><span class="s3">\n      </span><span class="s1">// If the default value of a parameter throws, it must reject asynchronously.</span><span class="s3">\n      </span><span class="s1">path.node.body = template.statement.ast`{</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">${path.node.body.body}</span><span class="s3">\n        </span><span class="s1">} catch (e) {</span><span class="s3">\n          </span><span class="s1">return Promise.reject(e);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}` as t.BlockStatement;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).unshiftContainer(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>