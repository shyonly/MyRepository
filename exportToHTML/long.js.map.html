<html>
<head>
<title>long.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
long.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack:///webpack/universalModuleDefinition&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack:///long.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack:///webpack/bootstrap f96e8d1360c0487f2545&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack:///./src/long.js&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;root&quot;</span><span class="s0">,</span><span class="s1">&quot;factory&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;define&quot;</span><span class="s0">,</span><span class="s1">&quot;amd&quot;</span><span class="s0">,</span><span class="s1">&quot;self&quot;</span><span class="s0">,</span><span class="s1">&quot;this&quot;</span><span class="s0">,</span><span class="s1">&quot;modules&quot;</span><span class="s0">,</span><span class="s1">&quot;__webpack_require__&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleId&quot;</span><span class="s0">,</span><span class="s1">&quot;installedModules&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;l&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;c&quot;</span><span class="s0">,</span><span class="s1">&quot;d&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;getter&quot;</span><span class="s0">,</span><span class="s1">&quot;o&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;configurable&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;__esModule&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;s&quot;</span><span class="s0">,</span><span class="s1">&quot;Long&quot;</span><span class="s0">,</span><span class="s1">&quot;low&quot;</span><span class="s0">,</span><span class="s1">&quot;high&quot;</span><span class="s0">,</span><span class="s1">&quot;unsigned&quot;</span><span class="s0">,</span><span class="s1">&quot;isLong&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;fromInt&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedObj&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;UINT_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;fromBits&quot;</span><span class="s0">,</span><span class="s1">&quot;INT_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;fromNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;isNaN&quot;</span><span class="s0">,</span><span class="s1">&quot;UZERO&quot;</span><span class="s0">,</span><span class="s1">&quot;ZERO&quot;</span><span class="s0">,</span><span class="s1">&quot;TWO_PWR_64_DBL&quot;</span><span class="s0">,</span><span class="s1">&quot;MAX_UNSIGNED_VALUE&quot;</span><span class="s0">,</span><span class="s1">&quot;TWO_PWR_63_DBL&quot;</span><span class="s0">,</span><span class="s1">&quot;MIN_VALUE&quot;</span><span class="s0">,</span><span class="s1">&quot;MAX_VALUE&quot;</span><span class="s0">,</span><span class="s1">&quot;neg&quot;</span><span class="s0">,</span><span class="s1">&quot;TWO_PWR_32_DBL&quot;</span><span class="s0">,</span><span class="s1">&quot;lowBits&quot;</span><span class="s0">,</span><span class="s1">&quot;highBits&quot;</span><span class="s0">,</span><span class="s1">&quot;fromString&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;radix&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;RangeError&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;substring&quot;</span><span class="s0">,</span><span class="s1">&quot;radixToPower&quot;</span><span class="s0">,</span><span class="s1">&quot;pow_dbl&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;min&quot;</span><span class="s0">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s0">,</span><span class="s1">&quot;power&quot;</span><span class="s0">,</span><span class="s1">&quot;mul&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;fromValue&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;wasm&quot;</span><span class="s0">,</span><span class="s1">&quot;WebAssembly&quot;</span><span class="s0">,</span><span class="s1">&quot;Instance&quot;</span><span class="s0">,</span><span class="s1">&quot;Module&quot;</span><span class="s0">,</span><span class="s1">&quot;Uint8Array&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;__isLong__&quot;</span><span class="s0">,</span><span class="s1">&quot;pow&quot;</span><span class="s0">,</span><span class="s1">&quot;TWO_PWR_16_DBL&quot;</span><span class="s0">,</span><span class="s1">&quot;TWO_PWR_24&quot;</span><span class="s0">,</span><span class="s1">&quot;ONE&quot;</span><span class="s0">,</span><span class="s1">&quot;UONE&quot;</span><span class="s0">,</span><span class="s1">&quot;NEG_ONE&quot;</span><span class="s0">,</span><span class="s1">&quot;LongPrototype&quot;</span><span class="s0">,</span><span class="s1">&quot;toInt&quot;</span><span class="s0">,</span><span class="s1">&quot;toNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;isZero&quot;</span><span class="s0">,</span><span class="s1">&quot;isNegative&quot;</span><span class="s0">,</span><span class="s1">&quot;eq&quot;</span><span class="s0">,</span><span class="s1">&quot;radixLong&quot;</span><span class="s0">,</span><span class="s1">&quot;div&quot;</span><span class="s0">,</span><span class="s1">&quot;rem1&quot;</span><span class="s0">,</span><span class="s1">&quot;sub&quot;</span><span class="s0">,</span><span class="s1">&quot;rem&quot;</span><span class="s0">,</span><span class="s1">&quot;remDiv&quot;</span><span class="s0">,</span><span class="s1">&quot;intval&quot;</span><span class="s0">,</span><span class="s1">&quot;digits&quot;</span><span class="s0">,</span><span class="s1">&quot;getHighBits&quot;</span><span class="s0">,</span><span class="s1">&quot;getHighBitsUnsigned&quot;</span><span class="s0">,</span><span class="s1">&quot;getLowBits&quot;</span><span class="s0">,</span><span class="s1">&quot;getLowBitsUnsigned&quot;</span><span class="s0">,</span><span class="s1">&quot;getNumBitsAbs&quot;</span><span class="s0">,</span><span class="s1">&quot;bit&quot;</span><span class="s0">,</span><span class="s1">&quot;eqz&quot;</span><span class="s0">,</span><span class="s1">&quot;isPositive&quot;</span><span class="s0">,</span><span class="s1">&quot;isOdd&quot;</span><span class="s0">,</span><span class="s1">&quot;isEven&quot;</span><span class="s0">,</span><span class="s1">&quot;equals&quot;</span><span class="s0">,</span><span class="s1">&quot;other&quot;</span><span class="s0">,</span><span class="s1">&quot;notEquals&quot;</span><span class="s0">,</span><span class="s1">&quot;neq&quot;</span><span class="s0">,</span><span class="s1">&quot;ne&quot;</span><span class="s0">,</span><span class="s1">&quot;lessThan&quot;</span><span class="s0">,</span><span class="s1">&quot;comp&quot;</span><span class="s0">,</span><span class="s1">&quot;lt&quot;</span><span class="s0">,</span><span class="s1">&quot;lessThanOrEqual&quot;</span><span class="s0">,</span><span class="s1">&quot;lte&quot;</span><span class="s0">,</span><span class="s1">&quot;le&quot;</span><span class="s0">,</span><span class="s1">&quot;greaterThan&quot;</span><span class="s0">,</span><span class="s1">&quot;gt&quot;</span><span class="s0">,</span><span class="s1">&quot;greaterThanOrEqual&quot;</span><span class="s0">,</span><span class="s1">&quot;gte&quot;</span><span class="s0">,</span><span class="s1">&quot;ge&quot;</span><span class="s0">,</span><span class="s1">&quot;compare&quot;</span><span class="s0">,</span><span class="s1">&quot;thisNeg&quot;</span><span class="s0">,</span><span class="s1">&quot;otherNeg&quot;</span><span class="s0">,</span><span class="s1">&quot;negate&quot;</span><span class="s0">,</span><span class="s1">&quot;not&quot;</span><span class="s0">,</span><span class="s1">&quot;addend&quot;</span><span class="s0">,</span><span class="s1">&quot;a48&quot;</span><span class="s0">,</span><span class="s1">&quot;a32&quot;</span><span class="s0">,</span><span class="s1">&quot;a16&quot;</span><span class="s0">,</span><span class="s1">&quot;a00&quot;</span><span class="s0">,</span><span class="s1">&quot;b48&quot;</span><span class="s0">,</span><span class="s1">&quot;b32&quot;</span><span class="s0">,</span><span class="s1">&quot;b16&quot;</span><span class="s0">,</span><span class="s1">&quot;b00&quot;</span><span class="s0">,</span><span class="s1">&quot;c48&quot;</span><span class="s0">,</span><span class="s1">&quot;c32&quot;</span><span class="s0">,</span><span class="s1">&quot;c16&quot;</span><span class="s0">,</span><span class="s1">&quot;c00&quot;</span><span class="s0">,</span><span class="s1">&quot;subtract&quot;</span><span class="s0">,</span><span class="s1">&quot;subtrahend&quot;</span><span class="s0">,</span><span class="s1">&quot;multiply&quot;</span><span class="s0">,</span><span class="s1">&quot;multiplier&quot;</span><span class="s0">,</span><span class="s1">&quot;divide&quot;</span><span class="s0">,</span><span class="s1">&quot;divisor&quot;</span><span class="s0">,</span><span class="s1">&quot;approx&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;toUnsigned&quot;</span><span class="s0">,</span><span class="s1">&quot;shru&quot;</span><span class="s0">,</span><span class="s1">&quot;shr&quot;</span><span class="s0">,</span><span class="s1">&quot;shl&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;floor&quot;</span><span class="s0">,</span><span class="s1">&quot;log2&quot;</span><span class="s0">,</span><span class="s1">&quot;ceil&quot;</span><span class="s0">,</span><span class="s1">&quot;log&quot;</span><span class="s0">,</span><span class="s1">&quot;LN2&quot;</span><span class="s0">,</span><span class="s1">&quot;delta&quot;</span><span class="s0">,</span><span class="s1">&quot;approxRes&quot;</span><span class="s0">,</span><span class="s1">&quot;approxRem&quot;</span><span class="s0">,</span><span class="s1">&quot;modulo&quot;</span><span class="s0">,</span><span class="s1">&quot;mod&quot;</span><span class="s0">,</span><span class="s1">&quot;and&quot;</span><span class="s0">,</span><span class="s1">&quot;or&quot;</span><span class="s0">,</span><span class="s1">&quot;xor&quot;</span><span class="s0">,</span><span class="s1">&quot;shiftLeft&quot;</span><span class="s0">,</span><span class="s1">&quot;numBits&quot;</span><span class="s0">,</span><span class="s1">&quot;shiftRight&quot;</span><span class="s0">,</span><span class="s1">&quot;shiftRightUnsigned&quot;</span><span class="s0">,</span><span class="s1">&quot;shr_u&quot;</span><span class="s0">,</span><span class="s1">&quot;rotateLeft&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;rotl&quot;</span><span class="s0">,</span><span class="s1">&quot;rotateRight&quot;</span><span class="s0">,</span><span class="s1">&quot;rotr&quot;</span><span class="s0">,</span><span class="s1">&quot;toSigned&quot;</span><span class="s0">,</span><span class="s1">&quot;toBytes&quot;</span><span class="s0">,</span><span class="s1">&quot;toBytesLE&quot;</span><span class="s0">,</span><span class="s1">&quot;toBytesBE&quot;</span><span class="s0">,</span><span class="s1">&quot;hi&quot;</span><span class="s0">,</span><span class="s1">&quot;lo&quot;</span><span class="s0">,</span><span class="s1">&quot;fromBytes&quot;</span><span class="s0">,</span><span class="s1">&quot;bytes&quot;</span><span class="s0">,</span><span class="s1">&quot;fromBytesLE&quot;</span><span class="s0">,</span><span class="s1">&quot;fromBytesBE&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;long.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;(function webpackUniversalModuleDefinition(root, factory) {</span><span class="s3">\n\t</span><span class="s1">if(typeof exports === 'object' &amp;&amp; typeof module === 'object')</span><span class="s3">\n\t\t</span><span class="s1">module.exports = factory();</span><span class="s3">\n\t</span><span class="s1">else if(typeof define === 'function' &amp;&amp; define.amd)</span><span class="s3">\n\t\t</span><span class="s1">define([], factory);</span><span class="s3">\n\t</span><span class="s1">else if(typeof exports === 'object')</span><span class="s3">\n\t\t</span><span class="s1">exports[</span><span class="s3">\&quot;</span><span class="s1">Long</span><span class="s3">\&quot;</span><span class="s1">] = factory();</span><span class="s3">\n\t</span><span class="s1">else</span><span class="s3">\n\t\t</span><span class="s1">root[</span><span class="s3">\&quot;</span><span class="s1">Long</span><span class="s3">\&quot;</span><span class="s1">] = factory();</span><span class="s3">\n</span><span class="s1">})(typeof self !== 'undefined' ? self : this, function() {</span><span class="s3">\n</span><span class="s1">return </span><span class="s3">\n\n\n</span><span class="s1">// WEBPACK FOOTER //</span><span class="s3">\n</span><span class="s1">// webpack/universalModuleDefinition&quot;</span><span class="s0">,</span><span class="s1">&quot;(function webpackUniversalModuleDefinition(root, factory) {</span><span class="s3">\n\t</span><span class="s1">if(typeof exports === 'object' &amp;&amp; typeof module === 'object')</span><span class="s3">\n\t\t</span><span class="s1">module.exports = factory();</span><span class="s3">\n\t</span><span class="s1">else if(typeof define === 'function' &amp;&amp; define.amd)</span><span class="s3">\n\t\t</span><span class="s1">define([], factory);</span><span class="s3">\n\t</span><span class="s1">else if(typeof exports === 'object')</span><span class="s3">\n\t\t</span><span class="s1">exports[</span><span class="s3">\&quot;</span><span class="s1">Long</span><span class="s3">\&quot;</span><span class="s1">] = factory();</span><span class="s3">\n\t</span><span class="s1">else</span><span class="s3">\n\t\t</span><span class="s1">root[</span><span class="s3">\&quot;</span><span class="s1">Long</span><span class="s3">\&quot;</span><span class="s1">] = factory();</span><span class="s3">\n</span><span class="s1">})(typeof self !== 'undefined' ? self : this, function() {</span><span class="s3">\n</span><span class="s1">return /******/ (function(modules) { // webpackBootstrap</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// The module cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">var installedModules = {};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// The require function</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">function __webpack_require__(moduleId) {</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Check if module is in cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">if(installedModules[moduleId]) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">return installedModules[moduleId].exports;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Create a new module (and put it into the cache)</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">var module = installedModules[moduleId] = {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">i: moduleId,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">l: false,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">exports: {}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Execute the module function</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Flag the module as loaded</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">module.l = true;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Return the exports of the module</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">return module.exports;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// expose the modules object (__webpack_modules__)</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.m = modules;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// expose the module cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.c = installedModules;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// define getter function for harmony exports</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.d = function(exports, name, getter) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">if(!__webpack_require__.o(exports, name)) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">Object.defineProperty(exports, name, {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t\t</span><span class="s1">configurable: false,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t\t</span><span class="s1">enumerable: true,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t\t</span><span class="s1">get: getter</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// getDefaultExport function for compatibility with non-harmony modules</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.n = function(module) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">var getter = module &amp;&amp; module.__esModule ?</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">function getDefault() { return module['default']; } :</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">function getModuleExports() { return module; };</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">__webpack_require__.d(getter, 'a', getter);</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">return getter;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// Object.prototype.hasOwnProperty.call</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// __webpack_public_path__</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.p = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// Load entry module and return exports</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">return __webpack_require__(__webpack_require__.s = 0);</span><span class="s3">\n</span><span class="s1">/******/ })</span><span class="s3">\n</span><span class="s1">/************************************************************************/</span><span class="s3">\n</span><span class="s1">/******/ ([</span><span class="s3">\n</span><span class="s1">/* 0 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports) {</span><span class="s3">\n\n</span><span class="s1">module.exports = Long;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* wasm optimizations, to do native i64 multiplication and divide</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var wasm = null;</span><span class="s3">\n\n</span><span class="s1">try {</span><span class="s3">\n  </span><span class="s1">wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([</span><span class="s3">\n    </span><span class="s1">0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11</span><span class="s3">\n  </span><span class="s1">])), {}).exports;</span><span class="s3">\n</span><span class="s1">} catch (e) {</span><span class="s3">\n  </span><span class="s1">// no wasm support :(</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.</span><span class="s3">\n </span><span class="s1">*  See the from* functions below for more convenient ways of constructing Longs.</span><span class="s3">\n </span><span class="s1">* @exports Long</span><span class="s3">\n </span><span class="s1">* @class A Long class for representing a 64 bit two's-complement integer value.</span><span class="s3">\n </span><span class="s1">* @param {number} low The low (signed) 32 bits of the long</span><span class="s3">\n </span><span class="s1">* @param {number} high The high (signed) 32 bits of the long</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @constructor</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function Long(low, high, unsigned) {</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The low 32 bits as a signed value.</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.low = low | 0;</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The high 32 bits as a signed value.</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.high = high | 0;</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether unsigned or not.</span><span class="s3">\n     </span><span class="s1">* @type {boolean}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.unsigned = !!unsigned;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// The internal representation of a long is the two given signed, 32-bit values.</span><span class="s3">\n</span><span class="s1">// We use 32-bit pieces because these are the size of integers on which</span><span class="s3">\n</span><span class="s1">// Javascript performs bit-operations.  For operations like addition and</span><span class="s3">\n</span><span class="s1">// multiplication, we split each number into 16 bit pieces, which can easily be</span><span class="s3">\n</span><span class="s1">// multiplied within Javascript's floating-point representation without overflow</span><span class="s3">\n</span><span class="s1">// or change in sign.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// In the algorithms below, we frequently reduce the negative case to the</span><span class="s3">\n</span><span class="s1">// positive case by negating the input(s) and then post-processing the result.</span><span class="s3">\n</span><span class="s1">// Note that we must ALWAYS check specially whether those values are MIN_VALUE</span><span class="s3">\n</span><span class="s1">// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as</span><span class="s3">\n</span><span class="s1">// a positive number, it overflows back into a negative).  Not handling this</span><span class="s3">\n</span><span class="s1">// case would often result in infinite recursion.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*</span><span class="s3">\n</span><span class="s1">// methods on which they depend.</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An indicator used to reliably determine if an object is a Long or not.</span><span class="s3">\n </span><span class="s1">* @type {boolean}</span><span class="s3">\n </span><span class="s1">* @const</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.prototype.__isLong__;</span><span class="s3">\n\n</span><span class="s1">Object.defineProperty(Long.prototype, </span><span class="s3">\&quot;</span><span class="s1">__isLong__</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {*} obj Object</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isLong(obj) {</span><span class="s3">\n    </span><span class="s1">return (obj &amp;&amp; obj[</span><span class="s3">\&quot;</span><span class="s1">__isLong__</span><span class="s3">\&quot;</span><span class="s1">]) === true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if the specified object is a Long.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {*} obj Object</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.isLong = isLong;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A cache of the Long representations of small integer values.</span><span class="s3">\n </span><span class="s1">* @type {!Object}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var INT_CACHE = {};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A cache of the Long representations of small unsigned integer values.</span><span class="s3">\n </span><span class="s1">* @type {!Object}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var UINT_CACHE = {};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {number} value</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function fromInt(value, unsigned) {</span><span class="s3">\n    </span><span class="s1">var obj, cachedObj, cache;</span><span class="s3">\n    </span><span class="s1">if (unsigned) {</span><span class="s3">\n        </span><span class="s1">value &gt;&gt;&gt;= 0;</span><span class="s3">\n        </span><span class="s1">if (cache = (0 &lt;= value &amp;&amp; value &lt; 256)) {</span><span class="s3">\n            </span><span class="s1">cachedObj = UINT_CACHE[value];</span><span class="s3">\n            </span><span class="s1">if (cachedObj)</span><span class="s3">\n                </span><span class="s1">return cachedObj;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">obj = fromBits(value, (value | 0) &lt; 0 ? -1 : 0, true);</span><span class="s3">\n        </span><span class="s1">if (cache)</span><span class="s3">\n            </span><span class="s1">UINT_CACHE[value] = obj;</span><span class="s3">\n        </span><span class="s1">return obj;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">value |= 0;</span><span class="s3">\n        </span><span class="s1">if (cache = (-128 &lt;= value &amp;&amp; value &lt; 128)) {</span><span class="s3">\n            </span><span class="s1">cachedObj = INT_CACHE[value];</span><span class="s3">\n            </span><span class="s1">if (cachedObj)</span><span class="s3">\n                </span><span class="s1">return cachedObj;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">obj = fromBits(value, value &lt; 0 ? -1 : 0, false);</span><span class="s3">\n        </span><span class="s1">if (cache)</span><span class="s3">\n            </span><span class="s1">INT_CACHE[value] = obj;</span><span class="s3">\n        </span><span class="s1">return obj;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a Long representing the given 32 bit integer value.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number} value The 32 bit integer in question</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @returns {!Long} The corresponding Long value</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.fromInt = fromInt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {number} value</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function fromNumber(value, unsigned) {</span><span class="s3">\n    </span><span class="s1">if (isNaN(value))</span><span class="s3">\n        </span><span class="s1">return unsigned ? UZERO : ZERO;</span><span class="s3">\n    </span><span class="s1">if (unsigned) {</span><span class="s3">\n        </span><span class="s1">if (value &lt; 0)</span><span class="s3">\n            </span><span class="s1">return UZERO;</span><span class="s3">\n        </span><span class="s1">if (value &gt;= TWO_PWR_64_DBL)</span><span class="s3">\n            </span><span class="s1">return MAX_UNSIGNED_VALUE;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (value &lt;= -TWO_PWR_63_DBL)</span><span class="s3">\n            </span><span class="s1">return MIN_VALUE;</span><span class="s3">\n        </span><span class="s1">if (value + 1 &gt;= TWO_PWR_63_DBL)</span><span class="s3">\n            </span><span class="s1">return MAX_VALUE;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (value &lt; 0)</span><span class="s3">\n        </span><span class="s1">return fromNumber(-value, unsigned).neg();</span><span class="s3">\n    </span><span class="s1">return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number} value The number in question</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @returns {!Long} The corresponding Long value</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.fromNumber = fromNumber;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {number} lowBits</span><span class="s3">\n </span><span class="s1">* @param {number} highBits</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function fromBits(lowBits, highBits, unsigned) {</span><span class="s3">\n    </span><span class="s1">return new Long(lowBits, highBits, unsigned);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is</span><span class="s3">\n </span><span class="s1">*  assumed to use 32 bits.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number} lowBits The low 32 bits</span><span class="s3">\n </span><span class="s1">* @param {number} highBits The high 32 bits</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @returns {!Long} The corresponding Long value</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.fromBits = fromBits;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number} base</span><span class="s3">\n </span><span class="s1">* @param {number} exponent</span><span class="s3">\n </span><span class="s1">* @returns {number}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} str</span><span class="s3">\n </span><span class="s1">* @param {(boolean|number)=} unsigned</span><span class="s3">\n </span><span class="s1">* @param {number=} radix</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function fromString(str, unsigned, radix) {</span><span class="s3">\n    </span><span class="s1">if (str.length === 0)</span><span class="s3">\n        </span><span class="s1">throw Error('empty string');</span><span class="s3">\n    </span><span class="s1">if (str === </span><span class="s3">\&quot;</span><span class="s1">NaN</span><span class="s3">\&quot; </span><span class="s1">|| str === </span><span class="s3">\&quot;</span><span class="s1">Infinity</span><span class="s3">\&quot; </span><span class="s1">|| str === </span><span class="s3">\&quot;</span><span class="s1">+Infinity</span><span class="s3">\&quot; </span><span class="s1">|| str === </span><span class="s3">\&quot;</span><span class="s1">-Infinity</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return ZERO;</span><span class="s3">\n    </span><span class="s1">if (typeof unsigned === 'number') {</span><span class="s3">\n        </span><span class="s1">// For goog.math.long compatibility</span><span class="s3">\n        </span><span class="s1">radix = unsigned,</span><span class="s3">\n        </span><span class="s1">unsigned = false;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">unsigned = !! unsigned;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">radix = radix || 10;</span><span class="s3">\n    </span><span class="s1">if (radix &lt; 2 || 36 &lt; radix)</span><span class="s3">\n        </span><span class="s1">throw RangeError('radix');</span><span class="s3">\n\n    </span><span class="s1">var p;</span><span class="s3">\n    </span><span class="s1">if ((p = str.indexOf('-')) &gt; 0)</span><span class="s3">\n        </span><span class="s1">throw Error('interior hyphen');</span><span class="s3">\n    </span><span class="s1">else if (p === 0) {</span><span class="s3">\n        </span><span class="s1">return fromString(str.substring(1), unsigned, radix).neg();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Do several (8) digits each time through the loop, so as to</span><span class="s3">\n    </span><span class="s1">// minimize the calls to the very expensive emulated div.</span><span class="s3">\n    </span><span class="s1">var radixToPower = fromNumber(pow_dbl(radix, 8));</span><span class="s3">\n\n    </span><span class="s1">var result = ZERO;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; str.length; i += 8) {</span><span class="s3">\n        </span><span class="s1">var size = Math.min(8, str.length - i),</span><span class="s3">\n            </span><span class="s1">value = parseInt(str.substring(i, i + size), radix);</span><span class="s3">\n        </span><span class="s1">if (size &lt; 8) {</span><span class="s3">\n            </span><span class="s1">var power = fromNumber(pow_dbl(radix, size));</span><span class="s3">\n            </span><span class="s1">result = result.mul(power).add(fromNumber(value));</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">result = result.mul(radixToPower);</span><span class="s3">\n            </span><span class="s1">result = result.add(fromNumber(value));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">result.unsigned = unsigned;</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a Long representation of the given string, written using the specified radix.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {string} str The textual representation of the Long</span><span class="s3">\n </span><span class="s1">* @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @param {number=} radix The radix in which the text is written (2-36), defaults to 10</span><span class="s3">\n </span><span class="s1">* @returns {!Long} The corresponding Long value</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.fromString = fromString;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function fromValue(val, unsigned) {</span><span class="s3">\n    </span><span class="s1">if (typeof val === 'number')</span><span class="s3">\n        </span><span class="s1">return fromNumber(val, unsigned);</span><span class="s3">\n    </span><span class="s1">if (typeof val === 'string')</span><span class="s3">\n        </span><span class="s1">return fromString(val, unsigned);</span><span class="s3">\n    </span><span class="s1">// Throws for non-objects, converts non-instanceof Long:</span><span class="s3">\n    </span><span class="s1">return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts the specified value to a Long using the appropriate from* function for its type.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.fromValue = fromValue;</span><span class="s3">\n\n</span><span class="s1">// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be</span><span class="s3">\n</span><span class="s1">// no runtime penalty for these.</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {number}</span><span class="s3">\n </span><span class="s1">* @const</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var TWO_PWR_16_DBL = 1 &lt;&lt; 16;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {number}</span><span class="s3">\n </span><span class="s1">* @const</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var TWO_PWR_24_DBL = 1 &lt;&lt; 24;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {number}</span><span class="s3">\n </span><span class="s1">* @const</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {number}</span><span class="s3">\n </span><span class="s1">* @const</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {number}</span><span class="s3">\n </span><span class="s1">* @const</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @const</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var ZERO = fromInt(0);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Signed zero.</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.ZERO = ZERO;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var UZERO = fromInt(0, true);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Unsigned zero.</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.UZERO = UZERO;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var ONE = fromInt(1);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Signed one.</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.ONE = ONE;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var UONE = fromInt(1, true);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Unsigned one.</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.UONE = UONE;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var NEG_ONE = fromInt(-1);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Signed negative one.</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.NEG_ONE = NEG_ONE;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Maximum signed value.</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.MAX_VALUE = MAX_VALUE;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Maximum unsigned value.</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var MIN_VALUE = fromBits(0, 0x80000000|0, false);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Minimum signed value.</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.MIN_VALUE = MIN_VALUE;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @alias Long.prototype</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var LongPrototype = Long.prototype;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.toInt = function toInt() {</span><span class="s3">\n    </span><span class="s1">return this.unsigned ? this.low &gt;&gt;&gt; 0 : this.low;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.toNumber = function toNumber() {</span><span class="s3">\n    </span><span class="s1">if (this.unsigned)</span><span class="s3">\n        </span><span class="s1">return ((this.high &gt;&gt;&gt; 0) * TWO_PWR_32_DBL) + (this.low &gt;&gt;&gt; 0);</span><span class="s3">\n    </span><span class="s1">return this.high * TWO_PWR_32_DBL + (this.low &gt;&gt;&gt; 0);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts the Long to a string written in the specified radix.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {number=} radix Radix (2-36), defaults to 10</span><span class="s3">\n </span><span class="s1">* @returns {string}</span><span class="s3">\n </span><span class="s1">* @override</span><span class="s3">\n </span><span class="s1">* @throws {RangeError} If `radix` is out of range</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.toString = function toString(radix) {</span><span class="s3">\n    </span><span class="s1">radix = radix || 10;</span><span class="s3">\n    </span><span class="s1">if (radix &lt; 2 || 36 &lt; radix)</span><span class="s3">\n        </span><span class="s1">throw RangeError('radix');</span><span class="s3">\n    </span><span class="s1">if (this.isZero())</span><span class="s3">\n        </span><span class="s1">return '0';</span><span class="s3">\n    </span><span class="s1">if (this.isNegative()) { // Unsigned Longs are never negative</span><span class="s3">\n        </span><span class="s1">if (this.eq(MIN_VALUE)) {</span><span class="s3">\n            </span><span class="s1">// We need to change the Long value before it can be negated, so we remove</span><span class="s3">\n            </span><span class="s1">// the bottom-most digit in this base and then recurse to do the rest.</span><span class="s3">\n            </span><span class="s1">var radixLong = fromNumber(radix),</span><span class="s3">\n                </span><span class="s1">div = this.div(radixLong),</span><span class="s3">\n                </span><span class="s1">rem1 = div.mul(radixLong).sub(this);</span><span class="s3">\n            </span><span class="s1">return div.toString(radix) + rem1.toInt().toString(radix);</span><span class="s3">\n        </span><span class="s1">} else</span><span class="s3">\n            </span><span class="s1">return '-' + this.neg().toString(radix);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Do several (6) digits each time through the loop, so as to</span><span class="s3">\n    </span><span class="s1">// minimize the calls to the very expensive emulated div.</span><span class="s3">\n    </span><span class="s1">var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),</span><span class="s3">\n        </span><span class="s1">rem = this;</span><span class="s3">\n    </span><span class="s1">var result = '';</span><span class="s3">\n    </span><span class="s1">while (true) {</span><span class="s3">\n        </span><span class="s1">var remDiv = rem.div(radixToPower),</span><span class="s3">\n            </span><span class="s1">intval = rem.sub(remDiv.mul(radixToPower)).toInt() &gt;&gt;&gt; 0,</span><span class="s3">\n            </span><span class="s1">digits = intval.toString(radix);</span><span class="s3">\n        </span><span class="s1">rem = remDiv;</span><span class="s3">\n        </span><span class="s1">if (rem.isZero())</span><span class="s3">\n            </span><span class="s1">return digits + result;</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">while (digits.length &lt; 6)</span><span class="s3">\n                </span><span class="s1">digits = '0' + digits;</span><span class="s3">\n            </span><span class="s1">result = '' + digits + result;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the high 32 bits as a signed integer.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {number} Signed high bits</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.getHighBits = function getHighBits() {</span><span class="s3">\n    </span><span class="s1">return this.high;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the high 32 bits as an unsigned integer.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {number} Unsigned high bits</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {</span><span class="s3">\n    </span><span class="s1">return this.high &gt;&gt;&gt; 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the low 32 bits as a signed integer.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {number} Signed low bits</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.getLowBits = function getLowBits() {</span><span class="s3">\n    </span><span class="s1">return this.low;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the low 32 bits as an unsigned integer.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {number} Unsigned low bits</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {</span><span class="s3">\n    </span><span class="s1">return this.low &gt;&gt;&gt; 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the number of bits needed to represent the absolute value of this Long.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.getNumBitsAbs = function getNumBitsAbs() {</span><span class="s3">\n    </span><span class="s1">if (this.isNegative()) // Unsigned Longs are never negative</span><span class="s3">\n        </span><span class="s1">return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();</span><span class="s3">\n    </span><span class="s1">var val = this.high != 0 ? this.high : this.low;</span><span class="s3">\n    </span><span class="s1">for (var bit = 31; bit &gt; 0; bit--)</span><span class="s3">\n        </span><span class="s1">if ((val &amp; (1 &lt;&lt; bit)) != 0)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">return this.high != 0 ? bit + 33 : bit + 1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value equals zero.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.isZero = function isZero() {</span><span class="s3">\n    </span><span class="s1">return this.high === 0 &amp;&amp; this.low === 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.eqz = LongPrototype.isZero;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is negative.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.isNegative = function isNegative() {</span><span class="s3">\n    </span><span class="s1">return !this.unsigned &amp;&amp; this.high &lt; 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is positive.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.isPositive = function isPositive() {</span><span class="s3">\n    </span><span class="s1">return this.unsigned || this.high &gt;= 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is odd.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.isOdd = function isOdd() {</span><span class="s3">\n    </span><span class="s1">return (this.low &amp; 1) === 1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is even.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.isEven = function isEven() {</span><span class="s3">\n    </span><span class="s1">return (this.low &amp; 1) === 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value equals the specified's.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.equals = function equals(other) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(other))</span><span class="s3">\n        </span><span class="s1">other = fromValue(other);</span><span class="s3">\n    </span><span class="s1">if (this.unsigned !== other.unsigned &amp;&amp; (this.high &gt;&gt;&gt; 31) === 1 &amp;&amp; (other.high &gt;&gt;&gt; 31) === 1)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">return this.high === other.high &amp;&amp; this.low === other.low;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.eq = LongPrototype.equals;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value differs from the specified's.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.notEquals = function notEquals(other) {</span><span class="s3">\n    </span><span class="s1">return !this.eq(/* validates */ other);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.neq = LongPrototype.notEquals;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.ne = LongPrototype.notEquals;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is less than the specified's.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.lessThan = function lessThan(other) {</span><span class="s3">\n    </span><span class="s1">return this.comp(/* validates */ other) &lt; 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.lt = LongPrototype.lessThan;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is less than or equal the specified's.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {</span><span class="s3">\n    </span><span class="s1">return this.comp(/* validates */ other) &lt;= 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.lte = LongPrototype.lessThanOrEqual;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.le = LongPrototype.lessThanOrEqual;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is greater than the specified's.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.greaterThan = function greaterThan(other) {</span><span class="s3">\n    </span><span class="s1">return this.comp(/* validates */ other) &gt; 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.gt = LongPrototype.greaterThan;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is greater than or equal the specified's.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {</span><span class="s3">\n    </span><span class="s1">return this.comp(/* validates */ other) &gt;= 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.gte = LongPrototype.greaterThanOrEqual;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.ge = LongPrototype.greaterThanOrEqual;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Compares this Long's value with the specified's.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {number} 0 if they are the same, 1 if the this is greater and -1</span><span class="s3">\n </span><span class="s1">*  if the given one is greater</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.compare = function compare(other) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(other))</span><span class="s3">\n        </span><span class="s1">other = fromValue(other);</span><span class="s3">\n    </span><span class="s1">if (this.eq(other))</span><span class="s3">\n        </span><span class="s1">return 0;</span><span class="s3">\n    </span><span class="s1">var thisNeg = this.isNegative(),</span><span class="s3">\n        </span><span class="s1">otherNeg = other.isNegative();</span><span class="s3">\n    </span><span class="s1">if (thisNeg &amp;&amp; !otherNeg)</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">if (!thisNeg &amp;&amp; otherNeg)</span><span class="s3">\n        </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">// At this point the sign bits are the same</span><span class="s3">\n    </span><span class="s1">if (!this.unsigned)</span><span class="s3">\n        </span><span class="s1">return this.sub(other).isNegative() ? -1 : 1;</span><span class="s3">\n    </span><span class="s1">// Both are positive if at least one is unsigned</span><span class="s3">\n    </span><span class="s1">return (other.high &gt;&gt;&gt; 0) &gt; (this.high &gt;&gt;&gt; 0) || (other.high === this.high &amp;&amp; (other.low &gt;&gt;&gt; 0) &gt; (this.low &gt;&gt;&gt; 0)) ? -1 : 1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {number} 0 if they are the same, 1 if the this is greater and -1</span><span class="s3">\n </span><span class="s1">*  if the given one is greater</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.comp = LongPrototype.compare;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Negates this Long's value.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Negated Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.negate = function negate() {</span><span class="s3">\n    </span><span class="s1">if (!this.unsigned &amp;&amp; this.eq(MIN_VALUE))</span><span class="s3">\n        </span><span class="s1">return MIN_VALUE;</span><span class="s3">\n    </span><span class="s1">return this.not().add(ONE);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Negates this Long's value. This is an alias of {@link Long#negate}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Negated Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.neg = LongPrototype.negate;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the sum of this and the specified Long.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} addend Addend</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Sum</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.add = function add(addend) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(addend))</span><span class="s3">\n        </span><span class="s1">addend = fromValue(addend);</span><span class="s3">\n\n    </span><span class="s1">// Divide each number into 4 chunks of 16 bits, and then sum the chunks.</span><span class="s3">\n\n    </span><span class="s1">var a48 = this.high &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">var a32 = this.high &amp; 0xFFFF;</span><span class="s3">\n    </span><span class="s1">var a16 = this.low &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">var a00 = this.low &amp; 0xFFFF;</span><span class="s3">\n\n    </span><span class="s1">var b48 = addend.high &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">var b32 = addend.high &amp; 0xFFFF;</span><span class="s3">\n    </span><span class="s1">var b16 = addend.low &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">var b00 = addend.low &amp; 0xFFFF;</span><span class="s3">\n\n    </span><span class="s1">var c48 = 0, c32 = 0, c16 = 0, c00 = 0;</span><span class="s3">\n    </span><span class="s1">c00 += a00 + b00;</span><span class="s3">\n    </span><span class="s1">c16 += c00 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c00 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c16 += a16 + b16;</span><span class="s3">\n    </span><span class="s1">c32 += c16 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c16 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c32 += a32 + b32;</span><span class="s3">\n    </span><span class="s1">c48 += c32 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c32 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c48 += a48 + b48;</span><span class="s3">\n    </span><span class="s1">c48 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">return fromBits((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32, this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the difference of this and the specified Long.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} subtrahend Subtrahend</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Difference</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.subtract = function subtract(subtrahend) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(subtrahend))</span><span class="s3">\n        </span><span class="s1">subtrahend = fromValue(subtrahend);</span><span class="s3">\n    </span><span class="s1">return this.add(subtrahend.neg());</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} subtrahend Subtrahend</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Difference</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.sub = LongPrototype.subtract;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the product of this and the specified Long.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} multiplier Multiplier</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Product</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.multiply = function multiply(multiplier) {</span><span class="s3">\n    </span><span class="s1">if (this.isZero())</span><span class="s3">\n        </span><span class="s1">return ZERO;</span><span class="s3">\n    </span><span class="s1">if (!isLong(multiplier))</span><span class="s3">\n        </span><span class="s1">multiplier = fromValue(multiplier);</span><span class="s3">\n\n    </span><span class="s1">// use wasm support if present</span><span class="s3">\n    </span><span class="s1">if (wasm) {</span><span class="s3">\n        </span><span class="s1">var low = wasm[</span><span class="s3">\&quot;</span><span class="s1">mul</span><span class="s3">\&quot;</span><span class="s1">](this.low,</span><span class="s3">\n                              </span><span class="s1">this.high,</span><span class="s3">\n                              </span><span class="s1">multiplier.low,</span><span class="s3">\n                              </span><span class="s1">multiplier.high);</span><span class="s3">\n        </span><span class="s1">return fromBits(low, wasm[</span><span class="s3">\&quot;</span><span class="s1">get_high</span><span class="s3">\&quot;</span><span class="s1">](), this.unsigned);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (multiplier.isZero())</span><span class="s3">\n        </span><span class="s1">return ZERO;</span><span class="s3">\n    </span><span class="s1">if (this.eq(MIN_VALUE))</span><span class="s3">\n        </span><span class="s1">return multiplier.isOdd() ? MIN_VALUE : ZERO;</span><span class="s3">\n    </span><span class="s1">if (multiplier.eq(MIN_VALUE))</span><span class="s3">\n        </span><span class="s1">return this.isOdd() ? MIN_VALUE : ZERO;</span><span class="s3">\n\n    </span><span class="s1">if (this.isNegative()) {</span><span class="s3">\n        </span><span class="s1">if (multiplier.isNegative())</span><span class="s3">\n            </span><span class="s1">return this.neg().mul(multiplier.neg());</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">return this.neg().mul(multiplier).neg();</span><span class="s3">\n    </span><span class="s1">} else if (multiplier.isNegative())</span><span class="s3">\n        </span><span class="s1">return this.mul(multiplier.neg()).neg();</span><span class="s3">\n\n    </span><span class="s1">// If both longs are small, use float multiplication</span><span class="s3">\n    </span><span class="s1">if (this.lt(TWO_PWR_24) &amp;&amp; multiplier.lt(TWO_PWR_24))</span><span class="s3">\n        </span><span class="s1">return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);</span><span class="s3">\n\n    </span><span class="s1">// Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.</span><span class="s3">\n    </span><span class="s1">// We can skip products that would overflow.</span><span class="s3">\n\n    </span><span class="s1">var a48 = this.high &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">var a32 = this.high &amp; 0xFFFF;</span><span class="s3">\n    </span><span class="s1">var a16 = this.low &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">var a00 = this.low &amp; 0xFFFF;</span><span class="s3">\n\n    </span><span class="s1">var b48 = multiplier.high &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">var b32 = multiplier.high &amp; 0xFFFF;</span><span class="s3">\n    </span><span class="s1">var b16 = multiplier.low &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">var b00 = multiplier.low &amp; 0xFFFF;</span><span class="s3">\n\n    </span><span class="s1">var c48 = 0, c32 = 0, c16 = 0, c00 = 0;</span><span class="s3">\n    </span><span class="s1">c00 += a00 * b00;</span><span class="s3">\n    </span><span class="s1">c16 += c00 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c00 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c16 += a16 * b00;</span><span class="s3">\n    </span><span class="s1">c32 += c16 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c16 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c16 += a00 * b16;</span><span class="s3">\n    </span><span class="s1">c32 += c16 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c16 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c32 += a32 * b00;</span><span class="s3">\n    </span><span class="s1">c48 += c32 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c32 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c32 += a16 * b16;</span><span class="s3">\n    </span><span class="s1">c48 += c32 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c32 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c32 += a00 * b32;</span><span class="s3">\n    </span><span class="s1">c48 += c32 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c32 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;</span><span class="s3">\n    </span><span class="s1">c48 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">return fromBits((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32, this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} multiplier Multiplier</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Product</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.mul = LongPrototype.multiply;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long divided by the specified. The result is signed if this Long is signed or</span><span class="s3">\n </span><span class="s1">*  unsigned if this Long is unsigned.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} divisor Divisor</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Quotient</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.divide = function divide(divisor) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(divisor))</span><span class="s3">\n        </span><span class="s1">divisor = fromValue(divisor);</span><span class="s3">\n    </span><span class="s1">if (divisor.isZero())</span><span class="s3">\n        </span><span class="s1">throw Error('division by zero');</span><span class="s3">\n\n    </span><span class="s1">// use wasm support if present</span><span class="s3">\n    </span><span class="s1">if (wasm) {</span><span class="s3">\n        </span><span class="s1">// guard against signed division overflow: the largest</span><span class="s3">\n        </span><span class="s1">// negative number / -1 would be 1 larger than the largest</span><span class="s3">\n        </span><span class="s1">// positive number, due to two's complement.</span><span class="s3">\n        </span><span class="s1">if (!this.unsigned &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.high === -0x80000000 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">divisor.low === -1 &amp;&amp; divisor.high === -1) {</span><span class="s3">\n            </span><span class="s1">// be consistent with non-wasm code path</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var low = (this.unsigned ? wasm[</span><span class="s3">\&quot;</span><span class="s1">div_u</span><span class="s3">\&quot;</span><span class="s1">] : wasm[</span><span class="s3">\&quot;</span><span class="s1">div_s</span><span class="s3">\&quot;</span><span class="s1">])(</span><span class="s3">\n            </span><span class="s1">this.low,</span><span class="s3">\n            </span><span class="s1">this.high,</span><span class="s3">\n            </span><span class="s1">divisor.low,</span><span class="s3">\n            </span><span class="s1">divisor.high</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return fromBits(low, wasm[</span><span class="s3">\&quot;</span><span class="s1">get_high</span><span class="s3">\&quot;</span><span class="s1">](), this.unsigned);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.isZero())</span><span class="s3">\n        </span><span class="s1">return this.unsigned ? UZERO : ZERO;</span><span class="s3">\n    </span><span class="s1">var approx, rem, res;</span><span class="s3">\n    </span><span class="s1">if (!this.unsigned) {</span><span class="s3">\n        </span><span class="s1">// This section is only relevant for signed longs and is derived from the</span><span class="s3">\n        </span><span class="s1">// closure library as a whole.</span><span class="s3">\n        </span><span class="s1">if (this.eq(MIN_VALUE)) {</span><span class="s3">\n            </span><span class="s1">if (divisor.eq(ONE) || divisor.eq(NEG_ONE))</span><span class="s3">\n                </span><span class="s1">return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE</span><span class="s3">\n            </span><span class="s1">else if (divisor.eq(MIN_VALUE))</span><span class="s3">\n                </span><span class="s1">return ONE;</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">// At this point, we have |other| &gt;= 2, so |this/other| &lt; |MIN_VALUE|.</span><span class="s3">\n                </span><span class="s1">var halfThis = this.shr(1);</span><span class="s3">\n                </span><span class="s1">approx = halfThis.div(divisor).shl(1);</span><span class="s3">\n                </span><span class="s1">if (approx.eq(ZERO)) {</span><span class="s3">\n                    </span><span class="s1">return divisor.isNegative() ? ONE : NEG_ONE;</span><span class="s3">\n                </span><span class="s1">} else {</span><span class="s3">\n                    </span><span class="s1">rem = this.sub(divisor.mul(approx));</span><span class="s3">\n                    </span><span class="s1">res = approx.add(rem.div(divisor));</span><span class="s3">\n                    </span><span class="s1">return res;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (divisor.eq(MIN_VALUE))</span><span class="s3">\n            </span><span class="s1">return this.unsigned ? UZERO : ZERO;</span><span class="s3">\n        </span><span class="s1">if (this.isNegative()) {</span><span class="s3">\n            </span><span class="s1">if (divisor.isNegative())</span><span class="s3">\n                </span><span class="s1">return this.neg().div(divisor.neg());</span><span class="s3">\n            </span><span class="s1">return this.neg().div(divisor).neg();</span><span class="s3">\n        </span><span class="s1">} else if (divisor.isNegative())</span><span class="s3">\n            </span><span class="s1">return this.div(divisor.neg()).neg();</span><span class="s3">\n        </span><span class="s1">res = ZERO;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// The algorithm below has not been made for unsigned longs. It's therefore</span><span class="s3">\n        </span><span class="s1">// required to take special care of the MSB prior to running it.</span><span class="s3">\n        </span><span class="s1">if (!divisor.unsigned)</span><span class="s3">\n            </span><span class="s1">divisor = divisor.toUnsigned();</span><span class="s3">\n        </span><span class="s1">if (divisor.gt(this))</span><span class="s3">\n            </span><span class="s1">return UZERO;</span><span class="s3">\n        </span><span class="s1">if (divisor.gt(this.shru(1))) // 15 &gt;&gt;&gt; 1 = 7 ; with divisor = 8 ; true</span><span class="s3">\n            </span><span class="s1">return UONE;</span><span class="s3">\n        </span><span class="s1">res = UZERO;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Repeat the following until the remainder is less than other:  find a</span><span class="s3">\n    </span><span class="s1">// floating-point that approximates remainder / other *from below*, add this</span><span class="s3">\n    </span><span class="s1">// into the result, and subtract it from the remainder.  It is critical that</span><span class="s3">\n    </span><span class="s1">// the approximate value is less than or equal to the real value so that the</span><span class="s3">\n    </span><span class="s1">// remainder never becomes negative.</span><span class="s3">\n    </span><span class="s1">rem = this;</span><span class="s3">\n    </span><span class="s1">while (rem.gte(divisor)) {</span><span class="s3">\n        </span><span class="s1">// Approximate the result of division. This may be a little greater or</span><span class="s3">\n        </span><span class="s1">// smaller than the actual value.</span><span class="s3">\n        </span><span class="s1">approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));</span><span class="s3">\n\n        </span><span class="s1">// We will tweak the approximate result by changing it in the 48-th digit or</span><span class="s3">\n        </span><span class="s1">// the smallest non-fractional digit, whichever is larger.</span><span class="s3">\n        </span><span class="s1">var log2 = Math.ceil(Math.log(approx) / Math.LN2),</span><span class="s3">\n            </span><span class="s1">delta = (log2 &lt;= 48) ? 1 : pow_dbl(2, log2 - 48),</span><span class="s3">\n\n        </span><span class="s1">// Decrease the approximation until it is smaller than the remainder.  Note</span><span class="s3">\n        </span><span class="s1">// that if it is too large, the product overflows and is negative.</span><span class="s3">\n            </span><span class="s1">approxRes = fromNumber(approx),</span><span class="s3">\n            </span><span class="s1">approxRem = approxRes.mul(divisor);</span><span class="s3">\n        </span><span class="s1">while (approxRem.isNegative() || approxRem.gt(rem)) {</span><span class="s3">\n            </span><span class="s1">approx -= delta;</span><span class="s3">\n            </span><span class="s1">approxRes = fromNumber(approx, this.unsigned);</span><span class="s3">\n            </span><span class="s1">approxRem = approxRes.mul(divisor);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// We know the answer can't be zero... and actually, zero would cause</span><span class="s3">\n        </span><span class="s1">// infinite recursion since we would make no progress.</span><span class="s3">\n        </span><span class="s1">if (approxRes.isZero())</span><span class="s3">\n            </span><span class="s1">approxRes = ONE;</span><span class="s3">\n\n        </span><span class="s1">res = res.add(approxRes);</span><span class="s3">\n        </span><span class="s1">rem = rem.sub(approxRem);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return res;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long divided by the specified. This is an alias of {@link Long#divide}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} divisor Divisor</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Quotient</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.div = LongPrototype.divide;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long modulo the specified.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} divisor Divisor</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Remainder</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.modulo = function modulo(divisor) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(divisor))</span><span class="s3">\n        </span><span class="s1">divisor = fromValue(divisor);</span><span class="s3">\n\n    </span><span class="s1">// use wasm support if present</span><span class="s3">\n    </span><span class="s1">if (wasm) {</span><span class="s3">\n        </span><span class="s1">var low = (this.unsigned ? wasm[</span><span class="s3">\&quot;</span><span class="s1">rem_u</span><span class="s3">\&quot;</span><span class="s1">] : wasm[</span><span class="s3">\&quot;</span><span class="s1">rem_s</span><span class="s3">\&quot;</span><span class="s1">])(</span><span class="s3">\n            </span><span class="s1">this.low,</span><span class="s3">\n            </span><span class="s1">this.high,</span><span class="s3">\n            </span><span class="s1">divisor.low,</span><span class="s3">\n            </span><span class="s1">divisor.high</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return fromBits(low, wasm[</span><span class="s3">\&quot;</span><span class="s1">get_high</span><span class="s3">\&quot;</span><span class="s1">](), this.unsigned);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.sub(this.div(divisor).mul(divisor));</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} divisor Divisor</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Remainder</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.mod = LongPrototype.modulo;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} divisor Divisor</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Remainder</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.rem = LongPrototype.modulo;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the bitwise NOT of this Long.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.not = function not() {</span><span class="s3">\n    </span><span class="s1">return fromBits(~this.low, ~this.high, this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the bitwise AND of this Long and the specified.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other Long</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.and = function and(other) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(other))</span><span class="s3">\n        </span><span class="s1">other = fromValue(other);</span><span class="s3">\n    </span><span class="s1">return fromBits(this.low &amp; other.low, this.high &amp; other.high, this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the bitwise OR of this Long and the specified.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other Long</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.or = function or(other) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(other))</span><span class="s3">\n        </span><span class="s1">other = fromValue(other);</span><span class="s3">\n    </span><span class="s1">return fromBits(this.low | other.low, this.high | other.high, this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the bitwise XOR of this Long and the given one.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other Long</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.xor = function xor(other) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(other))</span><span class="s3">\n        </span><span class="s1">other = fromValue(other);</span><span class="s3">\n    </span><span class="s1">return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits shifted to the left by the given amount.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Shifted Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.shiftLeft = function shiftLeft(numBits) {</span><span class="s3">\n    </span><span class="s1">if (isLong(numBits))</span><span class="s3">\n        </span><span class="s1">numBits = numBits.toInt();</span><span class="s3">\n    </span><span class="s1">if ((numBits &amp;= 63) === 0)</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">else if (numBits &lt; 32)</span><span class="s3">\n        </span><span class="s1">return fromBits(this.low &lt;&lt; numBits, (this.high &lt;&lt; numBits) | (this.low &gt;&gt;&gt; (32 - numBits)), this.unsigned);</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">return fromBits(0, this.low &lt;&lt; (numBits - 32), this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Shifted Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.shl = LongPrototype.shiftLeft;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits arithmetically shifted to the right by the given amount.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Shifted Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.shiftRight = function shiftRight(numBits) {</span><span class="s3">\n    </span><span class="s1">if (isLong(numBits))</span><span class="s3">\n        </span><span class="s1">numBits = numBits.toInt();</span><span class="s3">\n    </span><span class="s1">if ((numBits &amp;= 63) === 0)</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">else if (numBits &lt; 32)</span><span class="s3">\n        </span><span class="s1">return fromBits((this.low &gt;&gt;&gt; numBits) | (this.high &lt;&lt; (32 - numBits)), this.high &gt;&gt; numBits, this.unsigned);</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">return fromBits(this.high &gt;&gt; (numBits - 32), this.high &gt;= 0 ? 0 : -1, this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Shifted Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.shr = LongPrototype.shiftRight;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits logically shifted to the right by the given amount.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Shifted Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {</span><span class="s3">\n    </span><span class="s1">if (isLong(numBits)) numBits = numBits.toInt();</span><span class="s3">\n    </span><span class="s1">if ((numBits &amp;= 63) === 0) return this;</span><span class="s3">\n    </span><span class="s1">if (numBits &lt; 32) return fromBits((this.low &gt;&gt;&gt; numBits) | (this.high &lt;&lt; (32 - numBits)), this.high &gt;&gt;&gt; numBits, this.unsigned);</span><span class="s3">\n    </span><span class="s1">if (numBits === 32) return fromBits(this.high, 0, this.unsigned);</span><span class="s3">\n    </span><span class="s1">return fromBits(this.high &gt;&gt;&gt; (numBits - 32), 0, this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Shifted Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.shru = LongPrototype.shiftRightUnsigned;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Shifted Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits rotated to the left by the given amount.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Rotated Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.rotateLeft = function rotateLeft(numBits) {</span><span class="s3">\n    </span><span class="s1">var b;</span><span class="s3">\n    </span><span class="s1">if (isLong(numBits)) numBits = numBits.toInt();</span><span class="s3">\n    </span><span class="s1">if ((numBits &amp;= 63) === 0) return this;</span><span class="s3">\n    </span><span class="s1">if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);</span><span class="s3">\n    </span><span class="s1">if (numBits &lt; 32) {</span><span class="s3">\n        </span><span class="s1">b = (32 - numBits);</span><span class="s3">\n        </span><span class="s1">return fromBits(((this.low &lt;&lt; numBits) | (this.high &gt;&gt;&gt; b)), ((this.high &lt;&lt; numBits) | (this.low &gt;&gt;&gt; b)), this.unsigned);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">numBits -= 32;</span><span class="s3">\n    </span><span class="s1">b = (32 - numBits);</span><span class="s3">\n    </span><span class="s1">return fromBits(((this.high &lt;&lt; numBits) | (this.low &gt;&gt;&gt; b)), ((this.low &lt;&lt; numBits) | (this.high &gt;&gt;&gt; b)), this.unsigned);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Rotated Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.rotl = LongPrototype.rotateLeft;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits rotated to the right by the given amount.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Rotated Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.rotateRight = function rotateRight(numBits) {</span><span class="s3">\n    </span><span class="s1">var b;</span><span class="s3">\n    </span><span class="s1">if (isLong(numBits)) numBits = numBits.toInt();</span><span class="s3">\n    </span><span class="s1">if ((numBits &amp;= 63) === 0) return this;</span><span class="s3">\n    </span><span class="s1">if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);</span><span class="s3">\n    </span><span class="s1">if (numBits &lt; 32) {</span><span class="s3">\n        </span><span class="s1">b = (32 - numBits);</span><span class="s3">\n        </span><span class="s1">return fromBits(((this.high &lt;&lt; b) | (this.low &gt;&gt;&gt; numBits)), ((this.low &lt;&lt; b) | (this.high &gt;&gt;&gt; numBits)), this.unsigned);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">numBits -= 32;</span><span class="s3">\n    </span><span class="s1">b = (32 - numBits);</span><span class="s3">\n    </span><span class="s1">return fromBits(((this.low &lt;&lt; b) | (this.high &gt;&gt;&gt; numBits)), ((this.high &lt;&lt; b) | (this.low &gt;&gt;&gt; numBits)), this.unsigned);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Rotated Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.rotr = LongPrototype.rotateRight;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts this Long to signed.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Signed long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.toSigned = function toSigned() {</span><span class="s3">\n    </span><span class="s1">if (!this.unsigned)</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">return fromBits(this.low, this.high, false);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts this Long to unsigned.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Unsigned long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.toUnsigned = function toUnsigned() {</span><span class="s3">\n    </span><span class="s1">if (this.unsigned)</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">return fromBits(this.low, this.high, true);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts this Long to its byte representation.</span><span class="s3">\n </span><span class="s1">* @param {boolean=} le Whether little or big endian, defaults to big endian</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {!Array.&lt;number&gt;} Byte representation</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.toBytes = function toBytes(le) {</span><span class="s3">\n    </span><span class="s1">return le ? this.toBytesLE() : this.toBytesBE();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts this Long to its little endian byte representation.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {!Array.&lt;number&gt;} Little endian byte representation</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.toBytesLE = function toBytesLE() {</span><span class="s3">\n    </span><span class="s1">var hi = this.high,</span><span class="s3">\n        </span><span class="s1">lo = this.low;</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n        </span><span class="s1">lo        &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">lo &gt;&gt;&gt;  8 &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">lo &gt;&gt;&gt; 16 &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">lo &gt;&gt;&gt; 24       ,</span><span class="s3">\n        </span><span class="s1">hi        &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">hi &gt;&gt;&gt;  8 &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">hi &gt;&gt;&gt; 16 &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">hi &gt;&gt;&gt; 24</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts this Long to its big endian byte representation.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {!Array.&lt;number&gt;} Big endian byte representation</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.toBytesBE = function toBytesBE() {</span><span class="s3">\n    </span><span class="s1">var hi = this.high,</span><span class="s3">\n        </span><span class="s1">lo = this.low;</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n        </span><span class="s1">hi &gt;&gt;&gt; 24       ,</span><span class="s3">\n        </span><span class="s1">hi &gt;&gt;&gt; 16 &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">hi &gt;&gt;&gt;  8 &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">hi        &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">lo &gt;&gt;&gt; 24       ,</span><span class="s3">\n        </span><span class="s1">lo &gt;&gt;&gt; 16 &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">lo &gt;&gt;&gt;  8 &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">lo        &amp; 0xff</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a Long from its byte representation.</span><span class="s3">\n </span><span class="s1">* @param {!Array.&lt;number&gt;} bytes Byte representation</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @param {boolean=} le Whether little or big endian, defaults to big endian</span><span class="s3">\n </span><span class="s1">* @returns {Long} The corresponding Long value</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.fromBytes = function fromBytes(bytes, unsigned, le) {</span><span class="s3">\n    </span><span class="s1">return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a Long from its little endian byte representation.</span><span class="s3">\n </span><span class="s1">* @param {!Array.&lt;number&gt;} bytes Little endian byte representation</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @returns {Long} The corresponding Long value</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {</span><span class="s3">\n    </span><span class="s1">return new Long(</span><span class="s3">\n        </span><span class="s1">bytes[0]       |</span><span class="s3">\n        </span><span class="s1">bytes[1] &lt;&lt;  8 |</span><span class="s3">\n        </span><span class="s1">bytes[2] &lt;&lt; 16 |</span><span class="s3">\n        </span><span class="s1">bytes[3] &lt;&lt; 24,</span><span class="s3">\n        </span><span class="s1">bytes[4]       |</span><span class="s3">\n        </span><span class="s1">bytes[5] &lt;&lt;  8 |</span><span class="s3">\n        </span><span class="s1">bytes[6] &lt;&lt; 16 |</span><span class="s3">\n        </span><span class="s1">bytes[7] &lt;&lt; 24,</span><span class="s3">\n        </span><span class="s1">unsigned</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a Long from its big endian byte representation.</span><span class="s3">\n </span><span class="s1">* @param {!Array.&lt;number&gt;} bytes Big endian byte representation</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @returns {Long} The corresponding Long value</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {</span><span class="s3">\n    </span><span class="s1">return new Long(</span><span class="s3">\n        </span><span class="s1">bytes[4] &lt;&lt; 24 |</span><span class="s3">\n        </span><span class="s1">bytes[5] &lt;&lt; 16 |</span><span class="s3">\n        </span><span class="s1">bytes[6] &lt;&lt;  8 |</span><span class="s3">\n        </span><span class="s1">bytes[7],</span><span class="s3">\n        </span><span class="s1">bytes[0] &lt;&lt; 24 |</span><span class="s3">\n        </span><span class="s1">bytes[1] &lt;&lt; 16 |</span><span class="s3">\n        </span><span class="s1">bytes[2] &lt;&lt;  8 |</span><span class="s3">\n        </span><span class="s1">bytes[3],</span><span class="s3">\n        </span><span class="s1">unsigned</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n\n</span><span class="s1">/***/ })</span><span class="s3">\n</span><span class="s1">/******/ ]);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n\n</span><span class="s1">// WEBPACK FOOTER //</span><span class="s3">\n</span><span class="s1">// long.js&quot;</span><span class="s0">,</span><span class="s1">&quot; </span><span class="s3">\t</span><span class="s1">// The module cache</span><span class="s3">\n \t</span><span class="s1">var installedModules = {};</span><span class="s3">\n\n \t</span><span class="s1">// The require function</span><span class="s3">\n \t</span><span class="s1">function __webpack_require__(moduleId) {</span><span class="s3">\n\n \t\t</span><span class="s1">// Check if module is in cache</span><span class="s3">\n \t\t</span><span class="s1">if(installedModules[moduleId]) {</span><span class="s3">\n \t\t\t</span><span class="s1">return installedModules[moduleId].exports;</span><span class="s3">\n \t\t</span><span class="s1">}</span><span class="s3">\n \t\t</span><span class="s1">// Create a new module (and put it into the cache)</span><span class="s3">\n \t\t</span><span class="s1">var module = installedModules[moduleId] = {</span><span class="s3">\n \t\t\t</span><span class="s1">i: moduleId,</span><span class="s3">\n \t\t\t</span><span class="s1">l: false,</span><span class="s3">\n \t\t\t</span><span class="s1">exports: {}</span><span class="s3">\n \t\t</span><span class="s1">};</span><span class="s3">\n\n \t\t</span><span class="s1">// Execute the module function</span><span class="s3">\n \t\t</span><span class="s1">modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><span class="s3">\n\n \t\t</span><span class="s1">// Flag the module as loaded</span><span class="s3">\n \t\t</span><span class="s1">module.l = true;</span><span class="s3">\n\n \t\t</span><span class="s1">// Return the exports of the module</span><span class="s3">\n \t\t</span><span class="s1">return module.exports;</span><span class="s3">\n \t</span><span class="s1">}</span><span class="s3">\n\n\n \t</span><span class="s1">// expose the modules object (__webpack_modules__)</span><span class="s3">\n \t</span><span class="s1">__webpack_require__.m = modules;</span><span class="s3">\n\n \t</span><span class="s1">// expose the module cache</span><span class="s3">\n \t</span><span class="s1">__webpack_require__.c = installedModules;</span><span class="s3">\n\n \t</span><span class="s1">// define getter function for harmony exports</span><span class="s3">\n \t</span><span class="s1">__webpack_require__.d = function(exports, name, getter) {</span><span class="s3">\n \t\t</span><span class="s1">if(!__webpack_require__.o(exports, name)) {</span><span class="s3">\n \t\t\t</span><span class="s1">Object.defineProperty(exports, name, {</span><span class="s3">\n \t\t\t\t</span><span class="s1">configurable: false,</span><span class="s3">\n \t\t\t\t</span><span class="s1">enumerable: true,</span><span class="s3">\n \t\t\t\t</span><span class="s1">get: getter</span><span class="s3">\n \t\t\t</span><span class="s1">});</span><span class="s3">\n \t\t</span><span class="s1">}</span><span class="s3">\n \t</span><span class="s1">};</span><span class="s3">\n\n \t</span><span class="s1">// getDefaultExport function for compatibility with non-harmony modules</span><span class="s3">\n \t</span><span class="s1">__webpack_require__.n = function(module) {</span><span class="s3">\n \t\t</span><span class="s1">var getter = module &amp;&amp; module.__esModule ?</span><span class="s3">\n \t\t\t</span><span class="s1">function getDefault() { return module['default']; } :</span><span class="s3">\n \t\t\t</span><span class="s1">function getModuleExports() { return module; };</span><span class="s3">\n \t\t</span><span class="s1">__webpack_require__.d(getter, 'a', getter);</span><span class="s3">\n \t\t</span><span class="s1">return getter;</span><span class="s3">\n \t</span><span class="s1">};</span><span class="s3">\n\n \t</span><span class="s1">// Object.prototype.hasOwnProperty.call</span><span class="s3">\n \t</span><span class="s1">__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };</span><span class="s3">\n\n \t</span><span class="s1">// __webpack_public_path__</span><span class="s3">\n \t</span><span class="s1">__webpack_require__.p = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n\n \t</span><span class="s1">// Load entry module and return exports</span><span class="s3">\n \t</span><span class="s1">return __webpack_require__(__webpack_require__.s = 0);</span><span class="s3">\n\n\n\n</span><span class="s1">// WEBPACK FOOTER //</span><span class="s3">\n</span><span class="s1">// webpack/bootstrap f96e8d1360c0487f2545&quot;</span><span class="s0">,</span><span class="s1">&quot;module.exports = Long;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* wasm optimizations, to do native i64 multiplication and divide</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var wasm = null;</span><span class="s3">\n\n</span><span class="s1">try {</span><span class="s3">\n  </span><span class="s1">wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([</span><span class="s3">\n    </span><span class="s1">0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11</span><span class="s3">\n  </span><span class="s1">])), {}).exports;</span><span class="s3">\n</span><span class="s1">} catch (e) {</span><span class="s3">\n  </span><span class="s1">// no wasm support :(</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.</span><span class="s3">\n </span><span class="s1">*  See the from* functions below for more convenient ways of constructing Longs.</span><span class="s3">\n </span><span class="s1">* @exports Long</span><span class="s3">\n </span><span class="s1">* @class A Long class for representing a 64 bit two's-complement integer value.</span><span class="s3">\n </span><span class="s1">* @param {number} low The low (signed) 32 bits of the long</span><span class="s3">\n </span><span class="s1">* @param {number} high The high (signed) 32 bits of the long</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @constructor</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function Long(low, high, unsigned) {</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The low 32 bits as a signed value.</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.low = low | 0;</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The high 32 bits as a signed value.</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.high = high | 0;</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether unsigned or not.</span><span class="s3">\n     </span><span class="s1">* @type {boolean}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.unsigned = !!unsigned;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// The internal representation of a long is the two given signed, 32-bit values.</span><span class="s3">\n</span><span class="s1">// We use 32-bit pieces because these are the size of integers on which</span><span class="s3">\n</span><span class="s1">// Javascript performs bit-operations.  For operations like addition and</span><span class="s3">\n</span><span class="s1">// multiplication, we split each number into 16 bit pieces, which can easily be</span><span class="s3">\n</span><span class="s1">// multiplied within Javascript's floating-point representation without overflow</span><span class="s3">\n</span><span class="s1">// or change in sign.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// In the algorithms below, we frequently reduce the negative case to the</span><span class="s3">\n</span><span class="s1">// positive case by negating the input(s) and then post-processing the result.</span><span class="s3">\n</span><span class="s1">// Note that we must ALWAYS check specially whether those values are MIN_VALUE</span><span class="s3">\n</span><span class="s1">// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as</span><span class="s3">\n</span><span class="s1">// a positive number, it overflows back into a negative).  Not handling this</span><span class="s3">\n</span><span class="s1">// case would often result in infinite recursion.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*</span><span class="s3">\n</span><span class="s1">// methods on which they depend.</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An indicator used to reliably determine if an object is a Long or not.</span><span class="s3">\n </span><span class="s1">* @type {boolean}</span><span class="s3">\n </span><span class="s1">* @const</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.prototype.__isLong__;</span><span class="s3">\n\n</span><span class="s1">Object.defineProperty(Long.prototype, </span><span class="s3">\&quot;</span><span class="s1">__isLong__</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {*} obj Object</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isLong(obj) {</span><span class="s3">\n    </span><span class="s1">return (obj &amp;&amp; obj[</span><span class="s3">\&quot;</span><span class="s1">__isLong__</span><span class="s3">\&quot;</span><span class="s1">]) === true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if the specified object is a Long.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {*} obj Object</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.isLong = isLong;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A cache of the Long representations of small integer values.</span><span class="s3">\n </span><span class="s1">* @type {!Object}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var INT_CACHE = {};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A cache of the Long representations of small unsigned integer values.</span><span class="s3">\n </span><span class="s1">* @type {!Object}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var UINT_CACHE = {};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {number} value</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function fromInt(value, unsigned) {</span><span class="s3">\n    </span><span class="s1">var obj, cachedObj, cache;</span><span class="s3">\n    </span><span class="s1">if (unsigned) {</span><span class="s3">\n        </span><span class="s1">value &gt;&gt;&gt;= 0;</span><span class="s3">\n        </span><span class="s1">if (cache = (0 &lt;= value &amp;&amp; value &lt; 256)) {</span><span class="s3">\n            </span><span class="s1">cachedObj = UINT_CACHE[value];</span><span class="s3">\n            </span><span class="s1">if (cachedObj)</span><span class="s3">\n                </span><span class="s1">return cachedObj;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">obj = fromBits(value, (value | 0) &lt; 0 ? -1 : 0, true);</span><span class="s3">\n        </span><span class="s1">if (cache)</span><span class="s3">\n            </span><span class="s1">UINT_CACHE[value] = obj;</span><span class="s3">\n        </span><span class="s1">return obj;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">value |= 0;</span><span class="s3">\n        </span><span class="s1">if (cache = (-128 &lt;= value &amp;&amp; value &lt; 128)) {</span><span class="s3">\n            </span><span class="s1">cachedObj = INT_CACHE[value];</span><span class="s3">\n            </span><span class="s1">if (cachedObj)</span><span class="s3">\n                </span><span class="s1">return cachedObj;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">obj = fromBits(value, value &lt; 0 ? -1 : 0, false);</span><span class="s3">\n        </span><span class="s1">if (cache)</span><span class="s3">\n            </span><span class="s1">INT_CACHE[value] = obj;</span><span class="s3">\n        </span><span class="s1">return obj;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a Long representing the given 32 bit integer value.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number} value The 32 bit integer in question</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @returns {!Long} The corresponding Long value</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.fromInt = fromInt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {number} value</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function fromNumber(value, unsigned) {</span><span class="s3">\n    </span><span class="s1">if (isNaN(value))</span><span class="s3">\n        </span><span class="s1">return unsigned ? UZERO : ZERO;</span><span class="s3">\n    </span><span class="s1">if (unsigned) {</span><span class="s3">\n        </span><span class="s1">if (value &lt; 0)</span><span class="s3">\n            </span><span class="s1">return UZERO;</span><span class="s3">\n        </span><span class="s1">if (value &gt;= TWO_PWR_64_DBL)</span><span class="s3">\n            </span><span class="s1">return MAX_UNSIGNED_VALUE;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (value &lt;= -TWO_PWR_63_DBL)</span><span class="s3">\n            </span><span class="s1">return MIN_VALUE;</span><span class="s3">\n        </span><span class="s1">if (value + 1 &gt;= TWO_PWR_63_DBL)</span><span class="s3">\n            </span><span class="s1">return MAX_VALUE;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (value &lt; 0)</span><span class="s3">\n        </span><span class="s1">return fromNumber(-value, unsigned).neg();</span><span class="s3">\n    </span><span class="s1">return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number} value The number in question</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @returns {!Long} The corresponding Long value</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.fromNumber = fromNumber;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {number} lowBits</span><span class="s3">\n </span><span class="s1">* @param {number} highBits</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function fromBits(lowBits, highBits, unsigned) {</span><span class="s3">\n    </span><span class="s1">return new Long(lowBits, highBits, unsigned);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is</span><span class="s3">\n </span><span class="s1">*  assumed to use 32 bits.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number} lowBits The low 32 bits</span><span class="s3">\n </span><span class="s1">* @param {number} highBits The high 32 bits</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @returns {!Long} The corresponding Long value</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.fromBits = fromBits;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number} base</span><span class="s3">\n </span><span class="s1">* @param {number} exponent</span><span class="s3">\n </span><span class="s1">* @returns {number}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} str</span><span class="s3">\n </span><span class="s1">* @param {(boolean|number)=} unsigned</span><span class="s3">\n </span><span class="s1">* @param {number=} radix</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function fromString(str, unsigned, radix) {</span><span class="s3">\n    </span><span class="s1">if (str.length === 0)</span><span class="s3">\n        </span><span class="s1">throw Error('empty string');</span><span class="s3">\n    </span><span class="s1">if (str === </span><span class="s3">\&quot;</span><span class="s1">NaN</span><span class="s3">\&quot; </span><span class="s1">|| str === </span><span class="s3">\&quot;</span><span class="s1">Infinity</span><span class="s3">\&quot; </span><span class="s1">|| str === </span><span class="s3">\&quot;</span><span class="s1">+Infinity</span><span class="s3">\&quot; </span><span class="s1">|| str === </span><span class="s3">\&quot;</span><span class="s1">-Infinity</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return ZERO;</span><span class="s3">\n    </span><span class="s1">if (typeof unsigned === 'number') {</span><span class="s3">\n        </span><span class="s1">// For goog.math.long compatibility</span><span class="s3">\n        </span><span class="s1">radix = unsigned,</span><span class="s3">\n        </span><span class="s1">unsigned = false;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">unsigned = !! unsigned;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">radix = radix || 10;</span><span class="s3">\n    </span><span class="s1">if (radix &lt; 2 || 36 &lt; radix)</span><span class="s3">\n        </span><span class="s1">throw RangeError('radix');</span><span class="s3">\n\n    </span><span class="s1">var p;</span><span class="s3">\n    </span><span class="s1">if ((p = str.indexOf('-')) &gt; 0)</span><span class="s3">\n        </span><span class="s1">throw Error('interior hyphen');</span><span class="s3">\n    </span><span class="s1">else if (p === 0) {</span><span class="s3">\n        </span><span class="s1">return fromString(str.substring(1), unsigned, radix).neg();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Do several (8) digits each time through the loop, so as to</span><span class="s3">\n    </span><span class="s1">// minimize the calls to the very expensive emulated div.</span><span class="s3">\n    </span><span class="s1">var radixToPower = fromNumber(pow_dbl(radix, 8));</span><span class="s3">\n\n    </span><span class="s1">var result = ZERO;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; str.length; i += 8) {</span><span class="s3">\n        </span><span class="s1">var size = Math.min(8, str.length - i),</span><span class="s3">\n            </span><span class="s1">value = parseInt(str.substring(i, i + size), radix);</span><span class="s3">\n        </span><span class="s1">if (size &lt; 8) {</span><span class="s3">\n            </span><span class="s1">var power = fromNumber(pow_dbl(radix, size));</span><span class="s3">\n            </span><span class="s1">result = result.mul(power).add(fromNumber(value));</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">result = result.mul(radixToPower);</span><span class="s3">\n            </span><span class="s1">result = result.add(fromNumber(value));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">result.unsigned = unsigned;</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a Long representation of the given string, written using the specified radix.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {string} str The textual representation of the Long</span><span class="s3">\n </span><span class="s1">* @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @param {number=} radix The radix in which the text is written (2-36), defaults to 10</span><span class="s3">\n </span><span class="s1">* @returns {!Long} The corresponding Long value</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.fromString = fromString;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function fromValue(val, unsigned) {</span><span class="s3">\n    </span><span class="s1">if (typeof val === 'number')</span><span class="s3">\n        </span><span class="s1">return fromNumber(val, unsigned);</span><span class="s3">\n    </span><span class="s1">if (typeof val === 'string')</span><span class="s3">\n        </span><span class="s1">return fromString(val, unsigned);</span><span class="s3">\n    </span><span class="s1">// Throws for non-objects, converts non-instanceof Long:</span><span class="s3">\n    </span><span class="s1">return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts the specified value to a Long using the appropriate from* function for its type.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.fromValue = fromValue;</span><span class="s3">\n\n</span><span class="s1">// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be</span><span class="s3">\n</span><span class="s1">// no runtime penalty for these.</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {number}</span><span class="s3">\n </span><span class="s1">* @const</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var TWO_PWR_16_DBL = 1 &lt;&lt; 16;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {number}</span><span class="s3">\n </span><span class="s1">* @const</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var TWO_PWR_24_DBL = 1 &lt;&lt; 24;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {number}</span><span class="s3">\n </span><span class="s1">* @const</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {number}</span><span class="s3">\n </span><span class="s1">* @const</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {number}</span><span class="s3">\n </span><span class="s1">* @const</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @const</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var ZERO = fromInt(0);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Signed zero.</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.ZERO = ZERO;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var UZERO = fromInt(0, true);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Unsigned zero.</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.UZERO = UZERO;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var ONE = fromInt(1);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Signed one.</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.ONE = ONE;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var UONE = fromInt(1, true);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Unsigned one.</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.UONE = UONE;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var NEG_ONE = fromInt(-1);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Signed negative one.</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.NEG_ONE = NEG_ONE;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Maximum signed value.</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.MAX_VALUE = MAX_VALUE;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Maximum unsigned value.</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var MIN_VALUE = fromBits(0, 0x80000000|0, false);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Minimum signed value.</span><span class="s3">\n </span><span class="s1">* @type {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.MIN_VALUE = MIN_VALUE;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @alias Long.prototype</span><span class="s3">\n </span><span class="s1">* @inner</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var LongPrototype = Long.prototype;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.toInt = function toInt() {</span><span class="s3">\n    </span><span class="s1">return this.unsigned ? this.low &gt;&gt;&gt; 0 : this.low;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.toNumber = function toNumber() {</span><span class="s3">\n    </span><span class="s1">if (this.unsigned)</span><span class="s3">\n        </span><span class="s1">return ((this.high &gt;&gt;&gt; 0) * TWO_PWR_32_DBL) + (this.low &gt;&gt;&gt; 0);</span><span class="s3">\n    </span><span class="s1">return this.high * TWO_PWR_32_DBL + (this.low &gt;&gt;&gt; 0);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts the Long to a string written in the specified radix.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {number=} radix Radix (2-36), defaults to 10</span><span class="s3">\n </span><span class="s1">* @returns {string}</span><span class="s3">\n </span><span class="s1">* @override</span><span class="s3">\n </span><span class="s1">* @throws {RangeError} If `radix` is out of range</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.toString = function toString(radix) {</span><span class="s3">\n    </span><span class="s1">radix = radix || 10;</span><span class="s3">\n    </span><span class="s1">if (radix &lt; 2 || 36 &lt; radix)</span><span class="s3">\n        </span><span class="s1">throw RangeError('radix');</span><span class="s3">\n    </span><span class="s1">if (this.isZero())</span><span class="s3">\n        </span><span class="s1">return '0';</span><span class="s3">\n    </span><span class="s1">if (this.isNegative()) { // Unsigned Longs are never negative</span><span class="s3">\n        </span><span class="s1">if (this.eq(MIN_VALUE)) {</span><span class="s3">\n            </span><span class="s1">// We need to change the Long value before it can be negated, so we remove</span><span class="s3">\n            </span><span class="s1">// the bottom-most digit in this base and then recurse to do the rest.</span><span class="s3">\n            </span><span class="s1">var radixLong = fromNumber(radix),</span><span class="s3">\n                </span><span class="s1">div = this.div(radixLong),</span><span class="s3">\n                </span><span class="s1">rem1 = div.mul(radixLong).sub(this);</span><span class="s3">\n            </span><span class="s1">return div.toString(radix) + rem1.toInt().toString(radix);</span><span class="s3">\n        </span><span class="s1">} else</span><span class="s3">\n            </span><span class="s1">return '-' + this.neg().toString(radix);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Do several (6) digits each time through the loop, so as to</span><span class="s3">\n    </span><span class="s1">// minimize the calls to the very expensive emulated div.</span><span class="s3">\n    </span><span class="s1">var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),</span><span class="s3">\n        </span><span class="s1">rem = this;</span><span class="s3">\n    </span><span class="s1">var result = '';</span><span class="s3">\n    </span><span class="s1">while (true) {</span><span class="s3">\n        </span><span class="s1">var remDiv = rem.div(radixToPower),</span><span class="s3">\n            </span><span class="s1">intval = rem.sub(remDiv.mul(radixToPower)).toInt() &gt;&gt;&gt; 0,</span><span class="s3">\n            </span><span class="s1">digits = intval.toString(radix);</span><span class="s3">\n        </span><span class="s1">rem = remDiv;</span><span class="s3">\n        </span><span class="s1">if (rem.isZero())</span><span class="s3">\n            </span><span class="s1">return digits + result;</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">while (digits.length &lt; 6)</span><span class="s3">\n                </span><span class="s1">digits = '0' + digits;</span><span class="s3">\n            </span><span class="s1">result = '' + digits + result;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the high 32 bits as a signed integer.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {number} Signed high bits</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.getHighBits = function getHighBits() {</span><span class="s3">\n    </span><span class="s1">return this.high;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the high 32 bits as an unsigned integer.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {number} Unsigned high bits</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {</span><span class="s3">\n    </span><span class="s1">return this.high &gt;&gt;&gt; 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the low 32 bits as a signed integer.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {number} Signed low bits</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.getLowBits = function getLowBits() {</span><span class="s3">\n    </span><span class="s1">return this.low;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the low 32 bits as an unsigned integer.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {number} Unsigned low bits</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {</span><span class="s3">\n    </span><span class="s1">return this.low &gt;&gt;&gt; 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the number of bits needed to represent the absolute value of this Long.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.getNumBitsAbs = function getNumBitsAbs() {</span><span class="s3">\n    </span><span class="s1">if (this.isNegative()) // Unsigned Longs are never negative</span><span class="s3">\n        </span><span class="s1">return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();</span><span class="s3">\n    </span><span class="s1">var val = this.high != 0 ? this.high : this.low;</span><span class="s3">\n    </span><span class="s1">for (var bit = 31; bit &gt; 0; bit--)</span><span class="s3">\n        </span><span class="s1">if ((val &amp; (1 &lt;&lt; bit)) != 0)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">return this.high != 0 ? bit + 33 : bit + 1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value equals zero.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.isZero = function isZero() {</span><span class="s3">\n    </span><span class="s1">return this.high === 0 &amp;&amp; this.low === 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.eqz = LongPrototype.isZero;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is negative.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.isNegative = function isNegative() {</span><span class="s3">\n    </span><span class="s1">return !this.unsigned &amp;&amp; this.high &lt; 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is positive.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.isPositive = function isPositive() {</span><span class="s3">\n    </span><span class="s1">return this.unsigned || this.high &gt;= 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is odd.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.isOdd = function isOdd() {</span><span class="s3">\n    </span><span class="s1">return (this.low &amp; 1) === 1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is even.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.isEven = function isEven() {</span><span class="s3">\n    </span><span class="s1">return (this.low &amp; 1) === 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value equals the specified's.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.equals = function equals(other) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(other))</span><span class="s3">\n        </span><span class="s1">other = fromValue(other);</span><span class="s3">\n    </span><span class="s1">if (this.unsigned !== other.unsigned &amp;&amp; (this.high &gt;&gt;&gt; 31) === 1 &amp;&amp; (other.high &gt;&gt;&gt; 31) === 1)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">return this.high === other.high &amp;&amp; this.low === other.low;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.eq = LongPrototype.equals;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value differs from the specified's.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.notEquals = function notEquals(other) {</span><span class="s3">\n    </span><span class="s1">return !this.eq(/* validates */ other);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.neq = LongPrototype.notEquals;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.ne = LongPrototype.notEquals;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is less than the specified's.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.lessThan = function lessThan(other) {</span><span class="s3">\n    </span><span class="s1">return this.comp(/* validates */ other) &lt; 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.lt = LongPrototype.lessThan;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is less than or equal the specified's.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {</span><span class="s3">\n    </span><span class="s1">return this.comp(/* validates */ other) &lt;= 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.lte = LongPrototype.lessThanOrEqual;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.le = LongPrototype.lessThanOrEqual;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is greater than the specified's.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.greaterThan = function greaterThan(other) {</span><span class="s3">\n    </span><span class="s1">return this.comp(/* validates */ other) &gt; 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.gt = LongPrototype.greaterThan;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is greater than or equal the specified's.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {</span><span class="s3">\n    </span><span class="s1">return this.comp(/* validates */ other) &gt;= 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.gte = LongPrototype.greaterThanOrEqual;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.ge = LongPrototype.greaterThanOrEqual;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Compares this Long's value with the specified's.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {number} 0 if they are the same, 1 if the this is greater and -1</span><span class="s3">\n </span><span class="s1">*  if the given one is greater</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.compare = function compare(other) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(other))</span><span class="s3">\n        </span><span class="s1">other = fromValue(other);</span><span class="s3">\n    </span><span class="s1">if (this.eq(other))</span><span class="s3">\n        </span><span class="s1">return 0;</span><span class="s3">\n    </span><span class="s1">var thisNeg = this.isNegative(),</span><span class="s3">\n        </span><span class="s1">otherNeg = other.isNegative();</span><span class="s3">\n    </span><span class="s1">if (thisNeg &amp;&amp; !otherNeg)</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">if (!thisNeg &amp;&amp; otherNeg)</span><span class="s3">\n        </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">// At this point the sign bits are the same</span><span class="s3">\n    </span><span class="s1">if (!this.unsigned)</span><span class="s3">\n        </span><span class="s1">return this.sub(other).isNegative() ? -1 : 1;</span><span class="s3">\n    </span><span class="s1">// Both are positive if at least one is unsigned</span><span class="s3">\n    </span><span class="s1">return (other.high &gt;&gt;&gt; 0) &gt; (this.high &gt;&gt;&gt; 0) || (other.high === this.high &amp;&amp; (other.low &gt;&gt;&gt; 0) &gt; (this.low &gt;&gt;&gt; 0)) ? -1 : 1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other value</span><span class="s3">\n </span><span class="s1">* @returns {number} 0 if they are the same, 1 if the this is greater and -1</span><span class="s3">\n </span><span class="s1">*  if the given one is greater</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.comp = LongPrototype.compare;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Negates this Long's value.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Negated Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.negate = function negate() {</span><span class="s3">\n    </span><span class="s1">if (!this.unsigned &amp;&amp; this.eq(MIN_VALUE))</span><span class="s3">\n        </span><span class="s1">return MIN_VALUE;</span><span class="s3">\n    </span><span class="s1">return this.not().add(ONE);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Negates this Long's value. This is an alias of {@link Long#negate}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Negated Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.neg = LongPrototype.negate;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the sum of this and the specified Long.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} addend Addend</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Sum</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.add = function add(addend) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(addend))</span><span class="s3">\n        </span><span class="s1">addend = fromValue(addend);</span><span class="s3">\n\n    </span><span class="s1">// Divide each number into 4 chunks of 16 bits, and then sum the chunks.</span><span class="s3">\n\n    </span><span class="s1">var a48 = this.high &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">var a32 = this.high &amp; 0xFFFF;</span><span class="s3">\n    </span><span class="s1">var a16 = this.low &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">var a00 = this.low &amp; 0xFFFF;</span><span class="s3">\n\n    </span><span class="s1">var b48 = addend.high &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">var b32 = addend.high &amp; 0xFFFF;</span><span class="s3">\n    </span><span class="s1">var b16 = addend.low &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">var b00 = addend.low &amp; 0xFFFF;</span><span class="s3">\n\n    </span><span class="s1">var c48 = 0, c32 = 0, c16 = 0, c00 = 0;</span><span class="s3">\n    </span><span class="s1">c00 += a00 + b00;</span><span class="s3">\n    </span><span class="s1">c16 += c00 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c00 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c16 += a16 + b16;</span><span class="s3">\n    </span><span class="s1">c32 += c16 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c16 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c32 += a32 + b32;</span><span class="s3">\n    </span><span class="s1">c48 += c32 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c32 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c48 += a48 + b48;</span><span class="s3">\n    </span><span class="s1">c48 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">return fromBits((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32, this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the difference of this and the specified Long.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} subtrahend Subtrahend</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Difference</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.subtract = function subtract(subtrahend) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(subtrahend))</span><span class="s3">\n        </span><span class="s1">subtrahend = fromValue(subtrahend);</span><span class="s3">\n    </span><span class="s1">return this.add(subtrahend.neg());</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} subtrahend Subtrahend</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Difference</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.sub = LongPrototype.subtract;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the product of this and the specified Long.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} multiplier Multiplier</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Product</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.multiply = function multiply(multiplier) {</span><span class="s3">\n    </span><span class="s1">if (this.isZero())</span><span class="s3">\n        </span><span class="s1">return ZERO;</span><span class="s3">\n    </span><span class="s1">if (!isLong(multiplier))</span><span class="s3">\n        </span><span class="s1">multiplier = fromValue(multiplier);</span><span class="s3">\n\n    </span><span class="s1">// use wasm support if present</span><span class="s3">\n    </span><span class="s1">if (wasm) {</span><span class="s3">\n        </span><span class="s1">var low = wasm[</span><span class="s3">\&quot;</span><span class="s1">mul</span><span class="s3">\&quot;</span><span class="s1">](this.low,</span><span class="s3">\n                              </span><span class="s1">this.high,</span><span class="s3">\n                              </span><span class="s1">multiplier.low,</span><span class="s3">\n                              </span><span class="s1">multiplier.high);</span><span class="s3">\n        </span><span class="s1">return fromBits(low, wasm[</span><span class="s3">\&quot;</span><span class="s1">get_high</span><span class="s3">\&quot;</span><span class="s1">](), this.unsigned);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (multiplier.isZero())</span><span class="s3">\n        </span><span class="s1">return ZERO;</span><span class="s3">\n    </span><span class="s1">if (this.eq(MIN_VALUE))</span><span class="s3">\n        </span><span class="s1">return multiplier.isOdd() ? MIN_VALUE : ZERO;</span><span class="s3">\n    </span><span class="s1">if (multiplier.eq(MIN_VALUE))</span><span class="s3">\n        </span><span class="s1">return this.isOdd() ? MIN_VALUE : ZERO;</span><span class="s3">\n\n    </span><span class="s1">if (this.isNegative()) {</span><span class="s3">\n        </span><span class="s1">if (multiplier.isNegative())</span><span class="s3">\n            </span><span class="s1">return this.neg().mul(multiplier.neg());</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">return this.neg().mul(multiplier).neg();</span><span class="s3">\n    </span><span class="s1">} else if (multiplier.isNegative())</span><span class="s3">\n        </span><span class="s1">return this.mul(multiplier.neg()).neg();</span><span class="s3">\n\n    </span><span class="s1">// If both longs are small, use float multiplication</span><span class="s3">\n    </span><span class="s1">if (this.lt(TWO_PWR_24) &amp;&amp; multiplier.lt(TWO_PWR_24))</span><span class="s3">\n        </span><span class="s1">return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);</span><span class="s3">\n\n    </span><span class="s1">// Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.</span><span class="s3">\n    </span><span class="s1">// We can skip products that would overflow.</span><span class="s3">\n\n    </span><span class="s1">var a48 = this.high &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">var a32 = this.high &amp; 0xFFFF;</span><span class="s3">\n    </span><span class="s1">var a16 = this.low &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">var a00 = this.low &amp; 0xFFFF;</span><span class="s3">\n\n    </span><span class="s1">var b48 = multiplier.high &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">var b32 = multiplier.high &amp; 0xFFFF;</span><span class="s3">\n    </span><span class="s1">var b16 = multiplier.low &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">var b00 = multiplier.low &amp; 0xFFFF;</span><span class="s3">\n\n    </span><span class="s1">var c48 = 0, c32 = 0, c16 = 0, c00 = 0;</span><span class="s3">\n    </span><span class="s1">c00 += a00 * b00;</span><span class="s3">\n    </span><span class="s1">c16 += c00 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c00 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c16 += a16 * b00;</span><span class="s3">\n    </span><span class="s1">c32 += c16 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c16 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c16 += a00 * b16;</span><span class="s3">\n    </span><span class="s1">c32 += c16 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c16 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c32 += a32 * b00;</span><span class="s3">\n    </span><span class="s1">c48 += c32 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c32 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c32 += a16 * b16;</span><span class="s3">\n    </span><span class="s1">c48 += c32 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c32 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c32 += a00 * b32;</span><span class="s3">\n    </span><span class="s1">c48 += c32 &gt;&gt;&gt; 16;</span><span class="s3">\n    </span><span class="s1">c32 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;</span><span class="s3">\n    </span><span class="s1">c48 &amp;= 0xFFFF;</span><span class="s3">\n    </span><span class="s1">return fromBits((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32, this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} multiplier Multiplier</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Product</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.mul = LongPrototype.multiply;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long divided by the specified. The result is signed if this Long is signed or</span><span class="s3">\n </span><span class="s1">*  unsigned if this Long is unsigned.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} divisor Divisor</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Quotient</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.divide = function divide(divisor) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(divisor))</span><span class="s3">\n        </span><span class="s1">divisor = fromValue(divisor);</span><span class="s3">\n    </span><span class="s1">if (divisor.isZero())</span><span class="s3">\n        </span><span class="s1">throw Error('division by zero');</span><span class="s3">\n\n    </span><span class="s1">// use wasm support if present</span><span class="s3">\n    </span><span class="s1">if (wasm) {</span><span class="s3">\n        </span><span class="s1">// guard against signed division overflow: the largest</span><span class="s3">\n        </span><span class="s1">// negative number / -1 would be 1 larger than the largest</span><span class="s3">\n        </span><span class="s1">// positive number, due to two's complement.</span><span class="s3">\n        </span><span class="s1">if (!this.unsigned &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.high === -0x80000000 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">divisor.low === -1 &amp;&amp; divisor.high === -1) {</span><span class="s3">\n            </span><span class="s1">// be consistent with non-wasm code path</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var low = (this.unsigned ? wasm[</span><span class="s3">\&quot;</span><span class="s1">div_u</span><span class="s3">\&quot;</span><span class="s1">] : wasm[</span><span class="s3">\&quot;</span><span class="s1">div_s</span><span class="s3">\&quot;</span><span class="s1">])(</span><span class="s3">\n            </span><span class="s1">this.low,</span><span class="s3">\n            </span><span class="s1">this.high,</span><span class="s3">\n            </span><span class="s1">divisor.low,</span><span class="s3">\n            </span><span class="s1">divisor.high</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return fromBits(low, wasm[</span><span class="s3">\&quot;</span><span class="s1">get_high</span><span class="s3">\&quot;</span><span class="s1">](), this.unsigned);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.isZero())</span><span class="s3">\n        </span><span class="s1">return this.unsigned ? UZERO : ZERO;</span><span class="s3">\n    </span><span class="s1">var approx, rem, res;</span><span class="s3">\n    </span><span class="s1">if (!this.unsigned) {</span><span class="s3">\n        </span><span class="s1">// This section is only relevant for signed longs and is derived from the</span><span class="s3">\n        </span><span class="s1">// closure library as a whole.</span><span class="s3">\n        </span><span class="s1">if (this.eq(MIN_VALUE)) {</span><span class="s3">\n            </span><span class="s1">if (divisor.eq(ONE) || divisor.eq(NEG_ONE))</span><span class="s3">\n                </span><span class="s1">return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE</span><span class="s3">\n            </span><span class="s1">else if (divisor.eq(MIN_VALUE))</span><span class="s3">\n                </span><span class="s1">return ONE;</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">// At this point, we have |other| &gt;= 2, so |this/other| &lt; |MIN_VALUE|.</span><span class="s3">\n                </span><span class="s1">var halfThis = this.shr(1);</span><span class="s3">\n                </span><span class="s1">approx = halfThis.div(divisor).shl(1);</span><span class="s3">\n                </span><span class="s1">if (approx.eq(ZERO)) {</span><span class="s3">\n                    </span><span class="s1">return divisor.isNegative() ? ONE : NEG_ONE;</span><span class="s3">\n                </span><span class="s1">} else {</span><span class="s3">\n                    </span><span class="s1">rem = this.sub(divisor.mul(approx));</span><span class="s3">\n                    </span><span class="s1">res = approx.add(rem.div(divisor));</span><span class="s3">\n                    </span><span class="s1">return res;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (divisor.eq(MIN_VALUE))</span><span class="s3">\n            </span><span class="s1">return this.unsigned ? UZERO : ZERO;</span><span class="s3">\n        </span><span class="s1">if (this.isNegative()) {</span><span class="s3">\n            </span><span class="s1">if (divisor.isNegative())</span><span class="s3">\n                </span><span class="s1">return this.neg().div(divisor.neg());</span><span class="s3">\n            </span><span class="s1">return this.neg().div(divisor).neg();</span><span class="s3">\n        </span><span class="s1">} else if (divisor.isNegative())</span><span class="s3">\n            </span><span class="s1">return this.div(divisor.neg()).neg();</span><span class="s3">\n        </span><span class="s1">res = ZERO;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// The algorithm below has not been made for unsigned longs. It's therefore</span><span class="s3">\n        </span><span class="s1">// required to take special care of the MSB prior to running it.</span><span class="s3">\n        </span><span class="s1">if (!divisor.unsigned)</span><span class="s3">\n            </span><span class="s1">divisor = divisor.toUnsigned();</span><span class="s3">\n        </span><span class="s1">if (divisor.gt(this))</span><span class="s3">\n            </span><span class="s1">return UZERO;</span><span class="s3">\n        </span><span class="s1">if (divisor.gt(this.shru(1))) // 15 &gt;&gt;&gt; 1 = 7 ; with divisor = 8 ; true</span><span class="s3">\n            </span><span class="s1">return UONE;</span><span class="s3">\n        </span><span class="s1">res = UZERO;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Repeat the following until the remainder is less than other:  find a</span><span class="s3">\n    </span><span class="s1">// floating-point that approximates remainder / other *from below*, add this</span><span class="s3">\n    </span><span class="s1">// into the result, and subtract it from the remainder.  It is critical that</span><span class="s3">\n    </span><span class="s1">// the approximate value is less than or equal to the real value so that the</span><span class="s3">\n    </span><span class="s1">// remainder never becomes negative.</span><span class="s3">\n    </span><span class="s1">rem = this;</span><span class="s3">\n    </span><span class="s1">while (rem.gte(divisor)) {</span><span class="s3">\n        </span><span class="s1">// Approximate the result of division. This may be a little greater or</span><span class="s3">\n        </span><span class="s1">// smaller than the actual value.</span><span class="s3">\n        </span><span class="s1">approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));</span><span class="s3">\n\n        </span><span class="s1">// We will tweak the approximate result by changing it in the 48-th digit or</span><span class="s3">\n        </span><span class="s1">// the smallest non-fractional digit, whichever is larger.</span><span class="s3">\n        </span><span class="s1">var log2 = Math.ceil(Math.log(approx) / Math.LN2),</span><span class="s3">\n            </span><span class="s1">delta = (log2 &lt;= 48) ? 1 : pow_dbl(2, log2 - 48),</span><span class="s3">\n\n        </span><span class="s1">// Decrease the approximation until it is smaller than the remainder.  Note</span><span class="s3">\n        </span><span class="s1">// that if it is too large, the product overflows and is negative.</span><span class="s3">\n            </span><span class="s1">approxRes = fromNumber(approx),</span><span class="s3">\n            </span><span class="s1">approxRem = approxRes.mul(divisor);</span><span class="s3">\n        </span><span class="s1">while (approxRem.isNegative() || approxRem.gt(rem)) {</span><span class="s3">\n            </span><span class="s1">approx -= delta;</span><span class="s3">\n            </span><span class="s1">approxRes = fromNumber(approx, this.unsigned);</span><span class="s3">\n            </span><span class="s1">approxRem = approxRes.mul(divisor);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// We know the answer can't be zero... and actually, zero would cause</span><span class="s3">\n        </span><span class="s1">// infinite recursion since we would make no progress.</span><span class="s3">\n        </span><span class="s1">if (approxRes.isZero())</span><span class="s3">\n            </span><span class="s1">approxRes = ONE;</span><span class="s3">\n\n        </span><span class="s1">res = res.add(approxRes);</span><span class="s3">\n        </span><span class="s1">rem = rem.sub(approxRem);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return res;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long divided by the specified. This is an alias of {@link Long#divide}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} divisor Divisor</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Quotient</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.div = LongPrototype.divide;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long modulo the specified.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} divisor Divisor</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Remainder</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.modulo = function modulo(divisor) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(divisor))</span><span class="s3">\n        </span><span class="s1">divisor = fromValue(divisor);</span><span class="s3">\n\n    </span><span class="s1">// use wasm support if present</span><span class="s3">\n    </span><span class="s1">if (wasm) {</span><span class="s3">\n        </span><span class="s1">var low = (this.unsigned ? wasm[</span><span class="s3">\&quot;</span><span class="s1">rem_u</span><span class="s3">\&quot;</span><span class="s1">] : wasm[</span><span class="s3">\&quot;</span><span class="s1">rem_s</span><span class="s3">\&quot;</span><span class="s1">])(</span><span class="s3">\n            </span><span class="s1">this.low,</span><span class="s3">\n            </span><span class="s1">this.high,</span><span class="s3">\n            </span><span class="s1">divisor.low,</span><span class="s3">\n            </span><span class="s1">divisor.high</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return fromBits(low, wasm[</span><span class="s3">\&quot;</span><span class="s1">get_high</span><span class="s3">\&quot;</span><span class="s1">](), this.unsigned);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.sub(this.div(divisor).mul(divisor));</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} divisor Divisor</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Remainder</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.mod = LongPrototype.modulo;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} divisor Divisor</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Remainder</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.rem = LongPrototype.modulo;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the bitwise NOT of this Long.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.not = function not() {</span><span class="s3">\n    </span><span class="s1">return fromBits(~this.low, ~this.high, this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the bitwise AND of this Long and the specified.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other Long</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.and = function and(other) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(other))</span><span class="s3">\n        </span><span class="s1">other = fromValue(other);</span><span class="s3">\n    </span><span class="s1">return fromBits(this.low &amp; other.low, this.high &amp; other.high, this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the bitwise OR of this Long and the specified.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other Long</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.or = function or(other) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(other))</span><span class="s3">\n        </span><span class="s1">other = fromValue(other);</span><span class="s3">\n    </span><span class="s1">return fromBits(this.low | other.low, this.high | other.high, this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the bitwise XOR of this Long and the given one.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {!Long|number|string} other Other Long</span><span class="s3">\n </span><span class="s1">* @returns {!Long}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.xor = function xor(other) {</span><span class="s3">\n    </span><span class="s1">if (!isLong(other))</span><span class="s3">\n        </span><span class="s1">other = fromValue(other);</span><span class="s3">\n    </span><span class="s1">return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits shifted to the left by the given amount.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Shifted Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.shiftLeft = function shiftLeft(numBits) {</span><span class="s3">\n    </span><span class="s1">if (isLong(numBits))</span><span class="s3">\n        </span><span class="s1">numBits = numBits.toInt();</span><span class="s3">\n    </span><span class="s1">if ((numBits &amp;= 63) === 0)</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">else if (numBits &lt; 32)</span><span class="s3">\n        </span><span class="s1">return fromBits(this.low &lt;&lt; numBits, (this.high &lt;&lt; numBits) | (this.low &gt;&gt;&gt; (32 - numBits)), this.unsigned);</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">return fromBits(0, this.low &lt;&lt; (numBits - 32), this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Shifted Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.shl = LongPrototype.shiftLeft;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits arithmetically shifted to the right by the given amount.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Shifted Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.shiftRight = function shiftRight(numBits) {</span><span class="s3">\n    </span><span class="s1">if (isLong(numBits))</span><span class="s3">\n        </span><span class="s1">numBits = numBits.toInt();</span><span class="s3">\n    </span><span class="s1">if ((numBits &amp;= 63) === 0)</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">else if (numBits &lt; 32)</span><span class="s3">\n        </span><span class="s1">return fromBits((this.low &gt;&gt;&gt; numBits) | (this.high &lt;&lt; (32 - numBits)), this.high &gt;&gt; numBits, this.unsigned);</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">return fromBits(this.high &gt;&gt; (numBits - 32), this.high &gt;= 0 ? 0 : -1, this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Shifted Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.shr = LongPrototype.shiftRight;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits logically shifted to the right by the given amount.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Shifted Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {</span><span class="s3">\n    </span><span class="s1">if (isLong(numBits)) numBits = numBits.toInt();</span><span class="s3">\n    </span><span class="s1">if ((numBits &amp;= 63) === 0) return this;</span><span class="s3">\n    </span><span class="s1">if (numBits &lt; 32) return fromBits((this.low &gt;&gt;&gt; numBits) | (this.high &lt;&lt; (32 - numBits)), this.high &gt;&gt;&gt; numBits, this.unsigned);</span><span class="s3">\n    </span><span class="s1">if (numBits === 32) return fromBits(this.high, 0, this.unsigned);</span><span class="s3">\n    </span><span class="s1">return fromBits(this.high &gt;&gt;&gt; (numBits - 32), 0, this.unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Shifted Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.shru = LongPrototype.shiftRightUnsigned;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Shifted Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits rotated to the left by the given amount.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Rotated Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.rotateLeft = function rotateLeft(numBits) {</span><span class="s3">\n    </span><span class="s1">var b;</span><span class="s3">\n    </span><span class="s1">if (isLong(numBits)) numBits = numBits.toInt();</span><span class="s3">\n    </span><span class="s1">if ((numBits &amp;= 63) === 0) return this;</span><span class="s3">\n    </span><span class="s1">if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);</span><span class="s3">\n    </span><span class="s1">if (numBits &lt; 32) {</span><span class="s3">\n        </span><span class="s1">b = (32 - numBits);</span><span class="s3">\n        </span><span class="s1">return fromBits(((this.low &lt;&lt; numBits) | (this.high &gt;&gt;&gt; b)), ((this.high &lt;&lt; numBits) | (this.low &gt;&gt;&gt; b)), this.unsigned);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">numBits -= 32;</span><span class="s3">\n    </span><span class="s1">b = (32 - numBits);</span><span class="s3">\n    </span><span class="s1">return fromBits(((this.high &lt;&lt; numBits) | (this.low &gt;&gt;&gt; b)), ((this.low &lt;&lt; numBits) | (this.high &gt;&gt;&gt; b)), this.unsigned);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Rotated Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.rotl = LongPrototype.rotateLeft;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits rotated to the right by the given amount.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Rotated Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.rotateRight = function rotateRight(numBits) {</span><span class="s3">\n    </span><span class="s1">var b;</span><span class="s3">\n    </span><span class="s1">if (isLong(numBits)) numBits = numBits.toInt();</span><span class="s3">\n    </span><span class="s1">if ((numBits &amp;= 63) === 0) return this;</span><span class="s3">\n    </span><span class="s1">if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);</span><span class="s3">\n    </span><span class="s1">if (numBits &lt; 32) {</span><span class="s3">\n        </span><span class="s1">b = (32 - numBits);</span><span class="s3">\n        </span><span class="s1">return fromBits(((this.high &lt;&lt; b) | (this.low &gt;&gt;&gt; numBits)), ((this.low &lt;&lt; b) | (this.high &gt;&gt;&gt; numBits)), this.unsigned);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">numBits -= 32;</span><span class="s3">\n    </span><span class="s1">b = (32 - numBits);</span><span class="s3">\n    </span><span class="s1">return fromBits(((this.low &lt;&lt; b) | (this.high &gt;&gt;&gt; numBits)), ((this.high &lt;&lt; b) | (this.low &gt;&gt;&gt; numBits)), this.unsigned);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number|!Long} numBits Number of bits</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Rotated Long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.rotr = LongPrototype.rotateRight;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts this Long to signed.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Signed long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.toSigned = function toSigned() {</span><span class="s3">\n    </span><span class="s1">if (!this.unsigned)</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">return fromBits(this.low, this.high, false);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts this Long to unsigned.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {!Long} Unsigned long</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.toUnsigned = function toUnsigned() {</span><span class="s3">\n    </span><span class="s1">if (this.unsigned)</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">return fromBits(this.low, this.high, true);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts this Long to its byte representation.</span><span class="s3">\n </span><span class="s1">* @param {boolean=} le Whether little or big endian, defaults to big endian</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {!Array.&lt;number&gt;} Byte representation</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.toBytes = function toBytes(le) {</span><span class="s3">\n    </span><span class="s1">return le ? this.toBytesLE() : this.toBytesBE();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts this Long to its little endian byte representation.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {!Array.&lt;number&gt;} Little endian byte representation</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.toBytesLE = function toBytesLE() {</span><span class="s3">\n    </span><span class="s1">var hi = this.high,</span><span class="s3">\n        </span><span class="s1">lo = this.low;</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n        </span><span class="s1">lo        &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">lo &gt;&gt;&gt;  8 &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">lo &gt;&gt;&gt; 16 &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">lo &gt;&gt;&gt; 24       ,</span><span class="s3">\n        </span><span class="s1">hi        &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">hi &gt;&gt;&gt;  8 &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">hi &gt;&gt;&gt; 16 &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">hi &gt;&gt;&gt; 24</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts this Long to its big endian byte representation.</span><span class="s3">\n </span><span class="s1">* @this {!Long}</span><span class="s3">\n </span><span class="s1">* @returns {!Array.&lt;number&gt;} Big endian byte representation</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LongPrototype.toBytesBE = function toBytesBE() {</span><span class="s3">\n    </span><span class="s1">var hi = this.high,</span><span class="s3">\n        </span><span class="s1">lo = this.low;</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n        </span><span class="s1">hi &gt;&gt;&gt; 24       ,</span><span class="s3">\n        </span><span class="s1">hi &gt;&gt;&gt; 16 &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">hi &gt;&gt;&gt;  8 &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">hi        &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">lo &gt;&gt;&gt; 24       ,</span><span class="s3">\n        </span><span class="s1">lo &gt;&gt;&gt; 16 &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">lo &gt;&gt;&gt;  8 &amp; 0xff,</span><span class="s3">\n        </span><span class="s1">lo        &amp; 0xff</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a Long from its byte representation.</span><span class="s3">\n </span><span class="s1">* @param {!Array.&lt;number&gt;} bytes Byte representation</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @param {boolean=} le Whether little or big endian, defaults to big endian</span><span class="s3">\n </span><span class="s1">* @returns {Long} The corresponding Long value</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.fromBytes = function fromBytes(bytes, unsigned, le) {</span><span class="s3">\n    </span><span class="s1">return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a Long from its little endian byte representation.</span><span class="s3">\n </span><span class="s1">* @param {!Array.&lt;number&gt;} bytes Little endian byte representation</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @returns {Long} The corresponding Long value</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {</span><span class="s3">\n    </span><span class="s1">return new Long(</span><span class="s3">\n        </span><span class="s1">bytes[0]       |</span><span class="s3">\n        </span><span class="s1">bytes[1] &lt;&lt;  8 |</span><span class="s3">\n        </span><span class="s1">bytes[2] &lt;&lt; 16 |</span><span class="s3">\n        </span><span class="s1">bytes[3] &lt;&lt; 24,</span><span class="s3">\n        </span><span class="s1">bytes[4]       |</span><span class="s3">\n        </span><span class="s1">bytes[5] &lt;&lt;  8 |</span><span class="s3">\n        </span><span class="s1">bytes[6] &lt;&lt; 16 |</span><span class="s3">\n        </span><span class="s1">bytes[7] &lt;&lt; 24,</span><span class="s3">\n        </span><span class="s1">unsigned</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a Long from its big endian byte representation.</span><span class="s3">\n </span><span class="s1">* @param {!Array.&lt;number&gt;} bytes Big endian byte representation</span><span class="s3">\n </span><span class="s1">* @param {boolean=} unsigned Whether unsigned or not, defaults to signed</span><span class="s3">\n </span><span class="s1">* @returns {Long} The corresponding Long value</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {</span><span class="s3">\n    </span><span class="s1">return new Long(</span><span class="s3">\n        </span><span class="s1">bytes[4] &lt;&lt; 24 |</span><span class="s3">\n        </span><span class="s1">bytes[5] &lt;&lt; 16 |</span><span class="s3">\n        </span><span class="s1">bytes[6] &lt;&lt;  8 |</span><span class="s3">\n        </span><span class="s1">bytes[7],</span><span class="s3">\n        </span><span class="s1">bytes[0] &lt;&lt; 24 |</span><span class="s3">\n        </span><span class="s1">bytes[1] &lt;&lt; 16 |</span><span class="s3">\n        </span><span class="s1">bytes[2] &lt;&lt;  8 |</span><span class="s3">\n        </span><span class="s1">bytes[3],</span><span class="s3">\n        </span><span class="s1">unsigned</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n\n\n</span><span class="s1">//////////////////</span><span class="s3">\n</span><span class="s1">// WEBPACK FOOTER</span><span class="s3">\n</span><span class="s1">// ./src/long.js</span><span class="s3">\n</span><span class="s1">// module id = 0</span><span class="s3">\n</span><span class="s1">// module chunks = 0&quot;</span><span class="s0">],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>