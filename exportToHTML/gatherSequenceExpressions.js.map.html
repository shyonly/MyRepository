<html>
<head>
<title>gatherSequenceExpressions.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
gatherSequenceExpressions.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_getBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_index&quot;</span><span class="s0">,</span><span class="s1">&quot;_index2&quot;</span><span class="s0">,</span><span class="s1">&quot;_cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;gatherSequenceExpressions&quot;</span><span class="s0">,</span><span class="s1">&quot;nodes&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;declars&quot;</span><span class="s0">,</span><span class="s1">&quot;exprs&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureLastUndefined&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;isEmptyStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;declar&quot;</span><span class="s0">,</span><span class="s1">&quot;declarations&quot;</span><span class="s0">,</span><span class="s1">&quot;bindings&quot;</span><span class="s0">,</span><span class="s1">&quot;getBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isIfStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;consequent&quot;</span><span class="s0">,</span><span class="s1">&quot;buildUndefinedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;alternate&quot;</span><span class="s0">,</span><span class="s1">&quot;conditionalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;isBlockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/converters/gatherSequenceExpressions.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import getBindingIdentifiers from </span><span class="s3">\&quot;</span><span class="s1">../retrievers/getBindingIdentifiers.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isExpression,</span><span class="s3">\n  </span><span class="s1">isExpressionStatement,</span><span class="s3">\n  </span><span class="s1">isVariableDeclaration,</span><span class="s3">\n  </span><span class="s1">isIfStatement,</span><span class="s3">\n  </span><span class="s1">isBlockStatement,</span><span class="s3">\n  </span><span class="s1">isEmptyStatement,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">../validators/generated/index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">sequenceExpression,</span><span class="s3">\n  </span><span class="s1">assignmentExpression,</span><span class="s3">\n  </span><span class="s1">conditionalExpression,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">../builders/generated/index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import cloneNode from </span><span class="s3">\&quot;</span><span class="s1">../clone/cloneNode.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">../index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Scope } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export type DeclarationInfo = {</span><span class="s3">\n  </span><span class="s1">kind: t.VariableDeclaration[</span><span class="s3">\&quot;</span><span class="s1">kind</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">id: t.Identifier;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default function gatherSequenceExpressions(</span><span class="s3">\n  </span><span class="s1">nodes: ReadonlyArray&lt;t.Node&gt;,</span><span class="s3">\n  </span><span class="s1">scope: Scope,</span><span class="s3">\n  </span><span class="s1">declars: Array&lt;DeclarationInfo&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const exprs: t.Expression[] = [];</span><span class="s3">\n  </span><span class="s1">let ensureLastUndefined = true;</span><span class="s3">\n\n  </span><span class="s1">for (const node of nodes) {</span><span class="s3">\n    </span><span class="s1">// if we encounter emptyStatement before a non-emptyStatement</span><span class="s3">\n    </span><span class="s1">// we want to disregard that</span><span class="s3">\n    </span><span class="s1">if (!isEmptyStatement(node)) {</span><span class="s3">\n      </span><span class="s1">ensureLastUndefined = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isExpression(node)) {</span><span class="s3">\n      </span><span class="s1">exprs.push(node);</span><span class="s3">\n    </span><span class="s1">} else if (isExpressionStatement(node)) {</span><span class="s3">\n      </span><span class="s1">exprs.push(node.expression);</span><span class="s3">\n    </span><span class="s1">} else if (isVariableDeclaration(node)) {</span><span class="s3">\n      </span><span class="s1">if (node.kind !== </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">) return; // bailed</span><span class="s3">\n\n      </span><span class="s1">for (const declar of node.declarations) {</span><span class="s3">\n        </span><span class="s1">const bindings = getBindingIdentifiers(declar);</span><span class="s3">\n        </span><span class="s1">for (const key of Object.keys(bindings)) {</span><span class="s3">\n          </span><span class="s1">declars.push({</span><span class="s3">\n            </span><span class="s1">kind: node.kind,</span><span class="s3">\n            </span><span class="s1">id: cloneNode(bindings[key]),</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (declar.init) {</span><span class="s3">\n          </span><span class="s1">exprs.push(assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, declar.id, declar.init));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">ensureLastUndefined = true;</span><span class="s3">\n    </span><span class="s1">} else if (isIfStatement(node)) {</span><span class="s3">\n      </span><span class="s1">const consequent = node.consequent</span><span class="s3">\n        </span><span class="s1">? gatherSequenceExpressions([node.consequent], scope, declars)</span><span class="s3">\n        </span><span class="s1">: scope.buildUndefinedNode();</span><span class="s3">\n      </span><span class="s1">const alternate = node.alternate</span><span class="s3">\n        </span><span class="s1">? gatherSequenceExpressions([node.alternate], scope, declars)</span><span class="s3">\n        </span><span class="s1">: scope.buildUndefinedNode();</span><span class="s3">\n      </span><span class="s1">if (!consequent || !alternate) return; // bailed</span><span class="s3">\n\n      </span><span class="s1">exprs.push(conditionalExpression(node.test, consequent, alternate));</span><span class="s3">\n    </span><span class="s1">} else if (isBlockStatement(node)) {</span><span class="s3">\n      </span><span class="s1">const body = gatherSequenceExpressions(node.body, scope, declars);</span><span class="s3">\n      </span><span class="s1">if (!body) return; // bailed</span><span class="s3">\n\n      </span><span class="s1">exprs.push(body);</span><span class="s3">\n    </span><span class="s1">} else if (isEmptyStatement(node)) {</span><span class="s3">\n      </span><span class="s1">// empty statement so ensure the last item is undefined if we're last</span><span class="s3">\n      </span><span class="s1">// checks if emptyStatement is first</span><span class="s3">\n      </span><span class="s1">if (nodes.indexOf(node) === 0) {</span><span class="s3">\n        </span><span class="s1">ensureLastUndefined = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// bailed, we can't turn this statement into an expression</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (ensureLastUndefined) {</span><span class="s3">\n    </span><span class="s1">exprs.push(scope.buildUndefinedNode());</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (exprs.length === 1) {</span><span class="s3">\n    </span><span class="s1">return exprs[0];</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return sequenceExpression(exprs);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>