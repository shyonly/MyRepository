<html>
<head>
<title>shadow-utils.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
shadow-utils.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;iifeVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferencedIdentifier|BindingIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;getBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;needsOuterBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;stop&quot;</span><span class="s0">,</span><span class="s1">&quot;skip&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;collectShadowedParamsNames&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;functionScope&quot;</span><span class="s0">,</span><span class="s1">&quot;shadowedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;getBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;_functionScope$bindin&quot;</span><span class="s0">,</span><span class="s1">&quot;constantViolations&quot;</span><span class="s0">,</span><span class="s1">&quot;bindings&quot;</span><span class="s0">,</span><span class="s1">&quot;redeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isFor&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;buildScopeIIFE&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;returnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionExpression&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/shadow-utils.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath, Scope, Visitor } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">type State = {</span><span class="s3">\n  </span><span class="s1">needsOuterBinding: boolean;</span><span class="s3">\n  </span><span class="s1">scope: Scope;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export const iifeVisitor: Visitor&lt;State&gt; = {</span><span class="s3">\n  \&quot;</span><span class="s1">ReferencedIdentifier|BindingIdentifier</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;t.Identifier&gt;,</span><span class="s3">\n    </span><span class="s1">state,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const { scope, node } = path;</span><span class="s3">\n    </span><span class="s1">const { name } = node;</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">name === </span><span class="s3">\&quot;</span><span class="s1">eval</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">(scope.getBinding(name) === state.scope.parent.getBinding(name) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">state.scope.hasOwnBinding(name))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">state.needsOuterBinding = true;</span><span class="s3">\n      </span><span class="s1">path.stop();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// type annotations don't use or introduce </span><span class="s3">\&quot;</span><span class="s1">real</span><span class="s3">\&quot; </span><span class="s1">bindings</span><span class="s3">\n  \&quot;</span><span class="s1">TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">(path: NodePath) =&gt; path.skip(),</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function collectShadowedParamsNames(</span><span class="s3">\n  </span><span class="s1">param: NodePath&lt;t.Function[</span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">][number]&gt;,</span><span class="s3">\n  </span><span class="s1">functionScope: Scope,</span><span class="s3">\n  </span><span class="s1">shadowedParams: Set&lt;string&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">for (const name of Object.keys(param.getBindingIdentifiers())) {</span><span class="s3">\n    </span><span class="s1">const constantViolations = functionScope.bindings[name]?.constantViolations;</span><span class="s3">\n    </span><span class="s1">if (constantViolations) {</span><span class="s3">\n      </span><span class="s1">for (const redeclarator of constantViolations) {</span><span class="s3">\n        </span><span class="s1">const node = redeclarator.node;</span><span class="s3">\n        </span><span class="s1">// If a constant violation is a var or a function declaration,</span><span class="s3">\n        </span><span class="s1">// we first check to see if it's a var without an init.</span><span class="s3">\n        </span><span class="s1">// If so, we remove that declarator.</span><span class="s3">\n        </span><span class="s1">// Otherwise, we have to wrap it in an IIFE.</span><span class="s3">\n        </span><span class="s1">switch (node.type) {</span><span class="s3">\n          </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">VariableDeclarator</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">if (node.init === null) {</span><span class="s3">\n              </span><span class="s1">const declaration = redeclarator.parentPath;</span><span class="s3">\n              </span><span class="s1">// The following uninitialized var declarators should not be removed</span><span class="s3">\n              </span><span class="s1">// for (var x in {})</span><span class="s3">\n              </span><span class="s1">// for (var x;;)</span><span class="s3">\n              </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">!declaration.parentPath.isFor() ||</span><span class="s3">\n                </span><span class="s1">declaration.parentPath.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">) === declaration</span><span class="s3">\n              </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">redeclarator.remove();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">shadowedParams.add(name);</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">FunctionDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">shadowedParams.add(name);</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function buildScopeIIFE(</span><span class="s3">\n  </span><span class="s1">shadowedParams: Set&lt;string&gt;,</span><span class="s3">\n  </span><span class="s1">body: t.BlockStatement,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const args = [];</span><span class="s3">\n  </span><span class="s1">const params = [];</span><span class="s3">\n\n  </span><span class="s1">for (const name of shadowedParams) {</span><span class="s3">\n    </span><span class="s1">// We create them twice; the other option is to use t.cloneNode</span><span class="s3">\n    </span><span class="s1">args.push(t.identifier(name));</span><span class="s3">\n    </span><span class="s1">params.push(t.identifier(name));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return t.returnStatement(</span><span class="s3">\n    </span><span class="s1">t.callExpression(t.arrowFunctionExpression(params, body), args),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AAQO,MAAMC,WAA2B,GAAG;EACzC,wCAAwCC,CACtCC,IAA4B,EAC5BC,KAAK,EACL;IACA,MAAM;MAAEC,KAAK;MAAEC;IAAK,CAAC,GAAGH,IAAI;IAC5B,MAAM;MAAEI;IAAK,CAAC,GAAGD,IAAI;IAErB,IACEC,IAAI,KAAK,MAAM,IACdF,KAAK,CAACG,UAAU,CAACD,IAAI,CAAC,KAAKH,KAAK,CAACC,KAAK,CAACI,MAAM,CAACD,UAAU,CAACD,IAAI,CAAC,IAC7DH,KAAK,CAACC,KAAK,CAACK,aAAa,CAACH,IAAI,CAAE,EAClC;MACAH,KAAK,CAACO,iBAAiB,GAAG,IAAI;MAC9BR,IAAI,CAACS,IAAI,CAAC,CAAC;IACb;EACF,CAAC;EAED,qFAAqF,EAClFT,IAAc,IAAKA,IAAI,CAACU,IAAI,CAAC;AAClC,CAAC;AAACC,OAAA,CAAAb,WAAA,GAAAA,WAAA;AAEK,SAASc,0BAA0BA,CACxCC,KAA6C,EAC7CC,aAAoB,EACpBC,cAA2B,EAC3B;EACA,KAAK,MAAMX,IAAI,IAAIY,MAAM,CAACC,IAAI,CAACJ,KAAK,CAACK,qBAAqB,CAAC,CAAC,CAAC,EAAE;IAAA,IAAAC,qBAAA;IAC7D,MAAMC,kBAAkB,IAAAD,qBAAA,GAAGL,aAAa,CAACO,QAAQ,CAACjB,IAAI,CAAC,qBAA5Be,qBAAA,CAA8BC,kBAAkB;IAC3E,IAAIA,kBAAkB,EAAE;MACtB,KAAK,MAAME,YAAY,IAAIF,kBAAkB,EAAE;QAC7C,MAAMjB,IAAI,GAAGmB,YAAY,CAACnB,IAAI;QAK9B,QAAQA,IAAI,CAACoB,IAAI;UACf,KAAK,oBAAoB;YAAE;cACzB,IAAIpB,IAAI,CAACqB,IAAI,KAAK,IAAI,EAAE;gBACtB,MAAMC,WAAW,GAAGH,YAAY,CAACI,UAAU;gBAI3C,IACE,CAACD,WAAW,CAACC,UAAU,CAACC,KAAK,CAAC,CAAC,IAC/BF,WAAW,CAACC,UAAU,CAACE,GAAG,CAAC,MAAM,CAAC,KAAKH,WAAW,EAClD;kBACAH,YAAY,CAACO,MAAM,CAAC,CAAC;kBACrB;gBACF;cACF;cAEAd,cAAc,CAACe,GAAG,CAAC1B,IAAI,CAAC;cACxB;YACF;UACA,KAAK,qBAAqB;YACxBW,cAAc,CAACe,GAAG,CAAC1B,IAAI,CAAC;YACxB;QACJ;MACF;IACF;EACF;AACF;AAEO,SAAS2B,cAAcA,CAC5BhB,cAA2B,EAC3BiB,IAAsB,EACtB;EACA,MAAMC,IAAI,GAAG,EAAE;EACf,MAAMC,MAAM,GAAG,EAAE;EAEjB,KAAK,MAAM9B,IAAI,IAAIW,cAAc,EAAE;IAEjCkB,IAAI,CAACE,IAAI,CAACC,WAAC,CAACC,UAAU,CAACjC,IAAI,CAAC,CAAC;IAC7B8B,MAAM,CAACC,IAAI,CAACC,WAAC,CAACC,UAAU,CAACjC,IAAI,CAAC,CAAC;EACjC;EAEA,OAAOgC,WAAC,CAACE,eAAe,CACtBF,WAAC,CAACG,cAAc,CAACH,WAAC,CAACI,uBAAuB,CAACN,MAAM,EAAEF,IAAI,CAAC,EAAEC,IAAI,CAChE,CAAC;AACH&quot;</span><span class="s0">}</span></pre>
</body>
</html>