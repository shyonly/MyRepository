<html>
<head>
<title>transformClass.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
transformClass.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_helperFunctionName&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperReplaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperEnvironmentVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperOptimiseCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperAnnotateAsPure&quot;</span><span class="s0">,</span><span class="s1">&quot;_inlineCreateSuperHelpers&quot;</span><span class="s0">,</span><span class="s1">&quot;buildConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;classRef&quot;</span><span class="s0">,</span><span class="s1">&quot;constructorBody&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;func&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;functionDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;inherits&quot;</span><span class="s0">,</span><span class="s1">&quot;transformClass&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;builtinClasses&quot;</span><span class="s0">,</span><span class="s1">&quot;isLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;assumptions&quot;</span><span class="s0">,</span><span class="s1">&quot;supportUnicodeId&quot;</span><span class="s0">,</span><span class="s1">&quot;classState&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;classId&quot;</span><span class="s0">,</span><span class="s1">&quot;superFnId&quot;</span><span class="s0">,</span><span class="s1">&quot;superName&quot;</span><span class="s0">,</span><span class="s1">&quot;superReturns&quot;</span><span class="s0">,</span><span class="s1">&quot;isDerived&quot;</span><span class="s0">,</span><span class="s1">&quot;extendsNative&quot;</span><span class="s0">,</span><span class="s1">&quot;construct&quot;</span><span class="s0">,</span><span class="s1">&quot;userConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;userConstructorPath&quot;</span><span class="s0">,</span><span class="s1">&quot;hasConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;superThises&quot;</span><span class="s0">,</span><span class="s1">&quot;pushedConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;pushedInherits&quot;</span><span class="s0">,</span><span class="s1">&quot;pushedCreateClass&quot;</span><span class="s0">,</span><span class="s1">&quot;protoAlias&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;methods&quot;</span><span class="s0">,</span><span class="s1">&quot;instance&quot;</span><span class="s0">,</span><span class="s1">&quot;hasComputed&quot;</span><span class="s0">,</span><span class="s1">&quot;list&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;static&quot;</span><span class="s0">,</span><span class="s1">&quot;setState&quot;</span><span class="s0">,</span><span class="s1">&quot;newState&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;findThisesVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;visitors&quot;</span><span class="s0">,</span><span class="s1">&quot;merge&quot;</span><span class="s0">,</span><span class="s1">&quot;environmentVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;ThisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;createClassHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;addHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeCreateConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;classBodyPath&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;unshiftContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;classMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;buildBody&quot;</span><span class="s0">,</span><span class="s1">&quot;pushBody&quot;</span><span class="s0">,</span><span class="s1">&quot;verifyConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;pushDescriptors&quot;</span><span class="s0">,</span><span class="s1">&quot;classBodyPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;decorators&quot;</span><span class="s0">,</span><span class="s1">&quot;isConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;ReplaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;methodPath&quot;</span><span class="s0">,</span><span class="s1">&quot;objectRef&quot;</span><span class="s0">,</span><span class="s1">&quot;superRef&quot;</span><span class="s0">,</span><span class="s1">&quot;constantSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;refToPreserve&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;ReturnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;getFunctionParent&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;pushConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;pushMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;pushInheritsToBody&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;placement&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;desc&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;objectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;objectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;properties&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;nullLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;lastNonNullIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;isNullLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapSuperCall&quot;</span><span class="s0">,</span><span class="s1">&quot;bareSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;thisRef&quot;</span><span class="s0">,</span><span class="s1">&quot;bareSuperNode&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;superIsCallableConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isSpreadElement&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;argument&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;logicalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;optimiseCall&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;container&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;returnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDeclaredUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;thisPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;bareSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;Super&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;guaranteedSuperBeforeFinish&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;isLoop&quot;</span><span class="s0">,</span><span class="s1">&quot;isConditional&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapReturn&quot;</span><span class="s0">,</span><span class="s1">&quot;returnArg&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;returnParams&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;isReturnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;pushContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;returnPath&quot;</span><span class="s0">,</span><span class="s1">&quot;processMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;descKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isNumericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isBigIntLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;toComputedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;toExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isStringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;_nameFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;nameFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;descriptor&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;setClassMethods&quot;</span><span class="s0">,</span><span class="s1">&quot;insertProtoAliasOnce&quot;</span><span class="s0">,</span><span class="s1">&quot;methodName&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;isLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;functionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;generator&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;_nameFunction2&quot;</span><span class="s0">,</span><span class="s1">&quot;expr&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritsComments&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;classProto&quot;</span><span class="s0">,</span><span class="s1">&quot;protoDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;directives&quot;</span><span class="s0">,</span><span class="s1">&quot;pushConstructorToBody&quot;</span><span class="s0">,</span><span class="s1">&quot;hasInstanceDescriptors&quot;</span><span class="s0">,</span><span class="s1">&quot;hasStaticDescriptors&quot;</span><span class="s0">,</span><span class="s1">&quot;addCreateSuperHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;extractDynamicKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;elem&quot;</span><span class="s0">,</span><span class="s1">&quot;isPure&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifierBasedOnNode&quot;</span><span class="s0">,</span><span class="s1">&quot;setupClosureParamsArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;closureParams&quot;</span><span class="s0">,</span><span class="s1">&quot;closureArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;arg&quot;</span><span class="s0">,</span><span class="s1">&quot;annotateAsPure&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;classTransformer&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;hasBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;noClassCalls&quot;</span><span class="s0">,</span><span class="s1">&quot;isStrict&quot;</span><span class="s0">,</span><span class="s1">&quot;isInStrictMode&quot;</span><span class="s0">,</span><span class="s1">&quot;constructorOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;directive&quot;</span><span class="s0">,</span><span class="s1">&quot;directiveLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionExpression&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/transformClass.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { NodePath, Scope, Visitor } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import nameFunction from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-function-name</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import ReplaceSupers from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-replace-supers</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import environmentVisitor from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-environment-visitor</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import optimiseCall from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-optimise-call-expression</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { traverse, template, types as t, type File } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import annotateAsPure from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-annotate-as-pure</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import addCreateSuperHelper from </span><span class="s3">\&quot;</span><span class="s1">./inline-createSuper-helpers.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">type ClassAssumptions = {</span><span class="s3">\n  </span><span class="s1">setClassMethods: boolean;</span><span class="s3">\n  </span><span class="s1">constantSuper: boolean;</span><span class="s3">\n  </span><span class="s1">superIsCallableConstructor: boolean;</span><span class="s3">\n  </span><span class="s1">noClassCalls: boolean;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">type ClassConstructor = t.ClassMethod &amp; { kind: </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function buildConstructor(</span><span class="s3">\n  </span><span class="s1">classRef: t.Identifier,</span><span class="s3">\n  </span><span class="s1">constructorBody: t.BlockStatement,</span><span class="s3">\n  </span><span class="s1">node: t.Class,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const func = t.functionDeclaration(</span><span class="s3">\n    </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n    </span><span class="s1">[],</span><span class="s3">\n    </span><span class="s1">constructorBody,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">t.inherits(func, node);</span><span class="s3">\n  </span><span class="s1">return func;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type Descriptor = {</span><span class="s3">\n  </span><span class="s1">key: t.Expression;</span><span class="s3">\n  </span><span class="s1">get?: t.Expression | null;</span><span class="s3">\n  </span><span class="s1">set?: t.Expression | null;</span><span class="s3">\n  </span><span class="s1">value?: t.Expression | null;</span><span class="s3">\n  </span><span class="s1">constructor?: t.Expression | null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">type State = {</span><span class="s3">\n  </span><span class="s1">parent: t.Node;</span><span class="s3">\n  </span><span class="s1">scope: Scope;</span><span class="s3">\n  </span><span class="s1">node: t.Class;</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Class&gt;;</span><span class="s3">\n  </span><span class="s1">file: File;</span><span class="s3">\n\n  </span><span class="s1">classId: t.Identifier | void;</span><span class="s3">\n  </span><span class="s1">classRef: t.Identifier;</span><span class="s3">\n  </span><span class="s1">superFnId: t.Identifier;</span><span class="s3">\n  </span><span class="s1">superName: t.Expression | null;</span><span class="s3">\n  </span><span class="s1">superReturns: NodePath&lt;t.ReturnStatement&gt;[];</span><span class="s3">\n  </span><span class="s1">isDerived: boolean;</span><span class="s3">\n  </span><span class="s1">extendsNative: boolean;</span><span class="s3">\n\n  </span><span class="s1">construct: t.FunctionDeclaration;</span><span class="s3">\n  </span><span class="s1">constructorBody: t.BlockStatement;</span><span class="s3">\n  </span><span class="s1">userConstructor: ClassConstructor;</span><span class="s3">\n  </span><span class="s1">userConstructorPath: NodePath&lt;ClassConstructor&gt;;</span><span class="s3">\n  </span><span class="s1">hasConstructor: boolean;</span><span class="s3">\n\n  </span><span class="s1">body: t.Statement[];</span><span class="s3">\n  </span><span class="s1">superThises: NodePath&lt;t.ThisExpression&gt;[];</span><span class="s3">\n  </span><span class="s1">pushedConstructor: boolean;</span><span class="s3">\n  </span><span class="s1">pushedInherits: boolean;</span><span class="s3">\n  </span><span class="s1">pushedCreateClass: boolean;</span><span class="s3">\n  </span><span class="s1">protoAlias: t.Identifier | null;</span><span class="s3">\n  </span><span class="s1">isLoose: boolean;</span><span class="s3">\n\n  </span><span class="s1">dynamicKeys: Map&lt;string, t.Expression&gt;;</span><span class="s3">\n\n  </span><span class="s1">methods: {</span><span class="s3">\n    </span><span class="s1">// 'list' is in the same order as the elements appear in the class body.</span><span class="s3">\n    </span><span class="s1">// if there aren't computed keys, we can safely reorder class elements</span><span class="s3">\n    </span><span class="s1">// and use 'map' to merge duplicates.</span><span class="s3">\n    </span><span class="s1">instance: {</span><span class="s3">\n      </span><span class="s1">hasComputed: boolean;</span><span class="s3">\n      </span><span class="s1">list: Descriptor[];</span><span class="s3">\n      </span><span class="s1">map: Map&lt;string, Descriptor&gt;;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">static: {</span><span class="s3">\n      </span><span class="s1">hasComputed: boolean;</span><span class="s3">\n      </span><span class="s1">list: Descriptor[];</span><span class="s3">\n      </span><span class="s1">map: Map&lt;string, Descriptor&gt;;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">type PropertyInfo = {</span><span class="s3">\n  </span><span class="s1">instance: t.ObjectExpression[] | null;</span><span class="s3">\n  </span><span class="s1">static: t.ObjectExpression[] | null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default function transformClass(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Class&gt;,</span><span class="s3">\n  </span><span class="s1">file: File,</span><span class="s3">\n  </span><span class="s1">builtinClasses: ReadonlySet&lt;string&gt;,</span><span class="s3">\n  </span><span class="s1">isLoose: boolean,</span><span class="s3">\n  </span><span class="s1">assumptions: ClassAssumptions,</span><span class="s3">\n  </span><span class="s1">supportUnicodeId: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const classState: State = {</span><span class="s3">\n    </span><span class="s1">parent: undefined,</span><span class="s3">\n    </span><span class="s1">scope: undefined,</span><span class="s3">\n    </span><span class="s1">node: undefined,</span><span class="s3">\n    </span><span class="s1">path: undefined,</span><span class="s3">\n    </span><span class="s1">file: undefined,</span><span class="s3">\n\n    </span><span class="s1">classId: undefined,</span><span class="s3">\n    </span><span class="s1">classRef: undefined,</span><span class="s3">\n    </span><span class="s1">superFnId: undefined,</span><span class="s3">\n    </span><span class="s1">superName: null,</span><span class="s3">\n    </span><span class="s1">superReturns: [],</span><span class="s3">\n    </span><span class="s1">isDerived: false,</span><span class="s3">\n    </span><span class="s1">extendsNative: false,</span><span class="s3">\n\n    </span><span class="s1">construct: undefined,</span><span class="s3">\n    </span><span class="s1">constructorBody: undefined,</span><span class="s3">\n    </span><span class="s1">userConstructor: undefined,</span><span class="s3">\n    </span><span class="s1">userConstructorPath: undefined,</span><span class="s3">\n    </span><span class="s1">hasConstructor: false,</span><span class="s3">\n\n    </span><span class="s1">body: [],</span><span class="s3">\n    </span><span class="s1">superThises: [],</span><span class="s3">\n    </span><span class="s1">pushedConstructor: false,</span><span class="s3">\n    </span><span class="s1">pushedInherits: false,</span><span class="s3">\n    </span><span class="s1">pushedCreateClass: false,</span><span class="s3">\n    </span><span class="s1">protoAlias: null,</span><span class="s3">\n    </span><span class="s1">isLoose: false,</span><span class="s3">\n\n    </span><span class="s1">dynamicKeys: new Map(),</span><span class="s3">\n\n    </span><span class="s1">methods: {</span><span class="s3">\n      </span><span class="s1">instance: {</span><span class="s3">\n        </span><span class="s1">hasComputed: false,</span><span class="s3">\n        </span><span class="s1">list: [],</span><span class="s3">\n        </span><span class="s1">map: new Map(),</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">static: {</span><span class="s3">\n        </span><span class="s1">hasComputed: false,</span><span class="s3">\n        </span><span class="s1">list: [],</span><span class="s3">\n        </span><span class="s1">map: new Map(),</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">const setState = (newState: Partial&lt;State&gt;) =&gt; {</span><span class="s3">\n    </span><span class="s1">Object.assign(classState, newState);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">const findThisesVisitor = traverse.visitors.merge([</span><span class="s3">\n    </span><span class="s1">environmentVisitor,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">ThisExpression(path) {</span><span class="s3">\n        </span><span class="s1">classState.superThises.push(path);</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n\n  </span><span class="s1">function createClassHelper(args: t.Expression[]) {</span><span class="s3">\n    </span><span class="s1">return t.callExpression(classState.file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">createClass</span><span class="s3">\&quot;</span><span class="s1">), args);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a class constructor or bail out if there is one</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">function maybeCreateConstructor() {</span><span class="s3">\n    </span><span class="s1">const classBodyPath = classState.path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">for (const path of classBodyPath.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">if (path.isClassMethod({ kind: </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot; </span><span class="s1">})) return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let params: t.FunctionExpression[</span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">], body;</span><span class="s3">\n\n    </span><span class="s1">if (classState.isDerived) {</span><span class="s3">\n      </span><span class="s1">const constructor = template.expression.ast`</span><span class="s3">\n        </span><span class="s1">(function () {</span><span class="s3">\n          </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">` as t.FunctionExpression;</span><span class="s3">\n      </span><span class="s1">params = constructor.params;</span><span class="s3">\n      </span><span class="s1">body = constructor.body;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">params = [];</span><span class="s3">\n      </span><span class="s1">body = t.blockStatement([]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">classBodyPath.unshiftContainer(</span><span class="s3">\n      \&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">t.classMethod(</span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">, t.identifier(</span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">), params, body),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function buildBody() {</span><span class="s3">\n    </span><span class="s1">maybeCreateConstructor();</span><span class="s3">\n    </span><span class="s1">pushBody();</span><span class="s3">\n    </span><span class="s1">verifyConstructor();</span><span class="s3">\n\n    </span><span class="s1">if (classState.userConstructor) {</span><span class="s3">\n      </span><span class="s1">const { constructorBody, userConstructor, construct } = classState;</span><span class="s3">\n\n      </span><span class="s1">constructorBody.body.push(...userConstructor.body.body);</span><span class="s3">\n      </span><span class="s1">t.inherits(construct, userConstructor);</span><span class="s3">\n      </span><span class="s1">t.inherits(constructorBody, userConstructor.body);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">pushDescriptors();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function pushBody() {</span><span class="s3">\n    </span><span class="s1">const classBodyPaths: Array&lt;any&gt; = classState.path.get(</span><span class="s3">\&quot;</span><span class="s1">body.body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">for (const path of classBodyPaths) {</span><span class="s3">\n      </span><span class="s1">const node = path.node;</span><span class="s3">\n\n      </span><span class="s1">if (path.isClassProperty()) {</span><span class="s3">\n        </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\&quot;</span><span class="s1">Missing class properties transform.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (node.decorators) {</span><span class="s3">\n        </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n          \&quot;</span><span class="s1">Method has decorators, put the decorator plugin before the classes one.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (t.isClassMethod(node)) {</span><span class="s3">\n        </span><span class="s1">const isConstructor = node.kind === </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n        </span><span class="s1">const replaceSupers = new ReplaceSupers({</span><span class="s3">\n          </span><span class="s1">methodPath: path,</span><span class="s3">\n          </span><span class="s1">objectRef: classState.classRef,</span><span class="s3">\n          </span><span class="s1">superRef: classState.superName,</span><span class="s3">\n          </span><span class="s1">constantSuper: assumptions.constantSuper,</span><span class="s3">\n          </span><span class="s1">file: classState.file,</span><span class="s3">\n          </span><span class="s1">refToPreserve: classState.classRef,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n\n        </span><span class="s1">replaceSupers.replace();</span><span class="s3">\n\n        </span><span class="s1">const superReturns: NodePath&lt;t.ReturnStatement&gt;[] = [];</span><span class="s3">\n        </span><span class="s1">path.traverse(</span><span class="s3">\n          </span><span class="s1">traverse.visitors.merge([</span><span class="s3">\n            </span><span class="s1">environmentVisitor,</span><span class="s3">\n            </span><span class="s1">{</span><span class="s3">\n              </span><span class="s1">ReturnStatement(path) {</span><span class="s3">\n                </span><span class="s1">if (!path.getFunctionParent().isArrowFunctionExpression()) {</span><span class="s3">\n                  </span><span class="s1">superReturns.push(path);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">if (isConstructor) {</span><span class="s3">\n          </span><span class="s1">pushConstructor(superReturns, node as ClassConstructor, path);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">pushMethod(node, path);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function pushDescriptors() {</span><span class="s3">\n    </span><span class="s1">pushInheritsToBody();</span><span class="s3">\n\n    </span><span class="s1">const { body } = classState;</span><span class="s3">\n\n    </span><span class="s1">const props: PropertyInfo = {</span><span class="s3">\n      </span><span class="s1">instance: null,</span><span class="s3">\n      </span><span class="s1">static: null,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">for (const placement of [</span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">instance</span><span class="s3">\&quot;</span><span class="s1">] as const) {</span><span class="s3">\n      </span><span class="s1">if (classState.methods[placement].list.length) {</span><span class="s3">\n        </span><span class="s1">props[placement] = classState.methods[placement].list.map(desc =&gt; {</span><span class="s3">\n          </span><span class="s1">const obj = t.objectExpression([</span><span class="s3">\n            </span><span class="s1">t.objectProperty(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">), desc.key),</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n\n          </span><span class="s1">for (const kind of [</span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">] as const) {</span><span class="s3">\n            </span><span class="s1">if (desc[kind] != null) {</span><span class="s3">\n              </span><span class="s1">obj.properties.push(</span><span class="s3">\n                </span><span class="s1">t.objectProperty(t.identifier(kind), desc[kind]),</span><span class="s3">\n              </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">return obj;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (props.instance || props.static) {</span><span class="s3">\n      </span><span class="s1">let args = [</span><span class="s3">\n        </span><span class="s1">t.cloneNode(classState.classRef), // Constructor</span><span class="s3">\n        </span><span class="s1">props.instance ? t.arrayExpression(props.instance) : t.nullLiteral(), // instanceDescriptors</span><span class="s3">\n        </span><span class="s1">props.static ? t.arrayExpression(props.static) : t.nullLiteral(), // staticDescriptors</span><span class="s3">\n      </span><span class="s1">];</span><span class="s3">\n\n      </span><span class="s1">let lastNonNullIndex = 0;</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; args.length; i++) {</span><span class="s3">\n        </span><span class="s1">if (!t.isNullLiteral(args[i])) lastNonNullIndex = i;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">args = args.slice(0, lastNonNullIndex + 1);</span><span class="s3">\n\n      </span><span class="s1">body.push(t.expressionStatement(createClassHelper(args)));</span><span class="s3">\n      </span><span class="s1">classState.pushedCreateClass = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function wrapSuperCall(</span><span class="s3">\n    </span><span class="s1">bareSuper: NodePath&lt;t.CallExpression&gt;,</span><span class="s3">\n    </span><span class="s1">superRef: t.Expression,</span><span class="s3">\n    </span><span class="s1">thisRef: () =&gt; t.Identifier,</span><span class="s3">\n    </span><span class="s1">body: NodePath&lt;t.BlockStatement&gt;,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const bareSuperNode = bareSuper.node;</span><span class="s3">\n    </span><span class="s1">let call;</span><span class="s3">\n\n    </span><span class="s1">if (assumptions.superIsCallableConstructor) {</span><span class="s3">\n      </span><span class="s1">bareSuperNode.arguments.unshift(t.thisExpression());</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">bareSuperNode.arguments.length === 2 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">t.isSpreadElement(bareSuperNode.arguments[1]) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">t.isIdentifier(bareSuperNode.arguments[1].argument, {</span><span class="s3">\n          </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// special case single arguments spread</span><span class="s3">\n        </span><span class="s1">bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;</span><span class="s3">\n        </span><span class="s1">bareSuperNode.callee = t.memberExpression(</span><span class="s3">\n          </span><span class="s1">t.cloneNode(superRef),</span><span class="s3">\n          </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">apply</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">bareSuperNode.callee = t.memberExpression(</span><span class="s3">\n          </span><span class="s1">t.cloneNode(superRef),</span><span class="s3">\n          </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">call</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">call = t.logicalExpression(</span><span class="s3">\&quot;</span><span class="s1">||</span><span class="s3">\&quot;</span><span class="s1">, bareSuperNode, t.thisExpression());</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">call = optimiseCall(</span><span class="s3">\n        </span><span class="s1">t.cloneNode(classState.superFnId),</span><span class="s3">\n        </span><span class="s1">t.thisExpression(),</span><span class="s3">\n        </span><span class="s1">bareSuperNode.arguments,</span><span class="s3">\n        </span><span class="s1">false,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">bareSuper.parentPath.isExpressionStatement() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">bareSuper.parentPath.container === body.node.body &amp;&amp;</span><span class="s3">\n      </span><span class="s1">body.node.body.length - 1 === bareSuper.parentPath.key</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// this super call is the last statement in the body so we can just straight up</span><span class="s3">\n      </span><span class="s1">// turn it into a return</span><span class="s3">\n\n      </span><span class="s1">if (classState.superThises.length) {</span><span class="s3">\n        </span><span class="s1">call = t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, thisRef(), call);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">bareSuper.parentPath.replaceWith(t.returnStatement(call));</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">bareSuper.replaceWith(t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, thisRef(), call));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function verifyConstructor() {</span><span class="s3">\n    </span><span class="s1">if (!classState.isDerived) return;</span><span class="s3">\n\n    </span><span class="s1">const path = classState.userConstructorPath;</span><span class="s3">\n    </span><span class="s1">const body = path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">path.traverse(findThisesVisitor);</span><span class="s3">\n\n    </span><span class="s1">let thisRef = function () {</span><span class="s3">\n      </span><span class="s1">const ref = path.scope.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">thisRef = () =&gt; t.cloneNode(ref);</span><span class="s3">\n      </span><span class="s1">return ref;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">for (const thisPath of classState.superThises) {</span><span class="s3">\n      </span><span class="s1">const { node, parentPath } = thisPath;</span><span class="s3">\n      </span><span class="s1">if (parentPath.isMemberExpression({ object: node })) {</span><span class="s3">\n        </span><span class="s1">thisPath.replaceWith(thisRef());</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">thisPath.replaceWith(</span><span class="s3">\n        </span><span class="s1">t.callExpression(classState.file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">assertThisInitialized</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n          </span><span class="s1">thisRef(),</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const bareSupers: NodePath&lt;t.CallExpression&gt;[] = [];</span><span class="s3">\n    </span><span class="s1">path.traverse(</span><span class="s3">\n      </span><span class="s1">traverse.visitors.merge([</span><span class="s3">\n        </span><span class="s1">environmentVisitor,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">Super(path) {</span><span class="s3">\n            </span><span class="s1">const { node, parentPath } = path;</span><span class="s3">\n            </span><span class="s1">if (parentPath.isCallExpression({ callee: node })) {</span><span class="s3">\n              </span><span class="s1">bareSupers.unshift(parentPath);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">} as Visitor,</span><span class="s3">\n      </span><span class="s1">]),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">let guaranteedSuperBeforeFinish = !!bareSupers.length;</span><span class="s3">\n\n    </span><span class="s1">for (const bareSuper of bareSupers) {</span><span class="s3">\n      </span><span class="s1">wrapSuperCall(bareSuper, classState.superName, thisRef, body);</span><span class="s3">\n\n      </span><span class="s1">if (guaranteedSuperBeforeFinish) {</span><span class="s3">\n        </span><span class="s1">bareSuper.find(function (parentPath) {</span><span class="s3">\n          </span><span class="s1">// hit top so short circuit</span><span class="s3">\n          </span><span class="s1">if (parentPath === path) {</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">parentPath.isLoop() ||</span><span class="s3">\n            </span><span class="s1">parentPath.isConditional() ||</span><span class="s3">\n            </span><span class="s1">parentPath.isArrowFunctionExpression()</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">guaranteedSuperBeforeFinish = false;</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let wrapReturn;</span><span class="s3">\n\n    </span><span class="s1">if (classState.isLoose) {</span><span class="s3">\n      </span><span class="s1">wrapReturn = (returnArg: t.Expression | void) =&gt; {</span><span class="s3">\n        </span><span class="s1">const thisExpr = t.callExpression(</span><span class="s3">\n          </span><span class="s1">classState.file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">assertThisInitialized</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">[thisRef()],</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return returnArg</span><span class="s3">\n          </span><span class="s1">? t.logicalExpression(</span><span class="s3">\&quot;</span><span class="s1">||</span><span class="s3">\&quot;</span><span class="s1">, returnArg, thisExpr)</span><span class="s3">\n          </span><span class="s1">: thisExpr;</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">wrapReturn = (returnArg: t.Expression | undefined) =&gt; {</span><span class="s3">\n        </span><span class="s1">const returnParams: t.Expression[] = [thisRef()];</span><span class="s3">\n        </span><span class="s1">if (returnArg != null) {</span><span class="s3">\n          </span><span class="s1">returnParams.push(returnArg);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return t.callExpression(</span><span class="s3">\n          </span><span class="s1">classState.file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">possibleConstructorReturn</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">returnParams,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if we have a return as the last node in the body then we've already caught that</span><span class="s3">\n    </span><span class="s1">// return</span><span class="s3">\n    </span><span class="s1">const bodyPaths = body.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {</span><span class="s3">\n      </span><span class="s1">body.pushContainer(</span><span class="s3">\n        \&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">t.returnStatement(</span><span class="s3">\n          </span><span class="s1">guaranteedSuperBeforeFinish ? thisRef() : wrapReturn(),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const returnPath of classState.superReturns) {</span><span class="s3">\n      </span><span class="s1">returnPath</span><span class="s3">\n        </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replaceWith(wrapReturn(returnPath.node.argument));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Push a method to its respective mutatorMap.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">function pushMethod(node: t.ClassMethod, path?: NodePath) {</span><span class="s3">\n    </span><span class="s1">const scope = path ? path.scope : classState.scope;</span><span class="s3">\n\n    </span><span class="s1">if (node.kind === </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (processMethod(node, scope)) return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const placement = node.static ? </span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">instance</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">const methods = classState.methods[placement];</span><span class="s3">\n\n    </span><span class="s1">const descKey = node.kind === </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot; </span><span class="s1">: node.kind;</span><span class="s3">\n    </span><span class="s1">const key =</span><span class="s3">\n      </span><span class="s1">t.isNumericLiteral(node.key) || t.isBigIntLiteral(node.key)</span><span class="s3">\n        </span><span class="s1">? t.stringLiteral(String(node.key.value))</span><span class="s3">\n        </span><span class="s1">: t.toComputedKey(node);</span><span class="s3">\n\n    </span><span class="s1">let fn: t.Expression = t.toExpression(node);</span><span class="s3">\n\n    </span><span class="s1">if (t.isStringLiteral(key)) {</span><span class="s3">\n      </span><span class="s1">// infer function name</span><span class="s3">\n      </span><span class="s1">if (node.kind === </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error Fixme: we are passing a ClassMethod to nameFunction, but nameFunction</span><span class="s3">\n        </span><span class="s1">// does not seem to support it</span><span class="s3">\n        </span><span class="s1">fn =</span><span class="s3">\n          </span><span class="s1">nameFunction(</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error Fixme: we are passing a ClassMethod to nameFunction, but nameFunction</span><span class="s3">\n            </span><span class="s1">// does not seem to support it</span><span class="s3">\n            </span><span class="s1">{ id: key, node: node, scope },</span><span class="s3">\n            </span><span class="s1">undefined,</span><span class="s3">\n            </span><span class="s1">supportUnicodeId,</span><span class="s3">\n          </span><span class="s1">) ?? fn;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// todo(flow-&gt;ts) find a way to avoid </span><span class="s3">\&quot;</span><span class="s1">key as t.StringLiteral</span><span class="s3">\&quot; </span><span class="s1">below which relies on this assignment</span><span class="s3">\n      </span><span class="s1">methods.hasComputed = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let descriptor: Descriptor;</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!methods.hasComputed &amp;&amp;</span><span class="s3">\n      </span><span class="s1">methods.map.has((key as t.StringLiteral).value)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">descriptor = methods.map.get((key as t.StringLiteral).value);</span><span class="s3">\n      </span><span class="s1">descriptor[descKey] = fn;</span><span class="s3">\n\n      </span><span class="s1">if (descKey === </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">descriptor.get = null;</span><span class="s3">\n        </span><span class="s1">descriptor.set = null;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">descriptor.value = null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">descriptor = {</span><span class="s3">\n        </span><span class="s1">key:</span><span class="s3">\n          </span><span class="s1">// private name has been handled in class-properties transform</span><span class="s3">\n          </span><span class="s1">key as t.Expression,</span><span class="s3">\n        </span><span class="s1">[descKey]: fn,</span><span class="s3">\n      </span><span class="s1">} as Descriptor;</span><span class="s3">\n      </span><span class="s1">methods.list.push(descriptor);</span><span class="s3">\n\n      </span><span class="s1">if (!methods.hasComputed) {</span><span class="s3">\n        </span><span class="s1">methods.map.set((key as t.StringLiteral).value, descriptor);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function processMethod(node: t.ClassMethod, scope: Scope) {</span><span class="s3">\n    </span><span class="s1">if (assumptions.setClassMethods &amp;&amp; !node.decorators) {</span><span class="s3">\n      </span><span class="s1">// use assignments instead of define properties for loose classes</span><span class="s3">\n      </span><span class="s1">let { classRef } = classState;</span><span class="s3">\n      </span><span class="s1">if (!node.static) {</span><span class="s3">\n        </span><span class="s1">insertProtoAliasOnce();</span><span class="s3">\n        </span><span class="s1">classRef = classState.protoAlias;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const methodName = t.memberExpression(</span><span class="s3">\n        </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n        </span><span class="s1">node.key,</span><span class="s3">\n        </span><span class="s1">node.computed || t.isLiteral(node.key),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">let func: t.Expression = t.functionExpression(</span><span class="s3">\n        </span><span class="s1">null,</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error Fixme: should throw when we see TSParameterProperty</span><span class="s3">\n        </span><span class="s1">node.params,</span><span class="s3">\n        </span><span class="s1">node.body,</span><span class="s3">\n        </span><span class="s1">node.generator,</span><span class="s3">\n        </span><span class="s1">node.async,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">t.inherits(func, node);</span><span class="s3">\n\n      </span><span class="s1">const key = t.toComputedKey(node, node.key);</span><span class="s3">\n      </span><span class="s1">if (t.isStringLiteral(key)) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error: requires strictNullCheck</span><span class="s3">\n        </span><span class="s1">func =</span><span class="s3">\n          </span><span class="s1">nameFunction(</span><span class="s3">\n            </span><span class="s1">{</span><span class="s3">\n              </span><span class="s1">node: func,</span><span class="s3">\n              </span><span class="s1">id: key,</span><span class="s3">\n              </span><span class="s1">scope,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">undefined,</span><span class="s3">\n            </span><span class="s1">supportUnicodeId,</span><span class="s3">\n          </span><span class="s1">) ?? func;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const expr = t.expressionStatement(</span><span class="s3">\n        </span><span class="s1">t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, methodName, func),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">t.inheritsComments(expr, node);</span><span class="s3">\n      </span><span class="s1">classState.body.push(expr);</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function insertProtoAliasOnce() {</span><span class="s3">\n    </span><span class="s1">if (classState.protoAlias === null) {</span><span class="s3">\n      </span><span class="s1">setState({ protoAlias: classState.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">proto</span><span class="s3">\&quot;</span><span class="s1">) });</span><span class="s3">\n      </span><span class="s1">const classProto = t.memberExpression(</span><span class="s3">\n        </span><span class="s1">classState.classRef,</span><span class="s3">\n        </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">prototype</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const protoDeclaration = t.variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n        </span><span class="s1">t.variableDeclarator(classState.protoAlias, classProto),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n\n      </span><span class="s1">classState.body.push(protoDeclaration);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Replace the constructor body of our class.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">function pushConstructor(</span><span class="s3">\n    </span><span class="s1">superReturns: NodePath&lt;t.ReturnStatement&gt;[],</span><span class="s3">\n    </span><span class="s1">method: ClassConstructor,</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;ClassConstructor&gt;,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">setState({</span><span class="s3">\n      </span><span class="s1">userConstructorPath: path,</span><span class="s3">\n      </span><span class="s1">userConstructor: method,</span><span class="s3">\n      </span><span class="s1">hasConstructor: true,</span><span class="s3">\n      </span><span class="s1">superReturns,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">const { construct } = classState;</span><span class="s3">\n\n    </span><span class="s1">t.inheritsComments(construct, method);</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error Fixme: should throw when we see TSParameterProperty</span><span class="s3">\n    </span><span class="s1">construct.params = method.params;</span><span class="s3">\n\n    </span><span class="s1">t.inherits(construct.body, method.body);</span><span class="s3">\n    </span><span class="s1">construct.body.directives = method.body.directives;</span><span class="s3">\n\n    </span><span class="s1">pushConstructorToBody();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function pushConstructorToBody() {</span><span class="s3">\n    </span><span class="s1">if (classState.pushedConstructor) return;</span><span class="s3">\n    </span><span class="s1">classState.pushedConstructor = true;</span><span class="s3">\n\n    </span><span class="s1">// we haven't pushed any descriptors yet</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) maybe remove this block - properties from condition are not used anywhere else</span><span class="s3">\n    </span><span class="s1">if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {</span><span class="s3">\n      </span><span class="s1">pushDescriptors();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">classState.body.push(classState.construct);</span><span class="s3">\n\n    </span><span class="s1">pushInheritsToBody();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Push inherits helper to body.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">function pushInheritsToBody() {</span><span class="s3">\n    </span><span class="s1">if (!classState.isDerived || classState.pushedInherits) return;</span><span class="s3">\n\n    </span><span class="s1">const superFnId = path.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">super</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">setState({ pushedInherits: true, superFnId });</span><span class="s3">\n\n    </span><span class="s1">// Unshift to ensure that the constructor inheritance is set up before</span><span class="s3">\n    </span><span class="s1">// any properties can be assigned to the prototype.</span><span class="s3">\n\n    </span><span class="s1">if (!assumptions.superIsCallableConstructor) {</span><span class="s3">\n      </span><span class="s1">classState.body.unshift(</span><span class="s3">\n        </span><span class="s1">t.variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n          </span><span class="s1">t.variableDeclarator(</span><span class="s3">\n            </span><span class="s1">superFnId,</span><span class="s3">\n            </span><span class="s1">t.callExpression(addCreateSuperHelper(classState.file), [</span><span class="s3">\n              </span><span class="s1">t.cloneNode(classState.classRef),</span><span class="s3">\n            </span><span class="s1">]),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">classState.body.unshift(</span><span class="s3">\n      </span><span class="s1">t.expressionStatement(</span><span class="s3">\n        </span><span class="s1">t.callExpression(</span><span class="s3">\n          </span><span class="s1">classState.file.addHelper(</span><span class="s3">\n            </span><span class="s1">classState.isLoose ? </span><span class="s3">\&quot;</span><span class="s1">inheritsLoose</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">inherits</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">[t.cloneNode(classState.classRef), t.cloneNode(classState.superName)],</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function extractDynamicKeys() {</span><span class="s3">\n    </span><span class="s1">const { dynamicKeys, node, scope } = classState;</span><span class="s3">\n\n    </span><span class="s1">for (const elem of node.body.body) {</span><span class="s3">\n      </span><span class="s1">if (!t.isClassMethod(elem) || !elem.computed) continue;</span><span class="s3">\n      </span><span class="s1">if (scope.isPure(elem.key, /* constants only*/ true)) continue;</span><span class="s3">\n\n      </span><span class="s1">const id = scope.generateUidIdentifierBasedOnNode(elem.key);</span><span class="s3">\n      </span><span class="s1">dynamicKeys.set(id.name, elem.key);</span><span class="s3">\n\n      </span><span class="s1">elem.key = id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function setupClosureParamsArgs() {</span><span class="s3">\n    </span><span class="s1">const { superName, dynamicKeys } = classState;</span><span class="s3">\n    </span><span class="s1">const closureParams = [];</span><span class="s3">\n    </span><span class="s1">const closureArgs = [];</span><span class="s3">\n\n    </span><span class="s1">if (classState.isDerived) {</span><span class="s3">\n      </span><span class="s1">let arg = t.cloneNode(superName);</span><span class="s3">\n      </span><span class="s1">if (classState.extendsNative) {</span><span class="s3">\n        </span><span class="s1">arg = t.callExpression(classState.file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">wrapNativeSuper</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n          </span><span class="s1">arg,</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">annotateAsPure(arg);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const param =</span><span class="s3">\n        </span><span class="s1">classState.scope.generateUidIdentifierBasedOnNode(superName);</span><span class="s3">\n\n      </span><span class="s1">closureParams.push(param);</span><span class="s3">\n      </span><span class="s1">closureArgs.push(arg);</span><span class="s3">\n\n      </span><span class="s1">setState({ superName: t.cloneNode(param) });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const [name, value] of dynamicKeys) {</span><span class="s3">\n      </span><span class="s1">closureParams.push(t.identifier(name));</span><span class="s3">\n      </span><span class="s1">closureArgs.push(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return { closureParams, closureArgs };</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function classTransformer(</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;t.Class&gt;,</span><span class="s3">\n    </span><span class="s1">file: File,</span><span class="s3">\n    </span><span class="s1">builtinClasses: ReadonlySet&lt;string&gt;,</span><span class="s3">\n    </span><span class="s1">isLoose: boolean,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">setState({</span><span class="s3">\n      </span><span class="s1">parent: path.parent,</span><span class="s3">\n      </span><span class="s1">scope: path.scope,</span><span class="s3">\n      </span><span class="s1">node: path.node,</span><span class="s3">\n      </span><span class="s1">path,</span><span class="s3">\n      </span><span class="s1">file,</span><span class="s3">\n      </span><span class="s1">isLoose,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">setState({</span><span class="s3">\n      </span><span class="s1">classId: classState.node.id,</span><span class="s3">\n      </span><span class="s1">// this is the name of the binding that will **always** reference the class we've constructed</span><span class="s3">\n      </span><span class="s1">classRef: classState.node.id</span><span class="s3">\n        </span><span class="s1">? t.identifier(classState.node.id.name)</span><span class="s3">\n        </span><span class="s1">: classState.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">superName: classState.node.superClass,</span><span class="s3">\n      </span><span class="s1">isDerived: !!classState.node.superClass,</span><span class="s3">\n      </span><span class="s1">constructorBody: t.blockStatement([]),</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">setState({</span><span class="s3">\n      </span><span class="s1">extendsNative:</span><span class="s3">\n        </span><span class="s1">t.isIdentifier(classState.superName) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">builtinClasses.has(classState.superName.name) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!classState.scope.hasBinding(</span><span class="s3">\n          </span><span class="s1">classState.superName.name,</span><span class="s3">\n          </span><span class="s1">/* noGlobals */ true,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">const { classRef, node, constructorBody } = classState;</span><span class="s3">\n\n    </span><span class="s1">setState({</span><span class="s3">\n      </span><span class="s1">construct: buildConstructor(classRef, constructorBody, node),</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">extractDynamicKeys();</span><span class="s3">\n\n    </span><span class="s1">const { body } = classState;</span><span class="s3">\n    </span><span class="s1">const { closureParams, closureArgs } = setupClosureParamsArgs();</span><span class="s3">\n\n    </span><span class="s1">buildBody();</span><span class="s3">\n\n    </span><span class="s1">// make sure this class isn't directly called (with A() instead new A())</span><span class="s3">\n    </span><span class="s1">if (!assumptions.noClassCalls) {</span><span class="s3">\n      </span><span class="s1">constructorBody.body.unshift(</span><span class="s3">\n        </span><span class="s1">t.expressionStatement(</span><span class="s3">\n          </span><span class="s1">t.callExpression(classState.file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classCallCheck</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n            </span><span class="s1">t.thisExpression(),</span><span class="s3">\n            </span><span class="s1">t.cloneNode(classState.classRef),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const isStrict = path.isInStrictMode();</span><span class="s3">\n    </span><span class="s1">let constructorOnly = classState.classId &amp;&amp; body.length === 1;</span><span class="s3">\n    </span><span class="s1">if (constructorOnly &amp;&amp; !isStrict) {</span><span class="s3">\n      </span><span class="s1">for (const param of classState.construct.params) {</span><span class="s3">\n        </span><span class="s1">// It's illegal to put a use strict directive into the body of a function</span><span class="s3">\n        </span><span class="s1">// with non-simple parameters for some reason. So, we have to use a strict</span><span class="s3">\n        </span><span class="s1">// wrapper function.</span><span class="s3">\n        </span><span class="s1">if (!t.isIdentifier(param)) {</span><span class="s3">\n          </span><span class="s1">constructorOnly = false;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const directives = constructorOnly</span><span class="s3">\n      </span><span class="s1">? (body[0] as t.FunctionExpression | t.FunctionDeclaration).body</span><span class="s3">\n          </span><span class="s1">.directives</span><span class="s3">\n      </span><span class="s1">: [];</span><span class="s3">\n    </span><span class="s1">if (!isStrict) {</span><span class="s3">\n      </span><span class="s1">directives.push(t.directive(t.directiveLiteral(</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (constructorOnly) {</span><span class="s3">\n      </span><span class="s1">// named class with only a constructor</span><span class="s3">\n      </span><span class="s1">const expr = t.toExpression(</span><span class="s3">\n        </span><span class="s1">body[0] as t.FunctionExpression | t.FunctionDeclaration,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">return classState.isLoose ? expr : createClassHelper([expr]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let returnArg: t.Expression = t.cloneNode(classState.classRef);</span><span class="s3">\n    </span><span class="s1">if (!classState.pushedCreateClass &amp;&amp; !classState.isLoose) {</span><span class="s3">\n      </span><span class="s1">returnArg = createClassHelper([returnArg]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">body.push(t.returnStatement(returnArg));</span><span class="s3">\n    </span><span class="s1">const container = t.arrowFunctionExpression(</span><span class="s3">\n      </span><span class="s1">closureParams,</span><span class="s3">\n      </span><span class="s1">t.blockStatement(body, directives),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return t.callExpression(container, closureArgs);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return classTransformer(path, file, builtinClasses, isLoose);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>