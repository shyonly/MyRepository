<html>
<head>
<title>asn1.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #67a37c; font-style: italic;}
.s2 { color: #bcbec4;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #7a7e85;}
.s7 { color: #2aacb8;}
.s8 { color: #42c3d4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
asn1.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Javascript implementation of Abstract Syntax Notation Number One.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Dave Longley</span>
 <span class="s0">*</span>
 <span class="s0">* Copyright (c) 2010-2015 Digital Bazaar, Inc.</span>
 <span class="s0">*</span>
 <span class="s0">* An API for storing data using the Abstract Syntax Notation Number One</span>
 <span class="s0">* format using DER (Distinguished Encoding Rules) encoding. This encoding is</span>
 <span class="s0">* commonly used to store data for PKI, i.e. X.509 Certificates, and this</span>
 <span class="s0">* implementation exists for that purpose.</span>
 <span class="s0">*</span>
 <span class="s0">* Abstract Syntax Notation Number One (ASN.1) is used to define the abstract</span>
 <span class="s0">* syntax of information without restricting the way the information is encoded</span>
 <span class="s0">* for transmission. It provides a standard that allows for open systems</span>
 <span class="s0">* communication. ASN.1 defines the syntax of information data and a number of</span>
 <span class="s0">* simple data types as well as a notation for describing them and specifying</span>
 <span class="s0">* values for them.</span>
 <span class="s0">*</span>
 <span class="s0">* The RSA algorithm creates public and private keys that are often stored in</span>
 <span class="s0">* X.509 or PKCS#X formats -- which use ASN.1 (encoded in DER format). This</span>
 <span class="s0">* class provides the most basic functionality required to store and load DSA</span>
 <span class="s0">* keys that are encoded according to ASN.1.</span>
 <span class="s0">*</span>
 <span class="s0">* The most common binary encodings for ASN.1 are BER (Basic Encoding Rules)</span>
 <span class="s0">* and DER (Distinguished Encoding Rules). DER is just a subset of BER that</span>
 <span class="s0">* has stricter requirements for how data must be encoded.</span>
 <span class="s0">*</span>
 <span class="s0">* Each ASN.1 structure has a tag (a byte identifying the ASN.1 structure type)</span>
 <span class="s0">* and a byte array for the value of this ASN1 structure which may be data or a</span>
 <span class="s0">* list of ASN.1 structures.</span>
 <span class="s0">*</span>
 <span class="s0">* Each ASN.1 structure using BER is (Tag-Length-Value):</span>
 <span class="s0">*</span>
 <span class="s0">* | byte 0 | bytes X | bytes Y |</span>
 <span class="s0">* |--------|---------|----------</span>
 <span class="s0">* |  tag   | length  |  value  |</span>
 <span class="s0">*</span>
 <span class="s0">* ASN.1 allows for tags to be of &quot;High-tag-number form&quot; which allows a tag to</span>
 <span class="s0">* be two or more octets, but that is not supported by this class. A tag is</span>
 <span class="s0">* only 1 byte. Bits 1-5 give the tag number (ie the data type within a</span>
 <span class="s0">* particular 'class'), 6 indicates whether or not the ASN.1 value is</span>
 <span class="s0">* constructed from other ASN.1 values, and bits 7 and 8 give the 'class'. If</span>
 <span class="s0">* bits 7 and 8 are both zero, the class is UNIVERSAL. If only bit 7 is set,</span>
 <span class="s0">* then the class is APPLICATION. If only bit 8 is set, then the class is</span>
 <span class="s0">* CONTEXT_SPECIFIC. If both bits 7 and 8 are set, then the class is PRIVATE.</span>
 <span class="s0">* The tag numbers for the data types for the class UNIVERSAL are listed below:</span>
 <span class="s0">*</span>
 <span class="s0">* UNIVERSAL 0 Reserved for use by the encoding rules</span>
 <span class="s0">* UNIVERSAL 1 Boolean type</span>
 <span class="s0">* UNIVERSAL 2 Integer type</span>
 <span class="s0">* UNIVERSAL 3 Bitstring type</span>
 <span class="s0">* UNIVERSAL 4 Octetstring type</span>
 <span class="s0">* UNIVERSAL 5 Null type</span>
 <span class="s0">* UNIVERSAL 6 Object identifier type</span>
 <span class="s0">* UNIVERSAL 7 Object descriptor type</span>
 <span class="s0">* UNIVERSAL 8 External type and Instance-of type</span>
 <span class="s0">* UNIVERSAL 9 Real type</span>
 <span class="s0">* UNIVERSAL 10 Enumerated type</span>
 <span class="s0">* UNIVERSAL 11 Embedded-pdv type</span>
 <span class="s0">* UNIVERSAL 12 UTF8String type</span>
 <span class="s0">* UNIVERSAL 13 Relative object identifier type</span>
 <span class="s0">* UNIVERSAL 14-15 Reserved for future editions</span>
 <span class="s0">* UNIVERSAL 16 Sequence and Sequence-of types</span>
 <span class="s0">* UNIVERSAL 17 Set and Set-of types</span>
 <span class="s0">* UNIVERSAL 18-22, 25-30 Character string types</span>
 <span class="s0">* UNIVERSAL 23-24 Time types</span>
 <span class="s0">*</span>
 <span class="s0">* The length of an ASN.1 structure is specified after the tag identifier.</span>
 <span class="s0">* There is a definite form and an indefinite form. The indefinite form may</span>
 <span class="s0">* be used if the encoding is constructed and not all immediately available.</span>
 <span class="s0">* The indefinite form is encoded using a length byte with only the 8th bit</span>
 <span class="s0">* set. The end of the constructed object is marked using end-of-contents</span>
 <span class="s0">* octets (two zero bytes).</span>
 <span class="s0">*</span>
 <span class="s0">* The definite form looks like this:</span>
 <span class="s0">*</span>
 <span class="s0">* The length may take up 1 or more bytes, it depends on the length of the</span>
 <span class="s0">* value of the ASN.1 structure. DER encoding requires that if the ASN.1</span>
 <span class="s0">* structure has a value that has a length greater than 127, more than 1 byte</span>
 <span class="s0">* will be used to store its length, otherwise just one byte will be used.</span>
 <span class="s0">* This is strict.</span>
 <span class="s0">*</span>
 <span class="s0">* In the case that the length of the ASN.1 value is less than 127, 1 octet</span>
 <span class="s0">* (byte) is used to store the &quot;short form&quot; length. The 8th bit has a value of</span>
 <span class="s0">* 0 indicating the length is &quot;short form&quot; and not &quot;long form&quot; and bits 7-1</span>
 <span class="s0">* give the length of the data. (The 8th bit is the left-most, most significant</span>
 <span class="s0">* bit: also known as big endian or network format).</span>
 <span class="s0">*</span>
 <span class="s0">* In the case that the length of the ASN.1 value is greater than 127, 2 to</span>
 <span class="s0">* 127 octets (bytes) are used to store the &quot;long form&quot; length. The first</span>
 <span class="s0">* byte's 8th bit is set to 1 to indicate the length is &quot;long form.&quot; Bits 7-1</span>
 <span class="s0">* give the number of additional octets. All following octets are in base 256</span>
 <span class="s0">* with the most significant digit first (typical big-endian binary unsigned</span>
 <span class="s0">* integer storage). So, for instance, if the length of a value was 257, the</span>
 <span class="s0">* first byte would be set to:</span>
 <span class="s0">*</span>
 <span class="s0">* 10000010 = 130 = 0x82.</span>
 <span class="s0">*</span>
 <span class="s0">* This indicates there are 2 octets (base 256) for the length. The second and</span>
 <span class="s0">* third bytes (the octets just mentioned) would store the length in base 256:</span>
 <span class="s0">*</span>
 <span class="s0">* octet 2: 00000001 = 1 * 256^1 = 256</span>
 <span class="s0">* octet 3: 00000001 = 1 * 256^0 = 1</span>
 <span class="s0">* total = 257</span>
 <span class="s0">*</span>
 <span class="s0">* The algorithm for converting a js integer value of 257 to base-256 is:</span>
 <span class="s0">*</span>
 <span class="s0">* var value = 257;</span>
 <span class="s0">* var bytes = [];</span>
 <span class="s0">* bytes[0] = (value &gt;&gt;&gt; 8) &amp; 0xFF; // most significant byte first</span>
 <span class="s0">* bytes[1] = value &amp; 0xFF;        // least significant byte last</span>
 <span class="s0">*</span>
 <span class="s0">* On the ASN.1 UNIVERSAL Object Identifier (OID) type:</span>
 <span class="s0">*</span>
 <span class="s0">* An OID can be written like: &quot;value1.value2.value3...valueN&quot;</span>
 <span class="s0">*</span>
 <span class="s0">* The DER encoding rules:</span>
 <span class="s0">*</span>
 <span class="s0">* The first byte has the value 40 * value1 + value2.</span>
 <span class="s0">* The following bytes, if any, encode the remaining values. Each value is</span>
 <span class="s0">* encoded in base 128, most significant digit first (big endian), with as</span>
 <span class="s0">* few digits as possible, and the most significant bit of each byte set</span>
 <span class="s0">* to 1 except the last in each value's encoding. For example: Given the</span>
 <span class="s0">* OID &quot;1.2.840.113549&quot;, its DER encoding is (remember each byte except the</span>
 <span class="s0">* last one in each encoding is OR'd with 0x80):</span>
 <span class="s0">*</span>
 <span class="s0">* byte 1: 40 * 1 + 2 = 42 = 0x2A.</span>
 <span class="s0">* bytes 2-3: 128 * 6 + 72 = 840 = 6 72 = 6 72 = 0x0648 = 0x8648</span>
 <span class="s0">* bytes 4-6: 16384 * 6 + 128 * 119 + 13 = 6 119 13 = 0x06770D = 0x86F70D</span>
 <span class="s0">*</span>
 <span class="s0">* The final value is: 0x2A864886F70D.</span>
 <span class="s0">* The full OID (including ASN.1 tag and length of 6 bytes) is:</span>
 <span class="s0">* 0x06062A864886F70D</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">forge </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s5">'./forge'</span><span class="s4">);</span>
<span class="s2">require</span><span class="s4">(</span><span class="s5">'./util'</span><span class="s4">);</span>
<span class="s2">require</span><span class="s4">(</span><span class="s5">'./oids'</span><span class="s4">);</span>

<span class="s6">/* ASN.1 API */</span>
<span class="s3">var </span><span class="s2">asn1 </span><span class="s4">= </span><span class="s2">module</span><span class="s4">.</span><span class="s2">exports </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">asn1 </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">asn1 </span><span class="s4">|| {};</span>

<span class="s0">/**</span>
 <span class="s0">* ASN.1 classes.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class </span><span class="s4">= {</span>
  <span class="s2">UNIVERSAL</span><span class="s4">:        </span><span class="s7">0x00</span><span class="s4">,</span>
  <span class="s2">APPLICATION</span><span class="s4">:      </span><span class="s7">0x40</span><span class="s4">,</span>
  <span class="s2">CONTEXT_SPECIFIC</span><span class="s4">: </span><span class="s7">0x80</span><span class="s4">,</span>
  <span class="s2">PRIVATE</span><span class="s4">:          </span><span class="s7">0xC0</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* ASN.1 types. Not all types are supported by this implementation, only</span>
 <span class="s0">* those necessary to implement a simple PKI are implemented.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type </span><span class="s4">= {</span>
  <span class="s2">NONE</span><span class="s4">:             </span><span class="s7">0</span><span class="s4">,</span>
  <span class="s2">BOOLEAN</span><span class="s4">:          </span><span class="s7">1</span><span class="s4">,</span>
  <span class="s2">INTEGER</span><span class="s4">:          </span><span class="s7">2</span><span class="s4">,</span>
  <span class="s2">BITSTRING</span><span class="s4">:        </span><span class="s7">3</span><span class="s4">,</span>
  <span class="s2">OCTETSTRING</span><span class="s4">:      </span><span class="s7">4</span><span class="s4">,</span>
  <span class="s2">NULL</span><span class="s4">:             </span><span class="s7">5</span><span class="s4">,</span>
  <span class="s2">OID</span><span class="s4">:              </span><span class="s7">6</span><span class="s4">,</span>
  <span class="s2">ODESC</span><span class="s4">:            </span><span class="s7">7</span><span class="s4">,</span>
  <span class="s2">EXTERNAL</span><span class="s4">:         </span><span class="s7">8</span><span class="s4">,</span>
  <span class="s2">REAL</span><span class="s4">:             </span><span class="s7">9</span><span class="s4">,</span>
  <span class="s2">ENUMERATED</span><span class="s4">:      </span><span class="s7">10</span><span class="s4">,</span>
  <span class="s2">EMBEDDED</span><span class="s4">:        </span><span class="s7">11</span><span class="s4">,</span>
  <span class="s2">UTF8</span><span class="s4">:            </span><span class="s7">12</span><span class="s4">,</span>
  <span class="s2">ROID</span><span class="s4">:            </span><span class="s7">13</span><span class="s4">,</span>
  <span class="s2">SEQUENCE</span><span class="s4">:        </span><span class="s7">16</span><span class="s4">,</span>
  <span class="s2">SET</span><span class="s4">:             </span><span class="s7">17</span><span class="s4">,</span>
  <span class="s2">PRINTABLESTRING</span><span class="s4">: </span><span class="s7">19</span><span class="s4">,</span>
  <span class="s2">IA5STRING</span><span class="s4">:       </span><span class="s7">22</span><span class="s4">,</span>
  <span class="s2">UTCTIME</span><span class="s4">:         </span><span class="s7">23</span><span class="s4">,</span>
  <span class="s2">GENERALIZEDTIME</span><span class="s4">: </span><span class="s7">24</span><span class="s4">,</span>
  <span class="s2">BMPSTRING</span><span class="s4">:       </span><span class="s7">30</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a new asn1 object.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">tagClass the tag class for the object.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">type the data type (tag number) for the object.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">constructed true if the asn1 object is in constructed form.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">value the value for the object, if it is not constructed.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">[options] the options to use:</span>
 <span class="s0">*          [bitStringContents] the plain BIT STRING content including padding</span>
 <span class="s0">*            byte.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the asn1 object.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">create </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">tagClass</span><span class="s4">, </span><span class="s2">type</span><span class="s4">, </span><span class="s2">constructed</span><span class="s4">, </span><span class="s2">value</span><span class="s4">, </span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s6">/* An asn1 object has a tagClass, a type, a constructed flag, and a 
    value. The value's type depends on the constructed flag. If 
    constructed, it will contain a list of other asn1 objects. If not, 
    it will contain the ASN.1 value as an array of bytes formatted 
    according to the ASN.1 data type. */</span>

  <span class="s6">// remove undefined values</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">value</span><span class="s4">)) {</span>
    <span class="s3">var </span><span class="s2">tmp </span><span class="s4">= [];</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">value</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">value</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] !== </span><span class="s2">undefined</span><span class="s4">) {</span>
        <span class="s2">tmp</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">value</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
    <span class="s2">value </span><span class="s4">= </span><span class="s2">tmp</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s3">var </span><span class="s2">obj </span><span class="s4">= {</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">tagClass</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">type</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s2">constructed</span><span class="s4">,</span>
    <span class="s2">composed</span><span class="s4">: </span><span class="s2">constructed </span><span class="s4">|| </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">value</span><span class="s4">),</span>
    <span class="s2">value</span><span class="s4">: </span><span class="s2">value</span>
  <span class="s4">};</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">options </span><span class="s4">&amp;&amp; </span><span class="s5">'bitStringContents' </span><span class="s3">in </span><span class="s2">options</span><span class="s4">) {</span>
    <span class="s6">// TODO: copy byte buffer if it's a buffer not a string</span>
    <span class="s2">obj</span><span class="s4">.</span><span class="s2">bitStringContents </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">bitStringContents</span><span class="s4">;</span>
    <span class="s6">// TODO: add readonly flag to avoid this overhead</span>
    <span class="s6">// save copy to detect changes</span>
    <span class="s2">obj</span><span class="s4">.</span><span class="s2">original </span><span class="s4">= </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">copy</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s3">return </span><span class="s2">obj</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Copies an asn1 object.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">obj the asn1 object.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">[options] copy options:</span>
 <span class="s0">*          [excludeBitStringContents] true to not copy bitStringContents</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the a copy of the asn1 object.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">copy </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">, </span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">copy</span><span class="s4">;</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">)) {</span>
    <span class="s2">copy </span><span class="s4">= [];</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s2">copy</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">copy</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">[</span><span class="s2">i</span><span class="s4">], </span><span class="s2">options</span><span class="s4">));</span>
    <span class="s4">}</span>
    <span class="s3">return </span><span class="s2">copy</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">obj </span><span class="s4">=== </span><span class="s5">'string'</span><span class="s4">) {</span>
    <span class="s6">// TODO: copy byte buffer if it's a buffer not a string</span>
    <span class="s3">return </span><span class="s2">obj</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s2">copy </span><span class="s4">= {</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">tagClass</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">type</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">constructed</span><span class="s4">,</span>
    <span class="s2">composed</span><span class="s4">: </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">composed</span><span class="s4">,</span>
    <span class="s2">value</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">copy</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">, </span><span class="s2">options</span><span class="s4">)</span>
  <span class="s4">};</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">options </span><span class="s4">&amp;&amp; !</span><span class="s2">options</span><span class="s4">.</span><span class="s2">excludeBitStringContents</span><span class="s4">) {</span>
    <span class="s6">// TODO: copy byte buffer if it's a buffer not a string</span>
    <span class="s2">copy</span><span class="s4">.</span><span class="s2">bitStringContents </span><span class="s4">= </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">bitStringContents</span><span class="s4">;</span>
  <span class="s4">}</span>
  <span class="s3">return </span><span class="s2">copy</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Compares asn1 objects for equality.</span>
 <span class="s0">*</span>
 <span class="s0">* Note this function does not run in constant time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">obj1 the first asn1 object.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">obj2 the second asn1 object.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">[options] compare options:</span>
 <span class="s0">*          [includeBitStringContents] true to compare bitStringContents</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">true if the asn1 objects are equal.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">equals </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">obj1</span><span class="s4">, </span><span class="s2">obj2</span><span class="s4">, </span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">obj1</span><span class="s4">)) {</span>
    <span class="s3">if</span><span class="s4">(!</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">obj2</span><span class="s4">)) {</span>
      <span class="s3">return false</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">obj1</span><span class="s4">.</span><span class="s2">length </span><span class="s4">!== </span><span class="s2">obj2</span><span class="s4">.</span><span class="s2">length</span><span class="s4">) {</span>
      <span class="s3">return false</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">obj1</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s3">if</span><span class="s4">(!</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">equals</span><span class="s4">(</span><span class="s2">obj1</span><span class="s4">[</span><span class="s2">i</span><span class="s4">], </span><span class="s2">obj2</span><span class="s4">[</span><span class="s2">i</span><span class="s4">])) {</span>
        <span class="s3">return false</span><span class="s4">;</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
    <span class="s3">return true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">obj1 </span><span class="s4">!== </span><span class="s3">typeof </span><span class="s2">obj2</span><span class="s4">) {</span>
    <span class="s3">return false</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">obj1 </span><span class="s4">=== </span><span class="s5">'string'</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">obj1 </span><span class="s4">=== </span><span class="s2">obj2</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s3">var </span><span class="s2">equal </span><span class="s4">= </span><span class="s2">obj1</span><span class="s4">.</span><span class="s2">tagClass </span><span class="s4">=== </span><span class="s2">obj2</span><span class="s4">.</span><span class="s2">tagClass </span><span class="s4">&amp;&amp;</span>
    <span class="s2">obj1</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s2">obj2</span><span class="s4">.</span><span class="s2">type </span><span class="s4">&amp;&amp;</span>
    <span class="s2">obj1</span><span class="s4">.</span><span class="s2">constructed </span><span class="s4">=== </span><span class="s2">obj2</span><span class="s4">.</span><span class="s2">constructed </span><span class="s4">&amp;&amp;</span>
    <span class="s2">obj1</span><span class="s4">.</span><span class="s2">composed </span><span class="s4">=== </span><span class="s2">obj2</span><span class="s4">.</span><span class="s2">composed </span><span class="s4">&amp;&amp;</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">equals</span><span class="s4">(</span><span class="s2">obj1</span><span class="s4">.</span><span class="s2">value</span><span class="s4">, </span><span class="s2">obj2</span><span class="s4">.</span><span class="s2">value</span><span class="s4">);</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">options </span><span class="s4">&amp;&amp; </span><span class="s2">options</span><span class="s4">.</span><span class="s2">includeBitStringContents</span><span class="s4">) {</span>
    <span class="s2">equal </span><span class="s4">= </span><span class="s2">equal </span><span class="s4">&amp;&amp; (</span><span class="s2">obj1</span><span class="s4">.</span><span class="s2">bitStringContents </span><span class="s4">=== </span><span class="s2">obj2</span><span class="s4">.</span><span class="s2">bitStringContents</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s3">return </span><span class="s2">equal</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Gets the length of a BER-encoded ASN.1 value.</span>
 <span class="s0">*</span>
 <span class="s0">* In case the length is not specified, undefined is returned.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">b the BER-encoded ASN.1 byte buffer, starting with the first</span>
 <span class="s0">*          length byte.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the length of the BER-encoded ASN.1 value or undefined.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">getBerValueLength </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">b</span><span class="s4">) {</span>
  <span class="s6">// TODO: move this function and related DER/BER functions to a der.js</span>
  <span class="s6">// file; better abstract ASN.1 away from der/ber.</span>
  <span class="s3">var </span><span class="s2">b2 </span><span class="s4">= </span><span class="s2">b</span><span class="s4">.</span><span class="s2">getByte</span><span class="s4">();</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">b2 </span><span class="s4">=== </span><span class="s7">0x80</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">undefined</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// see if the length is &quot;short form&quot; or &quot;long form&quot; (bit 8 set)</span>
  <span class="s3">var </span><span class="s2">length</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">longForm </span><span class="s4">= </span><span class="s2">b2 </span><span class="s4">&amp; </span><span class="s7">0x80</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(!</span><span class="s2">longForm</span><span class="s4">) {</span>
    <span class="s6">// length is just the first byte</span>
    <span class="s2">length </span><span class="s4">= </span><span class="s2">b2</span><span class="s4">;</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s6">// the number of bytes the length is specified in bits 7 through 1</span>
    <span class="s6">// and each length byte is in big-endian base-256</span>
    <span class="s2">length </span><span class="s4">= </span><span class="s2">b</span><span class="s4">.</span><span class="s2">getInt</span><span class="s4">((</span><span class="s2">b2 </span><span class="s4">&amp; </span><span class="s7">0x7F</span><span class="s4">) &lt;&lt; </span><span class="s7">3</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s3">return </span><span class="s2">length</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Check if the byte buffer has enough bytes. Throws an Error if not.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">bytes the byte buffer to parse from.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">remaining the bytes remaining in the current parsing state.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">n the number of bytes the buffer must have.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">_checkBufferLength</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">, </span><span class="s2">remaining</span><span class="s4">, </span><span class="s2">n</span><span class="s4">) {</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">n </span><span class="s4">&gt; </span><span class="s2">remaining</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">error </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Too few bytes to parse DER.'</span><span class="s4">);</span>
    <span class="s2">error</span><span class="s4">.</span><span class="s2">available </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
    <span class="s2">error</span><span class="s4">.</span><span class="s2">remaining </span><span class="s4">= </span><span class="s2">remaining</span><span class="s4">;</span>
    <span class="s2">error</span><span class="s4">.</span><span class="s2">requested </span><span class="s4">= </span><span class="s2">n</span><span class="s4">;</span>
    <span class="s3">throw </span><span class="s2">error</span><span class="s4">;</span>
  <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Gets the length of a BER-encoded ASN.1 value.</span>
 <span class="s0">*</span>
 <span class="s0">* In case the length is not specified, undefined is returned.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">bytes the byte buffer to parse from.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">remaining the bytes remaining in the current parsing state.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the length of the BER-encoded ASN.1 value or undefined.</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">_getValueLength </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">, </span><span class="s2">remaining</span><span class="s4">) {</span>
  <span class="s6">// TODO: move this function and related DER/BER functions to a der.js</span>
  <span class="s6">// file; better abstract ASN.1 away from der/ber.</span>
  <span class="s6">// fromDer already checked that this byte exists</span>
  <span class="s3">var </span><span class="s2">b2 </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">getByte</span><span class="s4">();</span>
  <span class="s2">remaining</span><span class="s4">--;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">b2 </span><span class="s4">=== </span><span class="s7">0x80</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">undefined</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// see if the length is &quot;short form&quot; or &quot;long form&quot; (bit 8 set)</span>
  <span class="s3">var </span><span class="s2">length</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">longForm </span><span class="s4">= </span><span class="s2">b2 </span><span class="s4">&amp; </span><span class="s7">0x80</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(!</span><span class="s2">longForm</span><span class="s4">) {</span>
    <span class="s6">// length is just the first byte</span>
    <span class="s2">length </span><span class="s4">= </span><span class="s2">b2</span><span class="s4">;</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s6">// the number of bytes the length is specified in bits 7 through 1</span>
    <span class="s6">// and each length byte is in big-endian base-256</span>
    <span class="s3">var </span><span class="s2">longFormBytes </span><span class="s4">= </span><span class="s2">b2 </span><span class="s4">&amp; </span><span class="s7">0x7F</span><span class="s4">;</span>
    <span class="s2">_checkBufferLength</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">, </span><span class="s2">remaining</span><span class="s4">, </span><span class="s2">longFormBytes</span><span class="s4">);</span>
    <span class="s2">length </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">getInt</span><span class="s4">(</span><span class="s2">longFormBytes </span><span class="s4">&lt;&lt; </span><span class="s7">3</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s6">// FIXME: this will only happen for 32 bit getInt with high bit set</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">length </span><span class="s4">&lt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Negative length: ' </span><span class="s4">+ </span><span class="s2">length</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s3">return </span><span class="s2">length</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Parses an asn1 object from a byte buffer in DER format.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">bytes the byte buffer to parse from.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">[strict] true to be strict when checking value lengths, false to</span>
 <span class="s0">*          allow truncated values (default: true).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">[options] object with options or boolean strict flag</span>
 <span class="s0">*          [strict] true to be strict when checking value lengths, false to</span>
 <span class="s0">*            allow truncated values (default: true).</span>
 <span class="s0">*          [parseAllBytes] true to ensure all bytes are parsed</span>
 <span class="s0">*            (default: true)</span>
 <span class="s0">*          [decodeBitStrings] true to attempt to decode the content of</span>
 <span class="s0">*            BIT STRINGs (not OCTET STRINGs) using strict mode. Note that</span>
 <span class="s0">*            without schema support to understand the data context this can</span>
 <span class="s0">*            erroneously decode values that happen to be valid ASN.1. This</span>
 <span class="s0">*            flag will be deprecated or removed as soon as schema support is</span>
 <span class="s0">*            available. (default: true)</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">Will throw an error for various malformed input conditions.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the parsed asn1 object.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">fromDer </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">, </span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">options </span><span class="s4">=== </span><span class="s2">undefined</span><span class="s4">) {</span>
    <span class="s2">options </span><span class="s4">= {</span>
      <span class="s2">strict</span><span class="s4">: </span><span class="s3">true</span><span class="s4">,</span>
      <span class="s2">parseAllBytes</span><span class="s4">: </span><span class="s3">true</span><span class="s4">,</span>
      <span class="s2">decodeBitStrings</span><span class="s4">: </span><span class="s3">true</span>
    <span class="s4">};</span>
  <span class="s4">}</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">options </span><span class="s4">=== </span><span class="s5">'boolean'</span><span class="s4">) {</span>
    <span class="s2">options </span><span class="s4">= {</span>
      <span class="s2">strict</span><span class="s4">: </span><span class="s2">options</span><span class="s4">,</span>
      <span class="s2">parseAllBytes</span><span class="s4">: </span><span class="s3">true</span><span class="s4">,</span>
      <span class="s2">decodeBitStrings</span><span class="s4">: </span><span class="s3">true</span>
    <span class="s4">};</span>
  <span class="s4">}</span>
  <span class="s3">if</span><span class="s4">(!(</span><span class="s5">'strict' </span><span class="s3">in </span><span class="s2">options</span><span class="s4">)) {</span>
    <span class="s2">options</span><span class="s4">.</span><span class="s2">strict </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
  <span class="s4">}</span>
  <span class="s3">if</span><span class="s4">(!(</span><span class="s5">'parseAllBytes' </span><span class="s3">in </span><span class="s2">options</span><span class="s4">)) {</span>
    <span class="s2">options</span><span class="s4">.</span><span class="s2">parseAllBytes </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
  <span class="s4">}</span>
  <span class="s3">if</span><span class="s4">(!(</span><span class="s5">'decodeBitStrings' </span><span class="s3">in </span><span class="s2">options</span><span class="s4">)) {</span>
    <span class="s2">options</span><span class="s4">.</span><span class="s2">decodeBitStrings </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// wrap in buffer if needed</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">bytes </span><span class="s4">=== </span><span class="s5">'string'</span><span class="s4">) {</span>
    <span class="s2">bytes </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s3">var </span><span class="s2">byteCount </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
  <span class="s3">var </span><span class="s2">value </span><span class="s4">= </span><span class="s2">_fromDer</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">, </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">(), </span><span class="s7">0</span><span class="s4">, </span><span class="s2">options</span><span class="s4">);</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">parseAllBytes </span><span class="s4">&amp;&amp; </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() !== </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">error </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Unparsed DER bytes remain after ASN.1 parsing.'</span><span class="s4">);</span>
    <span class="s2">error</span><span class="s4">.</span><span class="s2">byteCount </span><span class="s4">= </span><span class="s2">byteCount</span><span class="s4">;</span>
    <span class="s2">error</span><span class="s4">.</span><span class="s2">remaining </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
    <span class="s3">throw </span><span class="s2">error</span><span class="s4">;</span>
  <span class="s4">}</span>
  <span class="s3">return </span><span class="s2">value</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Internal function to parse an asn1 object from a byte buffer in DER format.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">bytes the byte buffer to parse from.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">remaining the number of bytes remaining for this chunk.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">depth the current parsing depth.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">options object with same options as fromDer().</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the parsed asn1 object.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">_fromDer</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">, </span><span class="s2">remaining</span><span class="s4">, </span><span class="s2">depth</span><span class="s4">, </span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s6">// temporary storage for consumption calculations</span>
  <span class="s3">var </span><span class="s2">start</span><span class="s4">;</span>

  <span class="s6">// minimum length for ASN.1 DER structure is 2</span>
  <span class="s2">_checkBufferLength</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">, </span><span class="s2">remaining</span><span class="s4">, </span><span class="s7">2</span><span class="s4">);</span>

  <span class="s6">// get the first byte</span>
  <span class="s3">var </span><span class="s2">b1 </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">getByte</span><span class="s4">();</span>
  <span class="s6">// consumed one byte</span>
  <span class="s2">remaining</span><span class="s4">--;</span>

  <span class="s6">// get the tag class</span>
  <span class="s3">var </span><span class="s2">tagClass </span><span class="s4">= (</span><span class="s2">b1 </span><span class="s4">&amp; </span><span class="s7">0xC0</span><span class="s4">);</span>

  <span class="s6">// get the type (bits 1-5)</span>
  <span class="s3">var </span><span class="s2">type </span><span class="s4">= </span><span class="s2">b1 </span><span class="s4">&amp; </span><span class="s7">0x1F</span><span class="s4">;</span>

  <span class="s6">// get the variable value length and adjust remaining bytes</span>
  <span class="s2">start </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
  <span class="s3">var </span><span class="s2">length </span><span class="s4">= </span><span class="s2">_getValueLength</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">, </span><span class="s2">remaining</span><span class="s4">);</span>
  <span class="s2">remaining </span><span class="s4">-= </span><span class="s2">start </span><span class="s4">- </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>

  <span class="s6">// ensure there are enough bytes to get the value</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">length </span><span class="s4">!== </span><span class="s2">undefined </span><span class="s4">&amp;&amp; </span><span class="s2">length </span><span class="s4">&gt; </span><span class="s2">remaining</span><span class="s4">) {</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">strict</span><span class="s4">) {</span>
      <span class="s3">var </span><span class="s2">error </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Too few bytes to read ASN.1 value.'</span><span class="s4">);</span>
      <span class="s2">error</span><span class="s4">.</span><span class="s2">available </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
      <span class="s2">error</span><span class="s4">.</span><span class="s2">remaining </span><span class="s4">= </span><span class="s2">remaining</span><span class="s4">;</span>
      <span class="s2">error</span><span class="s4">.</span><span class="s2">requested </span><span class="s4">= </span><span class="s2">length</span><span class="s4">;</span>
      <span class="s3">throw </span><span class="s2">error</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s6">// Note: be lenient with truncated values and use remaining state bytes</span>
    <span class="s2">length </span><span class="s4">= </span><span class="s2">remaining</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// value storage</span>
  <span class="s3">var </span><span class="s2">value</span><span class="s4">;</span>
  <span class="s6">// possible BIT STRING contents storage</span>
  <span class="s3">var </span><span class="s2">bitStringContents</span><span class="s4">;</span>

  <span class="s6">// constructed flag is bit 6 (32 = 0x20) of the first byte</span>
  <span class="s3">var </span><span class="s2">constructed </span><span class="s4">= ((</span><span class="s2">b1 </span><span class="s4">&amp; </span><span class="s7">0x20</span><span class="s4">) === </span><span class="s7">0x20</span><span class="s4">);</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">constructed</span><span class="s4">) {</span>
    <span class="s6">// parse child asn1 objects from the value</span>
    <span class="s2">value </span><span class="s4">= [];</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">length </span><span class="s4">=== </span><span class="s2">undefined</span><span class="s4">) {</span>
      <span class="s6">// asn1 object of indefinite length, read until end tag</span>
      <span class="s3">for</span><span class="s4">(;;) {</span>
        <span class="s2">_checkBufferLength</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">, </span><span class="s2">remaining</span><span class="s4">, </span><span class="s7">2</span><span class="s4">);</span>
        <span class="s3">if</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">bytes</span><span class="s4">(</span><span class="s7">2</span><span class="s4">) === </span><span class="s2">String</span><span class="s4">.</span><span class="s2">fromCharCode</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">)) {</span>
          <span class="s2">bytes</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span><span class="s7">2</span><span class="s4">);</span>
          <span class="s2">remaining </span><span class="s4">-= </span><span class="s7">2</span><span class="s4">;</span>
          <span class="s3">break</span><span class="s4">;</span>
        <span class="s4">}</span>
        <span class="s2">start </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
        <span class="s2">value</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">_fromDer</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">, </span><span class="s2">remaining</span><span class="s4">, </span><span class="s2">depth </span><span class="s4">+ </span><span class="s7">1</span><span class="s4">, </span><span class="s2">options</span><span class="s4">));</span>
        <span class="s2">remaining </span><span class="s4">-= </span><span class="s2">start </span><span class="s4">- </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
      <span class="s4">}</span>
    <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
      <span class="s6">// parsing asn1 object of definite length</span>
      <span class="s3">while</span><span class="s4">(</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
        <span class="s2">start </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
        <span class="s2">value</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">_fromDer</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">, </span><span class="s2">length</span><span class="s4">, </span><span class="s2">depth </span><span class="s4">+ </span><span class="s7">1</span><span class="s4">, </span><span class="s2">options</span><span class="s4">));</span>
        <span class="s2">remaining </span><span class="s4">-= </span><span class="s2">start </span><span class="s4">- </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
        <span class="s2">length </span><span class="s4">-= </span><span class="s2">start </span><span class="s4">- </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s6">// if a BIT STRING, save the contents including padding</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">value </span><span class="s4">=== </span><span class="s2">undefined </span><span class="s4">&amp;&amp; </span><span class="s2">tagClass </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL </span><span class="s4">&amp;&amp;</span>
    <span class="s2">type </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">BITSTRING</span><span class="s4">) {</span>
    <span class="s2">bitStringContents </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">bytes</span><span class="s4">(</span><span class="s2">length</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s6">// determine if a non-constructed value should be decoded as a composed</span>
  <span class="s6">// value that contains other ASN.1 objects. BIT STRINGs (and OCTET STRINGs)</span>
  <span class="s6">// can be used this way.</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">value </span><span class="s4">=== </span><span class="s2">undefined </span><span class="s4">&amp;&amp; </span><span class="s2">options</span><span class="s4">.</span><span class="s2">decodeBitStrings </span><span class="s4">&amp;&amp;</span>
    <span class="s2">tagClass </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL </span><span class="s4">&amp;&amp;</span>
    <span class="s6">// FIXME: OCTET STRINGs not yet supported here</span>
    <span class="s6">// .. other parts of forge expect to decode OCTET STRINGs manually</span>
    <span class="s4">(</span><span class="s2">type </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">BITSTRING </span><span class="s6">/*|| type === asn1.Type.OCTETSTRING*/</span><span class="s4">) &amp;&amp;</span>
    <span class="s2">length </span><span class="s4">&gt; </span><span class="s7">1</span><span class="s4">) {</span>
    <span class="s6">// save read position</span>
    <span class="s3">var </span><span class="s2">savedRead </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">read</span><span class="s4">;</span>
    <span class="s3">var </span><span class="s2">savedRemaining </span><span class="s4">= </span><span class="s2">remaining</span><span class="s4">;</span>
    <span class="s3">var </span><span class="s2">unused </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">type </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">BITSTRING</span><span class="s4">) {</span>
      <span class="s6">/* The first octet gives the number of bits by which the length of the 
        bit string is less than the next multiple of eight (this is called 
        the &quot;number of unused bits&quot;). 
 
        The second and following octets give the value of the bit string 
        converted to an octet string. */</span>
      <span class="s2">_checkBufferLength</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">, </span><span class="s2">remaining</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
      <span class="s2">unused </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">getByte</span><span class="s4">();</span>
      <span class="s2">remaining</span><span class="s4">--;</span>
    <span class="s4">}</span>
    <span class="s6">// if all bits are used, maybe the BIT/OCTET STRING holds ASN.1 objs</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">unused </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
      <span class="s3">try </span><span class="s4">{</span>
        <span class="s6">// attempt to parse child asn1 object from the value</span>
        <span class="s6">// (stored in array to signal composed value)</span>
        <span class="s2">start </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
        <span class="s3">var </span><span class="s2">subOptions </span><span class="s4">= {</span>
          <span class="s6">// enforce strict mode to avoid parsing ASN.1 from plain data</span>
          <span class="s2">strict</span><span class="s4">: </span><span class="s3">true</span><span class="s4">,</span>
          <span class="s2">decodeBitStrings</span><span class="s4">: </span><span class="s3">true</span>
        <span class="s4">};</span>
        <span class="s3">var </span><span class="s2">composed </span><span class="s4">= </span><span class="s2">_fromDer</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">, </span><span class="s2">remaining</span><span class="s4">, </span><span class="s2">depth </span><span class="s4">+ </span><span class="s7">1</span><span class="s4">, </span><span class="s2">subOptions</span><span class="s4">);</span>
        <span class="s3">var </span><span class="s2">used </span><span class="s4">= </span><span class="s2">start </span><span class="s4">- </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
        <span class="s2">remaining </span><span class="s4">-= </span><span class="s2">used</span><span class="s4">;</span>
        <span class="s3">if</span><span class="s4">(</span><span class="s2">type </span><span class="s4">== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">BITSTRING</span><span class="s4">) {</span>
          <span class="s2">used</span><span class="s4">++;</span>
        <span class="s4">}</span>

        <span class="s6">// if the data all decoded and the class indicates UNIVERSAL or</span>
        <span class="s6">// CONTEXT_SPECIFIC then assume we've got an encapsulated ASN.1 object</span>
        <span class="s3">var </span><span class="s2">tc </span><span class="s4">= </span><span class="s2">composed</span><span class="s4">.</span><span class="s2">tagClass</span><span class="s4">;</span>
        <span class="s3">if</span><span class="s4">(</span><span class="s2">used </span><span class="s4">=== </span><span class="s2">length </span><span class="s4">&amp;&amp;</span>
          <span class="s4">(</span><span class="s2">tc </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL </span><span class="s4">|| </span><span class="s2">tc </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">CONTEXT_SPECIFIC</span><span class="s4">)) {</span>
          <span class="s2">value </span><span class="s4">= [</span><span class="s2">composed</span><span class="s4">];</span>
        <span class="s4">}</span>
      <span class="s4">} </span><span class="s3">catch</span><span class="s4">(</span><span class="s2">ex</span><span class="s4">) {</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">value </span><span class="s4">=== </span><span class="s2">undefined</span><span class="s4">) {</span>
      <span class="s6">// restore read position</span>
      <span class="s2">bytes</span><span class="s4">.</span><span class="s2">read </span><span class="s4">= </span><span class="s2">savedRead</span><span class="s4">;</span>
      <span class="s2">remaining </span><span class="s4">= </span><span class="s2">savedRemaining</span><span class="s4">;</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">value </span><span class="s4">=== </span><span class="s2">undefined</span><span class="s4">) {</span>
    <span class="s6">// asn1 not constructed or composed, get raw value</span>
    <span class="s6">// TODO: do DER to OID conversion and vice-versa in .toDer?</span>

    <span class="s3">if</span><span class="s4">(</span><span class="s2">length </span><span class="s4">=== </span><span class="s2">undefined</span><span class="s4">) {</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">strict</span><span class="s4">) {</span>
        <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Non-constructed ASN.1 object of indefinite length.'</span><span class="s4">);</span>
      <span class="s4">}</span>
      <span class="s6">// be lenient and use remaining state bytes</span>
      <span class="s2">length </span><span class="s4">= </span><span class="s2">remaining</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s3">if</span><span class="s4">(</span><span class="s2">type </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">BMPSTRING</span><span class="s4">) {</span>
      <span class="s2">value </span><span class="s4">= </span><span class="s5">''</span><span class="s4">;</span>
      <span class="s3">for</span><span class="s4">(; </span><span class="s2">length </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">; </span><span class="s2">length </span><span class="s4">-= </span><span class="s7">2</span><span class="s4">) {</span>
        <span class="s2">_checkBufferLength</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">, </span><span class="s2">remaining</span><span class="s4">, </span><span class="s7">2</span><span class="s4">);</span>
        <span class="s2">value </span><span class="s4">+= </span><span class="s2">String</span><span class="s4">.</span><span class="s2">fromCharCode</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">getInt16</span><span class="s4">());</span>
        <span class="s2">remaining </span><span class="s4">-= </span><span class="s7">2</span><span class="s4">;</span>
      <span class="s4">}</span>
    <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
      <span class="s2">value </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span><span class="s2">length</span><span class="s4">);</span>
      <span class="s2">remaining </span><span class="s4">-= </span><span class="s2">length</span><span class="s4">;</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s6">// add BIT STRING contents if available</span>
  <span class="s3">var </span><span class="s2">asn1Options </span><span class="s4">= </span><span class="s2">bitStringContents </span><span class="s4">=== </span><span class="s2">undefined </span><span class="s4">? </span><span class="s3">null </span><span class="s4">: {</span>
    <span class="s2">bitStringContents</span><span class="s4">: </span><span class="s2">bitStringContents</span>
  <span class="s4">};</span>

  <span class="s6">// create and return asn1 object</span>
  <span class="s3">return </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">tagClass</span><span class="s4">, </span><span class="s2">type</span><span class="s4">, </span><span class="s2">constructed</span><span class="s4">, </span><span class="s2">value</span><span class="s4">, </span><span class="s2">asn1Options</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Converts the given asn1 object to a buffer of bytes in DER format.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">asn1 the asn1 object to convert to bytes.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the buffer of bytes.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">toDer </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">bytes </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">();</span>

  <span class="s6">// build the first byte</span>
  <span class="s3">var </span><span class="s2">b1 </span><span class="s4">= </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">tagClass </span><span class="s4">| </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">type</span><span class="s4">;</span>

  <span class="s6">// for storing the ASN.1 value</span>
  <span class="s3">var </span><span class="s2">value </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">();</span>

  <span class="s6">// use BIT STRING contents if available and data not changed</span>
  <span class="s3">var </span><span class="s2">useBitStringContents </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s5">'bitStringContents' </span><span class="s3">in </span><span class="s2">obj</span><span class="s4">) {</span>
    <span class="s2">useBitStringContents </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">original</span><span class="s4">) {</span>
      <span class="s2">useBitStringContents </span><span class="s4">= </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">equals</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">, </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">original</span><span class="s4">);</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">useBitStringContents</span><span class="s4">) {</span>
    <span class="s2">value</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">bitStringContents</span><span class="s4">);</span>
  <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">composed</span><span class="s4">) {</span>
    <span class="s6">// if composed, use each child asn1 object's DER bytes as value</span>
    <span class="s6">// turn on 6th bit (0x20 = 32) to indicate asn1 is constructed</span>
    <span class="s6">// from other asn1 objects</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">constructed</span><span class="s4">) {</span>
      <span class="s2">b1 </span><span class="s4">|= </span><span class="s7">0x20</span><span class="s4">;</span>
    <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
      <span class="s6">// type is a bit string, add unused bits of 0x00</span>
      <span class="s2">value</span><span class="s4">.</span><span class="s2">putByte</span><span class="s4">(</span><span class="s7">0x00</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s6">// add all of the child DER bytes together</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] !== </span><span class="s2">undefined</span><span class="s4">) {</span>
        <span class="s2">value</span><span class="s4">.</span><span class="s2">putBuffer</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">toDer</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]));</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s6">// use asn1.value directly</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">BMPSTRING</span><span class="s4">) {</span>
      <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
        <span class="s2">value</span><span class="s4">.</span><span class="s2">putInt16</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">charCodeAt</span><span class="s4">(</span><span class="s2">i</span><span class="s4">));</span>
      <span class="s4">}</span>
    <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
      <span class="s6">// ensure integer is minimally-encoded</span>
      <span class="s6">// TODO: should all leading bytes be stripped vs just one?</span>
      <span class="s6">// .. ex '00 00 01' =&gt; '01'?</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER </span><span class="s4">&amp;&amp;</span>
        <span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s7">1 </span><span class="s4">&amp;&amp;</span>
        <span class="s6">// leading 0x00 for positive integer</span>
        <span class="s4">((</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">charCodeAt</span><span class="s4">(</span><span class="s7">0</span><span class="s4">) === </span><span class="s7">0 </span><span class="s4">&amp;&amp;</span>
        <span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">charCodeAt</span><span class="s4">(</span><span class="s7">1</span><span class="s4">) &amp; </span><span class="s7">0x80</span><span class="s4">) === </span><span class="s7">0</span><span class="s4">) ||</span>
        <span class="s6">// leading 0xFF for negative integer</span>
        <span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">charCodeAt</span><span class="s4">(</span><span class="s7">0</span><span class="s4">) === </span><span class="s7">0xFF </span><span class="s4">&amp;&amp;</span>
        <span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">charCodeAt</span><span class="s4">(</span><span class="s7">1</span><span class="s4">) &amp; </span><span class="s7">0x80</span><span class="s4">) === </span><span class="s7">0x80</span><span class="s4">))) {</span>
        <span class="s2">value</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s7">1</span><span class="s4">));</span>
      <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
        <span class="s2">value</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">);</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s6">// add tag byte</span>
  <span class="s2">bytes</span><span class="s4">.</span><span class="s2">putByte</span><span class="s4">(</span><span class="s2">b1</span><span class="s4">);</span>

  <span class="s6">// use &quot;short form&quot; encoding</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">value</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() &lt;= </span><span class="s7">127</span><span class="s4">) {</span>
    <span class="s6">// one byte describes the length</span>
    <span class="s6">// bit 8 = 0 and bits 7-1 = length</span>
    <span class="s2">bytes</span><span class="s4">.</span><span class="s2">putByte</span><span class="s4">(</span><span class="s2">value</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() &amp; </span><span class="s7">0x7F</span><span class="s4">);</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s6">// use &quot;long form&quot; encoding</span>
    <span class="s6">// 2 to 127 bytes describe the length</span>
    <span class="s6">// first byte: bit 8 = 1 and bits 7-1 = # of additional bytes</span>
    <span class="s6">// other bytes: length in base 256, big-endian</span>
    <span class="s3">var </span><span class="s2">len </span><span class="s4">= </span><span class="s2">value</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
    <span class="s3">var </span><span class="s2">lenBytes </span><span class="s4">= </span><span class="s5">''</span><span class="s4">;</span>
    <span class="s3">do </span><span class="s4">{</span>
      <span class="s2">lenBytes </span><span class="s4">+= </span><span class="s2">String</span><span class="s4">.</span><span class="s2">fromCharCode</span><span class="s4">(</span><span class="s2">len </span><span class="s4">&amp; </span><span class="s7">0xFF</span><span class="s4">);</span>
      <span class="s2">len </span><span class="s4">= </span><span class="s2">len </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">8</span><span class="s4">;</span>
    <span class="s4">} </span><span class="s3">while</span><span class="s4">(</span><span class="s2">len </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">);</span>

    <span class="s6">// set first byte to # bytes used to store the length and turn on</span>
    <span class="s6">// bit 8 to indicate long-form length is used</span>
    <span class="s2">bytes</span><span class="s4">.</span><span class="s2">putByte</span><span class="s4">(</span><span class="s2">lenBytes</span><span class="s4">.</span><span class="s2">length </span><span class="s4">| </span><span class="s7">0x80</span><span class="s4">);</span>

    <span class="s6">// concatenate length bytes in reverse since they were generated</span>
    <span class="s6">// little endian and we need big endian</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s2">lenBytes</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s7">1</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&gt;= </span><span class="s7">0</span><span class="s4">; --</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s2">bytes</span><span class="s4">.</span><span class="s2">putByte</span><span class="s4">(</span><span class="s2">lenBytes</span><span class="s4">.</span><span class="s2">charCodeAt</span><span class="s4">(</span><span class="s2">i</span><span class="s4">));</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s6">// concatenate value bytes</span>
  <span class="s2">bytes</span><span class="s4">.</span><span class="s2">putBuffer</span><span class="s4">(</span><span class="s2">value</span><span class="s4">);</span>
  <span class="s3">return </span><span class="s2">bytes</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts an OID dot-separated string to a byte buffer. The byte buffer</span>
 <span class="s0">* contains only the DER-encoded value, not any tag or length bytes.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">oid the OID dot-separated string.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the byte buffer.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">oidToDer </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">oid</span><span class="s4">) {</span>
  <span class="s6">// split OID into individual values</span>
  <span class="s3">var </span><span class="s2">values </span><span class="s4">= </span><span class="s2">oid</span><span class="s4">.</span><span class="s2">split</span><span class="s4">(</span><span class="s5">'.'</span><span class="s4">);</span>
  <span class="s3">var </span><span class="s2">bytes </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">();</span>

  <span class="s6">// first byte is 40 * value1 + value2</span>
  <span class="s2">bytes</span><span class="s4">.</span><span class="s2">putByte</span><span class="s4">(</span><span class="s7">40 </span><span class="s4">* </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">values</span><span class="s4">[</span><span class="s7">0</span><span class="s4">], </span><span class="s7">10</span><span class="s4">) + </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">values</span><span class="s4">[</span><span class="s7">1</span><span class="s4">], </span><span class="s7">10</span><span class="s4">));</span>
  <span class="s6">// other bytes are each value in base 128 with 8th bit set except for</span>
  <span class="s6">// the last byte for each value</span>
  <span class="s3">var </span><span class="s2">last</span><span class="s4">, </span><span class="s2">valueBytes</span><span class="s4">, </span><span class="s2">value</span><span class="s4">, </span><span class="s2">b</span><span class="s4">;</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">2</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">values</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s6">// produce value bytes in reverse because we don't know how many</span>
    <span class="s6">// bytes it will take to store the value</span>
    <span class="s2">last </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
    <span class="s2">valueBytes </span><span class="s4">= [];</span>
    <span class="s2">value </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">values</span><span class="s4">[</span><span class="s2">i</span><span class="s4">], </span><span class="s7">10</span><span class="s4">);</span>
    <span class="s3">do </span><span class="s4">{</span>
      <span class="s2">b </span><span class="s4">= </span><span class="s2">value </span><span class="s4">&amp; </span><span class="s7">0x7F</span><span class="s4">;</span>
      <span class="s2">value </span><span class="s4">= </span><span class="s2">value </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">7</span><span class="s4">;</span>
      <span class="s6">// if value is not last, then turn on 8th bit</span>
      <span class="s3">if</span><span class="s4">(!</span><span class="s2">last</span><span class="s4">) {</span>
        <span class="s2">b </span><span class="s4">|= </span><span class="s7">0x80</span><span class="s4">;</span>
      <span class="s4">}</span>
      <span class="s2">valueBytes</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">b</span><span class="s4">);</span>
      <span class="s2">last </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
    <span class="s4">} </span><span class="s3">while</span><span class="s4">(</span><span class="s2">value </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">);</span>

    <span class="s6">// add value bytes in reverse (needs to be in big endian)</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">n </span><span class="s4">= </span><span class="s2">valueBytes</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s7">1</span><span class="s4">; </span><span class="s2">n </span><span class="s4">&gt;= </span><span class="s7">0</span><span class="s4">; --</span><span class="s2">n</span><span class="s4">) {</span>
      <span class="s2">bytes</span><span class="s4">.</span><span class="s2">putByte</span><span class="s4">(</span><span class="s2">valueBytes</span><span class="s4">[</span><span class="s2">n</span><span class="s4">]);</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s3">return </span><span class="s2">bytes</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a DER-encoded byte buffer to an OID dot-separated string. The</span>
 <span class="s0">* byte buffer should contain only the DER-encoded value, not any tag or</span>
 <span class="s0">* length bytes.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">bytes the byte buffer.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the OID dot-separated string.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">derToOid </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">oid</span><span class="s4">;</span>

  <span class="s6">// wrap in buffer if needed</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">bytes </span><span class="s4">=== </span><span class="s5">'string'</span><span class="s4">) {</span>
    <span class="s2">bytes </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s6">// first byte is 40 * value1 + value2</span>
  <span class="s3">var </span><span class="s2">b </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">getByte</span><span class="s4">();</span>
  <span class="s2">oid </span><span class="s4">= </span><span class="s2">Math</span><span class="s4">.</span><span class="s2">floor</span><span class="s4">(</span><span class="s2">b </span><span class="s4">/ </span><span class="s7">40</span><span class="s4">) + </span><span class="s5">'.' </span><span class="s4">+ (</span><span class="s2">b </span><span class="s4">% </span><span class="s7">40</span><span class="s4">);</span>

  <span class="s6">// other bytes are each value in base 128 with 8th bit set except for</span>
  <span class="s6">// the last byte for each value</span>
  <span class="s3">var </span><span class="s2">value </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
  <span class="s3">while</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() &gt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s2">b </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">getByte</span><span class="s4">();</span>
    <span class="s2">value </span><span class="s4">= </span><span class="s2">value </span><span class="s4">&lt;&lt; </span><span class="s7">7</span><span class="s4">;</span>
    <span class="s6">// not the last byte for the value</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">b </span><span class="s4">&amp; </span><span class="s7">0x80</span><span class="s4">) {</span>
      <span class="s2">value </span><span class="s4">+= </span><span class="s2">b </span><span class="s4">&amp; </span><span class="s7">0x7F</span><span class="s4">;</span>
    <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
      <span class="s6">// last byte</span>
      <span class="s2">oid </span><span class="s4">+= </span><span class="s5">'.' </span><span class="s4">+ (</span><span class="s2">value </span><span class="s4">+ </span><span class="s2">b</span><span class="s4">);</span>
      <span class="s2">value </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s3">return </span><span class="s2">oid</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a UTCTime value to a date.</span>
 <span class="s0">*</span>
 <span class="s0">* Note: GeneralizedTime has 4 digits for the year and is used for X.509</span>
 <span class="s0">* dates past 2049. Parsing that structure hasn't been implemented yet.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">utc the UTCTime value to convert.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the date.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">utcTimeToDate </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">utc</span><span class="s4">) {</span>
  <span class="s6">/* The following formats can be used: 
 
    YYMMDDhhmmZ 
    YYMMDDhhmm+hh'mm' 
    YYMMDDhhmm-hh'mm' 
    YYMMDDhhmmssZ 
    YYMMDDhhmmss+hh'mm' 
    YYMMDDhhmmss-hh'mm' 
 
    Where: 
 
    YY is the least significant two digits of the year 
    MM is the month (01 to 12) 
    DD is the day (01 to 31) 
    hh is the hour (00 to 23) 
    mm are the minutes (00 to 59) 
    ss are the seconds (00 to 59) 
    Z indicates that local time is GMT, + indicates that local time is 
    later than GMT, and - indicates that local time is earlier than GMT 
    hh' is the absolute value of the offset from GMT in hours 
    mm' is the absolute value of the offset from GMT in minutes */</span>
  <span class="s3">var </span><span class="s2">date </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Date</span><span class="s4">();</span>

  <span class="s6">// if YY &gt;= 50 use 19xx, if YY &lt; 50 use 20xx</span>
  <span class="s3">var </span><span class="s2">year </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">utc</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, </span><span class="s7">2</span><span class="s4">), </span><span class="s7">10</span><span class="s4">);</span>
  <span class="s2">year </span><span class="s4">= (</span><span class="s2">year </span><span class="s4">&gt;= </span><span class="s7">50</span><span class="s4">) ? </span><span class="s7">1900 </span><span class="s4">+ </span><span class="s2">year </span><span class="s4">: </span><span class="s7">2000 </span><span class="s4">+ </span><span class="s2">year</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">MM </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">utc</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s7">2</span><span class="s4">, </span><span class="s7">2</span><span class="s4">), </span><span class="s7">10</span><span class="s4">) - </span><span class="s7">1</span><span class="s4">; </span><span class="s6">// use 0-11 for month</span>
  <span class="s3">var </span><span class="s2">DD </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">utc</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s7">4</span><span class="s4">, </span><span class="s7">2</span><span class="s4">), </span><span class="s7">10</span><span class="s4">);</span>
  <span class="s3">var </span><span class="s2">hh </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">utc</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s7">6</span><span class="s4">, </span><span class="s7">2</span><span class="s4">), </span><span class="s7">10</span><span class="s4">);</span>
  <span class="s3">var </span><span class="s2">mm </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">utc</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s7">8</span><span class="s4">, </span><span class="s7">2</span><span class="s4">), </span><span class="s7">10</span><span class="s4">);</span>
  <span class="s3">var </span><span class="s2">ss </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>

  <span class="s6">// not just YYMMDDhhmmZ</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">utc</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s7">11</span><span class="s4">) {</span>
    <span class="s6">// get character after minutes</span>
    <span class="s3">var </span><span class="s2">c </span><span class="s4">= </span><span class="s2">utc</span><span class="s4">.</span><span class="s2">charAt</span><span class="s4">(</span><span class="s7">10</span><span class="s4">);</span>
    <span class="s3">var </span><span class="s2">end </span><span class="s4">= </span><span class="s7">10</span><span class="s4">;</span>

    <span class="s6">// see if seconds are present</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">c </span><span class="s4">!== </span><span class="s5">'+' </span><span class="s4">&amp;&amp; </span><span class="s2">c </span><span class="s4">!== </span><span class="s5">'-'</span><span class="s4">) {</span>
      <span class="s6">// get seconds</span>
      <span class="s2">ss </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">utc</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s7">10</span><span class="s4">, </span><span class="s7">2</span><span class="s4">), </span><span class="s7">10</span><span class="s4">);</span>
      <span class="s2">end </span><span class="s4">+= </span><span class="s7">2</span><span class="s4">;</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s6">// update date</span>
  <span class="s2">date</span><span class="s4">.</span><span class="s2">setUTCFullYear</span><span class="s4">(</span><span class="s2">year</span><span class="s4">, </span><span class="s2">MM</span><span class="s4">, </span><span class="s2">DD</span><span class="s4">);</span>
  <span class="s2">date</span><span class="s4">.</span><span class="s2">setUTCHours</span><span class="s4">(</span><span class="s2">hh</span><span class="s4">, </span><span class="s2">mm</span><span class="s4">, </span><span class="s2">ss</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">end</span><span class="s4">) {</span>
    <span class="s6">// get +/- after end of time</span>
    <span class="s2">c </span><span class="s4">= </span><span class="s2">utc</span><span class="s4">.</span><span class="s2">charAt</span><span class="s4">(</span><span class="s2">end</span><span class="s4">);</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">c </span><span class="s4">=== </span><span class="s5">'+' </span><span class="s4">|| </span><span class="s2">c </span><span class="s4">=== </span><span class="s5">'-'</span><span class="s4">) {</span>
      <span class="s6">// get hours+minutes offset</span>
      <span class="s3">var </span><span class="s2">hhoffset </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">utc</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s2">end </span><span class="s4">+ </span><span class="s7">1</span><span class="s4">, </span><span class="s7">2</span><span class="s4">), </span><span class="s7">10</span><span class="s4">);</span>
      <span class="s3">var </span><span class="s2">mmoffset </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">utc</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s2">end </span><span class="s4">+ </span><span class="s7">4</span><span class="s4">, </span><span class="s7">2</span><span class="s4">), </span><span class="s7">10</span><span class="s4">);</span>

      <span class="s6">// calculate offset in milliseconds</span>
      <span class="s3">var </span><span class="s2">offset </span><span class="s4">= </span><span class="s2">hhoffset </span><span class="s4">* </span><span class="s7">60 </span><span class="s4">+ </span><span class="s2">mmoffset</span><span class="s4">;</span>
      <span class="s2">offset </span><span class="s4">*= </span><span class="s7">60000</span><span class="s4">;</span>

      <span class="s6">// apply offset</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">c </span><span class="s4">=== </span><span class="s5">'+'</span><span class="s4">) {</span>
        <span class="s2">date</span><span class="s4">.</span><span class="s2">setTime</span><span class="s4">(+</span><span class="s2">date </span><span class="s4">- </span><span class="s2">offset</span><span class="s4">);</span>
      <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
        <span class="s2">date</span><span class="s4">.</span><span class="s2">setTime</span><span class="s4">(+</span><span class="s2">date </span><span class="s4">+ </span><span class="s2">offset</span><span class="s4">);</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s3">return </span><span class="s2">date</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a GeneralizedTime value to a date.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">gentime the GeneralizedTime value to convert.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the date.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">generalizedTimeToDate </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">gentime</span><span class="s4">) {</span>
  <span class="s6">/* The following formats can be used: 
 
    YYYYMMDDHHMMSS 
    YYYYMMDDHHMMSS.fff 
    YYYYMMDDHHMMSSZ 
    YYYYMMDDHHMMSS.fffZ 
    YYYYMMDDHHMMSS+hh'mm' 
    YYYYMMDDHHMMSS.fff+hh'mm' 
    YYYYMMDDHHMMSS-hh'mm' 
    YYYYMMDDHHMMSS.fff-hh'mm' 
 
    Where: 
 
    YYYY is the year 
    MM is the month (01 to 12) 
    DD is the day (01 to 31) 
    hh is the hour (00 to 23) 
    mm are the minutes (00 to 59) 
    ss are the seconds (00 to 59) 
    .fff is the second fraction, accurate to three decimal places 
    Z indicates that local time is GMT, + indicates that local time is 
    later than GMT, and - indicates that local time is earlier than GMT 
    hh' is the absolute value of the offset from GMT in hours 
    mm' is the absolute value of the offset from GMT in minutes */</span>
  <span class="s3">var </span><span class="s2">date </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Date</span><span class="s4">();</span>

  <span class="s3">var </span><span class="s2">YYYY </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">gentime</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, </span><span class="s7">4</span><span class="s4">), </span><span class="s7">10</span><span class="s4">);</span>
  <span class="s3">var </span><span class="s2">MM </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">gentime</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s7">4</span><span class="s4">, </span><span class="s7">2</span><span class="s4">), </span><span class="s7">10</span><span class="s4">) - </span><span class="s7">1</span><span class="s4">; </span><span class="s6">// use 0-11 for month</span>
  <span class="s3">var </span><span class="s2">DD </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">gentime</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s7">6</span><span class="s4">, </span><span class="s7">2</span><span class="s4">), </span><span class="s7">10</span><span class="s4">);</span>
  <span class="s3">var </span><span class="s2">hh </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">gentime</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s7">8</span><span class="s4">, </span><span class="s7">2</span><span class="s4">), </span><span class="s7">10</span><span class="s4">);</span>
  <span class="s3">var </span><span class="s2">mm </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">gentime</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s7">10</span><span class="s4">, </span><span class="s7">2</span><span class="s4">), </span><span class="s7">10</span><span class="s4">);</span>
  <span class="s3">var </span><span class="s2">ss </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">gentime</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s7">12</span><span class="s4">, </span><span class="s7">2</span><span class="s4">), </span><span class="s7">10</span><span class="s4">);</span>
  <span class="s3">var </span><span class="s2">fff </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">offset </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">isUTC </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">gentime</span><span class="s4">.</span><span class="s2">charAt</span><span class="s4">(</span><span class="s2">gentime</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s7">1</span><span class="s4">) === </span><span class="s5">'Z'</span><span class="s4">) {</span>
    <span class="s2">isUTC </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s3">var </span><span class="s2">end </span><span class="s4">= </span><span class="s2">gentime</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s7">5</span><span class="s4">, </span><span class="s2">c </span><span class="s4">= </span><span class="s2">gentime</span><span class="s4">.</span><span class="s2">charAt</span><span class="s4">(</span><span class="s2">end</span><span class="s4">);</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">c </span><span class="s4">=== </span><span class="s5">'+' </span><span class="s4">|| </span><span class="s2">c </span><span class="s4">=== </span><span class="s5">'-'</span><span class="s4">) {</span>
    <span class="s6">// get hours+minutes offset</span>
    <span class="s3">var </span><span class="s2">hhoffset </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">gentime</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s2">end </span><span class="s4">+ </span><span class="s7">1</span><span class="s4">, </span><span class="s7">2</span><span class="s4">), </span><span class="s7">10</span><span class="s4">);</span>
    <span class="s3">var </span><span class="s2">mmoffset </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">gentime</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s2">end </span><span class="s4">+ </span><span class="s7">4</span><span class="s4">, </span><span class="s7">2</span><span class="s4">), </span><span class="s7">10</span><span class="s4">);</span>

    <span class="s6">// calculate offset in milliseconds</span>
    <span class="s2">offset </span><span class="s4">= </span><span class="s2">hhoffset </span><span class="s4">* </span><span class="s7">60 </span><span class="s4">+ </span><span class="s2">mmoffset</span><span class="s4">;</span>
    <span class="s2">offset </span><span class="s4">*= </span><span class="s7">60000</span><span class="s4">;</span>

    <span class="s6">// apply offset</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">c </span><span class="s4">=== </span><span class="s5">'+'</span><span class="s4">) {</span>
      <span class="s2">offset </span><span class="s4">*= -</span><span class="s7">1</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s2">isUTC </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// check for second fraction</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">gentime</span><span class="s4">.</span><span class="s2">charAt</span><span class="s4">(</span><span class="s7">14</span><span class="s4">) === </span><span class="s5">'.'</span><span class="s4">) {</span>
    <span class="s2">fff </span><span class="s4">= </span><span class="s2">parseFloat</span><span class="s4">(</span><span class="s2">gentime</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s7">14</span><span class="s4">), </span><span class="s7">10</span><span class="s4">) * </span><span class="s7">1000</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">isUTC</span><span class="s4">) {</span>
    <span class="s2">date</span><span class="s4">.</span><span class="s2">setUTCFullYear</span><span class="s4">(</span><span class="s2">YYYY</span><span class="s4">, </span><span class="s2">MM</span><span class="s4">, </span><span class="s2">DD</span><span class="s4">);</span>
    <span class="s2">date</span><span class="s4">.</span><span class="s2">setUTCHours</span><span class="s4">(</span><span class="s2">hh</span><span class="s4">, </span><span class="s2">mm</span><span class="s4">, </span><span class="s2">ss</span><span class="s4">, </span><span class="s2">fff</span><span class="s4">);</span>

    <span class="s6">// apply offset</span>
    <span class="s2">date</span><span class="s4">.</span><span class="s2">setTime</span><span class="s4">(+</span><span class="s2">date </span><span class="s4">+ </span><span class="s2">offset</span><span class="s4">);</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s2">date</span><span class="s4">.</span><span class="s2">setFullYear</span><span class="s4">(</span><span class="s2">YYYY</span><span class="s4">, </span><span class="s2">MM</span><span class="s4">, </span><span class="s2">DD</span><span class="s4">);</span>
    <span class="s2">date</span><span class="s4">.</span><span class="s2">setHours</span><span class="s4">(</span><span class="s2">hh</span><span class="s4">, </span><span class="s2">mm</span><span class="s4">, </span><span class="s2">ss</span><span class="s4">, </span><span class="s2">fff</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s3">return </span><span class="s2">date</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a date to a UTCTime value.</span>
 <span class="s0">*</span>
 <span class="s0">* Note: GeneralizedTime has 4 digits for the year and is used for X.509</span>
 <span class="s0">* dates past 2049. Converting to a GeneralizedTime hasn't been</span>
 <span class="s0">* implemented yet.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">date the date to convert.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the UTCTime value.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">dateToUtcTime </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">date</span><span class="s4">) {</span>
  <span class="s6">// TODO: validate; currently assumes proper format</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">date </span><span class="s4">=== </span><span class="s5">'string'</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">date</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s3">var </span><span class="s2">rval </span><span class="s4">= </span><span class="s5">''</span><span class="s4">;</span>

  <span class="s6">// create format YYMMDDhhmmssZ</span>
  <span class="s3">var </span><span class="s2">format </span><span class="s4">= [];</span>
  <span class="s2">format</span><span class="s4">.</span><span class="s2">push</span><span class="s4">((</span><span class="s5">'' </span><span class="s4">+ </span><span class="s2">date</span><span class="s4">.</span><span class="s2">getUTCFullYear</span><span class="s4">()).</span><span class="s2">substr</span><span class="s4">(</span><span class="s7">2</span><span class="s4">));</span>
  <span class="s2">format</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s5">'' </span><span class="s4">+ (</span><span class="s2">date</span><span class="s4">.</span><span class="s2">getUTCMonth</span><span class="s4">() + </span><span class="s7">1</span><span class="s4">));</span>
  <span class="s2">format</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s5">'' </span><span class="s4">+ </span><span class="s2">date</span><span class="s4">.</span><span class="s2">getUTCDate</span><span class="s4">());</span>
  <span class="s2">format</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s5">'' </span><span class="s4">+ </span><span class="s2">date</span><span class="s4">.</span><span class="s2">getUTCHours</span><span class="s4">());</span>
  <span class="s2">format</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s5">'' </span><span class="s4">+ </span><span class="s2">date</span><span class="s4">.</span><span class="s2">getUTCMinutes</span><span class="s4">());</span>
  <span class="s2">format</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s5">'' </span><span class="s4">+ </span><span class="s2">date</span><span class="s4">.</span><span class="s2">getUTCSeconds</span><span class="s4">());</span>

  <span class="s6">// ensure 2 digits are used for each format entry</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">format</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">format</span><span class="s4">[</span><span class="s2">i</span><span class="s4">].</span><span class="s2">length </span><span class="s4">&lt; </span><span class="s7">2</span><span class="s4">) {</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">'0'</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s2">rval </span><span class="s4">+= </span><span class="s2">format</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>
  <span class="s4">}</span>
  <span class="s2">rval </span><span class="s4">+= </span><span class="s5">'Z'</span><span class="s4">;</span>

  <span class="s3">return </span><span class="s2">rval</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a date to a GeneralizedTime value.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">date the date to convert.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the GeneralizedTime value as a string.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">dateToGeneralizedTime </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">date</span><span class="s4">) {</span>
  <span class="s6">// TODO: validate; currently assumes proper format</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">date </span><span class="s4">=== </span><span class="s5">'string'</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">date</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s3">var </span><span class="s2">rval </span><span class="s4">= </span><span class="s5">''</span><span class="s4">;</span>

  <span class="s6">// create format YYYYMMDDHHMMSSZ</span>
  <span class="s3">var </span><span class="s2">format </span><span class="s4">= [];</span>
  <span class="s2">format</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s5">'' </span><span class="s4">+ </span><span class="s2">date</span><span class="s4">.</span><span class="s2">getUTCFullYear</span><span class="s4">());</span>
  <span class="s2">format</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s5">'' </span><span class="s4">+ (</span><span class="s2">date</span><span class="s4">.</span><span class="s2">getUTCMonth</span><span class="s4">() + </span><span class="s7">1</span><span class="s4">));</span>
  <span class="s2">format</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s5">'' </span><span class="s4">+ </span><span class="s2">date</span><span class="s4">.</span><span class="s2">getUTCDate</span><span class="s4">());</span>
  <span class="s2">format</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s5">'' </span><span class="s4">+ </span><span class="s2">date</span><span class="s4">.</span><span class="s2">getUTCHours</span><span class="s4">());</span>
  <span class="s2">format</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s5">'' </span><span class="s4">+ </span><span class="s2">date</span><span class="s4">.</span><span class="s2">getUTCMinutes</span><span class="s4">());</span>
  <span class="s2">format</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s5">'' </span><span class="s4">+ </span><span class="s2">date</span><span class="s4">.</span><span class="s2">getUTCSeconds</span><span class="s4">());</span>

  <span class="s6">// ensure 2 digits are used for each format entry</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">format</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">format</span><span class="s4">[</span><span class="s2">i</span><span class="s4">].</span><span class="s2">length </span><span class="s4">&lt; </span><span class="s7">2</span><span class="s4">) {</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">'0'</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s2">rval </span><span class="s4">+= </span><span class="s2">format</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>
  <span class="s4">}</span>
  <span class="s2">rval </span><span class="s4">+= </span><span class="s5">'Z'</span><span class="s4">;</span>

  <span class="s3">return </span><span class="s2">rval</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a javascript integer to a DER-encoded byte buffer to be used</span>
 <span class="s0">* as the value for an INTEGER type.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">x the integer.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the byte buffer.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">integerToDer </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">x</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">rval </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">();</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">x </span><span class="s4">&gt;= -</span><span class="s7">0x80 </span><span class="s4">&amp;&amp; </span><span class="s2">x </span><span class="s4">&lt; </span><span class="s7">0x80</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">rval</span><span class="s4">.</span><span class="s2">putSignedInt</span><span class="s4">(</span><span class="s2">x</span><span class="s4">, </span><span class="s7">8</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">x </span><span class="s4">&gt;= -</span><span class="s7">0x8000 </span><span class="s4">&amp;&amp; </span><span class="s2">x </span><span class="s4">&lt; </span><span class="s7">0x8000</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">rval</span><span class="s4">.</span><span class="s2">putSignedInt</span><span class="s4">(</span><span class="s2">x</span><span class="s4">, </span><span class="s7">16</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">x </span><span class="s4">&gt;= -</span><span class="s7">0x800000 </span><span class="s4">&amp;&amp; </span><span class="s2">x </span><span class="s4">&lt; </span><span class="s7">0x800000</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">rval</span><span class="s4">.</span><span class="s2">putSignedInt</span><span class="s4">(</span><span class="s2">x</span><span class="s4">, </span><span class="s7">24</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">x </span><span class="s4">&gt;= -</span><span class="s7">0x80000000 </span><span class="s4">&amp;&amp; </span><span class="s2">x </span><span class="s4">&lt; </span><span class="s7">0x80000000</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">rval</span><span class="s4">.</span><span class="s2">putSignedInt</span><span class="s4">(</span><span class="s2">x</span><span class="s4">, </span><span class="s7">32</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s3">var </span><span class="s2">error </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Integer too large; max is 32-bits.'</span><span class="s4">);</span>
  <span class="s2">error</span><span class="s4">.</span><span class="s2">integer </span><span class="s4">= </span><span class="s2">x</span><span class="s4">;</span>
  <span class="s3">throw </span><span class="s2">error</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a DER-encoded byte buffer to a javascript integer. This is</span>
 <span class="s0">* typically used to decode the value of an INTEGER type.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">bytes the byte buffer.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the integer.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">derToInteger </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">) {</span>
  <span class="s6">// wrap in buffer if needed</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">bytes </span><span class="s4">=== </span><span class="s5">'string'</span><span class="s4">) {</span>
    <span class="s2">bytes </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s3">var </span><span class="s2">n </span><span class="s4">= </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() * </span><span class="s7">8</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">n </span><span class="s4">&gt; </span><span class="s7">32</span><span class="s4">) {</span>
    <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Integer too large; max is 32-bits.'</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s3">return </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">getSignedInt</span><span class="s4">(</span><span class="s2">n</span><span class="s4">);</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Validates that the given ASN.1 object is at least a super set of the</span>
 <span class="s0">* given ASN.1 structure. Only tag classes and types are checked. An</span>
 <span class="s0">* optional map may also be provided to capture ASN.1 values while the</span>
 <span class="s0">* structure is checked.</span>
 <span class="s0">*</span>
 <span class="s0">* To capture an ASN.1 value, set an object in the validator's 'capture'</span>
 <span class="s0">* parameter to the key to use in the capture map. To capture the full</span>
 <span class="s0">* ASN.1 object, specify 'captureAsn1'. To capture BIT STRING bytes, including</span>
 <span class="s0">* the leading unused bits counter byte, specify 'captureBitStringContents'.</span>
 <span class="s0">* To capture BIT STRING bytes, without the leading unused bits counter byte,</span>
 <span class="s0">* specify 'captureBitStringValue'.</span>
 <span class="s0">*</span>
 <span class="s0">* Objects in the validator may set a field 'optional' to true to indicate</span>
 <span class="s0">* that it isn't necessary to pass validation.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">obj the ASN.1 object to validate.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">v the ASN.1 structure validator.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">capture an optional map to capture values in.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">errors an optional array for storing validation errors.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">true on success, false on failure.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">validate </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">, </span><span class="s2">v</span><span class="s4">, </span><span class="s2">capture</span><span class="s4">, </span><span class="s2">errors</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">rval </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>

  <span class="s6">// ensure tag class and type are the same if specified</span>
  <span class="s3">if</span><span class="s4">((</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">tagClass </span><span class="s4">=== </span><span class="s2">v</span><span class="s4">.</span><span class="s2">tagClass </span><span class="s4">|| </span><span class="s3">typeof</span><span class="s4">(</span><span class="s2">v</span><span class="s4">.</span><span class="s2">tagClass</span><span class="s4">) === </span><span class="s5">'undefined'</span><span class="s4">) &amp;&amp;</span>
    <span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s2">v</span><span class="s4">.</span><span class="s2">type </span><span class="s4">|| </span><span class="s3">typeof</span><span class="s4">(</span><span class="s2">v</span><span class="s4">.</span><span class="s2">type</span><span class="s4">) === </span><span class="s5">'undefined'</span><span class="s4">)) {</span>
    <span class="s6">// ensure constructed flag is the same if specified</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">constructed </span><span class="s4">=== </span><span class="s2">v</span><span class="s4">.</span><span class="s2">constructed </span><span class="s4">||</span>
      <span class="s3">typeof</span><span class="s4">(</span><span class="s2">v</span><span class="s4">.</span><span class="s2">constructed</span><span class="s4">) === </span><span class="s5">'undefined'</span><span class="s4">) {</span>
      <span class="s2">rval </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>

      <span class="s6">// handle sub values</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">v</span><span class="s4">.</span><span class="s2">value </span><span class="s4">&amp;&amp; </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">v</span><span class="s4">.</span><span class="s2">value</span><span class="s4">)) {</span>
        <span class="s3">var </span><span class="s2">j </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
        <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">rval </span><span class="s4">&amp;&amp; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">v</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
          <span class="s2">rval </span><span class="s4">= </span><span class="s2">v</span><span class="s4">.</span><span class="s2">value</span><span class="s4">[</span><span class="s2">i</span><span class="s4">].</span><span class="s2">optional </span><span class="s4">|| </span><span class="s3">false</span><span class="s4">;</span>
          <span class="s3">if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">[</span><span class="s2">j</span><span class="s4">]) {</span>
            <span class="s2">rval </span><span class="s4">= </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">validate</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">[</span><span class="s2">j</span><span class="s4">], </span><span class="s2">v</span><span class="s4">.</span><span class="s2">value</span><span class="s4">[</span><span class="s2">i</span><span class="s4">], </span><span class="s2">capture</span><span class="s4">, </span><span class="s2">errors</span><span class="s4">);</span>
            <span class="s3">if</span><span class="s4">(</span><span class="s2">rval</span><span class="s4">) {</span>
              <span class="s4">++</span><span class="s2">j</span><span class="s4">;</span>
            <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">v</span><span class="s4">.</span><span class="s2">value</span><span class="s4">[</span><span class="s2">i</span><span class="s4">].</span><span class="s2">optional</span><span class="s4">) {</span>
              <span class="s2">rval </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
            <span class="s4">}</span>
          <span class="s4">}</span>
          <span class="s3">if</span><span class="s4">(!</span><span class="s2">rval </span><span class="s4">&amp;&amp; </span><span class="s2">errors</span><span class="s4">) {</span>
            <span class="s2">errors</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span>
              <span class="s5">'[' </span><span class="s4">+ </span><span class="s2">v</span><span class="s4">.</span><span class="s2">name </span><span class="s4">+ </span><span class="s5">'] ' </span><span class="s4">+</span>
              <span class="s5">'Tag class &quot;' </span><span class="s4">+ </span><span class="s2">v</span><span class="s4">.</span><span class="s2">tagClass </span><span class="s4">+ </span><span class="s5">'&quot;, type &quot;' </span><span class="s4">+</span>
              <span class="s2">v</span><span class="s4">.</span><span class="s2">type </span><span class="s4">+ </span><span class="s5">'&quot; expected value length &quot;' </span><span class="s4">+</span>
              <span class="s2">v</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">length </span><span class="s4">+ </span><span class="s5">'&quot;, got &quot;' </span><span class="s4">+</span>
              <span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">length </span><span class="s4">+ </span><span class="s5">'&quot;'</span><span class="s4">);</span>
          <span class="s4">}</span>
        <span class="s4">}</span>
      <span class="s4">}</span>

      <span class="s3">if</span><span class="s4">(</span><span class="s2">rval </span><span class="s4">&amp;&amp; </span><span class="s2">capture</span><span class="s4">) {</span>
        <span class="s3">if</span><span class="s4">(</span><span class="s2">v</span><span class="s4">.</span><span class="s2">capture</span><span class="s4">) {</span>
          <span class="s2">capture</span><span class="s4">[</span><span class="s2">v</span><span class="s4">.</span><span class="s2">capture</span><span class="s4">] = </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">;</span>
        <span class="s4">}</span>
        <span class="s3">if</span><span class="s4">(</span><span class="s2">v</span><span class="s4">.</span><span class="s2">captureAsn1</span><span class="s4">) {</span>
          <span class="s2">capture</span><span class="s4">[</span><span class="s2">v</span><span class="s4">.</span><span class="s2">captureAsn1</span><span class="s4">] = </span><span class="s2">obj</span><span class="s4">;</span>
        <span class="s4">}</span>
        <span class="s3">if</span><span class="s4">(</span><span class="s2">v</span><span class="s4">.</span><span class="s2">captureBitStringContents </span><span class="s4">&amp;&amp; </span><span class="s5">'bitStringContents' </span><span class="s3">in </span><span class="s2">obj</span><span class="s4">) {</span>
          <span class="s2">capture</span><span class="s4">[</span><span class="s2">v</span><span class="s4">.</span><span class="s2">captureBitStringContents</span><span class="s4">] = </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">bitStringContents</span><span class="s4">;</span>
        <span class="s4">}</span>
        <span class="s3">if</span><span class="s4">(</span><span class="s2">v</span><span class="s4">.</span><span class="s2">captureBitStringValue </span><span class="s4">&amp;&amp; </span><span class="s5">'bitStringContents' </span><span class="s3">in </span><span class="s2">obj</span><span class="s4">) {</span>
          <span class="s3">var </span><span class="s2">value</span><span class="s4">;</span>
          <span class="s3">if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">bitStringContents</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&lt; </span><span class="s7">2</span><span class="s4">) {</span>
            <span class="s2">capture</span><span class="s4">[</span><span class="s2">v</span><span class="s4">.</span><span class="s2">captureBitStringValue</span><span class="s4">] = </span><span class="s5">''</span><span class="s4">;</span>
          <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
            <span class="s6">// FIXME: support unused bits with data shifting</span>
            <span class="s3">var </span><span class="s2">unused </span><span class="s4">= </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">bitStringContents</span><span class="s4">.</span><span class="s2">charCodeAt</span><span class="s4">(</span><span class="s7">0</span><span class="s4">);</span>
            <span class="s3">if</span><span class="s4">(</span><span class="s2">unused </span><span class="s4">!== </span><span class="s7">0</span><span class="s4">) {</span>
              <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span>
                <span class="s5">'captureBitStringValue only supported for zero unused bits'</span><span class="s4">);</span>
            <span class="s4">}</span>
            <span class="s2">capture</span><span class="s4">[</span><span class="s2">v</span><span class="s4">.</span><span class="s2">captureBitStringValue</span><span class="s4">] = </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">bitStringContents</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s7">1</span><span class="s4">);</span>
          <span class="s4">}</span>
        <span class="s4">}</span>
      <span class="s4">}</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">errors</span><span class="s4">) {</span>
      <span class="s2">errors</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span>
        <span class="s5">'[' </span><span class="s4">+ </span><span class="s2">v</span><span class="s4">.</span><span class="s2">name </span><span class="s4">+ </span><span class="s5">'] ' </span><span class="s4">+</span>
        <span class="s5">'Expected constructed &quot;' </span><span class="s4">+ </span><span class="s2">v</span><span class="s4">.</span><span class="s2">constructed </span><span class="s4">+ </span><span class="s5">'&quot;, got &quot;' </span><span class="s4">+</span>
        <span class="s2">obj</span><span class="s4">.</span><span class="s2">constructed </span><span class="s4">+ </span><span class="s5">'&quot;'</span><span class="s4">);</span>
    <span class="s4">}</span>
  <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">errors</span><span class="s4">) {</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">tagClass </span><span class="s4">!== </span><span class="s2">v</span><span class="s4">.</span><span class="s2">tagClass</span><span class="s4">) {</span>
      <span class="s2">errors</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span>
        <span class="s5">'[' </span><span class="s4">+ </span><span class="s2">v</span><span class="s4">.</span><span class="s2">name </span><span class="s4">+ </span><span class="s5">'] ' </span><span class="s4">+</span>
        <span class="s5">'Expected tag class &quot;' </span><span class="s4">+ </span><span class="s2">v</span><span class="s4">.</span><span class="s2">tagClass </span><span class="s4">+ </span><span class="s5">'&quot;, got &quot;' </span><span class="s4">+</span>
        <span class="s2">obj</span><span class="s4">.</span><span class="s2">tagClass </span><span class="s4">+ </span><span class="s5">'&quot;'</span><span class="s4">);</span>
    <span class="s4">}</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">type </span><span class="s4">!== </span><span class="s2">v</span><span class="s4">.</span><span class="s2">type</span><span class="s4">) {</span>
      <span class="s2">errors</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span>
        <span class="s5">'[' </span><span class="s4">+ </span><span class="s2">v</span><span class="s4">.</span><span class="s2">name </span><span class="s4">+ </span><span class="s5">'] ' </span><span class="s4">+</span>
        <span class="s5">'Expected type &quot;' </span><span class="s4">+ </span><span class="s2">v</span><span class="s4">.</span><span class="s2">type </span><span class="s4">+ </span><span class="s5">'&quot;, got &quot;' </span><span class="s4">+ </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">type </span><span class="s4">+ </span><span class="s5">'&quot;'</span><span class="s4">);</span>
    <span class="s4">}</span>
  <span class="s4">}</span>
  <span class="s3">return </span><span class="s2">rval</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s6">// regex for testing for non-latin characters</span>
<span class="s3">var </span><span class="s2">_nonLatinRegex </span><span class="s4">= </span><span class="s8">/[^\\u0000-\\u00ff]/</span><span class="s4">;</span>

<span class="s0">/**</span>
 <span class="s0">* Pretty prints an ASN.1 object to a string.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">obj the object to write out.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">level the level in the tree.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">indentation the indentation to use.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the string.</span>
 <span class="s0">*/</span>
<span class="s2">asn1</span><span class="s4">.</span><span class="s2">prettyPrint </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">, </span><span class="s2">level</span><span class="s4">, </span><span class="s2">indentation</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">rval </span><span class="s4">= </span><span class="s5">''</span><span class="s4">;</span>

  <span class="s6">// set default level and indentation</span>
  <span class="s2">level </span><span class="s4">= </span><span class="s2">level </span><span class="s4">|| </span><span class="s7">0</span><span class="s4">;</span>
  <span class="s2">indentation </span><span class="s4">= </span><span class="s2">indentation </span><span class="s4">|| </span><span class="s7">2</span><span class="s4">;</span>

  <span class="s6">// start new line for deep levels</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">level </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s2">rval </span><span class="s4">+= </span><span class="s5">'</span><span class="s3">\n</span><span class="s5">'</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// create indent</span>
  <span class="s3">var </span><span class="s2">indent </span><span class="s4">= </span><span class="s5">''</span><span class="s4">;</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">level </span><span class="s4">* </span><span class="s2">indentation</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s2">indent </span><span class="s4">+= </span><span class="s5">' '</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// print class:type</span>
  <span class="s2">rval </span><span class="s4">+= </span><span class="s2">indent </span><span class="s4">+ </span><span class="s5">'Tag: '</span><span class="s4">;</span>
  <span class="s3">switch</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">tagClass</span><span class="s4">) {</span>
  <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">:</span>
    <span class="s2">rval </span><span class="s4">+= </span><span class="s5">'Universal:'</span><span class="s4">;</span>
    <span class="s3">break</span><span class="s4">;</span>
  <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">APPLICATION</span><span class="s4">:</span>
    <span class="s2">rval </span><span class="s4">+= </span><span class="s5">'Application:'</span><span class="s4">;</span>
    <span class="s3">break</span><span class="s4">;</span>
  <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">CONTEXT_SPECIFIC</span><span class="s4">:</span>
    <span class="s2">rval </span><span class="s4">+= </span><span class="s5">'Context-Specific:'</span><span class="s4">;</span>
    <span class="s3">break</span><span class="s4">;</span>
  <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">PRIVATE</span><span class="s4">:</span>
    <span class="s2">rval </span><span class="s4">+= </span><span class="s5">'Private:'</span><span class="s4">;</span>
    <span class="s3">break</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">tagClass </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">) {</span>
    <span class="s2">rval </span><span class="s4">+= </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">type</span><span class="s4">;</span>

    <span class="s6">// known types</span>
    <span class="s3">switch</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">type</span><span class="s4">) {</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">NONE</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (None)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">BOOLEAN</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (Boolean)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (Integer)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">BITSTRING</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (Bit string)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">OCTETSTRING</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (Octet string)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">NULL</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (Null)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">OID</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (Object Identifier)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">ODESC</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (Object Descriptor)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">EXTERNAL</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (External or Instance of)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">REAL</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (Real)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">ENUMERATED</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (Enumerated)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">EMBEDDED</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (Embedded PDV)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">UTF8</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (UTF8)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">ROID</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (Relative Object Identifier)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (Sequence)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SET</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (Set)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">PRINTABLESTRING</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (Printable String)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">IA5String</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (IA5String (ASCII))'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">UTCTIME</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (UTC time)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">GENERALIZEDTIME</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (Generalized time)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s3">case </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">BMPSTRING</span><span class="s4">:</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (BMP String)'</span><span class="s4">;</span>
      <span class="s3">break</span><span class="s4">;</span>
    <span class="s4">}</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s2">rval </span><span class="s4">+= </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">type</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s2">rval </span><span class="s4">+= </span><span class="s5">'</span><span class="s3">\n</span><span class="s5">'</span><span class="s4">;</span>
  <span class="s2">rval </span><span class="s4">+= </span><span class="s2">indent </span><span class="s4">+ </span><span class="s5">'Constructed: ' </span><span class="s4">+ </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">constructed </span><span class="s4">+ </span><span class="s5">'</span><span class="s3">\n</span><span class="s5">'</span><span class="s4">;</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">composed</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">subvalues </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
    <span class="s3">var </span><span class="s2">sub </span><span class="s4">= </span><span class="s5">''</span><span class="s4">;</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] !== </span><span class="s2">undefined</span><span class="s4">) {</span>
        <span class="s2">subvalues </span><span class="s4">+= </span><span class="s7">1</span><span class="s4">;</span>
        <span class="s2">sub </span><span class="s4">+= </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">prettyPrint</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">[</span><span class="s2">i</span><span class="s4">], </span><span class="s2">level </span><span class="s4">+ </span><span class="s7">1</span><span class="s4">, </span><span class="s2">indentation</span><span class="s4">);</span>
        <span class="s3">if</span><span class="s4">((</span><span class="s2">i </span><span class="s4">+ </span><span class="s7">1</span><span class="s4">) &lt; </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">length</span><span class="s4">) {</span>
          <span class="s2">sub </span><span class="s4">+= </span><span class="s5">','</span><span class="s4">;</span>
        <span class="s4">}</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
    <span class="s2">rval </span><span class="s4">+= </span><span class="s2">indent </span><span class="s4">+ </span><span class="s5">'Sub values: ' </span><span class="s4">+ </span><span class="s2">subvalues </span><span class="s4">+ </span><span class="s2">sub</span><span class="s4">;</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s2">rval </span><span class="s4">+= </span><span class="s2">indent </span><span class="s4">+ </span><span class="s5">'Value: '</span><span class="s4">;</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">OID</span><span class="s4">) {</span>
      <span class="s3">var </span><span class="s2">oid </span><span class="s4">= </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">derToOid</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">);</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s2">oid</span><span class="s4">;</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">pki </span><span class="s4">&amp;&amp; </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">pki</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">) {</span>
        <span class="s3">if</span><span class="s4">(</span><span class="s2">oid </span><span class="s3">in </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">pki</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">) {</span>
          <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (' </span><span class="s4">+ </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">pki</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">[</span><span class="s2">oid</span><span class="s4">] + </span><span class="s5">') '</span><span class="s4">;</span>
        <span class="s4">}</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">) {</span>
      <span class="s3">try </span><span class="s4">{</span>
        <span class="s2">rval </span><span class="s4">+= </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">derToInteger</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">);</span>
      <span class="s4">} </span><span class="s3">catch</span><span class="s4">(</span><span class="s2">ex</span><span class="s4">) {</span>
        <span class="s2">rval </span><span class="s4">+= </span><span class="s5">'0x' </span><span class="s4">+ </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">bytesToHex</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">);</span>
      <span class="s4">}</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">BITSTRING</span><span class="s4">) {</span>
      <span class="s6">// TODO: shift bits as needed to display without padding</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s7">1</span><span class="s4">) {</span>
        <span class="s6">// remove unused bits field</span>
        <span class="s2">rval </span><span class="s4">+= </span><span class="s5">'0x' </span><span class="s4">+ </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">bytesToHex</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s7">1</span><span class="s4">));</span>
      <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
        <span class="s2">rval </span><span class="s4">+= </span><span class="s5">'(none)'</span><span class="s4">;</span>
      <span class="s4">}</span>
      <span class="s6">// show unused bit count</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
        <span class="s3">var </span><span class="s2">unused </span><span class="s4">= </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">charCodeAt</span><span class="s4">(</span><span class="s7">0</span><span class="s4">);</span>
        <span class="s3">if</span><span class="s4">(</span><span class="s2">unused </span><span class="s4">== </span><span class="s7">1</span><span class="s4">) {</span>
          <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (1 unused bit shown)'</span><span class="s4">;</span>
        <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">unused </span><span class="s4">&gt; </span><span class="s7">1</span><span class="s4">) {</span>
          <span class="s2">rval </span><span class="s4">+= </span><span class="s5">' (' </span><span class="s4">+ </span><span class="s2">unused </span><span class="s4">+ </span><span class="s5">' unused bits shown)'</span><span class="s4">;</span>
        <span class="s4">}</span>
      <span class="s4">}</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">OCTETSTRING</span><span class="s4">) {</span>
      <span class="s3">if</span><span class="s4">(!</span><span class="s2">_nonLatinRegex</span><span class="s4">.</span><span class="s2">test</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">)) {</span>
        <span class="s2">rval </span><span class="s4">+= </span><span class="s5">'(' </span><span class="s4">+ </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value </span><span class="s4">+ </span><span class="s5">') '</span><span class="s4">;</span>
      <span class="s4">}</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">'0x' </span><span class="s4">+ </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">bytesToHex</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">);</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">UTF8</span><span class="s4">) {</span>
      <span class="s3">try </span><span class="s4">{</span>
        <span class="s2">rval </span><span class="s4">+= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">decodeUtf8</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">);</span>
      <span class="s4">} </span><span class="s3">catch</span><span class="s4">(</span><span class="s2">e</span><span class="s4">) {</span>
        <span class="s3">if</span><span class="s4">(</span><span class="s2">e</span><span class="s4">.</span><span class="s2">message </span><span class="s4">=== </span><span class="s5">'URI malformed'</span><span class="s4">) {</span>
          <span class="s2">rval </span><span class="s4">+=</span>
            <span class="s5">'0x' </span><span class="s4">+ </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">bytesToHex</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">) + </span><span class="s5">' (malformed UTF8)'</span><span class="s4">;</span>
        <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
          <span class="s3">throw </span><span class="s2">e</span><span class="s4">;</span>
        <span class="s4">}</span>
      <span class="s4">}</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">PRINTABLESTRING </span><span class="s4">||</span>
      <span class="s2">obj</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">IA5String</span><span class="s4">) {</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">;</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">_nonLatinRegex</span><span class="s4">.</span><span class="s2">test</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">)) {</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">'0x' </span><span class="s4">+ </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">bytesToHex</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">);</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s5">'[null]'</span><span class="s4">;</span>
    <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
      <span class="s2">rval </span><span class="s4">+= </span><span class="s2">obj</span><span class="s4">.</span><span class="s2">value</span><span class="s4">;</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s3">return </span><span class="s2">rval</span><span class="s4">;</span>
<span class="s4">};</span>
</pre>
</body>
</html>