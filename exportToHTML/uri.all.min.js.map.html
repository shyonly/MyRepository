<html>
<head>
<title>uri.all.min.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
uri.all.min.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/util.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/regexps-uri.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../node_modules/punycode/punycode.es6.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/uri.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/schemes/ws.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/schemes/mailto.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/regexps-iri.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/schemes/http.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/schemes/https.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/schemes/wss.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/schemes/urn.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/schemes/urn-uuid.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../../src/index.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;merge&quot;</span><span class="s0">,</span><span class="s1">&quot;sets&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;_len&quot;</span><span class="s0">,</span><span class="s1">&quot;_key&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;xl&quot;</span><span class="s0">,</span><span class="s1">&quot;x&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;subexp&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;typeOf&quot;</span><span class="s0">,</span><span class="s1">&quot;o&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;shift&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;toUpperCase&quot;</span><span class="s0">,</span><span class="s1">&quot;toArray&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;setInterval&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;buildExps&quot;</span><span class="s0">,</span><span class="s1">&quot;isIRI&quot;</span><span class="s0">,</span><span class="s1">&quot;HEXDIG$$&quot;</span><span class="s0">,</span><span class="s1">&quot;PCT_ENCODED$&quot;</span><span class="s0">,</span><span class="s1">&quot;SUB_DELIMS$$&quot;</span><span class="s0">,</span><span class="s1">&quot;RESERVED$$&quot;</span><span class="s0">,</span><span class="s1">&quot;UCSCHAR$$&quot;</span><span class="s0">,</span><span class="s1">&quot;DEC_OCTET_RELAXED$&quot;</span><span class="s0">,</span><span class="s1">&quot;H16$&quot;</span><span class="s0">,</span><span class="s1">&quot;LS32$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV4ADDRESS$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS1$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS2$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS3$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS4$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS5$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS6$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS7$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS8$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS9$&quot;</span><span class="s0">,</span><span class="s1">&quot;ZONEID$&quot;</span><span class="s0">,</span><span class="s1">&quot;UNRESERVED$$&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;IPRIVATE$$&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS$&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;RangeError&quot;</span><span class="s0">,</span><span class="s1">&quot;errors&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;array&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;mapDomain&quot;</span><span class="s0">,</span><span class="s1">&quot;string&quot;</span><span class="s0">,</span><span class="s1">&quot;parts&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;regexSeparators&quot;</span><span class="s0">,</span><span class="s1">&quot;ucs2decode&quot;</span><span class="s0">,</span><span class="s1">&quot;output&quot;</span><span class="s0">,</span><span class="s1">&quot;counter&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;extra&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;pctEncChar&quot;</span><span class="s0">,</span><span class="s1">&quot;chr&quot;</span><span class="s0">,</span><span class="s1">&quot;c&quot;</span><span class="s0">,</span><span class="s1">&quot;pctDecChars&quot;</span><span class="s0">,</span><span class="s1">&quot;newStr&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;il&quot;</span><span class="s0">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s0">,</span><span class="s1">&quot;substr&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;fromCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;c2&quot;</span><span class="s0">,</span><span class="s1">&quot;c3&quot;</span><span class="s0">,</span><span class="s1">&quot;_normalizeComponentEncoding&quot;</span><span class="s0">,</span><span class="s1">&quot;components&quot;</span><span class="s0">,</span><span class="s1">&quot;protocol&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeUnreserved&quot;</span><span class="s0">,</span><span class="s1">&quot;decStr&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;UNRESERVED&quot;</span><span class="s0">,</span><span class="s1">&quot;scheme&quot;</span><span class="s0">,</span><span class="s1">&quot;PCT_ENCODED&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_SCHEME&quot;</span><span class="s0">,</span><span class="s1">&quot;userinfo&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_USERINFO&quot;</span><span class="s0">,</span><span class="s1">&quot;host&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_HOST&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_PATH&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_PATH_NOSCHEME&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_QUERY&quot;</span><span class="s0">,</span><span class="s1">&quot;fragment&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_FRAGMENT&quot;</span><span class="s0">,</span><span class="s1">&quot;_stripLeadingZeros&quot;</span><span class="s0">,</span><span class="s1">&quot;_normalizeIPv4&quot;</span><span class="s0">,</span><span class="s1">&quot;matches&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV4ADDRESS&quot;</span><span class="s0">,</span><span class="s1">&quot;address&quot;</span><span class="s0">,</span><span class="s1">&quot;_matches&quot;</span><span class="s0">,</span><span class="s1">&quot;_normalizeIPv6&quot;</span><span class="s0">,</span><span class="s1">&quot;IPV6ADDRESS&quot;</span><span class="s0">,</span><span class="s1">&quot;_matches2&quot;</span><span class="s0">,</span><span class="s1">&quot;zone&quot;</span><span class="s0">,</span><span class="s1">&quot;reverse&quot;</span><span class="s0">,</span><span class="s1">&quot;last&quot;</span><span class="s0">,</span><span class="s1">&quot;_address$toLowerCase$2&quot;</span><span class="s0">,</span><span class="s1">&quot;first&quot;</span><span class="s0">,</span><span class="s1">&quot;firstFields&quot;</span><span class="s0">,</span><span class="s1">&quot;lastFields&quot;</span><span class="s0">,</span><span class="s1">&quot;isLastFieldIPv4Address&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;fieldCount&quot;</span><span class="s0">,</span><span class="s1">&quot;lastFieldsStart&quot;</span><span class="s0">,</span><span class="s1">&quot;fields&quot;</span><span class="s0">,</span><span class="s1">&quot;allZeroFields&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;acc&quot;</span><span class="s0">,</span><span class="s1">&quot;field&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;lastLongest&quot;</span><span class="s0">,</span><span class="s1">&quot;longestZeroFields&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;newHost&quot;</span><span class="s0">,</span><span class="s1">&quot;newFirst&quot;</span><span class="s0">,</span><span class="s1">&quot;newLast&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;uriString&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;iri&quot;</span><span class="s0">,</span><span class="s1">&quot;IRI_PROTOCOL&quot;</span><span class="s0">,</span><span class="s1">&quot;URI_PROTOCOL&quot;</span><span class="s0">,</span><span class="s1">&quot;reference&quot;</span><span class="s0">,</span><span class="s1">&quot;URI_PARSE&quot;</span><span class="s0">,</span><span class="s1">&quot;NO_MATCH_IS_UNDEFINED&quot;</span><span class="s0">,</span><span class="s1">&quot;port&quot;</span><span class="s0">,</span><span class="s1">&quot;isNaN&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;schemeHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;SCHEMES&quot;</span><span class="s0">,</span><span class="s1">&quot;unicodeSupport&quot;</span><span class="s0">,</span><span class="s1">&quot;domainHost&quot;</span><span class="s0">,</span><span class="s1">&quot;punycode&quot;</span><span class="s0">,</span><span class="s1">&quot;toASCII&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;_recomposeAuthority&quot;</span><span class="s0">,</span><span class="s1">&quot;uriTokens&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;$1&quot;</span><span class="s0">,</span><span class="s1">&quot;$2&quot;</span><span class="s0">,</span><span class="s1">&quot;removeDotSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;input&quot;</span><span class="s0">,</span><span class="s1">&quot;RDS1&quot;</span><span class="s0">,</span><span class="s1">&quot;RDS2&quot;</span><span class="s0">,</span><span class="s1">&quot;RDS3&quot;</span><span class="s0">,</span><span class="s1">&quot;im&quot;</span><span class="s0">,</span><span class="s1">&quot;RDS5&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;s&quot;</span><span class="s0">,</span><span class="s1">&quot;serialize&quot;</span><span class="s0">,</span><span class="s1">&quot;toUnicode&quot;</span><span class="s0">,</span><span class="s1">&quot;authority&quot;</span><span class="s0">,</span><span class="s1">&quot;charAt&quot;</span><span class="s0">,</span><span class="s1">&quot;absolutePath&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;base&quot;</span><span class="s0">,</span><span class="s1">&quot;relative&quot;</span><span class="s0">,</span><span class="s1">&quot;skipNormalization&quot;</span><span class="s0">,</span><span class="s1">&quot;tolerant&quot;</span><span class="s0">,</span><span class="s1">&quot;lastIndexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;baseURI&quot;</span><span class="s0">,</span><span class="s1">&quot;relativeURI&quot;</span><span class="s0">,</span><span class="s1">&quot;schemelessOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;normalize&quot;</span><span class="s0">,</span><span class="s1">&quot;uri&quot;</span><span class="s0">,</span><span class="s1">&quot;equal&quot;</span><span class="s0">,</span><span class="s1">&quot;uriA&quot;</span><span class="s0">,</span><span class="s1">&quot;uriB&quot;</span><span class="s0">,</span><span class="s1">&quot;escapeComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;ESCAPE&quot;</span><span class="s0">,</span><span class="s1">&quot;unescapeComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;isSecure&quot;</span><span class="s0">,</span><span class="s1">&quot;wsComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;secure&quot;</span><span class="s0">,</span><span class="s1">&quot;maxInt&quot;</span><span class="s0">,</span><span class="s1">&quot;regexPunycode&quot;</span><span class="s0">,</span><span class="s1">&quot;regexNonASCII&quot;</span><span class="s0">,</span><span class="s1">&quot;floor&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;stringFromCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;ucs2encode&quot;</span><span class="s0">,</span><span class="s1">&quot;fromCodePoint&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;toConsumableArray&quot;</span><span class="s0">,</span><span class="s1">&quot;basicToDigit&quot;</span><span class="s0">,</span><span class="s1">&quot;codePoint&quot;</span><span class="s0">,</span><span class="s1">&quot;digitToBasic&quot;</span><span class="s0">,</span><span class="s1">&quot;digit&quot;</span><span class="s0">,</span><span class="s1">&quot;flag&quot;</span><span class="s0">,</span><span class="s1">&quot;adapt&quot;</span><span class="s0">,</span><span class="s1">&quot;delta&quot;</span><span class="s0">,</span><span class="s1">&quot;numPoints&quot;</span><span class="s0">,</span><span class="s1">&quot;firstTime&quot;</span><span class="s0">,</span><span class="s1">&quot;k&quot;</span><span class="s0">,</span><span class="s1">&quot;baseMinusTMin&quot;</span><span class="s0">,</span><span class="s1">&quot;decode&quot;</span><span class="s0">,</span><span class="s1">&quot;inputLength&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;bias&quot;</span><span class="s0">,</span><span class="s1">&quot;basic&quot;</span><span class="s0">,</span><span class="s1">&quot;j&quot;</span><span class="s0">,</span><span class="s1">&quot;oldi&quot;</span><span class="s0">,</span><span class="s1">&quot;w&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;baseMinusT&quot;</span><span class="s0">,</span><span class="s1">&quot;out&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;encode&quot;</span><span class="s0">,</span><span class="s1">&quot;_step&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;_iteratorNormalCompletion&quot;</span><span class="s0">,</span><span class="s1">&quot;_iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;currentValue&quot;</span><span class="s0">,</span><span class="s1">&quot;basicLength&quot;</span><span class="s0">,</span><span class="s1">&quot;handledCPCount&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;_step2&quot;</span><span class="s0">,</span><span class="s1">&quot;_iteratorNormalCompletion2&quot;</span><span class="s0">,</span><span class="s1">&quot;_iterator2&quot;</span><span class="s0">,</span><span class="s1">&quot;handledCPCountPlusOne&quot;</span><span class="s0">,</span><span class="s1">&quot;_step3&quot;</span><span class="s0">,</span><span class="s1">&quot;_iteratorNormalCompletion3&quot;</span><span class="s0">,</span><span class="s1">&quot;_iterator3&quot;</span><span class="s0">,</span><span class="s1">&quot;q&quot;</span><span class="s0">,</span><span class="s1">&quot;qMinusT&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;http&quot;</span><span class="s0">,</span><span class="s1">&quot;resourceName&quot;</span><span class="s0">,</span><span class="s1">&quot;_wsComponents$resourc2&quot;</span><span class="s0">,</span><span class="s1">&quot;ws&quot;</span><span class="s0">,</span><span class="s1">&quot;O&quot;</span><span class="s0">,</span><span class="s1">&quot;VCHAR$$&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_LOCAL_PART&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_HFNAME&quot;</span><span class="s0">,</span><span class="s1">&quot;NOT_HFVALUE&quot;</span><span class="s0">,</span><span class="s1">&quot;mailtoComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;to&quot;</span><span class="s0">,</span><span class="s1">&quot;unknownHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;hfields&quot;</span><span class="s0">,</span><span class="s1">&quot;hfield&quot;</span><span class="s0">,</span><span class="s1">&quot;toAddrs&quot;</span><span class="s0">,</span><span class="s1">&quot;subject&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;addr&quot;</span><span class="s0">,</span><span class="s1">&quot;toAddr&quot;</span><span class="s0">,</span><span class="s1">&quot;atIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;localPart&quot;</span><span class="s0">,</span><span class="s1">&quot;domain&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;URN_PARSE&quot;</span><span class="s0">,</span><span class="s1">&quot;urnComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;nid&quot;</span><span class="s0">,</span><span class="s1">&quot;nss&quot;</span><span class="s0">,</span><span class="s1">&quot;urnScheme&quot;</span><span class="s0">,</span><span class="s1">&quot;uriComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;UUID&quot;</span><span class="s0">,</span><span class="s1">&quot;uuidComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;uuid&quot;</span><span class="s0">,</span><span class="s1">&quot;https&quot;</span><span class="s0">,</span><span class="s1">&quot;wss&quot;</span><span class="s0">,</span><span class="s1">&quot;mailto&quot;</span><span class="s0">,</span><span class="s1">&quot;urn&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;dist/es5/uri.all.min.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export function merge(...sets:Array&lt;string&gt;):string {</span><span class="s3">\n\t</span><span class="s1">if (sets.length &gt; 1) {</span><span class="s3">\n\t\t</span><span class="s1">sets[0] = sets[0].slice(0, -1);</span><span class="s3">\n\t\t</span><span class="s1">const xl = sets.length - 1;</span><span class="s3">\n\t\t</span><span class="s1">for (let x = 1; x &lt; xl; ++x) {</span><span class="s3">\n\t\t\t</span><span class="s1">sets[x] = sets[x].slice(1, -1);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">sets[xl] = sets[xl].slice(1);</span><span class="s3">\n\t\t</span><span class="s1">return sets.join('');</span><span class="s3">\n\t</span><span class="s1">} else {</span><span class="s3">\n\t\t</span><span class="s1">return sets[0];</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function subexp(str:string):string {</span><span class="s3">\n\t</span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot; </span><span class="s1">+ str + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function typeOf(o:any):string {</span><span class="s3">\n\t</span><span class="s1">return o === undefined ? </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">: (o === null ? </span><span class="s3">\&quot;</span><span class="s1">null</span><span class="s3">\&quot; </span><span class="s1">: Object.prototype.toString.call(o).split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">).pop().split(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">).shift().toLowerCase());</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function toUpperCase(str:string):string {</span><span class="s3">\n\t</span><span class="s1">return str.toUpperCase();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function toArray(obj:any):Array&lt;any&gt; {</span><span class="s3">\n\t</span><span class="s1">return obj !== undefined &amp;&amp; obj !== null ? (obj instanceof Array ? obj : (typeof obj.length !== </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj))) : [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n\n</span><span class="s1">export function assign(target: object, source: any): any {</span><span class="s3">\n\t</span><span class="s1">const obj = target as any;</span><span class="s3">\n\t</span><span class="s1">if (source) {</span><span class="s3">\n\t\t</span><span class="s1">for (const key in source) {</span><span class="s3">\n\t\t\t</span><span class="s1">obj[key] = source[key];</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return obj;</span><span class="s3">\n</span><span class="s1">}&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URIRegExps } from </span><span class="s3">\&quot;</span><span class="s1">./uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { merge, subexp } from </span><span class="s3">\&quot;</span><span class="s1">./util</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export function buildExps(isIRI:boolean):URIRegExps {</span><span class="s3">\n\t</span><span class="s1">const</span><span class="s3">\n\t\t</span><span class="s1">ALPHA$$ = </span><span class="s3">\&quot;</span><span class="s1">[A-Za-z]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">CR$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x0D]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">DIGIT$$ = </span><span class="s3">\&quot;</span><span class="s1">[0-9]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">DQUOTE$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x22]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">HEXDIG$$ = merge(DIGIT$$, </span><span class="s3">\&quot;</span><span class="s1">[A-Fa-f]</span><span class="s3">\&quot;</span><span class="s1">),  //case-insensitive</span><span class="s3">\n\t\t</span><span class="s1">LF$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x0A]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">SP$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x20]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">PCT_ENCODED$ = subexp(subexp(</span><span class="s3">\&quot;</span><span class="s1">%[EFef]</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">%[89A-Fa-f]</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$)),  //expanded</span><span class="s3">\n\t\t</span><span class="s1">GEN_DELIMS$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">#</span><span class="s3">\\\\</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">@]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">SUB_DELIMS$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">!</span><span class="s3">\\\\</span><span class="s1">$</span><span class="s3">\\\\</span><span class="s1">&amp;</span><span class="s3">\\\\</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">)</span><span class="s3">\\\\</span><span class="s1">*</span><span class="s3">\\\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">,</span><span class="s3">\\\\</span><span class="s1">;</span><span class="s3">\\\\</span><span class="s1">=]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),</span><span class="s3">\n\t\t</span><span class="s1">UCSCHAR$$ = isIRI ? </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">xA0-</span><span class="s3">\\\\</span><span class="s1">u200D</span><span class="s3">\\\\</span><span class="s1">u2010-</span><span class="s3">\\\\</span><span class="s1">u2029</span><span class="s3">\\\\</span><span class="s1">u202F-</span><span class="s3">\\\\</span><span class="s1">uD7FF</span><span class="s3">\\\\</span><span class="s1">uF900-</span><span class="s3">\\\\</span><span class="s1">uFDCF</span><span class="s3">\\\\</span><span class="s1">uFDF0-</span><span class="s3">\\\\</span><span class="s1">uFFEF]</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">[]</span><span class="s3">\&quot;</span><span class="s1">,  //subset, excludes bidi control characters</span><span class="s3">\n\t\t</span><span class="s1">IPRIVATE$$ = isIRI ? </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">uE000-</span><span class="s3">\\\\</span><span class="s1">uF8FF]</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">[]</span><span class="s3">\&quot;</span><span class="s1">,  //subset</span><span class="s3">\n\t\t</span><span class="s1">UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">-</span><span class="s3">\\\\</span><span class="s1">.</span><span class="s3">\\\\</span><span class="s1">_</span><span class="s3">\\\\</span><span class="s1">~]</span><span class="s3">\&quot;</span><span class="s1">, UCSCHAR$$),</span><span class="s3">\n\t\t</span><span class="s1">SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">-</span><span class="s3">\\\\</span><span class="s1">.]</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">USERINFO$ = subexp(subexp(PCT_ENCODED$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ merge(UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">:]</span><span class="s3">\&quot;</span><span class="s1">)) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">DEC_OCTET$ = subexp(subexp(</span><span class="s3">\&quot;</span><span class="s1">25[0-5]</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">2[0-4]</span><span class="s3">\&quot; </span><span class="s1">+ DIGIT$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">1</span><span class="s3">\&quot; </span><span class="s1">+ DIGIT$$ + DIGIT$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">[1-9]</span><span class="s3">\&quot; </span><span class="s1">+ DIGIT$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ DIGIT$$),</span><span class="s3">\n\t\t</span><span class="s1">DEC_OCTET_RELAXED$ = subexp(subexp(</span><span class="s3">\&quot;</span><span class="s1">25[0-5]</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">2[0-4]</span><span class="s3">\&quot; </span><span class="s1">+ DIGIT$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">1</span><span class="s3">\&quot; </span><span class="s1">+ DIGIT$$ + DIGIT$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">0?[1-9]</span><span class="s3">\&quot; </span><span class="s1">+ DIGIT$$) + </span><span class="s3">\&quot;</span><span class="s1">|0?0?</span><span class="s3">\&quot; </span><span class="s1">+ DIGIT$$),  //relaxed parsing rules</span><span class="s3">\n\t\t</span><span class="s1">IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">+ DEC_OCTET_RELAXED$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">+ DEC_OCTET_RELAXED$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">+ DEC_OCTET_RELAXED$),</span><span class="s3">\n\t\t</span><span class="s1">H16$ = subexp(HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">{1,4}</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">LS32$ = subexp(subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ H16$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ IPV4ADDRESS$),</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS1$ = subexp(                                                            subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{6}</span><span class="s3">\&quot; </span><span class="s1">+ LS32$), //                           6( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) ls32</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS2$ = subexp(                                                 </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{5}</span><span class="s3">\&quot; </span><span class="s1">+ LS32$), //                      </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot; </span><span class="s1">5( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) ls32</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS3$ = subexp(subexp(                                 H16$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{4}</span><span class="s3">\&quot; </span><span class="s1">+ LS32$), //[               h16 ] </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot; </span><span class="s1">4( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) ls32</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{0,1}</span><span class="s3">\&quot; </span><span class="s1">+ H16$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{3}</span><span class="s3">\&quot; </span><span class="s1">+ LS32$), //[ *1( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) h16 ] </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot; </span><span class="s1">3( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) ls32</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{0,2}</span><span class="s3">\&quot; </span><span class="s1">+ H16$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{2}</span><span class="s3">\&quot; </span><span class="s1">+ LS32$), //[ *2( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) h16 ] </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot; </span><span class="s1">2( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) ls32</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{0,3}</span><span class="s3">\&quot; </span><span class="s1">+ H16$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+        H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;          </span><span class="s1">+ LS32$), //[ *3( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) h16 ] </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot;    </span><span class="s1">h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;   </span><span class="s1">ls32</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{0,4}</span><span class="s3">\&quot; </span><span class="s1">+ H16$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot;                                </span><span class="s1">+ LS32$), //[ *4( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) h16 ] </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot;              </span><span class="s1">ls32</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{0,5}</span><span class="s3">\&quot; </span><span class="s1">+ H16$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot;                                </span><span class="s1">+ H16$ ), //[ *5( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) h16 ] </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot;              </span><span class="s1">h16</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">{0,6}</span><span class="s3">\&quot; </span><span class="s1">+ H16$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot;                                       </span><span class="s1">), //[ *6( h16 </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">) h16 ] </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot;\n\t\t</span><span class="s1">IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n\t\t</span><span class="s1">ZONEID$ = subexp(subexp(UNRESERVED$$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PCT_ENCODED$) + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">),  //RFC 6874</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">%25</span><span class="s3">\&quot; </span><span class="s1">+ ZONEID$),  //RFC 6874</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">%25|</span><span class="s3">\\\\</span><span class="s1">%(?!</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">{2})</span><span class="s3">\&quot;</span><span class="s1">) + ZONEID$),  //RFC 6874, with relaxed parsing rules</span><span class="s3">\n\t\t</span><span class="s1">IPVFUTURE$ = subexp(</span><span class="s3">\&quot;</span><span class="s1">[vV]</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">+ merge(UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">:]</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">IP_LITERAL$ = subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">[</span><span class="s3">\&quot; </span><span class="s1">+ subexp(IPV6ADDRZ_RELAXED$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ IPV6ADDRESS$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ IPVFUTURE$) + </span><span class="s3">\&quot;\\\\</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">),  //RFC 6874</span><span class="s3">\n\t\t</span><span class="s1">REG_NAME$ = subexp(subexp(PCT_ENCODED$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ merge(UNRESERVED$$, SUB_DELIMS$$)) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">HOST$ = subexp(IP_LITERAL$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ IPV4ADDRESS$ + </span><span class="s3">\&quot;</span><span class="s1">(?!</span><span class="s3">\&quot; </span><span class="s1">+ REG_NAME$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">+ </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ REG_NAME$),</span><span class="s3">\n\t\t</span><span class="s1">PORT$ = subexp(DIGIT$$ + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">AUTHORITY$ = subexp(subexp(USERINFO$ + </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ HOST$ + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ PORT$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">PCHAR$ = subexp(PCT_ENCODED$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ merge(UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">@]</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n\t\t</span><span class="s1">SEGMENT$ = subexp(PCHAR$ + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">SEGMENT_NZ$ = subexp(PCHAR$ + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ merge(UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">@]</span><span class="s3">\&quot;</span><span class="s1">)) + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">PATH_ABEMPTY$ = subexp(subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ SEGMENT$) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">PATH_ABSOLUTE$ = subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">),  //simplified</span><span class="s3">\n\t\t</span><span class="s1">PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),  //simplified</span><span class="s3">\n\t\t</span><span class="s1">PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),  //simplified</span><span class="s3">\n\t\t</span><span class="s1">PATH_EMPTY$ = </span><span class="s3">\&quot;</span><span class="s1">(?!</span><span class="s3">\&quot; </span><span class="s1">+ PCHAR$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">PATH$ = subexp(PATH_ABEMPTY$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_NOSCHEME$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ROOTLESS$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_EMPTY$),</span><span class="s3">\n\t\t</span><span class="s1">QUERY$ = subexp(subexp(PCHAR$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ merge(</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">?]</span><span class="s3">\&quot;</span><span class="s1">, IPRIVATE$$)) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">FRAGMENT$ = subexp(subexp(PCHAR$ + </span><span class="s3">\&quot;</span><span class="s1">|[</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">?]</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">HIER_PART$ = subexp(subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ AUTHORITY$ + PATH_ABEMPTY$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ROOTLESS$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_EMPTY$),</span><span class="s3">\n\t\t</span><span class="s1">URI$ = subexp(SCHEME$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ HIER_PART$ + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ QUERY$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">#</span><span class="s3">\&quot; </span><span class="s1">+ FRAGMENT$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">RELATIVE_PART$ = subexp(subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ AUTHORITY$ + PATH_ABEMPTY$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_NOSCHEME$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_EMPTY$),</span><span class="s3">\n\t\t</span><span class="s1">RELATIVE$ = subexp(RELATIVE_PART$ + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ QUERY$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">#</span><span class="s3">\&quot; </span><span class="s1">+ FRAGMENT$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">URI_REFERENCE$ = subexp(URI$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ RELATIVE$),</span><span class="s3">\n\t\t</span><span class="s1">ABSOLUTE_URI$ = subexp(SCHEME$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ HIER_PART$ + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ QUERY$) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\n\t\t</span><span class="s1">GENERIC_REF$ = </span><span class="s3">\&quot;</span><span class="s1">^(</span><span class="s3">\&quot; </span><span class="s1">+ SCHEME$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ subexp(subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">/(</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot; </span><span class="s1">+ USERINFO$ + </span><span class="s3">\&quot;</span><span class="s1">)@</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ HOST$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">:(</span><span class="s3">\&quot; </span><span class="s1">+ PORT$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABEMPTY$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ROOTLESS$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_EMPTY$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ QUERY$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">#(</span><span class="s3">\&quot; </span><span class="s1">+ FRAGMENT$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?$</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">RELATIVE_REF$ = </span><span class="s3">\&quot;</span><span class="s1">^(){0}</span><span class="s3">\&quot; </span><span class="s1">+ subexp(subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">/(</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot; </span><span class="s1">+ USERINFO$ + </span><span class="s3">\&quot;</span><span class="s1">)@</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ HOST$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">:(</span><span class="s3">\&quot; </span><span class="s1">+ PORT$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABEMPTY$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_NOSCHEME$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_EMPTY$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ QUERY$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">#(</span><span class="s3">\&quot; </span><span class="s1">+ FRAGMENT$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?$</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">ABSOLUTE_REF$ = </span><span class="s3">\&quot;</span><span class="s1">^(</span><span class="s3">\&quot; </span><span class="s1">+ SCHEME$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ subexp(subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">/(</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot; </span><span class="s1">+ USERINFO$ + </span><span class="s3">\&quot;</span><span class="s1">)@</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ HOST$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">:(</span><span class="s3">\&quot; </span><span class="s1">+ PORT$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABEMPTY$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_ROOTLESS$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PATH_EMPTY$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ QUERY$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?$</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">SAMEDOC_REF$ = </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">#(</span><span class="s3">\&quot; </span><span class="s1">+ FRAGMENT$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?$</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t\t</span><span class="s1">AUTHORITY_REF$ = </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot; </span><span class="s1">+ USERINFO$ + </span><span class="s3">\&quot;</span><span class="s1">)@</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?(</span><span class="s3">\&quot; </span><span class="s1">+ HOST$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">:(</span><span class="s3">\&quot; </span><span class="s1">+ PORT$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?$</span><span class="s3">\&quot;\n\t</span><span class="s1">;</span><span class="s3">\n\n\t</span><span class="s1">return {</span><span class="s3">\n\t\t</span><span class="s1">NOT_SCHEME : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^]</span><span class="s3">\&quot;</span><span class="s1">, ALPHA$$, DIGIT$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">-</span><span class="s3">\\\\</span><span class="s1">.]</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">NOT_USERINFO : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\\\\</span><span class="s1">%</span><span class="s3">\\\\</span><span class="s1">:]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">NOT_HOST : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\\\\</span><span class="s1">%</span><span class="s3">\\\\</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">:]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">NOT_PATH : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\\\\</span><span class="s1">%</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">@]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">NOT_PATH_NOSCHEME : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\\\\</span><span class="s1">%</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">@]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">NOT_QUERY : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\\\\</span><span class="s1">%]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">@</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">?]</span><span class="s3">\&quot;</span><span class="s1">, IPRIVATE$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">NOT_FRAGMENT : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\\\\</span><span class="s1">%]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">@</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">?]</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">ESCAPE : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">UNRESERVED : new RegExp(UNRESERVED$$, </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">OTHER_CHARS : new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\\\\</span><span class="s1">%]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, RESERVED$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">PCT_ENCODED : new RegExp(PCT_ENCODED$, </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">IPV4ADDRESS : new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^(</span><span class="s3">\&quot; </span><span class="s1">+ IPV4ADDRESS$ + </span><span class="s3">\&quot;</span><span class="s1">)$</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n\t\t</span><span class="s1">IPV6ADDRESS : new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\\\\</span><span class="s1">[?(</span><span class="s3">\&quot; </span><span class="s1">+ IPV6ADDRESS$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">+ subexp(subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">%25|</span><span class="s3">\\\\</span><span class="s1">%(?!</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">{2})</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot; </span><span class="s1">+ ZONEID$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">]?$</span><span class="s3">\&quot;</span><span class="s1">)  //RFC 6874, with relaxed parsing rules</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default buildExps(false);</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict';</span><span class="s3">\n\n</span><span class="s1">/** Highest positive signed 32-bit float value */</span><span class="s3">\n</span><span class="s1">const maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1</span><span class="s3">\n\n</span><span class="s1">/** Bootstring parameters */</span><span class="s3">\n</span><span class="s1">const base = 36;</span><span class="s3">\n</span><span class="s1">const tMin = 1;</span><span class="s3">\n</span><span class="s1">const tMax = 26;</span><span class="s3">\n</span><span class="s1">const skew = 38;</span><span class="s3">\n</span><span class="s1">const damp = 700;</span><span class="s3">\n</span><span class="s1">const initialBias = 72;</span><span class="s3">\n</span><span class="s1">const initialN = 128; // 0x80</span><span class="s3">\n</span><span class="s1">const delimiter = '-'; // '</span><span class="s3">\\</span><span class="s1">x2D'</span><span class="s3">\n\n</span><span class="s1">/** Regular expressions */</span><span class="s3">\n</span><span class="s1">const regexPunycode = /^xn--/;</span><span class="s3">\n</span><span class="s1">const regexNonASCII = /[^</span><span class="s3">\\</span><span class="s1">0-</span><span class="s3">\\</span><span class="s1">x7E]/; // non-ASCII chars</span><span class="s3">\n</span><span class="s1">const regexSeparators = /[</span><span class="s3">\\</span><span class="s1">x2E</span><span class="s3">\\</span><span class="s1">u3002</span><span class="s3">\\</span><span class="s1">uFF0E</span><span class="s3">\\</span><span class="s1">uFF61]/g; // RFC 3490 separators</span><span class="s3">\n\n</span><span class="s1">/** Error messages */</span><span class="s3">\n</span><span class="s1">const errors = {</span><span class="s3">\n\t</span><span class="s1">'overflow': 'Overflow: input needs wider integers to process',</span><span class="s3">\n\t</span><span class="s1">'not-basic': 'Illegal input &gt;= 0x80 (not a basic code point)',</span><span class="s3">\n\t</span><span class="s1">'invalid-input': 'Invalid input'</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/** Convenience shortcuts */</span><span class="s3">\n</span><span class="s1">const baseMinusTMin = base - tMin;</span><span class="s3">\n</span><span class="s1">const floor = Math.floor;</span><span class="s3">\n</span><span class="s1">const stringFromCharCode = String.fromCharCode;</span><span class="s3">\n\n</span><span class="s1">/*--------------------------------------------------------------------------*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A generic error utility function.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {String} type The error type.</span><span class="s3">\n </span><span class="s1">* @returns {Error} Throws a `RangeError` with the applicable error message.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function error(type) {</span><span class="s3">\n\t</span><span class="s1">throw new RangeError(errors[type]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A generic `Array#map` utility function.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} callback The function that gets called for every array</span><span class="s3">\n </span><span class="s1">* item.</span><span class="s3">\n </span><span class="s1">* @returns {Array} A new array of values returned by the callback function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function map(array, fn) {</span><span class="s3">\n\t</span><span class="s1">const result = [];</span><span class="s3">\n\t</span><span class="s1">let length = array.length;</span><span class="s3">\n\t</span><span class="s1">while (length--) {</span><span class="s3">\n\t\t</span><span class="s1">result[length] = fn(array[length]);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A simple `Array#map`-like wrapper to work with domain name strings or email</span><span class="s3">\n </span><span class="s1">* addresses.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {String} domain The domain name or email address.</span><span class="s3">\n </span><span class="s1">* @param {Function} callback The function that gets called for every</span><span class="s3">\n </span><span class="s1">* character.</span><span class="s3">\n </span><span class="s1">* @returns {Array} A new string of characters returned by the callback</span><span class="s3">\n </span><span class="s1">* function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function mapDomain(string, fn) {</span><span class="s3">\n\t</span><span class="s1">const parts = string.split('@');</span><span class="s3">\n\t</span><span class="s1">let result = '';</span><span class="s3">\n\t</span><span class="s1">if (parts.length &gt; 1) {</span><span class="s3">\n\t\t</span><span class="s1">// In email addresses, only the domain name should be punycoded. Leave</span><span class="s3">\n\t\t</span><span class="s1">// the local part (i.e. everything up to `@`) intact.</span><span class="s3">\n\t\t</span><span class="s1">result = parts[0] + '@';</span><span class="s3">\n\t\t</span><span class="s1">string = parts[1];</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Avoid `split(regex)` for IE8 compatibility. See #17.</span><span class="s3">\n\t</span><span class="s1">string = string.replace(regexSeparators, '</span><span class="s3">\\</span><span class="s1">x2E');</span><span class="s3">\n\t</span><span class="s1">const labels = string.split('.');</span><span class="s3">\n\t</span><span class="s1">const encoded = map(labels, fn).join('.');</span><span class="s3">\n\t</span><span class="s1">return result + encoded;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an array containing the numeric code points of each Unicode</span><span class="s3">\n </span><span class="s1">* character in the string. While JavaScript uses UCS-2 internally,</span><span class="s3">\n </span><span class="s1">* this function will convert a pair of surrogate halves (each of which</span><span class="s3">\n </span><span class="s1">* UCS-2 exposes as separate characters) into a single code point,</span><span class="s3">\n </span><span class="s1">* matching UTF-16.</span><span class="s3">\n </span><span class="s1">* @see `punycode.ucs2.encode`</span><span class="s3">\n </span><span class="s1">* @see &lt;https://mathiasbynens.be/notes/javascript-encoding&gt;</span><span class="s3">\n </span><span class="s1">* @memberOf punycode.ucs2</span><span class="s3">\n </span><span class="s1">* @name decode</span><span class="s3">\n </span><span class="s1">* @param {String} string The Unicode input string (UCS-2).</span><span class="s3">\n </span><span class="s1">* @returns {Array} The new array of code points.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function ucs2decode(string) {</span><span class="s3">\n\t</span><span class="s1">const output = [];</span><span class="s3">\n\t</span><span class="s1">let counter = 0;</span><span class="s3">\n\t</span><span class="s1">const length = string.length;</span><span class="s3">\n\t</span><span class="s1">while (counter &lt; length) {</span><span class="s3">\n\t\t</span><span class="s1">const value = string.charCodeAt(counter++);</span><span class="s3">\n\t\t</span><span class="s1">if (value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDBFF &amp;&amp; counter &lt; length) {</span><span class="s3">\n\t\t\t</span><span class="s1">// It's a high surrogate, and there is a next character.</span><span class="s3">\n\t\t\t</span><span class="s1">const extra = string.charCodeAt(counter++);</span><span class="s3">\n\t\t\t</span><span class="s1">if ((extra &amp; 0xFC00) == 0xDC00) { // Low surrogate.</span><span class="s3">\n\t\t\t\t</span><span class="s1">output.push(((value &amp; 0x3FF) &lt;&lt; 10) + (extra &amp; 0x3FF) + 0x10000);</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">// It's an unmatched surrogate; only append this code unit, in case the</span><span class="s3">\n\t\t\t\t</span><span class="s1">// next code unit is the high surrogate of a surrogate pair.</span><span class="s3">\n\t\t\t\t</span><span class="s1">output.push(value);</span><span class="s3">\n\t\t\t\t</span><span class="s1">counter--;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">output.push(value);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return output;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a string based on an array of numeric code points.</span><span class="s3">\n </span><span class="s1">* @see `punycode.ucs2.decode`</span><span class="s3">\n </span><span class="s1">* @memberOf punycode.ucs2</span><span class="s3">\n </span><span class="s1">* @name encode</span><span class="s3">\n </span><span class="s1">* @param {Array} codePoints The array of numeric code points.</span><span class="s3">\n </span><span class="s1">* @returns {String} The new Unicode string (UCS-2).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const ucs2encode = array =&gt; String.fromCodePoint(...array);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a basic code point into a digit/integer.</span><span class="s3">\n </span><span class="s1">* @see `digitToBasic()`</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Number} codePoint The basic numeric code point value.</span><span class="s3">\n </span><span class="s1">* @returns {Number} The numeric value of a basic code point (for use in</span><span class="s3">\n </span><span class="s1">* representing integers) in the range `0` to `base - 1`, or `base` if</span><span class="s3">\n </span><span class="s1">* the code point does not represent a value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const basicToDigit = function(codePoint) {</span><span class="s3">\n\t</span><span class="s1">if (codePoint - 0x30 &lt; 0x0A) {</span><span class="s3">\n\t\t</span><span class="s1">return codePoint - 0x16;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">if (codePoint - 0x41 &lt; 0x1A) {</span><span class="s3">\n\t\t</span><span class="s1">return codePoint - 0x41;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">if (codePoint - 0x61 &lt; 0x1A) {</span><span class="s3">\n\t\t</span><span class="s1">return codePoint - 0x61;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return base;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a digit/integer into a basic code point.</span><span class="s3">\n </span><span class="s1">* @see `basicToDigit()`</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Number} digit The numeric value of a basic code point.</span><span class="s3">\n </span><span class="s1">* @returns {Number} The basic code point whose value (when used for</span><span class="s3">\n </span><span class="s1">* representing integers) is `digit`, which needs to be in the range</span><span class="s3">\n </span><span class="s1">* `0` to `base - 1`. If `flag` is non-zero, the uppercase form is</span><span class="s3">\n </span><span class="s1">* used; else, the lowercase form is used. The behavior is undefined</span><span class="s3">\n </span><span class="s1">* if `flag` is non-zero and `digit` has no uppercase form.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const digitToBasic = function(digit, flag) {</span><span class="s3">\n\t</span><span class="s1">//  0..25 map to ASCII a..z or A..Z</span><span class="s3">\n\t</span><span class="s1">// 26..35 map to ASCII 0..9</span><span class="s3">\n\t</span><span class="s1">return digit + 22 + 75 * (digit &lt; 26) - ((flag != 0) &lt;&lt; 5);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Bias adaptation function as per section 3.4 of RFC 3492.</span><span class="s3">\n </span><span class="s1">* https://tools.ietf.org/html/rfc3492#section-3.4</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const adapt = function(delta, numPoints, firstTime) {</span><span class="s3">\n\t</span><span class="s1">let k = 0;</span><span class="s3">\n\t</span><span class="s1">delta = firstTime ? floor(delta / damp) : delta &gt;&gt; 1;</span><span class="s3">\n\t</span><span class="s1">delta += floor(delta / numPoints);</span><span class="s3">\n\t</span><span class="s1">for (/* no initialization */; delta &gt; baseMinusTMin * tMax &gt;&gt; 1; k += base) {</span><span class="s3">\n\t\t</span><span class="s1">delta = floor(delta / baseMinusTMin);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a Punycode string of ASCII-only symbols to a string of Unicode</span><span class="s3">\n </span><span class="s1">* symbols.</span><span class="s3">\n </span><span class="s1">* @memberOf punycode</span><span class="s3">\n </span><span class="s1">* @param {String} input The Punycode string of ASCII-only symbols.</span><span class="s3">\n </span><span class="s1">* @returns {String} The resulting string of Unicode symbols.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const decode = function(input) {</span><span class="s3">\n\t</span><span class="s1">// Don't use UCS-2.</span><span class="s3">\n\t</span><span class="s1">const output = [];</span><span class="s3">\n\t</span><span class="s1">const inputLength = input.length;</span><span class="s3">\n\t</span><span class="s1">let i = 0;</span><span class="s3">\n\t</span><span class="s1">let n = initialN;</span><span class="s3">\n\t</span><span class="s1">let bias = initialBias;</span><span class="s3">\n\n\t</span><span class="s1">// Handle the basic code points: let `basic` be the number of input code</span><span class="s3">\n\t</span><span class="s1">// points before the last delimiter, or `0` if there is none, then copy</span><span class="s3">\n\t</span><span class="s1">// the first basic code points to the output.</span><span class="s3">\n\n\t</span><span class="s1">let basic = input.lastIndexOf(delimiter);</span><span class="s3">\n\t</span><span class="s1">if (basic &lt; 0) {</span><span class="s3">\n\t\t</span><span class="s1">basic = 0;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">for (let j = 0; j &lt; basic; ++j) {</span><span class="s3">\n\t\t</span><span class="s1">// if it's not a basic code point</span><span class="s3">\n\t\t</span><span class="s1">if (input.charCodeAt(j) &gt;= 0x80) {</span><span class="s3">\n\t\t\t</span><span class="s1">error('not-basic');</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">output.push(input.charCodeAt(j));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">// Main decoding loop: start just after the last delimiter if any basic code</span><span class="s3">\n\t</span><span class="s1">// points were copied; start at the beginning otherwise.</span><span class="s3">\n\n\t</span><span class="s1">for (let index = basic &gt; 0 ? basic + 1 : 0; index &lt; inputLength; /* no final expression */) {</span><span class="s3">\n\n\t\t</span><span class="s1">// `index` is the index of the next character to be consumed.</span><span class="s3">\n\t\t</span><span class="s1">// Decode a generalized variable-length integer into `delta`,</span><span class="s3">\n\t\t</span><span class="s1">// which gets added to `i`. The overflow checking is easier</span><span class="s3">\n\t\t</span><span class="s1">// if we increase `i` as we go, then subtract off its starting</span><span class="s3">\n\t\t</span><span class="s1">// value at the end to obtain `delta`.</span><span class="s3">\n\t\t</span><span class="s1">let oldi = i;</span><span class="s3">\n\t\t</span><span class="s1">for (let w = 1, k = base; /* no condition */; k += base) {</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (index &gt;= inputLength) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">error('invalid-input');</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">const digit = basicToDigit(input.charCodeAt(index++));</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (digit &gt;= base || digit &gt; floor((maxInt - i) / w)) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">error('overflow');</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">i += digit * w;</span><span class="s3">\n\t\t\t</span><span class="s1">const t = k &lt;= bias ? tMin : (k &gt;= bias + tMax ? tMax : k - bias);</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (digit &lt; t) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">const baseMinusT = base - t;</span><span class="s3">\n\t\t\t</span><span class="s1">if (w &gt; floor(maxInt / baseMinusT)) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">error('overflow');</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">w *= baseMinusT;</span><span class="s3">\n\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">const out = output.length + 1;</span><span class="s3">\n\t\t</span><span class="s1">bias = adapt(i - oldi, out, oldi == 0);</span><span class="s3">\n\n\t\t</span><span class="s1">// `i` was supposed to wrap around from `out` to `0`,</span><span class="s3">\n\t\t</span><span class="s1">// incrementing `n` each time, so we'll fix that now:</span><span class="s3">\n\t\t</span><span class="s1">if (floor(i / out) &gt; maxInt - n) {</span><span class="s3">\n\t\t\t</span><span class="s1">error('overflow');</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">n += floor(i / out);</span><span class="s3">\n\t\t</span><span class="s1">i %= out;</span><span class="s3">\n\n\t\t</span><span class="s1">// Insert `n` at position `i` of the output.</span><span class="s3">\n\t\t</span><span class="s1">output.splice(i++, 0, n);</span><span class="s3">\n\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return String.fromCodePoint(...output);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a string of Unicode symbols (e.g. a domain name label) to a</span><span class="s3">\n </span><span class="s1">* Punycode string of ASCII-only symbols.</span><span class="s3">\n </span><span class="s1">* @memberOf punycode</span><span class="s3">\n </span><span class="s1">* @param {String} input The string of Unicode symbols.</span><span class="s3">\n </span><span class="s1">* @returns {String} The resulting Punycode string of ASCII-only symbols.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const encode = function(input) {</span><span class="s3">\n\t</span><span class="s1">const output = [];</span><span class="s3">\n\n\t</span><span class="s1">// Convert the input in UCS-2 to an array of Unicode code points.</span><span class="s3">\n\t</span><span class="s1">input = ucs2decode(input);</span><span class="s3">\n\n\t</span><span class="s1">// Cache the length.</span><span class="s3">\n\t</span><span class="s1">let inputLength = input.length;</span><span class="s3">\n\n\t</span><span class="s1">// Initialize the state.</span><span class="s3">\n\t</span><span class="s1">let n = initialN;</span><span class="s3">\n\t</span><span class="s1">let delta = 0;</span><span class="s3">\n\t</span><span class="s1">let bias = initialBias;</span><span class="s3">\n\n\t</span><span class="s1">// Handle the basic code points.</span><span class="s3">\n\t</span><span class="s1">for (const currentValue of input) {</span><span class="s3">\n\t\t</span><span class="s1">if (currentValue &lt; 0x80) {</span><span class="s3">\n\t\t\t</span><span class="s1">output.push(stringFromCharCode(currentValue));</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">let basicLength = output.length;</span><span class="s3">\n\t</span><span class="s1">let handledCPCount = basicLength;</span><span class="s3">\n\n\t</span><span class="s1">// `handledCPCount` is the number of code points that have been handled;</span><span class="s3">\n\t</span><span class="s1">// `basicLength` is the number of basic code points.</span><span class="s3">\n\n\t</span><span class="s1">// Finish the basic string with a delimiter unless it's empty.</span><span class="s3">\n\t</span><span class="s1">if (basicLength) {</span><span class="s3">\n\t\t</span><span class="s1">output.push(delimiter);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">// Main encoding loop:</span><span class="s3">\n\t</span><span class="s1">while (handledCPCount &lt; inputLength) {</span><span class="s3">\n\n\t\t</span><span class="s1">// All non-basic code points &lt; n have been handled already. Find the next</span><span class="s3">\n\t\t</span><span class="s1">// larger one:</span><span class="s3">\n\t\t</span><span class="s1">let m = maxInt;</span><span class="s3">\n\t\t</span><span class="s1">for (const currentValue of input) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (currentValue &gt;= n &amp;&amp; currentValue &lt; m) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">m = currentValue;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">// Increase `delta` enough to advance the decoder's &lt;n,i&gt; state to &lt;m,0&gt;,</span><span class="s3">\n\t\t</span><span class="s1">// but guard against overflow.</span><span class="s3">\n\t\t</span><span class="s1">const handledCPCountPlusOne = handledCPCount + 1;</span><span class="s3">\n\t\t</span><span class="s1">if (m - n &gt; floor((maxInt - delta) / handledCPCountPlusOne)) {</span><span class="s3">\n\t\t\t</span><span class="s1">error('overflow');</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">delta += (m - n) * handledCPCountPlusOne;</span><span class="s3">\n\t\t</span><span class="s1">n = m;</span><span class="s3">\n\n\t\t</span><span class="s1">for (const currentValue of input) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (currentValue &lt; n &amp;&amp; ++delta &gt; maxInt) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">error('overflow');</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">if (currentValue == n) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">// Represent delta as a generalized variable-length integer.</span><span class="s3">\n\t\t\t\t</span><span class="s1">let q = delta;</span><span class="s3">\n\t\t\t\t</span><span class="s1">for (let k = base; /* no condition */; k += base) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">const t = k &lt;= bias ? tMin : (k &gt;= bias + tMax ? tMax : k - bias);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if (q &lt; t) {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">const qMinusT = q - t;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">const baseMinusT = base - t;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">output.push(</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">q = floor(qMinusT / baseMinusT);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">output.push(stringFromCharCode(digitToBasic(q, 0)));</span><span class="s3">\n\t\t\t\t</span><span class="s1">bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);</span><span class="s3">\n\t\t\t\t</span><span class="s1">delta = 0;</span><span class="s3">\n\t\t\t\t</span><span class="s1">++handledCPCount;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">++delta;</span><span class="s3">\n\t\t</span><span class="s1">++n;</span><span class="s3">\n\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return output.join('');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a Punycode string representing a domain name or an email address</span><span class="s3">\n </span><span class="s1">* to Unicode. Only the Punycoded parts of the input will be converted, i.e.</span><span class="s3">\n </span><span class="s1">* it doesn't matter if you call it on a string that has already been</span><span class="s3">\n </span><span class="s1">* converted to Unicode.</span><span class="s3">\n </span><span class="s1">* @memberOf punycode</span><span class="s3">\n </span><span class="s1">* @param {String} input The Punycoded domain name or email address to</span><span class="s3">\n </span><span class="s1">* convert to Unicode.</span><span class="s3">\n </span><span class="s1">* @returns {String} The Unicode representation of the given Punycode</span><span class="s3">\n </span><span class="s1">* string.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const toUnicode = function(input) {</span><span class="s3">\n\t</span><span class="s1">return mapDomain(input, function(string) {</span><span class="s3">\n\t\t</span><span class="s1">return regexPunycode.test(string)</span><span class="s3">\n\t\t\t</span><span class="s1">? decode(string.slice(4).toLowerCase())</span><span class="s3">\n\t\t\t</span><span class="s1">: string;</span><span class="s3">\n\t</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a Unicode string representing a domain name or an email address to</span><span class="s3">\n </span><span class="s1">* Punycode. Only the non-ASCII parts of the domain name will be converted,</span><span class="s3">\n </span><span class="s1">* i.e. it doesn't matter if you call it with a domain that's already in</span><span class="s3">\n </span><span class="s1">* ASCII.</span><span class="s3">\n </span><span class="s1">* @memberOf punycode</span><span class="s3">\n </span><span class="s1">* @param {String} input The domain name or email address to convert, as a</span><span class="s3">\n </span><span class="s1">* Unicode string.</span><span class="s3">\n </span><span class="s1">* @returns {String} The Punycode representation of the given domain name or</span><span class="s3">\n </span><span class="s1">* email address.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const toASCII = function(input) {</span><span class="s3">\n\t</span><span class="s1">return mapDomain(input, function(string) {</span><span class="s3">\n\t\t</span><span class="s1">return regexNonASCII.test(string)</span><span class="s3">\n\t\t\t</span><span class="s1">? 'xn--' + encode(string)</span><span class="s3">\n\t\t\t</span><span class="s1">: string;</span><span class="s3">\n\t</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/*--------------------------------------------------------------------------*/</span><span class="s3">\n\n</span><span class="s1">/** Define the public API */</span><span class="s3">\n</span><span class="s1">const punycode = {</span><span class="s3">\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* A string representing the current Punycode.js version number.</span><span class="s3">\n\t </span><span class="s1">* @memberOf punycode</span><span class="s3">\n\t </span><span class="s1">* @type String</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">'version': '2.1.0',</span><span class="s3">\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* An object of methods to convert from JavaScript's internal character</span><span class="s3">\n\t </span><span class="s1">* representation (UCS-2) to Unicode code points, and back.</span><span class="s3">\n\t </span><span class="s1">* @see &lt;https://mathiasbynens.be/notes/javascript-encoding&gt;</span><span class="s3">\n\t </span><span class="s1">* @memberOf punycode</span><span class="s3">\n\t </span><span class="s1">* @type Object</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">'ucs2': {</span><span class="s3">\n\t\t</span><span class="s1">'decode': ucs2decode,</span><span class="s3">\n\t\t</span><span class="s1">'encode': ucs2encode</span><span class="s3">\n\t</span><span class="s1">},</span><span class="s3">\n\t</span><span class="s1">'decode': decode,</span><span class="s3">\n\t</span><span class="s1">'encode': encode,</span><span class="s3">\n\t</span><span class="s1">'toASCII': toASCII,</span><span class="s3">\n\t</span><span class="s1">'toUnicode': toUnicode</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default punycode;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* URI.js</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.</span><span class="s3">\n </span><span class="s1">* @author &lt;a href=</span><span class="s3">\&quot;</span><span class="s1">mailto:gary.court@gmail.com</span><span class="s3">\&quot;</span><span class="s1">&gt;Gary Court&lt;/a&gt;</span><span class="s3">\n </span><span class="s1">* @see http://github.com/garycourt/uri-js</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Copyright 2011 Gary Court. All rights reserved.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Redistribution and use in source and binary forms, with or without modification, are</span><span class="s3">\n </span><span class="s1">* permitted provided that the following conditions are met:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    1. Redistributions of source code must retain the above copyright notice, this list of</span><span class="s3">\n </span><span class="s1">*       conditions and the following disclaimer.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    2. Redistributions in binary form must reproduce the above copyright notice, this list</span><span class="s3">\n </span><span class="s1">*       of conditions and the following disclaimer in the documentation and/or other materials</span><span class="s3">\n </span><span class="s1">*       provided with the distribution.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED</span><span class="s3">\n </span><span class="s1">* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND</span><span class="s3">\n </span><span class="s1">* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR</span><span class="s3">\n </span><span class="s1">* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span><span class="s3">\n </span><span class="s1">* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span><span class="s3">\n </span><span class="s1">* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON</span><span class="s3">\n </span><span class="s1">* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span><span class="s3">\n </span><span class="s1">* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF</span><span class="s3">\n </span><span class="s1">* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The views and conclusions contained in the software and documentation are those of the</span><span class="s3">\n </span><span class="s1">* authors and should not be interpreted as representing official policies, either expressed</span><span class="s3">\n </span><span class="s1">* or implied, of Gary Court.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import URI_PROTOCOL from </span><span class="s3">\&quot;</span><span class="s1">./regexps-uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import IRI_PROTOCOL from </span><span class="s3">\&quot;</span><span class="s1">./regexps-iri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import punycode from </span><span class="s3">\&quot;</span><span class="s1">punycode</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { toUpperCase, typeOf, assign } from </span><span class="s3">\&quot;</span><span class="s1">./util</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export interface URIComponents {</span><span class="s3">\n\t</span><span class="s1">scheme?:string;</span><span class="s3">\n\t</span><span class="s1">userinfo?:string;</span><span class="s3">\n\t</span><span class="s1">host?:string;</span><span class="s3">\n\t</span><span class="s1">port?:number|string;</span><span class="s3">\n\t</span><span class="s1">path?:string;</span><span class="s3">\n\t</span><span class="s1">query?:string;</span><span class="s3">\n\t</span><span class="s1">fragment?:string;</span><span class="s3">\n\t</span><span class="s1">reference?:string;</span><span class="s3">\n\t</span><span class="s1">error?:string;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface URIOptions {</span><span class="s3">\n\t</span><span class="s1">scheme?:string;</span><span class="s3">\n\t</span><span class="s1">reference?:string;</span><span class="s3">\n\t</span><span class="s1">tolerant?:boolean;</span><span class="s3">\n\t</span><span class="s1">absolutePath?:boolean;</span><span class="s3">\n\t</span><span class="s1">iri?:boolean;</span><span class="s3">\n\t</span><span class="s1">unicodeSupport?:boolean;</span><span class="s3">\n\t</span><span class="s1">domainHost?:boolean;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface URISchemeHandler&lt;Components extends URIComponents = URIComponents, Options extends URIOptions = URIOptions, ParentComponents extends URIComponents = URIComponents&gt; {</span><span class="s3">\n\t</span><span class="s1">scheme:string;</span><span class="s3">\n\t</span><span class="s1">parse(components:ParentComponents, options:Options):Components;</span><span class="s3">\n\t</span><span class="s1">serialize(components:Components, options:Options):ParentComponents;</span><span class="s3">\n\t</span><span class="s1">unicodeSupport?:boolean;</span><span class="s3">\n\t</span><span class="s1">domainHost?:boolean;</span><span class="s3">\n\t</span><span class="s1">absolutePath?:boolean;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface URIRegExps {</span><span class="s3">\n\t</span><span class="s1">NOT_SCHEME : RegExp,</span><span class="s3">\n\t</span><span class="s1">NOT_USERINFO : RegExp,</span><span class="s3">\n\t</span><span class="s1">NOT_HOST : RegExp,</span><span class="s3">\n\t</span><span class="s1">NOT_PATH : RegExp,</span><span class="s3">\n\t</span><span class="s1">NOT_PATH_NOSCHEME : RegExp,</span><span class="s3">\n\t</span><span class="s1">NOT_QUERY : RegExp,</span><span class="s3">\n\t</span><span class="s1">NOT_FRAGMENT : RegExp,</span><span class="s3">\n\t</span><span class="s1">ESCAPE : RegExp,</span><span class="s3">\n\t</span><span class="s1">UNRESERVED : RegExp,</span><span class="s3">\n\t</span><span class="s1">OTHER_CHARS : RegExp,</span><span class="s3">\n\t</span><span class="s1">PCT_ENCODED : RegExp,</span><span class="s3">\n\t</span><span class="s1">IPV4ADDRESS : RegExp,</span><span class="s3">\n\t</span><span class="s1">IPV6ADDRESS : RegExp,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const SCHEMES:{[scheme:string]:URISchemeHandler} = {};</span><span class="s3">\n\n</span><span class="s1">export function pctEncChar(chr:string):string {</span><span class="s3">\n\t</span><span class="s1">const c = chr.charCodeAt(0);</span><span class="s3">\n\t</span><span class="s1">let e:string;</span><span class="s3">\n\n\t</span><span class="s1">if (c &lt; 16) e = </span><span class="s3">\&quot;</span><span class="s1">%0</span><span class="s3">\&quot; </span><span class="s1">+ c.toString(16).toUpperCase();</span><span class="s3">\n\t</span><span class="s1">else if (c &lt; 128) e = </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ c.toString(16).toUpperCase();</span><span class="s3">\n\t</span><span class="s1">else if (c &lt; 2048) e = </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ ((c &gt;&gt; 6) | 192).toString(16).toUpperCase() + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ ((c &amp; 63) | 128).toString(16).toUpperCase();</span><span class="s3">\n\t</span><span class="s1">else e = </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ ((c &gt;&gt; 12) | 224).toString(16).toUpperCase() + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ (((c &gt;&gt; 6) &amp; 63) | 128).toString(16).toUpperCase() + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ ((c &amp; 63) | 128).toString(16).toUpperCase();</span><span class="s3">\n\n\t</span><span class="s1">return e;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function pctDecChars(str:string):string {</span><span class="s3">\n\t</span><span class="s1">let newStr = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n\t</span><span class="s1">let i = 0;</span><span class="s3">\n\t</span><span class="s1">const il = str.length;</span><span class="s3">\n\n\t</span><span class="s1">while (i &lt; il) {</span><span class="s3">\n\t\t</span><span class="s1">const c = parseInt(str.substr(i + 1, 2), 16);</span><span class="s3">\n\n\t\t</span><span class="s1">if (c &lt; 128) {</span><span class="s3">\n\t\t\t</span><span class="s1">newStr += String.fromCharCode(c);</span><span class="s3">\n\t\t\t</span><span class="s1">i += 3;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">else if (c &gt;= 194 &amp;&amp; c &lt; 224) {</span><span class="s3">\n\t\t\t</span><span class="s1">if ((il - i) &gt;= 6) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const c2 = parseInt(str.substr(i + 4, 2), 16);</span><span class="s3">\n\t\t\t\t</span><span class="s1">newStr += String.fromCharCode(((c &amp; 31) &lt;&lt; 6) | (c2 &amp; 63));</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">newStr += str.substr(i, 6);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">i += 6;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">else if (c &gt;= 224) {</span><span class="s3">\n\t\t\t</span><span class="s1">if ((il - i) &gt;= 9) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const c2 = parseInt(str.substr(i + 4, 2), 16);</span><span class="s3">\n\t\t\t\t</span><span class="s1">const c3 = parseInt(str.substr(i + 7, 2), 16);</span><span class="s3">\n\t\t\t\t</span><span class="s1">newStr += String.fromCharCode(((c &amp; 15) &lt;&lt; 12) | ((c2 &amp; 63) &lt;&lt; 6) | (c3 &amp; 63));</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">newStr += str.substr(i, 9);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">i += 9;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">else {</span><span class="s3">\n\t\t\t</span><span class="s1">newStr += str.substr(i, 3);</span><span class="s3">\n\t\t\t</span><span class="s1">i += 3;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return newStr;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function _normalizeComponentEncoding(components:URIComponents, protocol:URIRegExps) {</span><span class="s3">\n\t</span><span class="s1">function decodeUnreserved(str:string):string {</span><span class="s3">\n\t\t</span><span class="s1">const decStr = pctDecChars(str);</span><span class="s3">\n\t\t</span><span class="s1">return (!decStr.match(protocol.UNRESERVED) ? str : decStr);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n\t</span><span class="s1">if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span><span class="s3">\n\t</span><span class="s1">if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span><span class="s3">\n\t</span><span class="s1">if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span><span class="s3">\n\t</span><span class="s1">if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span><span class="s3">\n\t</span><span class="s1">if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span><span class="s3">\n\n\t</span><span class="s1">return components;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function _stripLeadingZeros(str:string):string {</span><span class="s3">\n\t</span><span class="s1">return str.replace(/^0*(.*)/, </span><span class="s3">\&quot;</span><span class="s1">$1</span><span class="s3">\&quot;</span><span class="s1">) || </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function _normalizeIPv4(host:string, protocol:URIRegExps):string {</span><span class="s3">\n\t</span><span class="s1">const matches = host.match(protocol.IPV4ADDRESS) || [];</span><span class="s3">\n\t</span><span class="s1">const [, address] = matches;</span><span class="s3">\n\t\n\t</span><span class="s1">if (address) {</span><span class="s3">\n\t\t</span><span class="s1">return address.split(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">).map(_stripLeadingZeros).join(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t</span><span class="s1">} else {</span><span class="s3">\n\t\t</span><span class="s1">return host;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function _normalizeIPv6(host:string, protocol:URIRegExps):string {</span><span class="s3">\n\t</span><span class="s1">const matches = host.match(protocol.IPV6ADDRESS) || [];</span><span class="s3">\n\t</span><span class="s1">const [, address, zone] = matches;</span><span class="s3">\n\n\t</span><span class="s1">if (address) {</span><span class="s3">\n\t\t</span><span class="s1">const [last, first] = address.toLowerCase().split('::').reverse();</span><span class="s3">\n\t\t</span><span class="s1">const firstFields = first ? first.split(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">).map(_stripLeadingZeros) : [];</span><span class="s3">\n\t\t</span><span class="s1">const lastFields = last.split(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">).map(_stripLeadingZeros);</span><span class="s3">\n\t\t</span><span class="s1">const isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);</span><span class="s3">\n\t\t</span><span class="s1">const fieldCount = isLastFieldIPv4Address ? 7 : 8;</span><span class="s3">\n\t\t</span><span class="s1">const lastFieldsStart = lastFields.length - fieldCount;</span><span class="s3">\n\t\t</span><span class="s1">const fields = Array&lt;string&gt;(fieldCount);</span><span class="s3">\n\n\t\t</span><span class="s1">for (let x = 0; x &lt; fieldCount; ++x) {</span><span class="s3">\n\t\t\t</span><span class="s1">fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (isLastFieldIPv4Address) {</span><span class="s3">\n\t\t\t</span><span class="s1">fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">const allZeroFields = fields.reduce&lt;Array&lt;{index:number,length:number}&gt;&gt;((acc, field, index) =&gt; {</span><span class="s3">\n\t\t\t</span><span class="s1">if (!field || field === </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const lastLongest = acc[acc.length - 1];</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (lastLongest &amp;&amp; lastLongest.index + lastLongest.length === index) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">lastLongest.length++;</span><span class="s3">\n\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">acc.push({ index, length : 1 });</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">return acc;</span><span class="s3">\n\t\t</span><span class="s1">}, []);</span><span class="s3">\n\n\t\t</span><span class="s1">const longestZeroFields = allZeroFields.sort((a, b) =&gt; b.length - a.length)[0];</span><span class="s3">\n\n\t\t</span><span class="s1">let newHost:string;</span><span class="s3">\n\t\t</span><span class="s1">if (longestZeroFields &amp;&amp; longestZeroFields.length &gt; 1) {</span><span class="s3">\n\t\t\t</span><span class="s1">const newFirst = fields.slice(0, longestZeroFields.index) ;</span><span class="s3">\n\t\t\t</span><span class="s1">const newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);</span><span class="s3">\n\t\t\t</span><span class="s1">newHost = newFirst.join(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot; </span><span class="s1">+ newLast.join(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">newHost = fields.join(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (zone) {</span><span class="s3">\n\t\t\t</span><span class="s1">newHost += </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ zone;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return newHost;</span><span class="s3">\n\t</span><span class="s1">} else {</span><span class="s3">\n\t\t</span><span class="s1">return host;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const URI_PARSE = /^(?:([^:</span><span class="s3">\\</span><span class="s1">/?#]+):)?(?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/((?:([^</span><span class="s3">\\</span><span class="s1">/?#@]*)@)?(</span><span class="s3">\\</span><span class="s1">[[^</span><span class="s3">\\</span><span class="s1">/?#</span><span class="s3">\\</span><span class="s1">]]+</span><span class="s3">\\</span><span class="s1">]|[^</span><span class="s3">\\</span><span class="s1">/?#:]*)(?:</span><span class="s3">\\</span><span class="s1">:(</span><span class="s3">\\</span><span class="s1">d*))?))?([^?#]*)(?:</span><span class="s3">\\</span><span class="s1">?([^#]*))?(?:#((?:.|</span><span class="s3">\\</span><span class="s1">n|</span><span class="s3">\\</span><span class="s1">r)*))?/i;</span><span class="s3">\n</span><span class="s1">const NO_MATCH_IS_UNDEFINED = (&lt;RegExpMatchArray&gt;(</span><span class="s3">\&quot;\&quot;</span><span class="s1">).match(/(){0}/))[1] === undefined;</span><span class="s3">\n\n</span><span class="s1">export function parse(uriString:string, options:URIOptions = {}):URIComponents {</span><span class="s3">\n\t</span><span class="s1">const components:URIComponents = {};</span><span class="s3">\n\t</span><span class="s1">const protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);</span><span class="s3">\n\n\t</span><span class="s1">if (options.reference === </span><span class="s3">\&quot;</span><span class="s1">suffix</span><span class="s3">\&quot;</span><span class="s1">) uriString = (options.scheme ? options.scheme + </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot; </span><span class="s1">+ uriString;</span><span class="s3">\n\n\t</span><span class="s1">const matches = uriString.match(URI_PARSE);</span><span class="s3">\n\n\t</span><span class="s1">if (matches) {</span><span class="s3">\n\t\t</span><span class="s1">if (NO_MATCH_IS_UNDEFINED) {</span><span class="s3">\n\t\t\t</span><span class="s1">//store each component</span><span class="s3">\n\t\t\t</span><span class="s1">components.scheme = matches[1];</span><span class="s3">\n\t\t\t</span><span class="s1">components.userinfo = matches[3];</span><span class="s3">\n\t\t\t</span><span class="s1">components.host = matches[4];</span><span class="s3">\n\t\t\t</span><span class="s1">components.port = parseInt(matches[5], 10);</span><span class="s3">\n\t\t\t</span><span class="s1">components.path = matches[6] || </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t\t</span><span class="s1">components.query = matches[7];</span><span class="s3">\n\t\t\t</span><span class="s1">components.fragment = matches[8];</span><span class="s3">\n\n\t\t\t</span><span class="s1">//fix port number</span><span class="s3">\n\t\t\t</span><span class="s1">if (isNaN(components.port)) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">components.port = matches[5];</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">} else {  //IE FIX for improper RegExp matching</span><span class="s3">\n\t\t\t</span><span class="s1">//store each component</span><span class="s3">\n\t\t\t</span><span class="s1">components.scheme = matches[1] || undefined;</span><span class="s3">\n\t\t\t</span><span class="s1">components.userinfo = (uriString.indexOf(</span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">) !== -1 ? matches[3] : undefined);</span><span class="s3">\n\t\t\t</span><span class="s1">components.host = (uriString.indexOf(</span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot;</span><span class="s1">) !== -1 ? matches[4] : undefined);</span><span class="s3">\n\t\t\t</span><span class="s1">components.port = parseInt(matches[5], 10);</span><span class="s3">\n\t\t\t</span><span class="s1">components.path = matches[6] || </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t\t</span><span class="s1">components.query = (uriString.indexOf(</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">) !== -1 ? matches[7] : undefined);</span><span class="s3">\n\t\t\t</span><span class="s1">components.fragment = (uriString.indexOf(</span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">) !== -1 ? matches[8] : undefined);</span><span class="s3">\n\n\t\t\t</span><span class="s1">//fix port number</span><span class="s3">\n\t\t\t</span><span class="s1">if (isNaN(components.port)) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">components.port = (uriString.match(/</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/(?:.|</span><span class="s3">\\</span><span class="s1">n)*</span><span class="s3">\\</span><span class="s1">:(?:</span><span class="s3">\\</span><span class="s1">/|</span><span class="s3">\\</span><span class="s1">?|</span><span class="s3">\\</span><span class="s1">#|$)/) ? matches[4] : undefined);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (components.host) {</span><span class="s3">\n\t\t\t</span><span class="s1">//normalize IP hosts</span><span class="s3">\n\t\t\t</span><span class="s1">components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//determine reference type</span><span class="s3">\n\t\t</span><span class="s1">if (components.scheme === undefined &amp;&amp; components.userinfo === undefined &amp;&amp; components.host === undefined &amp;&amp; components.port === undefined &amp;&amp; !components.path &amp;&amp; components.query === undefined) {</span><span class="s3">\n\t\t\t</span><span class="s1">components.reference = </span><span class="s3">\&quot;</span><span class="s1">same-document</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">} else if (components.scheme === undefined) {</span><span class="s3">\n\t\t\t</span><span class="s1">components.reference = </span><span class="s3">\&quot;</span><span class="s1">relative</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">} else if (components.fragment === undefined) {</span><span class="s3">\n\t\t\t</span><span class="s1">components.reference = </span><span class="s3">\&quot;</span><span class="s1">absolute</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">components.reference = </span><span class="s3">\&quot;</span><span class="s1">uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//check for reference errors</span><span class="s3">\n\t\t</span><span class="s1">if (options.reference &amp;&amp; options.reference !== </span><span class="s3">\&quot;</span><span class="s1">suffix</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; options.reference !== components.reference) {</span><span class="s3">\n\t\t\t</span><span class="s1">components.error = components.error || </span><span class="s3">\&quot;</span><span class="s1">URI is not a </span><span class="s3">\&quot; </span><span class="s1">+ options.reference + </span><span class="s3">\&quot; </span><span class="s1">reference.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//find scheme handler</span><span class="s3">\n\t\t</span><span class="s1">const schemeHandler = SCHEMES[(options.scheme || components.scheme || </span><span class="s3">\&quot;\&quot;</span><span class="s1">).toLowerCase()];</span><span class="s3">\n\n\t\t</span><span class="s1">//check if scheme can't handle IRIs</span><span class="s3">\n\t\t</span><span class="s1">if (!options.unicodeSupport &amp;&amp; (!schemeHandler || !schemeHandler.unicodeSupport)) {</span><span class="s3">\n\t\t\t</span><span class="s1">//if host component is a domain name</span><span class="s3">\n\t\t\t</span><span class="s1">if (components.host &amp;&amp; (options.domainHost || (schemeHandler &amp;&amp; schemeHandler.domainHost))) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">//convert Unicode IDN -&gt; ASCII IDN</span><span class="s3">\n\t\t\t\t</span><span class="s1">try {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());</span><span class="s3">\n\t\t\t\t</span><span class="s1">} catch (e) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">components.error = components.error || </span><span class="s3">\&quot;</span><span class="s1">Host's domain name can not be converted to ASCII via punycode: </span><span class="s3">\&quot; </span><span class="s1">+ e;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">//convert IRI -&gt; URI</span><span class="s3">\n\t\t\t</span><span class="s1">_normalizeComponentEncoding(components, URI_PROTOCOL);</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">//normalize encodings</span><span class="s3">\n\t\t\t</span><span class="s1">_normalizeComponentEncoding(components, protocol);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//perform scheme specific parsing</span><span class="s3">\n\t\t</span><span class="s1">if (schemeHandler &amp;&amp; schemeHandler.parse) {</span><span class="s3">\n\t\t\t</span><span class="s1">schemeHandler.parse(components, options);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">} else {</span><span class="s3">\n\t\t</span><span class="s1">components.error = components.error || </span><span class="s3">\&quot;</span><span class="s1">URI can not be parsed.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return components;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function _recomposeAuthority(components:URIComponents, options:URIOptions):string|undefined {</span><span class="s3">\n\t</span><span class="s1">const protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);</span><span class="s3">\n\t</span><span class="s1">const uriTokens:Array&lt;string&gt; = [];</span><span class="s3">\n\n\t</span><span class="s1">if (components.userinfo !== undefined) {</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(components.userinfo);</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(</span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">if (components.host !== undefined) {</span><span class="s3">\n\t\t</span><span class="s1">//normalize IP hosts, add brackets and escape zone separator for IPv6</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, (_, $1, $2) =&gt; </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot; </span><span class="s1">+ $1 + ($2 ? </span><span class="s3">\&quot;</span><span class="s1">%25</span><span class="s3">\&quot; </span><span class="s1">+ $2 : </span><span class="s3">\&quot;\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">if (typeof components.port === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| typeof components.port === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(String(components.port));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return uriTokens.length ? uriTokens.join(</span><span class="s3">\&quot;\&quot;</span><span class="s1">) : undefined;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const RDS1 = /^</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.?</span><span class="s3">\\</span><span class="s1">//;</span><span class="s3">\n</span><span class="s1">const RDS2 = /^</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">.(</span><span class="s3">\\</span><span class="s1">/|$)/;</span><span class="s3">\n</span><span class="s1">const RDS3 = /^</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.(</span><span class="s3">\\</span><span class="s1">/|$)/;</span><span class="s3">\n</span><span class="s1">const RDS4 = /^</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.?$/;</span><span class="s3">\n</span><span class="s1">const RDS5 = /^</span><span class="s3">\\</span><span class="s1">/?(?:.|</span><span class="s3">\\</span><span class="s1">n)*?(?=</span><span class="s3">\\</span><span class="s1">/|$)/;</span><span class="s3">\n\n</span><span class="s1">export function removeDotSegments(input:string):string {</span><span class="s3">\n\t</span><span class="s1">const output:Array&lt;string&gt; = [];</span><span class="s3">\n\n\t</span><span class="s1">while (input.length) {</span><span class="s3">\n\t\t</span><span class="s1">if (input.match(RDS1)) {</span><span class="s3">\n\t\t\t</span><span class="s1">input = input.replace(RDS1, </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">} else if (input.match(RDS2)) {</span><span class="s3">\n\t\t\t</span><span class="s1">input = input.replace(RDS2, </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">} else if (input.match(RDS3)) {</span><span class="s3">\n\t\t\t</span><span class="s1">input = input.replace(RDS3, </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t\t</span><span class="s1">output.pop();</span><span class="s3">\n\t\t</span><span class="s1">} else if (input === </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">|| input === </span><span class="s3">\&quot;</span><span class="s1">..</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t\t</span><span class="s1">input = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">const im = input.match(RDS5);</span><span class="s3">\n\t\t\t</span><span class="s1">if (im) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const s = im[0];</span><span class="s3">\n\t\t\t\t</span><span class="s1">input = input.slice(s.length);</span><span class="s3">\n\t\t\t\t</span><span class="s1">output.push(s);</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Unexpected dot segment condition</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return output.join(</span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function serialize(components:URIComponents, options:URIOptions = {}):string {</span><span class="s3">\n\t</span><span class="s1">const protocol = (options.iri ? IRI_PROTOCOL : URI_PROTOCOL);</span><span class="s3">\n\t</span><span class="s1">const uriTokens:Array&lt;string&gt; = [];</span><span class="s3">\n\n\t</span><span class="s1">//find scheme handler</span><span class="s3">\n\t</span><span class="s1">const schemeHandler = SCHEMES[(options.scheme || components.scheme || </span><span class="s3">\&quot;\&quot;</span><span class="s1">).toLowerCase()];</span><span class="s3">\n\n\t</span><span class="s1">//perform scheme specific serialization</span><span class="s3">\n\t</span><span class="s1">if (schemeHandler &amp;&amp; schemeHandler.serialize) schemeHandler.serialize(components, options);</span><span class="s3">\n\n\t</span><span class="s1">if (components.host) {</span><span class="s3">\n\t\t</span><span class="s1">//if host component is an IPv6 address</span><span class="s3">\n\t\t</span><span class="s1">if (protocol.IPV6ADDRESS.test(components.host)) {</span><span class="s3">\n\t\t\t</span><span class="s1">//TODO: normalize IPv6 address as per RFC 5952</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//if host component is a domain name</span><span class="s3">\n\t\t</span><span class="s1">else if (options.domainHost || (schemeHandler &amp;&amp; schemeHandler.domainHost)) {</span><span class="s3">\n\t\t\t</span><span class="s1">//convert IDN via punycode</span><span class="s3">\n\t\t\t</span><span class="s1">try {</span><span class="s3">\n\t\t\t\t</span><span class="s1">components.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));</span><span class="s3">\n\t\t\t</span><span class="s1">} catch (e) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">components.error = components.error || </span><span class="s3">\&quot;</span><span class="s1">Host's domain name can not be converted to </span><span class="s3">\&quot; </span><span class="s1">+ (!options.iri ? </span><span class="s3">\&quot;</span><span class="s1">ASCII</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">Unicode</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot; </span><span class="s1">via punycode: </span><span class="s3">\&quot; </span><span class="s1">+ e;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">//normalize encoding</span><span class="s3">\n\t</span><span class="s1">_normalizeComponentEncoding(components, protocol);</span><span class="s3">\n\n\t</span><span class="s1">if (options.reference !== </span><span class="s3">\&quot;</span><span class="s1">suffix</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; components.scheme) {</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(components.scheme);</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">const authority = _recomposeAuthority(components, options);</span><span class="s3">\n\t</span><span class="s1">if (authority !== undefined) {</span><span class="s3">\n\t\t</span><span class="s1">if (options.reference !== </span><span class="s3">\&quot;</span><span class="s1">suffix</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t\t</span><span class="s1">uriTokens.push(</span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">uriTokens.push(authority);</span><span class="s3">\n\n\t\t</span><span class="s1">if (components.path &amp;&amp; components.path.charAt(0) !== </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t\t</span><span class="s1">uriTokens.push(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">if (components.path !== undefined) {</span><span class="s3">\n\t\t</span><span class="s1">let s = components.path;</span><span class="s3">\n\n\t\t</span><span class="s1">if (!options.absolutePath &amp;&amp; (!schemeHandler || !schemeHandler.absolutePath)) {</span><span class="s3">\n\t\t\t</span><span class="s1">s = removeDotSegments(s);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">if (authority === undefined) {</span><span class="s3">\n\t\t\t</span><span class="s1">s = s.replace(/^</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">//, </span><span class="s3">\&quot;</span><span class="s1">/%2F</span><span class="s3">\&quot;</span><span class="s1">);  //don't allow the path to start with </span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot;\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">uriTokens.push(s);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">if (components.query !== undefined) {</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(components.query);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">if (components.fragment !== undefined) {</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(</span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">uriTokens.push(components.fragment);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return uriTokens.join(</span><span class="s3">\&quot;\&quot;</span><span class="s1">);  //merge tokens into a string</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function resolveComponents(base:URIComponents, relative:URIComponents, options:URIOptions = {}, skipNormalization?:boolean):URIComponents {</span><span class="s3">\n\t</span><span class="s1">const target:URIComponents = {};</span><span class="s3">\n\n\t</span><span class="s1">if (!skipNormalization) {</span><span class="s3">\n\t\t</span><span class="s1">base = parse(serialize(base, options), options);  //normalize base components</span><span class="s3">\n\t\t</span><span class="s1">relative = parse(serialize(relative, options), options);  //normalize relative components</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">options = options || {};</span><span class="s3">\n\n\t</span><span class="s1">if (!options.tolerant &amp;&amp; relative.scheme) {</span><span class="s3">\n\t\t</span><span class="s1">target.scheme = relative.scheme;</span><span class="s3">\n\t\t</span><span class="s1">//target.authority = relative.authority;</span><span class="s3">\n\t\t</span><span class="s1">target.userinfo = relative.userinfo;</span><span class="s3">\n\t\t</span><span class="s1">target.host = relative.host;</span><span class="s3">\n\t\t</span><span class="s1">target.port = relative.port;</span><span class="s3">\n\t\t</span><span class="s1">target.path = removeDotSegments(relative.path || </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">target.query = relative.query;</span><span class="s3">\n\t</span><span class="s1">} else {</span><span class="s3">\n\t\t</span><span class="s1">if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {</span><span class="s3">\n\t\t\t</span><span class="s1">//target.authority = relative.authority;</span><span class="s3">\n\t\t\t</span><span class="s1">target.userinfo = relative.userinfo;</span><span class="s3">\n\t\t\t</span><span class="s1">target.host = relative.host;</span><span class="s3">\n\t\t\t</span><span class="s1">target.port = relative.port;</span><span class="s3">\n\t\t\t</span><span class="s1">target.path = removeDotSegments(relative.path || </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t\t</span><span class="s1">target.query = relative.query;</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">if (!relative.path) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">target.path = base.path;</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (relative.query !== undefined) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">target.query = relative.query;</span><span class="s3">\n\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">target.query = base.query;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (relative.path.charAt(0) === </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">target.path = removeDotSegments(relative.path);</span><span class="s3">\n\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) &amp;&amp; !base.path) {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">target.path = </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ relative.path;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">} else if (!base.path) {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">target.path = relative.path;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">target.path = base.path.slice(0, base.path.lastIndexOf(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">) + 1) + relative.path;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">target.path = removeDotSegments(target.path);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">target.query = relative.query;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">//target.authority = base.authority;</span><span class="s3">\n\t\t\t</span><span class="s1">target.userinfo = base.userinfo;</span><span class="s3">\n\t\t\t</span><span class="s1">target.host = base.host;</span><span class="s3">\n\t\t\t</span><span class="s1">target.port = base.port;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">target.scheme = base.scheme;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">target.fragment = relative.fragment;</span><span class="s3">\n\n\t</span><span class="s1">return target;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function resolve(baseURI:string, relativeURI:string, options?:URIOptions):string {</span><span class="s3">\n\t</span><span class="s1">const schemelessOptions = assign({ scheme : 'null' }, options);</span><span class="s3">\n\t</span><span class="s1">return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function normalize(uri:string, options?:URIOptions):string;</span><span class="s3">\n</span><span class="s1">export function normalize(uri:URIComponents, options?:URIOptions):URIComponents;</span><span class="s3">\n</span><span class="s1">export function normalize(uri:any, options?:URIOptions):any {</span><span class="s3">\n\t</span><span class="s1">if (typeof uri === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t</span><span class="s1">uri = serialize(parse(uri, options), options);</span><span class="s3">\n\t</span><span class="s1">} else if (typeOf(uri) === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t</span><span class="s1">uri = parse(serialize(&lt;URIComponents&gt;uri, options), options);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return uri;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function equal(uriA:string, uriB:string, options?: URIOptions):boolean;</span><span class="s3">\n</span><span class="s1">export function equal(uriA:URIComponents, uriB:URIComponents, options?:URIOptions):boolean;</span><span class="s3">\n</span><span class="s1">export function equal(uriA:any, uriB:any, options?:URIOptions):boolean {</span><span class="s3">\n\t</span><span class="s1">if (typeof uriA === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t</span><span class="s1">uriA = serialize(parse(uriA, options), options);</span><span class="s3">\n\t</span><span class="s1">} else if (typeOf(uriA) === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t</span><span class="s1">uriA = serialize(&lt;URIComponents&gt;uriA, options);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">if (typeof uriB === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t</span><span class="s1">uriB = serialize(parse(uriB, options), options);</span><span class="s3">\n\t</span><span class="s1">} else if (typeOf(uriB) === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t</span><span class="s1">uriB = serialize(&lt;URIComponents&gt;uriB, options);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\n\t</span><span class="s1">return uriA === uriB;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function escapeComponent(str:string, options?:URIOptions):string {</span><span class="s3">\n\t</span><span class="s1">return str &amp;&amp; str.toString().replace((!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function unescapeComponent(str:string, options?:URIOptions):string {</span><span class="s3">\n\t</span><span class="s1">return str &amp;&amp; str.toString().replace((!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URISchemeHandler, URIComponents, URIOptions } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export interface WSComponents extends URIComponents {</span><span class="s3">\n\t</span><span class="s1">resourceName?: string;</span><span class="s3">\n\t</span><span class="s1">secure?: boolean;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isSecure(wsComponents:WSComponents):boolean {</span><span class="s3">\n\t</span><span class="s1">return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === </span><span class="s3">\&quot;</span><span class="s1">wss</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">//RFC 6455</span><span class="s3">\n</span><span class="s1">const handler:URISchemeHandler = {</span><span class="s3">\n\t</span><span class="s1">scheme : </span><span class="s3">\&quot;</span><span class="s1">ws</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n\t</span><span class="s1">domainHost : true,</span><span class="s3">\n\n\t</span><span class="s1">parse : function (components:URIComponents, options:URIOptions):WSComponents {</span><span class="s3">\n\t\t</span><span class="s1">const wsComponents = components as WSComponents;</span><span class="s3">\n\n\t\t</span><span class="s1">//indicate if the secure flag is set</span><span class="s3">\n\t\t</span><span class="s1">wsComponents.secure = isSecure(wsComponents);</span><span class="s3">\n\n\t\t</span><span class="s1">//construct resouce name</span><span class="s3">\n\t\t</span><span class="s1">wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');</span><span class="s3">\n\t\t</span><span class="s1">wsComponents.path = undefined;</span><span class="s3">\n\t\t</span><span class="s1">wsComponents.query = undefined;</span><span class="s3">\n\n\t\t</span><span class="s1">return wsComponents;</span><span class="s3">\n\t</span><span class="s1">},</span><span class="s3">\n\n\t</span><span class="s1">serialize : function (wsComponents:WSComponents, options:URIOptions):URIComponents {</span><span class="s3">\n\t\t</span><span class="s1">//normalize the default port</span><span class="s3">\n\t\t</span><span class="s1">if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === </span><span class="s3">\&quot;\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t\t</span><span class="s1">wsComponents.port = undefined;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//ensure scheme matches secure flag</span><span class="s3">\n\t\t</span><span class="s1">if (typeof wsComponents.secure === 'boolean') {</span><span class="s3">\n\t\t\t</span><span class="s1">wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws');</span><span class="s3">\n\t\t\t</span><span class="s1">wsComponents.secure = undefined;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//reconstruct path from resource name</span><span class="s3">\n\t\t</span><span class="s1">if (wsComponents.resourceName) {</span><span class="s3">\n\t\t\t</span><span class="s1">const [path, query] = wsComponents.resourceName.split('?');</span><span class="s3">\n\t\t\t</span><span class="s1">wsComponents.path = (path &amp;&amp; path !== '/' ? path : undefined);</span><span class="s3">\n\t\t\t</span><span class="s1">wsComponents.query = query;</span><span class="s3">\n\t\t\t</span><span class="s1">wsComponents.resourceName = undefined;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//forbid fragment component</span><span class="s3">\n\t\t</span><span class="s1">wsComponents.fragment = undefined;</span><span class="s3">\n\n\t\t</span><span class="s1">return wsComponents;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default handler;&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URISchemeHandler, URIComponents, URIOptions } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { pctEncChar, pctDecChars, unescapeComponent } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import punycode from </span><span class="s3">\&quot;</span><span class="s1">punycode</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { merge, subexp, toUpperCase, toArray } from </span><span class="s3">\&quot;</span><span class="s1">../util</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export interface MailtoHeaders {</span><span class="s3">\n\t</span><span class="s1">[hfname:string]:string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface MailtoComponents extends URIComponents {</span><span class="s3">\n\t</span><span class="s1">to:Array&lt;string&gt;,</span><span class="s3">\n\t</span><span class="s1">headers?:MailtoHeaders,</span><span class="s3">\n\t</span><span class="s1">subject?:string,</span><span class="s3">\n\t</span><span class="s1">body?:string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const O:MailtoHeaders = {};</span><span class="s3">\n</span><span class="s1">const isIRI = true;</span><span class="s3">\n\n</span><span class="s1">//RFC 3986</span><span class="s3">\n</span><span class="s1">const UNRESERVED$$ = </span><span class="s3">\&quot;</span><span class="s1">[A-Za-z0-9</span><span class="s3">\\\\</span><span class="s1">-</span><span class="s3">\\\\</span><span class="s1">.</span><span class="s3">\\\\</span><span class="s1">_</span><span class="s3">\\\\</span><span class="s1">~</span><span class="s3">\&quot; </span><span class="s1">+ (isIRI ? </span><span class="s3">\&quot;\\\\</span><span class="s1">xA0-</span><span class="s3">\\\\</span><span class="s1">u200D</span><span class="s3">\\\\</span><span class="s1">u2010-</span><span class="s3">\\\\</span><span class="s1">u2029</span><span class="s3">\\\\</span><span class="s1">u202F-</span><span class="s3">\\\\</span><span class="s1">uD7FF</span><span class="s3">\\\\</span><span class="s1">uF900-</span><span class="s3">\\\\</span><span class="s1">uFDCF</span><span class="s3">\\\\</span><span class="s1">uFDF0-</span><span class="s3">\\\\</span><span class="s1">uFFEF</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const HEXDIG$$ = </span><span class="s3">\&quot;</span><span class="s1">[0-9A-Fa-f]</span><span class="s3">\&quot;</span><span class="s1">;  //case-insensitive</span><span class="s3">\n</span><span class="s1">const PCT_ENCODED$ = subexp(subexp(</span><span class="s3">\&quot;</span><span class="s1">%[EFef]</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">%[89A-Fa-f]</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$));  //expanded</span><span class="s3">\n\n</span><span class="s1">//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] &amp; ; =</span><span class="s3">\n</span><span class="s1">//const ATEXT$$ = </span><span class="s3">\&quot;</span><span class="s1">[A-Za-z0-9</span><span class="s3">\\\\</span><span class="s1">!</span><span class="s3">\\\\</span><span class="s1">#</span><span class="s3">\\\\</span><span class="s1">$</span><span class="s3">\\\\</span><span class="s1">%</span><span class="s3">\\\\</span><span class="s1">&amp;</span><span class="s3">\\\\</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">*</span><span class="s3">\\\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">-</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">=</span><span class="s3">\\\\</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">^</span><span class="s3">\\\\</span><span class="s1">_</span><span class="s3">\\\\</span><span class="s1">`</span><span class="s3">\\\\</span><span class="s1">{</span><span class="s3">\\\\</span><span class="s1">|</span><span class="s3">\\\\</span><span class="s1">}</span><span class="s3">\\\\</span><span class="s1">~]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">//const WSP$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x20</span><span class="s3">\\\\</span><span class="s1">x09]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">//const OBS_QTEXT$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x01-</span><span class="s3">\\\\</span><span class="s1">x08</span><span class="s3">\\\\</span><span class="s1">x0B</span><span class="s3">\\\\</span><span class="s1">x0C</span><span class="s3">\\\\</span><span class="s1">x0E-</span><span class="s3">\\\\</span><span class="s1">x1F</span><span class="s3">\\\\</span><span class="s1">x7F]</span><span class="s3">\&quot;</span><span class="s1">;  //(%d1-8 / %d11-12 / %d14-31 / %d127)</span><span class="s3">\n</span><span class="s1">//const QTEXT$$ = merge(</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x21</span><span class="s3">\\\\</span><span class="s1">x23-</span><span class="s3">\\\\</span><span class="s1">x5B</span><span class="s3">\\\\</span><span class="s1">x5D-</span><span class="s3">\\\\</span><span class="s1">x7E]</span><span class="s3">\&quot;</span><span class="s1">, OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext</span><span class="s3">\n</span><span class="s1">//const VCHAR$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x21-</span><span class="s3">\\\\</span><span class="s1">x7E]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">//const WSP$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x20</span><span class="s3">\\\\</span><span class="s1">x09]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">//const OBS_QP$ = subexp(</span><span class="s3">\&quot;\\\\\\\\\&quot; </span><span class="s1">+ merge(</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x00</span><span class="s3">\\\\</span><span class="s1">x0D</span><span class="s3">\\\\</span><span class="s1">x0A]</span><span class="s3">\&quot;</span><span class="s1">, OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext</span><span class="s3">\n</span><span class="s1">//const FWS$ = subexp(subexp(WSP$$ + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot; </span><span class="s1">+ </span><span class="s3">\&quot;\\\\</span><span class="s1">x0D</span><span class="s3">\\\\</span><span class="s1">x0A</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ WSP$$ + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">//const QUOTED_PAIR$ = subexp(subexp(</span><span class="s3">\&quot;\\\\\\\\\&quot; </span><span class="s1">+ subexp(VCHAR$$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ WSP$$)) + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ OBS_QP$);</span><span class="s3">\n</span><span class="s1">//const QUOTED_STRING$ = subexp('</span><span class="s3">\\\\\&quot;</span><span class="s1">' + subexp(FWS$ + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ QCONTENT$) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot; </span><span class="s1">+ FWS$ + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ '</span><span class="s3">\\\\\&quot;</span><span class="s1">');</span><span class="s3">\n</span><span class="s1">const ATEXT$$ = </span><span class="s3">\&quot;</span><span class="s1">[A-Za-z0-9</span><span class="s3">\\\\</span><span class="s1">!</span><span class="s3">\\\\</span><span class="s1">$</span><span class="s3">\\\\</span><span class="s1">%</span><span class="s3">\\\\</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">*</span><span class="s3">\\\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">-</span><span class="s3">\\\\</span><span class="s1">^</span><span class="s3">\\\\</span><span class="s1">_</span><span class="s3">\\\\</span><span class="s1">`</span><span class="s3">\\\\</span><span class="s1">{</span><span class="s3">\\\\</span><span class="s1">|</span><span class="s3">\\\\</span><span class="s1">}</span><span class="s3">\\\\</span><span class="s1">~]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const QTEXT$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">!</span><span class="s3">\\\\</span><span class="s1">$</span><span class="s3">\\\\</span><span class="s1">%</span><span class="s3">\\\\</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">)</span><span class="s3">\\\\</span><span class="s1">*</span><span class="s3">\\\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">,</span><span class="s3">\\\\</span><span class="s1">-</span><span class="s3">\\\\</span><span class="s1">.0-9</span><span class="s3">\\\\</span><span class="s1">&lt;</span><span class="s3">\\\\</span><span class="s1">&gt;A-Z</span><span class="s3">\\\\</span><span class="s1">x5E-</span><span class="s3">\\\\</span><span class="s1">x7E]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const VCHAR$$ = merge(QTEXT$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\\\\&quot;\\\\\\\\</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const DOT_ATOM_TEXT$ = subexp(ATEXT$$ + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot; </span><span class="s1">+ subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">+ ATEXT$$ + </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const QUOTED_PAIR$ = subexp(</span><span class="s3">\&quot;\\\\\\\\\&quot; </span><span class="s1">+ VCHAR$$);</span><span class="s3">\n</span><span class="s1">const QCONTENT$ = subexp(QTEXT$$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ QUOTED_PAIR$);</span><span class="s3">\n</span><span class="s1">const QUOTED_STRING$ = subexp('</span><span class="s3">\\\\\&quot;</span><span class="s1">' + QCONTENT$ + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot; </span><span class="s1">+ '</span><span class="s3">\\\\\&quot;</span><span class="s1">');</span><span class="s3">\n\n</span><span class="s1">//RFC 6068</span><span class="s3">\n</span><span class="s1">const DTEXT_NO_OBS$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">x21-</span><span class="s3">\\\\</span><span class="s1">x5A</span><span class="s3">\\\\</span><span class="s1">x5E-</span><span class="s3">\\\\</span><span class="s1">x7E]</span><span class="s3">\&quot;</span><span class="s1">;  //%d33-90 / %d94-126</span><span class="s3">\n</span><span class="s1">const SOME_DELIMS$$ = </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">!</span><span class="s3">\\\\</span><span class="s1">$</span><span class="s3">\\\\</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">)</span><span class="s3">\\\\</span><span class="s1">*</span><span class="s3">\\\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">,</span><span class="s3">\\\\</span><span class="s1">;</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">@]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const QCHAR$ = subexp(UNRESERVED$$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ PCT_ENCODED$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ SOME_DELIMS$$);</span><span class="s3">\n</span><span class="s1">const DOMAIN$ = subexp(DOT_ATOM_TEXT$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ </span><span class="s3">\&quot;\\\\</span><span class="s1">[</span><span class="s3">\&quot; </span><span class="s1">+ DTEXT_NO_OBS$$ + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot; </span><span class="s1">+ </span><span class="s3">\&quot;\\\\</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ QUOTED_STRING$);</span><span class="s3">\n</span><span class="s1">const ADDR_SPEC$ = subexp(LOCAL_PART$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">@</span><span class="s3">\&quot; </span><span class="s1">+ DOMAIN$);</span><span class="s3">\n</span><span class="s1">const TO$ = subexp(ADDR_SPEC$ + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ ADDR_SPEC$) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const HFNAME$ = subexp(QCHAR$ + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const HFVALUE$ = HFNAME$;</span><span class="s3">\n</span><span class="s1">const HFIELD$ = subexp(HFNAME$ + </span><span class="s3">\&quot;\\\\</span><span class="s1">=</span><span class="s3">\&quot; </span><span class="s1">+ HFVALUE$);</span><span class="s3">\n</span><span class="s1">const HFIELDS2$ = subexp(HFIELD$ + subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">&amp;</span><span class="s3">\&quot; </span><span class="s1">+ HFIELD$) + </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const HFIELDS$ = subexp(</span><span class="s3">\&quot;\\\\</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ HFIELDS2$);</span><span class="s3">\n</span><span class="s1">const MAILTO_URI = new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^mailto</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ TO$ + </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">+ HFIELDS$ + </span><span class="s3">\&quot;</span><span class="s1">?$</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">const UNRESERVED = new RegExp(UNRESERVED$$, </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const PCT_ENCODED = new RegExp(PCT_ENCODED$, </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const NOT_LOCAL_PART = new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^]</span><span class="s3">\&quot;</span><span class="s1">, ATEXT$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">.]</span><span class="s3">\&quot;</span><span class="s1">, '[</span><span class="s3">\\\\\&quot;</span><span class="s1">]', VCHAR$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const NOT_DOMAIN = new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^]</span><span class="s3">\&quot;</span><span class="s1">, ATEXT$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">.]</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">[]</span><span class="s3">\&quot;</span><span class="s1">, DTEXT_NO_OBS$$, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">]]</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const NOT_HFNAME = new RegExp(merge(</span><span class="s3">\&quot;</span><span class="s1">[^]</span><span class="s3">\&quot;</span><span class="s1">, UNRESERVED$$, SOME_DELIMS$$), </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const NOT_HFVALUE = NOT_HFNAME;</span><span class="s3">\n</span><span class="s1">const TO = new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot; </span><span class="s1">+ TO$ + </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const HFIELDS = new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot; </span><span class="s1">+ HFIELDS2$ + </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">function decodeUnreserved(str:string):string {</span><span class="s3">\n\t</span><span class="s1">const decStr = pctDecChars(str);</span><span class="s3">\n\t</span><span class="s1">return (!decStr.match(UNRESERVED) ? str : decStr);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const handler:URISchemeHandler&lt;MailtoComponents&gt; =  {</span><span class="s3">\n\t</span><span class="s1">scheme : </span><span class="s3">\&quot;</span><span class="s1">mailto</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n\t</span><span class="s1">parse : function (components:URIComponents, options:URIOptions):MailtoComponents {</span><span class="s3">\n\t\t</span><span class="s1">const mailtoComponents = components as MailtoComponents;</span><span class="s3">\n\t\t</span><span class="s1">const to = mailtoComponents.to = (mailtoComponents.path ? mailtoComponents.path.split(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) : []);</span><span class="s3">\n\t\t</span><span class="s1">mailtoComponents.path = undefined;</span><span class="s3">\n\n\t\t</span><span class="s1">if (mailtoComponents.query) {</span><span class="s3">\n\t\t\t</span><span class="s1">let unknownHeaders = false</span><span class="s3">\n\t\t\t</span><span class="s1">const headers:MailtoHeaders = {};</span><span class="s3">\n\t\t\t</span><span class="s1">const hfields = mailtoComponents.query.split(</span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n\t\t\t</span><span class="s1">for (let x = 0, xl = hfields.length; x &lt; xl; ++x) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const hfield = hfields[x].split(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">switch (hfield[0]) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">to</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">const toAddrs = hfield[1].split(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">for (let x = 0, xl = toAddrs.length; x &lt; xl; ++x) {</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">to.push(toAddrs[x]);</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">subject</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">mailtoComponents.subject = unescapeComponent(hfield[1], options);</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">mailtoComponents.body = unescapeComponent(hfield[1], options);</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">default:</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">unknownHeaders = true;</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">break;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (unknownHeaders) mailtoComponents.headers = headers;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">mailtoComponents.query = undefined;</span><span class="s3">\n\n\t\t</span><span class="s1">for (let x = 0, xl = to.length; x &lt; xl; ++x) {</span><span class="s3">\n\t\t\t</span><span class="s1">const addr = to[x].split(</span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n\t\t\t</span><span class="s1">addr[0] = unescapeComponent(addr[0]);</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (!options.unicodeSupport) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">//convert Unicode IDN -&gt; ASCII IDN</span><span class="s3">\n\t\t\t\t</span><span class="s1">try {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());</span><span class="s3">\n\t\t\t\t</span><span class="s1">} catch (e) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">mailtoComponents.error = mailtoComponents.error || </span><span class="s3">\&quot;</span><span class="s1">Email address's domain name can not be converted to ASCII via punycode: </span><span class="s3">\&quot; </span><span class="s1">+ e;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">addr[1] = unescapeComponent(addr[1], options).toLowerCase();</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">to[x] = addr.join(</span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return mailtoComponents;</span><span class="s3">\n\t</span><span class="s1">},</span><span class="s3">\n\n\t</span><span class="s1">serialize : function (mailtoComponents:MailtoComponents, options:URIOptions):URIComponents {</span><span class="s3">\n\t\t</span><span class="s1">const components = mailtoComponents as URIComponents;</span><span class="s3">\n\t\t</span><span class="s1">const to = toArray(mailtoComponents.to);</span><span class="s3">\n\t\t</span><span class="s1">if (to) {</span><span class="s3">\n\t\t\t</span><span class="s1">for (let x = 0, xl = to.length; x &lt; xl; ++x) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const toAddr = String(to[x]);</span><span class="s3">\n\t\t\t\t</span><span class="s1">const atIdx = toAddr.lastIndexOf(</span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t\t\t</span><span class="s1">const localPart = (toAddr.slice(0, atIdx)).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);</span><span class="s3">\n\t\t\t\t</span><span class="s1">let domain = toAddr.slice(atIdx + 1);</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">//convert IDN via punycode</span><span class="s3">\n\t\t\t\t</span><span class="s1">try {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">domain = (!options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain));</span><span class="s3">\n\t\t\t\t</span><span class="s1">} catch (e) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">components.error = components.error || </span><span class="s3">\&quot;</span><span class="s1">Email address's domain name can not be converted to </span><span class="s3">\&quot; </span><span class="s1">+ (!options.iri ? </span><span class="s3">\&quot;</span><span class="s1">ASCII</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">Unicode</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot; </span><span class="s1">via punycode: </span><span class="s3">\&quot; </span><span class="s1">+ e;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t\t</span><span class="s1">to[x] = localPart + </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot; </span><span class="s1">+ domain;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t\t</span><span class="s1">components.path = to.join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">const headers = mailtoComponents.headers = mailtoComponents.headers || {};</span><span class="s3">\n\n\t\t</span><span class="s1">if (mailtoComponents.subject) headers[</span><span class="s3">\&quot;</span><span class="s1">subject</span><span class="s3">\&quot;</span><span class="s1">] = mailtoComponents.subject;</span><span class="s3">\n\t\t</span><span class="s1">if (mailtoComponents.body) headers[</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">] = mailtoComponents.body;</span><span class="s3">\n\n\t\t</span><span class="s1">const fields = [];</span><span class="s3">\n\t\t</span><span class="s1">for (const name in headers) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (headers[name] !== O[name]) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">fields.push(</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) +</span><span class="s3">\n\t\t\t\t\t\&quot;</span><span class="s1">=</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar)</span><span class="s3">\n\t\t\t\t</span><span class="s1">);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">if (fields.length) {</span><span class="s3">\n\t\t\t</span><span class="s1">components.query = fields.join(</span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return components;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default handler;&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URIRegExps } from </span><span class="s3">\&quot;</span><span class="s1">./uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { buildExps } from </span><span class="s3">\&quot;</span><span class="s1">./regexps-uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export default buildExps(true);</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URISchemeHandler, URIComponents, URIOptions } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const handler:URISchemeHandler = {</span><span class="s3">\n\t</span><span class="s1">scheme : </span><span class="s3">\&quot;</span><span class="s1">http</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n\t</span><span class="s1">domainHost : true,</span><span class="s3">\n\n\t</span><span class="s1">parse : function (components:URIComponents, options:URIOptions):URIComponents {</span><span class="s3">\n\t\t</span><span class="s1">//report missing host</span><span class="s3">\n\t\t</span><span class="s1">if (!components.host) {</span><span class="s3">\n\t\t\t</span><span class="s1">components.error = components.error || </span><span class="s3">\&quot;</span><span class="s1">HTTP URIs must have a host.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return components;</span><span class="s3">\n\t</span><span class="s1">},</span><span class="s3">\n\n\t</span><span class="s1">serialize : function (components:URIComponents, options:URIOptions):URIComponents {</span><span class="s3">\n\t\t</span><span class="s1">const secure = String(components.scheme).toLowerCase() === </span><span class="s3">\&quot;</span><span class="s1">https</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\t\t</span><span class="s1">//normalize the default port</span><span class="s3">\n\t\t</span><span class="s1">if (components.port === (secure ? 443 : 80) || components.port === </span><span class="s3">\&quot;\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t\t</span><span class="s1">components.port = undefined;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\n\t\t</span><span class="s1">//normalize the empty path</span><span class="s3">\n\t\t</span><span class="s1">if (!components.path) {</span><span class="s3">\n\t\t\t</span><span class="s1">components.path = </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">//NOTE: We do not parse query strings for HTTP URIs</span><span class="s3">\n\t\t</span><span class="s1">//as WWW Form Url Encoded query strings are part of the HTML4+ spec,</span><span class="s3">\n\t\t</span><span class="s1">//and not the HTTP spec.</span><span class="s3">\n\n\t\t</span><span class="s1">return components;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default handler;&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URISchemeHandler, URIComponents, URIOptions } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import http from </span><span class="s3">\&quot;</span><span class="s1">./http</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const handler:URISchemeHandler = {</span><span class="s3">\n\t</span><span class="s1">scheme : </span><span class="s3">\&quot;</span><span class="s1">https</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t</span><span class="s1">domainHost : http.domainHost,</span><span class="s3">\n\t</span><span class="s1">parse : http.parse,</span><span class="s3">\n\t</span><span class="s1">serialize : http.serialize</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default handler;&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URISchemeHandler, URIComponents, URIOptions } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import ws from </span><span class="s3">\&quot;</span><span class="s1">./ws</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const handler:URISchemeHandler = {</span><span class="s3">\n\t</span><span class="s1">scheme : </span><span class="s3">\&quot;</span><span class="s1">wss</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t</span><span class="s1">domainHost : ws.domainHost,</span><span class="s3">\n\t</span><span class="s1">parse : ws.parse,</span><span class="s3">\n\t</span><span class="s1">serialize : ws.serialize</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default handler;&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URISchemeHandler, URIComponents, URIOptions } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { pctEncChar, SCHEMES } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export interface URNComponents extends URIComponents {</span><span class="s3">\n\t</span><span class="s1">nid?:string;</span><span class="s3">\n\t</span><span class="s1">nss?:string;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface URNOptions extends URIOptions {</span><span class="s3">\n\t</span><span class="s1">nid?:string;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const NID$ = </span><span class="s3">\&quot;</span><span class="s1">(?:[0-9A-Za-z][0-9A-Za-z</span><span class="s3">\\\\</span><span class="s1">-]{1,31})</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const PCT_ENCODED$ = </span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\\\\</span><span class="s1">%[0-9A-Fa-f]{2})</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const TRANS$$ = </span><span class="s3">\&quot;</span><span class="s1">[0-9A-Za-z</span><span class="s3">\\\\</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">)</span><span class="s3">\\\\</span><span class="s1">+</span><span class="s3">\\\\</span><span class="s1">,</span><span class="s3">\\\\</span><span class="s1">-</span><span class="s3">\\\\</span><span class="s1">.</span><span class="s3">\\\\</span><span class="s1">:</span><span class="s3">\\\\</span><span class="s1">=</span><span class="s3">\\\\</span><span class="s1">@</span><span class="s3">\\\\</span><span class="s1">;</span><span class="s3">\\\\</span><span class="s1">$</span><span class="s3">\\\\</span><span class="s1">_</span><span class="s3">\\\\</span><span class="s1">!</span><span class="s3">\\\\</span><span class="s1">*</span><span class="s3">\\\\</span><span class="s1">'</span><span class="s3">\\\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">?</span><span class="s3">\\\\</span><span class="s1">#]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const NSS$ = </span><span class="s3">\&quot;</span><span class="s1">(?:(?:</span><span class="s3">\&quot; </span><span class="s1">+ PCT_ENCODED$ + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ TRANS$$ + </span><span class="s3">\&quot;</span><span class="s1">)+)</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const URN_SCHEME = new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^urn</span><span class="s3">\\\\</span><span class="s1">:(</span><span class="s3">\&quot; </span><span class="s1">+ NID$ + </span><span class="s3">\&quot;</span><span class="s1">)$</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const URN_PATH = new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^(</span><span class="s3">\&quot; </span><span class="s1">+ NID$ + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\\\\</span><span class="s1">:(</span><span class="s3">\&quot; </span><span class="s1">+ NSS$ + </span><span class="s3">\&quot;</span><span class="s1">)$</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const URN_PARSE = /^([^</span><span class="s3">\\</span><span class="s1">:]+)</span><span class="s3">\\</span><span class="s1">:(.*)/;</span><span class="s3">\n</span><span class="s1">const URN_EXCLUDED = /[</span><span class="s3">\\</span><span class="s1">x00-</span><span class="s3">\\</span><span class="s1">x20</span><span class="s3">\\\\\\\&quot;\\</span><span class="s1">&amp;</span><span class="s3">\\</span><span class="s1">&lt;</span><span class="s3">\\</span><span class="s1">&gt;</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">^</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">{</span><span class="s3">\\</span><span class="s1">|</span><span class="s3">\\</span><span class="s1">}</span><span class="s3">\\</span><span class="s1">~</span><span class="s3">\\</span><span class="s1">x7F-</span><span class="s3">\\</span><span class="s1">xFF]/g;</span><span class="s3">\n\n</span><span class="s1">//RFC 2141</span><span class="s3">\n</span><span class="s1">const handler:URISchemeHandler&lt;URNComponents,URNOptions&gt; = {</span><span class="s3">\n\t</span><span class="s1">scheme : </span><span class="s3">\&quot;</span><span class="s1">urn</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n\t</span><span class="s1">parse : function (components:URIComponents, options:URNOptions):URNComponents {</span><span class="s3">\n\t\t</span><span class="s1">const matches = components.path &amp;&amp; components.path.match(URN_PARSE);</span><span class="s3">\n\t\t</span><span class="s1">let urnComponents = components as URNComponents;</span><span class="s3">\n\n\t\t</span><span class="s1">if (matches) {</span><span class="s3">\n\t\t\t</span><span class="s1">const scheme = options.scheme || urnComponents.scheme || </span><span class="s3">\&quot;</span><span class="s1">urn</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t\t</span><span class="s1">const nid = matches[1].toLowerCase();</span><span class="s3">\n\t\t\t</span><span class="s1">const nss = matches[2];</span><span class="s3">\n\t\t\t</span><span class="s1">const urnScheme = `${scheme}:${options.nid || nid}`;</span><span class="s3">\n\t\t\t</span><span class="s1">const schemeHandler = SCHEMES[urnScheme];</span><span class="s3">\n\n\t\t\t</span><span class="s1">urnComponents.nid = nid;</span><span class="s3">\n\t\t\t</span><span class="s1">urnComponents.nss = nss;</span><span class="s3">\n\t\t\t</span><span class="s1">urnComponents.path = undefined;</span><span class="s3">\n\n\t\t\t</span><span class="s1">if (schemeHandler) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">urnComponents = schemeHandler.parse(urnComponents, options) as URNComponents;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">urnComponents.error = urnComponents.error || </span><span class="s3">\&quot;</span><span class="s1">URN can not be parsed.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return urnComponents;</span><span class="s3">\n\t</span><span class="s1">},</span><span class="s3">\n\n\t</span><span class="s1">serialize : function (urnComponents:URNComponents, options:URNOptions):URIComponents {</span><span class="s3">\n\t\t</span><span class="s1">const scheme = options.scheme || urnComponents.scheme || </span><span class="s3">\&quot;</span><span class="s1">urn</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">const nid = urnComponents.nid;</span><span class="s3">\n\t\t</span><span class="s1">const urnScheme = `${scheme}:${options.nid || nid}`;</span><span class="s3">\n\t\t</span><span class="s1">const schemeHandler = SCHEMES[urnScheme];</span><span class="s3">\n\n\t\t</span><span class="s1">if (schemeHandler) {</span><span class="s3">\n\t\t\t</span><span class="s1">urnComponents = schemeHandler.serialize(urnComponents, options) as URNComponents;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">const uriComponents = urnComponents as URIComponents;</span><span class="s3">\n\t\t</span><span class="s1">const nss = urnComponents.nss;</span><span class="s3">\n\t\t</span><span class="s1">uriComponents.path = `${nid || options.nid}:${nss}`;</span><span class="s3">\n\n\t\t</span><span class="s1">return uriComponents;</span><span class="s3">\n\t</span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default handler;&quot;</span><span class="s0">,</span><span class="s1">&quot;import { URISchemeHandler, URIComponents, URIOptions } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { URNComponents } from </span><span class="s3">\&quot;</span><span class="s1">./urn</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { SCHEMES } from </span><span class="s3">\&quot;</span><span class="s1">../uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export interface UUIDComponents extends URNComponents {</span><span class="s3">\n\t</span><span class="s1">uuid?: string;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const UUID = /^[0-9A-Fa-f]{8}(?:</span><span class="s3">\\</span><span class="s1">-[0-9A-Fa-f]{4}){3}</span><span class="s3">\\</span><span class="s1">-[0-9A-Fa-f]{12}$/;</span><span class="s3">\n</span><span class="s1">const UUID_PARSE = /^[0-9A-Fa-f</span><span class="s3">\\</span><span class="s1">-]{36}/;</span><span class="s3">\n\n</span><span class="s1">//RFC 4122</span><span class="s3">\n</span><span class="s1">const handler:URISchemeHandler&lt;UUIDComponents, URIOptions, URNComponents&gt; = {</span><span class="s3">\n\t</span><span class="s1">scheme : </span><span class="s3">\&quot;</span><span class="s1">urn:uuid</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n\t</span><span class="s1">parse : function (urnComponents:URNComponents, options:URIOptions):UUIDComponents {</span><span class="s3">\n\t\t</span><span class="s1">const uuidComponents = urnComponents as UUIDComponents;</span><span class="s3">\n\t\t</span><span class="s1">uuidComponents.uuid = uuidComponents.nss;</span><span class="s3">\n\t\t</span><span class="s1">uuidComponents.nss = undefined;</span><span class="s3">\n\n\t\t</span><span class="s1">if (!options.tolerant &amp;&amp; (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {</span><span class="s3">\n\t\t\t</span><span class="s1">uuidComponents.error = uuidComponents.error || </span><span class="s3">\&quot;</span><span class="s1">UUID is not valid.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\n\t\t</span><span class="s1">return uuidComponents;</span><span class="s3">\n\t</span><span class="s1">},</span><span class="s3">\n\n\t</span><span class="s1">serialize : function (uuidComponents:UUIDComponents, options:URIOptions):URNComponents {</span><span class="s3">\n\t\t</span><span class="s1">const urnComponents = uuidComponents as URNComponents;</span><span class="s3">\n\t\t</span><span class="s1">//normalize UUID</span><span class="s3">\n\t\t</span><span class="s1">urnComponents.nss = (uuidComponents.uuid || </span><span class="s3">\&quot;\&quot;</span><span class="s1">).toLowerCase();</span><span class="s3">\n\t\t</span><span class="s1">return urnComponents;</span><span class="s3">\n\t</span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default handler;&quot;</span><span class="s0">,</span><span class="s1">&quot;import { SCHEMES } from </span><span class="s3">\&quot;</span><span class="s1">./uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import http from </span><span class="s3">\&quot;</span><span class="s1">./schemes/http</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">SCHEMES[http.scheme] = http;</span><span class="s3">\n\n</span><span class="s1">import https from </span><span class="s3">\&quot;</span><span class="s1">./schemes/https</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">SCHEMES[https.scheme] = https;</span><span class="s3">\n\n</span><span class="s1">import ws from </span><span class="s3">\&quot;</span><span class="s1">./schemes/ws</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">SCHEMES[ws.scheme] = ws;</span><span class="s3">\n\n</span><span class="s1">import wss from </span><span class="s3">\&quot;</span><span class="s1">./schemes/wss</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">SCHEMES[wss.scheme] = wss;</span><span class="s3">\n\n</span><span class="s1">import mailto from </span><span class="s3">\&quot;</span><span class="s1">./schemes/mailto</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">SCHEMES[mailto.scheme] = mailto;</span><span class="s3">\n\n</span><span class="s1">import urn from </span><span class="s3">\&quot;</span><span class="s1">./schemes/urn</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">SCHEMES[urn.scheme] = urn;</span><span class="s3">\n\n</span><span class="s1">import uuid from </span><span class="s3">\&quot;</span><span class="s1">./schemes/urn-uuid</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">SCHEMES[uuid.scheme] = uuid;</span><span class="s3">\n\n</span><span class="s1">export * from </span><span class="s3">\&quot;</span><span class="s1">./uri</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">]}</span></pre>
</body>
</html>