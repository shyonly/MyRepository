<html>
<head>
<title>conversion.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
conversion.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperEnvironmentVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperFunctionName&quot;</span><span class="s0">,</span><span class="s1">&quot;_visitors&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;binaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;conditionalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;logicalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;LOGICAL_OPERATORS&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;metaProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;numericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;objectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;restElement&quot;</span><span class="s0">,</span><span class="s1">&quot;returnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;spreadElement&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;super&quot;</span><span class="s0">,</span><span class="s1">&quot;_super&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;toExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;unaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;toComputedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;isProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferenceError&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyNode&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;isBlockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;statements&quot;</span><span class="s0">,</span><span class="s1">&quot;stringPath&quot;</span><span class="s0">,</span><span class="s1">&quot;listKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;setup&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionToShadowed&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionToExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;unwrapFunctionEnvironment&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;hoistFunctionEnvironment&quot;</span><span class="s0">,</span><span class="s1">&quot;setType&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;allowInsertArrow&quot;</span><span class="s0">,</span><span class="s1">&quot;allowInsertArrowWithRest&quot;</span><span class="s0">,</span><span class="s1">&quot;noNewArrows&quot;</span><span class="s0">,</span><span class="s1">&quot;_arguments$&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;specCompliant&quot;</span><span class="s0">,</span><span class="s1">&quot;thisBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;fnPath&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;checkBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;unshiftContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;hub&quot;</span><span class="s0">,</span><span class="s1">&quot;addHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;nameFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;getSuperCallsVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;mergeVisitors&quot;</span><span class="s0">,</span><span class="s1">&quot;CallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;child&quot;</span><span class="s0">,</span><span class="s1">&quot;allSuperCalls&quot;</span><span class="s0">,</span><span class="s1">&quot;isSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;environmentVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowParent&quot;</span><span class="s0">,</span><span class="s1">&quot;thisEnvFn&quot;</span><span class="s0">,</span><span class="s1">&quot;findParent&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;_arrowParent&quot;</span><span class="s0">,</span><span class="s1">&quot;isProgram&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;static&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassPrivateProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;inConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;thisPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;argumentsPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;newTargetPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;superProps&quot;</span><span class="s0">,</span><span class="s1">&quot;superCalls&quot;</span><span class="s0">,</span><span class="s1">&quot;getScopeInformation&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;superBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;getSuperBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;superCall&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;argumentsBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;getBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;buildUndefinedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;argumentsChild&quot;</span><span class="s0">,</span><span class="s1">&quot;argsRef&quot;</span><span class="s0">,</span><span class="s1">&quot;newTargetBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;targetChild&quot;</span><span class="s0">,</span><span class="s1">&quot;targetRef&quot;</span><span class="s0">,</span><span class="s1">&quot;flatSuperProps&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;acc&quot;</span><span class="s0">,</span><span class="s1">&quot;superProp&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;standardizeSuperProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;superParentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignment&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;isCall&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isTaggedTemplate&quot;</span><span class="s0">,</span><span class="s1">&quot;isTaggedTemplateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;getSuperPropBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;getThisBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;hasSuperClass&quot;</span><span class="s0">,</span><span class="s1">&quot;thisChild&quot;</span><span class="s0">,</span><span class="s1">&quot;thisRef&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSX&quot;</span><span class="s0">,</span><span class="s1">&quot;isLogicalOp&quot;</span><span class="s0">,</span><span class="s1">&quot;op&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;isLogicalAssignment&quot;</span><span class="s0">,</span><span class="s1">&quot;tmp&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDeclaredUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;rightExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isUpdateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;updateExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;computedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parts&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;assignSuperThisVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;supers&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWithMultiple&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakSet&quot;</span><span class="s0">,</span><span class="s1">&quot;argsBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;propName&quot;</span><span class="s0">,</span><span class="s1">&quot;argsList&quot;</span><span class="s0">,</span><span class="s1">&quot;fnBody&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;valueIdent&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;getData&quot;</span><span class="s0">,</span><span class="s1">&quot;setData&quot;</span><span class="s0">,</span><span class="s1">&quot;getScopeInformationVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;ThisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXOpeningElement&quot;</span><span class="s0">,</span><span class="s1">&quot;MemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;curr&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;rename&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;MetaProperty&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/path/conversion.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// This file contains methods that convert the path node into another node or some other type of data.</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">arrowFunctionExpression,</span><span class="s3">\n  </span><span class="s1">assignmentExpression,</span><span class="s3">\n  </span><span class="s1">binaryExpression,</span><span class="s3">\n  </span><span class="s1">blockStatement,</span><span class="s3">\n  </span><span class="s1">callExpression,</span><span class="s3">\n  </span><span class="s1">conditionalExpression,</span><span class="s3">\n  </span><span class="s1">expressionStatement,</span><span class="s3">\n  </span><span class="s1">identifier,</span><span class="s3">\n  </span><span class="s1">isIdentifier,</span><span class="s3">\n  </span><span class="s1">jsxIdentifier,</span><span class="s3">\n  </span><span class="s1">logicalExpression,</span><span class="s3">\n  </span><span class="s1">LOGICAL_OPERATORS,</span><span class="s3">\n  </span><span class="s1">memberExpression,</span><span class="s3">\n  </span><span class="s1">metaProperty,</span><span class="s3">\n  </span><span class="s1">numericLiteral,</span><span class="s3">\n  </span><span class="s1">objectExpression,</span><span class="s3">\n  </span><span class="s1">restElement,</span><span class="s3">\n  </span><span class="s1">returnStatement,</span><span class="s3">\n  </span><span class="s1">sequenceExpression,</span><span class="s3">\n  </span><span class="s1">spreadElement,</span><span class="s3">\n  </span><span class="s1">stringLiteral,</span><span class="s3">\n  </span><span class="s1">super as _super,</span><span class="s3">\n  </span><span class="s1">thisExpression,</span><span class="s3">\n  </span><span class="s1">toExpression,</span><span class="s3">\n  </span><span class="s1">unaryExpression,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import environmentVisitor from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-environment-visitor</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import nameFunction from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-function-name</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { merge as mergeVisitors } from </span><span class="s3">\&quot;</span><span class="s1">../visitors.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type NodePath from </span><span class="s3">\&quot;</span><span class="s1">./index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export function toComputedKey(this: NodePath) {</span><span class="s3">\n  </span><span class="s1">let key;</span><span class="s3">\n  </span><span class="s1">if (this.isMemberExpression()) {</span><span class="s3">\n    </span><span class="s1">key = this.node.property;</span><span class="s3">\n  </span><span class="s1">} else if (this.isProperty() || this.isMethod()) {</span><span class="s3">\n    </span><span class="s1">key = this.node.key;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw new ReferenceError(</span><span class="s3">\&quot;</span><span class="s1">todo</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) computed does not exist in ClassPrivateProperty</span><span class="s3">\n  </span><span class="s1">if (!this.node.computed) {</span><span class="s3">\n    </span><span class="s1">if (isIdentifier(key)) key = stringLiteral(key.name);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return key;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ensureBlock(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;</span><span class="s3">\n    </span><span class="s1">t.Loop | t.WithStatement | t.Function | t.LabeledStatement | t.CatchClause</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const body = this.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const bodyNode = body.node;</span><span class="s3">\n\n  </span><span class="s1">if (Array.isArray(body)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Can't convert array path to a block statement</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!bodyNode) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Can't convert node without a body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (body.isBlockStatement()) {</span><span class="s3">\n    </span><span class="s1">return bodyNode;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const statements: Array&lt;t.Statement&gt; = [];</span><span class="s3">\n\n  </span><span class="s1">let stringPath = </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">let key;</span><span class="s3">\n  </span><span class="s1">let listKey;</span><span class="s3">\n  </span><span class="s1">if (body.isStatement()) {</span><span class="s3">\n    </span><span class="s1">listKey = </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">key = 0;</span><span class="s3">\n    </span><span class="s1">statements.push(body.node);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">stringPath += </span><span class="s3">\&quot;</span><span class="s1">.body.0</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">if (this.isFunction()) {</span><span class="s3">\n      </span><span class="s1">key = </span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">statements.push(returnStatement(body.node as t.Expression));</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">key = </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">statements.push(expressionStatement(body.node as t.Expression));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.node.body = blockStatement(statements);</span><span class="s3">\n  </span><span class="s1">const parentPath = this.get(stringPath) as NodePath;</span><span class="s3">\n  </span><span class="s1">body.setup(</span><span class="s3">\n    </span><span class="s1">parentPath,</span><span class="s3">\n    </span><span class="s1">listKey</span><span class="s3">\n      </span><span class="s1">? // @ts-expect-error listKey must present in parent path</span><span class="s3">\n        </span><span class="s1">parentPath.node[listKey]</span><span class="s3">\n      </span><span class="s1">: parentPath.node,</span><span class="s3">\n    </span><span class="s1">listKey,</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">return this.node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">if (!process.env.BABEL_8_BREAKING &amp;&amp; !USE_ESM) {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Keeping this for backward-compatibility. You should use arrowFunctionToExpression() for &gt;=7.x.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-restricted-globals</span><span class="s3">\n  </span><span class="s1">exports.arrowFunctionToShadowed = function (this: NodePath) {</span><span class="s3">\n    </span><span class="s1">if (!this.isArrowFunctionExpression()) return;</span><span class="s3">\n\n    </span><span class="s1">this.arrowFunctionToExpression();</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Given an arbitrary function, process its content as if it were an arrow function, moving references</span><span class="s3">\n </span><span class="s1">* to </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">super</span><span class="s3">\&quot;</span><span class="s1">, and such into the function's parent scope. This method is useful if</span><span class="s3">\n </span><span class="s1">* you have wrapped some set of items in an IIFE or other function, but want </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">, and super</span><span class="s3">\&quot;\n </span><span class="s1">* to continue behaving as expected.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function unwrapFunctionEnvironment(this: NodePath) {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">!this.isArrowFunctionExpression() &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!this.isFunctionExpression() &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!this.isFunctionDeclaration()</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw this.buildCodeFrameError(</span><span class="s3">\n      \&quot;</span><span class="s1">Can only unwrap the environment of a function.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">hoistFunctionEnvironment(this);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function setType&lt;N extends t.Node, T extends N[</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">]&gt;(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;N&gt;,</span><span class="s3">\n  </span><span class="s1">type: T,</span><span class="s3">\n</span><span class="s1">): asserts path is NodePath&lt;Extract&lt;N, { type: T }&gt;&gt; {</span><span class="s3">\n  </span><span class="s1">path.node.type = type;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Convert a given arrow function into a normal ES5 function expression.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function arrowFunctionToExpression(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;t.ArrowFunctionExpression&gt;,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">allowInsertArrow = true,</span><span class="s3">\n    </span><span class="s1">allowInsertArrowWithRest = allowInsertArrow,</span><span class="s3">\n    </span><span class="s1">noNewArrows = process.env.BABEL_8_BREAKING</span><span class="s3">\n      </span><span class="s1">? // TODO(Babel 8): Consider defaulting to `false` for spec compliance</span><span class="s3">\n        </span><span class="s1">true</span><span class="s3">\n      </span><span class="s1">: !arguments[0]?.specCompliant,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">allowInsertArrow?: boolean | void;</span><span class="s3">\n    </span><span class="s1">allowInsertArrowWithRest?: boolean | void;</span><span class="s3">\n    </span><span class="s1">noNewArrows?: boolean;</span><span class="s3">\n  </span><span class="s1">} = {},</span><span class="s3">\n</span><span class="s1">): NodePath&lt;</span><span class="s3">\n  </span><span class="s1">Exclude&lt;t.Function, t.Method | t.ArrowFunctionExpression&gt; | t.CallExpression</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">if (!this.isArrowFunctionExpression()) {</span><span class="s3">\n    </span><span class="s1">throw (this as NodePath).buildCodeFrameError(</span><span class="s3">\n      \&quot;</span><span class="s1">Cannot convert non-arrow function to a function expression.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { thisBinding, fnPath: fn } = hoistFunctionEnvironment(</span><span class="s3">\n    </span><span class="s1">this,</span><span class="s3">\n    </span><span class="s1">noNewArrows,</span><span class="s3">\n    </span><span class="s1">allowInsertArrow,</span><span class="s3">\n    </span><span class="s1">allowInsertArrowWithRest,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error TS requires explicit fn type annotation</span><span class="s3">\n  </span><span class="s1">fn.ensureBlock();</span><span class="s3">\n  </span><span class="s1">setType(fn, </span><span class="s3">\&quot;</span><span class="s1">FunctionExpression</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">if (!noNewArrows) {</span><span class="s3">\n    </span><span class="s1">const checkBinding = thisBinding</span><span class="s3">\n      </span><span class="s1">? null</span><span class="s3">\n      </span><span class="s1">: fn.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">arrowCheckId</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (checkBinding) {</span><span class="s3">\n      </span><span class="s1">fn.parentPath.scope.push({</span><span class="s3">\n        </span><span class="s1">id: checkBinding,</span><span class="s3">\n        </span><span class="s1">init: objectExpression([]),</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">fn.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).unshiftContainer(</span><span class="s3">\n      \&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">expressionStatement(</span><span class="s3">\n        </span><span class="s1">callExpression(this.hub.addHelper(</span><span class="s3">\&quot;</span><span class="s1">newArrowCheck</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n          </span><span class="s1">thisExpression(),</span><span class="s3">\n          </span><span class="s1">checkBinding</span><span class="s3">\n            </span><span class="s1">? identifier(checkBinding.name)</span><span class="s3">\n            </span><span class="s1">: identifier(thisBinding),</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">fn.replaceWith(</span><span class="s3">\n      </span><span class="s1">callExpression(</span><span class="s3">\n        </span><span class="s1">memberExpression(</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error TS can't infer nameFunction returns CallExpression | ArrowFunctionExpression here</span><span class="s3">\n          </span><span class="s1">nameFunction(this, true) || fn.node,</span><span class="s3">\n          </span><span class="s1">identifier(</span><span class="s3">\&quot;</span><span class="s1">bind</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">[checkBinding ? identifier(checkBinding.name) : thisExpression()],</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">return fn.get(</span><span class="s3">\&quot;</span><span class="s1">callee.object</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return fn;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const getSuperCallsVisitor = mergeVisitors&lt;{</span><span class="s3">\n  </span><span class="s1">allSuperCalls: NodePath&lt;t.CallExpression&gt;[];</span><span class="s3">\n</span><span class="s1">}&gt;([</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">CallExpression(child, { allSuperCalls }) {</span><span class="s3">\n      </span><span class="s1">if (!child.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">).isSuper()) return;</span><span class="s3">\n      </span><span class="s1">allSuperCalls.push(child);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">environmentVisitor,</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Given a function, traverse its contents, and if there are references to </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">super</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n </span><span class="s1">* or </span><span class="s3">\&quot;</span><span class="s1">new.target</span><span class="s3">\&quot;</span><span class="s1">, ensure that these references reference the parent environment around this function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @returns `thisBinding`: the name of the injected reference to `this`; for example </span><span class="s3">\&quot;</span><span class="s1">_this</span><span class="s3">\&quot;\n </span><span class="s1">* @returns `fnPath`: the new path to the function node. This is different from the fnPath</span><span class="s3">\n </span><span class="s1">*                    parameter when the function node is wrapped in another node.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function hoistFunctionEnvironment(</span><span class="s3">\n  </span><span class="s1">fnPath: NodePath&lt;t.Function&gt;,</span><span class="s3">\n  </span><span class="s1">// TODO(Babel 8): Consider defaulting to `false` for spec compliance</span><span class="s3">\n  </span><span class="s1">noNewArrows: boolean | void = true,</span><span class="s3">\n  </span><span class="s1">allowInsertArrow: boolean | void = true,</span><span class="s3">\n  </span><span class="s1">allowInsertArrowWithRest: boolean | void = true,</span><span class="s3">\n</span><span class="s1">): { thisBinding: string; fnPath: NodePath&lt;t.Function&gt; } {</span><span class="s3">\n  </span><span class="s1">let arrowParent;</span><span class="s3">\n  </span><span class="s1">let thisEnvFn: NodePath&lt;t.Function&gt; = fnPath.findParent(p =&gt; {</span><span class="s3">\n    </span><span class="s1">if (p.isArrowFunctionExpression()) {</span><span class="s3">\n      </span><span class="s1">arrowParent ??= p;</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">p.isFunction() ||</span><span class="s3">\n      </span><span class="s1">p.isProgram() ||</span><span class="s3">\n      </span><span class="s1">p.isClassProperty({ static: false }) ||</span><span class="s3">\n      </span><span class="s1">p.isClassPrivateProperty({ static: false })</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}) as NodePath&lt;t.Function&gt;;</span><span class="s3">\n  </span><span class="s1">const inConstructor = thisEnvFn.isClassMethod({ kind: </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {</span><span class="s3">\n    </span><span class="s1">if (arrowParent) {</span><span class="s3">\n      </span><span class="s1">thisEnvFn = arrowParent;</span><span class="s3">\n    </span><span class="s1">} else if (allowInsertArrow) {</span><span class="s3">\n      </span><span class="s1">// It's safe to wrap this function in another and not hoist to the</span><span class="s3">\n      </span><span class="s1">// top level because the 'this' binding is constant in class</span><span class="s3">\n      </span><span class="s1">// properties (since 'super()' has already been called), so we don't</span><span class="s3">\n      </span><span class="s1">// need to capture/reassign it at the top level.</span><span class="s3">\n      </span><span class="s1">fnPath.replaceWith(</span><span class="s3">\n        </span><span class="s1">callExpression(</span><span class="s3">\n          </span><span class="s1">arrowFunctionExpression([], toExpression(fnPath.node)),</span><span class="s3">\n          </span><span class="s1">[],</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">thisEnvFn = fnPath.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.ArrowFunctionExpression&gt;;</span><span class="s3">\n      </span><span class="s1">fnPath = thisEnvFn.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.FunctionExpression&gt;;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">throw fnPath.buildCodeFrameError(</span><span class="s3">\n        \&quot;</span><span class="s1">Unable to transform arrow inside class property</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { thisPaths, argumentsPaths, newTargetPaths, superProps, superCalls } =</span><span class="s3">\n    </span><span class="s1">getScopeInformation(fnPath);</span><span class="s3">\n\n  </span><span class="s1">// Convert all super() calls in the constructor, if super is used in an arrow.</span><span class="s3">\n  </span><span class="s1">if (inConstructor &amp;&amp; superCalls.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">if (!allowInsertArrow) {</span><span class="s3">\n      </span><span class="s1">throw superCalls[0].buildCodeFrameError(</span><span class="s3">\n        \&quot;</span><span class="s1">When using '@babel/plugin-transform-arrow-functions', </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot;</span><span class="s1">it's not possible to compile `super()` in an arrow function without compiling classes.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot;</span><span class="s1">Please add '@babel/plugin-transform-classes' to your Babel configuration.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!allowInsertArrowWithRest) {</span><span class="s3">\n      </span><span class="s1">// preset-env with target `since 2017` enables `transform-parameters` without `transform-classes`.</span><span class="s3">\n      </span><span class="s1">throw superCalls[0].buildCodeFrameError(</span><span class="s3">\n        \&quot;</span><span class="s1">When using '@babel/plugin-transform-parameters', </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot;</span><span class="s1">it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot;</span><span class="s1">Please add '@babel/plugin-transform-classes' to your Babel configuration.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const allSuperCalls: NodePath&lt;t.CallExpression&gt;[] = [];</span><span class="s3">\n    </span><span class="s1">thisEnvFn.traverse(getSuperCallsVisitor, { allSuperCalls });</span><span class="s3">\n    </span><span class="s1">const superBinding = getSuperBinding(thisEnvFn);</span><span class="s3">\n    </span><span class="s1">allSuperCalls.forEach(superCall =&gt; {</span><span class="s3">\n      </span><span class="s1">const callee = identifier(superBinding);</span><span class="s3">\n      </span><span class="s1">callee.loc = superCall.node.callee.loc;</span><span class="s3">\n\n      </span><span class="s1">superCall.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">).replaceWith(callee);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Convert all </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot; </span><span class="s1">references in the arrow to point at the alias.</span><span class="s3">\n  </span><span class="s1">if (argumentsPaths.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">const argumentsBinding = getBinding(thisEnvFn, </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n      </span><span class="s1">const args = () =&gt; identifier(</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (thisEnvFn.scope.path.isProgram()) {</span><span class="s3">\n        </span><span class="s1">return conditionalExpression(</span><span class="s3">\n          </span><span class="s1">binaryExpression(</span><span class="s3">\n            \&quot;</span><span class="s1">===</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">unaryExpression(</span><span class="s3">\&quot;</span><span class="s1">typeof</span><span class="s3">\&quot;</span><span class="s1">, args()),</span><span class="s3">\n            </span><span class="s1">stringLiteral(</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">thisEnvFn.scope.buildUndefinedNode(),</span><span class="s3">\n          </span><span class="s1">args(),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return args();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">argumentsPaths.forEach(argumentsChild =&gt; {</span><span class="s3">\n      </span><span class="s1">const argsRef = identifier(argumentsBinding);</span><span class="s3">\n      </span><span class="s1">argsRef.loc = argumentsChild.node.loc;</span><span class="s3">\n\n      </span><span class="s1">argumentsChild.replaceWith(argsRef);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Convert all </span><span class="s3">\&quot;</span><span class="s1">new.target</span><span class="s3">\&quot; </span><span class="s1">references in the arrow to point at the alias.</span><span class="s3">\n  </span><span class="s1">if (newTargetPaths.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">const newTargetBinding = getBinding(thisEnvFn, </span><span class="s3">\&quot;</span><span class="s1">newtarget</span><span class="s3">\&quot;</span><span class="s1">, () =&gt;</span><span class="s3">\n      </span><span class="s1">metaProperty(identifier(</span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot;</span><span class="s1">), identifier(</span><span class="s3">\&quot;</span><span class="s1">target</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">newTargetPaths.forEach(targetChild =&gt; {</span><span class="s3">\n      </span><span class="s1">const targetRef = identifier(newTargetBinding);</span><span class="s3">\n      </span><span class="s1">targetRef.loc = targetChild.node.loc;</span><span class="s3">\n\n      </span><span class="s1">targetChild.replaceWith(targetRef);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Convert all </span><span class="s3">\&quot;</span><span class="s1">super.prop</span><span class="s3">\&quot; </span><span class="s1">references to point at aliases.</span><span class="s3">\n  </span><span class="s1">if (superProps.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">if (!allowInsertArrow) {</span><span class="s3">\n      </span><span class="s1">throw superProps[0].buildCodeFrameError(</span><span class="s3">\n        \&quot;</span><span class="s1">When using '@babel/plugin-transform-arrow-functions', </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot;</span><span class="s1">it's not possible to compile `super.prop` in an arrow function without compiling classes.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot;</span><span class="s1">Please add '@babel/plugin-transform-classes' to your Babel configuration.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const flatSuperProps: NodePath&lt;t.MemberExpression&gt;[] = superProps.reduce(</span><span class="s3">\n      </span><span class="s1">(acc, superProp) =&gt; acc.concat(standardizeSuperProperty(superProp)),</span><span class="s3">\n      </span><span class="s1">[],</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">flatSuperProps.forEach(superProp =&gt; {</span><span class="s3">\n      </span><span class="s1">const key = superProp.node.computed</span><span class="s3">\n        </span><span class="s1">? </span><span class="s3">\&quot;\&quot;\n        </span><span class="s1">: // @ts-expect-error super property must not contain private name</span><span class="s3">\n          </span><span class="s1">superProp.get(</span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">).node.name;</span><span class="s3">\n\n      </span><span class="s1">const superParentPath = superProp.parentPath;</span><span class="s3">\n\n      </span><span class="s1">const isAssignment = superParentPath.isAssignmentExpression({</span><span class="s3">\n        </span><span class="s1">left: superProp.node,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">const isCall = superParentPath.isCallExpression({</span><span class="s3">\n        </span><span class="s1">callee: superProp.node,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({</span><span class="s3">\n        </span><span class="s1">tag: superProp.node,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);</span><span class="s3">\n\n      </span><span class="s1">const args: t.Expression[] = [];</span><span class="s3">\n      </span><span class="s1">if (superProp.node.computed) {</span><span class="s3">\n        </span><span class="s1">// SuperProperty must not be a private name</span><span class="s3">\n        </span><span class="s1">args.push(superProp.get(</span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">).node as t.Expression);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isAssignment) {</span><span class="s3">\n        </span><span class="s1">const value = superParentPath.node.right;</span><span class="s3">\n        </span><span class="s1">args.push(value);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const call = callExpression(identifier(superBinding), args);</span><span class="s3">\n\n      </span><span class="s1">if (isCall) {</span><span class="s3">\n        </span><span class="s1">superParentPath.unshiftContainer(</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">, thisExpression());</span><span class="s3">\n        </span><span class="s1">superProp.replaceWith(memberExpression(call, identifier(</span><span class="s3">\&quot;</span><span class="s1">call</span><span class="s3">\&quot;</span><span class="s1">)));</span><span class="s3">\n\n        </span><span class="s1">thisPaths.push(</span><span class="s3">\n          </span><span class="s1">superParentPath.get(</span><span class="s3">\&quot;</span><span class="s1">arguments.0</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.ThisExpression&gt;,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else if (isAssignment) {</span><span class="s3">\n        </span><span class="s1">// Replace not only the super.prop, but the whole assignment</span><span class="s3">\n        </span><span class="s1">superParentPath.replaceWith(call);</span><span class="s3">\n      </span><span class="s1">} else if (isTaggedTemplate) {</span><span class="s3">\n        </span><span class="s1">superProp.replaceWith(</span><span class="s3">\n          </span><span class="s1">callExpression(memberExpression(call, identifier(</span><span class="s3">\&quot;</span><span class="s1">bind</span><span class="s3">\&quot;</span><span class="s1">), false), [</span><span class="s3">\n            </span><span class="s1">thisExpression(),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">thisPaths.push(</span><span class="s3">\n          </span><span class="s1">superProp.get(</span><span class="s3">\&quot;</span><span class="s1">arguments.0</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.ThisExpression&gt;,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">superProp.replaceWith(call);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Convert all </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot; </span><span class="s1">references in the arrow to point at the alias.</span><span class="s3">\n  </span><span class="s1">let thisBinding: string | null;</span><span class="s3">\n  </span><span class="s1">if (thisPaths.length &gt; 0 || !noNewArrows) {</span><span class="s3">\n    </span><span class="s1">thisBinding = getThisBinding(thisEnvFn, inConstructor);</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">noNewArrows ||</span><span class="s3">\n      </span><span class="s1">// In subclass constructors, still need to rewrite because </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot; </span><span class="s1">can't be bound in spec mode</span><span class="s3">\n      </span><span class="s1">// because it might not have been initialized yet.</span><span class="s3">\n      </span><span class="s1">(inConstructor &amp;&amp; hasSuperClass(thisEnvFn))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">thisPaths.forEach(thisChild =&gt; {</span><span class="s3">\n        </span><span class="s1">const thisRef = thisChild.isJSX()</span><span class="s3">\n          </span><span class="s1">? jsxIdentifier(thisBinding)</span><span class="s3">\n          </span><span class="s1">: identifier(thisBinding);</span><span class="s3">\n\n        </span><span class="s1">thisRef.loc = thisChild.node.loc;</span><span class="s3">\n        </span><span class="s1">thisChild.replaceWith(thisRef);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">if (!noNewArrows) thisBinding = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { thisBinding, fnPath };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type LogicalOp = Parameters&lt;typeof logicalExpression&gt;[0];</span><span class="s3">\n</span><span class="s1">type BinaryOp = Parameters&lt;typeof binaryExpression&gt;[0];</span><span class="s3">\n\n</span><span class="s1">function isLogicalOp(op: string): op is LogicalOp {</span><span class="s3">\n  </span><span class="s1">return LOGICAL_OPERATORS.includes(op);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function standardizeSuperProperty(</span><span class="s3">\n  </span><span class="s1">superProp: NodePath&lt;t.MemberExpression&gt;,</span><span class="s3">\n</span><span class="s1">):</span><span class="s3">\n  </span><span class="s1">| [NodePath&lt;t.MemberExpression&gt;]</span><span class="s3">\n  </span><span class="s1">| [NodePath&lt;t.MemberExpression&gt;, NodePath&lt;t.MemberExpression&gt;] {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">superProp.parentPath.isAssignmentExpression() &amp;&amp;</span><span class="s3">\n    </span><span class="s1">superProp.parentPath.node.operator !== </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const assignmentPath = superProp.parentPath;</span><span class="s3">\n\n    </span><span class="s1">const op = assignmentPath.node.operator.slice(0, -1) as</span><span class="s3">\n      </span><span class="s1">| LogicalOp</span><span class="s3">\n      </span><span class="s1">| BinaryOp;</span><span class="s3">\n\n    </span><span class="s1">const value = assignmentPath.node.right;</span><span class="s3">\n\n    </span><span class="s1">const isLogicalAssignment = isLogicalOp(op);</span><span class="s3">\n\n    </span><span class="s1">if (superProp.node.computed) {</span><span class="s3">\n      </span><span class="s1">// from: super[foo] **= 4;</span><span class="s3">\n      </span><span class="s1">// to:   super[tmp = foo] = super[tmp] ** 4;</span><span class="s3">\n\n      </span><span class="s1">// from: super[foo] ??= 4;</span><span class="s3">\n      </span><span class="s1">// to:   super[tmp = foo] ?? super[tmp] = 4;</span><span class="s3">\n\n      </span><span class="s1">const tmp = superProp.scope.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">tmp</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">const object = superProp.node.object;</span><span class="s3">\n      </span><span class="s1">const property = superProp.node.property as t.Expression;</span><span class="s3">\n\n      </span><span class="s1">assignmentPath</span><span class="s3">\n        </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replaceWith(</span><span class="s3">\n          </span><span class="s1">memberExpression(</span><span class="s3">\n            </span><span class="s1">object,</span><span class="s3">\n            </span><span class="s1">assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, tmp, property),</span><span class="s3">\n            </span><span class="s1">true /* computed */,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">assignmentPath</span><span class="s3">\n        </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replaceWith(</span><span class="s3">\n          </span><span class="s1">rightExpression(</span><span class="s3">\n            </span><span class="s1">isLogicalAssignment ? </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot; </span><span class="s1">: op,</span><span class="s3">\n            </span><span class="s1">memberExpression(object, identifier(tmp.name), true /* computed */),</span><span class="s3">\n            </span><span class="s1">value,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// from: super.foo **= 4;</span><span class="s3">\n      </span><span class="s1">// to:   super.foo = super.foo ** 4;</span><span class="s3">\n\n      </span><span class="s1">// from: super.foo ??= 4;</span><span class="s3">\n      </span><span class="s1">// to:   super.foo ?? super.foo = 4;</span><span class="s3">\n\n      </span><span class="s1">const object = superProp.node.object;</span><span class="s3">\n      </span><span class="s1">const property = superProp.node.property as t.Identifier;</span><span class="s3">\n\n      </span><span class="s1">assignmentPath</span><span class="s3">\n        </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replaceWith(memberExpression(object, property));</span><span class="s3">\n\n      </span><span class="s1">assignmentPath</span><span class="s3">\n        </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replaceWith(</span><span class="s3">\n          </span><span class="s1">rightExpression(</span><span class="s3">\n            </span><span class="s1">isLogicalAssignment ? </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot; </span><span class="s1">: op,</span><span class="s3">\n            </span><span class="s1">memberExpression(object, identifier(property.name)),</span><span class="s3">\n            </span><span class="s1">value,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isLogicalAssignment) {</span><span class="s3">\n      </span><span class="s1">assignmentPath.replaceWith(</span><span class="s3">\n        </span><span class="s1">logicalExpression(</span><span class="s3">\n          </span><span class="s1">op,</span><span class="s3">\n          </span><span class="s1">assignmentPath.node.left as t.MemberExpression,</span><span class="s3">\n          </span><span class="s1">assignmentPath.node.right,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">assignmentPath.node.operator = </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return [</span><span class="s3">\n      </span><span class="s1">assignmentPath.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.MemberExpression&gt;,</span><span class="s3">\n      </span><span class="s1">assignmentPath.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">).get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">} else if (superProp.parentPath.isUpdateExpression()) {</span><span class="s3">\n    </span><span class="s1">const updateExpr = superProp.parentPath;</span><span class="s3">\n\n    </span><span class="s1">const tmp = superProp.scope.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">tmp</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const computedKey = superProp.node.computed</span><span class="s3">\n      </span><span class="s1">? superProp.scope.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">prop</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">: null;</span><span class="s3">\n\n    </span><span class="s1">const parts: t.Expression[] = [</span><span class="s3">\n      </span><span class="s1">assignmentExpression(</span><span class="s3">\n        \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">tmp,</span><span class="s3">\n        </span><span class="s1">memberExpression(</span><span class="s3">\n          </span><span class="s1">superProp.node.object,</span><span class="s3">\n          </span><span class="s1">computedKey</span><span class="s3">\n            </span><span class="s1">? assignmentExpression(</span><span class="s3">\n                \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">computedKey,</span><span class="s3">\n                </span><span class="s1">superProp.node.property as t.Expression,</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">: superProp.node.property,</span><span class="s3">\n          </span><span class="s1">superProp.node.computed,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">assignmentExpression(</span><span class="s3">\n        \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">memberExpression(</span><span class="s3">\n          </span><span class="s1">superProp.node.object,</span><span class="s3">\n          </span><span class="s1">computedKey ? identifier(computedKey.name) : superProp.node.property,</span><span class="s3">\n          </span><span class="s1">superProp.node.computed,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">binaryExpression(</span><span class="s3">\n          </span><span class="s1">// map `++` to `+`, and `--` to `-`</span><span class="s3">\n          </span><span class="s1">superProp.parentPath.node.operator[0] as </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">identifier(tmp.name),</span><span class="s3">\n          </span><span class="s1">numericLiteral(1),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n\n    </span><span class="s1">if (!superProp.parentPath.node.prefix) {</span><span class="s3">\n      </span><span class="s1">parts.push(identifier(tmp.name));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">updateExpr.replaceWith(sequenceExpression(parts));</span><span class="s3">\n\n    </span><span class="s1">const left = updateExpr.get(</span><span class="s3">\n      \&quot;</span><span class="s1">expressions.0.right</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">) as NodePath&lt;t.MemberExpression&gt;;</span><span class="s3">\n    </span><span class="s1">const right = updateExpr.get(</span><span class="s3">\n      \&quot;</span><span class="s1">expressions.1.left</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">) as NodePath&lt;t.MemberExpression&gt;;</span><span class="s3">\n    </span><span class="s1">return [left, right];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return [superProp];</span><span class="s3">\n\n  </span><span class="s1">function rightExpression(</span><span class="s3">\n    </span><span class="s1">op: BinaryOp | </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">left: t.MemberExpression,</span><span class="s3">\n    </span><span class="s1">right: t.Expression,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (op === </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, left, right);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return binaryExpression(op, left, right);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function hasSuperClass(thisEnvFn: NodePath&lt;t.Function&gt;) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">thisEnvFn.isClassMethod() &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!!(thisEnvFn.parentPath.parentPath.node as t.Class).superClass</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const assignSuperThisVisitor = mergeVisitors&lt;{</span><span class="s3">\n  </span><span class="s1">supers: WeakSet&lt;t.CallExpression&gt;;</span><span class="s3">\n  </span><span class="s1">thisBinding: string;</span><span class="s3">\n</span><span class="s1">}&gt;([</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">CallExpression(child, { supers, thisBinding }) {</span><span class="s3">\n      </span><span class="s1">if (!child.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">).isSuper()) return;</span><span class="s3">\n      </span><span class="s1">if (supers.has(child.node)) return;</span><span class="s3">\n      </span><span class="s1">supers.add(child.node);</span><span class="s3">\n\n      </span><span class="s1">child.replaceWithMultiple([</span><span class="s3">\n        </span><span class="s1">child.node,</span><span class="s3">\n        </span><span class="s1">assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, identifier(thisBinding), identifier(</span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">environmentVisitor,</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n\n</span><span class="s1">// Create a binding that evaluates to the </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot; </span><span class="s1">of the given function.</span><span class="s3">\n</span><span class="s1">function getThisBinding(</span><span class="s3">\n  </span><span class="s1">thisEnvFn: NodePath&lt;t.Function&gt;,</span><span class="s3">\n  </span><span class="s1">inConstructor: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return getBinding(thisEnvFn, </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">, thisBinding =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();</span><span class="s3">\n\n    </span><span class="s1">thisEnvFn.traverse(assignSuperThisVisitor, {</span><span class="s3">\n      </span><span class="s1">supers: new WeakSet(),</span><span class="s3">\n      </span><span class="s1">thisBinding,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Create a binding for a function that will call </span><span class="s3">\&quot;</span><span class="s1">super()</span><span class="s3">\&quot; </span><span class="s1">with arguments passed through.</span><span class="s3">\n</span><span class="s1">function getSuperBinding(thisEnvFn: NodePath&lt;t.Function&gt;) {</span><span class="s3">\n  </span><span class="s1">return getBinding(thisEnvFn, </span><span class="s3">\&quot;</span><span class="s1">supercall</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n    </span><span class="s1">const argsBinding = thisEnvFn.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">args</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return arrowFunctionExpression(</span><span class="s3">\n      </span><span class="s1">[restElement(argsBinding)],</span><span class="s3">\n      </span><span class="s1">callExpression(_super(), [spreadElement(identifier(argsBinding.name))]),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Create a binding for a function that will call </span><span class="s3">\&quot;</span><span class="s1">super.foo</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">super[foo]</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n</span><span class="s1">function getSuperPropBinding(</span><span class="s3">\n  </span><span class="s1">thisEnvFn: NodePath&lt;t.Function&gt;,</span><span class="s3">\n  </span><span class="s1">isAssignment: boolean,</span><span class="s3">\n  </span><span class="s1">propName: string,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const op = isAssignment ? </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n  </span><span class="s1">return getBinding(thisEnvFn, `superprop_${op}:${propName || </span><span class="s3">\&quot;\&quot;</span><span class="s1">}`, () =&gt; {</span><span class="s3">\n    </span><span class="s1">const argsList = [];</span><span class="s3">\n\n    </span><span class="s1">let fnBody;</span><span class="s3">\n    </span><span class="s1">if (propName) {</span><span class="s3">\n      </span><span class="s1">// () =&gt; super.foo</span><span class="s3">\n      </span><span class="s1">fnBody = memberExpression(_super(), identifier(propName));</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const method = thisEnvFn.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">prop</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">// (method) =&gt; super[method]</span><span class="s3">\n      </span><span class="s1">argsList.unshift(method);</span><span class="s3">\n      </span><span class="s1">fnBody = memberExpression(</span><span class="s3">\n        </span><span class="s1">_super(),</span><span class="s3">\n        </span><span class="s1">identifier(method.name),</span><span class="s3">\n        </span><span class="s1">true /* computed */,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isAssignment) {</span><span class="s3">\n      </span><span class="s1">const valueIdent = thisEnvFn.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">argsList.push(valueIdent);</span><span class="s3">\n\n      </span><span class="s1">fnBody = assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, fnBody, identifier(valueIdent.name));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return arrowFunctionExpression(argsList, fnBody);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getBinding(</span><span class="s3">\n  </span><span class="s1">thisEnvFn: NodePath,</span><span class="s3">\n  </span><span class="s1">key: string,</span><span class="s3">\n  </span><span class="s1">init: (name: string) =&gt; t.Expression,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const cacheKey = </span><span class="s3">\&quot;</span><span class="s1">binding:</span><span class="s3">\&quot; </span><span class="s1">+ key;</span><span class="s3">\n  </span><span class="s1">let data: string | undefined = thisEnvFn.getData(cacheKey);</span><span class="s3">\n  </span><span class="s1">if (!data) {</span><span class="s3">\n    </span><span class="s1">const id = thisEnvFn.scope.generateUidIdentifier(key);</span><span class="s3">\n    </span><span class="s1">data = id.name;</span><span class="s3">\n    </span><span class="s1">thisEnvFn.setData(cacheKey, data);</span><span class="s3">\n\n    </span><span class="s1">thisEnvFn.scope.push({</span><span class="s3">\n      </span><span class="s1">id: id,</span><span class="s3">\n      </span><span class="s1">init: init(data),</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return data;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ScopeInfo = {</span><span class="s3">\n  </span><span class="s1">thisPaths: NodePath&lt;t.ThisExpression | t.JSXIdentifier&gt;[];</span><span class="s3">\n  </span><span class="s1">superCalls: NodePath&lt;t.CallExpression&gt;[];</span><span class="s3">\n  </span><span class="s1">superProps: NodePath&lt;t.MemberExpression&gt;[];</span><span class="s3">\n  </span><span class="s1">argumentsPaths: NodePath&lt;t.Identifier | t.JSXIdentifier&gt;[];</span><span class="s3">\n  </span><span class="s1">newTargetPaths: NodePath&lt;t.MetaProperty&gt;[];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const getScopeInformationVisitor = mergeVisitors&lt;ScopeInfo&gt;([</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">ThisExpression(child, { thisPaths }) {</span><span class="s3">\n      </span><span class="s1">thisPaths.push(child);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">JSXIdentifier(child, { thisPaths }) {</span><span class="s3">\n      </span><span class="s1">if (child.node.name !== </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">) return;</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!child.parentPath.isJSXMemberExpression({ object: child.node }) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!child.parentPath.isJSXOpeningElement({ name: child.node })</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">thisPaths.push(child);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">CallExpression(child, { superCalls }) {</span><span class="s3">\n      </span><span class="s1">if (child.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">).isSuper()) superCalls.push(child);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">MemberExpression(child, { superProps }) {</span><span class="s3">\n      </span><span class="s1">if (child.get(</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">).isSuper()) superProps.push(child);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">Identifier(child, { argumentsPaths }) {</span><span class="s3">\n      </span><span class="s1">if (!child.isReferencedIdentifier({ name: </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot; </span><span class="s1">})) return;</span><span class="s3">\n\n      </span><span class="s1">let curr = child.scope;</span><span class="s3">\n      </span><span class="s1">do {</span><span class="s3">\n        </span><span class="s1">if (curr.hasOwnBinding(</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n          </span><span class="s1">curr.rename(</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (curr.path.isFunction() &amp;&amp; !curr.path.isArrowFunctionExpression()) {</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} while ((curr = curr.parent));</span><span class="s3">\n\n      </span><span class="s1">argumentsPaths.push(child);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">MetaProperty(child, { newTargetPaths }) {</span><span class="s3">\n      </span><span class="s1">if (!child.get(</span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">).isIdentifier({ name: </span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot; </span><span class="s1">})) return;</span><span class="s3">\n      </span><span class="s1">if (!child.get(</span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">).isIdentifier({ name: </span><span class="s3">\&quot;</span><span class="s1">target</span><span class="s3">\&quot; </span><span class="s1">})) return;</span><span class="s3">\n\n      </span><span class="s1">newTargetPaths.push(child);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">environmentVisitor,</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n\n</span><span class="s1">function getScopeInformation(fnPath: NodePath) {</span><span class="s3">\n  </span><span class="s1">const thisPaths: ScopeInfo[</span><span class="s3">\&quot;</span><span class="s1">thisPaths</span><span class="s3">\&quot;</span><span class="s1">] = [];</span><span class="s3">\n  </span><span class="s1">const argumentsPaths: ScopeInfo[</span><span class="s3">\&quot;</span><span class="s1">argumentsPaths</span><span class="s3">\&quot;</span><span class="s1">] = [];</span><span class="s3">\n  </span><span class="s1">const newTargetPaths: ScopeInfo[</span><span class="s3">\&quot;</span><span class="s1">newTargetPaths</span><span class="s3">\&quot;</span><span class="s1">] = [];</span><span class="s3">\n  </span><span class="s1">const superProps: ScopeInfo[</span><span class="s3">\&quot;</span><span class="s1">superProps</span><span class="s3">\&quot;</span><span class="s1">] = [];</span><span class="s3">\n  </span><span class="s1">const superCalls: ScopeInfo[</span><span class="s3">\&quot;</span><span class="s1">superCalls</span><span class="s3">\&quot;</span><span class="s1">] = [];</span><span class="s3">\n\n  </span><span class="s1">fnPath.traverse(getScopeInformationVisitor, {</span><span class="s3">\n    </span><span class="s1">thisPaths,</span><span class="s3">\n    </span><span class="s1">argumentsPaths,</span><span class="s3">\n    </span><span class="s1">newTargetPaths,</span><span class="s3">\n    </span><span class="s1">superProps,</span><span class="s3">\n    </span><span class="s1">superCalls,</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">thisPaths,</span><span class="s3">\n    </span><span class="s1">argumentsPaths,</span><span class="s3">\n    </span><span class="s1">newTargetPaths,</span><span class="s3">\n    </span><span class="s1">superProps,</span><span class="s3">\n    </span><span class="s1">superCalls,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>