<html>
<head>
<title>explode-assignable-expression.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
explode-assignable-expression.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;isPureish&quot;</span><span class="s0">,</span><span class="s1">&quot;isSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;toComputedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;getObjRef&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;nodes&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;hasBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;temp&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifierBasedOnNode&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;getPropRef&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;explode&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;uid&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/explode-assignable-expression.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { Scope } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">assignmentExpression,</span><span class="s3">\n  </span><span class="s1">cloneNode,</span><span class="s3">\n  </span><span class="s1">isIdentifier,</span><span class="s3">\n  </span><span class="s1">isLiteral,</span><span class="s3">\n  </span><span class="s1">isMemberExpression,</span><span class="s3">\n  </span><span class="s1">isPrivateName,</span><span class="s3">\n  </span><span class="s1">isPureish,</span><span class="s3">\n  </span><span class="s1">isSuper,</span><span class="s3">\n  </span><span class="s1">memberExpression,</span><span class="s3">\n  </span><span class="s1">toComputedKey,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">function getObjRef(</span><span class="s3">\n  </span><span class="s1">node: t.Identifier | t.MemberExpression,</span><span class="s3">\n  </span><span class="s1">nodes: Array&lt;t.AssignmentExpression&gt;,</span><span class="s3">\n  </span><span class="s1">scope: Scope,</span><span class="s3">\n</span><span class="s1">): t.Identifier | t.Super {</span><span class="s3">\n  </span><span class="s1">let ref;</span><span class="s3">\n  </span><span class="s1">if (isIdentifier(node)) {</span><span class="s3">\n    </span><span class="s1">if (scope.hasBinding(node.name)) {</span><span class="s3">\n      </span><span class="s1">// this variable is declared in scope so we can be 100% sure</span><span class="s3">\n      </span><span class="s1">// that evaluating it multiple times won't trigger a getter</span><span class="s3">\n      </span><span class="s1">// or something else</span><span class="s3">\n      </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// could possibly trigger a getter so we need to only evaluate</span><span class="s3">\n      </span><span class="s1">// it once</span><span class="s3">\n      </span><span class="s1">ref = node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (isMemberExpression(node)) {</span><span class="s3">\n    </span><span class="s1">ref = node.object;</span><span class="s3">\n\n    </span><span class="s1">if (isSuper(ref) || (isIdentifier(ref) &amp;&amp; scope.hasBinding(ref.name))) {</span><span class="s3">\n      </span><span class="s1">// the object reference that we need to save is locally declared</span><span class="s3">\n      </span><span class="s1">// so as per the previous comment we can be 100% sure evaluating</span><span class="s3">\n      </span><span class="s1">// it multiple times will be safe</span><span class="s3">\n      </span><span class="s1">// Super cannot be directly assigned so lets return it also</span><span class="s3">\n      </span><span class="s1">return ref;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw new Error(`We can't explode this node type ${node[</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">]}`);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const temp = scope.generateUidIdentifierBasedOnNode(ref);</span><span class="s3">\n  </span><span class="s1">scope.push({ id: temp });</span><span class="s3">\n  </span><span class="s1">nodes.push(assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, cloneNode(temp), cloneNode(ref)));</span><span class="s3">\n  </span><span class="s1">return temp;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getPropRef(</span><span class="s3">\n  </span><span class="s1">node: t.MemberExpression,</span><span class="s3">\n  </span><span class="s1">nodes: Array&lt;t.AssignmentExpression&gt;,</span><span class="s3">\n  </span><span class="s1">scope: Scope,</span><span class="s3">\n</span><span class="s1">): t.Identifier | t.Literal {</span><span class="s3">\n  </span><span class="s1">const prop = node.property;</span><span class="s3">\n  </span><span class="s1">if (isPrivateName(prop)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">We can't generate property ref for private name, please install `@babel/plugin-transform-class-properties`</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const key = toComputedKey(node, prop);</span><span class="s3">\n  </span><span class="s1">if (isLiteral(key) &amp;&amp; isPureish(key)) return key;</span><span class="s3">\n\n  </span><span class="s1">const temp = scope.generateUidIdentifierBasedOnNode(prop);</span><span class="s3">\n  </span><span class="s1">scope.push({ id: temp });</span><span class="s3">\n  </span><span class="s1">nodes.push(assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, cloneNode(temp), cloneNode(prop)));</span><span class="s3">\n  </span><span class="s1">return temp;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default function explode(</span><span class="s3">\n  </span><span class="s1">node: t.Identifier | t.MemberExpression,</span><span class="s3">\n  </span><span class="s1">nodes: Array&lt;t.AssignmentExpression&gt;,</span><span class="s3">\n  </span><span class="s1">scope: Scope,</span><span class="s3">\n</span><span class="s1">): {</span><span class="s3">\n  </span><span class="s1">uid: t.Identifier | t.MemberExpression | t.Super;</span><span class="s3">\n  </span><span class="s1">ref: t.Identifier | t.MemberExpression;</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">const obj = getObjRef(node, nodes, scope);</span><span class="s3">\n\n  </span><span class="s1">let ref, uid;</span><span class="s3">\n\n  </span><span class="s1">if (isIdentifier(node)) {</span><span class="s3">\n    </span><span class="s1">ref = cloneNode(node);</span><span class="s3">\n    </span><span class="s1">uid = obj;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">const prop = getPropRef(node, nodes, scope);</span><span class="s3">\n    </span><span class="s1">const computed = node.computed || isLiteral(prop);</span><span class="s3">\n    </span><span class="s1">uid = memberExpression(cloneNode(obj), cloneNode(prop), computed);</span><span class="s3">\n    </span><span class="s1">ref = memberExpression(cloneNode(obj), cloneNode(prop), computed);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">uid: uid,</span><span class="s3">\n    </span><span class="s1">ref: ref,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>