<html>
<head>
<title>inferers.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
inferers.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_infererReference&quot;</span><span class="s0">,</span><span class="s1">&quot;_util&quot;</span><span class="s0">,</span><span class="s1">&quot;BOOLEAN_BINARY_OPERATORS&quot;</span><span class="s0">,</span><span class="s1">&quot;BOOLEAN_UNARY_OPERATORS&quot;</span><span class="s0">,</span><span class="s1">&quot;NUMBER_BINARY_OPERATORS&quot;</span><span class="s0">,</span><span class="s1">&quot;NUMBER_UNARY_OPERATORS&quot;</span><span class="s0">,</span><span class="s1">&quot;STRING_UNARY_OPERATORS&quot;</span><span class="s0">,</span><span class="s1">&quot;anyTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;booleanTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;buildMatchMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;genericTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;nullLiteralTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;numberTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;stringTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;tupleTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;unionTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;voidTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;VariableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;getTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeCastExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;typeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;validParent&quot;</span><span class="s0">,</span><span class="s1">&quot;TSAsExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;TSNonNullExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;NewExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;TemplateLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;UnaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;BinaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;isBaseType&quot;</span><span class="s0">,</span><span class="s1">&quot;LogicalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;argumentTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;createUnionType&quot;</span><span class="s0">,</span><span class="s1">&quot;ConditionalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;SequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;ParenthesizedExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;AssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;UpdateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;StringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;NumericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;BooleanLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;NullLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExpLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;ArrayExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;RestElement&quot;</span><span class="s0">,</span><span class="s1">&quot;Func&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrayFrom&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectValues&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;CallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveCall&quot;</span><span class="s0">,</span><span class="s1">&quot;TaggedTemplateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;generator&quot;</span><span class="s0">,</span><span class="s1">&quot;returnType&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/path/inference/inferers.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">BOOLEAN_BINARY_OPERATORS,</span><span class="s3">\n  </span><span class="s1">BOOLEAN_UNARY_OPERATORS,</span><span class="s3">\n  </span><span class="s1">NUMBER_BINARY_OPERATORS,</span><span class="s3">\n  </span><span class="s1">NUMBER_UNARY_OPERATORS,</span><span class="s3">\n  </span><span class="s1">STRING_UNARY_OPERATORS,</span><span class="s3">\n  </span><span class="s1">anyTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">arrayTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">booleanTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">buildMatchMemberExpression,</span><span class="s3">\n  </span><span class="s1">genericTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">identifier,</span><span class="s3">\n  </span><span class="s1">nullLiteralTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">numberTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">stringTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">tupleTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">unionTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">voidTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">isIdentifier,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export { default as Identifier } from </span><span class="s3">\&quot;</span><span class="s1">./inferer-reference.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import { createUnionType } from </span><span class="s3">\&quot;</span><span class="s1">./util.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type NodePath from </span><span class="s3">\&quot;</span><span class="s1">../index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export function VariableDeclarator(this: NodePath&lt;t.VariableDeclarator&gt;) {</span><span class="s3">\n  </span><span class="s1">if (!this.get(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">).isIdentifier()) return;</span><span class="s3">\n  </span><span class="s1">return this.get(</span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">).getTypeAnnotation();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function TypeCastExpression(node: t.TypeCastExpression) {</span><span class="s3">\n  </span><span class="s1">return node.typeAnnotation;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">TypeCastExpression.validParent = true;</span><span class="s3">\n\n</span><span class="s1">export function TSAsExpression(node: t.TSAsExpression) {</span><span class="s3">\n  </span><span class="s1">return node.typeAnnotation;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">TSAsExpression.validParent = true;</span><span class="s3">\n\n</span><span class="s1">export function TSNonNullExpression(this: NodePath&lt;t.TSNonNullExpression&gt;) {</span><span class="s3">\n  </span><span class="s1">return this.get(</span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">).getTypeAnnotation();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function NewExpression(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;t.NewExpression&gt;,</span><span class="s3">\n  </span><span class="s1">node: t.NewExpression,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (node.callee.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// only resolve identifier callee</span><span class="s3">\n    </span><span class="s1">return genericTypeAnnotation(node.callee);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function TemplateLiteral() {</span><span class="s3">\n  </span><span class="s1">return stringTypeAnnotation();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function UnaryExpression(node: t.UnaryExpression) {</span><span class="s3">\n  </span><span class="s1">const operator = node.operator;</span><span class="s3">\n\n  </span><span class="s1">if (operator === </span><span class="s3">\&quot;</span><span class="s1">void</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return voidTypeAnnotation();</span><span class="s3">\n  </span><span class="s1">} else if (NUMBER_UNARY_OPERATORS.indexOf(operator) &gt;= 0) {</span><span class="s3">\n    </span><span class="s1">return numberTypeAnnotation();</span><span class="s3">\n  </span><span class="s1">} else if (STRING_UNARY_OPERATORS.indexOf(operator) &gt;= 0) {</span><span class="s3">\n    </span><span class="s1">return stringTypeAnnotation();</span><span class="s3">\n  </span><span class="s1">} else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) &gt;= 0) {</span><span class="s3">\n    </span><span class="s1">return booleanTypeAnnotation();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function BinaryExpression(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;t.BinaryExpression&gt;,</span><span class="s3">\n  </span><span class="s1">node: t.BinaryExpression,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const operator = node.operator;</span><span class="s3">\n\n  </span><span class="s1">if (NUMBER_BINARY_OPERATORS.indexOf(operator) &gt;= 0) {</span><span class="s3">\n    </span><span class="s1">return numberTypeAnnotation();</span><span class="s3">\n  </span><span class="s1">} else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) &gt;= 0) {</span><span class="s3">\n    </span><span class="s1">return booleanTypeAnnotation();</span><span class="s3">\n  </span><span class="s1">} else if (operator === </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const right = this.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const left = this.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (left.isBaseType(</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; right.isBaseType(</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">// both numbers so this will be a number</span><span class="s3">\n      </span><span class="s1">return numberTypeAnnotation();</span><span class="s3">\n    </span><span class="s1">} else if (left.isBaseType(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) || right.isBaseType(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">// one is a string so the result will be a string</span><span class="s3">\n      </span><span class="s1">return stringTypeAnnotation();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// unsure if left and right are strings or numbers so stay on the safe side</span><span class="s3">\n    </span><span class="s1">return unionTypeAnnotation([</span><span class="s3">\n      </span><span class="s1">stringTypeAnnotation(),</span><span class="s3">\n      </span><span class="s1">numberTypeAnnotation(),</span><span class="s3">\n    </span><span class="s1">]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function LogicalExpression(this: NodePath&lt;t.LogicalExpression&gt;) {</span><span class="s3">\n  </span><span class="s1">const argumentTypes = [</span><span class="s3">\n    </span><span class="s1">this.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">).getTypeAnnotation(),</span><span class="s3">\n    </span><span class="s1">this.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">).getTypeAnnotation(),</span><span class="s3">\n  </span><span class="s1">];</span><span class="s3">\n\n  </span><span class="s1">return createUnionType(argumentTypes);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ConditionalExpression(this: NodePath&lt;t.ConditionalExpression&gt;) {</span><span class="s3">\n  </span><span class="s1">const argumentTypes = [</span><span class="s3">\n    </span><span class="s1">this.get(</span><span class="s3">\&quot;</span><span class="s1">consequent</span><span class="s3">\&quot;</span><span class="s1">).getTypeAnnotation(),</span><span class="s3">\n    </span><span class="s1">this.get(</span><span class="s3">\&quot;</span><span class="s1">alternate</span><span class="s3">\&quot;</span><span class="s1">).getTypeAnnotation(),</span><span class="s3">\n  </span><span class="s1">];</span><span class="s3">\n\n  </span><span class="s1">return createUnionType(argumentTypes);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function SequenceExpression(this: NodePath&lt;t.SequenceExpression&gt;) {</span><span class="s3">\n  </span><span class="s1">return this.get(</span><span class="s3">\&quot;</span><span class="s1">expressions</span><span class="s3">\&quot;</span><span class="s1">).pop().getTypeAnnotation();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ParenthesizedExpression(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;t.ParenthesizedExpression&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return this.get(</span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">).getTypeAnnotation();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function AssignmentExpression(this: NodePath&lt;t.AssignmentExpression&gt;) {</span><span class="s3">\n  </span><span class="s1">return this.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">).getTypeAnnotation();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function UpdateExpression(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;t.UpdateExpression&gt;,</span><span class="s3">\n  </span><span class="s1">node: t.UpdateExpression,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const operator = node.operator;</span><span class="s3">\n  </span><span class="s1">if (operator === </span><span class="s3">\&quot;</span><span class="s1">++</span><span class="s3">\&quot; </span><span class="s1">|| operator === </span><span class="s3">\&quot;</span><span class="s1">--</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return numberTypeAnnotation();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function StringLiteral() {</span><span class="s3">\n  </span><span class="s1">return stringTypeAnnotation();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function NumericLiteral() {</span><span class="s3">\n  </span><span class="s1">return numberTypeAnnotation();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function BooleanLiteral() {</span><span class="s3">\n  </span><span class="s1">return booleanTypeAnnotation();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function NullLiteral() {</span><span class="s3">\n  </span><span class="s1">return nullLiteralTypeAnnotation();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function RegExpLiteral() {</span><span class="s3">\n  </span><span class="s1">return genericTypeAnnotation(identifier(</span><span class="s3">\&quot;</span><span class="s1">RegExp</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ObjectExpression() {</span><span class="s3">\n  </span><span class="s1">return genericTypeAnnotation(identifier(</span><span class="s3">\&quot;</span><span class="s1">Object</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ArrayExpression() {</span><span class="s3">\n  </span><span class="s1">return genericTypeAnnotation(identifier(</span><span class="s3">\&quot;</span><span class="s1">Array</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function RestElement() {</span><span class="s3">\n  </span><span class="s1">return ArrayExpression();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">RestElement.validParent = true;</span><span class="s3">\n\n</span><span class="s1">function Func() {</span><span class="s3">\n  </span><span class="s1">return genericTypeAnnotation(identifier(</span><span class="s3">\&quot;</span><span class="s1">Function</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">Func as FunctionExpression,</span><span class="s3">\n  </span><span class="s1">Func as ArrowFunctionExpression,</span><span class="s3">\n  </span><span class="s1">Func as FunctionDeclaration,</span><span class="s3">\n  </span><span class="s1">Func as ClassExpression,</span><span class="s3">\n  </span><span class="s1">Func as ClassDeclaration,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const isArrayFrom = buildMatchMemberExpression(</span><span class="s3">\&quot;</span><span class="s1">Array.from</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const isObjectKeys = buildMatchMemberExpression(</span><span class="s3">\&quot;</span><span class="s1">Object.keys</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const isObjectValues = buildMatchMemberExpression(</span><span class="s3">\&quot;</span><span class="s1">Object.values</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const isObjectEntries = buildMatchMemberExpression(</span><span class="s3">\&quot;</span><span class="s1">Object.entries</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">export function CallExpression(this: NodePath&lt;t.CallExpression&gt;) {</span><span class="s3">\n  </span><span class="s1">const { callee } = this.node;</span><span class="s3">\n  </span><span class="s1">if (isObjectKeys(callee)) {</span><span class="s3">\n    </span><span class="s1">return arrayTypeAnnotation(stringTypeAnnotation());</span><span class="s3">\n  </span><span class="s1">} else if (</span><span class="s3">\n    </span><span class="s1">isArrayFrom(callee) ||</span><span class="s3">\n    </span><span class="s1">isObjectValues(callee) ||</span><span class="s3">\n    </span><span class="s1">// Detect </span><span class="s3">\&quot;</span><span class="s1">var foo = Array()</span><span class="s3">\&quot; </span><span class="s1">calls so we can optimize for arrays vs iterables.</span><span class="s3">\n    </span><span class="s1">isIdentifier(callee, { name: </span><span class="s3">\&quot;</span><span class="s1">Array</span><span class="s3">\&quot; </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return arrayTypeAnnotation(anyTypeAnnotation());</span><span class="s3">\n  </span><span class="s1">} else if (isObjectEntries(callee)) {</span><span class="s3">\n    </span><span class="s1">return arrayTypeAnnotation(</span><span class="s3">\n      </span><span class="s1">tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return resolveCall(this.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function TaggedTemplateExpression(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;t.TaggedTemplateExpression&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return resolveCall(this.get(</span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function resolveCall(callee: NodePath) {</span><span class="s3">\n  </span><span class="s1">callee = callee.resolve();</span><span class="s3">\n\n  </span><span class="s1">if (callee.isFunction()) {</span><span class="s3">\n    </span><span class="s1">const { node } = callee;</span><span class="s3">\n    </span><span class="s1">if (node.async) {</span><span class="s3">\n      </span><span class="s1">if (node.generator) {</span><span class="s3">\n        </span><span class="s1">return genericTypeAnnotation(identifier(</span><span class="s3">\&quot;</span><span class="s1">AsyncIterator</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return genericTypeAnnotation(identifier(</span><span class="s3">\&quot;</span><span class="s1">Promise</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (node.generator) {</span><span class="s3">\n        </span><span class="s1">return genericTypeAnnotation(identifier(</span><span class="s3">\&quot;</span><span class="s1">Iterator</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">} else if (callee.node.returnType) {</span><span class="s3">\n        </span><span class="s1">return callee.node.returnType;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// todo: get union type of all return arguments</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>