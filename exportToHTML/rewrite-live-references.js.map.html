<html>
<head>
<title>rewrite-live-references.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
rewrite-live-references.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_assert&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperSimpleAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;getOuterBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;numericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;isInType&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;exportKind&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteLiveReferences&quot;</span><span class="s0">,</span><span class="s1">&quot;programPath&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapReference&quot;</span><span class="s0">,</span><span class="s1">&quot;imported&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;exported&quot;</span><span class="s0">,</span><span class="s1">&quot;requeueInParent&quot;</span><span class="s0">,</span><span class="s1">&quot;requeue&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;localName&quot;</span><span class="s0">,</span><span class="s1">&quot;importName&quot;</span><span class="s0">,</span><span class="s1">&quot;imports&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;importsNamespace&quot;</span><span class="s0">,</span><span class="s1">&quot;local&quot;</span><span class="s0">,</span><span class="s1">&quot;exportMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteBindingInitVisitorState&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteBindingInitVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingNames&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;simplifyAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteReferencesVisitorState&quot;</span><span class="s0">,</span><span class="s1">&quot;seen&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakSet&quot;</span><span class="s0">,</span><span class="s1">&quot;buildImportReference&quot;</span><span class="s0">,</span><span class="s1">&quot;identNode&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;referenced&quot;</span><span class="s0">,</span><span class="s1">&quot;wrap&quot;</span><span class="s0">,</span><span class="s1">&quot;_wrapReference&quot;</span><span class="s0">,</span><span class="s1">&quot;namespace&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;_wrapReference2&quot;</span><span class="s0">,</span><span class="s1">&quot;interop&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;stringSpecifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteReferencesVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;Scope&quot;</span><span class="s0">,</span><span class="s1">&quot;skip&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;exportNames&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;buildBindingExportAssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_blockHoist&quot;</span><span class="s0">,</span><span class="s1">&quot;insertAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;VariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isVar&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;decl&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;buildUndefinedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;localExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;exportsObjectName&quot;</span><span class="s0">,</span><span class="s1">&quot;exportName&quot;</span><span class="s0">,</span><span class="s1">&quot;currentScope&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;rename&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;expr&quot;</span><span class="s0">,</span><span class="s1">&quot;buildImportThrow&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;importData&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;localBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;getBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;rootBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptionalCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isTaggedTemplateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;UpdateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;arg&quot;</span><span class="s0">,</span><span class="s1">&quot;update&quot;</span><span class="s0">,</span><span class="s1">&quot;exportedNames&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDeclaredUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;AssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;assert&quot;</span><span class="s0">,</span><span class="s1">&quot;assignment&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;ids&quot;</span><span class="s0">,</span><span class="s1">&quot;programScopeIds&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;items&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;ForOfStatement|ForInStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;programScope&quot;</span><span class="s0">,</span><span class="s1">&quot;didTransformExport&quot;</span><span class="s0">,</span><span class="s1">&quot;importConstViolationName&quot;</span><span class="s0">,</span><span class="s1">&quot;loopBodyScope&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyPath&quot;</span><span class="s0">,</span><span class="s1">&quot;newLoopId&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifierBasedOnNode&quot;</span><span class="s0">,</span><span class="s1">&quot;registerDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;unshiftContainer&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/rewrite-live-references.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import assert from </span><span class="s3">\&quot;</span><span class="s1">assert</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { template, types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath, Visitor, Scope } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import simplifyAccess from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-simple-access</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import type { ModuleMetadata } from </span><span class="s3">\&quot;</span><span class="s1">./normalize-and-load-metadata.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const {</span><span class="s3">\n  </span><span class="s1">assignmentExpression,</span><span class="s3">\n  </span><span class="s1">cloneNode,</span><span class="s3">\n  </span><span class="s1">expressionStatement,</span><span class="s3">\n  </span><span class="s1">getOuterBindingIdentifiers,</span><span class="s3">\n  </span><span class="s1">identifier,</span><span class="s3">\n  </span><span class="s1">isArrowFunctionExpression,</span><span class="s3">\n  </span><span class="s1">isClassExpression,</span><span class="s3">\n  </span><span class="s1">isFunctionExpression,</span><span class="s3">\n  </span><span class="s1">isIdentifier,</span><span class="s3">\n  </span><span class="s1">isMemberExpression,</span><span class="s3">\n  </span><span class="s1">isVariableDeclaration,</span><span class="s3">\n  </span><span class="s1">jsxIdentifier,</span><span class="s3">\n  </span><span class="s1">jsxMemberExpression,</span><span class="s3">\n  </span><span class="s1">memberExpression,</span><span class="s3">\n  </span><span class="s1">numericLiteral,</span><span class="s3">\n  </span><span class="s1">sequenceExpression,</span><span class="s3">\n  </span><span class="s1">stringLiteral,</span><span class="s3">\n  </span><span class="s1">variableDeclaration,</span><span class="s3">\n  </span><span class="s1">variableDeclarator,</span><span class="s3">\n</span><span class="s1">} = t;</span><span class="s3">\n\n</span><span class="s1">interface RewriteReferencesVisitorState {</span><span class="s3">\n  </span><span class="s1">exported: Map&lt;any, any&gt;;</span><span class="s3">\n  </span><span class="s1">metadata: ModuleMetadata;</span><span class="s3">\n  </span><span class="s1">requeueInParent: (path: NodePath) =&gt; void;</span><span class="s3">\n  </span><span class="s1">scope: Scope;</span><span class="s3">\n  </span><span class="s1">imported: Map&lt;any, any&gt;;</span><span class="s3">\n  </span><span class="s1">buildImportReference: (</span><span class="s3">\n    </span><span class="s1">[source, importName, localName]: readonly [string, string, string],</span><span class="s3">\n    </span><span class="s1">identNode: t.Identifier | t.CallExpression | t.JSXIdentifier,</span><span class="s3">\n  </span><span class="s1">) =&gt; any;</span><span class="s3">\n  </span><span class="s1">seen: WeakSet&lt;object&gt;;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface RewriteBindingInitVisitorState {</span><span class="s3">\n  </span><span class="s1">exported: Map&lt;any, any&gt;;</span><span class="s3">\n  </span><span class="s1">metadata: ModuleMetadata;</span><span class="s3">\n  </span><span class="s1">requeueInParent: (path: NodePath) =&gt; void;</span><span class="s3">\n  </span><span class="s1">scope: Scope;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isInType(path: NodePath) {</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">switch (path.parent.type) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSTypeAliasDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSTypeReference</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TypeAlias</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ExportSpecifier</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">(</span><span class="s3">\n            </span><span class="s1">path.parentPath.parent as</span><span class="s3">\n              </span><span class="s1">| t.ExportDefaultDeclaration</span><span class="s3">\n              </span><span class="s1">| t.ExportNamedDeclaration</span><span class="s3">\n          </span><span class="s1">).exportKind === </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">if (path.parentPath.isStatement() || path.parentPath.isExpression()) {</span><span class="s3">\n          </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} while ((path = path.parentPath));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default function rewriteLiveReferences(</span><span class="s3">\n  </span><span class="s1">programPath: NodePath&lt;t.Program&gt;,</span><span class="s3">\n  </span><span class="s1">metadata: ModuleMetadata,</span><span class="s3">\n  </span><span class="s1">wrapReference: (ref: t.Expression, payload: unknown) =&gt; null | t.Expression,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const imported = new Map();</span><span class="s3">\n  </span><span class="s1">const exported = new Map();</span><span class="s3">\n  </span><span class="s1">const requeueInParent = (path: NodePath) =&gt; {</span><span class="s3">\n    </span><span class="s1">// Manually re-queue `exports.default =` expressions so that the ES3</span><span class="s3">\n    </span><span class="s1">// transform has an opportunity to convert them. Ideally this would</span><span class="s3">\n    </span><span class="s1">// happen automatically from the replaceWith above. See #4140 for</span><span class="s3">\n    </span><span class="s1">// more info.</span><span class="s3">\n    </span><span class="s1">programPath.requeue(path);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">for (const [source, data] of metadata.source) {</span><span class="s3">\n    </span><span class="s1">for (const [localName, importName] of data.imports) {</span><span class="s3">\n      </span><span class="s1">imported.set(localName, [source, importName, null]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (const localName of data.importsNamespace) {</span><span class="s3">\n      </span><span class="s1">imported.set(localName, [source, null, localName]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const [local, data] of metadata.local) {</span><span class="s3">\n    </span><span class="s1">let exportMeta = exported.get(local);</span><span class="s3">\n    </span><span class="s1">if (!exportMeta) {</span><span class="s3">\n      </span><span class="s1">exportMeta = [];</span><span class="s3">\n      </span><span class="s1">exported.set(local, exportMeta);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">exportMeta.push(...data.names);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Rewrite initialization of bindings to update exports.</span><span class="s3">\n  </span><span class="s1">const rewriteBindingInitVisitorState: RewriteBindingInitVisitorState = {</span><span class="s3">\n    </span><span class="s1">metadata,</span><span class="s3">\n    </span><span class="s1">requeueInParent,</span><span class="s3">\n    </span><span class="s1">scope: programPath.scope,</span><span class="s3">\n    </span><span class="s1">exported, // local name =&gt; exported name list</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">programPath.traverse(</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n    </span><span class="s1">rewriteBindingInitVisitor,</span><span class="s3">\n    </span><span class="s1">rewriteBindingInitVisitorState,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">// NOTE(logan): The 'Array.from' calls are to make this code with in loose mode.</span><span class="s3">\n  </span><span class="s1">const bindingNames = new Set([</span><span class="s3">\n    </span><span class="s1">...Array.from(imported.keys()),</span><span class="s3">\n    </span><span class="s1">...Array.from(exported.keys()),</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n  </span><span class="s1">if (process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">simplifyAccess(programPath, bindingNames);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) The third param has been removed in Babel 8.</span><span class="s3">\n    </span><span class="s1">simplifyAccess(programPath, bindingNames, false);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Rewrite reads/writes from imports and exports to have the correct behavior.</span><span class="s3">\n  </span><span class="s1">const rewriteReferencesVisitorState: RewriteReferencesVisitorState = {</span><span class="s3">\n    </span><span class="s1">seen: new WeakSet(),</span><span class="s3">\n    </span><span class="s1">metadata,</span><span class="s3">\n    </span><span class="s1">requeueInParent,</span><span class="s3">\n    </span><span class="s1">scope: programPath.scope,</span><span class="s3">\n    </span><span class="s1">imported, // local / import</span><span class="s3">\n    </span><span class="s1">exported, // local name =&gt; exported name list</span><span class="s3">\n    </span><span class="s1">buildImportReference([source, importName, localName], identNode) {</span><span class="s3">\n      </span><span class="s1">const meta = metadata.source.get(source);</span><span class="s3">\n      </span><span class="s1">meta.referenced = true;</span><span class="s3">\n\n      </span><span class="s1">if (localName) {</span><span class="s3">\n        </span><span class="s1">if (meta.wrap) {</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error Fixme: we should handle the case when identNode is a JSXIdentifier</span><span class="s3">\n          </span><span class="s1">identNode = wrapReference(identNode, meta.wrap) ?? identNode;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return identNode;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let namespace: t.Expression = identifier(meta.name);</span><span class="s3">\n      </span><span class="s1">if (meta.wrap) {</span><span class="s3">\n        </span><span class="s1">namespace = wrapReference(namespace, meta.wrap) ?? namespace;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (importName === </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; meta.interop === </span><span class="s3">\&quot;</span><span class="s1">node-default</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return namespace;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const computed = metadata.stringSpecifiers.has(importName);</span><span class="s3">\n\n      </span><span class="s1">return memberExpression(</span><span class="s3">\n        </span><span class="s1">namespace,</span><span class="s3">\n        </span><span class="s1">computed ? stringLiteral(importName) : identifier(importName),</span><span class="s3">\n        </span><span class="s1">computed,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n  </span><span class="s1">programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A visitor to inject export update statements during binding initialization.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const rewriteBindingInitVisitor: Visitor&lt;RewriteBindingInitVisitorState&gt; = {</span><span class="s3">\n  </span><span class="s1">Scope(path) {</span><span class="s3">\n    </span><span class="s1">path.skip();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">ClassDeclaration(path) {</span><span class="s3">\n    </span><span class="s1">const { requeueInParent, exported, metadata } = this;</span><span class="s3">\n\n    </span><span class="s1">const { id } = path.node;</span><span class="s3">\n    </span><span class="s1">if (!id) throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Expected class to have a name</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const localName = id.name;</span><span class="s3">\n\n    </span><span class="s1">const exportNames = exported.get(localName) || [];</span><span class="s3">\n    </span><span class="s1">if (exportNames.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">const statement = expressionStatement(</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n        </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n          </span><span class="s1">metadata,</span><span class="s3">\n          </span><span class="s1">exportNames,</span><span class="s3">\n          </span><span class="s1">identifier(localName),</span><span class="s3">\n          </span><span class="s1">path.scope,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): avoid mutations</span><span class="s3">\n      </span><span class="s1">statement._blockHoist = path.node._blockHoist;</span><span class="s3">\n\n      </span><span class="s1">requeueInParent(path.insertAfter(statement)[0]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">VariableDeclaration(path) {</span><span class="s3">\n    </span><span class="s1">const { requeueInParent, exported, metadata } = this;</span><span class="s3">\n\n    </span><span class="s1">const isVar = path.node.kind === </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">for (const decl of path.get(</span><span class="s3">\&quot;</span><span class="s1">declarations</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">const { id } = decl.node;</span><span class="s3">\n      </span><span class="s1">let { init } = decl.node;</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">isIdentifier(id) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">exported.has(id.name) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!isArrowFunctionExpression(init) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(!isFunctionExpression(init) || init.id) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(!isClassExpression(init) || init.id)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (!init) {</span><span class="s3">\n          </span><span class="s1">if (isVar) {</span><span class="s3">\n            </span><span class="s1">// This variable might have already been assigned to, and the</span><span class="s3">\n            </span><span class="s1">// uninitalized declaration doesn't set it to `undefined` and does</span><span class="s3">\n            </span><span class="s1">// not updated the exported value.</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">init = path.scope.buildUndefinedNode();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n        </span><span class="s1">decl.node.init = buildBindingExportAssignmentExpression(</span><span class="s3">\n          </span><span class="s1">metadata,</span><span class="s3">\n          </span><span class="s1">exported.get(id.name),</span><span class="s3">\n          </span><span class="s1">init,</span><span class="s3">\n          </span><span class="s1">path.scope,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">requeueInParent(decl.get(</span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">for (const localName of Object.keys(</span><span class="s3">\n          </span><span class="s1">decl.getOuterBindingIdentifiers(),</span><span class="s3">\n        </span><span class="s1">)) {</span><span class="s3">\n          </span><span class="s1">if (exported.has(localName)) {</span><span class="s3">\n            </span><span class="s1">const statement = expressionStatement(</span><span class="s3">\n              </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n              </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n                </span><span class="s1">metadata,</span><span class="s3">\n                </span><span class="s1">exported.get(localName),</span><span class="s3">\n                </span><span class="s1">identifier(localName),</span><span class="s3">\n                </span><span class="s1">path.scope,</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): avoid mutations</span><span class="s3">\n            </span><span class="s1">statement._blockHoist = path.node._blockHoist;</span><span class="s3">\n\n            </span><span class="s1">requeueInParent(path.insertAfter(statement)[0]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const buildBindingExportAssignmentExpression = (</span><span class="s3">\n  </span><span class="s1">metadata: ModuleMetadata,</span><span class="s3">\n  </span><span class="s1">exportNames: string[],</span><span class="s3">\n  </span><span class="s1">localExpr: t.Expression,</span><span class="s3">\n  </span><span class="s1">scope: Scope,</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">const exportsObjectName = metadata.exportName;</span><span class="s3">\n  </span><span class="s1">for (</span><span class="s3">\n    </span><span class="s1">let currentScope = scope;</span><span class="s3">\n    </span><span class="s1">currentScope != null;</span><span class="s3">\n    </span><span class="s1">currentScope = currentScope.parent</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (currentScope.hasOwnBinding(exportsObjectName)) {</span><span class="s3">\n      </span><span class="s1">currentScope.rename(exportsObjectName);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return (exportNames || []).reduce((expr, exportName) =&gt; {</span><span class="s3">\n    </span><span class="s1">// class Foo {} export { Foo, Foo as Bar };</span><span class="s3">\n    </span><span class="s1">// as</span><span class="s3">\n    </span><span class="s1">// class Foo {} exports.Foo = exports.Bar = Foo;</span><span class="s3">\n    </span><span class="s1">const { stringSpecifiers } = metadata;</span><span class="s3">\n    </span><span class="s1">const computed = stringSpecifiers.has(exportName);</span><span class="s3">\n    </span><span class="s1">return assignmentExpression(</span><span class="s3">\n      \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">memberExpression(</span><span class="s3">\n        </span><span class="s1">identifier(exportsObjectName),</span><span class="s3">\n        </span><span class="s1">computed ? stringLiteral(exportName) : identifier(exportName),</span><span class="s3">\n        </span><span class="s1">/* computed */ computed,</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">expr,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}, localExpr);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const buildImportThrow = (localName: string) =&gt; {</span><span class="s3">\n  </span><span class="s1">return template.expression.ast`</span><span class="s3">\n    </span><span class="s1">(function() {</span><span class="s3">\n      </span><span class="s1">throw new Error('</span><span class="s3">\&quot;</span><span class="s1">' + '${localName}' + '</span><span class="s3">\&quot; </span><span class="s1">is read-only.');</span><span class="s3">\n    </span><span class="s1">})()</span><span class="s3">\n  </span><span class="s1">`;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const rewriteReferencesVisitor: Visitor&lt;RewriteReferencesVisitorState&gt; = {</span><span class="s3">\n  </span><span class="s1">ReferencedIdentifier(path) {</span><span class="s3">\n    </span><span class="s1">const { seen, buildImportReference, scope, imported, requeueInParent } =</span><span class="s3">\n      </span><span class="s1">this;</span><span class="s3">\n    </span><span class="s1">if (seen.has(path.node)) return;</span><span class="s3">\n    </span><span class="s1">seen.add(path.node);</span><span class="s3">\n\n    </span><span class="s1">const localName = path.node.name;</span><span class="s3">\n\n    </span><span class="s1">const importData = imported.get(localName);</span><span class="s3">\n    </span><span class="s1">if (importData) {</span><span class="s3">\n      </span><span class="s1">if (isInType(path)) {</span><span class="s3">\n        </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n          </span><span class="s1">`Cannot transform the imported binding </span><span class="s3">\&quot;</span><span class="s1">${localName}</span><span class="s3">\&quot; </span><span class="s1">since it's also used in a type annotation. ` +</span><span class="s3">\n            </span><span class="s1">`Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const localBinding = path.scope.getBinding(localName);</span><span class="s3">\n      </span><span class="s1">const rootBinding = scope.getBinding(localName);</span><span class="s3">\n\n      </span><span class="s1">// redeclared in this scope</span><span class="s3">\n      </span><span class="s1">if (rootBinding !== localBinding) return;</span><span class="s3">\n\n      </span><span class="s1">const ref = buildImportReference(importData, path.node);</span><span class="s3">\n\n      </span><span class="s1">// Preserve the binding location so that sourcemaps are nicer.</span><span class="s3">\n      </span><span class="s1">ref.loc = path.node.loc;</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">(path.parentPath.isCallExpression({ callee: path.node }) ||</span><span class="s3">\n          </span><span class="s1">path.parentPath.isOptionalCallExpression({ callee: path.node }) ||</span><span class="s3">\n          </span><span class="s1">path.parentPath.isTaggedTemplateExpression({ tag: path.node })) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isMemberExpression(ref)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">path.replaceWith(sequenceExpression([numericLiteral(0), ref]));</span><span class="s3">\n      </span><span class="s1">} else if (path.isJSXIdentifier() &amp;&amp; isMemberExpression(ref)) {</span><span class="s3">\n        </span><span class="s1">const { object, property } = ref;</span><span class="s3">\n        </span><span class="s1">path.replaceWith(</span><span class="s3">\n          </span><span class="s1">jsxMemberExpression(</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): possible bug `object` might not have a name</span><span class="s3">\n            </span><span class="s1">jsxIdentifier(object.name),</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): possible bug `property` might not have a name</span><span class="s3">\n            </span><span class="s1">jsxIdentifier(property.name),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">path.replaceWith(ref);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">requeueInParent(path);</span><span class="s3">\n\n      </span><span class="s1">// The path could have been replaced with an identifier that would</span><span class="s3">\n      </span><span class="s1">// otherwise be re-visited, so we skip processing its children.</span><span class="s3">\n      </span><span class="s1">path.skip();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">UpdateExpression(path) {</span><span class="s3">\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">scope,</span><span class="s3">\n      </span><span class="s1">seen,</span><span class="s3">\n      </span><span class="s1">imported,</span><span class="s3">\n      </span><span class="s1">exported,</span><span class="s3">\n      </span><span class="s1">requeueInParent,</span><span class="s3">\n      </span><span class="s1">buildImportReference,</span><span class="s3">\n    </span><span class="s1">} = this;</span><span class="s3">\n\n    </span><span class="s1">if (seen.has(path.node)) return;</span><span class="s3">\n\n    </span><span class="s1">seen.add(path.node);</span><span class="s3">\n\n    </span><span class="s1">const arg = path.get(</span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">// No change needed</span><span class="s3">\n    </span><span class="s1">if (arg.isMemberExpression()) return;</span><span class="s3">\n\n    </span><span class="s1">const update = path.node;</span><span class="s3">\n\n    </span><span class="s1">if (arg.isIdentifier()) {</span><span class="s3">\n      </span><span class="s1">const localName = arg.node.name;</span><span class="s3">\n\n      </span><span class="s1">// redeclared in this scope</span><span class="s3">\n      </span><span class="s1">if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const exportedNames = exported.get(localName);</span><span class="s3">\n      </span><span class="s1">const importData = imported.get(localName);</span><span class="s3">\n\n      </span><span class="s1">if (exportedNames?.length &gt; 0 || importData) {</span><span class="s3">\n        </span><span class="s1">if (importData) {</span><span class="s3">\n          </span><span class="s1">path.replaceWith(</span><span class="s3">\n            </span><span class="s1">assignmentExpression(</span><span class="s3">\n              </span><span class="s1">update.operator[0] + </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n              </span><span class="s1">buildImportReference(importData, arg.node),</span><span class="s3">\n              </span><span class="s1">buildImportThrow(localName),</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else if (update.prefix) {</span><span class="s3">\n          </span><span class="s1">// ++foo</span><span class="s3">\n          </span><span class="s1">// =&gt;   exports.foo = ++foo</span><span class="s3">\n          </span><span class="s1">path.replaceWith(</span><span class="s3">\n            </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n              </span><span class="s1">this.metadata,</span><span class="s3">\n              </span><span class="s1">exportedNames,</span><span class="s3">\n              </span><span class="s1">cloneNode(update),</span><span class="s3">\n              </span><span class="s1">path.scope,</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// foo++</span><span class="s3">\n          </span><span class="s1">// =&gt;   (ref = i++, exports.i = i, ref)</span><span class="s3">\n          </span><span class="s1">const ref = scope.generateDeclaredUidIdentifier(localName);</span><span class="s3">\n\n          </span><span class="s1">path.replaceWith(</span><span class="s3">\n            </span><span class="s1">sequenceExpression([</span><span class="s3">\n              </span><span class="s1">assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, cloneNode(ref), cloneNode(update)),</span><span class="s3">\n              </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n                </span><span class="s1">this.metadata,</span><span class="s3">\n                </span><span class="s1">exportedNames,</span><span class="s3">\n                </span><span class="s1">identifier(localName),</span><span class="s3">\n                </span><span class="s1">path.scope,</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">cloneNode(ref),</span><span class="s3">\n            </span><span class="s1">]),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">requeueInParent(path);</span><span class="s3">\n    </span><span class="s1">path.skip();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">AssignmentExpression: {</span><span class="s3">\n    </span><span class="s1">exit(path) {</span><span class="s3">\n      </span><span class="s1">const {</span><span class="s3">\n        </span><span class="s1">scope,</span><span class="s3">\n        </span><span class="s1">seen,</span><span class="s3">\n        </span><span class="s1">imported,</span><span class="s3">\n        </span><span class="s1">exported,</span><span class="s3">\n        </span><span class="s1">requeueInParent,</span><span class="s3">\n        </span><span class="s1">buildImportReference,</span><span class="s3">\n      </span><span class="s1">} = this;</span><span class="s3">\n\n      </span><span class="s1">if (seen.has(path.node)) return;</span><span class="s3">\n      </span><span class="s1">seen.add(path.node);</span><span class="s3">\n\n      </span><span class="s1">const left = path.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">// No change needed</span><span class="s3">\n      </span><span class="s1">if (left.isMemberExpression()) return;</span><span class="s3">\n\n      </span><span class="s1">if (left.isIdentifier()) {</span><span class="s3">\n        </span><span class="s1">// Simple update-assign foo += 1; export { foo };</span><span class="s3">\n        </span><span class="s1">// =&gt;   exports.foo =  (foo += 1);</span><span class="s3">\n        </span><span class="s1">const localName = left.node.name;</span><span class="s3">\n\n        </span><span class="s1">// redeclared in this scope</span><span class="s3">\n        </span><span class="s1">if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const exportedNames = exported.get(localName);</span><span class="s3">\n        </span><span class="s1">const importData = imported.get(localName);</span><span class="s3">\n        </span><span class="s1">if (exportedNames?.length &gt; 0 || importData) {</span><span class="s3">\n          </span><span class="s1">assert(path.node.operator === </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">Path was not simplified</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n          </span><span class="s1">const assignment = path.node;</span><span class="s3">\n\n          </span><span class="s1">if (importData) {</span><span class="s3">\n            </span><span class="s1">assignment.left = buildImportReference(importData, left.node);</span><span class="s3">\n\n            </span><span class="s1">assignment.right = sequenceExpression([</span><span class="s3">\n              </span><span class="s1">assignment.right,</span><span class="s3">\n              </span><span class="s1">buildImportThrow(localName),</span><span class="s3">\n            </span><span class="s1">]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">path.replaceWith(</span><span class="s3">\n            </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n              </span><span class="s1">this.metadata,</span><span class="s3">\n              </span><span class="s1">exportedNames,</span><span class="s3">\n              </span><span class="s1">assignment,</span><span class="s3">\n              </span><span class="s1">path.scope,</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">requeueInParent(path);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">const ids = left.getOuterBindingIdentifiers();</span><span class="s3">\n        </span><span class="s1">const programScopeIds = Object.keys(ids).filter(</span><span class="s3">\n          </span><span class="s1">localName =&gt;</span><span class="s3">\n            </span><span class="s1">scope.getBinding(localName) === path.scope.getBinding(localName),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const id = programScopeIds.find(localName =&gt; imported.has(localName));</span><span class="s3">\n\n        </span><span class="s1">if (id) {</span><span class="s3">\n          </span><span class="s1">path.node.right = sequenceExpression([</span><span class="s3">\n            </span><span class="s1">path.node.right,</span><span class="s3">\n            </span><span class="s1">buildImportThrow(id),</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Complex ({a, b, c} = {}); export { a, c };</span><span class="s3">\n        </span><span class="s1">// =&gt;   ({a, b, c} = {}), (exports.a = a, exports.c = c);</span><span class="s3">\n        </span><span class="s1">const items: t.Expression[] = [];</span><span class="s3">\n        </span><span class="s1">programScopeIds.forEach(localName =&gt; {</span><span class="s3">\n          </span><span class="s1">const exportedNames = exported.get(localName) || [];</span><span class="s3">\n          </span><span class="s1">if (exportedNames.length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">items.push(</span><span class="s3">\n              </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n                </span><span class="s1">this.metadata,</span><span class="s3">\n                </span><span class="s1">exportedNames,</span><span class="s3">\n                </span><span class="s1">identifier(localName),</span><span class="s3">\n                </span><span class="s1">path.scope,</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n\n        </span><span class="s1">if (items.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">let node: t.Node = sequenceExpression(items);</span><span class="s3">\n          </span><span class="s1">if (path.parentPath.isExpressionStatement()) {</span><span class="s3">\n            </span><span class="s1">node = expressionStatement(node);</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): avoid mutations</span><span class="s3">\n            </span><span class="s1">node._blockHoist = path.parentPath.node._blockHoist;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const statement = path.insertAfter(node)[0];</span><span class="s3">\n          </span><span class="s1">requeueInParent(statement);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  \&quot;</span><span class="s1">ForOfStatement|ForInStatement</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;t.ForOfStatement | t.ForInStatement&gt;,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const { scope, node } = path;</span><span class="s3">\n    </span><span class="s1">const { left } = node;</span><span class="s3">\n    </span><span class="s1">const { exported, imported, scope: programScope } = this;</span><span class="s3">\n\n    </span><span class="s1">if (!isVariableDeclaration(left)) {</span><span class="s3">\n      </span><span class="s1">let didTransformExport = false,</span><span class="s3">\n        </span><span class="s1">importConstViolationName;</span><span class="s3">\n      </span><span class="s1">const loopBodyScope = path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).scope;</span><span class="s3">\n      </span><span class="s1">for (const name of Object.keys(getOuterBindingIdentifiers(left))) {</span><span class="s3">\n        </span><span class="s1">if (programScope.getBinding(name) === scope.getBinding(name)) {</span><span class="s3">\n          </span><span class="s1">if (exported.has(name)) {</span><span class="s3">\n            </span><span class="s1">didTransformExport = true;</span><span class="s3">\n            </span><span class="s1">if (loopBodyScope.hasOwnBinding(name)) {</span><span class="s3">\n              </span><span class="s1">loopBodyScope.rename(name);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (imported.has(name) &amp;&amp; !importConstViolationName) {</span><span class="s3">\n            </span><span class="s1">importConstViolationName = name;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!didTransformExport &amp;&amp; !importConstViolationName) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">path.ensureBlock();</span><span class="s3">\n      </span><span class="s1">const bodyPath = path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">const newLoopId = scope.generateUidIdentifierBasedOnNode(left);</span><span class="s3">\n      </span><span class="s1">path</span><span class="s3">\n        </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replaceWith(</span><span class="s3">\n          </span><span class="s1">variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n            </span><span class="s1">variableDeclarator(cloneNode(newLoopId)),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">scope.registerDeclaration(path.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n\n      </span><span class="s1">if (didTransformExport) {</span><span class="s3">\n        </span><span class="s1">bodyPath.unshiftContainer(</span><span class="s3">\n          \&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">expressionStatement(assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, left, newLoopId)),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (importConstViolationName) {</span><span class="s3">\n        </span><span class="s1">bodyPath.unshiftContainer(</span><span class="s3">\n          \&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">expressionStatement(buildImportThrow(importConstViolationName)),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>