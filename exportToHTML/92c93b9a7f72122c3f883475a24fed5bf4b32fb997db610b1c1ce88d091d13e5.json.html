<html>
<head>
<title>92c93b9a7f72122c3f883475a24fed5bf4b32fb997db610b1c1ce88d091d13e5.json</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #cf8e6d;}
.s3 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
92c93b9a7f72122c3f883475a24fed5bf4b32fb997db610b1c1ce88d091d13e5.json</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;ast&quot;</span><span class="s0">:</span><span class="s2">null</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">:</span><span class="s1">&quot;import </span><span class="s2">\&quot;</span><span class="s1">core-js/modules/es.array.push.js</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* A collection of shims that provide minimal functionality of the ES6 collections.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* These implementations are not meant to be used outside of the ResizeObserver</span><span class="s2">\r\n </span><span class="s1">* modules as they cover only a limited range of use cases.</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">/* eslint-disable require-jsdoc, valid-jsdoc */</span><span class="s2">\n</span><span class="s1">var MapShim = function () {</span><span class="s2">\n  </span><span class="s1">if (typeof Map !== 'undefined') {</span><span class="s2">\n    </span><span class="s1">return Map;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Returns index in provided array that matches the specified key.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @param {Array&lt;Array&gt;} arr</span><span class="s2">\r\n   </span><span class="s1">* @param {*} key</span><span class="s2">\r\n   </span><span class="s1">* @returns {number}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">function getIndex(arr, key) {</span><span class="s2">\n    </span><span class="s1">var result = -1;</span><span class="s2">\n    </span><span class="s1">arr.some(function (entry, index) {</span><span class="s2">\n      </span><span class="s1">if (entry[0] === key) {</span><span class="s2">\n        </span><span class="s1">result = index;</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return result;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return (/** @class */function () {</span><span class="s2">\n      </span><span class="s1">function class_1() {</span><span class="s2">\n        </span><span class="s1">this.__entries__ = [];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">Object.defineProperty(class_1.prototype, </span><span class="s2">\&quot;</span><span class="s1">size</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n        </span><span class="s1">/**</span><span class="s2">\r\n         </span><span class="s1">* @returns {boolean}</span><span class="s2">\r\n         </span><span class="s1">*/</span><span class="s2">\n        </span><span class="s1">get: function () {</span><span class="s2">\n          </span><span class="s1">return this.__entries__.length;</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">enumerable: true,</span><span class="s2">\n        </span><span class="s1">configurable: true</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">/**</span><span class="s2">\r\n       </span><span class="s1">* @param {*} key</span><span class="s2">\r\n       </span><span class="s1">* @returns {*}</span><span class="s2">\r\n       </span><span class="s1">*/</span><span class="s2">\n      </span><span class="s1">class_1.prototype.get = function (key) {</span><span class="s2">\n        </span><span class="s1">var index = getIndex(this.__entries__, key);</span><span class="s2">\n        </span><span class="s1">var entry = this.__entries__[index];</span><span class="s2">\n        </span><span class="s1">return entry &amp;&amp; entry[1];</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">/**</span><span class="s2">\r\n       </span><span class="s1">* @param {*} key</span><span class="s2">\r\n       </span><span class="s1">* @param {*} value</span><span class="s2">\r\n       </span><span class="s1">* @returns {void}</span><span class="s2">\r\n       </span><span class="s1">*/</span><span class="s2">\n      </span><span class="s1">class_1.prototype.set = function (key, value) {</span><span class="s2">\n        </span><span class="s1">var index = getIndex(this.__entries__, key);</span><span class="s2">\n        </span><span class="s1">if (~index) {</span><span class="s2">\n          </span><span class="s1">this.__entries__[index][1] = value;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">this.__entries__.push([key, value]);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">/**</span><span class="s2">\r\n       </span><span class="s1">* @param {*} key</span><span class="s2">\r\n       </span><span class="s1">* @returns {void}</span><span class="s2">\r\n       </span><span class="s1">*/</span><span class="s2">\n      </span><span class="s1">class_1.prototype.delete = function (key) {</span><span class="s2">\n        </span><span class="s1">var entries = this.__entries__;</span><span class="s2">\n        </span><span class="s1">var index = getIndex(entries, key);</span><span class="s2">\n        </span><span class="s1">if (~index) {</span><span class="s2">\n          </span><span class="s1">entries.splice(index, 1);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">/**</span><span class="s2">\r\n       </span><span class="s1">* @param {*} key</span><span class="s2">\r\n       </span><span class="s1">* @returns {void}</span><span class="s2">\r\n       </span><span class="s1">*/</span><span class="s2">\n      </span><span class="s1">class_1.prototype.has = function (key) {</span><span class="s2">\n        </span><span class="s1">return !!~getIndex(this.__entries__, key);</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">/**</span><span class="s2">\r\n       </span><span class="s1">* @returns {void}</span><span class="s2">\r\n       </span><span class="s1">*/</span><span class="s2">\n      </span><span class="s1">class_1.prototype.clear = function () {</span><span class="s2">\n        </span><span class="s1">this.__entries__.splice(0);</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">/**</span><span class="s2">\r\n       </span><span class="s1">* @param {Function} callback</span><span class="s2">\r\n       </span><span class="s1">* @param {*} [ctx=null]</span><span class="s2">\r\n       </span><span class="s1">* @returns {void}</span><span class="s2">\r\n       </span><span class="s1">*/</span><span class="s2">\n      </span><span class="s1">class_1.prototype.forEach = function (callback, ctx) {</span><span class="s2">\n        </span><span class="s1">if (ctx === void 0) {</span><span class="s2">\n          </span><span class="s1">ctx = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">for (var _i = 0, _a = this.__entries__; _i &lt; _a.length; _i++) {</span><span class="s2">\n          </span><span class="s1">var entry = _a[_i];</span><span class="s2">\n          </span><span class="s1">callback.call(ctx, entry[1], entry[0]);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">return class_1;</span><span class="s2">\n    </span><span class="s1">}()</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}();</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Detects whether window and document objects are available in current environment.</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var isBrowser = typeof window !== 'undefined' &amp;&amp; typeof document !== 'undefined' &amp;&amp; window.document === document;</span><span class="s2">\n\n</span><span class="s1">// Returns global object of a current environment.</span><span class="s2">\n</span><span class="s1">var global$1 = function () {</span><span class="s2">\n  </span><span class="s1">if (typeof global !== 'undefined' &amp;&amp; global.Math === Math) {</span><span class="s2">\n    </span><span class="s1">return global;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (typeof self !== 'undefined' &amp;&amp; self.Math === Math) {</span><span class="s2">\n    </span><span class="s1">return self;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (typeof window !== 'undefined' &amp;&amp; window.Math === Math) {</span><span class="s2">\n    </span><span class="s1">return window;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// eslint-disable-next-line no-new-func</span><span class="s2">\n  </span><span class="s1">return Function('return this')();</span><span class="s2">\n</span><span class="s1">}();</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* A shim for the requestAnimationFrame which falls back to the setTimeout if</span><span class="s2">\r\n </span><span class="s1">* first one is not supported.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @returns {number} Requests' identifier.</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var requestAnimationFrame$1 = function () {</span><span class="s2">\n  </span><span class="s1">if (typeof requestAnimationFrame === 'function') {</span><span class="s2">\n    </span><span class="s1">// It's required to use a bounded function because IE sometimes throws</span><span class="s2">\n    </span><span class="s1">// an </span><span class="s2">\&quot;</span><span class="s1">Invalid calling object</span><span class="s2">\&quot; </span><span class="s1">error if rAF is invoked without the global</span><span class="s2">\n    </span><span class="s1">// object on the left hand side.</span><span class="s2">\n    </span><span class="s1">return requestAnimationFrame.bind(global$1);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return function (callback) {</span><span class="s2">\n    </span><span class="s1">return setTimeout(function () {</span><span class="s2">\n      </span><span class="s1">return callback(Date.now());</span><span class="s2">\n    </span><span class="s1">}, 1000 / 60);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}();</span><span class="s2">\n\n</span><span class="s1">// Defines minimum timeout before adding a trailing call.</span><span class="s2">\n</span><span class="s1">var trailingTimeout = 2;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Creates a wrapper function which ensures that provided callback will be</span><span class="s2">\r\n </span><span class="s1">* invoked only once during the specified delay period.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {Function} callback - Function to be invoked after the delay period.</span><span class="s2">\r\n </span><span class="s1">* @param {number} delay - Delay after which to invoke callback.</span><span class="s2">\r\n </span><span class="s1">* @returns {Function}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function throttle(callback, delay) {</span><span class="s2">\n  </span><span class="s1">var leadingCall = false,</span><span class="s2">\n    </span><span class="s1">trailingCall = false,</span><span class="s2">\n    </span><span class="s1">lastCallTime = 0;</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Invokes the original callback function and schedules new invocation if</span><span class="s2">\r\n   </span><span class="s1">* the </span><span class="s2">\&quot;</span><span class="s1">proxy</span><span class="s2">\&quot; </span><span class="s1">was called during current request.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @returns {void}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">function resolvePending() {</span><span class="s2">\n    </span><span class="s1">if (leadingCall) {</span><span class="s2">\n      </span><span class="s1">leadingCall = false;</span><span class="s2">\n      </span><span class="s1">callback();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (trailingCall) {</span><span class="s2">\n      </span><span class="s1">proxy();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Callback invoked after the specified delay. It will further postpone</span><span class="s2">\r\n   </span><span class="s1">* invocation of the original function delegating it to the</span><span class="s2">\r\n   </span><span class="s1">* requestAnimationFrame.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @returns {void}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">function timeoutCallback() {</span><span class="s2">\n    </span><span class="s1">requestAnimationFrame$1(resolvePending);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Schedules invocation of the original function.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @returns {void}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">function proxy() {</span><span class="s2">\n    </span><span class="s1">var timeStamp = Date.now();</span><span class="s2">\n    </span><span class="s1">if (leadingCall) {</span><span class="s2">\n      </span><span class="s1">// Reject immediately following calls.</span><span class="s2">\n      </span><span class="s1">if (timeStamp - lastCallTime &lt; trailingTimeout) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">// Schedule new call to be in invoked when the pending one is resolved.</span><span class="s2">\n      </span><span class="s1">// This is important for </span><span class="s2">\&quot;</span><span class="s1">transitions</span><span class="s2">\&quot; </span><span class="s1">which never actually start</span><span class="s2">\n      </span><span class="s1">// immediately so there is a chance that we might miss one if change</span><span class="s2">\n      </span><span class="s1">// happens amids the pending invocation.</span><span class="s2">\n      </span><span class="s1">trailingCall = true;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">leadingCall = true;</span><span class="s2">\n      </span><span class="s1">trailingCall = false;</span><span class="s2">\n      </span><span class="s1">setTimeout(timeoutCallback, delay);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">lastCallTime = timeStamp;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return proxy;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// Minimum delay before invoking the update of observers.</span><span class="s2">\n</span><span class="s1">var REFRESH_DELAY = 20;</span><span class="s2">\n</span><span class="s1">// A list of substrings of CSS properties used to find transition events that</span><span class="s2">\n</span><span class="s1">// might affect dimensions of observed elements.</span><span class="s2">\n</span><span class="s1">var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];</span><span class="s2">\n</span><span class="s1">// Check if MutationObserver is available.</span><span class="s2">\n</span><span class="s1">var mutationObserverSupported = typeof MutationObserver !== 'undefined';</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Singleton controller class which handles updates of ResizeObserver instances.</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var ResizeObserverController = /** @class */function () {</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Creates a new instance of ResizeObserverController.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @private</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">function ResizeObserverController() {</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Indicates whether DOM listeners have been added.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @private {boolean}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">this.connected_ = false;</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Tells that controller has subscribed for Mutation Events.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @private {boolean}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">this.mutationEventsAdded_ = false;</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Keeps reference to the instance of MutationObserver.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @private {MutationObserver}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">this.mutationsObserver_ = null;</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* A list of connected observers.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @private {Array&lt;ResizeObserverSPI&gt;}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">this.observers_ = [];</span><span class="s2">\n    </span><span class="s1">this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);</span><span class="s2">\n    </span><span class="s1">this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Adds observer to observers list.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @param {ResizeObserverSPI} observer - Observer to be added.</span><span class="s2">\r\n   </span><span class="s1">* @returns {void}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObserverController.prototype.addObserver = function (observer) {</span><span class="s2">\n    </span><span class="s1">if (!~this.observers_.indexOf(observer)) {</span><span class="s2">\n      </span><span class="s1">this.observers_.push(observer);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// Add listeners if they haven't been added yet.</span><span class="s2">\n    </span><span class="s1">if (!this.connected_) {</span><span class="s2">\n      </span><span class="s1">this.connect_();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Removes observer from observers list.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @param {ResizeObserverSPI} observer - Observer to be removed.</span><span class="s2">\r\n   </span><span class="s1">* @returns {void}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObserverController.prototype.removeObserver = function (observer) {</span><span class="s2">\n    </span><span class="s1">var observers = this.observers_;</span><span class="s2">\n    </span><span class="s1">var index = observers.indexOf(observer);</span><span class="s2">\n    </span><span class="s1">// Remove observer if it's present in registry.</span><span class="s2">\n    </span><span class="s1">if (~index) {</span><span class="s2">\n      </span><span class="s1">observers.splice(index, 1);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// Remove listeners if controller has no connected observers.</span><span class="s2">\n    </span><span class="s1">if (!observers.length &amp;&amp; this.connected_) {</span><span class="s2">\n      </span><span class="s1">this.disconnect_();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Invokes the update of observers. It will continue running updates insofar</span><span class="s2">\r\n   </span><span class="s1">* it detects changes.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @returns {void}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObserverController.prototype.refresh = function () {</span><span class="s2">\n    </span><span class="s1">var changesDetected = this.updateObservers_();</span><span class="s2">\n    </span><span class="s1">// Continue running updates if changes have been detected as there might</span><span class="s2">\n    </span><span class="s1">// be future ones caused by CSS transitions.</span><span class="s2">\n    </span><span class="s1">if (changesDetected) {</span><span class="s2">\n      </span><span class="s1">this.refresh();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Updates every observer from observers list and notifies them of queued</span><span class="s2">\r\n   </span><span class="s1">* entries.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @private</span><span class="s2">\r\n   </span><span class="s1">* @returns {boolean} Returns </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot; </span><span class="s1">if any observer has detected changes in</span><span class="s2">\r\n   </span><span class="s1">*      dimensions of it's elements.</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObserverController.prototype.updateObservers_ = function () {</span><span class="s2">\n    </span><span class="s1">// Collect observers that have active observations.</span><span class="s2">\n    </span><span class="s1">var activeObservers = this.observers_.filter(function (observer) {</span><span class="s2">\n      </span><span class="s1">return observer.gatherActive(), observer.hasActive();</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">// Deliver notifications in a separate cycle in order to avoid any</span><span class="s2">\n    </span><span class="s1">// collisions between observers, e.g. when multiple instances of</span><span class="s2">\n    </span><span class="s1">// ResizeObserver are tracking the same element and the callback of one</span><span class="s2">\n    </span><span class="s1">// of them changes content dimensions of the observed target. Sometimes</span><span class="s2">\n    </span><span class="s1">// this may result in notifications being blocked for the rest of observers.</span><span class="s2">\n    </span><span class="s1">activeObservers.forEach(function (observer) {</span><span class="s2">\n      </span><span class="s1">return observer.broadcastActive();</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return activeObservers.length &gt; 0;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Initializes DOM listeners.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @private</span><span class="s2">\r\n   </span><span class="s1">* @returns {void}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObserverController.prototype.connect_ = function () {</span><span class="s2">\n    </span><span class="s1">// Do nothing if running in a non-browser environment or if listeners</span><span class="s2">\n    </span><span class="s1">// have been already added.</span><span class="s2">\n    </span><span class="s1">if (!isBrowser || this.connected_) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// Subscription to the </span><span class="s2">\&quot;</span><span class="s1">Transitionend</span><span class="s2">\&quot; </span><span class="s1">event is used as a workaround for</span><span class="s2">\n    </span><span class="s1">// delayed transitions. This way it's possible to capture at least the</span><span class="s2">\n    </span><span class="s1">// final state of an element.</span><span class="s2">\n    </span><span class="s1">document.addEventListener('transitionend', this.onTransitionEnd_);</span><span class="s2">\n    </span><span class="s1">window.addEventListener('resize', this.refresh);</span><span class="s2">\n    </span><span class="s1">if (mutationObserverSupported) {</span><span class="s2">\n      </span><span class="s1">this.mutationsObserver_ = new MutationObserver(this.refresh);</span><span class="s2">\n      </span><span class="s1">this.mutationsObserver_.observe(document, {</span><span class="s2">\n        </span><span class="s1">attributes: true,</span><span class="s2">\n        </span><span class="s1">childList: true,</span><span class="s2">\n        </span><span class="s1">characterData: true,</span><span class="s2">\n        </span><span class="s1">subtree: true</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">document.addEventListener('DOMSubtreeModified', this.refresh);</span><span class="s2">\n      </span><span class="s1">this.mutationEventsAdded_ = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.connected_ = true;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Removes DOM listeners.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @private</span><span class="s2">\r\n   </span><span class="s1">* @returns {void}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObserverController.prototype.disconnect_ = function () {</span><span class="s2">\n    </span><span class="s1">// Do nothing if running in a non-browser environment or if listeners</span><span class="s2">\n    </span><span class="s1">// have been already removed.</span><span class="s2">\n    </span><span class="s1">if (!isBrowser || !this.connected_) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">document.removeEventListener('transitionend', this.onTransitionEnd_);</span><span class="s2">\n    </span><span class="s1">window.removeEventListener('resize', this.refresh);</span><span class="s2">\n    </span><span class="s1">if (this.mutationsObserver_) {</span><span class="s2">\n      </span><span class="s1">this.mutationsObserver_.disconnect();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (this.mutationEventsAdded_) {</span><span class="s2">\n      </span><span class="s1">document.removeEventListener('DOMSubtreeModified', this.refresh);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.mutationsObserver_ = null;</span><span class="s2">\n    </span><span class="s1">this.mutationEventsAdded_ = false;</span><span class="s2">\n    </span><span class="s1">this.connected_ = false;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* </span><span class="s2">\&quot;</span><span class="s1">Transitionend</span><span class="s2">\&quot; </span><span class="s1">event handler.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @private</span><span class="s2">\r\n   </span><span class="s1">* @param {TransitionEvent} event</span><span class="s2">\r\n   </span><span class="s1">* @returns {void}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {</span><span class="s2">\n    </span><span class="s1">var _b = _a.propertyName,</span><span class="s2">\n      </span><span class="s1">propertyName = _b === void 0 ? '' : _b;</span><span class="s2">\n    </span><span class="s1">// Detect whether transition may affect dimensions of an element.</span><span class="s2">\n    </span><span class="s1">var isReflowProperty = transitionKeys.some(function (key) {</span><span class="s2">\n      </span><span class="s1">return !!~propertyName.indexOf(key);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (isReflowProperty) {</span><span class="s2">\n      </span><span class="s1">this.refresh();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Returns instance of the ResizeObserverController.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @returns {ResizeObserverController}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObserverController.getInstance = function () {</span><span class="s2">\n    </span><span class="s1">if (!this.instance_) {</span><span class="s2">\n      </span><span class="s1">this.instance_ = new ResizeObserverController();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this.instance_;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Holds reference to the controller's instance.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @private {ResizeObserverController}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObserverController.instance_ = null;</span><span class="s2">\n  </span><span class="s1">return ResizeObserverController;</span><span class="s2">\n</span><span class="s1">}();</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Defines non-writable/enumerable properties of the provided target object.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {Object} target - Object for which to define properties.</span><span class="s2">\r\n </span><span class="s1">* @param {Object} props - Properties to be defined.</span><span class="s2">\r\n </span><span class="s1">* @returns {Object} Target object.</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var defineConfigurable = function (target, props) {</span><span class="s2">\n  </span><span class="s1">for (var _i = 0, _a = Object.keys(props); _i &lt; _a.length; _i++) {</span><span class="s2">\n    </span><span class="s1">var key = _a[_i];</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(target, key, {</span><span class="s2">\n      </span><span class="s1">value: props[key],</span><span class="s2">\n      </span><span class="s1">enumerable: false,</span><span class="s2">\n      </span><span class="s1">writable: false,</span><span class="s2">\n      </span><span class="s1">configurable: true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return target;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Returns the global object associated with provided element.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {Object} target</span><span class="s2">\r\n </span><span class="s1">* @returns {Object}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var getWindowOf = function (target) {</span><span class="s2">\n  </span><span class="s1">// Assume that the element is an instance of Node, which means that it</span><span class="s2">\n  </span><span class="s1">// has the </span><span class="s2">\&quot;</span><span class="s1">ownerDocument</span><span class="s2">\&quot; </span><span class="s1">property from which we can retrieve a</span><span class="s2">\n  </span><span class="s1">// corresponding global object.</span><span class="s2">\n  </span><span class="s1">var ownerGlobal = target &amp;&amp; target.ownerDocument &amp;&amp; target.ownerDocument.defaultView;</span><span class="s2">\n  </span><span class="s1">// Return the local global object if it's not possible extract one from</span><span class="s2">\n  </span><span class="s1">// provided element.</span><span class="s2">\n  </span><span class="s1">return ownerGlobal || global$1;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// Placeholder of an empty content rectangle.</span><span class="s2">\n</span><span class="s1">var emptyRect = createRectInit(0, 0, 0, 0);</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Converts provided string to a number.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {number|string} value</span><span class="s2">\r\n </span><span class="s1">* @returns {number}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function toFloat(value) {</span><span class="s2">\n  </span><span class="s1">return parseFloat(value) || 0;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Extracts borders size from provided styles.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {CSSStyleDeclaration} styles</span><span class="s2">\r\n </span><span class="s1">* @param {...string} positions - Borders positions (top, right, ...)</span><span class="s2">\r\n </span><span class="s1">* @returns {number}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function getBordersSize(styles) {</span><span class="s2">\n  </span><span class="s1">var positions = [];</span><span class="s2">\n  </span><span class="s1">for (var _i = 1; _i &lt; arguments.length; _i++) {</span><span class="s2">\n    </span><span class="s1">positions[_i - 1] = arguments[_i];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return positions.reduce(function (size, position) {</span><span class="s2">\n    </span><span class="s1">var value = styles['border-' + position + '-width'];</span><span class="s2">\n    </span><span class="s1">return size + toFloat(value);</span><span class="s2">\n  </span><span class="s1">}, 0);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Extracts paddings sizes from provided styles.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {CSSStyleDeclaration} styles</span><span class="s2">\r\n </span><span class="s1">* @returns {Object} Paddings box.</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function getPaddings(styles) {</span><span class="s2">\n  </span><span class="s1">var positions = ['top', 'right', 'bottom', 'left'];</span><span class="s2">\n  </span><span class="s1">var paddings = {};</span><span class="s2">\n  </span><span class="s1">for (var _i = 0, positions_1 = positions; _i &lt; positions_1.length; _i++) {</span><span class="s2">\n    </span><span class="s1">var position = positions_1[_i];</span><span class="s2">\n    </span><span class="s1">var value = styles['padding-' + position];</span><span class="s2">\n    </span><span class="s1">paddings[position] = toFloat(value);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return paddings;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Calculates content rectangle of provided SVG element.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {SVGGraphicsElement} target - Element content rectangle of which needs</span><span class="s2">\r\n </span><span class="s1">*      to be calculated.</span><span class="s2">\r\n </span><span class="s1">* @returns {DOMRectInit}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function getSVGContentRect(target) {</span><span class="s2">\n  </span><span class="s1">var bbox = target.getBBox();</span><span class="s2">\n  </span><span class="s1">return createRectInit(0, 0, bbox.width, bbox.height);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Calculates content rectangle of provided HTMLElement.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {HTMLElement} target - Element for which to calculate the content rectangle.</span><span class="s2">\r\n </span><span class="s1">* @returns {DOMRectInit}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function getHTMLElementContentRect(target) {</span><span class="s2">\n  </span><span class="s1">// Client width &amp; height properties can't be</span><span class="s2">\n  </span><span class="s1">// used exclusively as they provide rounded values.</span><span class="s2">\n  </span><span class="s1">var clientWidth = target.clientWidth,</span><span class="s2">\n    </span><span class="s1">clientHeight = target.clientHeight;</span><span class="s2">\n  </span><span class="s1">// By this condition we can catch all non-replaced inline, hidden and</span><span class="s2">\n  </span><span class="s1">// detached elements. Though elements with width &amp; height properties less</span><span class="s2">\n  </span><span class="s1">// than 0.5 will be discarded as well.</span><span class="s2">\n  </span><span class="s1">//</span><span class="s2">\n  </span><span class="s1">// Without it we would need to implement separate methods for each of</span><span class="s2">\n  </span><span class="s1">// those cases and it's not possible to perform a precise and performance</span><span class="s2">\n  </span><span class="s1">// effective test for hidden elements. E.g. even jQuery's ':visible' filter</span><span class="s2">\n  </span><span class="s1">// gives wrong results for elements with width &amp; height less than 0.5.</span><span class="s2">\n  </span><span class="s1">if (!clientWidth &amp;&amp; !clientHeight) {</span><span class="s2">\n    </span><span class="s1">return emptyRect;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var styles = getWindowOf(target).getComputedStyle(target);</span><span class="s2">\n  </span><span class="s1">var paddings = getPaddings(styles);</span><span class="s2">\n  </span><span class="s1">var horizPad = paddings.left + paddings.right;</span><span class="s2">\n  </span><span class="s1">var vertPad = paddings.top + paddings.bottom;</span><span class="s2">\n  </span><span class="s1">// Computed styles of width &amp; height are being used because they are the</span><span class="s2">\n  </span><span class="s1">// only dimensions available to JS that contain non-rounded values. It could</span><span class="s2">\n  </span><span class="s1">// be possible to utilize the getBoundingClientRect if only it's data wasn't</span><span class="s2">\n  </span><span class="s1">// affected by CSS transformations let alone paddings, borders and scroll bars.</span><span class="s2">\n  </span><span class="s1">var width = toFloat(styles.width),</span><span class="s2">\n    </span><span class="s1">height = toFloat(styles.height);</span><span class="s2">\n  </span><span class="s1">// Width &amp; height include paddings and borders when the 'border-box' box</span><span class="s2">\n  </span><span class="s1">// model is applied (except for IE).</span><span class="s2">\n  </span><span class="s1">if (styles.boxSizing === 'border-box') {</span><span class="s2">\n    </span><span class="s1">// Following conditions are required to handle Internet Explorer which</span><span class="s2">\n    </span><span class="s1">// doesn't include paddings and borders to computed CSS dimensions.</span><span class="s2">\n    </span><span class="s1">//</span><span class="s2">\n    </span><span class="s1">// We can say that if CSS dimensions + paddings are equal to the </span><span class="s2">\&quot;</span><span class="s1">client</span><span class="s2">\&quot;\n    </span><span class="s1">// properties then it's either IE, and thus we don't need to subtract</span><span class="s2">\n    </span><span class="s1">// anything, or an element merely doesn't have paddings/borders styles.</span><span class="s2">\n    </span><span class="s1">if (Math.round(width + horizPad) !== clientWidth) {</span><span class="s2">\n      </span><span class="s1">width -= getBordersSize(styles, 'left', 'right') + horizPad;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (Math.round(height + vertPad) !== clientHeight) {</span><span class="s2">\n      </span><span class="s1">height -= getBordersSize(styles, 'top', 'bottom') + vertPad;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// Following steps can't be applied to the document's root element as its</span><span class="s2">\n  </span><span class="s1">// client[Width/Height] properties represent viewport area of the window.</span><span class="s2">\n  </span><span class="s1">// Besides, it's as well not necessary as the &lt;html&gt; itself neither has</span><span class="s2">\n  </span><span class="s1">// rendered scroll bars nor it can be clipped.</span><span class="s2">\n  </span><span class="s1">if (!isDocumentElement(target)) {</span><span class="s2">\n    </span><span class="s1">// In some browsers (only in Firefox, actually) CSS width &amp; height</span><span class="s2">\n    </span><span class="s1">// include scroll bars size which can be removed at this step as scroll</span><span class="s2">\n    </span><span class="s1">// bars are the only difference between rounded dimensions + paddings</span><span class="s2">\n    </span><span class="s1">// and </span><span class="s2">\&quot;</span><span class="s1">client</span><span class="s2">\&quot; </span><span class="s1">properties, though that is not always true in Chrome.</span><span class="s2">\n    </span><span class="s1">var vertScrollbar = Math.round(width + horizPad) - clientWidth;</span><span class="s2">\n    </span><span class="s1">var horizScrollbar = Math.round(height + vertPad) - clientHeight;</span><span class="s2">\n    </span><span class="s1">// Chrome has a rather weird rounding of </span><span class="s2">\&quot;</span><span class="s1">client</span><span class="s2">\&quot; </span><span class="s1">properties.</span><span class="s2">\n    </span><span class="s1">// E.g. for an element with content width of 314.2px it sometimes gives</span><span class="s2">\n    </span><span class="s1">// the client width of 315px and for the width of 314.7px it may give</span><span class="s2">\n    </span><span class="s1">// 314px. And it doesn't happen all the time. So just ignore this delta</span><span class="s2">\n    </span><span class="s1">// as a non-relevant.</span><span class="s2">\n    </span><span class="s1">if (Math.abs(vertScrollbar) !== 1) {</span><span class="s2">\n      </span><span class="s1">width -= vertScrollbar;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (Math.abs(horizScrollbar) !== 1) {</span><span class="s2">\n      </span><span class="s1">height -= horizScrollbar;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return createRectInit(paddings.left, paddings.top, width, height);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Checks whether provided element is an instance of the SVGGraphicsElement.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {Element} target - Element to be checked.</span><span class="s2">\r\n </span><span class="s1">* @returns {boolean}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var isSVGGraphicsElement = function () {</span><span class="s2">\n  </span><span class="s1">// Some browsers, namely IE and Edge, don't have the SVGGraphicsElement</span><span class="s2">\n  </span><span class="s1">// interface.</span><span class="s2">\n  </span><span class="s1">if (typeof SVGGraphicsElement !== 'undefined') {</span><span class="s2">\n    </span><span class="s1">return function (target) {</span><span class="s2">\n      </span><span class="s1">return target instanceof getWindowOf(target).SVGGraphicsElement;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// If it's so, then check that element is at least an instance of the</span><span class="s2">\n  </span><span class="s1">// SVGElement and that it has the </span><span class="s2">\&quot;</span><span class="s1">getBBox</span><span class="s2">\&quot; </span><span class="s1">method.</span><span class="s2">\n  </span><span class="s1">// eslint-disable-next-line no-extra-parens</span><span class="s2">\n  </span><span class="s1">return function (target) {</span><span class="s2">\n    </span><span class="s1">return target instanceof getWindowOf(target).SVGElement &amp;&amp; typeof target.getBBox === 'function';</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}();</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Checks whether provided element is a document element (&lt;html&gt;).</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {Element} target - Element to be checked.</span><span class="s2">\r\n </span><span class="s1">* @returns {boolean}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isDocumentElement(target) {</span><span class="s2">\n  </span><span class="s1">return target === getWindowOf(target).document.documentElement;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Calculates an appropriate content rectangle for provided html or svg element.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {Element} target - Element content rectangle of which needs to be calculated.</span><span class="s2">\r\n </span><span class="s1">* @returns {DOMRectInit}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function getContentRect(target) {</span><span class="s2">\n  </span><span class="s1">if (!isBrowser) {</span><span class="s2">\n    </span><span class="s1">return emptyRect;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isSVGGraphicsElement(target)) {</span><span class="s2">\n    </span><span class="s1">return getSVGContentRect(target);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return getHTMLElementContentRect(target);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Creates rectangle with an interface of the DOMRectReadOnly.</span><span class="s2">\r\n </span><span class="s1">* Spec: https://drafts.fxtf.org/geometry/#domrectreadonly</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.</span><span class="s2">\r\n </span><span class="s1">* @returns {DOMRectReadOnly}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function createReadOnlyRect(_a) {</span><span class="s2">\n  </span><span class="s1">var x = _a.x,</span><span class="s2">\n    </span><span class="s1">y = _a.y,</span><span class="s2">\n    </span><span class="s1">width = _a.width,</span><span class="s2">\n    </span><span class="s1">height = _a.height;</span><span class="s2">\n  </span><span class="s1">// If DOMRectReadOnly is available use it as a prototype for the rectangle.</span><span class="s2">\n  </span><span class="s1">var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;</span><span class="s2">\n  </span><span class="s1">var rect = Object.create(Constr.prototype);</span><span class="s2">\n  </span><span class="s1">// Rectangle's properties are not writable and non-enumerable.</span><span class="s2">\n  </span><span class="s1">defineConfigurable(rect, {</span><span class="s2">\n    </span><span class="s1">x: x,</span><span class="s2">\n    </span><span class="s1">y: y,</span><span class="s2">\n    </span><span class="s1">width: width,</span><span class="s2">\n    </span><span class="s1">height: height,</span><span class="s2">\n    </span><span class="s1">top: y,</span><span class="s2">\n    </span><span class="s1">right: x + width,</span><span class="s2">\n    </span><span class="s1">bottom: height + y,</span><span class="s2">\n    </span><span class="s1">left: x</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return rect;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.</span><span class="s2">\r\n </span><span class="s1">* Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {number} x - X coordinate.</span><span class="s2">\r\n </span><span class="s1">* @param {number} y - Y coordinate.</span><span class="s2">\r\n </span><span class="s1">* @param {number} width - Rectangle's width.</span><span class="s2">\r\n </span><span class="s1">* @param {number} height - Rectangle's height.</span><span class="s2">\r\n </span><span class="s1">* @returns {DOMRectInit}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function createRectInit(x, y, width, height) {</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">x: x,</span><span class="s2">\n    </span><span class="s1">y: y,</span><span class="s2">\n    </span><span class="s1">width: width,</span><span class="s2">\n    </span><span class="s1">height: height</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Class that is responsible for computations of the content rectangle of</span><span class="s2">\r\n </span><span class="s1">* provided DOM element and for keeping track of it's changes.</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var ResizeObservation = /** @class */function () {</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Creates an instance of ResizeObservation.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @param {Element} target - Element to be observed.</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">function ResizeObservation(target) {</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Broadcasted width of content rectangle.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @type {number}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">this.broadcastWidth = 0;</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Broadcasted height of content rectangle.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @type {number}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">this.broadcastHeight = 0;</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Reference to the last observed content rectangle.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @private {DOMRectInit}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">this.contentRect_ = createRectInit(0, 0, 0, 0);</span><span class="s2">\n    </span><span class="s1">this.target = target;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Updates content rectangle and tells whether it's width or height properties</span><span class="s2">\r\n   </span><span class="s1">* have changed since the last broadcast.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @returns {boolean}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObservation.prototype.isActive = function () {</span><span class="s2">\n    </span><span class="s1">var rect = getContentRect(this.target);</span><span class="s2">\n    </span><span class="s1">this.contentRect_ = rect;</span><span class="s2">\n    </span><span class="s1">return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Updates 'broadcastWidth' and 'broadcastHeight' properties with a data</span><span class="s2">\r\n   </span><span class="s1">* from the corresponding properties of the last observed content rectangle.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @returns {DOMRectInit} Last observed content rectangle.</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObservation.prototype.broadcastRect = function () {</span><span class="s2">\n    </span><span class="s1">var rect = this.contentRect_;</span><span class="s2">\n    </span><span class="s1">this.broadcastWidth = rect.width;</span><span class="s2">\n    </span><span class="s1">this.broadcastHeight = rect.height;</span><span class="s2">\n    </span><span class="s1">return rect;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return ResizeObservation;</span><span class="s2">\n</span><span class="s1">}();</span><span class="s2">\n</span><span class="s1">var ResizeObserverEntry = /** @class */function () {</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Creates an instance of ResizeObserverEntry.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @param {Element} target - Element that is being observed.</span><span class="s2">\r\n   </span><span class="s1">* @param {DOMRectInit} rectInit - Data of the element's content rectangle.</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">function ResizeObserverEntry(target, rectInit) {</span><span class="s2">\n    </span><span class="s1">var contentRect = createReadOnlyRect(rectInit);</span><span class="s2">\n    </span><span class="s1">// According to the specification following properties are not writable</span><span class="s2">\n    </span><span class="s1">// and are also not enumerable in the native implementation.</span><span class="s2">\n    </span><span class="s1">//</span><span class="s2">\n    </span><span class="s1">// Property accessors are not being used as they'd require to define a</span><span class="s2">\n    </span><span class="s1">// private WeakMap storage which may cause memory leaks in browsers that</span><span class="s2">\n    </span><span class="s1">// don't support this type of collections.</span><span class="s2">\n    </span><span class="s1">defineConfigurable(this, {</span><span class="s2">\n      </span><span class="s1">target: target,</span><span class="s2">\n      </span><span class="s1">contentRect: contentRect</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return ResizeObserverEntry;</span><span class="s2">\n</span><span class="s1">}();</span><span class="s2">\n</span><span class="s1">var ResizeObserverSPI = /** @class */function () {</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Creates a new instance of ResizeObserver.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @param {ResizeObserverCallback} callback - Callback function that is invoked</span><span class="s2">\r\n   </span><span class="s1">*      when one of the observed elements changes it's content dimensions.</span><span class="s2">\r\n   </span><span class="s1">* @param {ResizeObserverController} controller - Controller instance which</span><span class="s2">\r\n   </span><span class="s1">*      is responsible for the updates of observer.</span><span class="s2">\r\n   </span><span class="s1">* @param {ResizeObserver} callbackCtx - Reference to the public</span><span class="s2">\r\n   </span><span class="s1">*      ResizeObserver instance which will be passed to callback function.</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">function ResizeObserverSPI(callback, controller, callbackCtx) {</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Collection of resize observations that have detected changes in dimensions</span><span class="s2">\r\n     </span><span class="s1">* of elements.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @private {Array&lt;ResizeObservation&gt;}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">this.activeObservations_ = [];</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Registry of the ResizeObservation instances.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @private {Map&lt;Element, ResizeObservation&gt;}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">this.observations_ = new MapShim();</span><span class="s2">\n    </span><span class="s1">if (typeof callback !== 'function') {</span><span class="s2">\n      </span><span class="s1">throw new TypeError('The callback provided as parameter 1 is not a function.');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.callback_ = callback;</span><span class="s2">\n    </span><span class="s1">this.controller_ = controller;</span><span class="s2">\n    </span><span class="s1">this.callbackCtx_ = callbackCtx;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Starts observing provided element.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @param {Element} target - Element to be observed.</span><span class="s2">\r\n   </span><span class="s1">* @returns {void}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObserverSPI.prototype.observe = function (target) {</span><span class="s2">\n    </span><span class="s1">if (!arguments.length) {</span><span class="s2">\n      </span><span class="s1">throw new TypeError('1 argument required, but only 0 present.');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// Do nothing if current environment doesn't have the Element interface.</span><span class="s2">\n    </span><span class="s1">if (typeof Element === 'undefined' || !(Element instanceof Object)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!(target instanceof getWindowOf(target).Element)) {</span><span class="s2">\n      </span><span class="s1">throw new TypeError('parameter 1 is not of type </span><span class="s2">\&quot;</span><span class="s1">Element</span><span class="s2">\&quot;</span><span class="s1">.');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var observations = this.observations_;</span><span class="s2">\n    </span><span class="s1">// Do nothing if element is already being observed.</span><span class="s2">\n    </span><span class="s1">if (observations.has(target)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">observations.set(target, new ResizeObservation(target));</span><span class="s2">\n    </span><span class="s1">this.controller_.addObserver(this);</span><span class="s2">\n    </span><span class="s1">// Force the update of observations.</span><span class="s2">\n    </span><span class="s1">this.controller_.refresh();</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Stops observing provided element.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @param {Element} target - Element to stop observing.</span><span class="s2">\r\n   </span><span class="s1">* @returns {void}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObserverSPI.prototype.unobserve = function (target) {</span><span class="s2">\n    </span><span class="s1">if (!arguments.length) {</span><span class="s2">\n      </span><span class="s1">throw new TypeError('1 argument required, but only 0 present.');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// Do nothing if current environment doesn't have the Element interface.</span><span class="s2">\n    </span><span class="s1">if (typeof Element === 'undefined' || !(Element instanceof Object)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!(target instanceof getWindowOf(target).Element)) {</span><span class="s2">\n      </span><span class="s1">throw new TypeError('parameter 1 is not of type </span><span class="s2">\&quot;</span><span class="s1">Element</span><span class="s2">\&quot;</span><span class="s1">.');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var observations = this.observations_;</span><span class="s2">\n    </span><span class="s1">// Do nothing if element is not being observed.</span><span class="s2">\n    </span><span class="s1">if (!observations.has(target)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">observations.delete(target);</span><span class="s2">\n    </span><span class="s1">if (!observations.size) {</span><span class="s2">\n      </span><span class="s1">this.controller_.removeObserver(this);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Stops observing all elements.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @returns {void}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObserverSPI.prototype.disconnect = function () {</span><span class="s2">\n    </span><span class="s1">this.clearActive();</span><span class="s2">\n    </span><span class="s1">this.observations_.clear();</span><span class="s2">\n    </span><span class="s1">this.controller_.removeObserver(this);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Collects observation instances the associated element of which has changed</span><span class="s2">\r\n   </span><span class="s1">* it's content rectangle.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @returns {void}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObserverSPI.prototype.gatherActive = function () {</span><span class="s2">\n    </span><span class="s1">var _this = this;</span><span class="s2">\n    </span><span class="s1">this.clearActive();</span><span class="s2">\n    </span><span class="s1">this.observations_.forEach(function (observation) {</span><span class="s2">\n      </span><span class="s1">if (observation.isActive()) {</span><span class="s2">\n        </span><span class="s1">_this.activeObservations_.push(observation);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Invokes initial callback function with a list of ResizeObserverEntry</span><span class="s2">\r\n   </span><span class="s1">* instances collected from active resize observations.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @returns {void}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObserverSPI.prototype.broadcastActive = function () {</span><span class="s2">\n    </span><span class="s1">// Do nothing if observer doesn't have active observations.</span><span class="s2">\n    </span><span class="s1">if (!this.hasActive()) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var ctx = this.callbackCtx_;</span><span class="s2">\n    </span><span class="s1">// Create ResizeObserverEntry instance for every active observation.</span><span class="s2">\n    </span><span class="s1">var entries = this.activeObservations_.map(function (observation) {</span><span class="s2">\n      </span><span class="s1">return new ResizeObserverEntry(observation.target, observation.broadcastRect());</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">this.callback_.call(ctx, entries, ctx);</span><span class="s2">\n    </span><span class="s1">this.clearActive();</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Clears the collection of active observations.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @returns {void}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObserverSPI.prototype.clearActive = function () {</span><span class="s2">\n    </span><span class="s1">this.activeObservations_.splice(0);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Tells whether observer has active observations.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @returns {boolean}</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">ResizeObserverSPI.prototype.hasActive = function () {</span><span class="s2">\n    </span><span class="s1">return this.activeObservations_.length &gt; 0;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return ResizeObserverSPI;</span><span class="s2">\n</span><span class="s1">}();</span><span class="s2">\n\n</span><span class="s1">// Registry of internal observers. If WeakMap is not available use current shim</span><span class="s2">\n</span><span class="s1">// for the Map collection as it has all required methods and because WeakMap</span><span class="s2">\n</span><span class="s1">// can't be fully polyfilled anyway.</span><span class="s2">\n</span><span class="s1">var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* ResizeObserver API. Encapsulates the ResizeObserver SPI implementation</span><span class="s2">\r\n </span><span class="s1">* exposing only those methods and properties that are defined in the spec.</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var ResizeObserver = /** @class */function () {</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\r\n   </span><span class="s1">* Creates a new instance of ResizeObserver.</span><span class="s2">\r\n   </span><span class="s1">*</span><span class="s2">\r\n   </span><span class="s1">* @param {ResizeObserverCallback} callback - Callback that is invoked when</span><span class="s2">\r\n   </span><span class="s1">*      dimensions of the observed elements change.</span><span class="s2">\r\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">function ResizeObserver(callback) {</span><span class="s2">\n    </span><span class="s1">if (!(this instanceof ResizeObserver)) {</span><span class="s2">\n      </span><span class="s1">throw new TypeError('Cannot call a class as a function.');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!arguments.length) {</span><span class="s2">\n      </span><span class="s1">throw new TypeError('1 argument required, but only 0 present.');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var controller = ResizeObserverController.getInstance();</span><span class="s2">\n    </span><span class="s1">var observer = new ResizeObserverSPI(callback, controller, this);</span><span class="s2">\n    </span><span class="s1">observers.set(this, observer);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return ResizeObserver;</span><span class="s2">\n</span><span class="s1">}();</span><span class="s2">\n</span><span class="s1">// Expose public methods of ResizeObserver.</span><span class="s2">\n</span><span class="s1">['observe', 'unobserve', 'disconnect'].forEach(function (method) {</span><span class="s2">\n  </span><span class="s1">ResizeObserver.prototype[method] = function () {</span><span class="s2">\n    </span><span class="s1">var _a;</span><span class="s2">\n    </span><span class="s1">return (_a = observers.get(this))[method].apply(_a, arguments);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">var index = function () {</span><span class="s2">\n  </span><span class="s1">// Export existing implementation if available.</span><span class="s2">\n  </span><span class="s1">if (typeof global$1.ResizeObserver !== 'undefined') {</span><span class="s2">\n    </span><span class="s1">return global$1.ResizeObserver;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return ResizeObserver;</span><span class="s2">\n</span><span class="s1">}();</span><span class="s2">\n</span><span class="s1">export default index;&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">:{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s3">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;MapShim&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;getIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;arr&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;class_1&quot;</span><span class="s0">,</span><span class="s1">&quot;__entries__&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;configurable&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;clear&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;callback&quot;</span><span class="s0">,</span><span class="s1">&quot;ctx&quot;</span><span class="s0">,</span><span class="s1">&quot;_i&quot;</span><span class="s0">,</span><span class="s1">&quot;_a&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;isBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;document&quot;</span><span class="s0">,</span><span class="s1">&quot;global$1&quot;</span><span class="s0">,</span><span class="s1">&quot;global&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;self&quot;</span><span class="s0">,</span><span class="s1">&quot;Function&quot;</span><span class="s0">,</span><span class="s1">&quot;requestAnimationFrame$1&quot;</span><span class="s0">,</span><span class="s1">&quot;requestAnimationFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;throttle&quot;</span><span class="s0">,</span><span class="s1">&quot;delay&quot;</span><span class="s0">,</span><span class="s1">&quot;leadingCall&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingCall&quot;</span><span class="s0">,</span><span class="s1">&quot;lastCallTime&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvePending&quot;</span><span class="s0">,</span><span class="s1">&quot;proxy&quot;</span><span class="s0">,</span><span class="s1">&quot;timeoutCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;timeStamp&quot;</span><span class="s0">,</span><span class="s1">&quot;REFRESH_DELAY&quot;</span><span class="s0">,</span><span class="s1">&quot;transitionKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;mutationObserverSupported&quot;</span><span class="s0">,</span><span class="s1">&quot;MutationObserver&quot;</span><span class="s0">,</span><span class="s1">&quot;ResizeObserverController&quot;</span><span class="s0">,</span><span class="s1">&quot;connected_&quot;</span><span class="s0">,</span><span class="s1">&quot;mutationEventsAdded_&quot;</span><span class="s0">,</span><span class="s1">&quot;mutationsObserver_&quot;</span><span class="s0">,</span><span class="s1">&quot;observers_&quot;</span><span class="s0">,</span><span class="s1">&quot;onTransitionEnd_&quot;</span><span class="s0">,</span><span class="s1">&quot;refresh&quot;</span><span class="s0">,</span><span class="s1">&quot;addObserver&quot;</span><span class="s0">,</span><span class="s1">&quot;observer&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;connect_&quot;</span><span class="s0">,</span><span class="s1">&quot;removeObserver&quot;</span><span class="s0">,</span><span class="s1">&quot;observers&quot;</span><span class="s0">,</span><span class="s1">&quot;disconnect_&quot;</span><span class="s0">,</span><span class="s1">&quot;changesDetected&quot;</span><span class="s0">,</span><span class="s1">&quot;updateObservers_&quot;</span><span class="s0">,</span><span class="s1">&quot;activeObservers&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;gatherActive&quot;</span><span class="s0">,</span><span class="s1">&quot;hasActive&quot;</span><span class="s0">,</span><span class="s1">&quot;broadcastActive&quot;</span><span class="s0">,</span><span class="s1">&quot;addEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;observe&quot;</span><span class="s0">,</span><span class="s1">&quot;attributes&quot;</span><span class="s0">,</span><span class="s1">&quot;childList&quot;</span><span class="s0">,</span><span class="s1">&quot;characterData&quot;</span><span class="s0">,</span><span class="s1">&quot;subtree&quot;</span><span class="s0">,</span><span class="s1">&quot;removeEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;disconnect&quot;</span><span class="s0">,</span><span class="s1">&quot;_b&quot;</span><span class="s0">,</span><span class="s1">&quot;propertyName&quot;</span><span class="s0">,</span><span class="s1">&quot;isReflowProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;getInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;instance_&quot;</span><span class="s0">,</span><span class="s1">&quot;defineConfigurable&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;writable&quot;</span><span class="s0">,</span><span class="s1">&quot;getWindowOf&quot;</span><span class="s0">,</span><span class="s1">&quot;ownerGlobal&quot;</span><span class="s0">,</span><span class="s1">&quot;ownerDocument&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultView&quot;</span><span class="s0">,</span><span class="s1">&quot;emptyRect&quot;</span><span class="s0">,</span><span class="s1">&quot;createRectInit&quot;</span><span class="s0">,</span><span class="s1">&quot;toFloat&quot;</span><span class="s0">,</span><span class="s1">&quot;parseFloat&quot;</span><span class="s0">,</span><span class="s1">&quot;getBordersSize&quot;</span><span class="s0">,</span><span class="s1">&quot;styles&quot;</span><span class="s0">,</span><span class="s1">&quot;positions&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;position&quot;</span><span class="s0">,</span><span class="s1">&quot;getPaddings&quot;</span><span class="s0">,</span><span class="s1">&quot;paddings&quot;</span><span class="s0">,</span><span class="s1">&quot;positions_1&quot;</span><span class="s0">,</span><span class="s1">&quot;getSVGContentRect&quot;</span><span class="s0">,</span><span class="s1">&quot;bbox&quot;</span><span class="s0">,</span><span class="s1">&quot;getBBox&quot;</span><span class="s0">,</span><span class="s1">&quot;width&quot;</span><span class="s0">,</span><span class="s1">&quot;height&quot;</span><span class="s0">,</span><span class="s1">&quot;getHTMLElementContentRect&quot;</span><span class="s0">,</span><span class="s1">&quot;clientWidth&quot;</span><span class="s0">,</span><span class="s1">&quot;clientHeight&quot;</span><span class="s0">,</span><span class="s1">&quot;getComputedStyle&quot;</span><span class="s0">,</span><span class="s1">&quot;horizPad&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;vertPad&quot;</span><span class="s0">,</span><span class="s1">&quot;top&quot;</span><span class="s0">,</span><span class="s1">&quot;bottom&quot;</span><span class="s0">,</span><span class="s1">&quot;boxSizing&quot;</span><span class="s0">,</span><span class="s1">&quot;round&quot;</span><span class="s0">,</span><span class="s1">&quot;isDocumentElement&quot;</span><span class="s0">,</span><span class="s1">&quot;vertScrollbar&quot;</span><span class="s0">,</span><span class="s1">&quot;horizScrollbar&quot;</span><span class="s0">,</span><span class="s1">&quot;abs&quot;</span><span class="s0">,</span><span class="s1">&quot;isSVGGraphicsElement&quot;</span><span class="s0">,</span><span class="s1">&quot;SVGGraphicsElement&quot;</span><span class="s0">,</span><span class="s1">&quot;SVGElement&quot;</span><span class="s0">,</span><span class="s1">&quot;documentElement&quot;</span><span class="s0">,</span><span class="s1">&quot;getContentRect&quot;</span><span class="s0">,</span><span class="s1">&quot;createReadOnlyRect&quot;</span><span class="s0">,</span><span class="s1">&quot;x&quot;</span><span class="s0">,</span><span class="s1">&quot;y&quot;</span><span class="s0">,</span><span class="s1">&quot;Constr&quot;</span><span class="s0">,</span><span class="s1">&quot;DOMRectReadOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;rect&quot;</span><span class="s0">,</span><span class="s1">&quot;create&quot;</span><span class="s0">,</span><span class="s1">&quot;ResizeObservation&quot;</span><span class="s0">,</span><span class="s1">&quot;broadcastWidth&quot;</span><span class="s0">,</span><span class="s1">&quot;broadcastHeight&quot;</span><span class="s0">,</span><span class="s1">&quot;contentRect_&quot;</span><span class="s0">,</span><span class="s1">&quot;isActive&quot;</span><span class="s0">,</span><span class="s1">&quot;broadcastRect&quot;</span><span class="s0">,</span><span class="s1">&quot;ResizeObserverEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;rectInit&quot;</span><span class="s0">,</span><span class="s1">&quot;contentRect&quot;</span><span class="s0">,</span><span class="s1">&quot;ResizeObserverSPI&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;callbackCtx&quot;</span><span class="s0">,</span><span class="s1">&quot;activeObservations_&quot;</span><span class="s0">,</span><span class="s1">&quot;observations_&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;callback_&quot;</span><span class="s0">,</span><span class="s1">&quot;controller_&quot;</span><span class="s0">,</span><span class="s1">&quot;callbackCtx_&quot;</span><span class="s0">,</span><span class="s1">&quot;Element&quot;</span><span class="s0">,</span><span class="s1">&quot;observations&quot;</span><span class="s0">,</span><span class="s1">&quot;unobserve&quot;</span><span class="s0">,</span><span class="s1">&quot;clearActive&quot;</span><span class="s0">,</span><span class="s1">&quot;_this&quot;</span><span class="s0">,</span><span class="s1">&quot;observation&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;ResizeObserver&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;E:/work/project/manager/vue/node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s2">\r\n </span><span class="s1">* A collection of shims that provide minimal functionality of the ES6 collections.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* These implementations are not meant to be used outside of the ResizeObserver</span><span class="s2">\r\n </span><span class="s1">* modules as they cover only a limited range of use cases.</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">/* eslint-disable require-jsdoc, valid-jsdoc */</span><span class="s2">\r\n</span><span class="s1">var MapShim = (function () {</span><span class="s2">\r\n    </span><span class="s1">if (typeof Map !== 'undefined') {</span><span class="s2">\r\n        </span><span class="s1">return Map;</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Returns index in provided array that matches the specified key.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @param {Array&lt;Array&gt;} arr</span><span class="s2">\r\n     </span><span class="s1">* @param {*} key</span><span class="s2">\r\n     </span><span class="s1">* @returns {number}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">function getIndex(arr, key) {</span><span class="s2">\r\n        </span><span class="s1">var result = -1;</span><span class="s2">\r\n        </span><span class="s1">arr.some(function (entry, index) {</span><span class="s2">\r\n            </span><span class="s1">if (entry[0] === key) {</span><span class="s2">\r\n                </span><span class="s1">result = index;</span><span class="s2">\r\n                </span><span class="s1">return true;</span><span class="s2">\r\n            </span><span class="s1">}</span><span class="s2">\r\n            </span><span class="s1">return false;</span><span class="s2">\r\n        </span><span class="s1">});</span><span class="s2">\r\n        </span><span class="s1">return result;</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">return /** @class */ (function () {</span><span class="s2">\r\n        </span><span class="s1">function class_1() {</span><span class="s2">\r\n            </span><span class="s1">this.__entries__ = [];</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">Object.defineProperty(class_1.prototype, </span><span class="s2">\&quot;</span><span class="s1">size</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\r\n            </span><span class="s1">/**</span><span class="s2">\r\n             </span><span class="s1">* @returns {boolean}</span><span class="s2">\r\n             </span><span class="s1">*/</span><span class="s2">\r\n            </span><span class="s1">get: function () {</span><span class="s2">\r\n                </span><span class="s1">return this.__entries__.length;</span><span class="s2">\r\n            </span><span class="s1">},</span><span class="s2">\r\n            </span><span class="s1">enumerable: true,</span><span class="s2">\r\n            </span><span class="s1">configurable: true</span><span class="s2">\r\n        </span><span class="s1">});</span><span class="s2">\r\n        </span><span class="s1">/**</span><span class="s2">\r\n         </span><span class="s1">* @param {*} key</span><span class="s2">\r\n         </span><span class="s1">* @returns {*}</span><span class="s2">\r\n         </span><span class="s1">*/</span><span class="s2">\r\n        </span><span class="s1">class_1.prototype.get = function (key) {</span><span class="s2">\r\n            </span><span class="s1">var index = getIndex(this.__entries__, key);</span><span class="s2">\r\n            </span><span class="s1">var entry = this.__entries__[index];</span><span class="s2">\r\n            </span><span class="s1">return entry &amp;&amp; entry[1];</span><span class="s2">\r\n        </span><span class="s1">};</span><span class="s2">\r\n        </span><span class="s1">/**</span><span class="s2">\r\n         </span><span class="s1">* @param {*} key</span><span class="s2">\r\n         </span><span class="s1">* @param {*} value</span><span class="s2">\r\n         </span><span class="s1">* @returns {void}</span><span class="s2">\r\n         </span><span class="s1">*/</span><span class="s2">\r\n        </span><span class="s1">class_1.prototype.set = function (key, value) {</span><span class="s2">\r\n            </span><span class="s1">var index = getIndex(this.__entries__, key);</span><span class="s2">\r\n            </span><span class="s1">if (~index) {</span><span class="s2">\r\n                </span><span class="s1">this.__entries__[index][1] = value;</span><span class="s2">\r\n            </span><span class="s1">}</span><span class="s2">\r\n            </span><span class="s1">else {</span><span class="s2">\r\n                </span><span class="s1">this.__entries__.push([key, value]);</span><span class="s2">\r\n            </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">};</span><span class="s2">\r\n        </span><span class="s1">/**</span><span class="s2">\r\n         </span><span class="s1">* @param {*} key</span><span class="s2">\r\n         </span><span class="s1">* @returns {void}</span><span class="s2">\r\n         </span><span class="s1">*/</span><span class="s2">\r\n        </span><span class="s1">class_1.prototype.delete = function (key) {</span><span class="s2">\r\n            </span><span class="s1">var entries = this.__entries__;</span><span class="s2">\r\n            </span><span class="s1">var index = getIndex(entries, key);</span><span class="s2">\r\n            </span><span class="s1">if (~index) {</span><span class="s2">\r\n                </span><span class="s1">entries.splice(index, 1);</span><span class="s2">\r\n            </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">};</span><span class="s2">\r\n        </span><span class="s1">/**</span><span class="s2">\r\n         </span><span class="s1">* @param {*} key</span><span class="s2">\r\n         </span><span class="s1">* @returns {void}</span><span class="s2">\r\n         </span><span class="s1">*/</span><span class="s2">\r\n        </span><span class="s1">class_1.prototype.has = function (key) {</span><span class="s2">\r\n            </span><span class="s1">return !!~getIndex(this.__entries__, key);</span><span class="s2">\r\n        </span><span class="s1">};</span><span class="s2">\r\n        </span><span class="s1">/**</span><span class="s2">\r\n         </span><span class="s1">* @returns {void}</span><span class="s2">\r\n         </span><span class="s1">*/</span><span class="s2">\r\n        </span><span class="s1">class_1.prototype.clear = function () {</span><span class="s2">\r\n            </span><span class="s1">this.__entries__.splice(0);</span><span class="s2">\r\n        </span><span class="s1">};</span><span class="s2">\r\n        </span><span class="s1">/**</span><span class="s2">\r\n         </span><span class="s1">* @param {Function} callback</span><span class="s2">\r\n         </span><span class="s1">* @param {*} [ctx=null]</span><span class="s2">\r\n         </span><span class="s1">* @returns {void}</span><span class="s2">\r\n         </span><span class="s1">*/</span><span class="s2">\r\n        </span><span class="s1">class_1.prototype.forEach = function (callback, ctx) {</span><span class="s2">\r\n            </span><span class="s1">if (ctx === void 0) { ctx = null; }</span><span class="s2">\r\n            </span><span class="s1">for (var _i = 0, _a = this.__entries__; _i &lt; _a.length; _i++) {</span><span class="s2">\r\n                </span><span class="s1">var entry = _a[_i];</span><span class="s2">\r\n                </span><span class="s1">callback.call(ctx, entry[1], entry[0]);</span><span class="s2">\r\n            </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">};</span><span class="s2">\r\n        </span><span class="s1">return class_1;</span><span class="s2">\r\n    </span><span class="s1">}());</span><span class="s2">\r\n</span><span class="s1">})();</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Detects whether window and document objects are available in current environment.</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">var isBrowser = typeof window !== 'undefined' &amp;&amp; typeof document !== 'undefined' &amp;&amp; window.document === document;</span><span class="s2">\n\n</span><span class="s1">// Returns global object of a current environment.</span><span class="s2">\r\n</span><span class="s1">var global$1 = (function () {</span><span class="s2">\r\n    </span><span class="s1">if (typeof global !== 'undefined' &amp;&amp; global.Math === Math) {</span><span class="s2">\r\n        </span><span class="s1">return global;</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">if (typeof self !== 'undefined' &amp;&amp; self.Math === Math) {</span><span class="s2">\r\n        </span><span class="s1">return self;</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">if (typeof window !== 'undefined' &amp;&amp; window.Math === Math) {</span><span class="s2">\r\n        </span><span class="s1">return window;</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">// eslint-disable-next-line no-new-func</span><span class="s2">\r\n    </span><span class="s1">return Function('return this')();</span><span class="s2">\r\n</span><span class="s1">})();</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* A shim for the requestAnimationFrame which falls back to the setTimeout if</span><span class="s2">\r\n </span><span class="s1">* first one is not supported.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @returns {number} Requests' identifier.</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">var requestAnimationFrame$1 = (function () {</span><span class="s2">\r\n    </span><span class="s1">if (typeof requestAnimationFrame === 'function') {</span><span class="s2">\r\n        </span><span class="s1">// It's required to use a bounded function because IE sometimes throws</span><span class="s2">\r\n        </span><span class="s1">// an </span><span class="s2">\&quot;</span><span class="s1">Invalid calling object</span><span class="s2">\&quot; </span><span class="s1">error if rAF is invoked without the global</span><span class="s2">\r\n        </span><span class="s1">// object on the left hand side.</span><span class="s2">\r\n        </span><span class="s1">return requestAnimationFrame.bind(global$1);</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };</span><span class="s2">\r\n</span><span class="s1">})();</span><span class="s2">\n\n</span><span class="s1">// Defines minimum timeout before adding a trailing call.</span><span class="s2">\r\n</span><span class="s1">var trailingTimeout = 2;</span><span class="s2">\r\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Creates a wrapper function which ensures that provided callback will be</span><span class="s2">\r\n </span><span class="s1">* invoked only once during the specified delay period.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {Function} callback - Function to be invoked after the delay period.</span><span class="s2">\r\n </span><span class="s1">* @param {number} delay - Delay after which to invoke callback.</span><span class="s2">\r\n </span><span class="s1">* @returns {Function}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">function throttle (callback, delay) {</span><span class="s2">\r\n    </span><span class="s1">var leadingCall = false, trailingCall = false, lastCallTime = 0;</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Invokes the original callback function and schedules new invocation if</span><span class="s2">\r\n     </span><span class="s1">* the </span><span class="s2">\&quot;</span><span class="s1">proxy</span><span class="s2">\&quot; </span><span class="s1">was called during current request.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @returns {void}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">function resolvePending() {</span><span class="s2">\r\n        </span><span class="s1">if (leadingCall) {</span><span class="s2">\r\n            </span><span class="s1">leadingCall = false;</span><span class="s2">\r\n            </span><span class="s1">callback();</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">if (trailingCall) {</span><span class="s2">\r\n            </span><span class="s1">proxy();</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Callback invoked after the specified delay. It will further postpone</span><span class="s2">\r\n     </span><span class="s1">* invocation of the original function delegating it to the</span><span class="s2">\r\n     </span><span class="s1">* requestAnimationFrame.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @returns {void}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">function timeoutCallback() {</span><span class="s2">\r\n        </span><span class="s1">requestAnimationFrame$1(resolvePending);</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Schedules invocation of the original function.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @returns {void}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">function proxy() {</span><span class="s2">\r\n        </span><span class="s1">var timeStamp = Date.now();</span><span class="s2">\r\n        </span><span class="s1">if (leadingCall) {</span><span class="s2">\r\n            </span><span class="s1">// Reject immediately following calls.</span><span class="s2">\r\n            </span><span class="s1">if (timeStamp - lastCallTime &lt; trailingTimeout) {</span><span class="s2">\r\n                </span><span class="s1">return;</span><span class="s2">\r\n            </span><span class="s1">}</span><span class="s2">\r\n            </span><span class="s1">// Schedule new call to be in invoked when the pending one is resolved.</span><span class="s2">\r\n            </span><span class="s1">// This is important for </span><span class="s2">\&quot;</span><span class="s1">transitions</span><span class="s2">\&quot; </span><span class="s1">which never actually start</span><span class="s2">\r\n            </span><span class="s1">// immediately so there is a chance that we might miss one if change</span><span class="s2">\r\n            </span><span class="s1">// happens amids the pending invocation.</span><span class="s2">\r\n            </span><span class="s1">trailingCall = true;</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">else {</span><span class="s2">\r\n            </span><span class="s1">leadingCall = true;</span><span class="s2">\r\n            </span><span class="s1">trailingCall = false;</span><span class="s2">\r\n            </span><span class="s1">setTimeout(timeoutCallback, delay);</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">lastCallTime = timeStamp;</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">return proxy;</span><span class="s2">\r\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// Minimum delay before invoking the update of observers.</span><span class="s2">\r\n</span><span class="s1">var REFRESH_DELAY = 20;</span><span class="s2">\r\n</span><span class="s1">// A list of substrings of CSS properties used to find transition events that</span><span class="s2">\r\n</span><span class="s1">// might affect dimensions of observed elements.</span><span class="s2">\r\n</span><span class="s1">var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];</span><span class="s2">\r\n</span><span class="s1">// Check if MutationObserver is available.</span><span class="s2">\r\n</span><span class="s1">var mutationObserverSupported = typeof MutationObserver !== 'undefined';</span><span class="s2">\r\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Singleton controller class which handles updates of ResizeObserver instances.</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">var ResizeObserverController = /** @class */ (function () {</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Creates a new instance of ResizeObserverController.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @private</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">function ResizeObserverController() {</span><span class="s2">\r\n        </span><span class="s1">/**</span><span class="s2">\r\n         </span><span class="s1">* Indicates whether DOM listeners have been added.</span><span class="s2">\r\n         </span><span class="s1">*</span><span class="s2">\r\n         </span><span class="s1">* @private {boolean}</span><span class="s2">\r\n         </span><span class="s1">*/</span><span class="s2">\r\n        </span><span class="s1">this.connected_ = false;</span><span class="s2">\r\n        </span><span class="s1">/**</span><span class="s2">\r\n         </span><span class="s1">* Tells that controller has subscribed for Mutation Events.</span><span class="s2">\r\n         </span><span class="s1">*</span><span class="s2">\r\n         </span><span class="s1">* @private {boolean}</span><span class="s2">\r\n         </span><span class="s1">*/</span><span class="s2">\r\n        </span><span class="s1">this.mutationEventsAdded_ = false;</span><span class="s2">\r\n        </span><span class="s1">/**</span><span class="s2">\r\n         </span><span class="s1">* Keeps reference to the instance of MutationObserver.</span><span class="s2">\r\n         </span><span class="s1">*</span><span class="s2">\r\n         </span><span class="s1">* @private {MutationObserver}</span><span class="s2">\r\n         </span><span class="s1">*/</span><span class="s2">\r\n        </span><span class="s1">this.mutationsObserver_ = null;</span><span class="s2">\r\n        </span><span class="s1">/**</span><span class="s2">\r\n         </span><span class="s1">* A list of connected observers.</span><span class="s2">\r\n         </span><span class="s1">*</span><span class="s2">\r\n         </span><span class="s1">* @private {Array&lt;ResizeObserverSPI&gt;}</span><span class="s2">\r\n         </span><span class="s1">*/</span><span class="s2">\r\n        </span><span class="s1">this.observers_ = [];</span><span class="s2">\r\n        </span><span class="s1">this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);</span><span class="s2">\r\n        </span><span class="s1">this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Adds observer to observers list.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @param {ResizeObserverSPI} observer - Observer to be added.</span><span class="s2">\r\n     </span><span class="s1">* @returns {void}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObserverController.prototype.addObserver = function (observer) {</span><span class="s2">\r\n        </span><span class="s1">if (!~this.observers_.indexOf(observer)) {</span><span class="s2">\r\n            </span><span class="s1">this.observers_.push(observer);</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">// Add listeners if they haven't been added yet.</span><span class="s2">\r\n        </span><span class="s1">if (!this.connected_) {</span><span class="s2">\r\n            </span><span class="s1">this.connect_();</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Removes observer from observers list.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @param {ResizeObserverSPI} observer - Observer to be removed.</span><span class="s2">\r\n     </span><span class="s1">* @returns {void}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObserverController.prototype.removeObserver = function (observer) {</span><span class="s2">\r\n        </span><span class="s1">var observers = this.observers_;</span><span class="s2">\r\n        </span><span class="s1">var index = observers.indexOf(observer);</span><span class="s2">\r\n        </span><span class="s1">// Remove observer if it's present in registry.</span><span class="s2">\r\n        </span><span class="s1">if (~index) {</span><span class="s2">\r\n            </span><span class="s1">observers.splice(index, 1);</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">// Remove listeners if controller has no connected observers.</span><span class="s2">\r\n        </span><span class="s1">if (!observers.length &amp;&amp; this.connected_) {</span><span class="s2">\r\n            </span><span class="s1">this.disconnect_();</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Invokes the update of observers. It will continue running updates insofar</span><span class="s2">\r\n     </span><span class="s1">* it detects changes.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @returns {void}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObserverController.prototype.refresh = function () {</span><span class="s2">\r\n        </span><span class="s1">var changesDetected = this.updateObservers_();</span><span class="s2">\r\n        </span><span class="s1">// Continue running updates if changes have been detected as there might</span><span class="s2">\r\n        </span><span class="s1">// be future ones caused by CSS transitions.</span><span class="s2">\r\n        </span><span class="s1">if (changesDetected) {</span><span class="s2">\r\n            </span><span class="s1">this.refresh();</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Updates every observer from observers list and notifies them of queued</span><span class="s2">\r\n     </span><span class="s1">* entries.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @private</span><span class="s2">\r\n     </span><span class="s1">* @returns {boolean} Returns </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot; </span><span class="s1">if any observer has detected changes in</span><span class="s2">\r\n     </span><span class="s1">*      dimensions of it's elements.</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObserverController.prototype.updateObservers_ = function () {</span><span class="s2">\r\n        </span><span class="s1">// Collect observers that have active observations.</span><span class="s2">\r\n        </span><span class="s1">var activeObservers = this.observers_.filter(function (observer) {</span><span class="s2">\r\n            </span><span class="s1">return observer.gatherActive(), observer.hasActive();</span><span class="s2">\r\n        </span><span class="s1">});</span><span class="s2">\r\n        </span><span class="s1">// Deliver notifications in a separate cycle in order to avoid any</span><span class="s2">\r\n        </span><span class="s1">// collisions between observers, e.g. when multiple instances of</span><span class="s2">\r\n        </span><span class="s1">// ResizeObserver are tracking the same element and the callback of one</span><span class="s2">\r\n        </span><span class="s1">// of them changes content dimensions of the observed target. Sometimes</span><span class="s2">\r\n        </span><span class="s1">// this may result in notifications being blocked for the rest of observers.</span><span class="s2">\r\n        </span><span class="s1">activeObservers.forEach(function (observer) { return observer.broadcastActive(); });</span><span class="s2">\r\n        </span><span class="s1">return activeObservers.length &gt; 0;</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Initializes DOM listeners.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @private</span><span class="s2">\r\n     </span><span class="s1">* @returns {void}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObserverController.prototype.connect_ = function () {</span><span class="s2">\r\n        </span><span class="s1">// Do nothing if running in a non-browser environment or if listeners</span><span class="s2">\r\n        </span><span class="s1">// have been already added.</span><span class="s2">\r\n        </span><span class="s1">if (!isBrowser || this.connected_) {</span><span class="s2">\r\n            </span><span class="s1">return;</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">// Subscription to the </span><span class="s2">\&quot;</span><span class="s1">Transitionend</span><span class="s2">\&quot; </span><span class="s1">event is used as a workaround for</span><span class="s2">\r\n        </span><span class="s1">// delayed transitions. This way it's possible to capture at least the</span><span class="s2">\r\n        </span><span class="s1">// final state of an element.</span><span class="s2">\r\n        </span><span class="s1">document.addEventListener('transitionend', this.onTransitionEnd_);</span><span class="s2">\r\n        </span><span class="s1">window.addEventListener('resize', this.refresh);</span><span class="s2">\r\n        </span><span class="s1">if (mutationObserverSupported) {</span><span class="s2">\r\n            </span><span class="s1">this.mutationsObserver_ = new MutationObserver(this.refresh);</span><span class="s2">\r\n            </span><span class="s1">this.mutationsObserver_.observe(document, {</span><span class="s2">\r\n                </span><span class="s1">attributes: true,</span><span class="s2">\r\n                </span><span class="s1">childList: true,</span><span class="s2">\r\n                </span><span class="s1">characterData: true,</span><span class="s2">\r\n                </span><span class="s1">subtree: true</span><span class="s2">\r\n            </span><span class="s1">});</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">else {</span><span class="s2">\r\n            </span><span class="s1">document.addEventListener('DOMSubtreeModified', this.refresh);</span><span class="s2">\r\n            </span><span class="s1">this.mutationEventsAdded_ = true;</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">this.connected_ = true;</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Removes DOM listeners.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @private</span><span class="s2">\r\n     </span><span class="s1">* @returns {void}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObserverController.prototype.disconnect_ = function () {</span><span class="s2">\r\n        </span><span class="s1">// Do nothing if running in a non-browser environment or if listeners</span><span class="s2">\r\n        </span><span class="s1">// have been already removed.</span><span class="s2">\r\n        </span><span class="s1">if (!isBrowser || !this.connected_) {</span><span class="s2">\r\n            </span><span class="s1">return;</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">document.removeEventListener('transitionend', this.onTransitionEnd_);</span><span class="s2">\r\n        </span><span class="s1">window.removeEventListener('resize', this.refresh);</span><span class="s2">\r\n        </span><span class="s1">if (this.mutationsObserver_) {</span><span class="s2">\r\n            </span><span class="s1">this.mutationsObserver_.disconnect();</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">if (this.mutationEventsAdded_) {</span><span class="s2">\r\n            </span><span class="s1">document.removeEventListener('DOMSubtreeModified', this.refresh);</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">this.mutationsObserver_ = null;</span><span class="s2">\r\n        </span><span class="s1">this.mutationEventsAdded_ = false;</span><span class="s2">\r\n        </span><span class="s1">this.connected_ = false;</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* </span><span class="s2">\&quot;</span><span class="s1">Transitionend</span><span class="s2">\&quot; </span><span class="s1">event handler.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @private</span><span class="s2">\r\n     </span><span class="s1">* @param {TransitionEvent} event</span><span class="s2">\r\n     </span><span class="s1">* @returns {void}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {</span><span class="s2">\r\n        </span><span class="s1">var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;</span><span class="s2">\r\n        </span><span class="s1">// Detect whether transition may affect dimensions of an element.</span><span class="s2">\r\n        </span><span class="s1">var isReflowProperty = transitionKeys.some(function (key) {</span><span class="s2">\r\n            </span><span class="s1">return !!~propertyName.indexOf(key);</span><span class="s2">\r\n        </span><span class="s1">});</span><span class="s2">\r\n        </span><span class="s1">if (isReflowProperty) {</span><span class="s2">\r\n            </span><span class="s1">this.refresh();</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Returns instance of the ResizeObserverController.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @returns {ResizeObserverController}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObserverController.getInstance = function () {</span><span class="s2">\r\n        </span><span class="s1">if (!this.instance_) {</span><span class="s2">\r\n            </span><span class="s1">this.instance_ = new ResizeObserverController();</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">return this.instance_;</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Holds reference to the controller's instance.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @private {ResizeObserverController}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObserverController.instance_ = null;</span><span class="s2">\r\n    </span><span class="s1">return ResizeObserverController;</span><span class="s2">\r\n</span><span class="s1">}());</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Defines non-writable/enumerable properties of the provided target object.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {Object} target - Object for which to define properties.</span><span class="s2">\r\n </span><span class="s1">* @param {Object} props - Properties to be defined.</span><span class="s2">\r\n </span><span class="s1">* @returns {Object} Target object.</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">var defineConfigurable = (function (target, props) {</span><span class="s2">\r\n    </span><span class="s1">for (var _i = 0, _a = Object.keys(props); _i &lt; _a.length; _i++) {</span><span class="s2">\r\n        </span><span class="s1">var key = _a[_i];</span><span class="s2">\r\n        </span><span class="s1">Object.defineProperty(target, key, {</span><span class="s2">\r\n            </span><span class="s1">value: props[key],</span><span class="s2">\r\n            </span><span class="s1">enumerable: false,</span><span class="s2">\r\n            </span><span class="s1">writable: false,</span><span class="s2">\r\n            </span><span class="s1">configurable: true</span><span class="s2">\r\n        </span><span class="s1">});</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">return target;</span><span class="s2">\r\n</span><span class="s1">});</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Returns the global object associated with provided element.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {Object} target</span><span class="s2">\r\n </span><span class="s1">* @returns {Object}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">var getWindowOf = (function (target) {</span><span class="s2">\r\n    </span><span class="s1">// Assume that the element is an instance of Node, which means that it</span><span class="s2">\r\n    </span><span class="s1">// has the </span><span class="s2">\&quot;</span><span class="s1">ownerDocument</span><span class="s2">\&quot; </span><span class="s1">property from which we can retrieve a</span><span class="s2">\r\n    </span><span class="s1">// corresponding global object.</span><span class="s2">\r\n    </span><span class="s1">var ownerGlobal = target &amp;&amp; target.ownerDocument &amp;&amp; target.ownerDocument.defaultView;</span><span class="s2">\r\n    </span><span class="s1">// Return the local global object if it's not possible extract one from</span><span class="s2">\r\n    </span><span class="s1">// provided element.</span><span class="s2">\r\n    </span><span class="s1">return ownerGlobal || global$1;</span><span class="s2">\r\n</span><span class="s1">});</span><span class="s2">\n\n</span><span class="s1">// Placeholder of an empty content rectangle.</span><span class="s2">\r\n</span><span class="s1">var emptyRect = createRectInit(0, 0, 0, 0);</span><span class="s2">\r\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Converts provided string to a number.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {number|string} value</span><span class="s2">\r\n </span><span class="s1">* @returns {number}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">function toFloat(value) {</span><span class="s2">\r\n    </span><span class="s1">return parseFloat(value) || 0;</span><span class="s2">\r\n</span><span class="s1">}</span><span class="s2">\r\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Extracts borders size from provided styles.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {CSSStyleDeclaration} styles</span><span class="s2">\r\n </span><span class="s1">* @param {...string} positions - Borders positions (top, right, ...)</span><span class="s2">\r\n </span><span class="s1">* @returns {number}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">function getBordersSize(styles) {</span><span class="s2">\r\n    </span><span class="s1">var positions = [];</span><span class="s2">\r\n    </span><span class="s1">for (var _i = 1; _i &lt; arguments.length; _i++) {</span><span class="s2">\r\n        </span><span class="s1">positions[_i - 1] = arguments[_i];</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">return positions.reduce(function (size, position) {</span><span class="s2">\r\n        </span><span class="s1">var value = styles['border-' + position + '-width'];</span><span class="s2">\r\n        </span><span class="s1">return size + toFloat(value);</span><span class="s2">\r\n    </span><span class="s1">}, 0);</span><span class="s2">\r\n</span><span class="s1">}</span><span class="s2">\r\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Extracts paddings sizes from provided styles.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {CSSStyleDeclaration} styles</span><span class="s2">\r\n </span><span class="s1">* @returns {Object} Paddings box.</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">function getPaddings(styles) {</span><span class="s2">\r\n    </span><span class="s1">var positions = ['top', 'right', 'bottom', 'left'];</span><span class="s2">\r\n    </span><span class="s1">var paddings = {};</span><span class="s2">\r\n    </span><span class="s1">for (var _i = 0, positions_1 = positions; _i &lt; positions_1.length; _i++) {</span><span class="s2">\r\n        </span><span class="s1">var position = positions_1[_i];</span><span class="s2">\r\n        </span><span class="s1">var value = styles['padding-' + position];</span><span class="s2">\r\n        </span><span class="s1">paddings[position] = toFloat(value);</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">return paddings;</span><span class="s2">\r\n</span><span class="s1">}</span><span class="s2">\r\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Calculates content rectangle of provided SVG element.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {SVGGraphicsElement} target - Element content rectangle of which needs</span><span class="s2">\r\n </span><span class="s1">*      to be calculated.</span><span class="s2">\r\n </span><span class="s1">* @returns {DOMRectInit}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">function getSVGContentRect(target) {</span><span class="s2">\r\n    </span><span class="s1">var bbox = target.getBBox();</span><span class="s2">\r\n    </span><span class="s1">return createRectInit(0, 0, bbox.width, bbox.height);</span><span class="s2">\r\n</span><span class="s1">}</span><span class="s2">\r\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Calculates content rectangle of provided HTMLElement.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {HTMLElement} target - Element for which to calculate the content rectangle.</span><span class="s2">\r\n </span><span class="s1">* @returns {DOMRectInit}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">function getHTMLElementContentRect(target) {</span><span class="s2">\r\n    </span><span class="s1">// Client width &amp; height properties can't be</span><span class="s2">\r\n    </span><span class="s1">// used exclusively as they provide rounded values.</span><span class="s2">\r\n    </span><span class="s1">var clientWidth = target.clientWidth, clientHeight = target.clientHeight;</span><span class="s2">\r\n    </span><span class="s1">// By this condition we can catch all non-replaced inline, hidden and</span><span class="s2">\r\n    </span><span class="s1">// detached elements. Though elements with width &amp; height properties less</span><span class="s2">\r\n    </span><span class="s1">// than 0.5 will be discarded as well.</span><span class="s2">\r\n    </span><span class="s1">//</span><span class="s2">\r\n    </span><span class="s1">// Without it we would need to implement separate methods for each of</span><span class="s2">\r\n    </span><span class="s1">// those cases and it's not possible to perform a precise and performance</span><span class="s2">\r\n    </span><span class="s1">// effective test for hidden elements. E.g. even jQuery's ':visible' filter</span><span class="s2">\r\n    </span><span class="s1">// gives wrong results for elements with width &amp; height less than 0.5.</span><span class="s2">\r\n    </span><span class="s1">if (!clientWidth &amp;&amp; !clientHeight) {</span><span class="s2">\r\n        </span><span class="s1">return emptyRect;</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">var styles = getWindowOf(target).getComputedStyle(target);</span><span class="s2">\r\n    </span><span class="s1">var paddings = getPaddings(styles);</span><span class="s2">\r\n    </span><span class="s1">var horizPad = paddings.left + paddings.right;</span><span class="s2">\r\n    </span><span class="s1">var vertPad = paddings.top + paddings.bottom;</span><span class="s2">\r\n    </span><span class="s1">// Computed styles of width &amp; height are being used because they are the</span><span class="s2">\r\n    </span><span class="s1">// only dimensions available to JS that contain non-rounded values. It could</span><span class="s2">\r\n    </span><span class="s1">// be possible to utilize the getBoundingClientRect if only it's data wasn't</span><span class="s2">\r\n    </span><span class="s1">// affected by CSS transformations let alone paddings, borders and scroll bars.</span><span class="s2">\r\n    </span><span class="s1">var width = toFloat(styles.width), height = toFloat(styles.height);</span><span class="s2">\r\n    </span><span class="s1">// Width &amp; height include paddings and borders when the 'border-box' box</span><span class="s2">\r\n    </span><span class="s1">// model is applied (except for IE).</span><span class="s2">\r\n    </span><span class="s1">if (styles.boxSizing === 'border-box') {</span><span class="s2">\r\n        </span><span class="s1">// Following conditions are required to handle Internet Explorer which</span><span class="s2">\r\n        </span><span class="s1">// doesn't include paddings and borders to computed CSS dimensions.</span><span class="s2">\r\n        </span><span class="s1">//</span><span class="s2">\r\n        </span><span class="s1">// We can say that if CSS dimensions + paddings are equal to the </span><span class="s2">\&quot;</span><span class="s1">client</span><span class="s2">\&quot;\r\n        </span><span class="s1">// properties then it's either IE, and thus we don't need to subtract</span><span class="s2">\r\n        </span><span class="s1">// anything, or an element merely doesn't have paddings/borders styles.</span><span class="s2">\r\n        </span><span class="s1">if (Math.round(width + horizPad) !== clientWidth) {</span><span class="s2">\r\n            </span><span class="s1">width -= getBordersSize(styles, 'left', 'right') + horizPad;</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">if (Math.round(height + vertPad) !== clientHeight) {</span><span class="s2">\r\n            </span><span class="s1">height -= getBordersSize(styles, 'top', 'bottom') + vertPad;</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">// Following steps can't be applied to the document's root element as its</span><span class="s2">\r\n    </span><span class="s1">// client[Width/Height] properties represent viewport area of the window.</span><span class="s2">\r\n    </span><span class="s1">// Besides, it's as well not necessary as the &lt;html&gt; itself neither has</span><span class="s2">\r\n    </span><span class="s1">// rendered scroll bars nor it can be clipped.</span><span class="s2">\r\n    </span><span class="s1">if (!isDocumentElement(target)) {</span><span class="s2">\r\n        </span><span class="s1">// In some browsers (only in Firefox, actually) CSS width &amp; height</span><span class="s2">\r\n        </span><span class="s1">// include scroll bars size which can be removed at this step as scroll</span><span class="s2">\r\n        </span><span class="s1">// bars are the only difference between rounded dimensions + paddings</span><span class="s2">\r\n        </span><span class="s1">// and </span><span class="s2">\&quot;</span><span class="s1">client</span><span class="s2">\&quot; </span><span class="s1">properties, though that is not always true in Chrome.</span><span class="s2">\r\n        </span><span class="s1">var vertScrollbar = Math.round(width + horizPad) - clientWidth;</span><span class="s2">\r\n        </span><span class="s1">var horizScrollbar = Math.round(height + vertPad) - clientHeight;</span><span class="s2">\r\n        </span><span class="s1">// Chrome has a rather weird rounding of </span><span class="s2">\&quot;</span><span class="s1">client</span><span class="s2">\&quot; </span><span class="s1">properties.</span><span class="s2">\r\n        </span><span class="s1">// E.g. for an element with content width of 314.2px it sometimes gives</span><span class="s2">\r\n        </span><span class="s1">// the client width of 315px and for the width of 314.7px it may give</span><span class="s2">\r\n        </span><span class="s1">// 314px. And it doesn't happen all the time. So just ignore this delta</span><span class="s2">\r\n        </span><span class="s1">// as a non-relevant.</span><span class="s2">\r\n        </span><span class="s1">if (Math.abs(vertScrollbar) !== 1) {</span><span class="s2">\r\n            </span><span class="s1">width -= vertScrollbar;</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">if (Math.abs(horizScrollbar) !== 1) {</span><span class="s2">\r\n            </span><span class="s1">height -= horizScrollbar;</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">return createRectInit(paddings.left, paddings.top, width, height);</span><span class="s2">\r\n</span><span class="s1">}</span><span class="s2">\r\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Checks whether provided element is an instance of the SVGGraphicsElement.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {Element} target - Element to be checked.</span><span class="s2">\r\n </span><span class="s1">* @returns {boolean}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">var isSVGGraphicsElement = (function () {</span><span class="s2">\r\n    </span><span class="s1">// Some browsers, namely IE and Edge, don't have the SVGGraphicsElement</span><span class="s2">\r\n    </span><span class="s1">// interface.</span><span class="s2">\r\n    </span><span class="s1">if (typeof SVGGraphicsElement !== 'undefined') {</span><span class="s2">\r\n        </span><span class="s1">return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">// If it's so, then check that element is at least an instance of the</span><span class="s2">\r\n    </span><span class="s1">// SVGElement and that it has the </span><span class="s2">\&quot;</span><span class="s1">getBBox</span><span class="s2">\&quot; </span><span class="s1">method.</span><span class="s2">\r\n    </span><span class="s1">// eslint-disable-next-line no-extra-parens</span><span class="s2">\r\n    </span><span class="s1">return function (target) { return (target instanceof getWindowOf(target).SVGElement &amp;&amp;</span><span class="s2">\r\n        </span><span class="s1">typeof target.getBBox === 'function'); };</span><span class="s2">\r\n</span><span class="s1">})();</span><span class="s2">\r\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Checks whether provided element is a document element (&lt;html&gt;).</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {Element} target - Element to be checked.</span><span class="s2">\r\n </span><span class="s1">* @returns {boolean}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">function isDocumentElement(target) {</span><span class="s2">\r\n    </span><span class="s1">return target === getWindowOf(target).document.documentElement;</span><span class="s2">\r\n</span><span class="s1">}</span><span class="s2">\r\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Calculates an appropriate content rectangle for provided html or svg element.</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {Element} target - Element content rectangle of which needs to be calculated.</span><span class="s2">\r\n </span><span class="s1">* @returns {DOMRectInit}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">function getContentRect(target) {</span><span class="s2">\r\n    </span><span class="s1">if (!isBrowser) {</span><span class="s2">\r\n        </span><span class="s1">return emptyRect;</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">if (isSVGGraphicsElement(target)) {</span><span class="s2">\r\n        </span><span class="s1">return getSVGContentRect(target);</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">return getHTMLElementContentRect(target);</span><span class="s2">\r\n</span><span class="s1">}</span><span class="s2">\r\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Creates rectangle with an interface of the DOMRectReadOnly.</span><span class="s2">\r\n </span><span class="s1">* Spec: https://drafts.fxtf.org/geometry/#domrectreadonly</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.</span><span class="s2">\r\n </span><span class="s1">* @returns {DOMRectReadOnly}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">function createReadOnlyRect(_a) {</span><span class="s2">\r\n    </span><span class="s1">var x = _a.x, y = _a.y, width = _a.width, height = _a.height;</span><span class="s2">\r\n    </span><span class="s1">// If DOMRectReadOnly is available use it as a prototype for the rectangle.</span><span class="s2">\r\n    </span><span class="s1">var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;</span><span class="s2">\r\n    </span><span class="s1">var rect = Object.create(Constr.prototype);</span><span class="s2">\r\n    </span><span class="s1">// Rectangle's properties are not writable and non-enumerable.</span><span class="s2">\r\n    </span><span class="s1">defineConfigurable(rect, {</span><span class="s2">\r\n        </span><span class="s1">x: x, y: y, width: width, height: height,</span><span class="s2">\r\n        </span><span class="s1">top: y,</span><span class="s2">\r\n        </span><span class="s1">right: x + width,</span><span class="s2">\r\n        </span><span class="s1">bottom: height + y,</span><span class="s2">\r\n        </span><span class="s1">left: x</span><span class="s2">\r\n    </span><span class="s1">});</span><span class="s2">\r\n    </span><span class="s1">return rect;</span><span class="s2">\r\n</span><span class="s1">}</span><span class="s2">\r\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.</span><span class="s2">\r\n </span><span class="s1">* Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit</span><span class="s2">\r\n </span><span class="s1">*</span><span class="s2">\r\n </span><span class="s1">* @param {number} x - X coordinate.</span><span class="s2">\r\n </span><span class="s1">* @param {number} y - Y coordinate.</span><span class="s2">\r\n </span><span class="s1">* @param {number} width - Rectangle's width.</span><span class="s2">\r\n </span><span class="s1">* @param {number} height - Rectangle's height.</span><span class="s2">\r\n </span><span class="s1">* @returns {DOMRectInit}</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">function createRectInit(x, y, width, height) {</span><span class="s2">\r\n    </span><span class="s1">return { x: x, y: y, width: width, height: height };</span><span class="s2">\r\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* Class that is responsible for computations of the content rectangle of</span><span class="s2">\r\n </span><span class="s1">* provided DOM element and for keeping track of it's changes.</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">var ResizeObservation = /** @class */ (function () {</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Creates an instance of ResizeObservation.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @param {Element} target - Element to be observed.</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">function ResizeObservation(target) {</span><span class="s2">\r\n        </span><span class="s1">/**</span><span class="s2">\r\n         </span><span class="s1">* Broadcasted width of content rectangle.</span><span class="s2">\r\n         </span><span class="s1">*</span><span class="s2">\r\n         </span><span class="s1">* @type {number}</span><span class="s2">\r\n         </span><span class="s1">*/</span><span class="s2">\r\n        </span><span class="s1">this.broadcastWidth = 0;</span><span class="s2">\r\n        </span><span class="s1">/**</span><span class="s2">\r\n         </span><span class="s1">* Broadcasted height of content rectangle.</span><span class="s2">\r\n         </span><span class="s1">*</span><span class="s2">\r\n         </span><span class="s1">* @type {number}</span><span class="s2">\r\n         </span><span class="s1">*/</span><span class="s2">\r\n        </span><span class="s1">this.broadcastHeight = 0;</span><span class="s2">\r\n        </span><span class="s1">/**</span><span class="s2">\r\n         </span><span class="s1">* Reference to the last observed content rectangle.</span><span class="s2">\r\n         </span><span class="s1">*</span><span class="s2">\r\n         </span><span class="s1">* @private {DOMRectInit}</span><span class="s2">\r\n         </span><span class="s1">*/</span><span class="s2">\r\n        </span><span class="s1">this.contentRect_ = createRectInit(0, 0, 0, 0);</span><span class="s2">\r\n        </span><span class="s1">this.target = target;</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Updates content rectangle and tells whether it's width or height properties</span><span class="s2">\r\n     </span><span class="s1">* have changed since the last broadcast.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @returns {boolean}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObservation.prototype.isActive = function () {</span><span class="s2">\r\n        </span><span class="s1">var rect = getContentRect(this.target);</span><span class="s2">\r\n        </span><span class="s1">this.contentRect_ = rect;</span><span class="s2">\r\n        </span><span class="s1">return (rect.width !== this.broadcastWidth ||</span><span class="s2">\r\n            </span><span class="s1">rect.height !== this.broadcastHeight);</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Updates 'broadcastWidth' and 'broadcastHeight' properties with a data</span><span class="s2">\r\n     </span><span class="s1">* from the corresponding properties of the last observed content rectangle.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @returns {DOMRectInit} Last observed content rectangle.</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObservation.prototype.broadcastRect = function () {</span><span class="s2">\r\n        </span><span class="s1">var rect = this.contentRect_;</span><span class="s2">\r\n        </span><span class="s1">this.broadcastWidth = rect.width;</span><span class="s2">\r\n        </span><span class="s1">this.broadcastHeight = rect.height;</span><span class="s2">\r\n        </span><span class="s1">return rect;</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">return ResizeObservation;</span><span class="s2">\r\n</span><span class="s1">}());</span><span class="s2">\n\n</span><span class="s1">var ResizeObserverEntry = /** @class */ (function () {</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Creates an instance of ResizeObserverEntry.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @param {Element} target - Element that is being observed.</span><span class="s2">\r\n     </span><span class="s1">* @param {DOMRectInit} rectInit - Data of the element's content rectangle.</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">function ResizeObserverEntry(target, rectInit) {</span><span class="s2">\r\n        </span><span class="s1">var contentRect = createReadOnlyRect(rectInit);</span><span class="s2">\r\n        </span><span class="s1">// According to the specification following properties are not writable</span><span class="s2">\r\n        </span><span class="s1">// and are also not enumerable in the native implementation.</span><span class="s2">\r\n        </span><span class="s1">//</span><span class="s2">\r\n        </span><span class="s1">// Property accessors are not being used as they'd require to define a</span><span class="s2">\r\n        </span><span class="s1">// private WeakMap storage which may cause memory leaks in browsers that</span><span class="s2">\r\n        </span><span class="s1">// don't support this type of collections.</span><span class="s2">\r\n        </span><span class="s1">defineConfigurable(this, { target: target, contentRect: contentRect });</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">return ResizeObserverEntry;</span><span class="s2">\r\n</span><span class="s1">}());</span><span class="s2">\n\n</span><span class="s1">var ResizeObserverSPI = /** @class */ (function () {</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Creates a new instance of ResizeObserver.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @param {ResizeObserverCallback} callback - Callback function that is invoked</span><span class="s2">\r\n     </span><span class="s1">*      when one of the observed elements changes it's content dimensions.</span><span class="s2">\r\n     </span><span class="s1">* @param {ResizeObserverController} controller - Controller instance which</span><span class="s2">\r\n     </span><span class="s1">*      is responsible for the updates of observer.</span><span class="s2">\r\n     </span><span class="s1">* @param {ResizeObserver} callbackCtx - Reference to the public</span><span class="s2">\r\n     </span><span class="s1">*      ResizeObserver instance which will be passed to callback function.</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">function ResizeObserverSPI(callback, controller, callbackCtx) {</span><span class="s2">\r\n        </span><span class="s1">/**</span><span class="s2">\r\n         </span><span class="s1">* Collection of resize observations that have detected changes in dimensions</span><span class="s2">\r\n         </span><span class="s1">* of elements.</span><span class="s2">\r\n         </span><span class="s1">*</span><span class="s2">\r\n         </span><span class="s1">* @private {Array&lt;ResizeObservation&gt;}</span><span class="s2">\r\n         </span><span class="s1">*/</span><span class="s2">\r\n        </span><span class="s1">this.activeObservations_ = [];</span><span class="s2">\r\n        </span><span class="s1">/**</span><span class="s2">\r\n         </span><span class="s1">* Registry of the ResizeObservation instances.</span><span class="s2">\r\n         </span><span class="s1">*</span><span class="s2">\r\n         </span><span class="s1">* @private {Map&lt;Element, ResizeObservation&gt;}</span><span class="s2">\r\n         </span><span class="s1">*/</span><span class="s2">\r\n        </span><span class="s1">this.observations_ = new MapShim();</span><span class="s2">\r\n        </span><span class="s1">if (typeof callback !== 'function') {</span><span class="s2">\r\n            </span><span class="s1">throw new TypeError('The callback provided as parameter 1 is not a function.');</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">this.callback_ = callback;</span><span class="s2">\r\n        </span><span class="s1">this.controller_ = controller;</span><span class="s2">\r\n        </span><span class="s1">this.callbackCtx_ = callbackCtx;</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Starts observing provided element.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @param {Element} target - Element to be observed.</span><span class="s2">\r\n     </span><span class="s1">* @returns {void}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObserverSPI.prototype.observe = function (target) {</span><span class="s2">\r\n        </span><span class="s1">if (!arguments.length) {</span><span class="s2">\r\n            </span><span class="s1">throw new TypeError('1 argument required, but only 0 present.');</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">// Do nothing if current environment doesn't have the Element interface.</span><span class="s2">\r\n        </span><span class="s1">if (typeof Element === 'undefined' || !(Element instanceof Object)) {</span><span class="s2">\r\n            </span><span class="s1">return;</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">if (!(target instanceof getWindowOf(target).Element)) {</span><span class="s2">\r\n            </span><span class="s1">throw new TypeError('parameter 1 is not of type </span><span class="s2">\&quot;</span><span class="s1">Element</span><span class="s2">\&quot;</span><span class="s1">.');</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">var observations = this.observations_;</span><span class="s2">\r\n        </span><span class="s1">// Do nothing if element is already being observed.</span><span class="s2">\r\n        </span><span class="s1">if (observations.has(target)) {</span><span class="s2">\r\n            </span><span class="s1">return;</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">observations.set(target, new ResizeObservation(target));</span><span class="s2">\r\n        </span><span class="s1">this.controller_.addObserver(this);</span><span class="s2">\r\n        </span><span class="s1">// Force the update of observations.</span><span class="s2">\r\n        </span><span class="s1">this.controller_.refresh();</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Stops observing provided element.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @param {Element} target - Element to stop observing.</span><span class="s2">\r\n     </span><span class="s1">* @returns {void}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObserverSPI.prototype.unobserve = function (target) {</span><span class="s2">\r\n        </span><span class="s1">if (!arguments.length) {</span><span class="s2">\r\n            </span><span class="s1">throw new TypeError('1 argument required, but only 0 present.');</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">// Do nothing if current environment doesn't have the Element interface.</span><span class="s2">\r\n        </span><span class="s1">if (typeof Element === 'undefined' || !(Element instanceof Object)) {</span><span class="s2">\r\n            </span><span class="s1">return;</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">if (!(target instanceof getWindowOf(target).Element)) {</span><span class="s2">\r\n            </span><span class="s1">throw new TypeError('parameter 1 is not of type </span><span class="s2">\&quot;</span><span class="s1">Element</span><span class="s2">\&quot;</span><span class="s1">.');</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">var observations = this.observations_;</span><span class="s2">\r\n        </span><span class="s1">// Do nothing if element is not being observed.</span><span class="s2">\r\n        </span><span class="s1">if (!observations.has(target)) {</span><span class="s2">\r\n            </span><span class="s1">return;</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">observations.delete(target);</span><span class="s2">\r\n        </span><span class="s1">if (!observations.size) {</span><span class="s2">\r\n            </span><span class="s1">this.controller_.removeObserver(this);</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Stops observing all elements.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @returns {void}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObserverSPI.prototype.disconnect = function () {</span><span class="s2">\r\n        </span><span class="s1">this.clearActive();</span><span class="s2">\r\n        </span><span class="s1">this.observations_.clear();</span><span class="s2">\r\n        </span><span class="s1">this.controller_.removeObserver(this);</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Collects observation instances the associated element of which has changed</span><span class="s2">\r\n     </span><span class="s1">* it's content rectangle.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @returns {void}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObserverSPI.prototype.gatherActive = function () {</span><span class="s2">\r\n        </span><span class="s1">var _this = this;</span><span class="s2">\r\n        </span><span class="s1">this.clearActive();</span><span class="s2">\r\n        </span><span class="s1">this.observations_.forEach(function (observation) {</span><span class="s2">\r\n            </span><span class="s1">if (observation.isActive()) {</span><span class="s2">\r\n                </span><span class="s1">_this.activeObservations_.push(observation);</span><span class="s2">\r\n            </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">});</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Invokes initial callback function with a list of ResizeObserverEntry</span><span class="s2">\r\n     </span><span class="s1">* instances collected from active resize observations.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @returns {void}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObserverSPI.prototype.broadcastActive = function () {</span><span class="s2">\r\n        </span><span class="s1">// Do nothing if observer doesn't have active observations.</span><span class="s2">\r\n        </span><span class="s1">if (!this.hasActive()) {</span><span class="s2">\r\n            </span><span class="s1">return;</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">var ctx = this.callbackCtx_;</span><span class="s2">\r\n        </span><span class="s1">// Create ResizeObserverEntry instance for every active observation.</span><span class="s2">\r\n        </span><span class="s1">var entries = this.activeObservations_.map(function (observation) {</span><span class="s2">\r\n            </span><span class="s1">return new ResizeObserverEntry(observation.target, observation.broadcastRect());</span><span class="s2">\r\n        </span><span class="s1">});</span><span class="s2">\r\n        </span><span class="s1">this.callback_.call(ctx, entries, ctx);</span><span class="s2">\r\n        </span><span class="s1">this.clearActive();</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Clears the collection of active observations.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @returns {void}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObserverSPI.prototype.clearActive = function () {</span><span class="s2">\r\n        </span><span class="s1">this.activeObservations_.splice(0);</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Tells whether observer has active observations.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @returns {boolean}</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">ResizeObserverSPI.prototype.hasActive = function () {</span><span class="s2">\r\n        </span><span class="s1">return this.activeObservations_.length &gt; 0;</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n    </span><span class="s1">return ResizeObserverSPI;</span><span class="s2">\r\n</span><span class="s1">}());</span><span class="s2">\n\n</span><span class="s1">// Registry of internal observers. If WeakMap is not available use current shim</span><span class="s2">\r\n</span><span class="s1">// for the Map collection as it has all required methods and because WeakMap</span><span class="s2">\r\n</span><span class="s1">// can't be fully polyfilled anyway.</span><span class="s2">\r\n</span><span class="s1">var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();</span><span class="s2">\r\n</span><span class="s1">/**</span><span class="s2">\r\n </span><span class="s1">* ResizeObserver API. Encapsulates the ResizeObserver SPI implementation</span><span class="s2">\r\n </span><span class="s1">* exposing only those methods and properties that are defined in the spec.</span><span class="s2">\r\n </span><span class="s1">*/</span><span class="s2">\r\n</span><span class="s1">var ResizeObserver = /** @class */ (function () {</span><span class="s2">\r\n    </span><span class="s1">/**</span><span class="s2">\r\n     </span><span class="s1">* Creates a new instance of ResizeObserver.</span><span class="s2">\r\n     </span><span class="s1">*</span><span class="s2">\r\n     </span><span class="s1">* @param {ResizeObserverCallback} callback - Callback that is invoked when</span><span class="s2">\r\n     </span><span class="s1">*      dimensions of the observed elements change.</span><span class="s2">\r\n     </span><span class="s1">*/</span><span class="s2">\r\n    </span><span class="s1">function ResizeObserver(callback) {</span><span class="s2">\r\n        </span><span class="s1">if (!(this instanceof ResizeObserver)) {</span><span class="s2">\r\n            </span><span class="s1">throw new TypeError('Cannot call a class as a function.');</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">if (!arguments.length) {</span><span class="s2">\r\n            </span><span class="s1">throw new TypeError('1 argument required, but only 0 present.');</span><span class="s2">\r\n        </span><span class="s1">}</span><span class="s2">\r\n        </span><span class="s1">var controller = ResizeObserverController.getInstance();</span><span class="s2">\r\n        </span><span class="s1">var observer = new ResizeObserverSPI(callback, controller, this);</span><span class="s2">\r\n        </span><span class="s1">observers.set(this, observer);</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">return ResizeObserver;</span><span class="s2">\r\n</span><span class="s1">}());</span><span class="s2">\r\n</span><span class="s1">// Expose public methods of ResizeObserver.</span><span class="s2">\r\n</span><span class="s1">[</span><span class="s2">\r\n    </span><span class="s1">'observe',</span><span class="s2">\r\n    </span><span class="s1">'unobserve',</span><span class="s2">\r\n    </span><span class="s1">'disconnect'</span><span class="s2">\r\n</span><span class="s1">].forEach(function (method) {</span><span class="s2">\r\n    </span><span class="s1">ResizeObserver.prototype[method] = function () {</span><span class="s2">\r\n        </span><span class="s1">var _a;</span><span class="s2">\r\n        </span><span class="s1">return (_a = observers.get(this))[method].apply(_a, arguments);</span><span class="s2">\r\n    </span><span class="s1">};</span><span class="s2">\r\n</span><span class="s1">});</span><span class="s2">\n\n</span><span class="s1">var index = (function () {</span><span class="s2">\r\n    </span><span class="s1">// Export existing implementation if available.</span><span class="s2">\r\n    </span><span class="s1">if (typeof global$1.ResizeObserver !== 'undefined') {</span><span class="s2">\r\n        </span><span class="s1">return global$1.ResizeObserver;</span><span class="s2">\r\n    </span><span class="s1">}</span><span class="s2">\r\n    </span><span class="s1">return ResizeObserver;</span><span class="s2">\r\n</span><span class="s1">})();</span><span class="s2">\n\n</span><span class="s1">export default index;</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">},</span><span class="s1">&quot;metadata&quot;</span><span class="s0">:{},</span><span class="s1">&quot;sourceType&quot;</span><span class="s0">:</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;externalDependencies&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>