<html>
<head>
<title>loop.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
loop.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;collectLoopBodyBindingsVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;Expression|Declaration|Loop&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;skip&quot;</span><span class="s0">,</span><span class="s1">&quot;Scope&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionParent&quot;</span><span class="s0">,</span><span class="s1">&quot;bindings&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;binding&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;blockScoped&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;getLoopBodyBindings&quot;</span><span class="s0">,</span><span class="s1">&quot;loopPath&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;getUsageInBody&quot;</span><span class="s0">,</span><span class="s1">&quot;seen&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakSet&quot;</span><span class="s0">,</span><span class="s1">&quot;capturedInClosure&quot;</span><span class="s0">,</span><span class="s1">&quot;constantViolations&quot;</span><span class="s0">,</span><span class="s1">&quot;filterMap&quot;</span><span class="s0">,</span><span class="s1">&quot;inBody&quot;</span><span class="s0">,</span><span class="s1">&quot;inClosure&quot;</span><span class="s0">,</span><span class="s1">&quot;relativeLoopLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;isUpdateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;references&quot;</span><span class="s0">,</span><span class="s1">&quot;referencePaths&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;hasConstantViolations&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;usages&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyPath&quot;</span><span class="s0">,</span><span class="s1">&quot;currPath&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;isClass&quot;</span><span class="s0">,</span><span class="s1">&quot;isMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;collectCompletionsAndVarsVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;Function&quot;</span><span class="s0">,</span><span class="s1">&quot;LabeledStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;enter&quot;</span><span class="s0">,</span><span class="s1">&quot;labelsStack&quot;</span><span class="s0">,</span><span class="s1">&quot;label&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;popped&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;Loop&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;labellessContinueTargets&quot;</span><span class="s0">,</span><span class="s1">&quot;labellessBreakTargets&quot;</span><span class="s0">,</span><span class="s1">&quot;SwitchStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;BreakStatement|ContinueStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;isBreakStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;breaksContinues&quot;</span><span class="s0">,</span><span class="s1">&quot;ReturnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;returns&quot;</span><span class="s0">,</span><span class="s1">&quot;VariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;loopNode&quot;</span><span class="s0">,</span><span class="s1">&quot;isVarInLoopHead&quot;</span><span class="s0">,</span><span class="s1">&quot;vars&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapLoopBody&quot;</span><span class="s0">,</span><span class="s1">&quot;captured&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedBindingsUsages&quot;</span><span class="s0">,</span><span class="s1">&quot;callArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;closureParams&quot;</span><span class="s0">,</span><span class="s1">&quot;updater&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedUsage&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;innerName&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUid&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;functionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;toBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;fnParent&quot;</span><span class="s0">,</span><span class="s1">&quot;findParent&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;generator&quot;</span><span class="s0">,</span><span class="s1">&quot;yieldExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;awaitExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;updaterNode&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;varPath&quot;</span><span class="s0">,</span><span class="s1">&quot;insertBefore&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyStmts&quot;</span><span class="s0">,</span><span class="s1">&quot;varNames&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;decl&quot;</span><span class="s0">,</span><span class="s1">&quot;declarations&quot;</span><span class="s0">,</span><span class="s1">&quot;getBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;replacement&quot;</span><span class="s0">,</span><span class="s1">&quot;isForStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isForXStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;pushContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;labelNum&quot;</span><span class="s0">,</span><span class="s1">&quot;returnNum&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;addComment&quot;</span><span class="s0">,</span><span class="s1">&quot;returnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;numericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;completionId&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;injected&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;hasInjected&quot;</span><span class="s0">,</span><span class="s1">&quot;arg&quot;</span><span class="s0">,</span><span class="s1">&quot;argument&quot;</span><span class="s0">,</span><span class="s1">&quot;buildUndefinedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;list&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;mapped&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/loop.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { template, types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath, Visitor, Binding } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">interface LoopBodyBindingsState {</span><span class="s3">\n  </span><span class="s1">blockScoped: Binding[];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const collectLoopBodyBindingsVisitor: Visitor&lt;LoopBodyBindingsState&gt; = {</span><span class="s3">\n  \&quot;</span><span class="s1">Expression|Declaration|Loop</span><span class="s3">\&quot;</span><span class="s1">(path) {</span><span class="s3">\n    </span><span class="s1">path.skip();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">Scope(path, state) {</span><span class="s3">\n    </span><span class="s1">if (path.isFunctionParent()) path.skip();</span><span class="s3">\n\n    </span><span class="s1">const { bindings } = path.scope;</span><span class="s3">\n    </span><span class="s1">for (const name of Object.keys(bindings)) {</span><span class="s3">\n      </span><span class="s1">const binding = bindings[name];</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">binding.kind === </span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n        </span><span class="s1">binding.kind === </span><span class="s3">\&quot;</span><span class="s1">const</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n        </span><span class="s1">binding.kind === </span><span class="s3">\&quot;</span><span class="s1">hoisted</span><span class="s3">\&quot;\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">state.blockScoped.push(binding);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function getLoopBodyBindings(loopPath: NodePath&lt;t.Loop&gt;) {</span><span class="s3">\n  </span><span class="s1">const state: LoopBodyBindingsState = { blockScoped: [] };</span><span class="s3">\n  </span><span class="s1">loopPath.traverse(collectLoopBodyBindingsVisitor, state);</span><span class="s3">\n  </span><span class="s1">return state.blockScoped;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getUsageInBody(binding: Binding, loopPath: NodePath&lt;t.Loop&gt;) {</span><span class="s3">\n  </span><span class="s1">// UpdateExpressions are counted both as a reference and a mutation,</span><span class="s3">\n  </span><span class="s1">// so we need to de-duplicate them.</span><span class="s3">\n  </span><span class="s1">const seen = new WeakSet&lt;t.Node&gt;();</span><span class="s3">\n\n  </span><span class="s1">let capturedInClosure = false;</span><span class="s3">\n\n  </span><span class="s1">const constantViolations = filterMap(binding.constantViolations, path =&gt; {</span><span class="s3">\n    </span><span class="s1">const { inBody, inClosure } = relativeLoopLocation(path, loopPath);</span><span class="s3">\n    </span><span class="s1">if (!inBody) return null;</span><span class="s3">\n    </span><span class="s1">capturedInClosure ||= inClosure;</span><span class="s3">\n\n    </span><span class="s1">const id = path.isUpdateExpression()</span><span class="s3">\n      </span><span class="s1">? path.get(</span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">: path.isAssignmentExpression()</span><span class="s3">\n      </span><span class="s1">? path.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">: null;</span><span class="s3">\n    </span><span class="s1">if (id) seen.add(id.node);</span><span class="s3">\n    </span><span class="s1">return id as NodePath&lt;t.Identifier&gt; | null;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">const references = filterMap(binding.referencePaths, path =&gt; {</span><span class="s3">\n    </span><span class="s1">if (seen.has(path.node)) return null;</span><span class="s3">\n\n    </span><span class="s1">const { inBody, inClosure } = relativeLoopLocation(path, loopPath);</span><span class="s3">\n    </span><span class="s1">if (!inBody) return null;</span><span class="s3">\n    </span><span class="s1">capturedInClosure ||= inClosure;</span><span class="s3">\n\n    </span><span class="s1">return path as NodePath&lt;t.Identifier&gt;;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">capturedInClosure,</span><span class="s3">\n    </span><span class="s1">hasConstantViolations: constantViolations.length &gt; 0,</span><span class="s3">\n    </span><span class="s1">usages: references.concat(constantViolations),</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function relativeLoopLocation(path: NodePath, loopPath: NodePath&lt;t.Loop&gt;) {</span><span class="s3">\n  </span><span class="s1">const bodyPath = loopPath.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">let inClosure = false;</span><span class="s3">\n\n  </span><span class="s1">for (let currPath = path; currPath; currPath = currPath.parentPath) {</span><span class="s3">\n    </span><span class="s1">if (currPath.isFunction() || currPath.isClass() || currPath.isMethod()) {</span><span class="s3">\n      </span><span class="s1">inClosure = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (currPath === bodyPath) {</span><span class="s3">\n      </span><span class="s1">return { inBody: true, inClosure };</span><span class="s3">\n    </span><span class="s1">} else if (currPath === loopPath) {</span><span class="s3">\n      </span><span class="s1">return { inBody: false, inClosure };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">throw new Error(</span><span class="s3">\n    \&quot;</span><span class="s1">Internal Babel error: path is not in loop. Please report this as a bug.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface CompletionsAndVarsState {</span><span class="s3">\n  </span><span class="s1">breaksContinues: NodePath&lt;t.BreakStatement | t.ContinueStatement&gt;[];</span><span class="s3">\n  </span><span class="s1">returns: NodePath&lt;t.ReturnStatement&gt;[];</span><span class="s3">\n  </span><span class="s1">labelsStack: string[];</span><span class="s3">\n  </span><span class="s1">labellessContinueTargets: number;</span><span class="s3">\n  </span><span class="s1">labellessBreakTargets: number;</span><span class="s3">\n\n  </span><span class="s1">vars: NodePath&lt;t.VariableDeclaration&gt;[];</span><span class="s3">\n  </span><span class="s1">loopNode: t.Loop;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const collectCompletionsAndVarsVisitor: Visitor&lt;CompletionsAndVarsState&gt; = {</span><span class="s3">\n  </span><span class="s1">Function(path) {</span><span class="s3">\n    </span><span class="s1">path.skip();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">LabeledStatement: {</span><span class="s3">\n    </span><span class="s1">enter({ node }, state) {</span><span class="s3">\n      </span><span class="s1">state.labelsStack.push(node.label.name);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">exit({ node }, state) {</span><span class="s3">\n      </span><span class="s1">const popped = state.labelsStack.pop();</span><span class="s3">\n      </span><span class="s1">if (popped !== node.label.name) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Assertion failure. Please report this bug to Babel.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">Loop: {</span><span class="s3">\n    </span><span class="s1">enter(_, state) {</span><span class="s3">\n      </span><span class="s1">state.labellessContinueTargets++;</span><span class="s3">\n      </span><span class="s1">state.labellessBreakTargets++;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">exit(_, state) {</span><span class="s3">\n      </span><span class="s1">state.labellessContinueTargets--;</span><span class="s3">\n      </span><span class="s1">state.labellessBreakTargets--;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">SwitchStatement: {</span><span class="s3">\n    </span><span class="s1">enter(_, state) {</span><span class="s3">\n      </span><span class="s1">state.labellessBreakTargets++;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">exit(_, state) {</span><span class="s3">\n      </span><span class="s1">state.labellessBreakTargets--;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  \&quot;</span><span class="s1">BreakStatement|ContinueStatement</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;t.BreakStatement | t.ContinueStatement&gt;,</span><span class="s3">\n    </span><span class="s1">state,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const { label } = path.node;</span><span class="s3">\n    </span><span class="s1">if (label) {</span><span class="s3">\n      </span><span class="s1">if (state.labelsStack.includes(label.name)) return;</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">path.isBreakStatement()</span><span class="s3">\n        </span><span class="s1">? state.labellessBreakTargets &gt; 0</span><span class="s3">\n        </span><span class="s1">: state.labellessContinueTargets &gt; 0</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">state.breaksContinues.push(path);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">ReturnStatement(path, state) {</span><span class="s3">\n    </span><span class="s1">state.returns.push(path);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">VariableDeclaration(path, state) {</span><span class="s3">\n    </span><span class="s1">if (path.parent === state.loopNode &amp;&amp; isVarInLoopHead(path)) return;</span><span class="s3">\n    </span><span class="s1">if (path.node.kind === </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">) state.vars.push(path);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function wrapLoopBody(</span><span class="s3">\n  </span><span class="s1">loopPath: NodePath&lt;t.Loop&gt;,</span><span class="s3">\n  </span><span class="s1">captured: string[],</span><span class="s3">\n  </span><span class="s1">updatedBindingsUsages: Map&lt;string, NodePath&lt;t.Identifier&gt;[]&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const loopNode = loopPath.node;</span><span class="s3">\n  </span><span class="s1">const state: CompletionsAndVarsState = {</span><span class="s3">\n    </span><span class="s1">breaksContinues: [],</span><span class="s3">\n    </span><span class="s1">returns: [],</span><span class="s3">\n    </span><span class="s1">labelsStack: [],</span><span class="s3">\n    </span><span class="s1">labellessBreakTargets: 0,</span><span class="s3">\n    </span><span class="s1">labellessContinueTargets: 0,</span><span class="s3">\n    </span><span class="s1">vars: [],</span><span class="s3">\n    </span><span class="s1">loopNode,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">loopPath.traverse(collectCompletionsAndVarsVisitor, state);</span><span class="s3">\n\n  </span><span class="s1">const callArgs = [];</span><span class="s3">\n  </span><span class="s1">const closureParams = [];</span><span class="s3">\n  </span><span class="s1">const updater = [];</span><span class="s3">\n  </span><span class="s1">for (const [name, updatedUsage] of updatedBindingsUsages) {</span><span class="s3">\n    </span><span class="s1">callArgs.push(t.identifier(name));</span><span class="s3">\n\n    </span><span class="s1">const innerName = loopPath.scope.generateUid(name);</span><span class="s3">\n    </span><span class="s1">closureParams.push(t.identifier(innerName));</span><span class="s3">\n    </span><span class="s1">updater.push(</span><span class="s3">\n      </span><span class="s1">t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, t.identifier(name), t.identifier(innerName)),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">for (const path of updatedUsage) path.replaceWith(t.identifier(innerName));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (const name of captured) {</span><span class="s3">\n    </span><span class="s1">if (updatedBindingsUsages.has(name)) continue; // already injected</span><span class="s3">\n    </span><span class="s1">callArgs.push(t.identifier(name));</span><span class="s3">\n    </span><span class="s1">closureParams.push(t.identifier(name));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const id = loopPath.scope.generateUid(</span><span class="s3">\&quot;</span><span class="s1">loop</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const fn = t.functionExpression(</span><span class="s3">\n    </span><span class="s1">null,</span><span class="s3">\n    </span><span class="s1">closureParams,</span><span class="s3">\n    </span><span class="s1">t.toBlock(loopNode.body),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">let call: t.Expression = t.callExpression(t.identifier(id), callArgs);</span><span class="s3">\n\n  </span><span class="s1">const fnParent = loopPath.findParent(p =&gt; p.isFunction());</span><span class="s3">\n  </span><span class="s1">if (fnParent) {</span><span class="s3">\n    </span><span class="s1">const { async, generator } = fnParent.node as t.Function;</span><span class="s3">\n    </span><span class="s1">fn.async = async;</span><span class="s3">\n    </span><span class="s1">fn.generator = generator;</span><span class="s3">\n    </span><span class="s1">if (generator) call = t.yieldExpression(call, true);</span><span class="s3">\n    </span><span class="s1">else if (async) call = t.awaitExpression(call);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const updaterNode =</span><span class="s3">\n    </span><span class="s1">updater.length &gt; 0</span><span class="s3">\n      </span><span class="s1">? t.expressionStatement(t.sequenceExpression(updater))</span><span class="s3">\n      </span><span class="s1">: null;</span><span class="s3">\n  </span><span class="s1">if (updaterNode) fn.body.body.push(updaterNode);</span><span class="s3">\n\n  </span><span class="s1">// NOTE: Calling .insertBefore on the loop path might cause the</span><span class="s3">\n  </span><span class="s1">// loop to be moved in the AST. For example, in</span><span class="s3">\n  </span><span class="s1">//   if (true) for (let x of y) ...</span><span class="s3">\n  </span><span class="s1">// .insertBefore will replace the loop with a block:</span><span class="s3">\n  </span><span class="s1">//   if (true) { var _loop = ...; for (let x of y) ... }</span><span class="s3">\n  </span><span class="s1">// All subsequent operations in this function on the loop node</span><span class="s3">\n  </span><span class="s1">// must not assume that loopPath still represents the loop.</span><span class="s3">\n  </span><span class="s1">// TODO: Consider using a function declaration</span><span class="s3">\n  </span><span class="s1">const [varPath] = loopPath.insertBefore(</span><span class="s3">\n    </span><span class="s1">t.variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">, [t.variableDeclarator(t.identifier(id), fn)]),</span><span class="s3">\n  </span><span class="s1">) as [NodePath&lt;t.VariableDeclaration&gt;];</span><span class="s3">\n\n  </span><span class="s1">const bodyStmts: t.Statement[] = [];</span><span class="s3">\n\n  </span><span class="s1">const varNames: string[] = [];</span><span class="s3">\n  </span><span class="s1">for (const varPath of state.vars) {</span><span class="s3">\n    </span><span class="s1">const assign = [];</span><span class="s3">\n    </span><span class="s1">for (const decl of varPath.node.declarations) {</span><span class="s3">\n      </span><span class="s1">varNames.push(...Object.keys(t.getBindingIdentifiers(decl.id)));</span><span class="s3">\n      </span><span class="s1">if (decl.init) {</span><span class="s3">\n        </span><span class="s1">assign.push(t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, decl.id, decl.init));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (assign.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">let replacement: t.Node =</span><span class="s3">\n        </span><span class="s1">assign.length === 1 ? assign[0] : t.sequenceExpression(assign);</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!t.isForStatement(varPath.parent, { init: varPath.node }) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!t.isForXStatement(varPath.parent, { left: varPath.node })</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">replacement = t.expressionStatement(replacement);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">varPath.replaceWith(replacement);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">varPath.remove();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (varNames.length) {</span><span class="s3">\n    </span><span class="s1">varPath.pushContainer(</span><span class="s3">\n      \&quot;</span><span class="s1">declarations</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">varNames.map(name =&gt; t.variableDeclarator(t.identifier(name))),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const labelNum = state.breaksContinues.length;</span><span class="s3">\n  </span><span class="s1">const returnNum = state.returns.length;</span><span class="s3">\n  </span><span class="s1">if (labelNum + returnNum === 0) {</span><span class="s3">\n    </span><span class="s1">bodyStmts.push(t.expressionStatement(call));</span><span class="s3">\n  </span><span class="s1">} else if (labelNum === 1 &amp;&amp; returnNum === 0) {</span><span class="s3">\n    </span><span class="s1">for (const path of state.breaksContinues) {</span><span class="s3">\n      </span><span class="s1">const { node } = path;</span><span class="s3">\n      </span><span class="s1">const { type, label } = node;</span><span class="s3">\n      </span><span class="s1">let name = type === </span><span class="s3">\&quot;</span><span class="s1">BreakStatement</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">break</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">continue</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">if (label) name += </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ label.name;</span><span class="s3">\n      </span><span class="s1">path.replaceWith(</span><span class="s3">\n        </span><span class="s1">t.addComment(</span><span class="s3">\n          </span><span class="s1">t.returnStatement(t.numericLiteral(1)),</span><span class="s3">\n          \&quot;</span><span class="s1">trailing</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          \&quot; \&quot; </span><span class="s1">+ name,</span><span class="s3">\n          </span><span class="s1">true,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (updaterNode) path.insertBefore(t.cloneNode(updaterNode));</span><span class="s3">\n\n      </span><span class="s1">bodyStmts.push(</span><span class="s3">\n        </span><span class="s1">template.statement.ast`</span><span class="s3">\n        </span><span class="s1">if (${call}) ${node}</span><span class="s3">\n      </span><span class="s1">`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">const completionId = loopPath.scope.generateUid(</span><span class="s3">\&quot;</span><span class="s1">ret</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (varPath.isVariableDeclaration()) {</span><span class="s3">\n      </span><span class="s1">varPath.pushContainer(</span><span class="s3">\&quot;</span><span class="s1">declarations</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n        </span><span class="s1">t.variableDeclarator(t.identifier(completionId)),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">bodyStmts.push(</span><span class="s3">\n        </span><span class="s1">t.expressionStatement(</span><span class="s3">\n          </span><span class="s1">t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, t.identifier(completionId), call),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">bodyStmts.push(</span><span class="s3">\n        </span><span class="s1">t.variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n          </span><span class="s1">t.variableDeclarator(t.identifier(completionId), call),</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const injected: string[] = [];</span><span class="s3">\n    </span><span class="s1">for (const path of state.breaksContinues) {</span><span class="s3">\n      </span><span class="s1">const { node } = path;</span><span class="s3">\n      </span><span class="s1">const { type, label } = node;</span><span class="s3">\n      </span><span class="s1">let name = type === </span><span class="s3">\&quot;</span><span class="s1">BreakStatement</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">break</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">continue</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">if (label) name += </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ label.name;</span><span class="s3">\n\n      </span><span class="s1">let i = injected.indexOf(name);</span><span class="s3">\n      </span><span class="s1">const hasInjected = i !== -1;</span><span class="s3">\n      </span><span class="s1">if (!hasInjected) {</span><span class="s3">\n        </span><span class="s1">injected.push(name);</span><span class="s3">\n        </span><span class="s1">i = injected.length - 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">path.replaceWith(</span><span class="s3">\n        </span><span class="s1">t.addComment(</span><span class="s3">\n          </span><span class="s1">t.returnStatement(t.numericLiteral(i)),</span><span class="s3">\n          \&quot;</span><span class="s1">trailing</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          \&quot; \&quot; </span><span class="s1">+ name,</span><span class="s3">\n          </span><span class="s1">true,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (updaterNode) path.insertBefore(t.cloneNode(updaterNode));</span><span class="s3">\n\n      </span><span class="s1">if (hasInjected) continue;</span><span class="s3">\n\n      </span><span class="s1">bodyStmts.push(</span><span class="s3">\n        </span><span class="s1">template.statement.ast`</span><span class="s3">\n        </span><span class="s1">if (${t.identifier(completionId)} === ${t.numericLiteral(i)}) ${node}</span><span class="s3">\n      </span><span class="s1">`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (returnNum) {</span><span class="s3">\n      </span><span class="s1">for (const path of state.returns) {</span><span class="s3">\n        </span><span class="s1">const arg = path.node.argument || path.scope.buildUndefinedNode();</span><span class="s3">\n        </span><span class="s1">path.replaceWith(</span><span class="s3">\n          </span><span class="s1">template.statement.ast`</span><span class="s3">\n          </span><span class="s1">return { v: ${arg} };</span><span class="s3">\n        </span><span class="s1">`,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">bodyStmts.push(</span><span class="s3">\n        </span><span class="s1">template.statement.ast`</span><span class="s3">\n          </span><span class="s1">if (${t.identifier(completionId)}) return ${t.identifier(</span><span class="s3">\n            </span><span class="s1">completionId,</span><span class="s3">\n          </span><span class="s1">)}.v;</span><span class="s3">\n        </span><span class="s1">`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">loopNode.body = t.blockStatement(bodyStmts);</span><span class="s3">\n\n  </span><span class="s1">return varPath;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isVarInLoopHead(path: NodePath&lt;t.VariableDeclaration&gt;) {</span><span class="s3">\n  </span><span class="s1">if (t.isForStatement(path.parent)) return path.key === </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">if (t.isForXStatement(path.parent)) return path.key === </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function filterMap&lt;T, U extends object&gt;(list: T[], fn: (item: T) =&gt; U | null) {</span><span class="s3">\n  </span><span class="s1">const result: U[] = [];</span><span class="s3">\n  </span><span class="s1">for (const item of list) {</span><span class="s3">\n    </span><span class="s1">const mapped = fn(item);</span><span class="s3">\n    </span><span class="s1">if (mapped) result.push(mapped);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>