<html>
<head>
<title>evaluation.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
evaluation.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;VALID_OBJECT_CALLEES&quot;</span><span class="s0">,</span><span class="s1">&quot;VALID_IDENTIFIER_CALLEES&quot;</span><span class="s0">,</span><span class="s1">&quot;INVALID_METHODS&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidObjectCallee&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidIdentifierCallee&quot;</span><span class="s0">,</span><span class="s1">&quot;isInvalidMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;evaluateTruthy&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;evaluate&quot;</span><span class="s0">,</span><span class="s1">&quot;confident&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;deopt&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;deoptPath&quot;</span><span class="s0">,</span><span class="s1">&quot;Globals&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;Infinity&quot;</span><span class="s0">,</span><span class="s1">&quot;NaN&quot;</span><span class="s0">,</span><span class="s1">&quot;evaluateCached&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;seen&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;existing&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;resolved&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;_evaluate&quot;</span><span class="s0">,</span><span class="s1">&quot;isSequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;exprs&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;isStringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isNumericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isBooleanLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isNullLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isTemplateLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;evaluateQuasis&quot;</span><span class="s0">,</span><span class="s1">&quot;quasis&quot;</span><span class="s0">,</span><span class="s1">&quot;isTaggedTemplateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;getBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;quasi&quot;</span><span class="s0">,</span><span class="s1">&quot;isConditionalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;testResult&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionWrapper&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;isLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;isReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;binding&quot;</span><span class="s0">,</span><span class="s1">&quot;constantViolations&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;hasValue&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;argument&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;isClass&quot;</span><span class="s0">,</span><span class="s1">&quot;arg&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrayExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;arr&quot;</span><span class="s0">,</span><span class="s1">&quot;elems&quot;</span><span class="s0">,</span><span class="s1">&quot;elem&quot;</span><span class="s0">,</span><span class="s1">&quot;elemValue&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;isSpreadElement&quot;</span><span class="s0">,</span><span class="s1">&quot;keyPath&quot;</span><span class="s0">,</span><span class="s1">&quot;valuePath&quot;</span><span class="s0">,</span><span class="s1">&quot;isLogicalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;wasConfident&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;leftConfident&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;rightConfident&quot;</span><span class="s0">,</span><span class="s1">&quot;isBinaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;pow&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;func&quot;</span><span class="s0">,</span><span class="s1">&quot;global&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;raw&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;cooked&quot;</span><span class="s0">,</span><span class="s1">&quot;expr&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/path/evaluation.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type NodePath from </span><span class="s3">\&quot;</span><span class="s1">./index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// This file contains Babels metainterpreter that can evaluate static code.</span><span class="s3">\n\n</span><span class="s1">const VALID_OBJECT_CALLEES = [</span><span class="s3">\&quot;</span><span class="s1">Number</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">String</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">Math</span><span class="s3">\&quot;</span><span class="s1">] as const;</span><span class="s3">\n</span><span class="s1">const VALID_IDENTIFIER_CALLEES = [</span><span class="s3">\n  \&quot;</span><span class="s1">isFinite</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">isNaN</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">parseFloat</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">parseInt</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">decodeURI</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">decodeURIComponent</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">encodeURI</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">encodeURIComponent</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">process.env.BABEL_8_BREAKING ? </span><span class="s3">\&quot;</span><span class="s1">btoa</span><span class="s3">\&quot; </span><span class="s1">: null,</span><span class="s3">\n  </span><span class="s1">process.env.BABEL_8_BREAKING ? </span><span class="s3">\&quot;</span><span class="s1">atob</span><span class="s3">\&quot; </span><span class="s1">: null,</span><span class="s3">\n</span><span class="s1">] as const;</span><span class="s3">\n\n</span><span class="s1">const INVALID_METHODS = [</span><span class="s3">\&quot;</span><span class="s1">random</span><span class="s3">\&quot;</span><span class="s1">] as const;</span><span class="s3">\n\n</span><span class="s1">function isValidObjectCallee(</span><span class="s3">\n  </span><span class="s1">val: string,</span><span class="s3">\n</span><span class="s1">): val is (typeof VALID_OBJECT_CALLEES)[number] {</span><span class="s3">\n  </span><span class="s1">return VALID_OBJECT_CALLEES.includes(</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error val is a string</span><span class="s3">\n    </span><span class="s1">val,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isValidIdentifierCallee(</span><span class="s3">\n  </span><span class="s1">val: string,</span><span class="s3">\n</span><span class="s1">): val is (typeof VALID_IDENTIFIER_CALLEES)[number] {</span><span class="s3">\n  </span><span class="s1">return VALID_IDENTIFIER_CALLEES.includes(</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error val is a string</span><span class="s3">\n    </span><span class="s1">val,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isInvalidMethod(val: string): val is (typeof INVALID_METHODS)[number] {</span><span class="s3">\n  </span><span class="s1">return INVALID_METHODS.includes(</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error val is a string</span><span class="s3">\n    </span><span class="s1">val,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Walk the input `node` and statically evaluate if it's truthy.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Returning `true` when we're sure that the expression will evaluate to a</span><span class="s3">\n </span><span class="s1">* truthy value, `false` if we're sure that it will evaluate to a falsy</span><span class="s3">\n </span><span class="s1">* value and `undefined` if we aren't sure. Because of this please do not</span><span class="s3">\n </span><span class="s1">* rely on coercion when using this method and check with === if it's false.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* For example do:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   if (t.evaluateTruthy(node) === false) falsyLogic();</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **AND NOT**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   if (!t.evaluateTruthy(node)) falsyLogic();</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function evaluateTruthy(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">const res = this.evaluate();</span><span class="s3">\n  </span><span class="s1">if (res.confident) return !!res.value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type State = {</span><span class="s3">\n  </span><span class="s1">confident: boolean;</span><span class="s3">\n  </span><span class="s1">deoptPath: NodePath | null;</span><span class="s3">\n  </span><span class="s1">seen: Map&lt;t.Node, Result&gt;;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">type Result = {</span><span class="s3">\n  </span><span class="s1">resolved: boolean;</span><span class="s3">\n  </span><span class="s1">value?: any;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Deopts the evaluation</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function deopt(path: NodePath, state: State) {</span><span class="s3">\n  </span><span class="s1">if (!state.confident) return;</span><span class="s3">\n  </span><span class="s1">state.deoptPath = path;</span><span class="s3">\n  </span><span class="s1">state.confident = false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const Globals = new Map([</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">, undefined],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">Infinity</span><span class="s3">\&quot;</span><span class="s1">, Infinity],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">NaN</span><span class="s3">\&quot;</span><span class="s1">, NaN],</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* We wrap the _evaluate method so we can track `seen` nodes, we push an item</span><span class="s3">\n </span><span class="s1">* to the map before we actually evaluate it so we can deopt on self recursive</span><span class="s3">\n </span><span class="s1">* nodes such as:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   var g = a ? 1 : 2,</span><span class="s3">\n </span><span class="s1">*       a = g * this.foo</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function evaluateCached(path: NodePath, state: State): any {</span><span class="s3">\n  </span><span class="s1">const { node } = path;</span><span class="s3">\n  </span><span class="s1">const { seen } = state;</span><span class="s3">\n\n  </span><span class="s1">if (seen.has(node)) {</span><span class="s3">\n    </span><span class="s1">const existing = seen.get(node);</span><span class="s3">\n    </span><span class="s1">if (existing.resolved) {</span><span class="s3">\n      </span><span class="s1">return existing.value;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">deopt(path, state);</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">const item: Result = { resolved: false };</span><span class="s3">\n    </span><span class="s1">seen.set(node, item);</span><span class="s3">\n\n    </span><span class="s1">const val = _evaluate(path, state);</span><span class="s3">\n    </span><span class="s1">if (state.confident) {</span><span class="s3">\n      </span><span class="s1">item.resolved = true;</span><span class="s3">\n      </span><span class="s1">item.value = val;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return val;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function _evaluate(path: NodePath, state: State): any {</span><span class="s3">\n  </span><span class="s1">if (!state.confident) return;</span><span class="s3">\n\n  </span><span class="s1">if (path.isSequenceExpression()) {</span><span class="s3">\n    </span><span class="s1">const exprs = path.get(</span><span class="s3">\&quot;</span><span class="s1">expressions</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return evaluateCached(exprs[exprs.length - 1], state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">path.isStringLiteral() ||</span><span class="s3">\n    </span><span class="s1">path.isNumericLiteral() ||</span><span class="s3">\n    </span><span class="s1">path.isBooleanLiteral()</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return path.node.value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (path.isNullLiteral()) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (path.isTemplateLiteral()) {</span><span class="s3">\n    </span><span class="s1">return evaluateQuasis(path, path.node.quasis, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">path.isTaggedTemplateExpression() &amp;&amp;</span><span class="s3">\n    </span><span class="s1">path.get(</span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">).isMemberExpression()</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const object = path.get(</span><span class="s3">\&quot;</span><span class="s1">tag.object</span><span class="s3">\&quot;</span><span class="s1">) as NodePath;</span><span class="s3">\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): possible bug, object is can be any expression and so name might be undefined</span><span class="s3">\n      </span><span class="s1">node: { name },</span><span class="s3">\n    </span><span class="s1">} = object;</span><span class="s3">\n    </span><span class="s1">const property = path.get(</span><span class="s3">\&quot;</span><span class="s1">tag.property</span><span class="s3">\&quot;</span><span class="s1">) as NodePath;</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">object.isIdentifier() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">name === </span><span class="s3">\&quot;</span><span class="s1">String</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n      </span><span class="s1">// todo(flow-&gt;ts): was changed from getBinding(name, true)</span><span class="s3">\n      </span><span class="s1">//  should this be hasBinding(name, true) as the binding is never used later?</span><span class="s3">\n      </span><span class="s1">!path.scope.getBinding(name) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">property.isIdentifier() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">property.node.name === </span><span class="s3">\&quot;</span><span class="s1">raw</span><span class="s3">\&quot;\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return evaluateQuasis(path, path.node.quasi.quasis, state, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (path.isConditionalExpression()) {</span><span class="s3">\n    </span><span class="s1">const testResult = evaluateCached(path.get(</span><span class="s3">\&quot;</span><span class="s1">test</span><span class="s3">\&quot;</span><span class="s1">), state);</span><span class="s3">\n    </span><span class="s1">if (!state.confident) return;</span><span class="s3">\n    </span><span class="s1">if (testResult) {</span><span class="s3">\n      </span><span class="s1">return evaluateCached(path.get(</span><span class="s3">\&quot;</span><span class="s1">consequent</span><span class="s3">\&quot;</span><span class="s1">), state);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return evaluateCached(path.get(</span><span class="s3">\&quot;</span><span class="s1">alternate</span><span class="s3">\&quot;</span><span class="s1">), state);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (path.isExpressionWrapper()) {</span><span class="s3">\n    </span><span class="s1">// TypeCastExpression, ExpressionStatement etc</span><span class="s3">\n    </span><span class="s1">return evaluateCached(path.get(</span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">), state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">.length, </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">[0]</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">path.isMemberExpression() &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!path.parentPath.isCallExpression({ callee: path.node })</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const property = path.get(</span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const object = path.get(</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (object.isLiteral()) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): instead of typeof - would it be better to check type of ast node?</span><span class="s3">\n      </span><span class="s1">const value = object.node.value;</span><span class="s3">\n      </span><span class="s1">const type = typeof value;</span><span class="s3">\n\n      </span><span class="s1">let key = null;</span><span class="s3">\n      </span><span class="s1">if (path.node.computed) {</span><span class="s3">\n        </span><span class="s1">key = evaluateCached(property, state);</span><span class="s3">\n        </span><span class="s1">if (!state.confident) return;</span><span class="s3">\n      </span><span class="s1">} else if (property.isIdentifier()) {</span><span class="s3">\n        </span><span class="s1">key = property.node.name;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">(type === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| type === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">key != null &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(typeof key === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| typeof key === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return value[key];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (path.isReferencedIdentifier()) {</span><span class="s3">\n    </span><span class="s1">const binding = path.scope.getBinding(path.node.name);</span><span class="s3">\n\n    </span><span class="s1">if (binding) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">binding.constantViolations.length &gt; 0 ||</span><span class="s3">\n        </span><span class="s1">path.node.start &lt; binding.path.node.end</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">deopt(binding.path, state);</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (binding.hasValue) {</span><span class="s3">\n        </span><span class="s1">return binding.value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const name = path.node.name;</span><span class="s3">\n    </span><span class="s1">if (Globals.has(name)) {</span><span class="s3">\n      </span><span class="s1">if (!binding) {</span><span class="s3">\n        </span><span class="s1">return Globals.get(name);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">deopt(binding.path, state);</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const resolved = path.resolve();</span><span class="s3">\n    </span><span class="s1">if (resolved === path) {</span><span class="s3">\n      </span><span class="s1">deopt(path, state);</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return evaluateCached(resolved, state);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (path.isUnaryExpression({ prefix: true })) {</span><span class="s3">\n    </span><span class="s1">if (path.node.operator === </span><span class="s3">\&quot;</span><span class="s1">void</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// we don't need to evaluate the argument to know what this will return</span><span class="s3">\n      </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const argument = path.get(</span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">path.node.operator === </span><span class="s3">\&quot;</span><span class="s1">typeof</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n      </span><span class="s1">(argument.isFunction() || argument.isClass())</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const arg = evaluateCached(argument, state);</span><span class="s3">\n    </span><span class="s1">if (!state.confident) return;</span><span class="s3">\n    </span><span class="s1">switch (path.node.operator) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return !arg;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return +arg;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return -arg;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">~</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return ~arg;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">typeof</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return typeof arg;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (path.isArrayExpression()) {</span><span class="s3">\n    </span><span class="s1">const arr = [];</span><span class="s3">\n    </span><span class="s1">const elems: Array&lt;NodePath&gt; = path.get(</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">for (const elem of elems) {</span><span class="s3">\n      </span><span class="s1">const elemValue = elem.evaluate();</span><span class="s3">\n\n      </span><span class="s1">if (elemValue.confident) {</span><span class="s3">\n        </span><span class="s1">arr.push(elemValue.value);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">deopt(elemValue.deopt, state);</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return arr;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (path.isObjectExpression()) {</span><span class="s3">\n    </span><span class="s1">const obj = {};</span><span class="s3">\n    </span><span class="s1">const props = path.get(</span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">for (const prop of props) {</span><span class="s3">\n      </span><span class="s1">if (prop.isObjectMethod() || prop.isSpreadElement()) {</span><span class="s3">\n        </span><span class="s1">deopt(prop, state);</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const keyPath = (prop as NodePath&lt;t.ObjectProperty&gt;).get(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">let key;</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): type refinement issues ObjectMethod and SpreadElement somehow not excluded</span><span class="s3">\n      </span><span class="s1">if (prop.node.computed) {</span><span class="s3">\n        </span><span class="s1">key = keyPath.evaluate();</span><span class="s3">\n        </span><span class="s1">if (!key.confident) {</span><span class="s3">\n          </span><span class="s1">deopt(key.deopt, state);</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">key = key.value;</span><span class="s3">\n      </span><span class="s1">} else if (keyPath.isIdentifier()) {</span><span class="s3">\n        </span><span class="s1">key = keyPath.node.name;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">key = (</span><span class="s3">\n          </span><span class="s1">keyPath.node as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral</span><span class="s3">\n        </span><span class="s1">).value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const valuePath = (prop as NodePath&lt;t.ObjectProperty&gt;).get(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">let value = valuePath.evaluate();</span><span class="s3">\n      </span><span class="s1">if (!value.confident) {</span><span class="s3">\n        </span><span class="s1">deopt(value.deopt, state);</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">value = value.value;</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error key is any type</span><span class="s3">\n      </span><span class="s1">obj[key] = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return obj;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (path.isLogicalExpression()) {</span><span class="s3">\n    </span><span class="s1">// If we are confident that the left side of an &amp;&amp; is false, or the left</span><span class="s3">\n    </span><span class="s1">// side of an || is true, we can be confident about the entire expression</span><span class="s3">\n    </span><span class="s1">const wasConfident = state.confident;</span><span class="s3">\n    </span><span class="s1">const left = evaluateCached(path.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">), state);</span><span class="s3">\n    </span><span class="s1">const leftConfident = state.confident;</span><span class="s3">\n    </span><span class="s1">state.confident = wasConfident;</span><span class="s3">\n    </span><span class="s1">const right = evaluateCached(path.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">), state);</span><span class="s3">\n    </span><span class="s1">const rightConfident = state.confident;</span><span class="s3">\n\n    </span><span class="s1">switch (path.node.operator) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">||</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">// TODO consider having a </span><span class="s3">\&quot;</span><span class="s1">truthy type</span><span class="s3">\&quot; </span><span class="s1">that doesn't bail on</span><span class="s3">\n        </span><span class="s1">// left uncertainty but can still evaluate to truthy.</span><span class="s3">\n        </span><span class="s1">state.confident = leftConfident &amp;&amp; (!!left || rightConfident);</span><span class="s3">\n        </span><span class="s1">if (!state.confident) return;</span><span class="s3">\n\n        </span><span class="s1">return left || right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">state.confident = leftConfident &amp;&amp; (!left || rightConfident);</span><span class="s3">\n        </span><span class="s1">if (!state.confident) return;</span><span class="s3">\n\n        </span><span class="s1">return left &amp;&amp; right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">??</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">state.confident = leftConfident &amp;&amp; (left != null || rightConfident);</span><span class="s3">\n        </span><span class="s1">if (!state.confident) return;</span><span class="s3">\n\n        </span><span class="s1">return left ?? right;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (path.isBinaryExpression()) {</span><span class="s3">\n    </span><span class="s1">const left = evaluateCached(path.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">), state);</span><span class="s3">\n    </span><span class="s1">if (!state.confident) return;</span><span class="s3">\n    </span><span class="s1">const right = evaluateCached(path.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">), state);</span><span class="s3">\n    </span><span class="s1">if (!state.confident) return;</span><span class="s3">\n\n    </span><span class="s1">switch (path.node.operator) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left - right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left + right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left / right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left * right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left % right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">**</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left ** right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left &lt; right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left &gt; right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&lt;=</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left &lt;= right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&gt;=</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left &gt;= right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">==</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left == right; // eslint-disable-line eqeqeq</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">!=</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left != right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">===</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left === right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">!==</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left !== right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left | right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left &amp; right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left ^ right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&lt;&lt;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left &lt;&lt; right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&gt;&gt;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left &gt;&gt; right;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&gt;&gt;&gt;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return left &gt;&gt;&gt; right;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (path.isCallExpression()) {</span><span class="s3">\n    </span><span class="s1">const callee = path.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let context;</span><span class="s3">\n    </span><span class="s1">let func;</span><span class="s3">\n\n    </span><span class="s1">// Number(1);</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">callee.isIdentifier() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!path.scope.getBinding(callee.node.name) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(isValidObjectCallee(callee.node.name) ||</span><span class="s3">\n        </span><span class="s1">isValidIdentifierCallee(callee.node.name))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">func = global[callee.node.name];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (callee.isMemberExpression()) {</span><span class="s3">\n      </span><span class="s1">const object = callee.get(</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const property = callee.get(</span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">// Math.min(1, 2)</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">object.isIdentifier() &amp;&amp;</span><span class="s3">\n        </span><span class="s1">property.isIdentifier() &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isValidObjectCallee(object.node.name) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!isInvalidMethod(property.node.name)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">context = global[object.node.name];</span><span class="s3">\n        </span><span class="s1">const key = property.node.name;</span><span class="s3">\n        </span><span class="s1">// TODO(Babel 8): Use Object.hasOwn</span><span class="s3">\n        </span><span class="s1">if (Object.hasOwnProperty.call(context, key)) {</span><span class="s3">\n          </span><span class="s1">func = context[key as keyof typeof context];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">abc</span><span class="s3">\&quot;</span><span class="s1">.charCodeAt(4)</span><span class="s3">\n      </span><span class="s1">if (object.isLiteral() &amp;&amp; property.isIdentifier()) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): consider checking ast node type instead of value type (StringLiteral and NumberLiteral)</span><span class="s3">\n        </span><span class="s1">const type = typeof object.node.value;</span><span class="s3">\n        </span><span class="s1">if (type === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">|| type === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): consider checking ast node type instead of value type</span><span class="s3">\n          </span><span class="s1">context = object.node.value;</span><span class="s3">\n          </span><span class="s1">func = context[property.node.name];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (func) {</span><span class="s3">\n      </span><span class="s1">const args = path.get(</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">).map(arg =&gt; evaluateCached(arg, state));</span><span class="s3">\n      </span><span class="s1">if (!state.confident) return;</span><span class="s3">\n\n      </span><span class="s1">return func.apply(context, args);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">deopt(path, state);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function evaluateQuasis(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.TaggedTemplateExpression | t.TemplateLiteral&gt;,</span><span class="s3">\n  </span><span class="s1">quasis: Array&lt;any&gt;,</span><span class="s3">\n  </span><span class="s1">state: State,</span><span class="s3">\n  </span><span class="s1">raw = false,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let str = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n\n  </span><span class="s1">let i = 0;</span><span class="s3">\n  </span><span class="s1">const exprs: Array&lt;NodePath&lt;t.Node&gt;&gt; = path.isTemplateLiteral()</span><span class="s3">\n    </span><span class="s1">? path.get(</span><span class="s3">\&quot;</span><span class="s1">expressions</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">: path.get(</span><span class="s3">\&quot;</span><span class="s1">quasi.expressions</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">for (const elem of quasis) {</span><span class="s3">\n    </span><span class="s1">// not confident, evaluated an expression we don't like</span><span class="s3">\n    </span><span class="s1">if (!state.confident) break;</span><span class="s3">\n\n    </span><span class="s1">// add on element</span><span class="s3">\n    </span><span class="s1">str += raw ? elem.value.raw : elem.value.cooked;</span><span class="s3">\n\n    </span><span class="s1">// add on interpolated expression if it's present</span><span class="s3">\n    </span><span class="s1">const expr = exprs[i++];</span><span class="s3">\n    </span><span class="s1">if (expr) str += String(evaluateCached(expr, state));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!state.confident) return;</span><span class="s3">\n  </span><span class="s1">return str;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Walk the input `node` and statically evaluate it.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Returns an object in the form `{ confident, value, deopt }`. `confident`</span><span class="s3">\n </span><span class="s1">* indicates whether or not we had to drop out of evaluating the expression</span><span class="s3">\n </span><span class="s1">* because of hitting an unknown node that we couldn't confidently find the</span><span class="s3">\n </span><span class="s1">* value of, in which case `deopt` is the path of said node.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Example:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   t.evaluate(parse(</span><span class="s3">\&quot;</span><span class="s1">5 + 5</span><span class="s3">\&quot;</span><span class="s1">)) // { confident: true, value: 10 }</span><span class="s3">\n </span><span class="s1">*   t.evaluate(parse(</span><span class="s3">\&quot;</span><span class="s1">!true</span><span class="s3">\&quot;</span><span class="s1">)) // { confident: true, value: false }</span><span class="s3">\n </span><span class="s1">*   t.evaluate(parse(</span><span class="s3">\&quot;</span><span class="s1">foo + foo</span><span class="s3">\&quot;</span><span class="s1">)) // { confident: false, value: undefined, deopt: NodePath }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function evaluate(this: NodePath): {</span><span class="s3">\n  </span><span class="s1">confident: boolean;</span><span class="s3">\n  </span><span class="s1">value: any;</span><span class="s3">\n  </span><span class="s1">deopt?: NodePath;</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">const state: State = {</span><span class="s3">\n    </span><span class="s1">confident: true,</span><span class="s3">\n    </span><span class="s1">deoptPath: null,</span><span class="s3">\n    </span><span class="s1">seen: new Map(),</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">let value = evaluateCached(this, state);</span><span class="s3">\n  </span><span class="s1">if (!state.confident) value = undefined;</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">confident: state.confident,</span><span class="s3">\n    </span><span class="s1">deopt: state.deoptPath,</span><span class="s3">\n    </span><span class="s1">value: value,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>