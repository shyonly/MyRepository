<html>
<head>
<title>remapping.mjs.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
remapping.mjs.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;remapping.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/source-map-tree.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/build-source-map-tree.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/source-map.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/remapping.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { GenMapping, maybeAddSegment, setSourceContent } from '@jridgewell/gen-mapping';</span><span class="s3">\n</span><span class="s1">import { traceSegment, decodedMappings } from '@jridgewell/trace-mapping';</span><span class="s3">\n\n</span><span class="s1">import type { TraceMap } from '@jridgewell/trace-mapping';</span><span class="s3">\n\n</span><span class="s1">export type SourceMapSegmentObject = {</span><span class="s3">\n  </span><span class="s1">column: number;</span><span class="s3">\n  </span><span class="s1">line: number;</span><span class="s3">\n  </span><span class="s1">name: string;</span><span class="s3">\n  </span><span class="s1">source: string;</span><span class="s3">\n  </span><span class="s1">content: string | null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export type OriginalSource = {</span><span class="s3">\n  </span><span class="s1">map: null;</span><span class="s3">\n  </span><span class="s1">sources: Sources[];</span><span class="s3">\n  </span><span class="s1">source: string;</span><span class="s3">\n  </span><span class="s1">content: string | null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export type MapSource = {</span><span class="s3">\n  </span><span class="s1">map: TraceMap;</span><span class="s3">\n  </span><span class="s1">sources: Sources[];</span><span class="s3">\n  </span><span class="s1">source: string;</span><span class="s3">\n  </span><span class="s1">content: null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export type Sources = OriginalSource | MapSource;</span><span class="s3">\n\n</span><span class="s1">const SOURCELESS_MAPPING = /* #__PURE__ */ SegmentObject('', -1, -1, '', null);</span><span class="s3">\n</span><span class="s1">const EMPTY_SOURCES: Sources[] = [];</span><span class="s3">\n\n</span><span class="s1">function SegmentObject(</span><span class="s3">\n  </span><span class="s1">source: string,</span><span class="s3">\n  </span><span class="s1">line: number,</span><span class="s3">\n  </span><span class="s1">column: number,</span><span class="s3">\n  </span><span class="s1">name: string,</span><span class="s3">\n  </span><span class="s1">content: string | null</span><span class="s3">\n</span><span class="s1">): SourceMapSegmentObject {</span><span class="s3">\n  </span><span class="s1">return { source, line, column, name, content };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function Source(map: TraceMap, sources: Sources[], source: '', content: null): MapSource;</span><span class="s3">\n</span><span class="s1">function Source(</span><span class="s3">\n  </span><span class="s1">map: null,</span><span class="s3">\n  </span><span class="s1">sources: Sources[],</span><span class="s3">\n  </span><span class="s1">source: string,</span><span class="s3">\n  </span><span class="s1">content: string | null</span><span class="s3">\n</span><span class="s1">): OriginalSource;</span><span class="s3">\n</span><span class="s1">function Source(</span><span class="s3">\n  </span><span class="s1">map: TraceMap | null,</span><span class="s3">\n  </span><span class="s1">sources: Sources[],</span><span class="s3">\n  </span><span class="s1">source: string | '',</span><span class="s3">\n  </span><span class="s1">content: string | null</span><span class="s3">\n</span><span class="s1">): Sources {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">map,</span><span class="s3">\n    </span><span class="s1">sources,</span><span class="s3">\n    </span><span class="s1">source,</span><span class="s3">\n    </span><span class="s1">content,</span><span class="s3">\n  </span><span class="s1">} as any;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes</span><span class="s3">\n </span><span class="s1">* (which may themselves be SourceMapTrees).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function MapSource(map: TraceMap, sources: Sources[]): MapSource {</span><span class="s3">\n  </span><span class="s1">return Source(map, sources, '', null);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A </span><span class="s3">\&quot;</span><span class="s1">leaf</span><span class="s3">\&quot; </span><span class="s1">node in the sourcemap tree, representing an original, unmodified source file. Recursive</span><span class="s3">\n </span><span class="s1">* segment tracing ends at the `OriginalSource`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function OriginalSource(source: string, content: string | null): OriginalSource {</span><span class="s3">\n  </span><span class="s1">return Source(null, EMPTY_SOURCES, source, content);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* traceMappings is only called on the root level SourceMapTree, and begins the process of</span><span class="s3">\n </span><span class="s1">* resolving each mapping in terms of the original source files.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function traceMappings(tree: MapSource): GenMapping {</span><span class="s3">\n  </span><span class="s1">// TODO: Eventually support sourceRoot, which has to be removed because the sources are already</span><span class="s3">\n  </span><span class="s1">// fully resolved. We'll need to make sources relative to the sourceRoot before adding them.</span><span class="s3">\n  </span><span class="s1">const gen = new GenMapping({ file: tree.map.file });</span><span class="s3">\n  </span><span class="s1">const { sources: rootSources, map } = tree;</span><span class="s3">\n  </span><span class="s1">const rootNames = map.names;</span><span class="s3">\n  </span><span class="s1">const rootMappings = decodedMappings(map);</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; rootMappings.length; i++) {</span><span class="s3">\n    </span><span class="s1">const segments = rootMappings[i];</span><span class="s3">\n\n    </span><span class="s1">for (let j = 0; j &lt; segments.length; j++) {</span><span class="s3">\n      </span><span class="s1">const segment = segments[j];</span><span class="s3">\n      </span><span class="s1">const genCol = segment[0];</span><span class="s3">\n      </span><span class="s1">let traced: SourceMapSegmentObject | null = SOURCELESS_MAPPING;</span><span class="s3">\n\n      </span><span class="s1">// 1-length segments only move the current generated column, there's no source information</span><span class="s3">\n      </span><span class="s1">// to gather from it.</span><span class="s3">\n      </span><span class="s1">if (segment.length !== 1) {</span><span class="s3">\n        </span><span class="s1">const source = rootSources[segment[1]];</span><span class="s3">\n        </span><span class="s1">traced = originalPositionFor(</span><span class="s3">\n          </span><span class="s1">source,</span><span class="s3">\n          </span><span class="s1">segment[2],</span><span class="s3">\n          </span><span class="s1">segment[3],</span><span class="s3">\n          </span><span class="s1">segment.length === 5 ? rootNames[segment[4]] : ''</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">// If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a</span><span class="s3">\n        </span><span class="s1">// respective segment into an original source.</span><span class="s3">\n        </span><span class="s1">if (traced == null) continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const { column, line, name, content, source } = traced;</span><span class="s3">\n\n      </span><span class="s1">maybeAddSegment(gen, i, genCol, source, line, column, name);</span><span class="s3">\n      </span><span class="s1">if (source &amp;&amp; content != null) setSourceContent(gen, source, content);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return gen;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* originalPositionFor is only called on children SourceMapTrees. It recurses down into its own</span><span class="s3">\n </span><span class="s1">* child SourceMapTrees, until we find the original source map.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function originalPositionFor(</span><span class="s3">\n  </span><span class="s1">source: Sources,</span><span class="s3">\n  </span><span class="s1">line: number,</span><span class="s3">\n  </span><span class="s1">column: number,</span><span class="s3">\n  </span><span class="s1">name: string</span><span class="s3">\n</span><span class="s1">): SourceMapSegmentObject | null {</span><span class="s3">\n  </span><span class="s1">if (!source.map) {</span><span class="s3">\n    </span><span class="s1">return SegmentObject(source.source, line, column, name, source.content);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const segment = traceSegment(source.map, line, column);</span><span class="s3">\n\n  </span><span class="s1">// If we couldn't find a segment, then this doesn't exist in the sourcemap.</span><span class="s3">\n  </span><span class="s1">if (segment == null) return null;</span><span class="s3">\n  </span><span class="s1">// 1-length segments only move the current generated column, there's no source information</span><span class="s3">\n  </span><span class="s1">// to gather from it.</span><span class="s3">\n  </span><span class="s1">if (segment.length === 1) return SOURCELESS_MAPPING;</span><span class="s3">\n\n  </span><span class="s1">return originalPositionFor(</span><span class="s3">\n    </span><span class="s1">source.sources[segment[1]],</span><span class="s3">\n    </span><span class="s1">segment[2],</span><span class="s3">\n    </span><span class="s1">segment[3],</span><span class="s3">\n    </span><span class="s1">segment.length === 5 ? source.map.names[segment[4]] : name</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { TraceMap } from '@jridgewell/trace-mapping';</span><span class="s3">\n\n</span><span class="s1">import { OriginalSource, MapSource } from './source-map-tree';</span><span class="s3">\n\n</span><span class="s1">import type { Sources, MapSource as MapSourceType } from './source-map-tree';</span><span class="s3">\n</span><span class="s1">import type { SourceMapInput, SourceMapLoader, LoaderContext } from './types';</span><span class="s3">\n\n</span><span class="s1">function asArray&lt;T&gt;(value: T | T[]): T[] {</span><span class="s3">\n  </span><span class="s1">if (Array.isArray(value)) return value;</span><span class="s3">\n  </span><span class="s1">return [value];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Recursively builds a tree structure out of sourcemap files, with each node</span><span class="s3">\n </span><span class="s1">* being either an `OriginalSource` </span><span class="s3">\&quot;</span><span class="s1">leaf</span><span class="s3">\&quot; </span><span class="s1">or a `SourceMapTree` composed of</span><span class="s3">\n </span><span class="s1">* `OriginalSource`s and `SourceMapTree`s.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Every sourcemap is composed of a collection of source files and mappings</span><span class="s3">\n </span><span class="s1">* into locations of those source files. When we generate a `SourceMapTree` for</span><span class="s3">\n </span><span class="s1">* the sourcemap, we attempt to load each source file's own sourcemap. If it</span><span class="s3">\n </span><span class="s1">* does not have an associated sourcemap, it is considered an original,</span><span class="s3">\n </span><span class="s1">* unmodified source file.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function buildSourceMapTree(</span><span class="s3">\n  </span><span class="s1">input: SourceMapInput | SourceMapInput[],</span><span class="s3">\n  </span><span class="s1">loader: SourceMapLoader</span><span class="s3">\n</span><span class="s1">): MapSourceType {</span><span class="s3">\n  </span><span class="s1">const maps = asArray(input).map((m) =&gt; new TraceMap(m, ''));</span><span class="s3">\n  </span><span class="s1">const map = maps.pop()!;</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; maps.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (maps[i].sources.length &gt; 1) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`Transformation map ${i} must have exactly one source file.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n          </span><span class="s1">'Did you specify these with the most recent transformation maps first?'</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let tree = build(map, loader, '', 0);</span><span class="s3">\n  </span><span class="s1">for (let i = maps.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n    </span><span class="s1">tree = MapSource(maps[i], [tree]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return tree;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function build(</span><span class="s3">\n  </span><span class="s1">map: TraceMap,</span><span class="s3">\n  </span><span class="s1">loader: SourceMapLoader,</span><span class="s3">\n  </span><span class="s1">importer: string,</span><span class="s3">\n  </span><span class="s1">importerDepth: number</span><span class="s3">\n</span><span class="s1">): MapSourceType {</span><span class="s3">\n  </span><span class="s1">const { resolvedSources, sourcesContent } = map;</span><span class="s3">\n\n  </span><span class="s1">const depth = importerDepth + 1;</span><span class="s3">\n  </span><span class="s1">const children = resolvedSources.map((sourceFile: string | null, i: number): Sources =&gt; {</span><span class="s3">\n    </span><span class="s1">// The loading context gives the loader more information about why this file is being loaded</span><span class="s3">\n    </span><span class="s1">// (eg, from which importer). It also allows the loader to override the location of the loaded</span><span class="s3">\n    </span><span class="s1">// sourcemap/original source, or to override the content in the sourcesContent field if it's</span><span class="s3">\n    </span><span class="s1">// an unmodified source file.</span><span class="s3">\n    </span><span class="s1">const ctx: LoaderContext = {</span><span class="s3">\n      </span><span class="s1">importer,</span><span class="s3">\n      </span><span class="s1">depth,</span><span class="s3">\n      </span><span class="s1">source: sourceFile || '',</span><span class="s3">\n      </span><span class="s1">content: undefined,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// Use the provided loader callback to retrieve the file's sourcemap.</span><span class="s3">\n    </span><span class="s1">// TODO: We should eventually support async loading of sourcemap files.</span><span class="s3">\n    </span><span class="s1">const sourceMap = loader(ctx.source, ctx);</span><span class="s3">\n\n    </span><span class="s1">const { source, content } = ctx;</span><span class="s3">\n\n    </span><span class="s1">// If there is a sourcemap, then we need to recurse into it to load its source files.</span><span class="s3">\n    </span><span class="s1">if (sourceMap) return build(new TraceMap(sourceMap, source), loader, source, depth);</span><span class="s3">\n\n    </span><span class="s1">// Else, it's an an unmodified source file.</span><span class="s3">\n    </span><span class="s1">// The contents of this unmodified source file can be overridden via the loader context,</span><span class="s3">\n    </span><span class="s1">// allowing it to be explicitly null or a string. If it remains undefined, we fall back to</span><span class="s3">\n    </span><span class="s1">// the importing sourcemap's `sourcesContent` field.</span><span class="s3">\n    </span><span class="s1">const sourceContent =</span><span class="s3">\n      </span><span class="s1">content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;</span><span class="s3">\n    </span><span class="s1">return OriginalSource(source, sourceContent);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return MapSource(map, children);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { toDecodedMap, toEncodedMap } from '@jridgewell/gen-mapping';</span><span class="s3">\n\n</span><span class="s1">import type { GenMapping } from '@jridgewell/gen-mapping';</span><span class="s3">\n</span><span class="s1">import type { DecodedSourceMap, EncodedSourceMap, Options } from './types';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A SourceMap v3 compatible sourcemap, which only includes fields that were</span><span class="s3">\n </span><span class="s1">* provided to it.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default class SourceMap {</span><span class="s3">\n  </span><span class="s1">declare file?: string | null;</span><span class="s3">\n  </span><span class="s1">declare mappings: EncodedSourceMap['mappings'] | DecodedSourceMap['mappings'];</span><span class="s3">\n  </span><span class="s1">declare sourceRoot?: string;</span><span class="s3">\n  </span><span class="s1">declare names: string[];</span><span class="s3">\n  </span><span class="s1">declare sources: (string | null)[];</span><span class="s3">\n  </span><span class="s1">declare sourcesContent?: (string | null)[];</span><span class="s3">\n  </span><span class="s1">declare version: 3;</span><span class="s3">\n\n  </span><span class="s1">constructor(map: GenMapping, options: Options) {</span><span class="s3">\n    </span><span class="s1">const out = options.decodedMappings ? toDecodedMap(map) : toEncodedMap(map);</span><span class="s3">\n    </span><span class="s1">this.version = out.version; // SourceMap spec says this should be first.</span><span class="s3">\n    </span><span class="s1">this.file = out.file;</span><span class="s3">\n    </span><span class="s1">this.mappings = out.mappings as SourceMap['mappings'];</span><span class="s3">\n    </span><span class="s1">this.names = out.names as SourceMap['names'];</span><span class="s3">\n\n    </span><span class="s1">this.sourceRoot = out.sourceRoot;</span><span class="s3">\n\n    </span><span class="s1">this.sources = out.sources as SourceMap['sources'];</span><span class="s3">\n    </span><span class="s1">if (!options.excludeContent) {</span><span class="s3">\n      </span><span class="s1">this.sourcesContent = out.sourcesContent as SourceMap['sourcesContent'];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toString(): string {</span><span class="s3">\n    </span><span class="s1">return JSON.stringify(this);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import buildSourceMapTree from './build-source-map-tree';</span><span class="s3">\n</span><span class="s1">import { traceMappings } from './source-map-tree';</span><span class="s3">\n</span><span class="s1">import SourceMap from './source-map';</span><span class="s3">\n\n</span><span class="s1">import type { SourceMapInput, SourceMapLoader, Options } from './types';</span><span class="s3">\n</span><span class="s1">export type {</span><span class="s3">\n  </span><span class="s1">SourceMapSegment,</span><span class="s3">\n  </span><span class="s1">EncodedSourceMap,</span><span class="s3">\n  </span><span class="s1">EncodedSourceMap as RawSourceMap,</span><span class="s3">\n  </span><span class="s1">DecodedSourceMap,</span><span class="s3">\n  </span><span class="s1">SourceMapInput,</span><span class="s3">\n  </span><span class="s1">SourceMapLoader,</span><span class="s3">\n  </span><span class="s1">LoaderContext,</span><span class="s3">\n  </span><span class="s1">Options,</span><span class="s3">\n</span><span class="s1">} from './types';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Traces through all the mappings in the root sourcemap, through the sources</span><span class="s3">\n </span><span class="s1">* (and their sourcemaps), all the way back to the original source location.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* `loader` will be called every time we encounter a source file. If it returns</span><span class="s3">\n </span><span class="s1">* a sourcemap, we will recurse into that sourcemap to continue the trace. If</span><span class="s3">\n </span><span class="s1">* it returns a falsey value, that source file is treated as an original,</span><span class="s3">\n </span><span class="s1">* unmodified source file.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Pass `excludeContent` to exclude any self-containing source file content</span><span class="s3">\n </span><span class="s1">* from the output sourcemap.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Pass `decodedMappings` to receive a SourceMap with decoded (instead of</span><span class="s3">\n </span><span class="s1">* VLQ encoded) mappings.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function remapping(</span><span class="s3">\n  </span><span class="s1">input: SourceMapInput | SourceMapInput[],</span><span class="s3">\n  </span><span class="s1">loader: SourceMapLoader,</span><span class="s3">\n  </span><span class="s1">options?: boolean | Options</span><span class="s3">\n</span><span class="s1">): SourceMap {</span><span class="s3">\n  </span><span class="s1">const opts =</span><span class="s3">\n    </span><span class="s1">typeof options === 'object' ? options : { excludeContent: !!options, decodedMappings: false };</span><span class="s3">\n  </span><span class="s1">const tree = buildSourceMapTree(input, loader);</span><span class="s3">\n  </span><span class="s1">return new SourceMap(traceMappings(tree), opts);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>