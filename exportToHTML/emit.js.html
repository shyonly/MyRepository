<html>
<head>
<title>emit.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #6aab73;}
.s4 { color: #bcbec4;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
emit.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Copyright (c) 2014-present, Facebook, Inc.</span>
 <span class="s0">*</span>
 <span class="s0">* This source code is licensed under the MIT license found in the</span>
 <span class="s0">* LICENSE file in the root directory of this source tree.</span>
 <span class="s0">*/</span>

<span class="s2">import </span><span class="s1">assert from </span><span class="s3">&quot;assert&quot;</span><span class="s4">;</span>
<span class="s2">import </span><span class="s4">* as </span><span class="s1">leap from </span><span class="s3">&quot;./leap&quot;</span><span class="s4">;</span>
<span class="s2">import </span><span class="s4">* as </span><span class="s1">meta from </span><span class="s3">&quot;./meta&quot;</span><span class="s4">;</span>
<span class="s2">import </span><span class="s4">* as </span><span class="s1">util from </span><span class="s3">&quot;./util&quot;</span><span class="s4">;</span>

<span class="s2">let </span><span class="s1">hasOwn </span><span class="s4">= </span><span class="s1">Object</span><span class="s4">.</span><span class="s1">prototype</span><span class="s4">.</span><span class="s1">hasOwnProperty</span><span class="s4">;</span>

<span class="s2">function </span><span class="s1">Emitter</span><span class="s4">(</span><span class="s1">contextId</span><span class="s4">) {</span>
  <span class="s1">assert</span><span class="s4">.</span><span class="s1">ok</span><span class="s4">(</span><span class="s2">this instanceof </span><span class="s1">Emitter</span><span class="s4">);</span>

  <span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">().</span><span class="s1">assertIdentifier</span><span class="s4">(</span><span class="s1">contextId</span><span class="s4">);</span>

  <span class="s5">// Used to generate unique temporary names.</span>
  <span class="s2">this</span><span class="s4">.</span><span class="s1">nextTempId </span><span class="s4">= </span><span class="s6">0</span><span class="s4">;</span>

  <span class="s5">// In order to make sure the context object does not collide with</span>
  <span class="s5">// anything in the local scope, we might have to rename it, so we</span>
  <span class="s5">// refer to it symbolically instead of just assuming that it will be</span>
  <span class="s5">// called &quot;context&quot;.</span>
  <span class="s2">this</span><span class="s4">.</span><span class="s1">contextId </span><span class="s4">= </span><span class="s1">contextId</span><span class="s4">;</span>

  <span class="s5">// An append-only list of Statements that grows each time this.emit is</span>
  <span class="s5">// called.</span>
  <span class="s2">this</span><span class="s4">.</span><span class="s1">listing </span><span class="s4">= [];</span>

  <span class="s5">// A sparse array whose keys correspond to locations in this.listing</span>
  <span class="s5">// that have been marked as branch/jump targets.</span>
  <span class="s2">this</span><span class="s4">.</span><span class="s1">marked </span><span class="s4">= [</span><span class="s2">true</span><span class="s4">];</span>

  <span class="s2">this</span><span class="s4">.</span><span class="s1">insertedLocs </span><span class="s4">= </span><span class="s2">new </span><span class="s1">Set</span><span class="s4">();</span>

  <span class="s5">// The last location will be marked when this.getDispatchLoop is</span>
  <span class="s5">// called.</span>
  <span class="s2">this</span><span class="s4">.</span><span class="s1">finalLoc </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>

  <span class="s5">// A list of all leap.TryEntry statements emitted.</span>
  <span class="s2">this</span><span class="s4">.</span><span class="s1">tryEntries </span><span class="s4">= [];</span>

  <span class="s5">// Each time we evaluate the body of a loop, we tell this.leapManager</span>
  <span class="s5">// to enter a nested loop context that determines the meaning of break</span>
  <span class="s5">// and continue statements therein.</span>
  <span class="s2">this</span><span class="s4">.</span><span class="s1">leapManager </span><span class="s4">= </span><span class="s2">new </span><span class="s1">leap</span><span class="s4">.</span><span class="s1">LeapManager</span><span class="s4">(</span><span class="s2">this</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s2">let </span><span class="s1">Ep </span><span class="s4">= </span><span class="s1">Emitter</span><span class="s4">.</span><span class="s1">prototype</span><span class="s4">;</span>
<span class="s1">exports</span><span class="s4">.</span><span class="s1">Emitter </span><span class="s4">= </span><span class="s1">Emitter</span><span class="s4">;</span>

<span class="s5">// Offsets into this.listing that could be used as targets for branches or</span>
<span class="s5">// jumps are represented as numeric Literal nodes. This representation has</span>
<span class="s5">// the amazingly convenient benefit of allowing the exact value of the</span>
<span class="s5">// location to be determined at any time, even after generating code that</span>
<span class="s5">// refers to the location.</span>
<span class="s5">// We use 'Number.MAX_VALUE' to mark uninitialized location. We can safely do</span>
<span class="s5">// so because no code can realistically have about 1.8e+308 locations before</span>
<span class="s5">// hitting memory limit of the machine it's running on. For comparison, the</span>
<span class="s5">// estimated number of atoms in the observable universe is around 1e+80.</span>
<span class="s2">const </span><span class="s1">PENDING_LOCATION </span><span class="s4">= </span><span class="s1">Number</span><span class="s4">.</span><span class="s1">MAX_VALUE</span><span class="s4">;</span>
<span class="s1">Ep</span><span class="s4">.</span><span class="s1">loc </span><span class="s4">= </span><span class="s2">function</span><span class="s4">() {</span>
  <span class="s2">const </span><span class="s1">l </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">().</span><span class="s1">numericLiteral</span><span class="s4">(</span><span class="s1">PENDING_LOCATION</span><span class="s4">)</span>
  <span class="s2">this</span><span class="s4">.</span><span class="s1">insertedLocs</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">l</span><span class="s4">);</span>
  <span class="s2">return </span><span class="s1">l</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s1">Ep</span><span class="s4">.</span><span class="s1">getInsertedLocs </span><span class="s4">= </span><span class="s2">function</span><span class="s4">() {</span>
  <span class="s2">return this</span><span class="s4">.</span><span class="s1">insertedLocs</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s1">Ep</span><span class="s4">.</span><span class="s1">getContextId </span><span class="s4">= </span><span class="s2">function</span><span class="s4">() {</span>
  <span class="s2">return </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">().</span><span class="s1">clone</span><span class="s4">(</span><span class="s2">this</span><span class="s4">.</span><span class="s1">contextId</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s5">// Sets the exact value of the given location to the offset of the next</span>
<span class="s5">// Statement emitted.</span>
<span class="s1">Ep</span><span class="s4">.</span><span class="s1">mark </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">loc</span><span class="s4">) {</span>
  <span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">().</span><span class="s1">assertLiteral</span><span class="s4">(</span><span class="s1">loc</span><span class="s4">);</span>
  <span class="s2">let </span><span class="s1">index </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">listing</span><span class="s4">.</span><span class="s1">length</span><span class="s4">;</span>
  <span class="s2">if </span><span class="s4">(</span><span class="s1">loc</span><span class="s4">.</span><span class="s1">value </span><span class="s4">=== </span><span class="s1">PENDING_LOCATION</span><span class="s4">) {</span>
    <span class="s1">loc</span><span class="s4">.</span><span class="s1">value </span><span class="s4">= </span><span class="s1">index</span><span class="s4">;</span>
  <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
    <span class="s5">// Locations can be marked redundantly, but their values cannot change</span>
    <span class="s5">// once set the first time.</span>
    <span class="s1">assert</span><span class="s4">.</span><span class="s1">strictEqual</span><span class="s4">(</span><span class="s1">loc</span><span class="s4">.</span><span class="s1">value</span><span class="s4">, </span><span class="s1">index</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s2">this</span><span class="s4">.</span><span class="s1">marked</span><span class="s4">[</span><span class="s1">index</span><span class="s4">] = </span><span class="s2">true</span><span class="s4">;</span>
  <span class="s2">return </span><span class="s1">loc</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s1">Ep</span><span class="s4">.</span><span class="s1">emit </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">node</span><span class="s4">) {</span>
  <span class="s2">const </span><span class="s1">t </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">();</span>

  <span class="s2">if </span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">isExpression</span><span class="s4">(</span><span class="s1">node</span><span class="s4">)) {</span>
    <span class="s1">node </span><span class="s4">= </span><span class="s1">t</span><span class="s4">.</span><span class="s1">expressionStatement</span><span class="s4">(</span><span class="s1">node</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s1">t</span><span class="s4">.</span><span class="s1">assertStatement</span><span class="s4">(</span><span class="s1">node</span><span class="s4">);</span>
  <span class="s2">this</span><span class="s4">.</span><span class="s1">listing</span><span class="s4">.</span><span class="s1">push</span><span class="s4">(</span><span class="s1">node</span><span class="s4">);</span>
<span class="s4">};</span>

<span class="s5">// Shorthand for emitting assignment statements. This will come in handy</span>
<span class="s5">// for assignments to temporary variables.</span>
<span class="s1">Ep</span><span class="s4">.</span><span class="s1">emitAssign </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">lhs</span><span class="s4">, </span><span class="s1">rhs</span><span class="s4">) {</span>
  <span class="s2">this</span><span class="s4">.</span><span class="s1">emit</span><span class="s4">(</span><span class="s2">this</span><span class="s4">.</span><span class="s1">assign</span><span class="s4">(</span><span class="s1">lhs</span><span class="s4">, </span><span class="s1">rhs</span><span class="s4">));</span>
  <span class="s2">return </span><span class="s1">lhs</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s5">// Shorthand for an assignment statement.</span>
<span class="s1">Ep</span><span class="s4">.</span><span class="s1">assign </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">lhs</span><span class="s4">, </span><span class="s1">rhs</span><span class="s4">) {</span>
  <span class="s2">const </span><span class="s1">t </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">();</span>
  <span class="s2">return </span><span class="s1">t</span><span class="s4">.</span><span class="s1">expressionStatement</span><span class="s4">(</span>
    <span class="s1">t</span><span class="s4">.</span><span class="s1">assignmentExpression</span><span class="s4">(</span><span class="s3">&quot;=&quot;</span><span class="s4">, </span><span class="s1">t</span><span class="s4">.</span><span class="s1">cloneDeep</span><span class="s4">(</span><span class="s1">lhs</span><span class="s4">), </span><span class="s1">rhs</span><span class="s4">));</span>
<span class="s4">};</span>

<span class="s5">// Convenience function for generating expressions like context.next,</span>
<span class="s5">// context.sent, and context.rval.</span>
<span class="s1">Ep</span><span class="s4">.</span><span class="s1">contextProperty </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">computed</span><span class="s4">) {</span>
  <span class="s2">const </span><span class="s1">t </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">();</span>
  <span class="s2">return </span><span class="s1">t</span><span class="s4">.</span><span class="s1">memberExpression</span><span class="s4">(</span>
    <span class="s2">this</span><span class="s4">.</span><span class="s1">getContextId</span><span class="s4">(),</span>
    <span class="s1">computed </span><span class="s4">? </span><span class="s1">t</span><span class="s4">.</span><span class="s1">stringLiteral</span><span class="s4">(</span><span class="s1">name</span><span class="s4">) : </span><span class="s1">t</span><span class="s4">.</span><span class="s1">identifier</span><span class="s4">(</span><span class="s1">name</span><span class="s4">),</span>
    <span class="s4">!!</span><span class="s1">computed</span>
  <span class="s4">);</span>
<span class="s4">};</span>

<span class="s5">// Shorthand for setting context.rval and jumping to `context.stop()`.</span>
<span class="s1">Ep</span><span class="s4">.</span><span class="s1">stop </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">rval</span><span class="s4">) {</span>
  <span class="s2">if </span><span class="s4">(</span><span class="s1">rval</span><span class="s4">) {</span>
    <span class="s2">this</span><span class="s4">.</span><span class="s1">setReturnValue</span><span class="s4">(</span><span class="s1">rval</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s2">this</span><span class="s4">.</span><span class="s1">jump</span><span class="s4">(</span><span class="s2">this</span><span class="s4">.</span><span class="s1">finalLoc</span><span class="s4">);</span>
<span class="s4">};</span>

<span class="s1">Ep</span><span class="s4">.</span><span class="s1">setReturnValue </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">valuePath</span><span class="s4">) {</span>
  <span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">().</span><span class="s1">assertExpression</span><span class="s4">(</span><span class="s1">valuePath</span><span class="s4">.</span><span class="s1">value</span><span class="s4">);</span>

  <span class="s2">this</span><span class="s4">.</span><span class="s1">emitAssign</span><span class="s4">(</span>
    <span class="s2">this</span><span class="s4">.</span><span class="s1">contextProperty</span><span class="s4">(</span><span class="s3">&quot;rval&quot;</span><span class="s4">),</span>
    <span class="s2">this</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">valuePath</span><span class="s4">)</span>
  <span class="s4">);</span>
<span class="s4">};</span>

<span class="s1">Ep</span><span class="s4">.</span><span class="s1">clearPendingException </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">tryLoc</span><span class="s4">, </span><span class="s1">assignee</span><span class="s4">) {</span>
  <span class="s2">const </span><span class="s1">t </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">();</span>

  <span class="s1">t</span><span class="s4">.</span><span class="s1">assertLiteral</span><span class="s4">(</span><span class="s1">tryLoc</span><span class="s4">);</span>

  <span class="s2">let </span><span class="s1">catchCall </span><span class="s4">= </span><span class="s1">t</span><span class="s4">.</span><span class="s1">callExpression</span><span class="s4">(</span>
    <span class="s2">this</span><span class="s4">.</span><span class="s1">contextProperty</span><span class="s4">(</span><span class="s3">&quot;catch&quot;</span><span class="s4">, </span><span class="s2">true</span><span class="s4">),</span>
    <span class="s4">[</span><span class="s1">t</span><span class="s4">.</span><span class="s1">clone</span><span class="s4">(</span><span class="s1">tryLoc</span><span class="s4">)]</span>
  <span class="s4">);</span>

  <span class="s2">if </span><span class="s4">(</span><span class="s1">assignee</span><span class="s4">) {</span>
    <span class="s2">this</span><span class="s4">.</span><span class="s1">emitAssign</span><span class="s4">(</span><span class="s1">assignee</span><span class="s4">, </span><span class="s1">catchCall</span><span class="s4">);</span>
  <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
    <span class="s2">this</span><span class="s4">.</span><span class="s1">emit</span><span class="s4">(</span><span class="s1">catchCall</span><span class="s4">);</span>
  <span class="s4">}</span>
<span class="s4">};</span>

<span class="s5">// Emits code for an unconditional jump to the given location, even if the</span>
<span class="s5">// exact value of the location is not yet known.</span>
<span class="s1">Ep</span><span class="s4">.</span><span class="s1">jump </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">toLoc</span><span class="s4">) {</span>
  <span class="s2">this</span><span class="s4">.</span><span class="s1">emitAssign</span><span class="s4">(</span><span class="s2">this</span><span class="s4">.</span><span class="s1">contextProperty</span><span class="s4">(</span><span class="s3">&quot;next&quot;</span><span class="s4">), </span><span class="s1">toLoc</span><span class="s4">);</span>
  <span class="s2">this</span><span class="s4">.</span><span class="s1">emit</span><span class="s4">(</span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">().</span><span class="s1">breakStatement</span><span class="s4">());</span>
<span class="s4">};</span>

<span class="s5">// Conditional jump.</span>
<span class="s1">Ep</span><span class="s4">.</span><span class="s1">jumpIf </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">test</span><span class="s4">, </span><span class="s1">toLoc</span><span class="s4">) {</span>
  <span class="s2">const </span><span class="s1">t </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">();</span>

  <span class="s1">t</span><span class="s4">.</span><span class="s1">assertExpression</span><span class="s4">(</span><span class="s1">test</span><span class="s4">);</span>
  <span class="s1">t</span><span class="s4">.</span><span class="s1">assertLiteral</span><span class="s4">(</span><span class="s1">toLoc</span><span class="s4">);</span>

  <span class="s2">this</span><span class="s4">.</span><span class="s1">emit</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">ifStatement</span><span class="s4">(</span>
    <span class="s1">test</span><span class="s4">,</span>
    <span class="s1">t</span><span class="s4">.</span><span class="s1">blockStatement</span><span class="s4">([</span>
      <span class="s2">this</span><span class="s4">.</span><span class="s1">assign</span><span class="s4">(</span><span class="s2">this</span><span class="s4">.</span><span class="s1">contextProperty</span><span class="s4">(</span><span class="s3">&quot;next&quot;</span><span class="s4">), </span><span class="s1">toLoc</span><span class="s4">),</span>
      <span class="s1">t</span><span class="s4">.</span><span class="s1">breakStatement</span><span class="s4">()</span>
    <span class="s4">])</span>
  <span class="s4">));</span>
<span class="s4">};</span>

<span class="s5">// Conditional jump, with the condition negated.</span>
<span class="s1">Ep</span><span class="s4">.</span><span class="s1">jumpIfNot </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">test</span><span class="s4">, </span><span class="s1">toLoc</span><span class="s4">) {</span>
  <span class="s2">const </span><span class="s1">t </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">();</span>

  <span class="s1">t</span><span class="s4">.</span><span class="s1">assertExpression</span><span class="s4">(</span><span class="s1">test</span><span class="s4">);</span>
  <span class="s1">t</span><span class="s4">.</span><span class="s1">assertLiteral</span><span class="s4">(</span><span class="s1">toLoc</span><span class="s4">);</span>

  <span class="s2">let </span><span class="s1">negatedTest</span><span class="s4">;</span>
  <span class="s2">if </span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">isUnaryExpression</span><span class="s4">(</span><span class="s1">test</span><span class="s4">) &amp;&amp;</span>
      <span class="s1">test</span><span class="s4">.</span><span class="s1">operator </span><span class="s4">=== </span><span class="s3">&quot;!&quot;</span><span class="s4">) {</span>
    <span class="s5">// Avoid double negation.</span>
    <span class="s1">negatedTest </span><span class="s4">= </span><span class="s1">test</span><span class="s4">.</span><span class="s1">argument</span><span class="s4">;</span>
  <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
    <span class="s1">negatedTest </span><span class="s4">= </span><span class="s1">t</span><span class="s4">.</span><span class="s1">unaryExpression</span><span class="s4">(</span><span class="s3">&quot;!&quot;</span><span class="s4">, </span><span class="s1">test</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s2">this</span><span class="s4">.</span><span class="s1">emit</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">ifStatement</span><span class="s4">(</span>
    <span class="s1">negatedTest</span><span class="s4">,</span>
    <span class="s1">t</span><span class="s4">.</span><span class="s1">blockStatement</span><span class="s4">([</span>
      <span class="s2">this</span><span class="s4">.</span><span class="s1">assign</span><span class="s4">(</span><span class="s2">this</span><span class="s4">.</span><span class="s1">contextProperty</span><span class="s4">(</span><span class="s3">&quot;next&quot;</span><span class="s4">), </span><span class="s1">toLoc</span><span class="s4">),</span>
      <span class="s1">t</span><span class="s4">.</span><span class="s1">breakStatement</span><span class="s4">()</span>
    <span class="s4">])</span>
  <span class="s4">));</span>
<span class="s4">};</span>

<span class="s5">// Returns a unique MemberExpression that can be used to store and</span>
<span class="s5">// retrieve temporary values. Since the object of the member expression is</span>
<span class="s5">// the context object, which is presumed to coexist peacefully with all</span>
<span class="s5">// other local variables, and since we just increment `nextTempId`</span>
<span class="s5">// monotonically, uniqueness is assured.</span>
<span class="s1">Ep</span><span class="s4">.</span><span class="s1">makeTempVar </span><span class="s4">= </span><span class="s2">function</span><span class="s4">() {</span>
  <span class="s2">return this</span><span class="s4">.</span><span class="s1">contextProperty</span><span class="s4">(</span><span class="s3">&quot;t&quot; </span><span class="s4">+ </span><span class="s2">this</span><span class="s4">.</span><span class="s1">nextTempId</span><span class="s4">++);</span>
<span class="s4">};</span>

<span class="s1">Ep</span><span class="s4">.</span><span class="s1">getContextFunction </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">id</span><span class="s4">) {</span>
  <span class="s2">const </span><span class="s1">t </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">();</span>

  <span class="s2">return </span><span class="s1">t</span><span class="s4">.</span><span class="s1">functionExpression</span><span class="s4">(</span>
    <span class="s1">id </span><span class="s4">|| </span><span class="s2">null</span><span class="s5">/*Anonymous*/</span><span class="s4">,</span>
    <span class="s4">[</span><span class="s2">this</span><span class="s4">.</span><span class="s1">getContextId</span><span class="s4">()],</span>
    <span class="s1">t</span><span class="s4">.</span><span class="s1">blockStatement</span><span class="s4">([</span><span class="s2">this</span><span class="s4">.</span><span class="s1">getDispatchLoop</span><span class="s4">()]),</span>
    <span class="s2">false</span><span class="s4">, </span><span class="s5">// Not a generator anymore!</span>
    <span class="s2">false </span><span class="s5">// Nor an expression.</span>
  <span class="s4">);</span>
<span class="s4">};</span>

<span class="s5">// Turns this.listing into a loop of the form</span>
<span class="s5">//</span>
<span class="s5">//   while (1) switch (context.next) {</span>
<span class="s5">//   case 0:</span>
<span class="s5">//   ...</span>
<span class="s5">//   case n:</span>
<span class="s5">//     return context.stop();</span>
<span class="s5">//   }</span>
<span class="s5">//</span>
<span class="s5">// Each marked location in this.listing will correspond to one generated</span>
<span class="s5">// case statement.</span>
<span class="s1">Ep</span><span class="s4">.</span><span class="s1">getDispatchLoop </span><span class="s4">= </span><span class="s2">function</span><span class="s4">() {</span>
  <span class="s2">const </span><span class="s1">self </span><span class="s4">= </span><span class="s2">this</span><span class="s4">;</span>
  <span class="s2">const </span><span class="s1">t </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">();</span>
  <span class="s2">let </span><span class="s1">cases </span><span class="s4">= [];</span>
  <span class="s2">let </span><span class="s1">current</span><span class="s4">;</span>

  <span class="s5">// If we encounter a break, continue, or return statement in a switch</span>
  <span class="s5">// case, we can skip the rest of the statements until the next case.</span>
  <span class="s2">let </span><span class="s1">alreadyEnded </span><span class="s4">= </span><span class="s2">false</span><span class="s4">;</span>

  <span class="s1">self</span><span class="s4">.</span><span class="s1">listing</span><span class="s4">.</span><span class="s1">forEach</span><span class="s4">(</span><span class="s2">function</span><span class="s4">(</span><span class="s1">stmt</span><span class="s4">, </span><span class="s1">i</span><span class="s4">) {</span>
    <span class="s2">if </span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">marked</span><span class="s4">.</span><span class="s1">hasOwnProperty</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)) {</span>
      <span class="s1">cases</span><span class="s4">.</span><span class="s1">push</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">switchCase</span><span class="s4">(</span>
        <span class="s1">t</span><span class="s4">.</span><span class="s1">numericLiteral</span><span class="s4">(</span><span class="s1">i</span><span class="s4">),</span>
        <span class="s1">current </span><span class="s4">= []));</span>
      <span class="s1">alreadyEnded </span><span class="s4">= </span><span class="s2">false</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s2">if </span><span class="s4">(!</span><span class="s1">alreadyEnded</span><span class="s4">) {</span>
      <span class="s1">current</span><span class="s4">.</span><span class="s1">push</span><span class="s4">(</span><span class="s1">stmt</span><span class="s4">);</span>
      <span class="s2">if </span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">isCompletionStatement</span><span class="s4">(</span><span class="s1">stmt</span><span class="s4">))</span>
        <span class="s1">alreadyEnded </span><span class="s4">= </span><span class="s2">true</span><span class="s4">;</span>
    <span class="s4">}</span>
  <span class="s4">});</span>

  <span class="s5">// Now that we know how many statements there will be in this.listing,</span>
  <span class="s5">// we can finally resolve this.finalLoc.value.</span>
  <span class="s2">this</span><span class="s4">.</span><span class="s1">finalLoc</span><span class="s4">.</span><span class="s1">value </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">listing</span><span class="s4">.</span><span class="s1">length</span><span class="s4">;</span>

  <span class="s1">cases</span><span class="s4">.</span><span class="s1">push</span><span class="s4">(</span>
    <span class="s1">t</span><span class="s4">.</span><span class="s1">switchCase</span><span class="s4">(</span><span class="s2">this</span><span class="s4">.</span><span class="s1">finalLoc</span><span class="s4">, [</span>
      <span class="s5">// Intentionally fall through to the &quot;end&quot; case...</span>
    <span class="s4">]),</span>

    <span class="s5">// So that the runtime can jump to the final location without having</span>
    <span class="s5">// to know its offset, we provide the &quot;end&quot; case as a synonym.</span>
    <span class="s1">t</span><span class="s4">.</span><span class="s1">switchCase</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">stringLiteral</span><span class="s4">(</span><span class="s3">&quot;end&quot;</span><span class="s4">), [</span>
      <span class="s5">// This will check/clear both context.thrown and context.rval.</span>
      <span class="s1">t</span><span class="s4">.</span><span class="s1">returnStatement</span><span class="s4">(</span>
        <span class="s1">t</span><span class="s4">.</span><span class="s1">callExpression</span><span class="s4">(</span><span class="s2">this</span><span class="s4">.</span><span class="s1">contextProperty</span><span class="s4">(</span><span class="s3">&quot;stop&quot;</span><span class="s4">), [])</span>
      <span class="s4">)</span>
    <span class="s4">])</span>
  <span class="s4">);</span>

  <span class="s2">return </span><span class="s1">t</span><span class="s4">.</span><span class="s1">whileStatement</span><span class="s4">(</span>
    <span class="s1">t</span><span class="s4">.</span><span class="s1">numericLiteral</span><span class="s4">(</span><span class="s6">1</span><span class="s4">),</span>
    <span class="s1">t</span><span class="s4">.</span><span class="s1">switchStatement</span><span class="s4">(</span>
      <span class="s1">t</span><span class="s4">.</span><span class="s1">assignmentExpression</span><span class="s4">(</span>
        <span class="s3">&quot;=&quot;</span><span class="s4">,</span>
        <span class="s2">this</span><span class="s4">.</span><span class="s1">contextProperty</span><span class="s4">(</span><span class="s3">&quot;prev&quot;</span><span class="s4">),</span>
        <span class="s2">this</span><span class="s4">.</span><span class="s1">contextProperty</span><span class="s4">(</span><span class="s3">&quot;next&quot;</span><span class="s4">)</span>
      <span class="s4">),</span>
      <span class="s1">cases</span>
    <span class="s4">)</span>
  <span class="s4">);</span>
<span class="s4">};</span>

<span class="s1">Ep</span><span class="s4">.</span><span class="s1">getTryLocsList </span><span class="s4">= </span><span class="s2">function</span><span class="s4">() {</span>
  <span class="s2">if </span><span class="s4">(</span><span class="s2">this</span><span class="s4">.</span><span class="s1">tryEntries</span><span class="s4">.</span><span class="s1">length </span><span class="s4">=== </span><span class="s6">0</span><span class="s4">) {</span>
    <span class="s5">// To avoid adding a needless [] to the majority of runtime.wrap</span>
    <span class="s5">// argument lists, force the caller to handle this case specially.</span>
    <span class="s2">return null</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s2">const </span><span class="s1">t </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">();</span>
  <span class="s2">let </span><span class="s1">lastLocValue </span><span class="s4">= </span><span class="s6">0</span><span class="s4">;</span>

  <span class="s2">return </span><span class="s1">t</span><span class="s4">.</span><span class="s1">arrayExpression</span><span class="s4">(</span>
    <span class="s2">this</span><span class="s4">.</span><span class="s1">tryEntries</span><span class="s4">.</span><span class="s1">map</span><span class="s4">(</span><span class="s2">function</span><span class="s4">(</span><span class="s1">tryEntry</span><span class="s4">) {</span>
      <span class="s2">let </span><span class="s1">thisLocValue </span><span class="s4">= </span><span class="s1">tryEntry</span><span class="s4">.</span><span class="s1">firstLoc</span><span class="s4">.</span><span class="s1">value</span><span class="s4">;</span>
      <span class="s1">assert</span><span class="s4">.</span><span class="s1">ok</span><span class="s4">(</span><span class="s1">thisLocValue </span><span class="s4">&gt;= </span><span class="s1">lastLocValue</span><span class="s4">, </span><span class="s3">&quot;try entries out of order&quot;</span><span class="s4">);</span>
      <span class="s1">lastLocValue </span><span class="s4">= </span><span class="s1">thisLocValue</span><span class="s4">;</span>

      <span class="s2">let </span><span class="s1">ce </span><span class="s4">= </span><span class="s1">tryEntry</span><span class="s4">.</span><span class="s1">catchEntry</span><span class="s4">;</span>
      <span class="s2">let </span><span class="s1">fe </span><span class="s4">= </span><span class="s1">tryEntry</span><span class="s4">.</span><span class="s1">finallyEntry</span><span class="s4">;</span>

      <span class="s2">let </span><span class="s1">locs </span><span class="s4">= [</span>
        <span class="s1">tryEntry</span><span class="s4">.</span><span class="s1">firstLoc</span><span class="s4">,</span>
        <span class="s5">// The null here makes a hole in the array.</span>
        <span class="s1">ce </span><span class="s4">? </span><span class="s1">ce</span><span class="s4">.</span><span class="s1">firstLoc </span><span class="s4">: </span><span class="s2">null</span>
      <span class="s4">];</span>

      <span class="s2">if </span><span class="s4">(</span><span class="s1">fe</span><span class="s4">) {</span>
        <span class="s1">locs</span><span class="s4">[</span><span class="s6">2</span><span class="s4">] = </span><span class="s1">fe</span><span class="s4">.</span><span class="s1">firstLoc</span><span class="s4">;</span>
        <span class="s1">locs</span><span class="s4">[</span><span class="s6">3</span><span class="s4">] = </span><span class="s1">fe</span><span class="s4">.</span><span class="s1">afterLoc</span><span class="s4">;</span>
      <span class="s4">}</span>

      <span class="s2">return </span><span class="s1">t</span><span class="s4">.</span><span class="s1">arrayExpression</span><span class="s4">(</span><span class="s1">locs</span><span class="s4">.</span><span class="s1">map</span><span class="s4">(</span><span class="s1">loc </span><span class="s4">=&gt; </span><span class="s1">loc </span><span class="s4">&amp;&amp; </span><span class="s1">t</span><span class="s4">.</span><span class="s1">clone</span><span class="s4">(</span><span class="s1">loc</span><span class="s4">)));</span>
    <span class="s4">})</span>
  <span class="s4">);</span>
<span class="s4">};</span>

<span class="s5">// All side effects must be realized in order.</span>

<span class="s5">// If any subexpression harbors a leap, all subexpressions must be</span>
<span class="s5">// neutered of side effects.</span>

<span class="s5">// No destructive modification of AST nodes.</span>

<span class="s1">Ep</span><span class="s4">.</span><span class="s1">explode </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">path</span><span class="s4">, </span><span class="s1">ignoreResult</span><span class="s4">) {</span>
  <span class="s2">const </span><span class="s1">t </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">();</span>
  <span class="s2">let </span><span class="s1">node </span><span class="s4">= </span><span class="s1">path</span><span class="s4">.</span><span class="s1">node</span><span class="s4">;</span>
  <span class="s2">let </span><span class="s1">self </span><span class="s4">= </span><span class="s2">this</span><span class="s4">;</span>

  <span class="s1">t</span><span class="s4">.</span><span class="s1">assertNode</span><span class="s4">(</span><span class="s1">node</span><span class="s4">);</span>

  <span class="s2">if </span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">isDeclaration</span><span class="s4">(</span><span class="s1">node</span><span class="s4">))</span>
    <span class="s2">throw </span><span class="s1">getDeclError</span><span class="s4">(</span><span class="s1">node</span><span class="s4">);</span>

  <span class="s2">if </span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">isStatement</span><span class="s4">(</span><span class="s1">node</span><span class="s4">))</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeStatement</span><span class="s4">(</span><span class="s1">path</span><span class="s4">);</span>

  <span class="s2">if </span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">isExpression</span><span class="s4">(</span><span class="s1">node</span><span class="s4">))</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">, </span><span class="s1">ignoreResult</span><span class="s4">);</span>

  <span class="s2">switch </span><span class="s4">(</span><span class="s1">node</span><span class="s4">.</span><span class="s1">type</span><span class="s4">) {</span>
  <span class="s2">case </span><span class="s3">&quot;Program&quot;</span><span class="s4">:</span>
    <span class="s2">return </span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;body&quot;</span><span class="s4">).</span><span class="s1">map</span><span class="s4">(</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeStatement</span><span class="s4">,</span>
      <span class="s1">self</span>
    <span class="s4">);</span>

  <span class="s2">case </span><span class="s3">&quot;VariableDeclarator&quot;</span><span class="s4">:</span>
    <span class="s2">throw </span><span class="s1">getDeclError</span><span class="s4">(</span><span class="s1">node</span><span class="s4">);</span>

  <span class="s5">// These node types should be handled by their parent nodes</span>
  <span class="s5">// (ObjectExpression, SwitchStatement, and TryStatement, respectively).</span>
  <span class="s2">case </span><span class="s3">&quot;Property&quot;</span><span class="s4">:</span>
  <span class="s2">case </span><span class="s3">&quot;SwitchCase&quot;</span><span class="s4">:</span>
  <span class="s2">case </span><span class="s3">&quot;CatchClause&quot;</span><span class="s4">:</span>
    <span class="s2">throw new </span><span class="s1">Error</span><span class="s4">(</span>
      <span class="s1">node</span><span class="s4">.</span><span class="s1">type </span><span class="s4">+ </span><span class="s3">&quot; nodes should be handled by their parents&quot;</span><span class="s4">);</span>

  <span class="s2">default</span><span class="s4">:</span>
    <span class="s2">throw new </span><span class="s1">Error</span><span class="s4">(</span>
      <span class="s3">&quot;unknown Node of type &quot; </span><span class="s4">+</span>
        <span class="s1">JSON</span><span class="s4">.</span><span class="s1">stringify</span><span class="s4">(</span><span class="s1">node</span><span class="s4">.</span><span class="s1">type</span><span class="s4">));</span>
  <span class="s4">}</span>
<span class="s4">};</span>

<span class="s2">function </span><span class="s1">getDeclError</span><span class="s4">(</span><span class="s1">node</span><span class="s4">) {</span>
  <span class="s2">return new </span><span class="s1">Error</span><span class="s4">(</span>
    <span class="s3">&quot;all declarations should have been transformed into &quot; </span><span class="s4">+</span>
    <span class="s3">&quot;assignments before the Exploder began its work: &quot; </span><span class="s4">+</span>
    <span class="s1">JSON</span><span class="s4">.</span><span class="s1">stringify</span><span class="s4">(</span><span class="s1">node</span><span class="s4">));</span>
<span class="s4">}</span>

<span class="s1">Ep</span><span class="s4">.</span><span class="s1">explodeStatement </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">path</span><span class="s4">, </span><span class="s1">labelId</span><span class="s4">) {</span>
  <span class="s2">const </span><span class="s1">t </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">();</span>
  <span class="s2">let </span><span class="s1">stmt </span><span class="s4">= </span><span class="s1">path</span><span class="s4">.</span><span class="s1">node</span><span class="s4">;</span>
  <span class="s2">let </span><span class="s1">self </span><span class="s4">= </span><span class="s2">this</span><span class="s4">;</span>
  <span class="s2">let </span><span class="s1">before</span><span class="s4">, </span><span class="s1">after</span><span class="s4">, </span><span class="s1">head</span><span class="s4">;</span>

  <span class="s1">t</span><span class="s4">.</span><span class="s1">assertStatement</span><span class="s4">(</span><span class="s1">stmt</span><span class="s4">);</span>

  <span class="s2">if </span><span class="s4">(</span><span class="s1">labelId</span><span class="s4">) {</span>
    <span class="s1">t</span><span class="s4">.</span><span class="s1">assertIdentifier</span><span class="s4">(</span><span class="s1">labelId</span><span class="s4">);</span>
  <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
    <span class="s1">labelId </span><span class="s4">= </span><span class="s2">null</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s5">// Explode BlockStatement nodes even if they do not contain a yield,</span>
  <span class="s5">// because we don't want or need the curly braces.</span>
  <span class="s2">if </span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">isBlockStatement</span><span class="s4">(</span><span class="s1">stmt</span><span class="s4">)) {</span>
    <span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;body&quot;</span><span class="s4">).</span><span class="s1">forEach</span><span class="s4">(</span><span class="s2">function </span><span class="s4">(</span><span class="s1">path</span><span class="s4">) {</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeStatement</span><span class="s4">(</span><span class="s1">path</span><span class="s4">);</span>
    <span class="s4">});</span>
    <span class="s2">return</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s2">if </span><span class="s4">(!</span><span class="s1">meta</span><span class="s4">.</span><span class="s1">containsLeap</span><span class="s4">(</span><span class="s1">stmt</span><span class="s4">)) {</span>
    <span class="s5">// Technically we should be able to avoid emitting the statement</span>
    <span class="s5">// altogether if !meta.hasSideEffects(stmt), but that leads to</span>
    <span class="s5">// confusing generated code (for instance, `while (true) {}` just</span>
    <span class="s5">// disappears) and is probably a more appropriate job for a dedicated</span>
    <span class="s5">// dead code elimination pass.</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">emit</span><span class="s4">(</span><span class="s1">stmt</span><span class="s4">);</span>
    <span class="s2">return</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s2">switch </span><span class="s4">(</span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">type</span><span class="s4">) {</span>
  <span class="s2">case </span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s4">:</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;expression&quot;</span><span class="s4">), </span><span class="s2">true</span><span class="s4">);</span>
    <span class="s2">break</span><span class="s4">;</span>

  <span class="s2">case </span><span class="s3">&quot;LabeledStatement&quot;</span><span class="s4">:</span>
    <span class="s1">after </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>

    <span class="s5">// Did you know you can break from any labeled block statement or</span>
    <span class="s5">// control structure? Well, you can! Note: when a labeled loop is</span>
    <span class="s5">// encountered, the leap.LabeledEntry created here will immediately</span>
    <span class="s5">// enclose a leap.LoopEntry on the leap manager's stack, and both</span>
    <span class="s5">// entries will have the same label. Though this works just fine, it</span>
    <span class="s5">// may seem a bit redundant. In theory, we could check here to</span>
    <span class="s5">// determine if stmt knows how to handle its own label; for example,</span>
    <span class="s5">// stmt happens to be a WhileStatement and so we know it's going to</span>
    <span class="s5">// establish its own LoopEntry when we explode it (below). Then this</span>
    <span class="s5">// LabeledEntry would be unnecessary. Alternatively, we might be</span>
    <span class="s5">// tempted not to pass stmt.label down into self.explodeStatement,</span>
    <span class="s5">// because we've handled the label here, but that's a mistake because</span>
    <span class="s5">// labeled loops may contain labeled continue statements, which is not</span>
    <span class="s5">// something we can handle in this generic case. All in all, I think a</span>
    <span class="s5">// little redundancy greatly simplifies the logic of this case, since</span>
    <span class="s5">// it's clear that we handle all possible LabeledStatements correctly</span>
    <span class="s5">// here, regardless of whether they interact with the leap manager</span>
    <span class="s5">// themselves. Also remember that labels and break/continue-to-label</span>
    <span class="s5">// statements are rare, and all of this logic happens at transform</span>
    <span class="s5">// time, so it has no additional runtime cost.</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">leapManager</span><span class="s4">.</span><span class="s1">withEntry</span><span class="s4">(</span>
      <span class="s2">new </span><span class="s1">leap</span><span class="s4">.</span><span class="s1">LabeledEntry</span><span class="s4">(</span><span class="s1">after</span><span class="s4">, </span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">label</span><span class="s4">),</span>
      <span class="s2">function</span><span class="s4">() {</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeStatement</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;body&quot;</span><span class="s4">), </span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">label</span><span class="s4">);</span>
      <span class="s4">}</span>
    <span class="s4">);</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">after</span><span class="s4">);</span>

    <span class="s2">break</span><span class="s4">;</span>

  <span class="s2">case </span><span class="s3">&quot;WhileStatement&quot;</span><span class="s4">:</span>
    <span class="s1">before </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>
    <span class="s1">after </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">before</span><span class="s4">);</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">jumpIfNot</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;test&quot;</span><span class="s4">)), </span><span class="s1">after</span><span class="s4">);</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">leapManager</span><span class="s4">.</span><span class="s1">withEntry</span><span class="s4">(</span>
      <span class="s2">new </span><span class="s1">leap</span><span class="s4">.</span><span class="s1">LoopEntry</span><span class="s4">(</span><span class="s1">after</span><span class="s4">, </span><span class="s1">before</span><span class="s4">, </span><span class="s1">labelId</span><span class="s4">),</span>
      <span class="s2">function</span><span class="s4">() { </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeStatement</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;body&quot;</span><span class="s4">)); }</span>
    <span class="s4">);</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">jump</span><span class="s4">(</span><span class="s1">before</span><span class="s4">);</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">after</span><span class="s4">);</span>

    <span class="s2">break</span><span class="s4">;</span>

  <span class="s2">case </span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s4">:</span>
    <span class="s2">let </span><span class="s1">first </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>
    <span class="s2">let </span><span class="s1">test </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>
    <span class="s1">after </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">first</span><span class="s4">);</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">leapManager</span><span class="s4">.</span><span class="s1">withEntry</span><span class="s4">(</span>
      <span class="s2">new </span><span class="s1">leap</span><span class="s4">.</span><span class="s1">LoopEntry</span><span class="s4">(</span><span class="s1">after</span><span class="s4">, </span><span class="s1">test</span><span class="s4">, </span><span class="s1">labelId</span><span class="s4">),</span>
      <span class="s2">function</span><span class="s4">() { </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explode</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;body&quot;</span><span class="s4">)); }</span>
    <span class="s4">);</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">test</span><span class="s4">);</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">jumpIf</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;test&quot;</span><span class="s4">)), </span><span class="s1">first</span><span class="s4">);</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">after</span><span class="s4">);</span>

    <span class="s2">break</span><span class="s4">;</span>

  <span class="s2">case </span><span class="s3">&quot;ForStatement&quot;</span><span class="s4">:</span>
    <span class="s1">head </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>
    <span class="s2">let </span><span class="s1">update </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>
    <span class="s1">after </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>

    <span class="s2">if </span><span class="s4">(</span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">init</span><span class="s4">) {</span>
      <span class="s5">// We pass true here to indicate that if stmt.init is an expression</span>
      <span class="s5">// then we do not care about its result.</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">explode</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;init&quot;</span><span class="s4">), </span><span class="s2">true</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">head</span><span class="s4">);</span>

    <span class="s2">if </span><span class="s4">(</span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">test</span><span class="s4">) {</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">jumpIfNot</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;test&quot;</span><span class="s4">)), </span><span class="s1">after</span><span class="s4">);</span>
    <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
      <span class="s5">// No test means continue unconditionally.</span>
    <span class="s4">}</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">leapManager</span><span class="s4">.</span><span class="s1">withEntry</span><span class="s4">(</span>
      <span class="s2">new </span><span class="s1">leap</span><span class="s4">.</span><span class="s1">LoopEntry</span><span class="s4">(</span><span class="s1">after</span><span class="s4">, </span><span class="s1">update</span><span class="s4">, </span><span class="s1">labelId</span><span class="s4">),</span>
      <span class="s2">function</span><span class="s4">() { </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeStatement</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;body&quot;</span><span class="s4">)); }</span>
    <span class="s4">);</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">update</span><span class="s4">);</span>

    <span class="s2">if </span><span class="s4">(</span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">update</span><span class="s4">) {</span>
      <span class="s5">// We pass true here to indicate that if stmt.update is an</span>
      <span class="s5">// expression then we do not care about its result.</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">explode</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;update&quot;</span><span class="s4">), </span><span class="s2">true</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">jump</span><span class="s4">(</span><span class="s1">head</span><span class="s4">);</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">after</span><span class="s4">);</span>

    <span class="s2">break</span><span class="s4">;</span>

  <span class="s2">case </span><span class="s3">&quot;TypeCastExpression&quot;</span><span class="s4">:</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;expression&quot;</span><span class="s4">));</span>

  <span class="s2">case </span><span class="s3">&quot;ForInStatement&quot;</span><span class="s4">:</span>
    <span class="s1">head </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>
    <span class="s1">after </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>

    <span class="s2">let </span><span class="s1">keyIterNextFn </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">makeTempVar</span><span class="s4">();</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">emitAssign</span><span class="s4">(</span>
      <span class="s1">keyIterNextFn</span><span class="s4">,</span>
      <span class="s1">t</span><span class="s4">.</span><span class="s1">callExpression</span><span class="s4">(</span>
        <span class="s1">util</span><span class="s4">.</span><span class="s1">runtimeProperty</span><span class="s4">(</span><span class="s3">&quot;keys&quot;</span><span class="s4">),</span>
        <span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;right&quot;</span><span class="s4">))]</span>
      <span class="s4">)</span>
    <span class="s4">);</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">head</span><span class="s4">);</span>

    <span class="s2">let </span><span class="s1">keyInfoTmpVar </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">makeTempVar</span><span class="s4">();</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">jumpIf</span><span class="s4">(</span>
      <span class="s1">t</span><span class="s4">.</span><span class="s1">memberExpression</span><span class="s4">(</span>
        <span class="s1">t</span><span class="s4">.</span><span class="s1">assignmentExpression</span><span class="s4">(</span>
          <span class="s3">&quot;=&quot;</span><span class="s4">,</span>
          <span class="s1">keyInfoTmpVar</span><span class="s4">,</span>
          <span class="s1">t</span><span class="s4">.</span><span class="s1">callExpression</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">cloneDeep</span><span class="s4">(</span><span class="s1">keyIterNextFn</span><span class="s4">), [])</span>
        <span class="s4">),</span>
        <span class="s1">t</span><span class="s4">.</span><span class="s1">identifier</span><span class="s4">(</span><span class="s3">&quot;done&quot;</span><span class="s4">),</span>
        <span class="s2">false</span>
      <span class="s4">),</span>
      <span class="s1">after</span>
    <span class="s4">);</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">emitAssign</span><span class="s4">(</span>
      <span class="s1">stmt</span><span class="s4">.</span><span class="s1">left</span><span class="s4">,</span>
      <span class="s1">t</span><span class="s4">.</span><span class="s1">memberExpression</span><span class="s4">(</span>
        <span class="s1">t</span><span class="s4">.</span><span class="s1">cloneDeep</span><span class="s4">(</span><span class="s1">keyInfoTmpVar</span><span class="s4">),</span>
        <span class="s1">t</span><span class="s4">.</span><span class="s1">identifier</span><span class="s4">(</span><span class="s3">&quot;value&quot;</span><span class="s4">),</span>
        <span class="s2">false</span>
      <span class="s4">)</span>
    <span class="s4">);</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">leapManager</span><span class="s4">.</span><span class="s1">withEntry</span><span class="s4">(</span>
      <span class="s2">new </span><span class="s1">leap</span><span class="s4">.</span><span class="s1">LoopEntry</span><span class="s4">(</span><span class="s1">after</span><span class="s4">, </span><span class="s1">head</span><span class="s4">, </span><span class="s1">labelId</span><span class="s4">),</span>
      <span class="s2">function</span><span class="s4">() { </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeStatement</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;body&quot;</span><span class="s4">)); }</span>
    <span class="s4">);</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">jump</span><span class="s4">(</span><span class="s1">head</span><span class="s4">);</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">after</span><span class="s4">);</span>

    <span class="s2">break</span><span class="s4">;</span>

  <span class="s2">case </span><span class="s3">&quot;BreakStatement&quot;</span><span class="s4">:</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">emitAbruptCompletion</span><span class="s4">({</span>
      <span class="s1">type</span><span class="s4">: </span><span class="s3">&quot;break&quot;</span><span class="s4">,</span>
      <span class="s1">target</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">leapManager</span><span class="s4">.</span><span class="s1">getBreakLoc</span><span class="s4">(</span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">label</span><span class="s4">)</span>
    <span class="s4">});</span>

    <span class="s2">break</span><span class="s4">;</span>

  <span class="s2">case </span><span class="s3">&quot;ContinueStatement&quot;</span><span class="s4">:</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">emitAbruptCompletion</span><span class="s4">({</span>
      <span class="s1">type</span><span class="s4">: </span><span class="s3">&quot;continue&quot;</span><span class="s4">,</span>
      <span class="s1">target</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">leapManager</span><span class="s4">.</span><span class="s1">getContinueLoc</span><span class="s4">(</span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">label</span><span class="s4">)</span>
    <span class="s4">});</span>

    <span class="s2">break</span><span class="s4">;</span>

  <span class="s2">case </span><span class="s3">&quot;SwitchStatement&quot;</span><span class="s4">:</span>
    <span class="s5">// Always save the discriminant into a temporary variable in case the</span>
    <span class="s5">// test expressions overwrite values like context.sent.</span>
    <span class="s2">let </span><span class="s1">disc </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">emitAssign</span><span class="s4">(</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">makeTempVar</span><span class="s4">(),</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;discriminant&quot;</span><span class="s4">))</span>
    <span class="s4">);</span>

    <span class="s1">after </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>
    <span class="s2">let </span><span class="s1">defaultLoc </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>
    <span class="s2">let </span><span class="s1">condition </span><span class="s4">= </span><span class="s1">defaultLoc</span><span class="s4">;</span>
    <span class="s2">let </span><span class="s1">caseLocs </span><span class="s4">= [];</span>

    <span class="s5">// If there are no cases, .cases might be undefined.</span>
    <span class="s2">let </span><span class="s1">cases </span><span class="s4">= </span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">cases </span><span class="s4">|| [];</span>

    <span class="s2">for </span><span class="s4">(</span><span class="s2">let </span><span class="s1">i </span><span class="s4">= </span><span class="s1">cases</span><span class="s4">.</span><span class="s1">length </span><span class="s4">- </span><span class="s6">1</span><span class="s4">; </span><span class="s1">i </span><span class="s4">&gt;= </span><span class="s6">0</span><span class="s4">; --</span><span class="s1">i</span><span class="s4">) {</span>
      <span class="s2">let </span><span class="s1">c </span><span class="s4">= </span><span class="s1">cases</span><span class="s4">[</span><span class="s1">i</span><span class="s4">];</span>
      <span class="s1">t</span><span class="s4">.</span><span class="s1">assertSwitchCase</span><span class="s4">(</span><span class="s1">c</span><span class="s4">);</span>

      <span class="s2">if </span><span class="s4">(</span><span class="s1">c</span><span class="s4">.</span><span class="s1">test</span><span class="s4">) {</span>
        <span class="s1">condition </span><span class="s4">= </span><span class="s1">t</span><span class="s4">.</span><span class="s1">conditionalExpression</span><span class="s4">(</span>
          <span class="s1">t</span><span class="s4">.</span><span class="s1">binaryExpression</span><span class="s4">(</span><span class="s3">&quot;===&quot;</span><span class="s4">, </span><span class="s1">t</span><span class="s4">.</span><span class="s1">cloneDeep</span><span class="s4">(</span><span class="s1">disc</span><span class="s4">), </span><span class="s1">c</span><span class="s4">.</span><span class="s1">test</span><span class="s4">),</span>
          <span class="s1">caseLocs</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">(),</span>
          <span class="s1">condition</span>
        <span class="s4">);</span>
      <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
        <span class="s1">caseLocs</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s1">defaultLoc</span><span class="s4">;</span>
      <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s2">let </span><span class="s1">discriminant </span><span class="s4">= </span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;discriminant&quot;</span><span class="s4">);</span>
    <span class="s1">util</span><span class="s4">.</span><span class="s1">replaceWithOrRemove</span><span class="s4">(</span><span class="s1">discriminant</span><span class="s4">, </span><span class="s1">condition</span><span class="s4">);</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">jump</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">discriminant</span><span class="s4">));</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">leapManager</span><span class="s4">.</span><span class="s1">withEntry</span><span class="s4">(</span>
      <span class="s2">new </span><span class="s1">leap</span><span class="s4">.</span><span class="s1">SwitchEntry</span><span class="s4">(</span><span class="s1">after</span><span class="s4">),</span>
      <span class="s2">function</span><span class="s4">() {</span>
        <span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;cases&quot;</span><span class="s4">).</span><span class="s1">forEach</span><span class="s4">(</span><span class="s2">function</span><span class="s4">(</span><span class="s1">casePath</span><span class="s4">) {</span>
          <span class="s2">let </span><span class="s1">i </span><span class="s4">= </span><span class="s1">casePath</span><span class="s4">.</span><span class="s1">key</span><span class="s4">;</span>
          <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">caseLocs</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]);</span>

          <span class="s1">casePath</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;consequent&quot;</span><span class="s4">).</span><span class="s1">forEach</span><span class="s4">(</span><span class="s2">function </span><span class="s4">(</span><span class="s1">path</span><span class="s4">) {</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeStatement</span><span class="s4">(</span><span class="s1">path</span><span class="s4">);</span>
          <span class="s4">});</span>
        <span class="s4">});</span>
      <span class="s4">}</span>
    <span class="s4">);</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">after</span><span class="s4">);</span>
    <span class="s2">if </span><span class="s4">(</span><span class="s1">defaultLoc</span><span class="s4">.</span><span class="s1">value </span><span class="s4">=== </span><span class="s1">PENDING_LOCATION</span><span class="s4">) {</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">defaultLoc</span><span class="s4">);</span>
      <span class="s1">assert</span><span class="s4">.</span><span class="s1">strictEqual</span><span class="s4">(</span><span class="s1">after</span><span class="s4">.</span><span class="s1">value</span><span class="s4">, </span><span class="s1">defaultLoc</span><span class="s4">.</span><span class="s1">value</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s2">break</span><span class="s4">;</span>

  <span class="s2">case </span><span class="s3">&quot;IfStatement&quot;</span><span class="s4">:</span>
    <span class="s2">let </span><span class="s1">elseLoc </span><span class="s4">= </span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">alternate </span><span class="s4">&amp;&amp; </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>
    <span class="s1">after </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">jumpIfNot</span><span class="s4">(</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;test&quot;</span><span class="s4">)),</span>
      <span class="s1">elseLoc </span><span class="s4">|| </span><span class="s1">after</span>
    <span class="s4">);</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeStatement</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;consequent&quot;</span><span class="s4">));</span>

    <span class="s2">if </span><span class="s4">(</span><span class="s1">elseLoc</span><span class="s4">) {</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">jump</span><span class="s4">(</span><span class="s1">after</span><span class="s4">);</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">elseLoc</span><span class="s4">);</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeStatement</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;alternate&quot;</span><span class="s4">));</span>
    <span class="s4">}</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">after</span><span class="s4">);</span>

    <span class="s2">break</span><span class="s4">;</span>

  <span class="s2">case </span><span class="s3">&quot;ReturnStatement&quot;</span><span class="s4">:</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">emitAbruptCompletion</span><span class="s4">({</span>
      <span class="s1">type</span><span class="s4">: </span><span class="s3">&quot;return&quot;</span><span class="s4">,</span>
      <span class="s1">value</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;argument&quot;</span><span class="s4">))</span>
    <span class="s4">});</span>

    <span class="s2">break</span><span class="s4">;</span>

  <span class="s2">case </span><span class="s3">&quot;WithStatement&quot;</span><span class="s4">:</span>
    <span class="s2">throw new </span><span class="s1">Error</span><span class="s4">(</span><span class="s3">&quot;WithStatement not supported in generator functions.&quot;</span><span class="s4">);</span>

  <span class="s2">case </span><span class="s3">&quot;TryStatement&quot;</span><span class="s4">:</span>
    <span class="s1">after </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>

    <span class="s2">let </span><span class="s1">handler </span><span class="s4">= </span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">handler</span><span class="s4">;</span>

    <span class="s2">let </span><span class="s1">catchLoc </span><span class="s4">= </span><span class="s1">handler </span><span class="s4">&amp;&amp; </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>
    <span class="s2">let </span><span class="s1">catchEntry </span><span class="s4">= </span><span class="s1">catchLoc </span><span class="s4">&amp;&amp; </span><span class="s2">new </span><span class="s1">leap</span><span class="s4">.</span><span class="s1">CatchEntry</span><span class="s4">(</span>
      <span class="s1">catchLoc</span><span class="s4">,</span>
      <span class="s1">handler</span><span class="s4">.</span><span class="s1">param</span>
    <span class="s4">);</span>

    <span class="s2">let </span><span class="s1">finallyLoc </span><span class="s4">= </span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">finalizer </span><span class="s4">&amp;&amp; </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>
    <span class="s2">let </span><span class="s1">finallyEntry </span><span class="s4">= </span><span class="s1">finallyLoc </span><span class="s4">&amp;&amp;</span>
      <span class="s2">new </span><span class="s1">leap</span><span class="s4">.</span><span class="s1">FinallyEntry</span><span class="s4">(</span><span class="s1">finallyLoc</span><span class="s4">, </span><span class="s1">after</span><span class="s4">);</span>

    <span class="s2">let </span><span class="s1">tryEntry </span><span class="s4">= </span><span class="s2">new </span><span class="s1">leap</span><span class="s4">.</span><span class="s1">TryEntry</span><span class="s4">(</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">getUnmarkedCurrentLoc</span><span class="s4">(),</span>
      <span class="s1">catchEntry</span><span class="s4">,</span>
      <span class="s1">finallyEntry</span>
    <span class="s4">);</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">tryEntries</span><span class="s4">.</span><span class="s1">push</span><span class="s4">(</span><span class="s1">tryEntry</span><span class="s4">);</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">updateContextPrevLoc</span><span class="s4">(</span><span class="s1">tryEntry</span><span class="s4">.</span><span class="s1">firstLoc</span><span class="s4">);</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">leapManager</span><span class="s4">.</span><span class="s1">withEntry</span><span class="s4">(</span><span class="s1">tryEntry</span><span class="s4">, </span><span class="s2">function</span><span class="s4">() {</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeStatement</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;block&quot;</span><span class="s4">));</span>

      <span class="s2">if </span><span class="s4">(</span><span class="s1">catchLoc</span><span class="s4">) {</span>
        <span class="s2">if </span><span class="s4">(</span><span class="s1">finallyLoc</span><span class="s4">) {</span>
          <span class="s5">// If we have both a catch block and a finally block, then</span>
          <span class="s5">// because we emit the catch block first, we need to jump over</span>
          <span class="s5">// it to the finally block.</span>
          <span class="s1">self</span><span class="s4">.</span><span class="s1">jump</span><span class="s4">(</span><span class="s1">finallyLoc</span><span class="s4">);</span>

        <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
          <span class="s5">// If there is no finally block, then we need to jump over the</span>
          <span class="s5">// catch block to the fall-through location.</span>
          <span class="s1">self</span><span class="s4">.</span><span class="s1">jump</span><span class="s4">(</span><span class="s1">after</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">updateContextPrevLoc</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">catchLoc</span><span class="s4">));</span>

        <span class="s2">let </span><span class="s1">bodyPath </span><span class="s4">= </span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;handler.body&quot;</span><span class="s4">);</span>
        <span class="s2">let </span><span class="s1">safeParam </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">makeTempVar</span><span class="s4">();</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">clearPendingException</span><span class="s4">(</span><span class="s1">tryEntry</span><span class="s4">.</span><span class="s1">firstLoc</span><span class="s4">, </span><span class="s1">safeParam</span><span class="s4">);</span>

        <span class="s1">bodyPath</span><span class="s4">.</span><span class="s1">traverse</span><span class="s4">(</span><span class="s1">catchParamVisitor</span><span class="s4">, {</span>
          <span class="s1">getSafeParam</span><span class="s4">: () =&gt; </span><span class="s1">t</span><span class="s4">.</span><span class="s1">cloneDeep</span><span class="s4">(</span><span class="s1">safeParam</span><span class="s4">),</span>
          <span class="s1">catchParamName</span><span class="s4">: </span><span class="s1">handler</span><span class="s4">.</span><span class="s1">param</span><span class="s4">.</span><span class="s1">name</span>
        <span class="s4">});</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">leapManager</span><span class="s4">.</span><span class="s1">withEntry</span><span class="s4">(</span><span class="s1">catchEntry</span><span class="s4">, </span><span class="s2">function</span><span class="s4">() {</span>
          <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeStatement</span><span class="s4">(</span><span class="s1">bodyPath</span><span class="s4">);</span>
        <span class="s4">});</span>
      <span class="s4">}</span>

      <span class="s2">if </span><span class="s4">(</span><span class="s1">finallyLoc</span><span class="s4">) {</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">updateContextPrevLoc</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">finallyLoc</span><span class="s4">));</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">leapManager</span><span class="s4">.</span><span class="s1">withEntry</span><span class="s4">(</span><span class="s1">finallyEntry</span><span class="s4">, </span><span class="s2">function</span><span class="s4">() {</span>
          <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeStatement</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;finalizer&quot;</span><span class="s4">));</span>
        <span class="s4">});</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">emit</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">returnStatement</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">callExpression</span><span class="s4">(</span>
          <span class="s1">self</span><span class="s4">.</span><span class="s1">contextProperty</span><span class="s4">(</span><span class="s3">&quot;finish&quot;</span><span class="s4">),</span>
          <span class="s4">[</span><span class="s1">finallyEntry</span><span class="s4">.</span><span class="s1">firstLoc</span><span class="s4">]</span>
        <span class="s4">)));</span>
      <span class="s4">}</span>
    <span class="s4">});</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">after</span><span class="s4">);</span>

    <span class="s2">break</span><span class="s4">;</span>

  <span class="s2">case </span><span class="s3">&quot;ThrowStatement&quot;</span><span class="s4">:</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">emit</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">throwStatement</span><span class="s4">(</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;argument&quot;</span><span class="s4">))</span>
    <span class="s4">));</span>

    <span class="s2">break</span><span class="s4">;</span>

  <span class="s2">case </span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s4">:</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">emit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeClass</span><span class="s4">(</span><span class="s1">path</span><span class="s4">));</span>
    <span class="s2">break</span><span class="s4">;</span>

  <span class="s2">default</span><span class="s4">:</span>
    <span class="s2">throw new </span><span class="s1">Error</span><span class="s4">(</span>
      <span class="s3">&quot;unknown Statement of type &quot; </span><span class="s4">+</span>
        <span class="s1">JSON</span><span class="s4">.</span><span class="s1">stringify</span><span class="s4">(</span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">type</span><span class="s4">));</span>
  <span class="s4">}</span>
<span class="s4">};</span>

<span class="s2">let </span><span class="s1">catchParamVisitor </span><span class="s4">= {</span>
  <span class="s1">Identifier</span><span class="s4">: </span><span class="s2">function</span><span class="s4">(</span><span class="s1">path</span><span class="s4">, </span><span class="s1">state</span><span class="s4">) {</span>
    <span class="s2">if </span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">name </span><span class="s4">=== </span><span class="s1">state</span><span class="s4">.</span><span class="s1">catchParamName </span><span class="s4">&amp;&amp; </span><span class="s1">util</span><span class="s4">.</span><span class="s1">isReference</span><span class="s4">(</span><span class="s1">path</span><span class="s4">)) {</span>
      <span class="s1">util</span><span class="s4">.</span><span class="s1">replaceWithOrRemove</span><span class="s4">(</span><span class="s1">path</span><span class="s4">, </span><span class="s1">state</span><span class="s4">.</span><span class="s1">getSafeParam</span><span class="s4">());</span>
    <span class="s4">}</span>
  <span class="s4">},</span>

  <span class="s1">Scope</span><span class="s4">: </span><span class="s2">function</span><span class="s4">(</span><span class="s1">path</span><span class="s4">, </span><span class="s1">state</span><span class="s4">) {</span>
    <span class="s2">if </span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">scope</span><span class="s4">.</span><span class="s1">hasOwnBinding</span><span class="s4">(</span><span class="s1">state</span><span class="s4">.</span><span class="s1">catchParamName</span><span class="s4">)) {</span>
      <span class="s5">// Don't descend into nested scopes that shadow the catch</span>
      <span class="s5">// parameter with their own declarations.</span>
      <span class="s1">path</span><span class="s4">.</span><span class="s1">skip</span><span class="s4">();</span>
    <span class="s4">}</span>
  <span class="s4">}</span>
<span class="s4">};</span>

<span class="s1">Ep</span><span class="s4">.</span><span class="s1">emitAbruptCompletion </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">record</span><span class="s4">) {</span>
  <span class="s2">if </span><span class="s4">(!</span><span class="s1">isValidCompletion</span><span class="s4">(</span><span class="s1">record</span><span class="s4">)) {</span>
    <span class="s1">assert</span><span class="s4">.</span><span class="s1">ok</span><span class="s4">(</span>
      <span class="s2">false</span><span class="s4">,</span>
      <span class="s3">&quot;invalid completion record: &quot; </span><span class="s4">+</span>
        <span class="s1">JSON</span><span class="s4">.</span><span class="s1">stringify</span><span class="s4">(</span><span class="s1">record</span><span class="s4">)</span>
    <span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s1">assert</span><span class="s4">.</span><span class="s1">notStrictEqual</span><span class="s4">(</span>
    <span class="s1">record</span><span class="s4">.</span><span class="s1">type</span><span class="s4">, </span><span class="s3">&quot;normal&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;normal completions are not abrupt&quot;</span>
  <span class="s4">);</span>

  <span class="s2">const </span><span class="s1">t </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">();</span>
  <span class="s2">let </span><span class="s1">abruptArgs </span><span class="s4">= [</span><span class="s1">t</span><span class="s4">.</span><span class="s1">stringLiteral</span><span class="s4">(</span><span class="s1">record</span><span class="s4">.</span><span class="s1">type</span><span class="s4">)];</span>

  <span class="s2">if </span><span class="s4">(</span><span class="s1">record</span><span class="s4">.</span><span class="s1">type </span><span class="s4">=== </span><span class="s3">&quot;break&quot; </span><span class="s4">||</span>
      <span class="s1">record</span><span class="s4">.</span><span class="s1">type </span><span class="s4">=== </span><span class="s3">&quot;continue&quot;</span><span class="s4">) {</span>
    <span class="s1">t</span><span class="s4">.</span><span class="s1">assertLiteral</span><span class="s4">(</span><span class="s1">record</span><span class="s4">.</span><span class="s1">target</span><span class="s4">);</span>
    <span class="s1">abruptArgs</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] = </span><span class="s2">this</span><span class="s4">.</span><span class="s1">insertedLocs</span><span class="s4">.</span><span class="s1">has</span><span class="s4">(</span><span class="s1">record</span><span class="s4">.</span><span class="s1">target</span><span class="s4">)</span>
      <span class="s4">? </span><span class="s1">record</span><span class="s4">.</span><span class="s1">target</span>
      <span class="s4">: </span><span class="s1">t</span><span class="s4">.</span><span class="s1">cloneDeep</span><span class="s4">(</span><span class="s1">record</span><span class="s4">.</span><span class="s1">target</span><span class="s4">);</span>
  <span class="s4">} </span><span class="s2">else if </span><span class="s4">(</span><span class="s1">record</span><span class="s4">.</span><span class="s1">type </span><span class="s4">=== </span><span class="s3">&quot;return&quot; </span><span class="s4">||</span>
             <span class="s1">record</span><span class="s4">.</span><span class="s1">type </span><span class="s4">=== </span><span class="s3">&quot;throw&quot;</span><span class="s4">) {</span>
    <span class="s2">if </span><span class="s4">(</span><span class="s1">record</span><span class="s4">.</span><span class="s1">value</span><span class="s4">) {</span>
      <span class="s1">t</span><span class="s4">.</span><span class="s1">assertExpression</span><span class="s4">(</span><span class="s1">record</span><span class="s4">.</span><span class="s1">value</span><span class="s4">);</span>
      <span class="s1">abruptArgs</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] = </span><span class="s2">this</span><span class="s4">.</span><span class="s1">insertedLocs</span><span class="s4">.</span><span class="s1">has</span><span class="s4">(</span><span class="s1">record</span><span class="s4">.</span><span class="s1">value</span><span class="s4">)</span>
        <span class="s4">? </span><span class="s1">record</span><span class="s4">.</span><span class="s1">value</span>
        <span class="s4">: </span><span class="s1">t</span><span class="s4">.</span><span class="s1">cloneDeep</span><span class="s4">(</span><span class="s1">record</span><span class="s4">.</span><span class="s1">value</span><span class="s4">);</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s2">this</span><span class="s4">.</span><span class="s1">emit</span><span class="s4">(</span>
    <span class="s1">t</span><span class="s4">.</span><span class="s1">returnStatement</span><span class="s4">(</span>
      <span class="s1">t</span><span class="s4">.</span><span class="s1">callExpression</span><span class="s4">(</span>
        <span class="s2">this</span><span class="s4">.</span><span class="s1">contextProperty</span><span class="s4">(</span><span class="s3">&quot;abrupt&quot;</span><span class="s4">),</span>
        <span class="s1">abruptArgs</span>
      <span class="s4">)</span>
    <span class="s4">)</span>
  <span class="s4">);</span>
<span class="s4">};</span>

<span class="s2">function </span><span class="s1">isValidCompletion</span><span class="s4">(</span><span class="s1">record</span><span class="s4">) {</span>
  <span class="s2">let </span><span class="s1">type </span><span class="s4">= </span><span class="s1">record</span><span class="s4">.</span><span class="s1">type</span><span class="s4">;</span>

  <span class="s2">if </span><span class="s4">(</span><span class="s1">type </span><span class="s4">=== </span><span class="s3">&quot;normal&quot;</span><span class="s4">) {</span>
    <span class="s2">return </span><span class="s4">!</span><span class="s1">hasOwn</span><span class="s4">.</span><span class="s1">call</span><span class="s4">(</span><span class="s1">record</span><span class="s4">, </span><span class="s3">&quot;target&quot;</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s2">if </span><span class="s4">(</span><span class="s1">type </span><span class="s4">=== </span><span class="s3">&quot;break&quot; </span><span class="s4">||</span>
      <span class="s1">type </span><span class="s4">=== </span><span class="s3">&quot;continue&quot;</span><span class="s4">) {</span>
    <span class="s2">return </span><span class="s4">!</span><span class="s1">hasOwn</span><span class="s4">.</span><span class="s1">call</span><span class="s4">(</span><span class="s1">record</span><span class="s4">, </span><span class="s3">&quot;value&quot;</span><span class="s4">)</span>
        <span class="s4">&amp;&amp; </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">().</span><span class="s1">isLiteral</span><span class="s4">(</span><span class="s1">record</span><span class="s4">.</span><span class="s1">target</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s2">if </span><span class="s4">(</span><span class="s1">type </span><span class="s4">=== </span><span class="s3">&quot;return&quot; </span><span class="s4">||</span>
      <span class="s1">type </span><span class="s4">=== </span><span class="s3">&quot;throw&quot;</span><span class="s4">) {</span>
    <span class="s2">return </span><span class="s1">hasOwn</span><span class="s4">.</span><span class="s1">call</span><span class="s4">(</span><span class="s1">record</span><span class="s4">, </span><span class="s3">&quot;value&quot;</span><span class="s4">)</span>
        <span class="s4">&amp;&amp; !</span><span class="s1">hasOwn</span><span class="s4">.</span><span class="s1">call</span><span class="s4">(</span><span class="s1">record</span><span class="s4">, </span><span class="s3">&quot;target&quot;</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s2">return false</span><span class="s4">;</span>
<span class="s4">}</span>


<span class="s5">// Not all offsets into emitter.listing are potential jump targets. For</span>
<span class="s5">// example, execution typically falls into the beginning of a try block</span>
<span class="s5">// without jumping directly there. This method returns the current offset</span>
<span class="s5">// without marking it, so that a switch case will not necessarily be</span>
<span class="s5">// generated for this offset (I say &quot;not necessarily&quot; because the same</span>
<span class="s5">// location might end up being marked in the process of emitting other</span>
<span class="s5">// statements). There's no logical harm in marking such locations as jump</span>
<span class="s5">// targets, but minimizing the number of switch cases keeps the generated</span>
<span class="s5">// code shorter.</span>
<span class="s1">Ep</span><span class="s4">.</span><span class="s1">getUnmarkedCurrentLoc </span><span class="s4">= </span><span class="s2">function</span><span class="s4">() {</span>
  <span class="s2">return </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">().</span><span class="s1">numericLiteral</span><span class="s4">(</span><span class="s2">this</span><span class="s4">.</span><span class="s1">listing</span><span class="s4">.</span><span class="s1">length</span><span class="s4">);</span>
<span class="s4">};</span>

<span class="s5">// The context.prev property takes the value of context.next whenever we</span>
<span class="s5">// evaluate the switch statement discriminant, which is generally good</span>
<span class="s5">// enough for tracking the last location we jumped to, but sometimes</span>
<span class="s5">// context.prev needs to be more precise, such as when we fall</span>
<span class="s5">// successfully out of a try block and into a finally block without</span>
<span class="s5">// jumping. This method exists to update context.prev to the freshest</span>
<span class="s5">// available location. If we were implementing a full interpreter, we</span>
<span class="s5">// would know the location of the current instruction with complete</span>
<span class="s5">// precision at all times, but we don't have that luxury here, as it would</span>
<span class="s5">// be costly and verbose to set context.prev before every statement.</span>
<span class="s1">Ep</span><span class="s4">.</span><span class="s1">updateContextPrevLoc </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">loc</span><span class="s4">) {</span>
  <span class="s2">const </span><span class="s1">t </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">();</span>
  <span class="s2">if </span><span class="s4">(</span><span class="s1">loc</span><span class="s4">) {</span>
    <span class="s1">t</span><span class="s4">.</span><span class="s1">assertLiteral</span><span class="s4">(</span><span class="s1">loc</span><span class="s4">);</span>

    <span class="s2">if </span><span class="s4">(</span><span class="s1">loc</span><span class="s4">.</span><span class="s1">value </span><span class="s4">=== </span><span class="s1">PENDING_LOCATION</span><span class="s4">) {</span>
      <span class="s5">// If an uninitialized location literal was passed in, set its value</span>
      <span class="s5">// to the current this.listing.length.</span>
      <span class="s1">loc</span><span class="s4">.</span><span class="s1">value </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">listing</span><span class="s4">.</span><span class="s1">length</span><span class="s4">;</span>
    <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
      <span class="s5">// Otherwise assert that the location matches the current offset.</span>
      <span class="s1">assert</span><span class="s4">.</span><span class="s1">strictEqual</span><span class="s4">(</span><span class="s1">loc</span><span class="s4">.</span><span class="s1">value</span><span class="s4">, </span><span class="s2">this</span><span class="s4">.</span><span class="s1">listing</span><span class="s4">.</span><span class="s1">length</span><span class="s4">);</span>
    <span class="s4">}</span>

  <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
    <span class="s1">loc </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">getUnmarkedCurrentLoc</span><span class="s4">();</span>
  <span class="s4">}</span>

  <span class="s5">// Make sure context.prev is up to date in case we fell into this try</span>
  <span class="s5">// statement without jumping to it. TODO Consider avoiding this</span>
  <span class="s5">// assignment when we know control must have jumped here.</span>
  <span class="s2">this</span><span class="s4">.</span><span class="s1">emitAssign</span><span class="s4">(</span><span class="s2">this</span><span class="s4">.</span><span class="s1">contextProperty</span><span class="s4">(</span><span class="s3">&quot;prev&quot;</span><span class="s4">), </span><span class="s1">loc</span><span class="s4">);</span>
<span class="s4">};</span>


<span class="s5">// In order to save the rest of explodeExpression from a combinatorial</span>
<span class="s5">// trainwreck of special cases, explodeViaTempVar is responsible for</span>
<span class="s5">// deciding when a subexpression needs to be &quot;exploded,&quot; which is my</span>
<span class="s5">// very technical term for emitting the subexpression as an assignment</span>
<span class="s5">// to a temporary variable and the substituting the temporary variable</span>
<span class="s5">// for the original subexpression. Think of exploded view diagrams, not</span>
<span class="s5">// Michael Bay movies. The point of exploding subexpressions is to</span>
<span class="s5">// control the precise order in which the generated code realizes the</span>
<span class="s5">// side effects of those subexpressions.</span>
<span class="s1">Ep</span><span class="s4">.</span><span class="s1">explodeViaTempVar </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">tempVar</span><span class="s4">, </span><span class="s1">childPath</span><span class="s4">, </span><span class="s1">hasLeapingChildren</span><span class="s4">, </span><span class="s1">ignoreChildResult</span><span class="s4">) {</span>
  <span class="s1">assert</span><span class="s4">.</span><span class="s1">ok</span><span class="s4">(</span>
    <span class="s4">!</span><span class="s1">ignoreChildResult </span><span class="s4">|| !</span><span class="s1">tempVar</span><span class="s4">,</span>
    <span class="s3">&quot;Ignoring the result of a child expression but forcing it to &quot; </span><span class="s4">+</span>
      <span class="s3">&quot;be assigned to a temporary variable?&quot;</span>
  <span class="s4">);</span>
  <span class="s2">const </span><span class="s1">t </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">();</span>

  <span class="s2">let </span><span class="s1">result </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">childPath</span><span class="s4">, </span><span class="s1">ignoreChildResult</span><span class="s4">);</span>

  <span class="s2">if </span><span class="s4">(</span><span class="s1">ignoreChildResult</span><span class="s4">) {</span>
    <span class="s5">// Side effects already emitted above.</span>

  <span class="s4">} </span><span class="s2">else if </span><span class="s4">(</span><span class="s1">tempVar </span><span class="s4">|| (</span><span class="s1">hasLeapingChildren </span><span class="s4">&amp;&amp;</span>
                          <span class="s4">!</span><span class="s1">t</span><span class="s4">.</span><span class="s1">isLiteral</span><span class="s4">(</span><span class="s1">result</span><span class="s4">))) {</span>
    <span class="s5">// If tempVar was provided, then the result will always be assigned</span>
    <span class="s5">// to it, even if the result does not otherwise need to be assigned</span>
    <span class="s5">// to a temporary variable.  When no tempVar is provided, we have</span>
    <span class="s5">// the flexibility to decide whether a temporary variable is really</span>
    <span class="s5">// necessary.  Unfortunately, in general, a temporary variable is</span>
    <span class="s5">// required whenever any child contains a yield expression, since it</span>
    <span class="s5">// is difficult to prove (at all, let alone efficiently) whether</span>
    <span class="s5">// this result would evaluate to the same value before and after the</span>
    <span class="s5">// yield (see #206).  One narrow case where we can prove it doesn't</span>
    <span class="s5">// matter (and thus we do not need a temporary variable) is when the</span>
    <span class="s5">// result in question is a Literal value.</span>
    <span class="s1">result </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">emitAssign</span><span class="s4">(</span>
      <span class="s1">tempVar </span><span class="s4">|| </span><span class="s2">this</span><span class="s4">.</span><span class="s1">makeTempVar</span><span class="s4">(),</span>
      <span class="s1">result</span>
    <span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s1">Ep</span><span class="s4">.</span><span class="s1">explodeExpression </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">path</span><span class="s4">, </span><span class="s1">ignoreResult</span><span class="s4">) {</span>
  <span class="s2">const </span><span class="s1">t </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">getTypes</span><span class="s4">();</span>
  <span class="s2">let </span><span class="s1">expr </span><span class="s4">= </span><span class="s1">path</span><span class="s4">.</span><span class="s1">node</span><span class="s4">;</span>
  <span class="s2">if </span><span class="s4">(</span><span class="s1">expr</span><span class="s4">) {</span>
    <span class="s1">t</span><span class="s4">.</span><span class="s1">assertExpression</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">);</span>
  <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
    <span class="s2">return </span><span class="s1">expr</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s2">let </span><span class="s1">self </span><span class="s4">= </span><span class="s2">this</span><span class="s4">;</span>
  <span class="s2">let </span><span class="s1">result</span><span class="s4">; </span><span class="s5">// Used optionally by several cases below.</span>
  <span class="s2">let </span><span class="s1">after</span><span class="s4">;</span>

  <span class="s2">function </span><span class="s1">finish</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">) {</span>
    <span class="s1">t</span><span class="s4">.</span><span class="s1">assertExpression</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">);</span>
    <span class="s2">if </span><span class="s4">(</span><span class="s1">ignoreResult</span><span class="s4">) {</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">emit</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">);</span>
    <span class="s4">}</span>
    <span class="s2">return </span><span class="s1">expr</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s5">// If the expression does not contain a leap, then we either emit the</span>
  <span class="s5">// expression as a standalone statement or return it whole.</span>
  <span class="s2">if </span><span class="s4">(!</span><span class="s1">meta</span><span class="s4">.</span><span class="s1">containsLeap</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">)) {</span>
    <span class="s2">return </span><span class="s1">finish</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s5">// If any child contains a leap (such as a yield or labeled continue or</span>
  <span class="s5">// break statement), then any sibling subexpressions will almost</span>
  <span class="s5">// certainly have to be exploded in order to maintain the order of their</span>
  <span class="s5">// side effects relative to the leaping child(ren).</span>
  <span class="s2">let </span><span class="s1">hasLeapingChildren </span><span class="s4">= </span><span class="s1">meta</span><span class="s4">.</span><span class="s1">containsLeap</span><span class="s4">.</span><span class="s1">onlyChildren</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">);</span>

  <span class="s5">// If ignoreResult is true, then we must take full responsibility for</span>
  <span class="s5">// emitting the expression with all its side effects, and we should not</span>
  <span class="s5">// return a result.</span>

  <span class="s2">switch </span><span class="s4">(</span><span class="s1">expr</span><span class="s4">.</span><span class="s1">type</span><span class="s4">) {</span>
  <span class="s2">case </span><span class="s3">&quot;MemberExpression&quot;</span><span class="s4">:</span>
    <span class="s2">return </span><span class="s1">finish</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">memberExpression</span><span class="s4">(</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;object&quot;</span><span class="s4">)),</span>
      <span class="s1">expr</span><span class="s4">.</span><span class="s1">computed</span>
        <span class="s4">? </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeViaTempVar</span><span class="s4">(</span><span class="s2">null</span><span class="s4">, </span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;property&quot;</span><span class="s4">), </span><span class="s1">hasLeapingChildren</span><span class="s4">)</span>
        <span class="s4">: </span><span class="s1">expr</span><span class="s4">.</span><span class="s1">property</span><span class="s4">,</span>
      <span class="s1">expr</span><span class="s4">.</span><span class="s1">computed</span>
    <span class="s4">));</span>

  <span class="s2">case </span><span class="s3">&quot;CallExpression&quot;</span><span class="s4">:</span>
    <span class="s2">let </span><span class="s1">calleePath </span><span class="s4">= </span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;callee&quot;</span><span class="s4">);</span>
    <span class="s2">let </span><span class="s1">argsPath </span><span class="s4">= </span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;arguments&quot;</span><span class="s4">);</span>

    <span class="s2">let </span><span class="s1">newCallee</span><span class="s4">;</span>
    <span class="s2">let </span><span class="s1">newArgs</span><span class="s4">;</span>

    <span class="s2">let </span><span class="s1">hasLeapingArgs </span><span class="s4">= </span><span class="s1">argsPath</span><span class="s4">.</span><span class="s1">some</span><span class="s4">(</span>
      <span class="s1">argPath </span><span class="s4">=&gt; </span><span class="s1">meta</span><span class="s4">.</span><span class="s1">containsLeap</span><span class="s4">(</span><span class="s1">argPath</span><span class="s4">.</span><span class="s1">node</span><span class="s4">)</span>
    <span class="s4">);</span>

    <span class="s2">let </span><span class="s1">injectFirstArg </span><span class="s4">= </span><span class="s2">null</span><span class="s4">;</span>

    <span class="s2">if </span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">isMemberExpression</span><span class="s4">(</span><span class="s1">calleePath</span><span class="s4">.</span><span class="s1">node</span><span class="s4">)) {</span>
      <span class="s2">if </span><span class="s4">(</span><span class="s1">hasLeapingArgs</span><span class="s4">) {</span>
        <span class="s5">// If the arguments of the CallExpression contained any yield</span>
        <span class="s5">// expressions, then we need to be sure to evaluate the callee</span>
        <span class="s5">// before evaluating the arguments, but if the callee was a member</span>
        <span class="s5">// expression, then we must be careful that the object of the</span>
        <span class="s5">// member expression still gets bound to `this` for the call.</span>

        <span class="s2">let </span><span class="s1">newObject </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeViaTempVar</span><span class="s4">(</span>
          <span class="s5">// Assign the exploded callee.object expression to a temporary</span>
          <span class="s5">// variable so that we can use it twice without reevaluating it.</span>
          <span class="s1">self</span><span class="s4">.</span><span class="s1">makeTempVar</span><span class="s4">(),</span>
          <span class="s1">calleePath</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;object&quot;</span><span class="s4">),</span>
          <span class="s1">hasLeapingChildren</span>
        <span class="s4">);</span>

        <span class="s2">let </span><span class="s1">newProperty </span><span class="s4">= </span><span class="s1">calleePath</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">computed</span>
          <span class="s4">? </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeViaTempVar</span><span class="s4">(</span><span class="s2">null</span><span class="s4">, </span><span class="s1">calleePath</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;property&quot;</span><span class="s4">), </span><span class="s1">hasLeapingChildren</span><span class="s4">)</span>
          <span class="s4">: </span><span class="s1">calleePath</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">property</span><span class="s4">;</span>

        <span class="s1">injectFirstArg </span><span class="s4">= </span><span class="s1">newObject</span><span class="s4">;</span>

        <span class="s1">newCallee </span><span class="s4">= </span><span class="s1">t</span><span class="s4">.</span><span class="s1">memberExpression</span><span class="s4">(</span>
          <span class="s1">t</span><span class="s4">.</span><span class="s1">memberExpression</span><span class="s4">(</span>
            <span class="s1">t</span><span class="s4">.</span><span class="s1">cloneDeep</span><span class="s4">(</span><span class="s1">newObject</span><span class="s4">),</span>
            <span class="s1">newProperty</span><span class="s4">,</span>
            <span class="s1">calleePath</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">computed</span>
          <span class="s4">),</span>
          <span class="s1">t</span><span class="s4">.</span><span class="s1">identifier</span><span class="s4">(</span><span class="s3">&quot;call&quot;</span><span class="s4">),</span>
          <span class="s2">false</span>
        <span class="s4">);</span>

      <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
        <span class="s1">newCallee </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">calleePath</span><span class="s4">);</span>
      <span class="s4">}</span>

    <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
      <span class="s1">newCallee </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeViaTempVar</span><span class="s4">(</span><span class="s2">null</span><span class="s4">, </span><span class="s1">calleePath</span><span class="s4">, </span><span class="s1">hasLeapingChildren</span><span class="s4">);</span>

      <span class="s2">if </span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">isMemberExpression</span><span class="s4">(</span><span class="s1">newCallee</span><span class="s4">)) {</span>
        <span class="s5">// If the callee was not previously a MemberExpression, then the</span>
        <span class="s5">// CallExpression was &quot;unqualified,&quot; meaning its `this` object</span>
        <span class="s5">// should be the global object. If the exploded expression has</span>
        <span class="s5">// become a MemberExpression (e.g. a context property, probably a</span>
        <span class="s5">// temporary variable), then we need to force it to be unqualified</span>
        <span class="s5">// by using the (0, object.property)(...) trick; otherwise, it</span>
        <span class="s5">// will receive the object of the MemberExpression as its `this`</span>
        <span class="s5">// object.</span>
        <span class="s1">newCallee </span><span class="s4">= </span><span class="s1">t</span><span class="s4">.</span><span class="s1">sequenceExpression</span><span class="s4">([</span>
          <span class="s1">t</span><span class="s4">.</span><span class="s1">numericLiteral</span><span class="s4">(</span><span class="s6">0</span><span class="s4">),</span>
          <span class="s1">t</span><span class="s4">.</span><span class="s1">cloneDeep</span><span class="s4">(</span><span class="s1">newCallee</span><span class="s4">)</span>
        <span class="s4">]);</span>
      <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s2">if </span><span class="s4">(</span><span class="s1">hasLeapingArgs</span><span class="s4">) {</span>
      <span class="s1">newArgs </span><span class="s4">= </span><span class="s1">argsPath</span><span class="s4">.</span><span class="s1">map</span><span class="s4">(</span><span class="s1">argPath </span><span class="s4">=&gt; </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeViaTempVar</span><span class="s4">(</span><span class="s2">null</span><span class="s4">, </span><span class="s1">argPath</span><span class="s4">, </span><span class="s1">hasLeapingChildren</span><span class="s4">));</span>
      <span class="s2">if </span><span class="s4">(</span><span class="s1">injectFirstArg</span><span class="s4">) </span><span class="s1">newArgs</span><span class="s4">.</span><span class="s1">unshift</span><span class="s4">(</span><span class="s1">injectFirstArg</span><span class="s4">);</span>

      <span class="s1">newArgs </span><span class="s4">= </span><span class="s1">newArgs</span><span class="s4">.</span><span class="s1">map</span><span class="s4">(</span><span class="s1">arg </span><span class="s4">=&gt; </span><span class="s1">t</span><span class="s4">.</span><span class="s1">cloneDeep</span><span class="s4">(</span><span class="s1">arg</span><span class="s4">));</span>
    <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
      <span class="s1">newArgs </span><span class="s4">= </span><span class="s1">path</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">arguments</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s2">return </span><span class="s1">finish</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">callExpression</span><span class="s4">(</span><span class="s1">newCallee</span><span class="s4">, </span><span class="s1">newArgs</span><span class="s4">));</span>

  <span class="s2">case </span><span class="s3">&quot;NewExpression&quot;</span><span class="s4">:</span>
    <span class="s2">return </span><span class="s1">finish</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">newExpression</span><span class="s4">(</span>
     <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeViaTempVar</span><span class="s4">(</span><span class="s2">null</span><span class="s4">, </span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;callee&quot;</span><span class="s4">), </span><span class="s1">hasLeapingChildren</span><span class="s4">),</span>
       <span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;arguments&quot;</span><span class="s4">).</span><span class="s1">map</span><span class="s4">(</span><span class="s2">function</span><span class="s4">(</span><span class="s1">argPath</span><span class="s4">) {</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeViaTempVar</span><span class="s4">(</span><span class="s2">null</span><span class="s4">, </span><span class="s1">argPath</span><span class="s4">, </span><span class="s1">hasLeapingChildren</span><span class="s4">);</span>
      <span class="s4">})</span>
    <span class="s4">));</span>

  <span class="s2">case </span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s4">:</span>
    <span class="s2">return </span><span class="s1">finish</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">objectExpression</span><span class="s4">(</span>
      <span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;properties&quot;</span><span class="s4">).</span><span class="s1">map</span><span class="s4">(</span><span class="s2">function</span><span class="s4">(</span><span class="s1">propPath</span><span class="s4">) {</span>
        <span class="s2">if </span><span class="s4">(</span><span class="s1">propPath</span><span class="s4">.</span><span class="s1">isObjectProperty</span><span class="s4">()) {</span>
          <span class="s2">return </span><span class="s1">t</span><span class="s4">.</span><span class="s1">objectProperty</span><span class="s4">(</span>
            <span class="s1">propPath</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">key</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeViaTempVar</span><span class="s4">(</span><span class="s2">null</span><span class="s4">, </span><span class="s1">propPath</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;value&quot;</span><span class="s4">), </span><span class="s1">hasLeapingChildren</span><span class="s4">),</span>
            <span class="s1">propPath</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">computed</span>
          <span class="s4">);</span>
        <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
          <span class="s2">return </span><span class="s1">propPath</span><span class="s4">.</span><span class="s1">node</span><span class="s4">;</span>
        <span class="s4">}</span>
      <span class="s4">})</span>
    <span class="s4">));</span>

  <span class="s2">case </span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s4">:</span>
    <span class="s2">return </span><span class="s1">finish</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">arrayExpression</span><span class="s4">(</span>
      <span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;elements&quot;</span><span class="s4">).</span><span class="s1">map</span><span class="s4">(</span><span class="s2">function</span><span class="s4">(</span><span class="s1">elemPath</span><span class="s4">) {</span>
        <span class="s2">if </span><span class="s4">(!</span><span class="s1">elemPath</span><span class="s4">.</span><span class="s1">node</span><span class="s4">) {</span>
          <span class="s2">return null</span><span class="s4">;</span>
        <span class="s4">} </span><span class="s2">if </span><span class="s4">(</span><span class="s1">elemPath</span><span class="s4">.</span><span class="s1">isSpreadElement</span><span class="s4">()) {</span>
          <span class="s2">return </span><span class="s1">t</span><span class="s4">.</span><span class="s1">spreadElement</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeViaTempVar</span><span class="s4">(</span><span class="s2">null</span><span class="s4">, </span><span class="s1">elemPath</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;argument&quot;</span><span class="s4">), </span><span class="s1">hasLeapingChildren</span><span class="s4">)</span>
          <span class="s4">);</span>
        <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
          <span class="s2">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeViaTempVar</span><span class="s4">(</span><span class="s2">null</span><span class="s4">, </span><span class="s1">elemPath</span><span class="s4">, </span><span class="s1">hasLeapingChildren</span><span class="s4">);</span>
        <span class="s4">}</span>
      <span class="s4">})</span>
    <span class="s4">));</span>

  <span class="s2">case </span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s4">:</span>
    <span class="s2">let </span><span class="s1">lastIndex </span><span class="s4">= </span><span class="s1">expr</span><span class="s4">.</span><span class="s1">expressions</span><span class="s4">.</span><span class="s1">length </span><span class="s4">- </span><span class="s6">1</span><span class="s4">;</span>

    <span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;expressions&quot;</span><span class="s4">).</span><span class="s1">forEach</span><span class="s4">(</span><span class="s2">function</span><span class="s4">(</span><span class="s1">exprPath</span><span class="s4">) {</span>
      <span class="s2">if </span><span class="s4">(</span><span class="s1">exprPath</span><span class="s4">.</span><span class="s1">key </span><span class="s4">=== </span><span class="s1">lastIndex</span><span class="s4">) {</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">exprPath</span><span class="s4">, </span><span class="s1">ignoreResult</span><span class="s4">);</span>
      <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">exprPath</span><span class="s4">, </span><span class="s2">true</span><span class="s4">);</span>
      <span class="s4">}</span>
    <span class="s4">});</span>

    <span class="s2">return </span><span class="s1">result</span><span class="s4">;</span>

  <span class="s2">case </span><span class="s3">&quot;LogicalExpression&quot;</span><span class="s4">:</span>
    <span class="s1">after </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>

    <span class="s2">if </span><span class="s4">(!</span><span class="s1">ignoreResult</span><span class="s4">) {</span>
      <span class="s1">result </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">makeTempVar</span><span class="s4">();</span>
    <span class="s4">}</span>

    <span class="s2">let </span><span class="s1">left </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeViaTempVar</span><span class="s4">(</span><span class="s1">result</span><span class="s4">, </span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;left&quot;</span><span class="s4">), </span><span class="s1">hasLeapingChildren</span><span class="s4">);</span>

    <span class="s2">if </span><span class="s4">(</span><span class="s1">expr</span><span class="s4">.</span><span class="s1">operator </span><span class="s4">=== </span><span class="s3">&quot;&amp;&amp;&quot;</span><span class="s4">) {</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">jumpIfNot</span><span class="s4">(</span><span class="s1">left</span><span class="s4">, </span><span class="s1">after</span><span class="s4">);</span>
    <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
      <span class="s1">assert</span><span class="s4">.</span><span class="s1">strictEqual</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">, </span><span class="s3">&quot;||&quot;</span><span class="s4">);</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">jumpIf</span><span class="s4">(</span><span class="s1">left</span><span class="s4">, </span><span class="s1">after</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeViaTempVar</span><span class="s4">(</span><span class="s1">result</span><span class="s4">, </span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;right&quot;</span><span class="s4">), </span><span class="s1">hasLeapingChildren</span><span class="s4">, </span><span class="s1">ignoreResult</span><span class="s4">);</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">after</span><span class="s4">);</span>

    <span class="s2">return </span><span class="s1">result</span><span class="s4">;</span>

  <span class="s2">case </span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s4">:</span>
    <span class="s2">let </span><span class="s1">elseLoc </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>
    <span class="s1">after </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>
    <span class="s2">let </span><span class="s1">test </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;test&quot;</span><span class="s4">));</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">jumpIfNot</span><span class="s4">(</span><span class="s1">test</span><span class="s4">, </span><span class="s1">elseLoc</span><span class="s4">);</span>

    <span class="s2">if </span><span class="s4">(!</span><span class="s1">ignoreResult</span><span class="s4">) {</span>
      <span class="s1">result </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">makeTempVar</span><span class="s4">();</span>
    <span class="s4">}</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeViaTempVar</span><span class="s4">(</span><span class="s1">result</span><span class="s4">, </span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;consequent&quot;</span><span class="s4">), </span><span class="s1">hasLeapingChildren</span><span class="s4">, </span><span class="s1">ignoreResult</span><span class="s4">);</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">jump</span><span class="s4">(</span><span class="s1">after</span><span class="s4">);</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">elseLoc</span><span class="s4">);</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeViaTempVar</span><span class="s4">(</span><span class="s1">result</span><span class="s4">, </span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;alternate&quot;</span><span class="s4">), </span><span class="s1">hasLeapingChildren</span><span class="s4">, </span><span class="s1">ignoreResult</span><span class="s4">);</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">after</span><span class="s4">);</span>

    <span class="s2">return </span><span class="s1">result</span><span class="s4">;</span>

  <span class="s2">case </span><span class="s3">&quot;UnaryExpression&quot;</span><span class="s4">:</span>
    <span class="s2">return </span><span class="s1">finish</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">unaryExpression</span><span class="s4">(</span>
      <span class="s1">expr</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">,</span>
      <span class="s5">// Can't (and don't need to) break up the syntax of the argument.</span>
      <span class="s5">// Think about delete a[b].</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;argument&quot;</span><span class="s4">)),</span>
      <span class="s4">!!</span><span class="s1">expr</span><span class="s4">.</span><span class="s1">prefix</span>
    <span class="s4">));</span>

  <span class="s2">case </span><span class="s3">&quot;BinaryExpression&quot;</span><span class="s4">:</span>
    <span class="s2">return </span><span class="s1">finish</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">binaryExpression</span><span class="s4">(</span>
      <span class="s1">expr</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">,</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeViaTempVar</span><span class="s4">(</span><span class="s2">null</span><span class="s4">, </span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;left&quot;</span><span class="s4">), </span><span class="s1">hasLeapingChildren</span><span class="s4">),</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeViaTempVar</span><span class="s4">(</span><span class="s2">null</span><span class="s4">, </span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;right&quot;</span><span class="s4">), </span><span class="s1">hasLeapingChildren</span><span class="s4">)</span>
    <span class="s4">));</span>

  <span class="s2">case </span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s4">:</span>
    <span class="s2">if </span><span class="s4">(</span><span class="s1">expr</span><span class="s4">.</span><span class="s1">operator </span><span class="s4">=== </span><span class="s3">&quot;=&quot;</span><span class="s4">) {</span>
      <span class="s5">// If this is a simple assignment, the left hand side does not need</span>
      <span class="s5">// to be read before the right hand side is evaluated, so we can</span>
      <span class="s5">// avoid the more complicated logic below.</span>
      <span class="s2">return </span><span class="s1">finish</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">assignmentExpression</span><span class="s4">(</span>
        <span class="s1">expr</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">,</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;left&quot;</span><span class="s4">)),</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;right&quot;</span><span class="s4">))</span>
      <span class="s4">));</span>
    <span class="s4">}</span>

    <span class="s2">const </span><span class="s1">lhs </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;left&quot;</span><span class="s4">));</span>
    <span class="s2">const </span><span class="s1">temp </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">emitAssign</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">makeTempVar</span><span class="s4">(), </span><span class="s1">lhs</span><span class="s4">);</span>

    <span class="s5">// For example,</span>
    <span class="s5">//</span>
    <span class="s5">//   x += yield y</span>
    <span class="s5">//</span>
    <span class="s5">// becomes</span>
    <span class="s5">//</span>
    <span class="s5">//   context.t0 = x</span>
    <span class="s5">//   x = context.t0 += yield y</span>
    <span class="s5">//</span>
    <span class="s5">// so that the left-hand side expression is read before the yield.</span>
    <span class="s5">// Fixes https://github.com/facebook/regenerator/issues/345.</span>

    <span class="s2">return </span><span class="s1">finish</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">assignmentExpression</span><span class="s4">(</span>
      <span class="s3">&quot;=&quot;</span><span class="s4">,</span>
      <span class="s1">t</span><span class="s4">.</span><span class="s1">cloneDeep</span><span class="s4">(</span><span class="s1">lhs</span><span class="s4">),</span>
      <span class="s1">t</span><span class="s4">.</span><span class="s1">assignmentExpression</span><span class="s4">(</span>
        <span class="s1">expr</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">,</span>
        <span class="s1">t</span><span class="s4">.</span><span class="s1">cloneDeep</span><span class="s4">(</span><span class="s1">temp</span><span class="s4">),</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;right&quot;</span><span class="s4">))</span>
      <span class="s4">)</span>
    <span class="s4">));</span>

  <span class="s2">case </span><span class="s3">&quot;UpdateExpression&quot;</span><span class="s4">:</span>
    <span class="s2">return </span><span class="s1">finish</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">updateExpression</span><span class="s4">(</span>
      <span class="s1">expr</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">,</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;argument&quot;</span><span class="s4">)),</span>
      <span class="s1">expr</span><span class="s4">.</span><span class="s1">prefix</span>
    <span class="s4">));</span>

  <span class="s2">case </span><span class="s3">&quot;YieldExpression&quot;</span><span class="s4">:</span>
    <span class="s1">after </span><span class="s4">= </span><span class="s2">this</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">();</span>
    <span class="s2">let </span><span class="s1">arg </span><span class="s4">= </span><span class="s1">expr</span><span class="s4">.</span><span class="s1">argument </span><span class="s4">&amp;&amp; </span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;argument&quot;</span><span class="s4">));</span>

    <span class="s2">if </span><span class="s4">(</span><span class="s1">arg </span><span class="s4">&amp;&amp; </span><span class="s1">expr</span><span class="s4">.</span><span class="s1">delegate</span><span class="s4">) {</span>
      <span class="s2">let </span><span class="s1">result </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">makeTempVar</span><span class="s4">();</span>

      <span class="s2">let </span><span class="s1">ret </span><span class="s4">= </span><span class="s1">t</span><span class="s4">.</span><span class="s1">returnStatement</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">callExpression</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">contextProperty</span><span class="s4">(</span><span class="s3">&quot;delegateYield&quot;</span><span class="s4">),</span>
        <span class="s4">[</span>
          <span class="s1">arg</span><span class="s4">,</span>
          <span class="s1">t</span><span class="s4">.</span><span class="s1">stringLiteral</span><span class="s4">(</span><span class="s1">result</span><span class="s4">.</span><span class="s1">property</span><span class="s4">.</span><span class="s1">name</span><span class="s4">),</span>
          <span class="s1">after</span>
        <span class="s4">]</span>
      <span class="s4">));</span>
      <span class="s1">ret</span><span class="s4">.</span><span class="s1">loc </span><span class="s4">= </span><span class="s1">expr</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">;</span>

      <span class="s1">self</span><span class="s4">.</span><span class="s1">emit</span><span class="s4">(</span><span class="s1">ret</span><span class="s4">);</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">after</span><span class="s4">);</span>

      <span class="s2">return </span><span class="s1">result</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s1">self</span><span class="s4">.</span><span class="s1">emitAssign</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">contextProperty</span><span class="s4">(</span><span class="s3">&quot;next&quot;</span><span class="s4">), </span><span class="s1">after</span><span class="s4">);</span>

    <span class="s2">let </span><span class="s1">ret </span><span class="s4">= </span><span class="s1">t</span><span class="s4">.</span><span class="s1">returnStatement</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">cloneDeep</span><span class="s4">(</span><span class="s1">arg</span><span class="s4">) || </span><span class="s2">null</span><span class="s4">);</span>
    <span class="s5">// Preserve the `yield` location so that source mappings for the statements</span>
    <span class="s5">// link back to the yield properly.</span>
    <span class="s1">ret</span><span class="s4">.</span><span class="s1">loc </span><span class="s4">= </span><span class="s1">expr</span><span class="s4">.</span><span class="s1">loc</span><span class="s4">;</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">emit</span><span class="s4">(</span><span class="s1">ret</span><span class="s4">);</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">(</span><span class="s1">after</span><span class="s4">);</span>

    <span class="s2">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">contextProperty</span><span class="s4">(</span><span class="s3">&quot;sent&quot;</span><span class="s4">);</span>

  <span class="s2">case </span><span class="s3">&quot;ClassExpression&quot;</span><span class="s4">:</span>
    <span class="s2">return </span><span class="s1">finish</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">explodeClass</span><span class="s4">(</span><span class="s1">path</span><span class="s4">));</span>

  <span class="s2">default</span><span class="s4">:</span>
    <span class="s2">throw new </span><span class="s1">Error</span><span class="s4">(</span>
      <span class="s3">&quot;unknown Expression of type &quot; </span><span class="s4">+</span>
        <span class="s1">JSON</span><span class="s4">.</span><span class="s1">stringify</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">.</span><span class="s1">type</span><span class="s4">));</span>
  <span class="s4">}</span>
<span class="s4">};</span>

<span class="s1">Ep</span><span class="s4">.</span><span class="s1">explodeClass </span><span class="s4">= </span><span class="s2">function</span><span class="s4">(</span><span class="s1">path</span><span class="s4">) {</span>
  <span class="s2">const </span><span class="s1">explodingChildren </span><span class="s4">= [];</span>

  <span class="s2">if </span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">superClass</span><span class="s4">) {</span>
    <span class="s1">explodingChildren</span><span class="s4">.</span><span class="s1">push</span><span class="s4">(</span><span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;superClass&quot;</span><span class="s4">));</span>
  <span class="s4">}</span>

  <span class="s1">path</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;body.body&quot;</span><span class="s4">).</span><span class="s1">forEach</span><span class="s4">(</span><span class="s1">member </span><span class="s4">=&gt; {</span>
    <span class="s2">if </span><span class="s4">(</span><span class="s1">member</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">computed</span><span class="s4">) {</span>
      <span class="s1">explodingChildren</span><span class="s4">.</span><span class="s1">push</span><span class="s4">(</span><span class="s1">member</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s3">&quot;key&quot;</span><span class="s4">));</span>
    <span class="s4">}</span>
  <span class="s4">});</span>

  <span class="s2">const </span><span class="s1">hasLeapingChildren </span><span class="s4">= </span><span class="s1">explodingChildren</span><span class="s4">.</span><span class="s1">some</span><span class="s4">(</span>
    <span class="s1">child </span><span class="s4">=&gt; </span><span class="s1">meta</span><span class="s4">.</span><span class="s1">containsLeap</span><span class="s4">(</span><span class="s1">child</span><span class="s4">));</span>

  <span class="s2">for </span><span class="s4">(</span><span class="s2">let </span><span class="s1">i </span><span class="s4">= </span><span class="s6">0</span><span class="s4">; </span><span class="s1">i </span><span class="s4">&lt; </span><span class="s1">explodingChildren</span><span class="s4">.</span><span class="s1">length</span><span class="s4">; </span><span class="s1">i</span><span class="s4">++) {</span>
    <span class="s2">const </span><span class="s1">child </span><span class="s4">= </span><span class="s1">explodingChildren</span><span class="s4">[</span><span class="s1">i</span><span class="s4">];</span>
    <span class="s2">const </span><span class="s1">isLast </span><span class="s4">= </span><span class="s1">i </span><span class="s4">=== </span><span class="s1">explodingChildren</span><span class="s4">.</span><span class="s1">length </span><span class="s4">- </span><span class="s6">1</span><span class="s4">;</span>

    <span class="s2">if </span><span class="s4">(</span><span class="s1">isLast</span><span class="s4">) {</span>
      <span class="s1">child</span><span class="s4">.</span><span class="s1">replaceWith</span><span class="s4">(</span><span class="s2">this</span><span class="s4">.</span><span class="s1">explodeExpression</span><span class="s4">(</span><span class="s1">child</span><span class="s4">));</span>
    <span class="s4">} </span><span class="s2">else </span><span class="s4">{</span>
      <span class="s1">child</span><span class="s4">.</span><span class="s1">replaceWith</span><span class="s4">(</span><span class="s2">this</span><span class="s4">.</span><span class="s1">explodeViaTempVar</span><span class="s4">(</span><span class="s2">null</span><span class="s4">, </span><span class="s1">child</span><span class="s4">, </span><span class="s1">hasLeapingChildren</span><span class="s4">));</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s2">return </span><span class="s1">path</span><span class="s4">.</span><span class="s1">node</span><span class="s4">;</span>
<span class="s4">};</span>
</pre>
</body>
</html>