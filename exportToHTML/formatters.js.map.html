<html>
<head>
<title>formatters.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
formatters.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;assertExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;makeStatementFormatter&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;validate&quot;</span><span class="s0">,</span><span class="s1">&quot;unwrap&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;program&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;smart&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;statements&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;stmt&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/formatters.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { assertExpressionStatement } from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export type Formatter&lt;T&gt; = {</span><span class="s3">\n  </span><span class="s1">code: (source: string) =&gt; string;</span><span class="s3">\n  </span><span class="s1">validate: (ast: t.File) =&gt; void;</span><span class="s3">\n  </span><span class="s1">unwrap: (ast: t.File) =&gt; T;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function makeStatementFormatter&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">fn: (statements: Array&lt;t.Statement&gt;) =&gt; T,</span><span class="s3">\n</span><span class="s1">): Formatter&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">// We need to prepend a </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot; </span><span class="s1">to force statement parsing so that</span><span class="s3">\n    </span><span class="s1">// ExpressionStatement strings won't be parsed as directives.</span><span class="s3">\n    </span><span class="s1">// Alongside that, we also prepend a comment so that when a syntax error</span><span class="s3">\n    </span><span class="s1">// is encountered, the user will be less likely to get confused about</span><span class="s3">\n    </span><span class="s1">// where the random semicolon came from.</span><span class="s3">\n    </span><span class="s1">code: str =&gt; `/* @babel/template */;</span><span class="s3">\\</span><span class="s1">n${str}`,</span><span class="s3">\n    </span><span class="s1">validate: () =&gt; {},</span><span class="s3">\n    </span><span class="s1">unwrap: (ast: t.File): T =&gt; {</span><span class="s3">\n      </span><span class="s1">return fn(ast.program.body.slice(1));</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const smart = makeStatementFormatter(body =&gt; {</span><span class="s3">\n  </span><span class="s1">if (body.length &gt; 1) {</span><span class="s3">\n    </span><span class="s1">return body;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return body[0];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export const statements = makeStatementFormatter(body =&gt; body);</span><span class="s3">\n\n</span><span class="s1">export const statement = makeStatementFormatter(body =&gt; {</span><span class="s3">\n  </span><span class="s1">// We do this validation when unwrapping since the replacement process</span><span class="s3">\n  </span><span class="s1">// could have added or removed statements.</span><span class="s3">\n  </span><span class="s1">if (body.length === 0) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Found nothing to return.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (body.length &gt; 1) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Found multiple statements but wanted one</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return body[0];</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export const expression: Formatter&lt;t.Expression&gt; = {</span><span class="s3">\n  </span><span class="s1">code: str =&gt; `(</span><span class="s3">\\</span><span class="s1">n${str}</span><span class="s3">\\</span><span class="s1">n)`,</span><span class="s3">\n  </span><span class="s1">validate: ast =&gt; {</span><span class="s3">\n    </span><span class="s1">if (ast.program.body.length &gt; 1) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Found multiple statements but wanted one</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (expression.unwrap(ast).start === 0) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Parse result included parens.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">unwrap: ({ program }) =&gt; {</span><span class="s3">\n    </span><span class="s1">const [stmt] = program.body;</span><span class="s3">\n    </span><span class="s1">assertExpressionStatement(stmt);</span><span class="s3">\n    </span><span class="s1">return stmt.expression;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export const program: Formatter&lt;t.Program&gt; = {</span><span class="s3">\n  </span><span class="s1">code: str =&gt; str,</span><span class="s3">\n  </span><span class="s1">validate: () =&gt; {},</span><span class="s3">\n  </span><span class="s1">unwrap: ast =&gt; ast.program,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA,IAAAA,EAAA,GAAAC,OAAA;AAAyD;EAAhDC;AAAyB,IAAAF,EAAA;AASlC,SAASG,sBAAsBA,CAC7BC,EAAyC,EAC3B;EACd,OAAO;IAMLC,IAAI,EAAEC,GAAG,IAAK,2BAA0BA,GAAI,EAAC;IAC7CC,QAAQ,EAAEA,CAAA,KAAM,CAAC,CAAC;IAClBC,MAAM,EAAGC,GAAW,IAAQ;MAC1B,OAAOL,EAAE,CAACK,GAAG,CAACC,OAAO,CAACC,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC;IACtC;EACF,CAAC;AACH;AAEO,MAAMC,KAAK,GAAGV,sBAAsB,CAACQ,IAAI,IAAI;EAClD,IAAIA,IAAI,CAACG,MAAM,GAAG,CAAC,EAAE;IACnB,OAAOH,IAAI;EACb,CAAC,MAAM;IACL,OAAOA,IAAI,CAAC,CAAC,CAAC;EAChB;AACF,CAAC,CAAC;AAACI,OAAA,CAAAF,KAAA,GAAAA,KAAA;AAEI,MAAMG,UAAU,GAAGb,sBAAsB,CAACQ,IAAI,IAAIA,IAAI,CAAC;AAACI,OAAA,CAAAC,UAAA,GAAAA,UAAA;AAExD,MAAMC,SAAS,GAAGd,sBAAsB,CAACQ,IAAI,IAAI;EAGtD,IAAIA,IAAI,CAACG,MAAM,KAAK,CAAC,EAAE;IACrB,MAAM,IAAII,KAAK,CAAC,0BAA0B,CAAC;EAC7C;EACA,IAAIP,IAAI,CAACG,MAAM,GAAG,CAAC,EAAE;IACnB,MAAM,IAAII,KAAK,CAAC,0CAA0C,CAAC;EAC7D;EAEA,OAAOP,IAAI,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC;AAACI,OAAA,CAAAE,SAAA,GAAAA,SAAA;AAEI,MAAME,UAAmC,GAAG;EACjDd,IAAI,EAAEC,GAAG,IAAK,MAAKA,GAAI,KAAI;EAC3BC,QAAQ,EAAEE,GAAG,IAAI;IACf,IAAIA,GAAG,CAACC,OAAO,CAACC,IAAI,CAACG,MAAM,GAAG,CAAC,EAAE;MAC/B,MAAM,IAAII,KAAK,CAAC,0CAA0C,CAAC;IAC7D;IACA,IAAIC,UAAU,CAACX,MAAM,CAACC,GAAG,CAAC,CAACW,KAAK,KAAK,CAAC,EAAE;MACtC,MAAM,IAAIF,KAAK,CAAC,+BAA+B,CAAC;IAClD;EACF,CAAC;EACDV,MAAM,EAAEA,CAAC;IAAEE;EAAQ,CAAC,KAAK;IACvB,MAAM,CAACW,IAAI,CAAC,GAAGX,OAAO,CAACC,IAAI;IAC3BT,yBAAyB,CAACmB,IAAI,CAAC;IAC/B,OAAOA,IAAI,CAACF,UAAU;EACxB;AACF,CAAC;AAACJ,OAAA,CAAAI,UAAA,GAAAA,UAAA;AAEK,MAAMT,OAA6B,GAAG;EAC3CL,IAAI,EAAEC,GAAG,IAAIA,GAAG;EAChBC,QAAQ,EAAEA,CAAA,KAAM,CAAC,CAAC;EAClBC,MAAM,EAAEC,GAAG,IAAIA,GAAG,CAACC;AACrB,CAAC;AAACK,OAAA,CAAAL,OAAA,GAAAA,OAAA&quot;</span><span class="s0">}</span></pre>
</body>
</html>