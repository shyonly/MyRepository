<html>
<head>
<title>decorators.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
decorators.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperReplaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperFunctionName&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$decorators&quot;</span><span class="s0">,</span><span class="s1">&quot;decorators&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;hasDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;objectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;objectMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;takeDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;decorator&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;getKey&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;extractElementDescriptor&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;classRef&quot;</span><span class="s0">,</span><span class="s1">&quot;superRef&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;isMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrivate&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSDeclareMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;ReplaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;methodPath&quot;</span><span class="s0">,</span><span class="s1">&quot;objectRef&quot;</span><span class="s0">,</span><span class="s1">&quot;refToPreserve&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;properties&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;static&quot;</span><span class="s0">,</span><span class="s1">&quot;booleanLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;transformed&quot;</span><span class="s0">,</span><span class="s1">&quot;toExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;nameFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;statements&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;buildUndefinedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;objectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;addDecorateHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;addHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;buildDecoratedClass&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;elements&quot;</span><span class="s0">,</span><span class="s1">&quot;initializeId&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isStrict&quot;</span><span class="s0">,</span><span class="s1">&quot;isInStrictMode&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;superId&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifierBasedOnNode&quot;</span><span class="s0">,</span><span class="s1">&quot;classDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;definitions&quot;</span><span class="s0">,</span><span class="s1">&quot;element&quot;</span><span class="s0">,</span><span class="s1">&quot;abstract&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapperCall&quot;</span><span class="s0">,</span><span class="s1">&quot;nullLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;directives&quot;</span><span class="s0">,</span><span class="s1">&quot;directive&quot;</span><span class="s0">,</span><span class="s1">&quot;directiveLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;replacement&quot;</span><span class="s0">,</span><span class="s1">&quot;classPathDesc&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;instanceNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapClass&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/decorators.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// TODO(Babel 8): Remove this file</span><span class="s3">\n\n</span><span class="s1">import { types as t, template } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { File } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import ReplaceSupers from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-replace-supers</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import nameFunction from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-function-name</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">type Decoratable = Extract&lt;t.Node, { decorators?: t.Decorator[] | null }&gt;;</span><span class="s3">\n\n</span><span class="s1">export function hasOwnDecorators(node: t.Class | t.ClassBody[</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">][number]) {</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error: 'decorators' not in TSIndexSignature</span><span class="s3">\n  </span><span class="s1">return !!node.decorators?.length;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function hasDecorators(node: t.Class) {</span><span class="s3">\n  </span><span class="s1">return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function prop(key: string, value?: t.Expression) {</span><span class="s3">\n  </span><span class="s1">if (!value) return null;</span><span class="s3">\n  </span><span class="s1">return t.objectProperty(t.identifier(key), value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function method(key: string, body: t.Statement[]) {</span><span class="s3">\n  </span><span class="s1">return t.objectMethod(</span><span class="s3">\n    \&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">t.identifier(key),</span><span class="s3">\n    </span><span class="s1">[],</span><span class="s3">\n    </span><span class="s1">t.blockStatement(body),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function takeDecorators(node: Decoratable) {</span><span class="s3">\n  </span><span class="s1">let result: t.ArrayExpression | undefined;</span><span class="s3">\n  </span><span class="s1">if (node.decorators &amp;&amp; node.decorators.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">result = t.arrayExpression(</span><span class="s3">\n      </span><span class="s1">node.decorators.map(decorator =&gt; decorator.expression),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">node.decorators = undefined;</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type AcceptedElement = Exclude&lt;ClassElement, t.TSIndexSignature&gt;;</span><span class="s3">\n</span><span class="s1">type SupportedElement = Exclude&lt;</span><span class="s3">\n  </span><span class="s1">AcceptedElement,</span><span class="s3">\n  </span><span class="s1">| t.ClassPrivateMethod</span><span class="s3">\n  </span><span class="s1">| t.ClassPrivateProperty</span><span class="s3">\n  </span><span class="s1">| t.ClassAccessorProperty</span><span class="s3">\n  </span><span class="s1">| t.StaticBlock</span><span class="s3">\n</span><span class="s1">&gt;;</span><span class="s3">\n\n</span><span class="s1">function getKey(node: SupportedElement) {</span><span class="s3">\n  </span><span class="s1">if (node.computed) {</span><span class="s3">\n    </span><span class="s1">return node.key;</span><span class="s3">\n  </span><span class="s1">} else if (t.isIdentifier(node.key)) {</span><span class="s3">\n    </span><span class="s1">return t.stringLiteral(node.key.name);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return t.stringLiteral(</span><span class="s3">\n      </span><span class="s1">String(</span><span class="s3">\n        </span><span class="s1">// A non-identifier non-computed key</span><span class="s3">\n        </span><span class="s1">(node.key as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral)</span><span class="s3">\n          </span><span class="s1">.value,</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function extractElementDescriptor(</span><span class="s3">\n  </span><span class="s1">file: File,</span><span class="s3">\n  </span><span class="s1">classRef: t.Identifier,</span><span class="s3">\n  </span><span class="s1">superRef: t.Identifier,</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;AcceptedElement&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const isMethod = path.isClassMethod();</span><span class="s3">\n  </span><span class="s1">if (path.isPrivate()) {</span><span class="s3">\n    </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n      </span><span class="s1">`Private ${</span><span class="s3">\n        </span><span class="s1">isMethod ? </span><span class="s3">\&quot;</span><span class="s1">methods</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">fields</span><span class="s3">\&quot;\n      </span><span class="s1">} in decorated classes are not supported yet.`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (path.node.type === </span><span class="s3">\&quot;</span><span class="s1">ClassAccessorProperty</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n      </span><span class="s1">`Accessor properties are not supported in 2018-09 decorator transform, please specify { </span><span class="s3">\&quot;</span><span class="s1">version</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">2021-12</span><span class="s3">\&quot; </span><span class="s1">} instead.`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (path.node.type === </span><span class="s3">\&quot;</span><span class="s1">StaticBlock</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n      </span><span class="s1">`Static blocks are not supported in 2018-09 decorator transform, please specify { </span><span class="s3">\&quot;</span><span class="s1">version</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">2021-12</span><span class="s3">\&quot; </span><span class="s1">} instead.`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { node, scope } = path as NodePath&lt;SupportedElement&gt;;</span><span class="s3">\n\n  </span><span class="s1">if (!path.isTSDeclareMethod()) {</span><span class="s3">\n    </span><span class="s1">new ReplaceSupers({</span><span class="s3">\n      </span><span class="s1">methodPath: path as NodePath&lt;</span><span class="s3">\n        </span><span class="s1">Exclude&lt;SupportedElement, t.TSDeclareMethod&gt;</span><span class="s3">\n      </span><span class="s1">&gt;,</span><span class="s3">\n      </span><span class="s1">objectRef: classRef,</span><span class="s3">\n      </span><span class="s1">superRef,</span><span class="s3">\n      </span><span class="s1">file,</span><span class="s3">\n      </span><span class="s1">refToPreserve: classRef,</span><span class="s3">\n    </span><span class="s1">}).replace();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const properties: t.ObjectExpression[</span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">] = [</span><span class="s3">\n    </span><span class="s1">prop(</span><span class="s3">\&quot;</span><span class="s1">kind</span><span class="s3">\&quot;</span><span class="s1">, t.stringLiteral(t.isClassMethod(node) ? node.kind : </span><span class="s3">\&quot;</span><span class="s1">field</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n    </span><span class="s1">prop(</span><span class="s3">\&quot;</span><span class="s1">decorators</span><span class="s3">\&quot;</span><span class="s1">, takeDecorators(node as Decoratable)),</span><span class="s3">\n    </span><span class="s1">prop(</span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot;</span><span class="s1">, node.static &amp;&amp; t.booleanLiteral(true)),</span><span class="s3">\n    </span><span class="s1">prop(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">, getKey(node)),</span><span class="s3">\n  </span><span class="s1">].filter(Boolean);</span><span class="s3">\n\n  </span><span class="s1">if (t.isClassMethod(node)) {</span><span class="s3">\n    </span><span class="s1">const id = node.computed</span><span class="s3">\n      </span><span class="s1">? null</span><span class="s3">\n      </span><span class="s1">: (node.key as</span><span class="s3">\n          </span><span class="s1">| t.Identifier</span><span class="s3">\n          </span><span class="s1">| t.StringLiteral</span><span class="s3">\n          </span><span class="s1">| t.NumericLiteral</span><span class="s3">\n          </span><span class="s1">| t.BigIntLiteral);</span><span class="s3">\n    </span><span class="s1">const transformed = t.toExpression(node);</span><span class="s3">\n    </span><span class="s1">properties.push(</span><span class="s3">\n      </span><span class="s1">prop(</span><span class="s3">\n        \&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">nameFunction({ node: transformed, id, scope }) || transformed,</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else if (t.isClassProperty(node) &amp;&amp; node.value) {</span><span class="s3">\n    </span><span class="s1">properties.push(</span><span class="s3">\n      </span><span class="s1">method(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, template.statements.ast`return ${node.value}`),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">properties.push(prop(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, scope.buildUndefinedNode()));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">path.remove();</span><span class="s3">\n\n  </span><span class="s1">return t.objectExpression(properties);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function addDecorateHelper(file: File) {</span><span class="s3">\n  </span><span class="s1">return file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">decorate</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ClassElement = t.Class[</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">][</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">][number];</span><span class="s3">\n</span><span class="s1">type ClassElementPath = NodePath&lt;ClassElement&gt;;</span><span class="s3">\n\n</span><span class="s1">export function buildDecoratedClass(</span><span class="s3">\n  </span><span class="s1">ref: t.Identifier,</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Class&gt;,</span><span class="s3">\n  </span><span class="s1">elements: ClassElementPath[],</span><span class="s3">\n  </span><span class="s1">file: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { node, scope } = path;</span><span class="s3">\n  </span><span class="s1">const initializeId = scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">initialize</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const isDeclaration = node.id &amp;&amp; path.isDeclaration();</span><span class="s3">\n  </span><span class="s1">const isStrict = path.isInStrictMode();</span><span class="s3">\n  </span><span class="s1">const { superClass } = node;</span><span class="s3">\n\n  </span><span class="s1">node.type = </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">if (!node.id) node.id = t.cloneNode(ref);</span><span class="s3">\n\n  </span><span class="s1">let superId: t.Identifier;</span><span class="s3">\n  </span><span class="s1">if (superClass) {</span><span class="s3">\n    </span><span class="s1">superId = scope.generateUidIdentifierBasedOnNode(node.superClass, </span><span class="s3">\&quot;</span><span class="s1">super</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">node.superClass = superId;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const classDecorators = takeDecorators(node);</span><span class="s3">\n  </span><span class="s1">const definitions = t.arrayExpression(</span><span class="s3">\n    </span><span class="s1">elements</span><span class="s3">\n      </span><span class="s1">.filter(</span><span class="s3">\n        </span><span class="s1">element =&gt;</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error Ignore TypeScript's abstract methods (see #10514)</span><span class="s3">\n          </span><span class="s1">!element.node.abstract &amp;&amp; element.node.type !== </span><span class="s3">\&quot;</span><span class="s1">TSIndexSignature</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">.map(path =&gt;</span><span class="s3">\n        </span><span class="s1">extractElementDescriptor(</span><span class="s3">\n          </span><span class="s1">file,</span><span class="s3">\n          </span><span class="s1">node.id,</span><span class="s3">\n          </span><span class="s1">superId,</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error TS can not exclude TSIndexSignature</span><span class="s3">\n          </span><span class="s1">path,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">const wrapperCall = template.expression.ast`</span><span class="s3">\n    </span><span class="s1">${addDecorateHelper(file)}(</span><span class="s3">\n      </span><span class="s1">${classDecorators || t.nullLiteral()},</span><span class="s3">\n      </span><span class="s1">function (${initializeId}, ${superClass ? t.cloneNode(superId) : null}) {</span><span class="s3">\n        </span><span class="s1">${node}</span><span class="s3">\n        </span><span class="s1">return { F: ${t.cloneNode(node.id)}, d: ${definitions} };</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">${superClass}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">` as t.CallExpression &amp; { arguments: [unknown, t.FunctionExpression] };</span><span class="s3">\n\n  </span><span class="s1">if (!isStrict) {</span><span class="s3">\n    </span><span class="s1">wrapperCall.arguments[1].body.directives.push(</span><span class="s3">\n      </span><span class="s1">t.directive(t.directiveLiteral(</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let replacement: t.Node = wrapperCall;</span><span class="s3">\n  </span><span class="s1">let classPathDesc = </span><span class="s3">\&quot;</span><span class="s1">arguments.1.body.body.0</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">if (isDeclaration) {</span><span class="s3">\n    </span><span class="s1">replacement = template.statement.ast`let ${ref} = ${wrapperCall}`;</span><span class="s3">\n    </span><span class="s1">classPathDesc = </span><span class="s3">\&quot;</span><span class="s1">declarations.0.init.</span><span class="s3">\&quot; </span><span class="s1">+ classPathDesc;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">instanceNodes: [template.statement.ast`${t.cloneNode(initializeId)}(this)`],</span><span class="s3">\n    </span><span class="s1">wrapClass(path: NodePath&lt;t.Class&gt;) {</span><span class="s3">\n      </span><span class="s1">path.replaceWith(replacement);</span><span class="s3">\n      </span><span class="s1">return path.get(classPathDesc) as NodePath;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>