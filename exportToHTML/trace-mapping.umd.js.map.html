<html>
<head>
<title>trace-mapping.umd.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
trace-mapping.umd.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;trace-mapping.umd.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/resolve.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/strip-filename.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/sourcemap-segment.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/sort.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/binary-search.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/by-source.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/any-map.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/trace-mapping.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import resolveUri from '@jridgewell/resolve-uri';</span><span class="s3">\n\n</span><span class="s1">export default function resolve(input: string, base: string | undefined): string {</span><span class="s3">\n  </span><span class="s1">// The base is always treated as a directory, if it's not empty.</span><span class="s3">\n  </span><span class="s1">// https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327</span><span class="s3">\n  </span><span class="s1">// https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401</span><span class="s3">\n  </span><span class="s1">if (base &amp;&amp; !base.endsWith('/')) base += '/';</span><span class="s3">\n\n  </span><span class="s1">return resolveUri(input, base);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Removes everything after the last </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">, but leaves the slash.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function stripFilename(path: string | undefined | null): string {</span><span class="s3">\n  </span><span class="s1">if (!path) return '';</span><span class="s3">\n  </span><span class="s1">const index = path.lastIndexOf('/');</span><span class="s3">\n  </span><span class="s1">return path.slice(0, index + 1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;type GeneratedColumn = number;</span><span class="s3">\n</span><span class="s1">type SourcesIndex = number;</span><span class="s3">\n</span><span class="s1">type SourceLine = number;</span><span class="s3">\n</span><span class="s1">type SourceColumn = number;</span><span class="s3">\n</span><span class="s1">type NamesIndex = number;</span><span class="s3">\n\n</span><span class="s1">type GeneratedLine = number;</span><span class="s3">\n\n</span><span class="s1">export type SourceMapSegment =</span><span class="s3">\n  </span><span class="s1">| [GeneratedColumn]</span><span class="s3">\n  </span><span class="s1">| [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]</span><span class="s3">\n  </span><span class="s1">| [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];</span><span class="s3">\n\n</span><span class="s1">export type ReverseSegment = [SourceColumn, GeneratedLine, GeneratedColumn];</span><span class="s3">\n\n</span><span class="s1">export const COLUMN = 0;</span><span class="s3">\n</span><span class="s1">export const SOURCES_INDEX = 1;</span><span class="s3">\n</span><span class="s1">export const SOURCE_LINE = 2;</span><span class="s3">\n</span><span class="s1">export const SOURCE_COLUMN = 3;</span><span class="s3">\n</span><span class="s1">export const NAMES_INDEX = 4;</span><span class="s3">\n\n</span><span class="s1">export const REV_GENERATED_LINE = 1;</span><span class="s3">\n</span><span class="s1">export const REV_GENERATED_COLUMN = 2;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { COLUMN } from './sourcemap-segment';</span><span class="s3">\n\n</span><span class="s1">import type { SourceMapSegment } from './sourcemap-segment';</span><span class="s3">\n\n</span><span class="s1">export default function maybeSort(</span><span class="s3">\n  </span><span class="s1">mappings: SourceMapSegment[][],</span><span class="s3">\n  </span><span class="s1">owned: boolean,</span><span class="s3">\n</span><span class="s1">): SourceMapSegment[][] {</span><span class="s3">\n  </span><span class="s1">const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);</span><span class="s3">\n  </span><span class="s1">if (unsortedIndex === mappings.length) return mappings;</span><span class="s3">\n\n  </span><span class="s1">// If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If</span><span class="s3">\n  </span><span class="s1">// not, we do not want to modify the consumer's input array.</span><span class="s3">\n  </span><span class="s1">if (!owned) mappings = mappings.slice();</span><span class="s3">\n\n  </span><span class="s1">for (let i = unsortedIndex; i &lt; mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {</span><span class="s3">\n    </span><span class="s1">mappings[i] = sortSegments(mappings[i], owned);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return mappings;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function nextUnsortedSegmentLine(mappings: SourceMapSegment[][], start: number): number {</span><span class="s3">\n  </span><span class="s1">for (let i = start; i &lt; mappings.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (!isSorted(mappings[i])) return i;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return mappings.length;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isSorted(line: SourceMapSegment[]): boolean {</span><span class="s3">\n  </span><span class="s1">for (let j = 1; j &lt; line.length; j++) {</span><span class="s3">\n    </span><span class="s1">if (line[j][COLUMN] &lt; line[j - 1][COLUMN]) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function sortSegments(line: SourceMapSegment[], owned: boolean): SourceMapSegment[] {</span><span class="s3">\n  </span><span class="s1">if (!owned) line = line.slice();</span><span class="s3">\n  </span><span class="s1">return line.sort(sortComparator);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {</span><span class="s3">\n  </span><span class="s1">return a[COLUMN] - b[COLUMN];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';</span><span class="s3">\n</span><span class="s1">import { COLUMN } from './sourcemap-segment';</span><span class="s3">\n\n</span><span class="s1">export type MemoState = {</span><span class="s3">\n  </span><span class="s1">lastKey: number;</span><span class="s3">\n  </span><span class="s1">lastNeedle: number;</span><span class="s3">\n  </span><span class="s1">lastIndex: number;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export let found = false;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A binary search implementation that returns the index if a match is found.</span><span class="s3">\n </span><span class="s1">* If no match is found, then the left-index (the index associated with the item that comes just</span><span class="s3">\n </span><span class="s1">* before the desired index) is returned. To maintain proper sort order, a splice would happen at</span><span class="s3">\n </span><span class="s1">* the next index:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* ```js</span><span class="s3">\n </span><span class="s1">* const array = [1, 3];</span><span class="s3">\n </span><span class="s1">* const needle = 2;</span><span class="s3">\n </span><span class="s1">* const index = binarySearch(array, needle, (item, needle) =&gt; item - needle);</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* assert.equal(index, 0);</span><span class="s3">\n </span><span class="s1">* array.splice(index + 1, 0, needle);</span><span class="s3">\n </span><span class="s1">* assert.deepEqual(array, [1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function binarySearch(</span><span class="s3">\n  </span><span class="s1">haystack: SourceMapSegment[] | ReverseSegment[],</span><span class="s3">\n  </span><span class="s1">needle: number,</span><span class="s3">\n  </span><span class="s1">low: number,</span><span class="s3">\n  </span><span class="s1">high: number,</span><span class="s3">\n</span><span class="s1">): number {</span><span class="s3">\n  </span><span class="s1">while (low &lt;= high) {</span><span class="s3">\n    </span><span class="s1">const mid = low + ((high - low) &gt;&gt; 1);</span><span class="s3">\n    </span><span class="s1">const cmp = haystack[mid][COLUMN] - needle;</span><span class="s3">\n\n    </span><span class="s1">if (cmp === 0) {</span><span class="s3">\n      </span><span class="s1">found = true;</span><span class="s3">\n      </span><span class="s1">return mid;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (cmp &lt; 0) {</span><span class="s3">\n      </span><span class="s1">low = mid + 1;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">high = mid - 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">found = false;</span><span class="s3">\n  </span><span class="s1">return low - 1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function upperBound(</span><span class="s3">\n  </span><span class="s1">haystack: SourceMapSegment[] | ReverseSegment[],</span><span class="s3">\n  </span><span class="s1">needle: number,</span><span class="s3">\n  </span><span class="s1">index: number,</span><span class="s3">\n</span><span class="s1">): number {</span><span class="s3">\n  </span><span class="s1">for (let i = index + 1; i &lt; haystack.length; index = i++) {</span><span class="s3">\n    </span><span class="s1">if (haystack[i][COLUMN] !== needle) break;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function lowerBound(</span><span class="s3">\n  </span><span class="s1">haystack: SourceMapSegment[] | ReverseSegment[],</span><span class="s3">\n  </span><span class="s1">needle: number,</span><span class="s3">\n  </span><span class="s1">index: number,</span><span class="s3">\n</span><span class="s1">): number {</span><span class="s3">\n  </span><span class="s1">for (let i = index - 1; i &gt;= 0; index = i--) {</span><span class="s3">\n    </span><span class="s1">if (haystack[i][COLUMN] !== needle) break;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function memoizedState(): MemoState {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">lastKey: -1,</span><span class="s3">\n    </span><span class="s1">lastNeedle: -1,</span><span class="s3">\n    </span><span class="s1">lastIndex: -1,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This overly complicated beast is just to record the last tested line/column and the resulting</span><span class="s3">\n </span><span class="s1">* index, allowing us to skip a few tests if mappings are monotonically increasing.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function memoizedBinarySearch(</span><span class="s3">\n  </span><span class="s1">haystack: SourceMapSegment[] | ReverseSegment[],</span><span class="s3">\n  </span><span class="s1">needle: number,</span><span class="s3">\n  </span><span class="s1">state: MemoState,</span><span class="s3">\n  </span><span class="s1">key: number,</span><span class="s3">\n</span><span class="s1">): number {</span><span class="s3">\n  </span><span class="s1">const { lastKey, lastNeedle, lastIndex } = state;</span><span class="s3">\n\n  </span><span class="s1">let low = 0;</span><span class="s3">\n  </span><span class="s1">let high = haystack.length - 1;</span><span class="s3">\n  </span><span class="s1">if (key === lastKey) {</span><span class="s3">\n    </span><span class="s1">if (needle === lastNeedle) {</span><span class="s3">\n      </span><span class="s1">found = lastIndex !== -1 &amp;&amp; haystack[lastIndex][COLUMN] === needle;</span><span class="s3">\n      </span><span class="s1">return lastIndex;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (needle &gt;= lastNeedle) {</span><span class="s3">\n      </span><span class="s1">// lastIndex may be -1 if the previous needle was not found.</span><span class="s3">\n      </span><span class="s1">low = lastIndex === -1 ? 0 : lastIndex;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">high = lastIndex;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">state.lastKey = key;</span><span class="s3">\n  </span><span class="s1">state.lastNeedle = needle;</span><span class="s3">\n\n  </span><span class="s1">return (state.lastIndex = binarySearch(haystack, needle, low, high));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { COLUMN, SOURCES_INDEX, SOURCE_LINE, SOURCE_COLUMN } from './sourcemap-segment';</span><span class="s3">\n</span><span class="s1">import { memoizedBinarySearch, upperBound } from './binary-search';</span><span class="s3">\n\n</span><span class="s1">import type { ReverseSegment, SourceMapSegment } from './sourcemap-segment';</span><span class="s3">\n</span><span class="s1">import type { MemoState } from './binary-search';</span><span class="s3">\n\n</span><span class="s1">export type Source = {</span><span class="s3">\n  </span><span class="s1">__proto__: null;</span><span class="s3">\n  </span><span class="s1">[line: number]: Exclude&lt;ReverseSegment, [number]&gt;[];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Rebuilds the original source files, with mappings that are ordered by source line/column instead</span><span class="s3">\n</span><span class="s1">// of generated line/column.</span><span class="s3">\n</span><span class="s1">export default function buildBySources(</span><span class="s3">\n  </span><span class="s1">decoded: readonly SourceMapSegment[][],</span><span class="s3">\n  </span><span class="s1">memos: MemoState[],</span><span class="s3">\n</span><span class="s1">): Source[] {</span><span class="s3">\n  </span><span class="s1">const sources: Source[] = memos.map(buildNullArray);</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; decoded.length; i++) {</span><span class="s3">\n    </span><span class="s1">const line = decoded[i];</span><span class="s3">\n    </span><span class="s1">for (let j = 0; j &lt; line.length; j++) {</span><span class="s3">\n      </span><span class="s1">const seg = line[j];</span><span class="s3">\n      </span><span class="s1">if (seg.length === 1) continue;</span><span class="s3">\n\n      </span><span class="s1">const sourceIndex = seg[SOURCES_INDEX];</span><span class="s3">\n      </span><span class="s1">const sourceLine = seg[SOURCE_LINE];</span><span class="s3">\n      </span><span class="s1">const sourceColumn = seg[SOURCE_COLUMN];</span><span class="s3">\n      </span><span class="s1">const originalSource = sources[sourceIndex];</span><span class="s3">\n      </span><span class="s1">const originalLine = (originalSource[sourceLine] ||= []);</span><span class="s3">\n      </span><span class="s1">const memo = memos[sourceIndex];</span><span class="s3">\n\n      </span><span class="s1">// The binary search either found a match, or it found the left-index just before where the</span><span class="s3">\n      </span><span class="s1">// segment should go. Either way, we want to insert after that. And there may be multiple</span><span class="s3">\n      </span><span class="s1">// generated segments associated with an original location, so there may need to move several</span><span class="s3">\n      </span><span class="s1">// indexes before we find where we need to insert.</span><span class="s3">\n      </span><span class="s1">const index = upperBound(</span><span class="s3">\n        </span><span class="s1">originalLine,</span><span class="s3">\n        </span><span class="s1">sourceColumn,</span><span class="s3">\n        </span><span class="s1">memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return sources;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function insert&lt;T&gt;(array: T[], index: number, value: T) {</span><span class="s3">\n  </span><span class="s1">for (let i = array.length; i &gt; index; i--) {</span><span class="s3">\n    </span><span class="s1">array[i] = array[i - 1];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">array[index] = value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like</span><span class="s3">\n</span><span class="s1">// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.</span><span class="s3">\n</span><span class="s1">// Numeric properties on objects are magically sorted in ascending order by the engine regardless of</span><span class="s3">\n</span><span class="s1">// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending</span><span class="s3">\n</span><span class="s1">// order when iterating with for-in.</span><span class="s3">\n</span><span class="s1">function buildNullArray&lt;T extends { __proto__: null }&gt;(): T {</span><span class="s3">\n  </span><span class="s1">return { __proto__: null } as T;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { TraceMap, presortedDecodedMap, decodedMappings } from './trace-mapping';</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">COLUMN,</span><span class="s3">\n  </span><span class="s1">SOURCES_INDEX,</span><span class="s3">\n  </span><span class="s1">SOURCE_LINE,</span><span class="s3">\n  </span><span class="s1">SOURCE_COLUMN,</span><span class="s3">\n  </span><span class="s1">NAMES_INDEX,</span><span class="s3">\n</span><span class="s1">} from './sourcemap-segment';</span><span class="s3">\n\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Section,</span><span class="s3">\n  </span><span class="s1">SectionedSourceMap,</span><span class="s3">\n  </span><span class="s1">DecodedSourceMap,</span><span class="s3">\n  </span><span class="s1">SectionedSourceMapInput,</span><span class="s3">\n  </span><span class="s1">Ro,</span><span class="s3">\n</span><span class="s1">} from './types';</span><span class="s3">\n</span><span class="s1">import type { SourceMapSegment } from './sourcemap-segment';</span><span class="s3">\n\n</span><span class="s1">type AnyMap = {</span><span class="s3">\n  </span><span class="s1">new (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;</span><span class="s3">\n  </span><span class="s1">(map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export const AnyMap: AnyMap = function (map, mapUrl) {</span><span class="s3">\n  </span><span class="s1">const parsed =</span><span class="s3">\n    </span><span class="s1">typeof map === 'string' ? (JSON.parse(map) as Exclude&lt;SectionedSourceMapInput, string&gt;) : map;</span><span class="s3">\n\n  </span><span class="s1">if (!('sections' in parsed)) return new TraceMap(parsed, mapUrl);</span><span class="s3">\n\n  </span><span class="s1">const mappings: SourceMapSegment[][] = [];</span><span class="s3">\n  </span><span class="s1">const sources: string[] = [];</span><span class="s3">\n  </span><span class="s1">const sourcesContent: (string | null)[] = [];</span><span class="s3">\n  </span><span class="s1">const names: string[] = [];</span><span class="s3">\n\n  </span><span class="s1">recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);</span><span class="s3">\n\n  </span><span class="s1">const joined: DecodedSourceMap = {</span><span class="s3">\n    </span><span class="s1">version: 3,</span><span class="s3">\n    </span><span class="s1">file: parsed.file,</span><span class="s3">\n    </span><span class="s1">names,</span><span class="s3">\n    </span><span class="s1">sources,</span><span class="s3">\n    </span><span class="s1">sourcesContent,</span><span class="s3">\n    </span><span class="s1">mappings,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">return presortedDecodedMap(joined);</span><span class="s3">\n</span><span class="s1">} as AnyMap;</span><span class="s3">\n\n</span><span class="s1">function recurse(</span><span class="s3">\n  </span><span class="s1">input: Ro&lt;SectionedSourceMap&gt;,</span><span class="s3">\n  </span><span class="s1">mapUrl: string | null | undefined,</span><span class="s3">\n  </span><span class="s1">mappings: SourceMapSegment[][],</span><span class="s3">\n  </span><span class="s1">sources: string[],</span><span class="s3">\n  </span><span class="s1">sourcesContent: (string | null)[],</span><span class="s3">\n  </span><span class="s1">names: string[],</span><span class="s3">\n  </span><span class="s1">lineOffset: number,</span><span class="s3">\n  </span><span class="s1">columnOffset: number,</span><span class="s3">\n  </span><span class="s1">stopLine: number,</span><span class="s3">\n  </span><span class="s1">stopColumn: number,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { sections } = input;</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; sections.length; i++) {</span><span class="s3">\n    </span><span class="s1">const { map, offset } = sections[i];</span><span class="s3">\n\n    </span><span class="s1">let sl = stopLine;</span><span class="s3">\n    </span><span class="s1">let sc = stopColumn;</span><span class="s3">\n    </span><span class="s1">if (i + 1 &lt; sections.length) {</span><span class="s3">\n      </span><span class="s1">const nextOffset = sections[i + 1].offset;</span><span class="s3">\n      </span><span class="s1">sl = Math.min(stopLine, lineOffset + nextOffset.line);</span><span class="s3">\n\n      </span><span class="s1">if (sl === stopLine) {</span><span class="s3">\n        </span><span class="s1">sc = Math.min(stopColumn, columnOffset + nextOffset.column);</span><span class="s3">\n      </span><span class="s1">} else if (sl &lt; stopLine) {</span><span class="s3">\n        </span><span class="s1">sc = columnOffset + nextOffset.column;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">addSection(</span><span class="s3">\n      </span><span class="s1">map,</span><span class="s3">\n      </span><span class="s1">mapUrl,</span><span class="s3">\n      </span><span class="s1">mappings,</span><span class="s3">\n      </span><span class="s1">sources,</span><span class="s3">\n      </span><span class="s1">sourcesContent,</span><span class="s3">\n      </span><span class="s1">names,</span><span class="s3">\n      </span><span class="s1">lineOffset + offset.line,</span><span class="s3">\n      </span><span class="s1">columnOffset + offset.column,</span><span class="s3">\n      </span><span class="s1">sl,</span><span class="s3">\n      </span><span class="s1">sc,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function addSection(</span><span class="s3">\n  </span><span class="s1">input: Ro&lt;Section['map']&gt;,</span><span class="s3">\n  </span><span class="s1">mapUrl: string | null | undefined,</span><span class="s3">\n  </span><span class="s1">mappings: SourceMapSegment[][],</span><span class="s3">\n  </span><span class="s1">sources: string[],</span><span class="s3">\n  </span><span class="s1">sourcesContent: (string | null)[],</span><span class="s3">\n  </span><span class="s1">names: string[],</span><span class="s3">\n  </span><span class="s1">lineOffset: number,</span><span class="s3">\n  </span><span class="s1">columnOffset: number,</span><span class="s3">\n  </span><span class="s1">stopLine: number,</span><span class="s3">\n  </span><span class="s1">stopColumn: number,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if ('sections' in input) return recurse(...(arguments as unknown as Parameters&lt;typeof recurse&gt;));</span><span class="s3">\n\n  </span><span class="s1">const map = new TraceMap(input, mapUrl);</span><span class="s3">\n  </span><span class="s1">const sourcesOffset = sources.length;</span><span class="s3">\n  </span><span class="s1">const namesOffset = names.length;</span><span class="s3">\n  </span><span class="s1">const decoded = decodedMappings(map);</span><span class="s3">\n  </span><span class="s1">const { resolvedSources, sourcesContent: contents } = map;</span><span class="s3">\n\n  </span><span class="s1">append(sources, resolvedSources);</span><span class="s3">\n  </span><span class="s1">append(names, map.names);</span><span class="s3">\n  </span><span class="s1">if (contents) append(sourcesContent, contents);</span><span class="s3">\n  </span><span class="s1">else for (let i = 0; i &lt; resolvedSources.length; i++) sourcesContent.push(null);</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; decoded.length; i++) {</span><span class="s3">\n    </span><span class="s1">const lineI = lineOffset + i;</span><span class="s3">\n\n    </span><span class="s1">// We can only add so many lines before we step into the range that the next section's map</span><span class="s3">\n    </span><span class="s1">// controls. When we get to the last line, then we'll start checking the segments to see if</span><span class="s3">\n    </span><span class="s1">// they've crossed into the column range. But it may not have any columns that overstep, so we</span><span class="s3">\n    </span><span class="s1">// still need to check that we don't overstep lines, too.</span><span class="s3">\n    </span><span class="s1">if (lineI &gt; stopLine) return;</span><span class="s3">\n\n    </span><span class="s1">// The out line may already exist in mappings (if we're continuing the line started by a</span><span class="s3">\n    </span><span class="s1">// previous section). Or, we may have jumped ahead several lines to start this section.</span><span class="s3">\n    </span><span class="s1">const out = getLine(mappings, lineI);</span><span class="s3">\n    </span><span class="s1">// On the 0th loop, the section's column offset shifts us forward. On all other lines (since the</span><span class="s3">\n    </span><span class="s1">// map can be multiple lines), it doesn't.</span><span class="s3">\n    </span><span class="s1">const cOffset = i === 0 ? columnOffset : 0;</span><span class="s3">\n\n    </span><span class="s1">const line = decoded[i];</span><span class="s3">\n    </span><span class="s1">for (let j = 0; j &lt; line.length; j++) {</span><span class="s3">\n      </span><span class="s1">const seg = line[j];</span><span class="s3">\n      </span><span class="s1">const column = cOffset + seg[COLUMN];</span><span class="s3">\n\n      </span><span class="s1">// If this segment steps into the column range that the next section's map controls, we need</span><span class="s3">\n      </span><span class="s1">// to stop early.</span><span class="s3">\n      </span><span class="s1">if (lineI === stopLine &amp;&amp; column &gt;= stopColumn) return;</span><span class="s3">\n\n      </span><span class="s1">if (seg.length === 1) {</span><span class="s3">\n        </span><span class="s1">out.push([column]);</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];</span><span class="s3">\n      </span><span class="s1">const sourceLine = seg[SOURCE_LINE];</span><span class="s3">\n      </span><span class="s1">const sourceColumn = seg[SOURCE_COLUMN];</span><span class="s3">\n      </span><span class="s1">out.push(</span><span class="s3">\n        </span><span class="s1">seg.length === 4</span><span class="s3">\n          </span><span class="s1">? [column, sourcesIndex, sourceLine, sourceColumn]</span><span class="s3">\n          </span><span class="s1">: [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]],</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function append&lt;T&gt;(arr: T[], other: T[]) {</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; other.length; i++) arr.push(other[i]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getLine&lt;T&gt;(arr: T[][], index: number): T[] {</span><span class="s3">\n  </span><span class="s1">for (let i = arr.length; i &lt;= index; i++) arr[i] = [];</span><span class="s3">\n  </span><span class="s1">return arr[index];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { encode, decode } from '@jridgewell/sourcemap-codec';</span><span class="s3">\n\n</span><span class="s1">import resolve from './resolve';</span><span class="s3">\n</span><span class="s1">import stripFilename from './strip-filename';</span><span class="s3">\n</span><span class="s1">import maybeSort from './sort';</span><span class="s3">\n</span><span class="s1">import buildBySources from './by-source';</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">memoizedState,</span><span class="s3">\n  </span><span class="s1">memoizedBinarySearch,</span><span class="s3">\n  </span><span class="s1">upperBound,</span><span class="s3">\n  </span><span class="s1">lowerBound,</span><span class="s3">\n  </span><span class="s1">found as bsFound,</span><span class="s3">\n</span><span class="s1">} from './binary-search';</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">COLUMN,</span><span class="s3">\n  </span><span class="s1">SOURCES_INDEX,</span><span class="s3">\n  </span><span class="s1">SOURCE_LINE,</span><span class="s3">\n  </span><span class="s1">SOURCE_COLUMN,</span><span class="s3">\n  </span><span class="s1">NAMES_INDEX,</span><span class="s3">\n  </span><span class="s1">REV_GENERATED_LINE,</span><span class="s3">\n  </span><span class="s1">REV_GENERATED_COLUMN,</span><span class="s3">\n</span><span class="s1">} from './sourcemap-segment';</span><span class="s3">\n\n</span><span class="s1">import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">SourceMapV3,</span><span class="s3">\n  </span><span class="s1">DecodedSourceMap,</span><span class="s3">\n  </span><span class="s1">EncodedSourceMap,</span><span class="s3">\n  </span><span class="s1">InvalidOriginalMapping,</span><span class="s3">\n  </span><span class="s1">OriginalMapping,</span><span class="s3">\n  </span><span class="s1">InvalidGeneratedMapping,</span><span class="s3">\n  </span><span class="s1">GeneratedMapping,</span><span class="s3">\n  </span><span class="s1">SourceMapInput,</span><span class="s3">\n  </span><span class="s1">Needle,</span><span class="s3">\n  </span><span class="s1">SourceNeedle,</span><span class="s3">\n  </span><span class="s1">SourceMap,</span><span class="s3">\n  </span><span class="s1">EachMapping,</span><span class="s3">\n  </span><span class="s1">Bias,</span><span class="s3">\n</span><span class="s1">} from './types';</span><span class="s3">\n</span><span class="s1">import type { Source } from './by-source';</span><span class="s3">\n</span><span class="s1">import type { MemoState } from './binary-search';</span><span class="s3">\n\n</span><span class="s1">export type { SourceMapSegment } from './sourcemap-segment';</span><span class="s3">\n</span><span class="s1">export type {</span><span class="s3">\n  </span><span class="s1">SourceMapInput,</span><span class="s3">\n  </span><span class="s1">SectionedSourceMapInput,</span><span class="s3">\n  </span><span class="s1">DecodedSourceMap,</span><span class="s3">\n  </span><span class="s1">EncodedSourceMap,</span><span class="s3">\n  </span><span class="s1">SectionedSourceMap,</span><span class="s3">\n  </span><span class="s1">InvalidOriginalMapping,</span><span class="s3">\n  </span><span class="s1">OriginalMapping as Mapping,</span><span class="s3">\n  </span><span class="s1">OriginalMapping,</span><span class="s3">\n  </span><span class="s1">InvalidGeneratedMapping,</span><span class="s3">\n  </span><span class="s1">GeneratedMapping,</span><span class="s3">\n  </span><span class="s1">EachMapping,</span><span class="s3">\n</span><span class="s1">} from './types';</span><span class="s3">\n\n</span><span class="s1">const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';</span><span class="s3">\n</span><span class="s1">const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';</span><span class="s3">\n\n</span><span class="s1">export const LEAST_UPPER_BOUND = -1;</span><span class="s3">\n</span><span class="s1">export const GREATEST_LOWER_BOUND = 1;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the encoded (VLQ string) form of the SourceMap's mappings field.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let encodedMappings: (map: TraceMap) =&gt; EncodedSourceMap['mappings'];</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let decodedMappings: (map: TraceMap) =&gt; Readonly&lt;DecodedSourceMap['mappings']&gt;;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A low-level API to find the segment associated with a generated line/column (think, from a</span><span class="s3">\n </span><span class="s1">* stack trace). Line and column here are 0-based, unlike `originalPositionFor`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let traceSegment: (</span><span class="s3">\n  </span><span class="s1">map: TraceMap,</span><span class="s3">\n  </span><span class="s1">line: number,</span><span class="s3">\n  </span><span class="s1">column: number,</span><span class="s3">\n</span><span class="s1">) =&gt; Readonly&lt;SourceMapSegment&gt; | null;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A higher-level API to find the source/line/column associated with a generated line/column</span><span class="s3">\n </span><span class="s1">* (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in</span><span class="s3">\n </span><span class="s1">* `source-map` library.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let originalPositionFor: (</span><span class="s3">\n  </span><span class="s1">map: TraceMap,</span><span class="s3">\n  </span><span class="s1">needle: Needle,</span><span class="s3">\n</span><span class="s1">) =&gt; OriginalMapping | InvalidOriginalMapping;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Finds the generated line/column position of the provided source/line/column source position.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let generatedPositionFor: (</span><span class="s3">\n  </span><span class="s1">map: TraceMap,</span><span class="s3">\n  </span><span class="s1">needle: SourceNeedle,</span><span class="s3">\n</span><span class="s1">) =&gt; GeneratedMapping | InvalidGeneratedMapping;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Finds all generated line/column positions of the provided source/line/column source position.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let allGeneratedPositionsFor: (map: TraceMap, needle: SourceNeedle) =&gt; GeneratedMapping[];</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Iterates each mapping in generated position order.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let eachMapping: (map: TraceMap, cb: (mapping: EachMapping) =&gt; void) =&gt; void;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Retrieves the source content for a particular source, if its found. Returns null if not.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let sourceContentFor: (map: TraceMap, source: string) =&gt; string | null;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A helper that skips sorting of the input map's mappings array, which can be expensive for larger</span><span class="s3">\n </span><span class="s1">* maps.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let presortedDecodedMap: (map: DecodedSourceMap, mapUrl?: string) =&gt; TraceMap;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects</span><span class="s3">\n </span><span class="s1">* a sourcemap, or to JSON.stringify.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let decodedMap: (</span><span class="s3">\n  </span><span class="s1">map: TraceMap,</span><span class="s3">\n</span><span class="s1">) =&gt; Omit&lt;DecodedSourceMap, 'mappings'&gt; &amp; { mappings: readonly SourceMapSegment[][] };</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects</span><span class="s3">\n </span><span class="s1">* a sourcemap, or to JSON.stringify.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export let encodedMap: (map: TraceMap) =&gt; EncodedSourceMap;</span><span class="s3">\n\n</span><span class="s1">export { AnyMap } from './any-map';</span><span class="s3">\n\n</span><span class="s1">export class TraceMap implements SourceMap {</span><span class="s3">\n  </span><span class="s1">declare version: SourceMapV3['version'];</span><span class="s3">\n  </span><span class="s1">declare file: SourceMapV3['file'];</span><span class="s3">\n  </span><span class="s1">declare names: SourceMapV3['names'];</span><span class="s3">\n  </span><span class="s1">declare sourceRoot: SourceMapV3['sourceRoot'];</span><span class="s3">\n  </span><span class="s1">declare sources: SourceMapV3['sources'];</span><span class="s3">\n  </span><span class="s1">declare sourcesContent: SourceMapV3['sourcesContent'];</span><span class="s3">\n\n  </span><span class="s1">declare resolvedSources: string[];</span><span class="s3">\n  </span><span class="s1">private declare _encoded: string | undefined;</span><span class="s3">\n\n  </span><span class="s1">private declare _decoded: SourceMapSegment[][] | undefined;</span><span class="s3">\n  </span><span class="s1">private declare _decodedMemo: MemoState;</span><span class="s3">\n\n  </span><span class="s1">private declare _bySources: Source[] | undefined;</span><span class="s3">\n  </span><span class="s1">private declare _bySourceMemos: MemoState[] | undefined;</span><span class="s3">\n\n  </span><span class="s1">constructor(map: SourceMapInput, mapUrl?: string | null) {</span><span class="s3">\n    </span><span class="s1">const isString = typeof map === 'string';</span><span class="s3">\n\n    </span><span class="s1">if (!isString &amp;&amp; (map as unknown as { _decodedMemo: any })._decodedMemo) return map as TraceMap;</span><span class="s3">\n\n    </span><span class="s1">const parsed = (isString ? JSON.parse(map) : map) as DecodedSourceMap | EncodedSourceMap;</span><span class="s3">\n\n    </span><span class="s1">const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;</span><span class="s3">\n    </span><span class="s1">this.version = version;</span><span class="s3">\n    </span><span class="s1">this.file = file;</span><span class="s3">\n    </span><span class="s1">this.names = names;</span><span class="s3">\n    </span><span class="s1">this.sourceRoot = sourceRoot;</span><span class="s3">\n    </span><span class="s1">this.sources = sources;</span><span class="s3">\n    </span><span class="s1">this.sourcesContent = sourcesContent;</span><span class="s3">\n\n    </span><span class="s1">const from = resolve(sourceRoot || '', stripFilename(mapUrl));</span><span class="s3">\n    </span><span class="s1">this.resolvedSources = sources.map((s) =&gt; resolve(s || '', from));</span><span class="s3">\n\n    </span><span class="s1">const { mappings } = parsed;</span><span class="s3">\n    </span><span class="s1">if (typeof mappings === 'string') {</span><span class="s3">\n      </span><span class="s1">this._encoded = mappings;</span><span class="s3">\n      </span><span class="s1">this._decoded = undefined;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this._encoded = undefined;</span><span class="s3">\n      </span><span class="s1">this._decoded = maybeSort(mappings, isString);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._decodedMemo = memoizedState();</span><span class="s3">\n    </span><span class="s1">this._bySources = undefined;</span><span class="s3">\n    </span><span class="s1">this._bySourceMemos = undefined;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">encodedMappings = (map) =&gt; {</span><span class="s3">\n      </span><span class="s1">return (map._encoded ??= encode(map._decoded!));</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">decodedMappings = (map) =&gt; {</span><span class="s3">\n      </span><span class="s1">return (map._decoded ||= decode(map._encoded!));</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">traceSegment = (map, line, column) =&gt; {</span><span class="s3">\n      </span><span class="s1">const decoded = decodedMappings(map);</span><span class="s3">\n\n      </span><span class="s1">// It's common for parent source maps to have pointers to lines that have no</span><span class="s3">\n      </span><span class="s1">// mapping (like a </span><span class="s3">\&quot;</span><span class="s1">//# sourceMappingURL=</span><span class="s3">\&quot;</span><span class="s1">) at the end of the child file.</span><span class="s3">\n      </span><span class="s1">if (line &gt;= decoded.length) return null;</span><span class="s3">\n\n      </span><span class="s1">const segments = decoded[line];</span><span class="s3">\n      </span><span class="s1">const index = traceSegmentInternal(</span><span class="s3">\n        </span><span class="s1">segments,</span><span class="s3">\n        </span><span class="s1">map._decodedMemo,</span><span class="s3">\n        </span><span class="s1">line,</span><span class="s3">\n        </span><span class="s1">column,</span><span class="s3">\n        </span><span class="s1">GREATEST_LOWER_BOUND,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">return index === -1 ? null : segments[index];</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">originalPositionFor = (map, { line, column, bias }) =&gt; {</span><span class="s3">\n      </span><span class="s1">line--;</span><span class="s3">\n      </span><span class="s1">if (line &lt; 0) throw new Error(LINE_GTR_ZERO);</span><span class="s3">\n      </span><span class="s1">if (column &lt; 0) throw new Error(COL_GTR_EQ_ZERO);</span><span class="s3">\n\n      </span><span class="s1">const decoded = decodedMappings(map);</span><span class="s3">\n\n      </span><span class="s1">// It's common for parent source maps to have pointers to lines that have no</span><span class="s3">\n      </span><span class="s1">// mapping (like a </span><span class="s3">\&quot;</span><span class="s1">//# sourceMappingURL=</span><span class="s3">\&quot;</span><span class="s1">) at the end of the child file.</span><span class="s3">\n      </span><span class="s1">if (line &gt;= decoded.length) return OMapping(null, null, null, null);</span><span class="s3">\n\n      </span><span class="s1">const segments = decoded[line];</span><span class="s3">\n      </span><span class="s1">const index = traceSegmentInternal(</span><span class="s3">\n        </span><span class="s1">segments,</span><span class="s3">\n        </span><span class="s1">map._decodedMemo,</span><span class="s3">\n        </span><span class="s1">line,</span><span class="s3">\n        </span><span class="s1">column,</span><span class="s3">\n        </span><span class="s1">bias || GREATEST_LOWER_BOUND,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">if (index === -1) return OMapping(null, null, null, null);</span><span class="s3">\n\n      </span><span class="s1">const segment = segments[index];</span><span class="s3">\n      </span><span class="s1">if (segment.length === 1) return OMapping(null, null, null, null);</span><span class="s3">\n\n      </span><span class="s1">const { names, resolvedSources } = map;</span><span class="s3">\n      </span><span class="s1">return OMapping(</span><span class="s3">\n        </span><span class="s1">resolvedSources[segment[SOURCES_INDEX]],</span><span class="s3">\n        </span><span class="s1">segment[SOURCE_LINE] + 1,</span><span class="s3">\n        </span><span class="s1">segment[SOURCE_COLUMN],</span><span class="s3">\n        </span><span class="s1">segment.length === 5 ? names[segment[NAMES_INDEX]] : null,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">allGeneratedPositionsFor = (map, { source, line, column, bias }) =&gt; {</span><span class="s3">\n      </span><span class="s1">// SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.</span><span class="s3">\n      </span><span class="s1">return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">generatedPositionFor = (map, { source, line, column, bias }) =&gt; {</span><span class="s3">\n      </span><span class="s1">return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">eachMapping = (map, cb) =&gt; {</span><span class="s3">\n      </span><span class="s1">const decoded = decodedMappings(map);</span><span class="s3">\n      </span><span class="s1">const { names, resolvedSources } = map;</span><span class="s3">\n\n      </span><span class="s1">for (let i = 0; i &lt; decoded.length; i++) {</span><span class="s3">\n        </span><span class="s1">const line = decoded[i];</span><span class="s3">\n        </span><span class="s1">for (let j = 0; j &lt; line.length; j++) {</span><span class="s3">\n          </span><span class="s1">const seg = line[j];</span><span class="s3">\n\n          </span><span class="s1">const generatedLine = i + 1;</span><span class="s3">\n          </span><span class="s1">const generatedColumn = seg[0];</span><span class="s3">\n          </span><span class="s1">let source = null;</span><span class="s3">\n          </span><span class="s1">let originalLine = null;</span><span class="s3">\n          </span><span class="s1">let originalColumn = null;</span><span class="s3">\n          </span><span class="s1">let name = null;</span><span class="s3">\n          </span><span class="s1">if (seg.length !== 1) {</span><span class="s3">\n            </span><span class="s1">source = resolvedSources[seg[1]];</span><span class="s3">\n            </span><span class="s1">originalLine = seg[2] + 1;</span><span class="s3">\n            </span><span class="s1">originalColumn = seg[3];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (seg.length === 5) name = names[seg[4]];</span><span class="s3">\n\n          </span><span class="s1">cb({</span><span class="s3">\n            </span><span class="s1">generatedLine,</span><span class="s3">\n            </span><span class="s1">generatedColumn,</span><span class="s3">\n            </span><span class="s1">source,</span><span class="s3">\n            </span><span class="s1">originalLine,</span><span class="s3">\n            </span><span class="s1">originalColumn,</span><span class="s3">\n            </span><span class="s1">name,</span><span class="s3">\n          </span><span class="s1">} as EachMapping);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">sourceContentFor = (map, source) =&gt; {</span><span class="s3">\n      </span><span class="s1">const { sources, resolvedSources, sourcesContent } = map;</span><span class="s3">\n      </span><span class="s1">if (sourcesContent == null) return null;</span><span class="s3">\n\n      </span><span class="s1">let index = sources.indexOf(source);</span><span class="s3">\n      </span><span class="s1">if (index === -1) index = resolvedSources.indexOf(source);</span><span class="s3">\n\n      </span><span class="s1">return index === -1 ? null : sourcesContent[index];</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">presortedDecodedMap = (map, mapUrl) =&gt; {</span><span class="s3">\n      </span><span class="s1">const tracer = new TraceMap(clone(map, []), mapUrl);</span><span class="s3">\n      </span><span class="s1">tracer._decoded = map.mappings;</span><span class="s3">\n      </span><span class="s1">return tracer;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">decodedMap = (map) =&gt; {</span><span class="s3">\n      </span><span class="s1">return clone(map, decodedMappings(map));</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">encodedMap = (map) =&gt; {</span><span class="s3">\n      </span><span class="s1">return clone(map, encodedMappings(map));</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">function generatedPosition(</span><span class="s3">\n      </span><span class="s1">map: TraceMap,</span><span class="s3">\n      </span><span class="s1">source: string,</span><span class="s3">\n      </span><span class="s1">line: number,</span><span class="s3">\n      </span><span class="s1">column: number,</span><span class="s3">\n      </span><span class="s1">bias: Bias,</span><span class="s3">\n      </span><span class="s1">all: false,</span><span class="s3">\n    </span><span class="s1">): GeneratedMapping | InvalidGeneratedMapping;</span><span class="s3">\n    </span><span class="s1">function generatedPosition(</span><span class="s3">\n      </span><span class="s1">map: TraceMap,</span><span class="s3">\n      </span><span class="s1">source: string,</span><span class="s3">\n      </span><span class="s1">line: number,</span><span class="s3">\n      </span><span class="s1">column: number,</span><span class="s3">\n      </span><span class="s1">bias: Bias,</span><span class="s3">\n      </span><span class="s1">all: true,</span><span class="s3">\n    </span><span class="s1">): GeneratedMapping[];</span><span class="s3">\n    </span><span class="s1">function generatedPosition(</span><span class="s3">\n      </span><span class="s1">map: TraceMap,</span><span class="s3">\n      </span><span class="s1">source: string,</span><span class="s3">\n      </span><span class="s1">line: number,</span><span class="s3">\n      </span><span class="s1">column: number,</span><span class="s3">\n      </span><span class="s1">bias: Bias,</span><span class="s3">\n      </span><span class="s1">all: boolean,</span><span class="s3">\n    </span><span class="s1">): GeneratedMapping | InvalidGeneratedMapping | GeneratedMapping[] {</span><span class="s3">\n      </span><span class="s1">line--;</span><span class="s3">\n      </span><span class="s1">if (line &lt; 0) throw new Error(LINE_GTR_ZERO);</span><span class="s3">\n      </span><span class="s1">if (column &lt; 0) throw new Error(COL_GTR_EQ_ZERO);</span><span class="s3">\n\n      </span><span class="s1">const { sources, resolvedSources } = map;</span><span class="s3">\n      </span><span class="s1">let sourceIndex = sources.indexOf(source);</span><span class="s3">\n      </span><span class="s1">if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);</span><span class="s3">\n      </span><span class="s1">if (sourceIndex === -1) return all ? [] : GMapping(null, null);</span><span class="s3">\n\n      </span><span class="s1">const generated = (map._bySources ||= buildBySources(</span><span class="s3">\n        </span><span class="s1">decodedMappings(map),</span><span class="s3">\n        </span><span class="s1">(map._bySourceMemos = sources.map(memoizedState)),</span><span class="s3">\n      </span><span class="s1">));</span><span class="s3">\n\n      </span><span class="s1">const segments = generated[sourceIndex][line];</span><span class="s3">\n      </span><span class="s1">if (segments == null) return all ? [] : GMapping(null, null);</span><span class="s3">\n\n      </span><span class="s1">const memo = map._bySourceMemos![sourceIndex];</span><span class="s3">\n\n      </span><span class="s1">if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);</span><span class="s3">\n\n      </span><span class="s1">const index = traceSegmentInternal(segments, memo, line, column, bias);</span><span class="s3">\n      </span><span class="s1">if (index === -1) return GMapping(null, null);</span><span class="s3">\n\n      </span><span class="s1">const segment = segments[index];</span><span class="s3">\n      </span><span class="s1">return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function clone&lt;T extends string | readonly SourceMapSegment[][]&gt;(</span><span class="s3">\n  </span><span class="s1">map: TraceMap | DecodedSourceMap | EncodedSourceMap,</span><span class="s3">\n  </span><span class="s1">mappings: T,</span><span class="s3">\n</span><span class="s1">): T extends string ? EncodedSourceMap : DecodedSourceMap {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">version: map.version,</span><span class="s3">\n    </span><span class="s1">file: map.file,</span><span class="s3">\n    </span><span class="s1">names: map.names,</span><span class="s3">\n    </span><span class="s1">sourceRoot: map.sourceRoot,</span><span class="s3">\n    </span><span class="s1">sources: map.sources,</span><span class="s3">\n    </span><span class="s1">sourcesContent: map.sourcesContent,</span><span class="s3">\n    </span><span class="s1">mappings,</span><span class="s3">\n  </span><span class="s1">} as any;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function OMapping(source: null, line: null, column: null, name: null): InvalidOriginalMapping;</span><span class="s3">\n</span><span class="s1">function OMapping(</span><span class="s3">\n  </span><span class="s1">source: string,</span><span class="s3">\n  </span><span class="s1">line: number,</span><span class="s3">\n  </span><span class="s1">column: number,</span><span class="s3">\n  </span><span class="s1">name: string | null,</span><span class="s3">\n</span><span class="s1">): OriginalMapping;</span><span class="s3">\n</span><span class="s1">function OMapping(</span><span class="s3">\n  </span><span class="s1">source: string | null,</span><span class="s3">\n  </span><span class="s1">line: number | null,</span><span class="s3">\n  </span><span class="s1">column: number | null,</span><span class="s3">\n  </span><span class="s1">name: string | null,</span><span class="s3">\n</span><span class="s1">): OriginalMapping | InvalidOriginalMapping {</span><span class="s3">\n  </span><span class="s1">return { source, line, column, name } as any;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function GMapping(line: null, column: null): InvalidGeneratedMapping;</span><span class="s3">\n</span><span class="s1">function GMapping(line: number, column: number): GeneratedMapping;</span><span class="s3">\n</span><span class="s1">function GMapping(</span><span class="s3">\n  </span><span class="s1">line: number | null,</span><span class="s3">\n  </span><span class="s1">column: number | null,</span><span class="s3">\n</span><span class="s1">): GeneratedMapping | InvalidGeneratedMapping {</span><span class="s3">\n  </span><span class="s1">return { line, column } as any;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function traceSegmentInternal(</span><span class="s3">\n  </span><span class="s1">segments: SourceMapSegment[],</span><span class="s3">\n  </span><span class="s1">memo: MemoState,</span><span class="s3">\n  </span><span class="s1">line: number,</span><span class="s3">\n  </span><span class="s1">column: number,</span><span class="s3">\n  </span><span class="s1">bias: Bias,</span><span class="s3">\n</span><span class="s1">): number;</span><span class="s3">\n</span><span class="s1">function traceSegmentInternal(</span><span class="s3">\n  </span><span class="s1">segments: ReverseSegment[],</span><span class="s3">\n  </span><span class="s1">memo: MemoState,</span><span class="s3">\n  </span><span class="s1">line: number,</span><span class="s3">\n  </span><span class="s1">column: number,</span><span class="s3">\n  </span><span class="s1">bias: Bias,</span><span class="s3">\n</span><span class="s1">): number;</span><span class="s3">\n</span><span class="s1">function traceSegmentInternal(</span><span class="s3">\n  </span><span class="s1">segments: SourceMapSegment[] | ReverseSegment[],</span><span class="s3">\n  </span><span class="s1">memo: MemoState,</span><span class="s3">\n  </span><span class="s1">line: number,</span><span class="s3">\n  </span><span class="s1">column: number,</span><span class="s3">\n  </span><span class="s1">bias: Bias,</span><span class="s3">\n</span><span class="s1">): number {</span><span class="s3">\n  </span><span class="s1">let index = memoizedBinarySearch(segments, column, memo, line);</span><span class="s3">\n  </span><span class="s1">if (bsFound) {</span><span class="s3">\n    </span><span class="s1">index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);</span><span class="s3">\n  </span><span class="s1">} else if (bias === LEAST_UPPER_BOUND) index++;</span><span class="s3">\n\n  </span><span class="s1">if (index === -1 || index === segments.length) return -1;</span><span class="s3">\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function sliceGeneratedPositions(</span><span class="s3">\n  </span><span class="s1">segments: ReverseSegment[],</span><span class="s3">\n  </span><span class="s1">memo: MemoState,</span><span class="s3">\n  </span><span class="s1">line: number,</span><span class="s3">\n  </span><span class="s1">column: number,</span><span class="s3">\n  </span><span class="s1">bias: Bias,</span><span class="s3">\n</span><span class="s1">): GeneratedMapping[] {</span><span class="s3">\n  </span><span class="s1">let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);</span><span class="s3">\n\n  </span><span class="s1">// We ignored the bias when tracing the segment so that we're guarnateed to find the first (in</span><span class="s3">\n  </span><span class="s1">// insertion order) segment that matched. Even if we did respect the bias when tracing, we would</span><span class="s3">\n  </span><span class="s1">// still need to call `lowerBound()` to find the first segment, which is slower than just looking</span><span class="s3">\n  </span><span class="s1">// for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the</span><span class="s3">\n  </span><span class="s1">// binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to</span><span class="s3">\n  </span><span class="s1">// match LEAST_UPPER_BOUND.</span><span class="s3">\n  </span><span class="s1">if (!bsFound &amp;&amp; bias === LEAST_UPPER_BOUND) min++;</span><span class="s3">\n\n  </span><span class="s1">if (min === -1 || min === segments.length) return [];</span><span class="s3">\n\n  </span><span class="s1">// We may have found the segment that started at an earlier column. If this is the case, then we</span><span class="s3">\n  </span><span class="s1">// need to slice all generated segments that match _that_ column, because all such segments span</span><span class="s3">\n  </span><span class="s1">// to our desired column.</span><span class="s3">\n  </span><span class="s1">const matchedColumn = bsFound ? column : segments[min][COLUMN];</span><span class="s3">\n\n  </span><span class="s1">// The binary search is not guaranteed to find the lower bound when a match wasn't found.</span><span class="s3">\n  </span><span class="s1">if (!bsFound) min = lowerBound(segments, matchedColumn, min);</span><span class="s3">\n  </span><span class="s1">const max = upperBound(segments, matchedColumn, min);</span><span class="s3">\n\n  </span><span class="s1">const result = [];</span><span class="s3">\n  </span><span class="s1">for (; min &lt;= max; min++) {</span><span class="s3">\n    </span><span class="s1">const segment = segments[min];</span><span class="s3">\n    </span><span class="s1">result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;resolveUri&quot;</span><span class="s0">,</span><span class="s1">&quot;presortedDecodedMap&quot;</span><span class="s0">,</span><span class="s1">&quot;decodedMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;encodedMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;traceSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;originalPositionFor&quot;</span><span class="s0">,</span><span class="s1">&quot;generatedPositionFor&quot;</span><span class="s0">,</span><span class="s1">&quot;allGeneratedPositionsFor&quot;</span><span class="s0">,</span><span class="s1">&quot;eachMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceContentFor&quot;</span><span class="s0">,</span><span class="s1">&quot;decodedMap&quot;</span><span class="s0">,</span><span class="s1">&quot;encodedMap&quot;</span><span class="s0">,</span><span class="s1">&quot;encode&quot;</span><span class="s0">,</span><span class="s1">&quot;decode&quot;</span><span class="s0">,</span><span class="s1">&quot;bsFound&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>