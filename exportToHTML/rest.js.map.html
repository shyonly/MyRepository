<html>
<head>
<title>rest.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
rest.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_shadowUtils&quot;</span><span class="s0">,</span><span class="s1">&quot;buildRest&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;restIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;restIndexImpure&quot;</span><span class="s0">,</span><span class="s1">&quot;restLength&quot;</span><span class="s0">,</span><span class="s1">&quot;referencesRest&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingIdentifierEquals&quot;</span><span class="s0">,</span><span class="s1">&quot;outerBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpressionOptimisationVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;Scope&quot;</span><span class="s0">,</span><span class="s1">&quot;skip&quot;</span><span class="s0">,</span><span class="s1">&quot;Flow&quot;</span><span class="s0">,</span><span class="s1">&quot;isTypeCastExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;Function&quot;</span><span class="s0">,</span><span class="s1">&quot;oldNoOptimise&quot;</span><span class="s0">,</span><span class="s1">&quot;noOptimise&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;deopted&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;listKey&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;offset&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;grandparentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;argsOptEligible&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;isLVal&quot;</span><span class="s0">,</span><span class="s1">&quot;isForXStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isUpdateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isNewExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;isBaseType&quot;</span><span class="s0">,</span><span class="s1">&quot;candidates&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;cause&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;isSpreadElement&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;references&quot;</span><span class="s0">,</span><span class="s1">&quot;BindingIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;getParamsCount&quot;</span><span class="s0">,</span><span class="s1">&quot;count&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;hasRest&quot;</span><span class="s0">,</span><span class="s1">&quot;isRestElement&quot;</span><span class="s0">,</span><span class="s1">&quot;optimiseIndexGetter&quot;</span><span class="s0">,</span><span class="s1">&quot;argsId&quot;</span><span class="s0">,</span><span class="s1">&quot;offsetLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;numericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;isNumericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;binaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;isPure&quot;</span><span class="s0">,</span><span class="s1">&quot;temp&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifierBasedOnNode&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;ARGUMENTS&quot;</span><span class="s0">,</span><span class="s1">&quot;OFFSET&quot;</span><span class="s0">,</span><span class="s1">&quot;INDEX&quot;</span><span class="s0">,</span><span class="s1">&quot;REF&quot;</span><span class="s0">,</span><span class="s1">&quot;replacedParentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;offsetTestPath&quot;</span><span class="s0">,</span><span class="s1">&quot;valRes&quot;</span><span class="s0">,</span><span class="s1">&quot;evaluate&quot;</span><span class="s0">,</span><span class="s1">&quot;confident&quot;</span><span class="s0">,</span><span class="s1">&quot;buildUndefinedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;optimiseLengthGetter&quot;</span><span class="s0">,</span><span class="s1">&quot;convertFunctionRest&quot;</span><span class="s0">,</span><span class="s1">&quot;restPath&quot;</span><span class="s0">,</span><span class="s1">&quot;shadowedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;collectShadowedParamsNames&quot;</span><span class="s0">,</span><span class="s1">&quot;needsIIFE&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;needsOuterBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;iifeVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;buildScopeIIFE&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;rest&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;isPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;declar&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;rename&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;paramsCount&quot;</span><span class="s0">,</span><span class="s1">&quot;argumentsNode&quot;</span><span class="s0">,</span><span class="s1">&quot;getBindingIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;clonedArgsId&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;len&quot;</span><span class="s0">,</span><span class="s1">&quot;arrKey&quot;</span><span class="s0">,</span><span class="s1">&quot;arrLen&quot;</span><span class="s0">,</span><span class="s1">&quot;conditionalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;loop&quot;</span><span class="s0">,</span><span class="s1">&quot;ARRAY_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;ARRAY_LEN&quot;</span><span class="s0">,</span><span class="s1">&quot;START&quot;</span><span class="s0">,</span><span class="s1">&quot;ARRAY&quot;</span><span class="s0">,</span><span class="s1">&quot;KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;LEN&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;getEarliestCommonAncestorFrom&quot;</span><span class="s0">,</span><span class="s1">&quot;getStatementParent&quot;</span><span class="s0">,</span><span class="s1">&quot;findParent&quot;</span><span class="s0">,</span><span class="s1">&quot;isLoop&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;insertBefore&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/rest.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { template, types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath, Visitor } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">iifeVisitor,</span><span class="s3">\n  </span><span class="s1">collectShadowedParamsNames,</span><span class="s3">\n  </span><span class="s1">buildScopeIIFE,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./shadow-utils.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const buildRest = template.statement(`</span><span class="s3">\n  </span><span class="s1">for (var LEN = ARGUMENTS.length,</span><span class="s3">\n           </span><span class="s1">ARRAY = new Array(ARRAY_LEN),</span><span class="s3">\n           </span><span class="s1">KEY = START;</span><span class="s3">\n       </span><span class="s1">KEY &lt; LEN;</span><span class="s3">\n       </span><span class="s1">KEY++) {</span><span class="s3">\n    </span><span class="s1">ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">`);</span><span class="s3">\n\n</span><span class="s1">const restIndex = template.expression(`</span><span class="s3">\n  </span><span class="s1">(INDEX &lt; OFFSET || ARGUMENTS.length &lt;= INDEX) ? undefined : ARGUMENTS[INDEX]</span><span class="s3">\n</span><span class="s1">`);</span><span class="s3">\n\n</span><span class="s1">const restIndexImpure = template.expression(`</span><span class="s3">\n  </span><span class="s1">REF = INDEX, (REF &lt; OFFSET || ARGUMENTS.length &lt;= REF) ? undefined : ARGUMENTS[REF]</span><span class="s3">\n</span><span class="s1">`);</span><span class="s3">\n\n</span><span class="s1">const restLength = template.expression(`</span><span class="s3">\n  </span><span class="s1">ARGUMENTS.length &lt;= OFFSET ? 0 : ARGUMENTS.length - OFFSET</span><span class="s3">\n</span><span class="s1">`);</span><span class="s3">\n\n</span><span class="s1">function referencesRest(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Identifier | t.JSXIdentifier&gt;,</span><span class="s3">\n  </span><span class="s1">state: State,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (path.node.name === state.name) {</span><span class="s3">\n    </span><span class="s1">// Check rest parameter is not shadowed by a binding in another scope.</span><span class="s3">\n    </span><span class="s1">return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type Candidate = {</span><span class="s3">\n  </span><span class="s1">cause: </span><span class="s3">\&quot;</span><span class="s1">argSpread</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">indexGetter</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">lengthGetter</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Identifier | t.JSXIdentifier&gt;;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">type State = {</span><span class="s3">\n  </span><span class="s1">references: NodePath&lt;t.Identifier | t.JSXIdentifier&gt;[];</span><span class="s3">\n  </span><span class="s1">offset: number;</span><span class="s3">\n\n  </span><span class="s1">argumentsNode: t.Identifier;</span><span class="s3">\n  </span><span class="s1">outerBinding: t.Identifier;</span><span class="s3">\n\n  </span><span class="s1">// candidate member expressions we could optimise if there are no other references</span><span class="s3">\n  </span><span class="s1">candidates: Candidate[];</span><span class="s3">\n\n  </span><span class="s1">// local rest binding name</span><span class="s3">\n  </span><span class="s1">name: string;</span><span class="s3">\n\n  </span><span class="s1">/*</span><span class="s3">\n  </span><span class="s1">It may be possible to optimize the output code in certain ways, such as</span><span class="s3">\n  </span><span class="s1">not generating code to initialize an array (perhaps substituting direct</span><span class="s3">\n  </span><span class="s1">references to arguments[i] or arguments.length for reads of the</span><span class="s3">\n  </span><span class="s1">corresponding rest parameter property) or positioning the initialization</span><span class="s3">\n  </span><span class="s1">code so that it may not have to execute depending on runtime conditions.</span><span class="s3">\n\n  </span><span class="s1">This property tracks eligibility for optimization. </span><span class="s3">\&quot;</span><span class="s1">deopted</span><span class="s3">\&quot; </span><span class="s1">means give up</span><span class="s3">\n  </span><span class="s1">and don't perform optimization. For example, when any of rest's elements /</span><span class="s3">\n  </span><span class="s1">properties is assigned to at the top level, or referenced at all in a</span><span class="s3">\n  </span><span class="s1">nested function.</span><span class="s3">\n  </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">deopted: boolean;</span><span class="s3">\n  </span><span class="s1">noOptimise?: boolean;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const memberExpressionOptimisationVisitor: Visitor&lt;State&gt; = {</span><span class="s3">\n  </span><span class="s1">Scope(path, state) {</span><span class="s3">\n    </span><span class="s1">// check if this scope has a local binding that will shadow the rest parameter</span><span class="s3">\n    </span><span class="s1">if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {</span><span class="s3">\n      </span><span class="s1">path.skip();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">Flow(path: NodePath&lt;t.Flow&gt;) {</span><span class="s3">\n    </span><span class="s1">// Do not skip TypeCastExpressions as the contain valid non flow code</span><span class="s3">\n    </span><span class="s1">if (path.isTypeCastExpression()) return;</span><span class="s3">\n    </span><span class="s1">// don't touch reference in type annotations</span><span class="s3">\n    </span><span class="s1">path.skip();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">Function(path, state) {</span><span class="s3">\n    </span><span class="s1">// Detect whether any reference to rest is contained in nested functions to</span><span class="s3">\n    </span><span class="s1">// determine if deopt is necessary.</span><span class="s3">\n    </span><span class="s1">const oldNoOptimise = state.noOptimise;</span><span class="s3">\n    </span><span class="s1">state.noOptimise = true;</span><span class="s3">\n    </span><span class="s1">path.traverse(memberExpressionOptimisationVisitor, state);</span><span class="s3">\n    </span><span class="s1">state.noOptimise = oldNoOptimise;</span><span class="s3">\n\n    </span><span class="s1">// Skip because optimizing references to rest would refer to the `arguments`</span><span class="s3">\n    </span><span class="s1">// of the nested function.</span><span class="s3">\n    </span><span class="s1">path.skip();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">ReferencedIdentifier(path, state) {</span><span class="s3">\n    </span><span class="s1">const { node } = path;</span><span class="s3">\n\n    </span><span class="s1">// we can't guarantee the purity of arguments</span><span class="s3">\n    </span><span class="s1">if (node.name === </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">state.deopted = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// is this a referenced identifier and is it referencing the rest parameter?</span><span class="s3">\n    </span><span class="s1">if (!referencesRest(path, state)) return;</span><span class="s3">\n\n    </span><span class="s1">if (state.noOptimise) {</span><span class="s3">\n      </span><span class="s1">state.deopted = true;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const { parentPath } = path;</span><span class="s3">\n\n      </span><span class="s1">// Is this identifier the right hand side of a default parameter?</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">parentPath.listKey === </span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">(parentPath.key as number) &lt; state.offset</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// ex: `args[0]`</span><span class="s3">\n      </span><span class="s1">// ex: `args.whatever`</span><span class="s3">\n      </span><span class="s1">if (parentPath.isMemberExpression({ object: node })) {</span><span class="s3">\n        </span><span class="s1">const grandparentPath = parentPath.parentPath;</span><span class="s3">\n\n        </span><span class="s1">const argsOptEligible =</span><span class="s3">\n          </span><span class="s1">!state.deopted &amp;&amp;</span><span class="s3">\n          </span><span class="s1">!(</span><span class="s3">\n            </span><span class="s1">// ex: `args[0] = </span><span class="s3">\&quot;</span><span class="s1">whatever</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n            </span><span class="s1">(</span><span class="s3">\n              </span><span class="s1">(grandparentPath.isAssignmentExpression() &amp;&amp;</span><span class="s3">\n                </span><span class="s1">parentPath.node === grandparentPath.node.left) ||</span><span class="s3">\n              </span><span class="s1">// ex: `[args[0]] = [</span><span class="s3">\&quot;</span><span class="s1">whatever</span><span class="s3">\&quot;</span><span class="s1">]`</span><span class="s3">\n              </span><span class="s1">grandparentPath.isLVal() ||</span><span class="s3">\n              </span><span class="s1">// ex: `for (rest[0] in this)`</span><span class="s3">\n              </span><span class="s1">// ex: `for (rest[0] of this)`</span><span class="s3">\n              </span><span class="s1">grandparentPath.isForXStatement() ||</span><span class="s3">\n              </span><span class="s1">// ex: `++args[0]`</span><span class="s3">\n              </span><span class="s1">// ex: `args[0]--`</span><span class="s3">\n              </span><span class="s1">grandparentPath.isUpdateExpression() ||</span><span class="s3">\n              </span><span class="s1">// ex: `delete args[0]`</span><span class="s3">\n              </span><span class="s1">grandparentPath.isUnaryExpression({ operator: </span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot; </span><span class="s1">}) ||</span><span class="s3">\n              </span><span class="s1">// ex: `args[0]()`</span><span class="s3">\n              </span><span class="s1">// ex: `new args[0]()`</span><span class="s3">\n              </span><span class="s1">// ex: `new args[0]`</span><span class="s3">\n              </span><span class="s1">((grandparentPath.isCallExpression() ||</span><span class="s3">\n                </span><span class="s1">grandparentPath.isNewExpression()) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">parentPath.node === grandparentPath.node.callee)</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">if (argsOptEligible) {</span><span class="s3">\n          </span><span class="s1">if (parentPath.node.computed) {</span><span class="s3">\n            </span><span class="s1">// if we know that this member expression is referencing a number then</span><span class="s3">\n            </span><span class="s1">// we can safely optimise it</span><span class="s3">\n            </span><span class="s1">if (parentPath.get(</span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">).isBaseType(</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n              </span><span class="s1">state.candidates.push({ cause: </span><span class="s3">\&quot;</span><span class="s1">indexGetter</span><span class="s3">\&quot;</span><span class="s1">, path });</span><span class="s3">\n              </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else if (</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error .length must not be a private name</span><span class="s3">\n            </span><span class="s1">parentPath.node.property.name === </span><span class="s3">\&quot;</span><span class="s1">length</span><span class="s3">\&quot;\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">// args.length</span><span class="s3">\n            </span><span class="s1">state.candidates.push({ cause: </span><span class="s3">\&quot;</span><span class="s1">lengthGetter</span><span class="s3">\&quot;</span><span class="s1">, path });</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// we can only do these optimizations if the rest variable would match</span><span class="s3">\n      </span><span class="s1">// the arguments exactly</span><span class="s3">\n      </span><span class="s1">// optimise single spread args in calls</span><span class="s3">\n      </span><span class="s1">// ex: fn(...args)</span><span class="s3">\n      </span><span class="s1">if (state.offset === 0 &amp;&amp; parentPath.isSpreadElement()) {</span><span class="s3">\n        </span><span class="s1">const call = parentPath.parentPath;</span><span class="s3">\n        </span><span class="s1">if (call.isCallExpression() &amp;&amp; call.node.arguments.length === 1) {</span><span class="s3">\n          </span><span class="s1">state.candidates.push({ cause: </span><span class="s3">\&quot;</span><span class="s1">argSpread</span><span class="s3">\&quot;</span><span class="s1">, path });</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">state.references.push(path);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Deopt on use of a binding identifier with the same name as our rest param.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* See https://github.com/babel/babel/issues/2091</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">BindingIdentifier(path, state) {</span><span class="s3">\n    </span><span class="s1">if (referencesRest(path, state)) {</span><span class="s3">\n      </span><span class="s1">state.deopted = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function getParamsCount(node: t.Function) {</span><span class="s3">\n  </span><span class="s1">let count = node.params.length;</span><span class="s3">\n  </span><span class="s1">// skip the first parameter if it is a TypeScript 'this parameter'</span><span class="s3">\n  </span><span class="s1">if (count &gt; 0 &amp;&amp; t.isIdentifier(node.params[0], { name: </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot; </span><span class="s1">})) {</span><span class="s3">\n    </span><span class="s1">count -= 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return count;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function hasRest(node: t.Function) {</span><span class="s3">\n  </span><span class="s1">const length = node.params.length;</span><span class="s3">\n  </span><span class="s1">return length &gt; 0 &amp;&amp; t.isRestElement(node.params[length - 1]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function optimiseIndexGetter(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Identifier | t.JSXIdentifier&gt;,</span><span class="s3">\n  </span><span class="s1">argsId: t.Identifier,</span><span class="s3">\n  </span><span class="s1">offset: number,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const offsetLiteral = t.numericLiteral(offset);</span><span class="s3">\n  </span><span class="s1">let index;</span><span class="s3">\n  </span><span class="s1">const parent = path.parent as t.MemberExpression;</span><span class="s3">\n\n  </span><span class="s1">if (t.isNumericLiteral(parent.property)) {</span><span class="s3">\n    </span><span class="s1">index = t.numericLiteral(parent.property.value + offset);</span><span class="s3">\n  </span><span class="s1">} else if (offset === 0) {</span><span class="s3">\n    </span><span class="s1">// Avoid unnecessary '+ 0'</span><span class="s3">\n    </span><span class="s1">index = parent.property;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">index = t.binaryExpression(</span><span class="s3">\n      \&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">parent.property,</span><span class="s3">\n      </span><span class="s1">t.cloneNode(offsetLiteral),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { scope, parentPath } = path;</span><span class="s3">\n  </span><span class="s1">if (!scope.isPure(index)) {</span><span class="s3">\n    </span><span class="s1">const temp = scope.generateUidIdentifierBasedOnNode(index);</span><span class="s3">\n    </span><span class="s1">scope.push({ id: temp, kind: </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">parentPath.replaceWith(</span><span class="s3">\n      </span><span class="s1">restIndexImpure({</span><span class="s3">\n        </span><span class="s1">ARGUMENTS: argsId,</span><span class="s3">\n        </span><span class="s1">OFFSET: offsetLiteral,</span><span class="s3">\n        </span><span class="s1">INDEX: index,</span><span class="s3">\n        </span><span class="s1">REF: t.cloneNode(temp),</span><span class="s3">\n      </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">parentPath.replaceWith(</span><span class="s3">\n      </span><span class="s1">restIndex({</span><span class="s3">\n        </span><span class="s1">ARGUMENTS: argsId,</span><span class="s3">\n        </span><span class="s1">OFFSET: offsetLiteral,</span><span class="s3">\n        </span><span class="s1">INDEX: index,</span><span class="s3">\n      </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const replacedParentPath = parentPath as NodePath&lt;t.ConditionalExpression&gt;;</span><span class="s3">\n\n    </span><span class="s1">// See if we can statically evaluate the first test (i.e. index &lt; offset)</span><span class="s3">\n    </span><span class="s1">// and optimize the AST accordingly.</span><span class="s3">\n    </span><span class="s1">const offsetTestPath = replacedParentPath.get(</span><span class="s3">\n      \&quot;</span><span class="s1">test</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">) as NodePath&lt;t.BinaryExpression&gt;;</span><span class="s3">\n    </span><span class="s1">const valRes = offsetTestPath.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">).evaluate();</span><span class="s3">\n    </span><span class="s1">if (valRes.confident) {</span><span class="s3">\n      </span><span class="s1">if (valRes.value === true) {</span><span class="s3">\n        </span><span class="s1">replacedParentPath.replaceWith(scope.buildUndefinedNode());</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">offsetTestPath.replaceWith(offsetTestPath.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function optimiseLengthGetter(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Identifier | t.JSXIdentifier&gt;,</span><span class="s3">\n  </span><span class="s1">argsId: t.Identifier,</span><span class="s3">\n  </span><span class="s1">offset: number,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (offset) {</span><span class="s3">\n    </span><span class="s1">path.parentPath.replaceWith(</span><span class="s3">\n      </span><span class="s1">restLength({</span><span class="s3">\n        </span><span class="s1">ARGUMENTS: argsId,</span><span class="s3">\n        </span><span class="s1">OFFSET: t.numericLiteral(offset),</span><span class="s3">\n      </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">path.replaceWith(argsId);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default function convertFunctionRest(path: NodePath&lt;t.Function&gt;) {</span><span class="s3">\n  </span><span class="s1">const { node, scope } = path;</span><span class="s3">\n  </span><span class="s1">if (!hasRest(node)) return false;</span><span class="s3">\n\n  </span><span class="s1">const restPath = path.get(</span><span class="s3">\n    </span><span class="s1">`params.${node.params.length - 1}.argument`,</span><span class="s3">\n  </span><span class="s1">) as NodePath&lt;t.Pattern | t.Identifier&gt;;</span><span class="s3">\n\n  </span><span class="s1">if (!restPath.isIdentifier()) {</span><span class="s3">\n    </span><span class="s1">const shadowedParams = new Set&lt;string&gt;();</span><span class="s3">\n    </span><span class="s1">collectShadowedParamsNames(restPath, path.scope, shadowedParams);</span><span class="s3">\n\n    </span><span class="s1">let needsIIFE = shadowedParams.size &gt; 0;</span><span class="s3">\n    </span><span class="s1">if (!needsIIFE) {</span><span class="s3">\n      </span><span class="s1">const state = {</span><span class="s3">\n        </span><span class="s1">needsOuterBinding: false,</span><span class="s3">\n        </span><span class="s1">scope,</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">restPath.traverse(iifeVisitor, state);</span><span class="s3">\n      </span><span class="s1">needsIIFE = state.needsOuterBinding;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (needsIIFE) {</span><span class="s3">\n      </span><span class="s1">path.ensureBlock();</span><span class="s3">\n      </span><span class="s1">path.set(</span><span class="s3">\n        \&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">t.blockStatement([buildScopeIIFE(shadowedParams, path.node.body)]),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let rest = restPath.node;</span><span class="s3">\n  </span><span class="s1">node.params.pop(); // This returns 'rest'</span><span class="s3">\n\n  </span><span class="s1">if (t.isPattern(rest)) {</span><span class="s3">\n    </span><span class="s1">const pattern = rest;</span><span class="s3">\n    </span><span class="s1">rest = scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">ref</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">const declar = t.variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n      </span><span class="s1">t.variableDeclarator(pattern, rest),</span><span class="s3">\n    </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">path.ensureBlock();</span><span class="s3">\n    </span><span class="s1">(node.body as t.BlockStatement).body.unshift(declar);</span><span class="s3">\n  </span><span class="s1">} else if (rest.name === </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">scope.rename(rest.name);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const argsId = t.identifier(</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const paramsCount = getParamsCount(node);</span><span class="s3">\n\n  </span><span class="s1">// check and optimise for extremely common cases</span><span class="s3">\n  </span><span class="s1">const state: State = {</span><span class="s3">\n    </span><span class="s1">references: [],</span><span class="s3">\n    </span><span class="s1">offset: paramsCount,</span><span class="s3">\n    </span><span class="s1">argumentsNode: argsId,</span><span class="s3">\n    </span><span class="s1">outerBinding: scope.getBindingIdentifier(rest.name),</span><span class="s3">\n    </span><span class="s1">candidates: [],</span><span class="s3">\n    </span><span class="s1">name: rest.name,</span><span class="s3">\n    </span><span class="s1">deopted: false,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">path.traverse(memberExpressionOptimisationVisitor, state);</span><span class="s3">\n\n  </span><span class="s1">// There are only </span><span class="s3">\&quot;</span><span class="s1">shorthand</span><span class="s3">\&quot; </span><span class="s1">references</span><span class="s3">\n  </span><span class="s1">if (!state.deopted &amp;&amp; !state.references.length) {</span><span class="s3">\n    </span><span class="s1">for (const { path, cause } of state.candidates) {</span><span class="s3">\n      </span><span class="s1">const clonedArgsId = t.cloneNode(argsId);</span><span class="s3">\n      </span><span class="s1">switch (cause) {</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">indexGetter</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n          </span><span class="s1">optimiseIndexGetter(path, clonedArgsId, state.offset);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">lengthGetter</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n          </span><span class="s1">optimiseLengthGetter(path, clonedArgsId, state.offset);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">path.replaceWith(clonedArgsId);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">state.references.push(...state.candidates.map(({ path }) =&gt; path));</span><span class="s3">\n\n  </span><span class="s1">const start = t.numericLiteral(paramsCount);</span><span class="s3">\n  </span><span class="s1">const key = scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const len = scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">len</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">let arrKey, arrLen;</span><span class="s3">\n  </span><span class="s1">if (paramsCount) {</span><span class="s3">\n    </span><span class="s1">// this method has additional params, so we need to subtract</span><span class="s3">\n    </span><span class="s1">// the index of the current argument position from the</span><span class="s3">\n    </span><span class="s1">// position in the array that we want to populate</span><span class="s3">\n    </span><span class="s1">arrKey = t.binaryExpression(</span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">, t.cloneNode(key), t.cloneNode(start));</span><span class="s3">\n\n    </span><span class="s1">// we need to work out the size of the array that we're</span><span class="s3">\n    </span><span class="s1">// going to store all the rest parameters</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// we need to add a check to avoid constructing the array</span><span class="s3">\n    </span><span class="s1">// with &lt;0 if there are less arguments than params as it'll</span><span class="s3">\n    </span><span class="s1">// cause an error</span><span class="s3">\n    </span><span class="s1">arrLen = t.conditionalExpression(</span><span class="s3">\n      </span><span class="s1">t.binaryExpression(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">, t.cloneNode(len), t.cloneNode(start)),</span><span class="s3">\n      </span><span class="s1">t.binaryExpression(</span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">, t.cloneNode(len), t.cloneNode(start)),</span><span class="s3">\n      </span><span class="s1">t.numericLiteral(0),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">arrKey = t.identifier(key.name);</span><span class="s3">\n    </span><span class="s1">arrLen = t.identifier(len.name);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const loop = buildRest({</span><span class="s3">\n    </span><span class="s1">ARGUMENTS: argsId,</span><span class="s3">\n    </span><span class="s1">ARRAY_KEY: arrKey,</span><span class="s3">\n    </span><span class="s1">ARRAY_LEN: arrLen,</span><span class="s3">\n    </span><span class="s1">START: start,</span><span class="s3">\n    </span><span class="s1">ARRAY: rest,</span><span class="s3">\n    </span><span class="s1">KEY: key,</span><span class="s3">\n    </span><span class="s1">LEN: len,</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">if (state.deopted) {</span><span class="s3">\n    </span><span class="s1">(node.body as t.BlockStatement).body.unshift(loop);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">let target = path</span><span class="s3">\n      </span><span class="s1">.getEarliestCommonAncestorFrom(state.references)</span><span class="s3">\n      </span><span class="s1">.getStatementParent();</span><span class="s3">\n\n    </span><span class="s1">// don't perform the allocation inside a loop</span><span class="s3">\n    </span><span class="s1">target.findParent(path =&gt; {</span><span class="s3">\n      </span><span class="s1">if (path.isLoop()) {</span><span class="s3">\n        </span><span class="s1">target = path;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// Stop crawling up if this is a function.</span><span class="s3">\n        </span><span class="s1">return path.isFunction();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">target.insertBefore(loop);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>