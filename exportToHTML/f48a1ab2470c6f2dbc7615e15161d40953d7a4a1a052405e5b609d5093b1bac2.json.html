<html>
<head>
<title>f48a1ab2470c6f2dbc7615e15161d40953d7a4a1a052405e5b609d5093b1bac2.json</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #cf8e6d;}
.s3 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
f48a1ab2470c6f2dbc7615e15161d40953d7a4a1a052405e5b609d5093b1bac2.json</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;ast&quot;</span><span class="s0">:</span><span class="s2">null</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">:</span><span class="s1">&quot;/* eslint-disable no-undefined,no-param-reassign,no-shadow */</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Throttle execution of a function. Especially useful for rate limiting</span><span class="s2">\n </span><span class="s1">* execution of handlers on events like resize and scroll.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.</span><span class="s2">\n </span><span class="s1">* @param  {Boolean}   [noTrailing]   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the</span><span class="s2">\n </span><span class="s1">*                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time</span><span class="s2">\n </span><span class="s1">*                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,</span><span class="s2">\n </span><span class="s1">*                                    the internal counter is reset)</span><span class="s2">\n </span><span class="s1">* @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,</span><span class="s2">\n </span><span class="s1">*                                    to `callback` when the throttled-function is executed.</span><span class="s2">\n </span><span class="s1">* @param  {Boolean}   [debounceMode] If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),</span><span class="s2">\n </span><span class="s1">*                                    schedule `callback` to execute after `delay` ms.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @return {Function}  A new, throttled, function.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">module.exports = function (delay, noTrailing, callback, debounceMode) {</span><span class="s2">\n  </span><span class="s1">// After wrapper has stopped being called, this timeout ensures that</span><span class="s2">\n  </span><span class="s1">// `callback` is executed at the proper times in `throttle` and `end`</span><span class="s2">\n  </span><span class="s1">// debounce modes.</span><span class="s2">\n  </span><span class="s1">var timeoutID;</span><span class="s2">\n\n  </span><span class="s1">// Keep track of the last time `callback` was executed.</span><span class="s2">\n  </span><span class="s1">var lastExec = 0;</span><span class="s2">\n\n  </span><span class="s1">// `noTrailing` defaults to falsy.</span><span class="s2">\n  </span><span class="s1">if (typeof noTrailing !== 'boolean') {</span><span class="s2">\n    </span><span class="s1">debounceMode = callback;</span><span class="s2">\n    </span><span class="s1">callback = noTrailing;</span><span class="s2">\n    </span><span class="s1">noTrailing = undefined;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// The `wrapper` function encapsulates all of the throttling / debouncing</span><span class="s2">\n  </span><span class="s1">// functionality and when executed will limit the rate at which `callback`</span><span class="s2">\n  </span><span class="s1">// is executed.</span><span class="s2">\n  </span><span class="s1">function wrapper() {</span><span class="s2">\n    </span><span class="s1">var self = this;</span><span class="s2">\n    </span><span class="s1">var elapsed = Number(new Date()) - lastExec;</span><span class="s2">\n    </span><span class="s1">var args = arguments;</span><span class="s2">\n\n    </span><span class="s1">// Execute `callback` and update the `lastExec` timestamp.</span><span class="s2">\n    </span><span class="s1">function exec() {</span><span class="s2">\n      </span><span class="s1">lastExec = Number(new Date());</span><span class="s2">\n      </span><span class="s1">callback.apply(self, args);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// If `debounceMode` is true (at begin) this is used to clear the flag</span><span class="s2">\n    </span><span class="s1">// to allow future `callback` executions.</span><span class="s2">\n    </span><span class="s1">function clear() {</span><span class="s2">\n      </span><span class="s1">timeoutID = undefined;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (debounceMode &amp;&amp; !timeoutID) {</span><span class="s2">\n      </span><span class="s1">// Since `wrapper` is being called for the first time and</span><span class="s2">\n      </span><span class="s1">// `debounceMode` is true (at begin), execute `callback`.</span><span class="s2">\n      </span><span class="s1">exec();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Clear any existing timeout.</span><span class="s2">\n    </span><span class="s1">if (timeoutID) {</span><span class="s2">\n      </span><span class="s1">clearTimeout(timeoutID);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (debounceMode === undefined &amp;&amp; elapsed &gt; delay) {</span><span class="s2">\n      </span><span class="s1">// In throttle mode, if `delay` time has been exceeded, execute</span><span class="s2">\n      </span><span class="s1">// `callback`.</span><span class="s2">\n      </span><span class="s1">exec();</span><span class="s2">\n    </span><span class="s1">} else if (noTrailing !== true) {</span><span class="s2">\n      </span><span class="s1">// In trailing throttle mode, since `delay` time has not been</span><span class="s2">\n      </span><span class="s1">// exceeded, schedule `callback` to execute `delay` ms after most</span><span class="s2">\n      </span><span class="s1">// recent execution.</span><span class="s2">\n      </span><span class="s1">//</span><span class="s2">\n      </span><span class="s1">// If `debounceMode` is true (at begin), schedule `clear` to execute</span><span class="s2">\n      </span><span class="s1">// after `delay` ms.</span><span class="s2">\n      </span><span class="s1">//</span><span class="s2">\n      </span><span class="s1">// If `debounceMode` is false (at end), schedule `callback` to</span><span class="s2">\n      </span><span class="s1">// execute after `delay` ms.</span><span class="s2">\n      </span><span class="s1">timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Return the wrapper function.</span><span class="s2">\n  </span><span class="s1">return wrapper;</span><span class="s2">\n</span><span class="s1">};&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">:{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s3">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;delay&quot;</span><span class="s0">,</span><span class="s1">&quot;noTrailing&quot;</span><span class="s0">,</span><span class="s1">&quot;callback&quot;</span><span class="s0">,</span><span class="s1">&quot;debounceMode&quot;</span><span class="s0">,</span><span class="s1">&quot;timeoutID&quot;</span><span class="s0">,</span><span class="s1">&quot;lastExec&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapper&quot;</span><span class="s0">,</span><span class="s1">&quot;self&quot;</span><span class="s0">,</span><span class="s1">&quot;elapsed&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;exec&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;clear&quot;</span><span class="s0">,</span><span class="s1">&quot;clearTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;E:/work/project/manager/vue/node_modules/throttle-debounce/throttle.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/* eslint-disable no-undefined,no-param-reassign,no-shadow */</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Throttle execution of a function. Especially useful for rate limiting</span><span class="s2">\n </span><span class="s1">* execution of handlers on events like resize and scroll.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.</span><span class="s2">\n </span><span class="s1">* @param  {Boolean}   [noTrailing]   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the</span><span class="s2">\n </span><span class="s1">*                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time</span><span class="s2">\n </span><span class="s1">*                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,</span><span class="s2">\n </span><span class="s1">*                                    the internal counter is reset)</span><span class="s2">\n </span><span class="s1">* @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,</span><span class="s2">\n </span><span class="s1">*                                    to `callback` when the throttled-function is executed.</span><span class="s2">\n </span><span class="s1">* @param  {Boolean}   [debounceMode] If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),</span><span class="s2">\n </span><span class="s1">*                                    schedule `callback` to execute after `delay` ms.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @return {Function}  A new, throttled, function.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">module.exports = function ( delay, noTrailing, callback, debounceMode ) {</span><span class="s2">\n\n\t</span><span class="s1">// After wrapper has stopped being called, this timeout ensures that</span><span class="s2">\n\t</span><span class="s1">// `callback` is executed at the proper times in `throttle` and `end`</span><span class="s2">\n\t</span><span class="s1">// debounce modes.</span><span class="s2">\n\t</span><span class="s1">var timeoutID;</span><span class="s2">\n\n\t</span><span class="s1">// Keep track of the last time `callback` was executed.</span><span class="s2">\n\t</span><span class="s1">var lastExec = 0;</span><span class="s2">\n\n\t</span><span class="s1">// `noTrailing` defaults to falsy.</span><span class="s2">\n\t</span><span class="s1">if ( typeof noTrailing !== 'boolean' ) {</span><span class="s2">\n\t\t</span><span class="s1">debounceMode = callback;</span><span class="s2">\n\t\t</span><span class="s1">callback = noTrailing;</span><span class="s2">\n\t\t</span><span class="s1">noTrailing = undefined;</span><span class="s2">\n\t</span><span class="s1">}</span><span class="s2">\n\n\t</span><span class="s1">// The `wrapper` function encapsulates all of the throttling / debouncing</span><span class="s2">\n\t</span><span class="s1">// functionality and when executed will limit the rate at which `callback`</span><span class="s2">\n\t</span><span class="s1">// is executed.</span><span class="s2">\n\t</span><span class="s1">function wrapper () {</span><span class="s2">\n\n\t\t</span><span class="s1">var self = this;</span><span class="s2">\n\t\t</span><span class="s1">var elapsed = Number(new Date()) - lastExec;</span><span class="s2">\n\t\t</span><span class="s1">var args = arguments;</span><span class="s2">\n\n\t\t</span><span class="s1">// Execute `callback` and update the `lastExec` timestamp.</span><span class="s2">\n\t\t</span><span class="s1">function exec () {</span><span class="s2">\n\t\t\t</span><span class="s1">lastExec = Number(new Date());</span><span class="s2">\n\t\t\t</span><span class="s1">callback.apply(self, args);</span><span class="s2">\n\t\t</span><span class="s1">}</span><span class="s2">\n\n\t\t</span><span class="s1">// If `debounceMode` is true (at begin) this is used to clear the flag</span><span class="s2">\n\t\t</span><span class="s1">// to allow future `callback` executions.</span><span class="s2">\n\t\t</span><span class="s1">function clear () {</span><span class="s2">\n\t\t\t</span><span class="s1">timeoutID = undefined;</span><span class="s2">\n\t\t</span><span class="s1">}</span><span class="s2">\n\n\t\t</span><span class="s1">if ( debounceMode &amp;&amp; !timeoutID ) {</span><span class="s2">\n\t\t\t</span><span class="s1">// Since `wrapper` is being called for the first time and</span><span class="s2">\n\t\t\t</span><span class="s1">// `debounceMode` is true (at begin), execute `callback`.</span><span class="s2">\n\t\t\t</span><span class="s1">exec();</span><span class="s2">\n\t\t</span><span class="s1">}</span><span class="s2">\n\n\t\t</span><span class="s1">// Clear any existing timeout.</span><span class="s2">\n\t\t</span><span class="s1">if ( timeoutID ) {</span><span class="s2">\n\t\t\t</span><span class="s1">clearTimeout(timeoutID);</span><span class="s2">\n\t\t</span><span class="s1">}</span><span class="s2">\n\n\t\t</span><span class="s1">if ( debounceMode === undefined &amp;&amp; elapsed &gt; delay ) {</span><span class="s2">\n\t\t\t</span><span class="s1">// In throttle mode, if `delay` time has been exceeded, execute</span><span class="s2">\n\t\t\t</span><span class="s1">// `callback`.</span><span class="s2">\n\t\t\t</span><span class="s1">exec();</span><span class="s2">\n\n\t\t</span><span class="s1">} else if ( noTrailing !== true ) {</span><span class="s2">\n\t\t\t</span><span class="s1">// In trailing throttle mode, since `delay` time has not been</span><span class="s2">\n\t\t\t</span><span class="s1">// exceeded, schedule `callback` to execute `delay` ms after most</span><span class="s2">\n\t\t\t</span><span class="s1">// recent execution.</span><span class="s2">\n\t\t\t</span><span class="s1">//</span><span class="s2">\n\t\t\t</span><span class="s1">// If `debounceMode` is true (at begin), schedule `clear` to execute</span><span class="s2">\n\t\t\t</span><span class="s1">// after `delay` ms.</span><span class="s2">\n\t\t\t</span><span class="s1">//</span><span class="s2">\n\t\t\t</span><span class="s1">// If `debounceMode` is false (at end), schedule `callback` to</span><span class="s2">\n\t\t\t</span><span class="s1">// execute after `delay` ms.</span><span class="s2">\n\t\t\t</span><span class="s1">timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);</span><span class="s2">\n\t\t</span><span class="s1">}</span><span class="s2">\n\n\t</span><span class="s1">}</span><span class="s2">\n\n\t</span><span class="s1">// Return the wrapper function.</span><span class="s2">\n\t</span><span class="s1">return wrapper;</span><span class="s2">\n\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,OAAO,GAAG,UAAWC,KAAK,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,YAAY,EAAG;EAEvE;EACA;EACA;EACA,IAAIC,SAAS;;EAEb;EACA,IAAIC,QAAQ,GAAG,CAAC;;EAEhB;EACA,IAAK,OAAOJ,UAAU,KAAK,SAAS,EAAG;IACtCE,YAAY,GAAGD,QAAQ;IACvBA,QAAQ,GAAGD,UAAU;IACrBA,UAAU,GAAGK,SAAS;EACvB;;EAEA;EACA;EACA;EACA,SAASC,OAAOA,CAAA,EAAI;IAEnB,IAAIC,IAAI,GAAG,IAAI;IACf,IAAIC,OAAO,GAAGC,MAAM,CAAC,IAAIC,IAAI,CAAC,CAAC,CAAC,GAAGN,QAAQ;IAC3C,IAAIO,IAAI,GAAGC,SAAS;;IAEpB;IACA,SAASC,IAAIA,CAAA,EAAI;MAChBT,QAAQ,GAAGK,MAAM,CAAC,IAAIC,IAAI,CAAC,CAAC,CAAC;MAC7BT,QAAQ,CAACa,KAAK,CAACP,IAAI,EAAEI,IAAI,CAAC;IAC3B;;IAEA;IACA;IACA,SAASI,KAAKA,CAAA,EAAI;MACjBZ,SAAS,GAAGE,SAAS;IACtB;IAEA,IAAKH,YAAY,IAAI,CAACC,SAAS,EAAG;MACjC;MACA;MACAU,IAAI,CAAC,CAAC;IACP;;IAEA;IACA,IAAKV,SAAS,EAAG;MAChBa,YAAY,CAACb,SAAS,CAAC;IACxB;IAEA,IAAKD,YAAY,KAAKG,SAAS,IAAIG,OAAO,GAAGT,KAAK,EAAG;MACpD;MACA;MACAc,IAAI,CAAC,CAAC;IAEP,CAAC,MAAM,IAAKb,UAAU,KAAK,IAAI,EAAG;MACjC;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACAG,SAAS,GAAGc,UAAU,CAACf,YAAY,GAAGa,KAAK,GAAGF,IAAI,EAAEX,YAAY,KAAKG,SAAS,GAAGN,KAAK,GAAGS,OAAO,GAAGT,KAAK,CAAC;IAC1G;EAED;;EAEA;EACA,OAAOO,OAAO;AAEf,CAAC&quot;</span><span class="s0">},</span><span class="s1">&quot;metadata&quot;</span><span class="s0">:{},</span><span class="s1">&quot;sourceType&quot;</span><span class="s0">:</span><span class="s1">&quot;script&quot;</span><span class="s0">,</span><span class="s1">&quot;externalDependencies&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>