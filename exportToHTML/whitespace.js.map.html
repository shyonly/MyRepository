<html>
<head>
<title>whitespace.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
whitespace.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;FLIPPED_ALIAS_KEYS&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrayExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isBinary&quot;</span><span class="s0">,</span><span class="s1">&quot;isBlockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptionalCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptionalMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isStringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;crawlInternal&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;hasCall&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;hasFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;hasHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;isHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;crawl&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;isType&quot;</span><span class="s0">,</span><span class="s1">&quot;nodes&quot;</span><span class="s0">,</span><span class="s1">&quot;AssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;SwitchCase&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;consequent&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;cases&quot;</span><span class="s0">,</span><span class="s1">&quot;LogicalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;Literal&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;CallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;OptionalCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;VariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;declarations&quot;</span><span class="s0">,</span><span class="s1">&quot;declar&quot;</span><span class="s0">,</span><span class="s1">&quot;enabled&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;IfStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectTypeProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;properties&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectTypeCallProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;_parent$properties&quot;</span><span class="s0">,</span><span class="s1">&quot;callProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectTypeIndexer&quot;</span><span class="s0">,</span><span class="s1">&quot;_parent$properties2&quot;</span><span class="s0">,</span><span class="s1">&quot;_parent$callPropertie&quot;</span><span class="s0">,</span><span class="s1">&quot;indexers&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectTypeInternalSlot&quot;</span><span class="s0">,</span><span class="s1">&quot;_parent$properties3&quot;</span><span class="s0">,</span><span class="s1">&quot;_parent$callPropertie2&quot;</span><span class="s0">,</span><span class="s1">&quot;_parent$indexers&quot;</span><span class="s0">,</span><span class="s1">&quot;internalSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;amounts&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;ret&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/node/whitespace.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">FLIPPED_ALIAS_KEYS,</span><span class="s3">\n  </span><span class="s1">isArrayExpression,</span><span class="s3">\n  </span><span class="s1">isAssignmentExpression,</span><span class="s3">\n  </span><span class="s1">isBinary,</span><span class="s3">\n  </span><span class="s1">isBlockStatement,</span><span class="s3">\n  </span><span class="s1">isCallExpression,</span><span class="s3">\n  </span><span class="s1">isFunction,</span><span class="s3">\n  </span><span class="s1">isIdentifier,</span><span class="s3">\n  </span><span class="s1">isLiteral,</span><span class="s3">\n  </span><span class="s1">isMemberExpression,</span><span class="s3">\n  </span><span class="s1">isObjectExpression,</span><span class="s3">\n  </span><span class="s1">isOptionalCallExpression,</span><span class="s3">\n  </span><span class="s1">isOptionalMemberExpression,</span><span class="s3">\n  </span><span class="s1">isStringLiteral,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import * as charCodes from </span><span class="s3">\&quot;</span><span class="s1">charcodes</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import type { NodeHandlers } from </span><span class="s3">\&quot;</span><span class="s1">./index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const enum WhitespaceFlag {</span><span class="s3">\n  </span><span class="s1">before = 1 &lt;&lt; 0,</span><span class="s3">\n  </span><span class="s1">after = 1 &lt;&lt; 1,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type { WhitespaceFlag };</span><span class="s3">\n\n</span><span class="s1">function crawlInternal(</span><span class="s3">\n  </span><span class="s1">node: t.Node,</span><span class="s3">\n  </span><span class="s1">state: { hasCall: boolean; hasFunction: boolean; hasHelper: boolean },</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!node) return state;</span><span class="s3">\n\n  </span><span class="s1">if (isMemberExpression(node) || isOptionalMemberExpression(node)) {</span><span class="s3">\n    </span><span class="s1">crawlInternal(node.object, state);</span><span class="s3">\n    </span><span class="s1">if (node.computed) crawlInternal(node.property, state);</span><span class="s3">\n  </span><span class="s1">} else if (isBinary(node) || isAssignmentExpression(node)) {</span><span class="s3">\n    </span><span class="s1">crawlInternal(node.left, state);</span><span class="s3">\n    </span><span class="s1">crawlInternal(node.right, state);</span><span class="s3">\n  </span><span class="s1">} else if (isCallExpression(node) || isOptionalCallExpression(node)) {</span><span class="s3">\n    </span><span class="s1">state.hasCall = true;</span><span class="s3">\n    </span><span class="s1">crawlInternal(node.callee, state);</span><span class="s3">\n  </span><span class="s1">} else if (isFunction(node)) {</span><span class="s3">\n    </span><span class="s1">state.hasFunction = true;</span><span class="s3">\n  </span><span class="s1">} else if (isIdentifier(node)) {</span><span class="s3">\n    </span><span class="s1">state.hasHelper =</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): node.callee is not really expected hereâ€¦</span><span class="s3">\n      </span><span class="s1">state.hasHelper || (node.callee &amp;&amp; isHelper(node.callee));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return state;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Crawl a node to test if it contains a CallExpression, a Function, or a Helper.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* crawl(node)</span><span class="s3">\n </span><span class="s1">* // { hasCall: false, hasFunction: true, hasHelper: false }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">function crawl(node: t.Node) {</span><span class="s3">\n  </span><span class="s1">return crawlInternal(node, {</span><span class="s3">\n    </span><span class="s1">hasCall: false,</span><span class="s3">\n    </span><span class="s1">hasFunction: false,</span><span class="s3">\n    </span><span class="s1">hasHelper: false,</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Test if a node is or has a helper.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">function isHelper(node: t.Node): boolean {</span><span class="s3">\n  </span><span class="s1">if (!node) return false;</span><span class="s3">\n\n  </span><span class="s1">if (isMemberExpression(node)) {</span><span class="s3">\n    </span><span class="s1">return isHelper(node.object) || isHelper(node.property);</span><span class="s3">\n  </span><span class="s1">} else if (isIdentifier(node)) {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">node.name === </span><span class="s3">\&quot;</span><span class="s1">require</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">node.name.charCodeAt(0) === charCodes.underscore</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else if (isCallExpression(node)) {</span><span class="s3">\n    </span><span class="s1">return isHelper(node.callee);</span><span class="s3">\n  </span><span class="s1">} else if (isBinary(node) || isAssignmentExpression(node)) {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">(isIdentifier(node.left) &amp;&amp; isHelper(node.left)) || isHelper(node.right)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isType(node: t.Node) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">isLiteral(node) ||</span><span class="s3">\n    </span><span class="s1">isObjectExpression(node) ||</span><span class="s3">\n    </span><span class="s1">isArrayExpression(node) ||</span><span class="s3">\n    </span><span class="s1">isIdentifier(node) ||</span><span class="s3">\n    </span><span class="s1">isMemberExpression(node)</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests for node types that need whitespace.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export const nodes: NodeHandlers&lt;WhitespaceFlag&gt; = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Test if AssignmentExpression needs whitespace.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">AssignmentExpression(node: t.AssignmentExpression): WhitespaceFlag {</span><span class="s3">\n    </span><span class="s1">const state = crawl(node.right);</span><span class="s3">\n    </span><span class="s1">if ((state.hasCall &amp;&amp; state.hasHelper) || state.hasFunction) {</span><span class="s3">\n      </span><span class="s1">return state.hasFunction</span><span class="s3">\n        </span><span class="s1">? WhitespaceFlag.before | WhitespaceFlag.after</span><span class="s3">\n        </span><span class="s1">: WhitespaceFlag.after;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Test if SwitchCase needs whitespace.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">SwitchCase(node: t.SwitchCase, parent: t.SwitchStatement): WhitespaceFlag {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">(!!node.consequent.length || parent.cases[0] === node</span><span class="s3">\n        </span><span class="s1">? WhitespaceFlag.before</span><span class="s3">\n        </span><span class="s1">: 0) |</span><span class="s3">\n      </span><span class="s1">(!node.consequent.length &amp;&amp; parent.cases[parent.cases.length - 1] === node</span><span class="s3">\n        </span><span class="s1">? WhitespaceFlag.after</span><span class="s3">\n        </span><span class="s1">: 0)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Test if LogicalExpression needs whitespace.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">LogicalExpression(node: t.LogicalExpression): WhitespaceFlag {</span><span class="s3">\n    </span><span class="s1">if (isFunction(node.left) || isFunction(node.right)) {</span><span class="s3">\n      </span><span class="s1">return WhitespaceFlag.after;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Test if Literal needs whitespace.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">Literal(node: t.Literal): WhitespaceFlag {</span><span class="s3">\n    </span><span class="s1">if (isStringLiteral(node) &amp;&amp; node.value === </span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return WhitespaceFlag.after;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Test if CallExpressionish needs whitespace.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">CallExpression(node: t.CallExpression): WhitespaceFlag {</span><span class="s3">\n    </span><span class="s1">if (isFunction(node.callee) || isHelper(node)) {</span><span class="s3">\n      </span><span class="s1">return WhitespaceFlag.before | WhitespaceFlag.after;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">OptionalCallExpression(node: t.OptionalCallExpression): WhitespaceFlag {</span><span class="s3">\n    </span><span class="s1">if (isFunction(node.callee)) {</span><span class="s3">\n      </span><span class="s1">return WhitespaceFlag.before | WhitespaceFlag.after;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Test if VariableDeclaration needs whitespace.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">VariableDeclaration(node: t.VariableDeclaration): WhitespaceFlag {</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; node.declarations.length; i++) {</span><span class="s3">\n      </span><span class="s1">const declar = node.declarations[i];</span><span class="s3">\n\n      </span><span class="s1">let enabled = isHelper(declar.id) &amp;&amp; !isType(declar.init);</span><span class="s3">\n      </span><span class="s1">if (!enabled &amp;&amp; declar.init) {</span><span class="s3">\n        </span><span class="s1">const state = crawl(declar.init);</span><span class="s3">\n        </span><span class="s1">enabled = (isHelper(declar.init) &amp;&amp; state.hasCall) || state.hasFunction;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (enabled) {</span><span class="s3">\n        </span><span class="s1">return WhitespaceFlag.before | WhitespaceFlag.after;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Test if IfStatement needs whitespace.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">IfStatement(node: t.IfStatement): WhitespaceFlag {</span><span class="s3">\n    </span><span class="s1">if (isBlockStatement(node.consequent)) {</span><span class="s3">\n      </span><span class="s1">return WhitespaceFlag.before | WhitespaceFlag.after;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Test if Property needs whitespace.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">nodes.ObjectProperty =</span><span class="s3">\n  </span><span class="s1">nodes.ObjectTypeProperty =</span><span class="s3">\n  </span><span class="s1">nodes.ObjectMethod =</span><span class="s3">\n    </span><span class="s1">function (</span><span class="s3">\n      </span><span class="s1">node: t.ObjectProperty | t.ObjectTypeProperty | t.ObjectMethod,</span><span class="s3">\n      </span><span class="s1">parent: t.ObjectExpression,</span><span class="s3">\n    </span><span class="s1">): WhitespaceFlag {</span><span class="s3">\n      </span><span class="s1">if (parent.properties[0] === node) {</span><span class="s3">\n        </span><span class="s1">return WhitespaceFlag.before;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">nodes.ObjectTypeCallProperty = function (</span><span class="s3">\n  </span><span class="s1">node: t.ObjectTypeCallProperty,</span><span class="s3">\n  </span><span class="s1">parent: t.ObjectTypeAnnotation,</span><span class="s3">\n</span><span class="s1">): WhitespaceFlag {</span><span class="s3">\n  </span><span class="s1">if (parent.callProperties[0] === node &amp;&amp; !parent.properties?.length) {</span><span class="s3">\n    </span><span class="s1">return WhitespaceFlag.before;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">nodes.ObjectTypeIndexer = function (</span><span class="s3">\n  </span><span class="s1">node: t.ObjectTypeIndexer,</span><span class="s3">\n  </span><span class="s1">parent: t.ObjectTypeAnnotation,</span><span class="s3">\n</span><span class="s1">): WhitespaceFlag {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">parent.indexers[0] === node &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!parent.properties?.length &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!parent.callProperties?.length</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return WhitespaceFlag.before;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">nodes.ObjectTypeInternalSlot = function (</span><span class="s3">\n  </span><span class="s1">node: t.ObjectTypeInternalSlot,</span><span class="s3">\n  </span><span class="s1">parent: t.ObjectTypeAnnotation,</span><span class="s3">\n</span><span class="s1">): WhitespaceFlag {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">parent.internalSlots[0] === node &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!parent.properties?.length &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!parent.callProperties?.length &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!parent.indexers?.length</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return WhitespaceFlag.before;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Add whitespace tests for nodes and their aliases.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">(</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">Function</span><span class="s3">\&quot;</span><span class="s1">, true],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">Class</span><span class="s3">\&quot;</span><span class="s1">, true],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">Loop</span><span class="s3">\&quot;</span><span class="s1">, true],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">LabeledStatement</span><span class="s3">\&quot;</span><span class="s1">, true],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">SwitchStatement</span><span class="s3">\&quot;</span><span class="s1">, true],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">TryStatement</span><span class="s3">\&quot;</span><span class="s1">, true],</span><span class="s3">\n  </span><span class="s1">] as const</span><span class="s3">\n</span><span class="s1">).forEach(function ([type, amounts]) {</span><span class="s3">\n  </span><span class="s1">[type as string]</span><span class="s3">\n    </span><span class="s1">.concat(FLIPPED_ALIAS_KEYS[type] || [])</span><span class="s3">\n    </span><span class="s1">.forEach(function (type) {</span><span class="s3">\n      </span><span class="s1">const ret = amounts ? WhitespaceFlag.before | WhitespaceFlag.after : 0;</span><span class="s3">\n      </span><span class="s1">nodes[type] = () =&gt; ret;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>