<html>
<head>
<title>transformer-2023-05.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
transformer-2023-05.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_pluginSyntaxDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperReplaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperSplitExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;incrementId&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;idx&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrivateUidGeneratorForClass&quot;</span><span class="s0">,</span><span class="s1">&quot;classPath&quot;</span><span class="s0">,</span><span class="s1">&quot;currentPrivateId&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNames&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;PrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;reifiedId&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;fromCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;privateName&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;createLazyPrivateUidGeneratorForClass&quot;</span><span class="s0">,</span><span class="s1">&quot;generator&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceClassWithVar&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;varId&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifierBasedOnNode&quot;</span><span class="s0">,</span><span class="s1">&quot;classId&quot;</span><span class="s0">,</span><span class="s1">&quot;rename&quot;</span><span class="s0">,</span><span class="s1">&quot;insertBefore&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;className&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDeclaredUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;newClassExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;classExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;newPath&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;generateClassProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;classPrivateProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;classProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;addProxyAccessorsFor&quot;</span><span class="s0">,</span><span class="s1">&quot;element&quot;</span><span class="s0">,</span><span class="s1">&quot;originalKey&quot;</span><span class="s0">,</span><span class="s1">&quot;targetKey&quot;</span><span class="s0">,</span><span class="s1">&quot;version&quot;</span><span class="s0">,</span><span class="s1">&quot;isComputed&quot;</span><span class="s0">,</span><span class="s1">&quot;static&quot;</span><span class="s0">,</span><span class="s1">&quot;thisArg&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;getterBody&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;returnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;setterBody&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;getter&quot;</span><span class="s0">,</span><span class="s1">&quot;setter&quot;</span><span class="s0">,</span><span class="s1">&quot;classPrivateMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;classMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;insertAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;extractProxyAccessorsFor&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;FIELD&quot;</span><span class="s0">,</span><span class="s1">&quot;ACCESSOR&quot;</span><span class="s0">,</span><span class="s1">&quot;METHOD&quot;</span><span class="s0">,</span><span class="s1">&quot;GETTER&quot;</span><span class="s0">,</span><span class="s1">&quot;SETTER&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC_OLD_VERSION&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC&quot;</span><span class="s0">,</span><span class="s1">&quot;DECORATORS_HAVE_THIS&quot;</span><span class="s0">,</span><span class="s1">&quot;getElementKind&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;isDecoratorInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;info&quot;</span><span class="s0">,</span><span class="s1">&quot;filteredOrderedDecoratorInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;filtered&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;el&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDecorationList&quot;</span><span class="s0">,</span><span class="s1">&quot;decorators&quot;</span><span class="s0">,</span><span class="s1">&quot;decoratorsThis&quot;</span><span class="s0">,</span><span class="s1">&quot;decsCount&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOneThis&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;decs&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;unaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;numericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;hasThis&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDecorationExprs&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;flag&quot;</span><span class="s0">,</span><span class="s1">&quot;privateMethods&quot;</span><span class="s0">,</span><span class="s1">&quot;extractElementLocalAssignments&quot;</span><span class="s0">,</span><span class="s1">&quot;decorationInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;localIds&quot;</span><span class="s0">,</span><span class="s1">&quot;locals&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;addCallAccessorsFor&quot;</span><span class="s0">,</span><span class="s1">&quot;getId&quot;</span><span class="s0">,</span><span class="s1">&quot;setId&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isNotTsParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;movePrivateAccessor&quot;</span><span class="s0">,</span><span class="s1">&quot;methodLocalVar&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;block&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassDecoratableElementPath&quot;</span><span class="s0">,</span><span class="s1">&quot;staticBlockToIIFE&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeSequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;exprs&quot;</span><span class="s0">,</span><span class="s1">&quot;transformClass&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;constantSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;classDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;hasElementDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;generateClassPrivateUid&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;newId&quot;</span><span class="s0">,</span><span class="s1">&quot;valueNode&quot;</span><span class="s0">,</span><span class="s1">&quot;newField&quot;</span><span class="s0">,</span><span class="s1">&quot;elementDecoratorInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;firstFieldPath&quot;</span><span class="s0">,</span><span class="s1">&quot;constructorPath&quot;</span><span class="s0">,</span><span class="s1">&quot;requiresProtoInit&quot;</span><span class="s0">,</span><span class="s1">&quot;requiresStaticInit&quot;</span><span class="s0">,</span><span class="s1">&quot;decoratedPrivateMethods&quot;</span><span class="s0">,</span><span class="s1">&quot;protoInitLocal&quot;</span><span class="s0">,</span><span class="s1">&quot;staticInitLocal&quot;</span><span class="s0">,</span><span class="s1">&quot;classInitLocal&quot;</span><span class="s0">,</span><span class="s1">&quot;classIdLocal&quot;</span><span class="s0">,</span><span class="s1">&quot;assignments&quot;</span><span class="s0">,</span><span class="s1">&quot;scopeParent&quot;</span><span class="s0">,</span><span class="s1">&quot;memoiseExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;hint&quot;</span><span class="s0">,</span><span class="s1">&quot;localEvaluatedId&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeExtractDecorator&quot;</span><span class="s0">,</span><span class="s1">&quot;decorator&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;isSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;isThisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;classDecorator&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;lastInstancePrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;needsInstancePrivateBrandCheck&quot;</span><span class="s0">,</span><span class="s1">&quot;hasDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;decoratorPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrivate&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassPrivateProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;newFieldInitId&quot;</span><span class="s0">,</span><span class="s1">&quot;newValue&quot;</span><span class="s0">,</span><span class="s1">&quot;initId&quot;</span><span class="s0">,</span><span class="s1">&quot;valuePath&quot;</span><span class="s0">,</span><span class="s1">&quot;v&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;ReplaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;methodPath&quot;</span><span class="s0">,</span><span class="s1">&quot;objectRef&quot;</span><span class="s0">,</span><span class="s1">&quot;superRef&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;refToPreserve&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;isAsync&quot;</span><span class="s0">,</span><span class="s1">&quot;functionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;nameExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;d&quot;</span><span class="s0">,</span><span class="s1">&quot;elementDecorations&quot;</span><span class="s0">,</span><span class="s1">&quot;classDecorationsFlag&quot;</span><span class="s0">,</span><span class="s1">&quot;classDecorations&quot;</span><span class="s0">,</span><span class="s1">&quot;dec&quot;</span><span class="s0">,</span><span class="s1">&quot;elementLocals&quot;</span><span class="s0">,</span><span class="s1">&quot;protoInitCall&quot;</span><span class="s0">,</span><span class="s1">&quot;CallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;skip&quot;</span><span class="s0">,</span><span class="s1">&quot;super&quot;</span><span class="s0">,</span><span class="s1">&quot;spreadElement&quot;</span><span class="s0">,</span><span class="s1">&quot;restElement&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;parentParentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;classLocals&quot;</span><span class="s0">,</span><span class="s1">&quot;classInitInjected&quot;</span><span class="s0">,</span><span class="s1">&quot;classInitCall&quot;</span><span class="s0">,</span><span class="s1">&quot;originalClass&quot;</span><span class="s0">,</span><span class="s1">&quot;statics&quot;</span><span class="s0">,</span><span class="s1">&quot;staticBlocks&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;isProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassPrivateMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;allValues&quot;</span><span class="s0">,</span><span class="s1">&quot;staticsClass&quot;</span><span class="s0">,</span><span class="s1">&quot;addHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;staticBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;toStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;constructorBody&quot;</span><span class="s0">,</span><span class="s1">&quot;newExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;newExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeGenerateMemoised&quot;</span><span class="s0">,</span><span class="s1">&quot;createLocalsAssignment&quot;</span><span class="s0">,</span><span class="s1">&quot;expr&quot;</span><span class="s0">,</span><span class="s1">&quot;crawl&quot;</span><span class="s0">,</span><span class="s1">&quot;maybePrivateBranName&quot;</span><span class="s0">,</span><span class="s1">&quot;lhs&quot;</span><span class="s0">,</span><span class="s1">&quot;rhs&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;availableHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;objectPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;objectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;_default&quot;</span><span class="s0">,</span><span class="s1">&quot;assertVersion&quot;</span><span class="s0">,</span><span class="s1">&quot;assumption&quot;</span><span class="s0">,</span><span class="s1">&quot;loose&quot;</span><span class="s0">,</span><span class="s1">&quot;_assumption&quot;</span><span class="s0">,</span><span class="s1">&quot;VISITED&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakSet&quot;</span><span class="s0">,</span><span class="s1">&quot;inherits&quot;</span><span class="s0">,</span><span class="s1">&quot;syntaxDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;visitor&quot;</span><span class="s0">,</span><span class="s1">&quot;ExportNamedDeclaration|ExportDefaultDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;_declaration$decorato&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;splitExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;Class&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/transformer-2023-05.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { NodePath, Scope } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { types as t, template } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import syntaxDecorators from </span><span class="s3">\&quot;</span><span class="s1">@babel/plugin-syntax-decorators</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import ReplaceSupers from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-replace-supers</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import splitExportDeclaration from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-split-export-declaration</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import * as charCodes from </span><span class="s3">\&quot;</span><span class="s1">charcodes</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { PluginAPI, PluginObject, PluginPass } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Options } from </span><span class="s3">\&quot;</span><span class="s1">./index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">type ClassDecoratableElement =</span><span class="s3">\n  </span><span class="s1">| t.ClassMethod</span><span class="s3">\n  </span><span class="s1">| t.ClassPrivateMethod</span><span class="s3">\n  </span><span class="s1">| t.ClassProperty</span><span class="s3">\n  </span><span class="s1">| t.ClassPrivateProperty</span><span class="s3">\n  </span><span class="s1">| t.ClassAccessorProperty;</span><span class="s3">\n\n</span><span class="s1">type ClassElement =</span><span class="s3">\n  </span><span class="s1">| ClassDecoratableElement</span><span class="s3">\n  </span><span class="s1">| t.TSDeclareMethod</span><span class="s3">\n  </span><span class="s1">| t.TSIndexSignature</span><span class="s3">\n  </span><span class="s1">| t.StaticBlock;</span><span class="s3">\n\n</span><span class="s1">type DecoratorVersionKind = </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">2023-01</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">2022-03</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">2021-12</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">function incrementId(id: number[], idx = id.length - 1): void {</span><span class="s3">\n  </span><span class="s1">// If index is -1, id needs an additional character, unshift A</span><span class="s3">\n  </span><span class="s1">if (idx === -1) {</span><span class="s3">\n    </span><span class="s1">id.unshift(charCodes.uppercaseA);</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const current = id[idx];</span><span class="s3">\n\n  </span><span class="s1">if (current === charCodes.uppercaseZ) {</span><span class="s3">\n    </span><span class="s1">// if current is Z, skip to a</span><span class="s3">\n    </span><span class="s1">id[idx] = charCodes.lowercaseA;</span><span class="s3">\n  </span><span class="s1">} else if (current === charCodes.lowercaseZ) {</span><span class="s3">\n    </span><span class="s1">// if current is z, reset to A and carry the 1</span><span class="s3">\n    </span><span class="s1">id[idx] = charCodes.uppercaseA;</span><span class="s3">\n    </span><span class="s1">incrementId(id, idx - 1);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// else, increment by one</span><span class="s3">\n    </span><span class="s1">id[idx] = current + 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generates a new private name that is unique to the given class. This can be</span><span class="s3">\n </span><span class="s1">* used to create extra class fields and methods for the implementation, while</span><span class="s3">\n </span><span class="s1">* keeping the length of those names as small as possible. This is important for</span><span class="s3">\n </span><span class="s1">* minification purposes (though private names can generally be minified,</span><span class="s3">\n </span><span class="s1">* transpilations and polyfills cannot yet).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createPrivateUidGeneratorForClass(</span><span class="s3">\n  </span><span class="s1">classPath: NodePath&lt;t.ClassDeclaration | t.ClassExpression&gt;,</span><span class="s3">\n</span><span class="s1">): () =&gt; t.PrivateName {</span><span class="s3">\n  </span><span class="s1">const currentPrivateId: number[] = [];</span><span class="s3">\n  </span><span class="s1">const privateNames = new Set&lt;string&gt;();</span><span class="s3">\n\n  </span><span class="s1">classPath.traverse({</span><span class="s3">\n    </span><span class="s1">PrivateName(path) {</span><span class="s3">\n      </span><span class="s1">privateNames.add(path.node.id.name);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return (): t.PrivateName =&gt; {</span><span class="s3">\n    </span><span class="s1">let reifiedId;</span><span class="s3">\n    </span><span class="s1">do {</span><span class="s3">\n      </span><span class="s1">incrementId(currentPrivateId);</span><span class="s3">\n      </span><span class="s1">reifiedId = String.fromCharCode(...currentPrivateId);</span><span class="s3">\n    </span><span class="s1">} while (privateNames.has(reifiedId));</span><span class="s3">\n\n    </span><span class="s1">return t.privateName(t.identifier(reifiedId));</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Wraps the above generator function so that it's run lazily the first time</span><span class="s3">\n </span><span class="s1">* it's actually required. Several types of decoration do not require this, so it</span><span class="s3">\n </span><span class="s1">* saves iterating the class elements an additional time and allocating the space</span><span class="s3">\n </span><span class="s1">* for the Sets of element names.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createLazyPrivateUidGeneratorForClass(</span><span class="s3">\n  </span><span class="s1">classPath: NodePath&lt;t.ClassDeclaration | t.ClassExpression&gt;,</span><span class="s3">\n</span><span class="s1">): () =&gt; t.PrivateName {</span><span class="s3">\n  </span><span class="s1">let generator: () =&gt; t.PrivateName;</span><span class="s3">\n\n  </span><span class="s1">return (): t.PrivateName =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!generator) {</span><span class="s3">\n      </span><span class="s1">generator = createPrivateUidGeneratorForClass(classPath);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return generator();</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Takes a class definition and replaces it with an equivalent class declaration</span><span class="s3">\n </span><span class="s1">* which is then assigned to a local variable. This allows us to reassign the</span><span class="s3">\n </span><span class="s1">* local variable with the decorated version of the class. The class definition</span><span class="s3">\n </span><span class="s1">* retains its original name so that `toString` is not affected, other</span><span class="s3">\n </span><span class="s1">* references to the class are renamed instead.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function replaceClassWithVar(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.ClassDeclaration | t.ClassExpression&gt;,</span><span class="s3">\n</span><span class="s1">): [t.Identifier, NodePath&lt;t.ClassDeclaration | t.ClassExpression&gt;] {</span><span class="s3">\n  </span><span class="s1">if (path.type === </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const varId = path.scope.generateUidIdentifierBasedOnNode(path.node.id);</span><span class="s3">\n    </span><span class="s1">const classId = t.identifier(path.node.id.name);</span><span class="s3">\n\n    </span><span class="s1">path.scope.rename(classId.name, varId.name);</span><span class="s3">\n\n    </span><span class="s1">path.insertBefore(</span><span class="s3">\n      </span><span class="s1">t.variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">, [t.variableDeclarator(varId)]),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">path.get(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">).replaceWith(classId);</span><span class="s3">\n\n    </span><span class="s1">return [t.cloneNode(varId), path];</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">let className: string;</span><span class="s3">\n    </span><span class="s1">let varId: t.Identifier;</span><span class="s3">\n\n    </span><span class="s1">if (path.node.id) {</span><span class="s3">\n      </span><span class="s1">className = path.node.id.name;</span><span class="s3">\n      </span><span class="s1">varId = path.scope.parent.generateDeclaredUidIdentifier(className);</span><span class="s3">\n      </span><span class="s1">path.scope.rename(className, varId.name);</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">path.parentPath.node.type === </span><span class="s3">\&quot;</span><span class="s1">VariableDeclarator</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n      </span><span class="s1">path.parentPath.node.id.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">className = path.parentPath.node.id.name;</span><span class="s3">\n      </span><span class="s1">varId = path.scope.parent.generateDeclaredUidIdentifier(className);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">varId =</span><span class="s3">\n        </span><span class="s1">path.scope.parent.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">decorated_class</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const newClassExpr = t.classExpression(</span><span class="s3">\n      </span><span class="s1">className &amp;&amp; t.identifier(className),</span><span class="s3">\n      </span><span class="s1">path.node.superClass,</span><span class="s3">\n      </span><span class="s1">path.node.body,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">const [newPath] = path.replaceWith(</span><span class="s3">\n      </span><span class="s1">t.sequenceExpression([newClassExpr, varId]),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">return [</span><span class="s3">\n      </span><span class="s1">t.cloneNode(varId),</span><span class="s3">\n      </span><span class="s1">newPath.get(</span><span class="s3">\&quot;</span><span class="s1">expressions.0</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.ClassExpression&gt;,</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function generateClassProperty(</span><span class="s3">\n  </span><span class="s1">key: t.PrivateName | t.Identifier,</span><span class="s3">\n  </span><span class="s1">value: t.Expression | undefined,</span><span class="s3">\n  </span><span class="s1">isStatic: boolean,</span><span class="s3">\n</span><span class="s1">): t.ClassPrivateProperty | t.ClassProperty {</span><span class="s3">\n  </span><span class="s1">if (key.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateName</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return t.classPrivateProperty(key, value, undefined, isStatic);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return t.classProperty(key, value, undefined, undefined, isStatic);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function addProxyAccessorsFor(</span><span class="s3">\n  </span><span class="s1">className: t.Identifier,</span><span class="s3">\n  </span><span class="s1">element: NodePath&lt;ClassDecoratableElement&gt;,</span><span class="s3">\n  </span><span class="s1">originalKey: t.PrivateName | t.Expression,</span><span class="s3">\n  </span><span class="s1">targetKey: t.PrivateName,</span><span class="s3">\n  </span><span class="s1">version: DecoratorVersionKind,</span><span class="s3">\n  </span><span class="s1">isComputed = false,</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const { static: isStatic } = element.node;</span><span class="s3">\n\n  </span><span class="s1">const thisArg =</span><span class="s3">\n    </span><span class="s1">version === </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; isStatic ? className : t.thisExpression();</span><span class="s3">\n\n  </span><span class="s1">const getterBody = t.blockStatement([</span><span class="s3">\n    </span><span class="s1">t.returnStatement(</span><span class="s3">\n      </span><span class="s1">t.memberExpression(t.cloneNode(thisArg), t.cloneNode(targetKey)),</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n\n  </span><span class="s1">const setterBody = t.blockStatement([</span><span class="s3">\n    </span><span class="s1">t.expressionStatement(</span><span class="s3">\n      </span><span class="s1">t.assignmentExpression(</span><span class="s3">\n        \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">t.memberExpression(t.cloneNode(thisArg), t.cloneNode(targetKey)),</span><span class="s3">\n        </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n\n  </span><span class="s1">let getter: t.ClassMethod | t.ClassPrivateMethod,</span><span class="s3">\n    </span><span class="s1">setter: t.ClassMethod | t.ClassPrivateMethod;</span><span class="s3">\n\n  </span><span class="s1">if (originalKey.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateName</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">getter = t.classPrivateMethod(</span><span class="s3">\n      \&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">t.cloneNode(originalKey),</span><span class="s3">\n      </span><span class="s1">[],</span><span class="s3">\n      </span><span class="s1">getterBody,</span><span class="s3">\n      </span><span class="s1">isStatic,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">setter = t.classPrivateMethod(</span><span class="s3">\n      \&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">t.cloneNode(originalKey),</span><span class="s3">\n      </span><span class="s1">[t.identifier(</span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">)],</span><span class="s3">\n      </span><span class="s1">setterBody,</span><span class="s3">\n      </span><span class="s1">isStatic,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">getter = t.classMethod(</span><span class="s3">\n      \&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">t.cloneNode(originalKey),</span><span class="s3">\n      </span><span class="s1">[],</span><span class="s3">\n      </span><span class="s1">getterBody,</span><span class="s3">\n      </span><span class="s1">isComputed,</span><span class="s3">\n      </span><span class="s1">isStatic,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">setter = t.classMethod(</span><span class="s3">\n      \&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">t.cloneNode(originalKey),</span><span class="s3">\n      </span><span class="s1">[t.identifier(</span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">)],</span><span class="s3">\n      </span><span class="s1">setterBody,</span><span class="s3">\n      </span><span class="s1">isComputed,</span><span class="s3">\n      </span><span class="s1">isStatic,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">element.insertAfter(setter);</span><span class="s3">\n  </span><span class="s1">element.insertAfter(getter);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function extractProxyAccessorsFor(</span><span class="s3">\n  </span><span class="s1">targetKey: t.PrivateName,</span><span class="s3">\n  </span><span class="s1">version: DecoratorVersionKind,</span><span class="s3">\n</span><span class="s1">): (t.FunctionExpression | t.ArrowFunctionExpression)[] {</span><span class="s3">\n  </span><span class="s1">if (version !== </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; version !== </span><span class="s3">\&quot;</span><span class="s1">2023-01</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n      </span><span class="s1">template.expression.ast`</span><span class="s3">\n        </span><span class="s1">function () {</span><span class="s3">\n          </span><span class="s1">return this.${t.cloneNode(targetKey)};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">` as t.FunctionExpression,</span><span class="s3">\n      </span><span class="s1">template.expression.ast`</span><span class="s3">\n        </span><span class="s1">function (value) {</span><span class="s3">\n          </span><span class="s1">this.${t.cloneNode(targetKey)} = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">` as t.FunctionExpression,</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return [</span><span class="s3">\n    </span><span class="s1">template.expression.ast`</span><span class="s3">\n      </span><span class="s1">o =&gt; o.${t.cloneNode(targetKey)}</span><span class="s3">\n    </span><span class="s1">` as t.ArrowFunctionExpression,</span><span class="s3">\n    </span><span class="s1">template.expression.ast`</span><span class="s3">\n      </span><span class="s1">(o, v) =&gt; o.${t.cloneNode(targetKey)} = v</span><span class="s3">\n    </span><span class="s1">` as t.ArrowFunctionExpression,</span><span class="s3">\n  </span><span class="s1">];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// 3 bits reserved to this (0-7)</span><span class="s3">\n</span><span class="s1">const FIELD = 0;</span><span class="s3">\n</span><span class="s1">const ACCESSOR = 1;</span><span class="s3">\n</span><span class="s1">const METHOD = 2;</span><span class="s3">\n</span><span class="s1">const GETTER = 3;</span><span class="s3">\n</span><span class="s1">const SETTER = 4;</span><span class="s3">\n\n</span><span class="s1">const STATIC_OLD_VERSION = 5; // Before 2023-05</span><span class="s3">\n</span><span class="s1">const STATIC = 8; // 1 &lt;&lt; 3</span><span class="s3">\n</span><span class="s1">const DECORATORS_HAVE_THIS = 16; // 1 &lt;&lt; 3</span><span class="s3">\n\n</span><span class="s1">function getElementKind(element: NodePath&lt;ClassDecoratableElement&gt;): number {</span><span class="s3">\n  </span><span class="s1">switch (element.node.type) {</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassPrivateProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return FIELD;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassAccessorProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return ACCESSOR;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassMethod</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassPrivateMethod</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">if (element.node.kind === </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return GETTER;</span><span class="s3">\n      </span><span class="s1">} else if (element.node.kind === </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return SETTER;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return METHOD;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Information about the decorators applied to an element</span><span class="s3">\n</span><span class="s1">interface DecoratorInfo {</span><span class="s3">\n  </span><span class="s1">// The expressions of the decorators themselves</span><span class="s3">\n  </span><span class="s1">decorators: t.Expression[];</span><span class="s3">\n  </span><span class="s1">decoratorsThis: t.Expression[];</span><span class="s3">\n\n  </span><span class="s1">// The kind of the decorated value, matches the kind value passed to applyDecs</span><span class="s3">\n  </span><span class="s1">kind: number;</span><span class="s3">\n\n  </span><span class="s1">// whether or not the field is static</span><span class="s3">\n  </span><span class="s1">isStatic: boolean;</span><span class="s3">\n\n  </span><span class="s1">// The name of the decorator</span><span class="s3">\n  </span><span class="s1">name: t.StringLiteral | t.Expression;</span><span class="s3">\n\n  </span><span class="s1">privateMethods:</span><span class="s3">\n    </span><span class="s1">| (t.FunctionExpression | t.ArrowFunctionExpression)[]</span><span class="s3">\n    </span><span class="s1">| undefined;</span><span class="s3">\n\n  </span><span class="s1">// The names of local variables that will be used/returned from the decoration</span><span class="s3">\n  </span><span class="s1">locals: t.Identifier | t.Identifier[] | undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Information about a computed property key. These must be evaluated</span><span class="s3">\n</span><span class="s1">// interspersed with decorator expressions, which is why they get added to the</span><span class="s3">\n</span><span class="s1">// array of DecoratorInfos later on.</span><span class="s3">\n</span><span class="s1">interface ComputedPropInfo {</span><span class="s3">\n  </span><span class="s1">localComputedNameId: t.Identifier;</span><span class="s3">\n  </span><span class="s1">keyNode: t.Expression;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isDecoratorInfo(</span><span class="s3">\n  </span><span class="s1">info: DecoratorInfo | ComputedPropInfo,</span><span class="s3">\n</span><span class="s1">): info is DecoratorInfo {</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">decorators</span><span class="s3">\&quot; </span><span class="s1">in info;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function filteredOrderedDecoratorInfo(</span><span class="s3">\n  </span><span class="s1">info: (DecoratorInfo | ComputedPropInfo)[],</span><span class="s3">\n</span><span class="s1">): DecoratorInfo[] {</span><span class="s3">\n  </span><span class="s1">const filtered = info.filter(isDecoratorInfo);</span><span class="s3">\n\n  </span><span class="s1">return [</span><span class="s3">\n    </span><span class="s1">...filtered.filter(</span><span class="s3">\n      </span><span class="s1">el =&gt; el.isStatic &amp;&amp; el.kind &gt;= ACCESSOR &amp;&amp; el.kind &lt;= SETTER,</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">...filtered.filter(</span><span class="s3">\n      </span><span class="s1">el =&gt; !el.isStatic &amp;&amp; el.kind &gt;= ACCESSOR &amp;&amp; el.kind &lt;= SETTER,</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">...filtered.filter(el =&gt; el.isStatic &amp;&amp; el.kind === FIELD),</span><span class="s3">\n    </span><span class="s1">...filtered.filter(el =&gt; !el.isStatic &amp;&amp; el.kind === FIELD),</span><span class="s3">\n  </span><span class="s1">];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function generateDecorationList(</span><span class="s3">\n  </span><span class="s1">decorators: t.Expression[],</span><span class="s3">\n  </span><span class="s1">decoratorsThis: (t.Expression | null)[],</span><span class="s3">\n  </span><span class="s1">version: DecoratorVersionKind,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const decsCount = decorators.length;</span><span class="s3">\n  </span><span class="s1">const hasOneThis = decoratorsThis.some(Boolean);</span><span class="s3">\n  </span><span class="s1">const decs: t.Expression[] = [];</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; decsCount; i++) {</span><span class="s3">\n    </span><span class="s1">if (version === </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; hasOneThis) {</span><span class="s3">\n      </span><span class="s1">decs.push(</span><span class="s3">\n        </span><span class="s1">decoratorsThis[i] || t.unaryExpression(</span><span class="s3">\&quot;</span><span class="s1">void</span><span class="s3">\&quot;</span><span class="s1">, t.numericLiteral(0)),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">decs.push(decorators[i]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { hasThis: hasOneThis, decs };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function generateDecorationExprs(</span><span class="s3">\n  </span><span class="s1">info: (DecoratorInfo | ComputedPropInfo)[],</span><span class="s3">\n  </span><span class="s1">version: DecoratorVersionKind,</span><span class="s3">\n</span><span class="s1">): t.ArrayExpression {</span><span class="s3">\n  </span><span class="s1">return t.arrayExpression(</span><span class="s3">\n    </span><span class="s1">filteredOrderedDecoratorInfo(info).map(el =&gt; {</span><span class="s3">\n      </span><span class="s1">const { decs, hasThis } = generateDecorationList(</span><span class="s3">\n        </span><span class="s1">el.decorators,</span><span class="s3">\n        </span><span class="s1">el.decoratorsThis,</span><span class="s3">\n        </span><span class="s1">version,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">let flag = el.kind;</span><span class="s3">\n      </span><span class="s1">if (el.isStatic) {</span><span class="s3">\n        </span><span class="s1">flag += version === </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot; </span><span class="s1">? STATIC : STATIC_OLD_VERSION;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (hasThis) flag += DECORATORS_HAVE_THIS;</span><span class="s3">\n\n      </span><span class="s1">return t.arrayExpression([</span><span class="s3">\n        </span><span class="s1">decs.length === 1 ? decs[0] : t.arrayExpression(decs),</span><span class="s3">\n        </span><span class="s1">t.numericLiteral(flag),</span><span class="s3">\n        </span><span class="s1">el.name,</span><span class="s3">\n        </span><span class="s1">...(el.privateMethods || []),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function extractElementLocalAssignments(</span><span class="s3">\n  </span><span class="s1">decorationInfo: (DecoratorInfo | ComputedPropInfo)[],</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const localIds: t.Identifier[] = [];</span><span class="s3">\n\n  </span><span class="s1">for (const el of filteredOrderedDecoratorInfo(decorationInfo)) {</span><span class="s3">\n    </span><span class="s1">const { locals } = el;</span><span class="s3">\n\n    </span><span class="s1">if (Array.isArray(locals)) {</span><span class="s3">\n      </span><span class="s1">localIds.push(...locals);</span><span class="s3">\n    </span><span class="s1">} else if (locals !== undefined) {</span><span class="s3">\n      </span><span class="s1">localIds.push(locals);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return localIds;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function addCallAccessorsFor(</span><span class="s3">\n  </span><span class="s1">element: NodePath,</span><span class="s3">\n  </span><span class="s1">key: t.PrivateName,</span><span class="s3">\n  </span><span class="s1">getId: t.Identifier,</span><span class="s3">\n  </span><span class="s1">setId: t.Identifier,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">element.insertAfter(</span><span class="s3">\n    </span><span class="s1">t.classPrivateMethod(</span><span class="s3">\n      \&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">t.cloneNode(key),</span><span class="s3">\n      </span><span class="s1">[],</span><span class="s3">\n      </span><span class="s1">t.blockStatement([</span><span class="s3">\n        </span><span class="s1">t.returnStatement(</span><span class="s3">\n          </span><span class="s1">t.callExpression(t.cloneNode(getId), [t.thisExpression()]),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">]),</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">element.insertAfter(</span><span class="s3">\n    </span><span class="s1">t.classPrivateMethod(</span><span class="s3">\n      \&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">t.cloneNode(key),</span><span class="s3">\n      </span><span class="s1">[t.identifier(</span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">)],</span><span class="s3">\n      </span><span class="s1">t.blockStatement([</span><span class="s3">\n        </span><span class="s1">t.expressionStatement(</span><span class="s3">\n          </span><span class="s1">t.callExpression(t.cloneNode(setId), [</span><span class="s3">\n            </span><span class="s1">t.thisExpression(),</span><span class="s3">\n            </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">]),</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isNotTsParameter(</span><span class="s3">\n  </span><span class="s1">node: t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty,</span><span class="s3">\n</span><span class="s1">): node is t.Identifier | t.Pattern | t.RestElement {</span><span class="s3">\n  </span><span class="s1">return node.type !== </span><span class="s3">\&quot;</span><span class="s1">TSParameterProperty</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function movePrivateAccessor(</span><span class="s3">\n  </span><span class="s1">element: NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n  </span><span class="s1">key: t.PrivateName,</span><span class="s3">\n  </span><span class="s1">methodLocalVar: t.Identifier,</span><span class="s3">\n  </span><span class="s1">isStatic: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let params: (t.Identifier | t.RestElement)[];</span><span class="s3">\n  </span><span class="s1">let block: t.Statement[];</span><span class="s3">\n\n  </span><span class="s1">if (element.node.kind === </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">params = [t.identifier(</span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">)];</span><span class="s3">\n    </span><span class="s1">block = [</span><span class="s3">\n      </span><span class="s1">t.expressionStatement(</span><span class="s3">\n        </span><span class="s1">t.callExpression(methodLocalVar, [</span><span class="s3">\n          </span><span class="s1">t.thisExpression(),</span><span class="s3">\n          </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">params = [];</span><span class="s3">\n    </span><span class="s1">block = [</span><span class="s3">\n      </span><span class="s1">t.returnStatement(t.callExpression(methodLocalVar, [t.thisExpression()])),</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">element.replaceWith(</span><span class="s3">\n    </span><span class="s1">t.classPrivateMethod(</span><span class="s3">\n      </span><span class="s1">element.node.kind,</span><span class="s3">\n      </span><span class="s1">t.cloneNode(key),</span><span class="s3">\n      </span><span class="s1">params,</span><span class="s3">\n      </span><span class="s1">t.blockStatement(block),</span><span class="s3">\n      </span><span class="s1">isStatic,</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isClassDecoratableElementPath(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;ClassElement&gt;,</span><span class="s3">\n</span><span class="s1">): path is NodePath&lt;ClassDecoratableElement&gt; {</span><span class="s3">\n  </span><span class="s1">const { type } = path;</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">type !== </span><span class="s3">\&quot;</span><span class="s1">TSDeclareMethod</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">type !== </span><span class="s3">\&quot;</span><span class="s1">TSIndexSignature</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">type !== </span><span class="s3">\&quot;</span><span class="s1">StaticBlock</span><span class="s3">\&quot;\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function staticBlockToIIFE(block: t.StaticBlock) {</span><span class="s3">\n  </span><span class="s1">return t.callExpression(</span><span class="s3">\n    </span><span class="s1">t.arrowFunctionExpression([], t.blockStatement(block.body)),</span><span class="s3">\n    </span><span class="s1">[],</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function maybeSequenceExpression(exprs: t.Expression[]) {</span><span class="s3">\n  </span><span class="s1">if (exprs.length === 0) return t.unaryExpression(</span><span class="s3">\&quot;</span><span class="s1">void</span><span class="s3">\&quot;</span><span class="s1">, t.numericLiteral(0));</span><span class="s3">\n  </span><span class="s1">if (exprs.length === 1) return exprs[0];</span><span class="s3">\n  </span><span class="s1">return t.sequenceExpression(exprs);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function transformClass(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.ClassExpression | t.ClassDeclaration&gt;,</span><span class="s3">\n  </span><span class="s1">state: PluginPass,</span><span class="s3">\n  </span><span class="s1">constantSuper: boolean,</span><span class="s3">\n  </span><span class="s1">version: DecoratorVersionKind,</span><span class="s3">\n</span><span class="s1">): NodePath {</span><span class="s3">\n  </span><span class="s1">const body = path.get(</span><span class="s3">\&quot;</span><span class="s1">body.body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">const classDecorators = path.node.decorators;</span><span class="s3">\n  </span><span class="s1">let hasElementDecorators = false;</span><span class="s3">\n\n  </span><span class="s1">const generateClassPrivateUid = createLazyPrivateUidGeneratorForClass(path);</span><span class="s3">\n\n  </span><span class="s1">// Iterate over the class to see if we need to decorate it, and also to</span><span class="s3">\n  </span><span class="s1">// transform simple auto accessors which are not decorated</span><span class="s3">\n  </span><span class="s1">for (const element of body) {</span><span class="s3">\n    </span><span class="s1">if (!isClassDecoratableElementPath(element)) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (element.node.decorators &amp;&amp; element.node.decorators.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">hasElementDecorators = true;</span><span class="s3">\n    </span><span class="s1">} else if (element.node.type === </span><span class="s3">\&quot;</span><span class="s1">ClassAccessorProperty</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const { key, value, static: isStatic, computed } = element.node;</span><span class="s3">\n\n      </span><span class="s1">const newId = generateClassPrivateUid();</span><span class="s3">\n\n      </span><span class="s1">const valueNode = value ? t.cloneNode(value) : undefined;</span><span class="s3">\n\n      </span><span class="s1">const newField = generateClassProperty(newId, valueNode, isStatic);</span><span class="s3">\n\n      </span><span class="s1">const [newPath] = element.replaceWith(newField);</span><span class="s3">\n      </span><span class="s1">addProxyAccessorsFor(</span><span class="s3">\n        </span><span class="s1">path.node.id,</span><span class="s3">\n        </span><span class="s1">newPath,</span><span class="s3">\n        </span><span class="s1">key,</span><span class="s3">\n        </span><span class="s1">newId,</span><span class="s3">\n        </span><span class="s1">version,</span><span class="s3">\n        </span><span class="s1">computed,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If nothing is decorated, return</span><span class="s3">\n  </span><span class="s1">if (!classDecorators &amp;&amp; !hasElementDecorators) return;</span><span class="s3">\n\n  </span><span class="s1">const elementDecoratorInfo: (DecoratorInfo | ComputedPropInfo)[] = [];</span><span class="s3">\n\n  </span><span class="s1">// The initializer of the first non-static field will be injected with the protoInit call</span><span class="s3">\n  </span><span class="s1">let firstFieldPath:</span><span class="s3">\n    </span><span class="s1">| NodePath&lt;t.ClassProperty | t.ClassPrivateProperty&gt;</span><span class="s3">\n    </span><span class="s1">| undefined;</span><span class="s3">\n  </span><span class="s1">let constructorPath: NodePath&lt;t.ClassMethod&gt; | undefined;</span><span class="s3">\n  </span><span class="s1">let requiresProtoInit = false;</span><span class="s3">\n  </span><span class="s1">let requiresStaticInit = false;</span><span class="s3">\n  </span><span class="s1">const decoratedPrivateMethods = new Set&lt;string&gt;();</span><span class="s3">\n\n  </span><span class="s1">let protoInitLocal: t.Identifier,</span><span class="s3">\n    </span><span class="s1">staticInitLocal: t.Identifier,</span><span class="s3">\n    </span><span class="s1">classInitLocal: t.Identifier,</span><span class="s3">\n    </span><span class="s1">classIdLocal: t.Identifier;</span><span class="s3">\n  </span><span class="s1">const assignments: t.AssignmentExpression[] = [];</span><span class="s3">\n  </span><span class="s1">const scopeParent: Scope = path.scope.parent;</span><span class="s3">\n\n  </span><span class="s1">const memoiseExpression = (expression: t.Expression, hint: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const localEvaluatedId = scopeParent.generateDeclaredUidIdentifier(hint);</span><span class="s3">\n    </span><span class="s1">assignments.push(t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, localEvaluatedId, expression));</span><span class="s3">\n    </span><span class="s1">return t.cloneNode(localEvaluatedId);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">const decoratorsThis = new Map&lt;t.Decorator, t.Expression&gt;();</span><span class="s3">\n  </span><span class="s1">const maybeExtractDecorator = (decorator: t.Decorator) =&gt; {</span><span class="s3">\n    </span><span class="s1">const { expression } = decorator;</span><span class="s3">\n    </span><span class="s1">if (version === </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; t.isMemberExpression(expression)) {</span><span class="s3">\n      </span><span class="s1">let object;</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">t.isSuper(expression.object) ||</span><span class="s3">\n        </span><span class="s1">t.isThisExpression(expression.object)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">object = memoiseExpression(t.thisExpression(), </span><span class="s3">\&quot;</span><span class="s1">obj</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else if (!scopeParent.isStatic(expression.object)) {</span><span class="s3">\n        </span><span class="s1">object = memoiseExpression(expression.object, </span><span class="s3">\&quot;</span><span class="s1">obj</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">expression.object = object;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">object = expression.object;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">decoratorsThis.set(decorator, t.cloneNode(object));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!scopeParent.isStatic(expression)) {</span><span class="s3">\n      </span><span class="s1">decorator.expression = memoiseExpression(expression, </span><span class="s3">\&quot;</span><span class="s1">dec</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">if (classDecorators) {</span><span class="s3">\n    </span><span class="s1">classInitLocal = scopeParent.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">initClass</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">const [classId, classPath] = replaceClassWithVar(path);</span><span class="s3">\n    </span><span class="s1">path = classPath;</span><span class="s3">\n    </span><span class="s1">classIdLocal = classId;</span><span class="s3">\n\n    </span><span class="s1">path.node.decorators = null;</span><span class="s3">\n\n    </span><span class="s1">for (const classDecorator of classDecorators) {</span><span class="s3">\n      </span><span class="s1">maybeExtractDecorator(classDecorator);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (!path.node.id) {</span><span class="s3">\n      </span><span class="s1">path.node.id = path.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">Class</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">classIdLocal = t.cloneNode(path.node.id);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let lastInstancePrivateName: t.PrivateName;</span><span class="s3">\n  </span><span class="s1">let needsInstancePrivateBrandCheck = false;</span><span class="s3">\n\n  </span><span class="s1">if (hasElementDecorators) {</span><span class="s3">\n    </span><span class="s1">for (const element of body) {</span><span class="s3">\n      </span><span class="s1">if (!isClassDecoratableElementPath(element)) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const { node } = element;</span><span class="s3">\n      </span><span class="s1">const decorators = element.get(</span><span class="s3">\&quot;</span><span class="s1">decorators</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">const hasDecorators = Array.isArray(decorators) &amp;&amp; decorators.length &gt; 0;</span><span class="s3">\n\n      </span><span class="s1">if (hasDecorators) {</span><span class="s3">\n        </span><span class="s1">for (const decoratorPath of decorators) {</span><span class="s3">\n          </span><span class="s1">maybeExtractDecorator(decoratorPath.node);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const isComputed =</span><span class="s3">\n        \&quot;</span><span class="s1">computed</span><span class="s3">\&quot; </span><span class="s1">in element.node &amp;&amp; element.node.computed === true;</span><span class="s3">\n      </span><span class="s1">if (isComputed) {</span><span class="s3">\n        </span><span class="s1">if (!scopeParent.isStatic(node.key)) {</span><span class="s3">\n          </span><span class="s1">node.key = memoiseExpression(node.key as t.Expression, </span><span class="s3">\&quot;</span><span class="s1">computedKey</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const kind = getElementKind(element);</span><span class="s3">\n      </span><span class="s1">const { key } = node;</span><span class="s3">\n\n      </span><span class="s1">const isPrivate = key.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateName</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n      </span><span class="s1">const isStatic = !!element.node.static;</span><span class="s3">\n\n      </span><span class="s1">let name = </span><span class="s3">\&quot;</span><span class="s1">computedKey</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n      </span><span class="s1">if (isPrivate) {</span><span class="s3">\n        </span><span class="s1">name = key.id.name;</span><span class="s3">\n      </span><span class="s1">} else if (!isComputed &amp;&amp; key.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">name = key.name;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isPrivate &amp;&amp; !isStatic) {</span><span class="s3">\n        </span><span class="s1">if (hasDecorators) {</span><span class="s3">\n          </span><span class="s1">needsInstancePrivateBrandCheck = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (t.isClassPrivateProperty(node) || !lastInstancePrivateName) {</span><span class="s3">\n          </span><span class="s1">lastInstancePrivateName = key;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (element.isClassMethod({ kind: </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot; </span><span class="s1">})) {</span><span class="s3">\n        </span><span class="s1">constructorPath = element;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (hasDecorators) {</span><span class="s3">\n        </span><span class="s1">let locals: t.Identifier | t.Identifier[];</span><span class="s3">\n        </span><span class="s1">let privateMethods: Array&lt;</span><span class="s3">\n          </span><span class="s1">t.FunctionExpression | t.ArrowFunctionExpression</span><span class="s3">\n        </span><span class="s1">&gt;;</span><span class="s3">\n\n        </span><span class="s1">if (kind === ACCESSOR) {</span><span class="s3">\n          </span><span class="s1">const { value } = element.node as t.ClassAccessorProperty;</span><span class="s3">\n\n          </span><span class="s1">const params: t.Expression[] = [t.thisExpression()];</span><span class="s3">\n\n          </span><span class="s1">if (value) {</span><span class="s3">\n            </span><span class="s1">params.push(t.cloneNode(value));</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const newId = generateClassPrivateUid();</span><span class="s3">\n          </span><span class="s1">const newFieldInitId =</span><span class="s3">\n            </span><span class="s1">element.scope.parent.generateDeclaredUidIdentifier(`init_${name}`);</span><span class="s3">\n          </span><span class="s1">const newValue = t.callExpression(</span><span class="s3">\n            </span><span class="s1">t.cloneNode(newFieldInitId),</span><span class="s3">\n            </span><span class="s1">params,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n\n          </span><span class="s1">const newField = generateClassProperty(newId, newValue, isStatic);</span><span class="s3">\n          </span><span class="s1">const [newPath] = element.replaceWith(newField);</span><span class="s3">\n\n          </span><span class="s1">if (isPrivate) {</span><span class="s3">\n            </span><span class="s1">privateMethods = extractProxyAccessorsFor(newId, version);</span><span class="s3">\n\n            </span><span class="s1">const getId = newPath.scope.parent.generateDeclaredUidIdentifier(</span><span class="s3">\n              </span><span class="s1">`get_${name}`,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">const setId = newPath.scope.parent.generateDeclaredUidIdentifier(</span><span class="s3">\n              </span><span class="s1">`set_${name}`,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n\n            </span><span class="s1">addCallAccessorsFor(newPath, key, getId, setId);</span><span class="s3">\n\n            </span><span class="s1">locals = [newFieldInitId, getId, setId];</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">addProxyAccessorsFor(</span><span class="s3">\n              </span><span class="s1">path.node.id,</span><span class="s3">\n              </span><span class="s1">newPath,</span><span class="s3">\n              </span><span class="s1">key,</span><span class="s3">\n              </span><span class="s1">newId,</span><span class="s3">\n              </span><span class="s1">version,</span><span class="s3">\n              </span><span class="s1">isComputed,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">locals = newFieldInitId;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (kind === FIELD) {</span><span class="s3">\n          </span><span class="s1">const initId = element.scope.parent.generateDeclaredUidIdentifier(</span><span class="s3">\n            </span><span class="s1">`init_${name}`,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">const valuePath = (</span><span class="s3">\n            </span><span class="s1">element as NodePath&lt;t.ClassProperty | t.ClassPrivateProperty&gt;</span><span class="s3">\n          </span><span class="s1">).get(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n          </span><span class="s1">valuePath.replaceWith(</span><span class="s3">\n            </span><span class="s1">t.callExpression(</span><span class="s3">\n              </span><span class="s1">t.cloneNode(initId),</span><span class="s3">\n              </span><span class="s1">[t.thisExpression(), valuePath.node].filter(v =&gt; v),</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n\n          </span><span class="s1">locals = initId;</span><span class="s3">\n\n          </span><span class="s1">if (isPrivate) {</span><span class="s3">\n            </span><span class="s1">privateMethods = extractProxyAccessorsFor(key, version);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (isPrivate) {</span><span class="s3">\n          </span><span class="s1">locals = element.scope.parent.generateDeclaredUidIdentifier(</span><span class="s3">\n            </span><span class="s1">`call_${name}`,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n\n          </span><span class="s1">const replaceSupers = new ReplaceSupers({</span><span class="s3">\n            </span><span class="s1">constantSuper,</span><span class="s3">\n            </span><span class="s1">methodPath: element as NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n            </span><span class="s1">objectRef: classIdLocal,</span><span class="s3">\n            </span><span class="s1">superRef: path.node.superClass,</span><span class="s3">\n            </span><span class="s1">file: state.file,</span><span class="s3">\n            </span><span class="s1">refToPreserve: classIdLocal,</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n\n          </span><span class="s1">replaceSupers.replace();</span><span class="s3">\n\n          </span><span class="s1">const {</span><span class="s3">\n            </span><span class="s1">params,</span><span class="s3">\n            </span><span class="s1">body,</span><span class="s3">\n            </span><span class="s1">async: isAsync,</span><span class="s3">\n          </span><span class="s1">} = element.node as t.ClassPrivateMethod;</span><span class="s3">\n\n          </span><span class="s1">privateMethods = [</span><span class="s3">\n            </span><span class="s1">t.functionExpression(</span><span class="s3">\n              </span><span class="s1">undefined,</span><span class="s3">\n              </span><span class="s1">params.filter(isNotTsParameter),</span><span class="s3">\n              </span><span class="s1">body,</span><span class="s3">\n              </span><span class="s1">isAsync,</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">];</span><span class="s3">\n\n          </span><span class="s1">if (kind === GETTER || kind === SETTER) {</span><span class="s3">\n            </span><span class="s1">movePrivateAccessor(</span><span class="s3">\n              </span><span class="s1">element as NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n              </span><span class="s1">t.cloneNode(key),</span><span class="s3">\n              </span><span class="s1">t.cloneNode(locals),</span><span class="s3">\n              </span><span class="s1">isStatic,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">const node = element.node as t.ClassPrivateMethod;</span><span class="s3">\n\n            </span><span class="s1">// Unshift</span><span class="s3">\n            </span><span class="s1">path.node.body.body.unshift(</span><span class="s3">\n              </span><span class="s1">t.classPrivateProperty(key, t.cloneNode(locals), [], node.static),</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n\n            </span><span class="s1">decoratedPrivateMethods.add(key.id.name);</span><span class="s3">\n\n            </span><span class="s1">element.remove();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">let nameExpr: t.Expression;</span><span class="s3">\n\n        </span><span class="s1">if (isComputed) {</span><span class="s3">\n          </span><span class="s1">nameExpr = t.cloneNode(key as t.Expression);</span><span class="s3">\n        </span><span class="s1">} else if (key.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateName</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">nameExpr = t.stringLiteral(key.id.name);</span><span class="s3">\n        </span><span class="s1">} else if (key.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">nameExpr = t.stringLiteral(key.name);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">nameExpr = t.cloneNode(key as t.Expression);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">elementDecoratorInfo.push({</span><span class="s3">\n          </span><span class="s1">kind,</span><span class="s3">\n          </span><span class="s1">decorators: decorators.map(d =&gt; d.node.expression),</span><span class="s3">\n          </span><span class="s1">decoratorsThis: decorators.map(d =&gt; decoratorsThis.get(d.node)),</span><span class="s3">\n          </span><span class="s1">name: nameExpr,</span><span class="s3">\n          </span><span class="s1">isStatic,</span><span class="s3">\n          </span><span class="s1">privateMethods,</span><span class="s3">\n          </span><span class="s1">locals,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n\n        </span><span class="s1">if (kind !== FIELD) {</span><span class="s3">\n          </span><span class="s1">if (isStatic) {</span><span class="s3">\n            </span><span class="s1">requiresStaticInit = true;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">requiresProtoInit = true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (element.node) {</span><span class="s3">\n          </span><span class="s1">element.node.decorators = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">!firstFieldPath &amp;&amp;</span><span class="s3">\n          </span><span class="s1">!isStatic &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(kind === FIELD || kind === ACCESSOR)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">firstFieldPath = element as NodePath&lt;</span><span class="s3">\n            </span><span class="s1">t.ClassProperty | t.ClassPrivateProperty</span><span class="s3">\n          </span><span class="s1">&gt;;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const elementDecorations = generateDecorationExprs(</span><span class="s3">\n    </span><span class="s1">elementDecoratorInfo,</span><span class="s3">\n    </span><span class="s1">version,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">let classDecorationsFlag = 0;</span><span class="s3">\n  </span><span class="s1">let classDecorations: t.Expression[] = [];</span><span class="s3">\n  </span><span class="s1">if (classDecorators) {</span><span class="s3">\n    </span><span class="s1">const { hasThis, decs } = generateDecorationList(</span><span class="s3">\n      </span><span class="s1">classDecorators.map(el =&gt; el.expression),</span><span class="s3">\n      </span><span class="s1">classDecorators.map(dec =&gt; decoratorsThis.get(dec)),</span><span class="s3">\n      </span><span class="s1">version,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">classDecorationsFlag = hasThis ? 1 : 0;</span><span class="s3">\n    </span><span class="s1">classDecorations = decs;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const elementLocals: t.Identifier[] =</span><span class="s3">\n    </span><span class="s1">extractElementLocalAssignments(elementDecoratorInfo);</span><span class="s3">\n\n  </span><span class="s1">if (requiresProtoInit) {</span><span class="s3">\n    </span><span class="s1">protoInitLocal = scopeParent.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">initProto</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">elementLocals.push(protoInitLocal);</span><span class="s3">\n\n    </span><span class="s1">const protoInitCall = t.callExpression(t.cloneNode(protoInitLocal), [</span><span class="s3">\n      </span><span class="s1">t.thisExpression(),</span><span class="s3">\n    </span><span class="s1">]);</span><span class="s3">\n\n    </span><span class="s1">if (firstFieldPath) {</span><span class="s3">\n      </span><span class="s1">const value = firstFieldPath.get(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const body: t.Expression[] = [protoInitCall];</span><span class="s3">\n\n      </span><span class="s1">if (value.node) {</span><span class="s3">\n        </span><span class="s1">body.push(value.node);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">value.replaceWith(t.sequenceExpression(body));</span><span class="s3">\n    </span><span class="s1">} else if (constructorPath) {</span><span class="s3">\n      </span><span class="s1">if (path.node.superClass) {</span><span class="s3">\n        </span><span class="s1">path.traverse({</span><span class="s3">\n          </span><span class="s1">CallExpression: {</span><span class="s3">\n            </span><span class="s1">exit(path) {</span><span class="s3">\n              </span><span class="s1">if (!path.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">).isSuper()) return;</span><span class="s3">\n\n              </span><span class="s1">path.replaceWith(</span><span class="s3">\n                </span><span class="s1">t.callExpression(t.cloneNode(protoInitLocal), [path.node]),</span><span class="s3">\n              </span><span class="s1">);</span><span class="s3">\n\n              </span><span class="s1">path.skip();</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">constructorPath.node.body.body.unshift(</span><span class="s3">\n          </span><span class="s1">t.expressionStatement(protoInitCall),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const body: t.Statement[] = [t.expressionStatement(protoInitCall)];</span><span class="s3">\n\n      </span><span class="s1">if (path.node.superClass) {</span><span class="s3">\n        </span><span class="s1">body.unshift(</span><span class="s3">\n          </span><span class="s1">t.expressionStatement(</span><span class="s3">\n            </span><span class="s1">t.callExpression(t.super(), [</span><span class="s3">\n              </span><span class="s1">t.spreadElement(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">args</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n            </span><span class="s1">]),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">path.node.body.body.unshift(</span><span class="s3">\n        </span><span class="s1">t.classMethod(</span><span class="s3">\n          \&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">[t.restElement(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">args</span><span class="s3">\&quot;</span><span class="s1">))],</span><span class="s3">\n          </span><span class="s1">t.blockStatement(body),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (requiresStaticInit) {</span><span class="s3">\n    </span><span class="s1">staticInitLocal = scopeParent.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">initStatic</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">elementLocals.push(staticInitLocal);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (decoratedPrivateMethods.size &gt; 0) {</span><span class="s3">\n    </span><span class="s1">path.traverse({</span><span class="s3">\n      </span><span class="s1">PrivateName(path) {</span><span class="s3">\n        </span><span class="s1">if (!decoratedPrivateMethods.has(path.node.id.name)) return;</span><span class="s3">\n\n        </span><span class="s1">const parentPath = path.parentPath;</span><span class="s3">\n        </span><span class="s1">const parentParentPath = parentPath.parentPath;</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">// this.bar().#x = 123;</span><span class="s3">\n          </span><span class="s1">(parentParentPath.node.type === </span><span class="s3">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n            </span><span class="s1">parentParentPath.node.left === parentPath.node) ||</span><span class="s3">\n          </span><span class="s1">// this.#x++;</span><span class="s3">\n          </span><span class="s1">parentParentPath.node.type === </span><span class="s3">\&quot;</span><span class="s1">UpdateExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n          </span><span class="s1">// ([...this.#x] = foo);</span><span class="s3">\n          </span><span class="s1">parentParentPath.node.type === </span><span class="s3">\&quot;</span><span class="s1">RestElement</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n          </span><span class="s1">// ([this.#x] = foo);</span><span class="s3">\n          </span><span class="s1">parentParentPath.node.type === </span><span class="s3">\&quot;</span><span class="s1">ArrayPattern</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n          </span><span class="s1">// ({ a: this.#x } = bar);</span><span class="s3">\n          </span><span class="s1">(parentParentPath.node.type === </span><span class="s3">\&quot;</span><span class="s1">ObjectProperty</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n            </span><span class="s1">parentParentPath.node.value === parentPath.node &amp;&amp;</span><span class="s3">\n            </span><span class="s1">parentParentPath.parentPath.type === </span><span class="s3">\&quot;</span><span class="s1">ObjectPattern</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n          </span><span class="s1">// for (this.#x of []);</span><span class="s3">\n          </span><span class="s1">(parentParentPath.node.type === </span><span class="s3">\&quot;</span><span class="s1">ForOfStatement</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n            </span><span class="s1">parentParentPath.node.left === parentPath.node)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n            </span><span class="s1">`Decorated private methods are not updatable, but </span><span class="s3">\&quot;</span><span class="s1">#${path.node.id.name}</span><span class="s3">\&quot; </span><span class="s1">is updated via this expression.`,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const classLocals: t.Identifier[] = [];</span><span class="s3">\n  </span><span class="s1">let classInitInjected = false;</span><span class="s3">\n  </span><span class="s1">const classInitCall =</span><span class="s3">\n    </span><span class="s1">classInitLocal &amp;&amp; t.callExpression(t.cloneNode(classInitLocal), []);</span><span class="s3">\n\n  </span><span class="s1">const originalClass = path.node;</span><span class="s3">\n\n  </span><span class="s1">if (classDecorators) {</span><span class="s3">\n    </span><span class="s1">classLocals.push(classIdLocal, classInitLocal);</span><span class="s3">\n    </span><span class="s1">const statics: (</span><span class="s3">\n      </span><span class="s1">| t.ClassProperty</span><span class="s3">\n      </span><span class="s1">| t.ClassPrivateProperty</span><span class="s3">\n      </span><span class="s1">| t.ClassPrivateMethod</span><span class="s3">\n    </span><span class="s1">)[] = [];</span><span class="s3">\n    </span><span class="s1">let staticBlocks: t.StaticBlock[] = [];</span><span class="s3">\n    </span><span class="s1">path.get(</span><span class="s3">\&quot;</span><span class="s1">body.body</span><span class="s3">\&quot;</span><span class="s1">).forEach(element =&gt; {</span><span class="s3">\n      </span><span class="s1">// Static blocks cannot be compiled to </span><span class="s3">\&quot;</span><span class="s1">instance blocks</span><span class="s3">\&quot;</span><span class="s1">, but we can inline</span><span class="s3">\n      </span><span class="s1">// them as IIFEs in the next property.</span><span class="s3">\n      </span><span class="s1">if (element.isStaticBlock()) {</span><span class="s3">\n        </span><span class="s1">staticBlocks.push(element.node);</span><span class="s3">\n        </span><span class="s1">element.remove();</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const isProperty =</span><span class="s3">\n        </span><span class="s1">element.isClassProperty() || element.isClassPrivateProperty();</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">(isProperty || element.isClassPrivateMethod()) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">element.node.static</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (isProperty &amp;&amp; staticBlocks.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">const allValues: t.Expression[] = staticBlocks.map(staticBlockToIIFE);</span><span class="s3">\n          </span><span class="s1">if (element.node.value) allValues.push(element.node.value);</span><span class="s3">\n          </span><span class="s1">element.node.value = maybeSequenceExpression(allValues);</span><span class="s3">\n          </span><span class="s1">staticBlocks = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">element.node.static = false;</span><span class="s3">\n        </span><span class="s1">statics.push(element.node);</span><span class="s3">\n        </span><span class="s1">element.remove();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">if (statics.length &gt; 0 || staticBlocks.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">const staticsClass = template.expression.ast`</span><span class="s3">\n        </span><span class="s1">class extends ${state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">identity</span><span class="s3">\&quot;</span><span class="s1">)} {}</span><span class="s3">\n      </span><span class="s1">` as t.ClassExpression;</span><span class="s3">\n      </span><span class="s1">staticsClass.body.body = [</span><span class="s3">\n        </span><span class="s1">t.staticBlock([</span><span class="s3">\n          </span><span class="s1">t.toStatement(originalClass, true) ||</span><span class="s3">\n            </span><span class="s1">// If toStatement returns false, originalClass must be an anonymous ClassExpression,</span><span class="s3">\n            </span><span class="s1">// because `export default @dec ...` has been handled in the export visitor before.</span><span class="s3">\n            </span><span class="s1">t.expressionStatement(originalClass as t.ClassExpression),</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">...statics,</span><span class="s3">\n      </span><span class="s1">];</span><span class="s3">\n\n      </span><span class="s1">const constructorBody: t.Expression[] = [];</span><span class="s3">\n\n      </span><span class="s1">const newExpr = t.newExpression(staticsClass, []);</span><span class="s3">\n\n      </span><span class="s1">if (staticBlocks.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">constructorBody.push(...staticBlocks.map(staticBlockToIIFE));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (classInitCall) {</span><span class="s3">\n        </span><span class="s1">classInitInjected = true;</span><span class="s3">\n        </span><span class="s1">constructorBody.push(classInitCall);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (constructorBody.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">constructorBody.unshift(</span><span class="s3">\n          </span><span class="s1">t.callExpression(t.super(), [t.cloneNode(classIdLocal)]),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">staticsClass.body.body.push(</span><span class="s3">\n          </span><span class="s1">t.classMethod(</span><span class="s3">\n            \&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">[],</span><span class="s3">\n            </span><span class="s1">t.blockStatement([</span><span class="s3">\n              </span><span class="s1">t.expressionStatement(t.sequenceExpression(constructorBody)),</span><span class="s3">\n            </span><span class="s1">]),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">newExpr.arguments.push(t.cloneNode(classIdLocal));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">path.replaceWith(newExpr);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!classInitInjected &amp;&amp; classInitCall) {</span><span class="s3">\n    </span><span class="s1">path.node.body.body.push(</span><span class="s3">\n      </span><span class="s1">t.staticBlock([t.expressionStatement(classInitCall)]),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let { superClass } = originalClass;</span><span class="s3">\n  </span><span class="s1">if (superClass &amp;&amp; (process.env.BABEL_8_BREAKING || version === </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n    </span><span class="s1">const id = path.scope.maybeGenerateMemoised(superClass);</span><span class="s3">\n    </span><span class="s1">if (id) {</span><span class="s3">\n      </span><span class="s1">originalClass.superClass = t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, id, superClass);</span><span class="s3">\n      </span><span class="s1">superClass = id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">originalClass.body.body.unshift(</span><span class="s3">\n    </span><span class="s1">t.staticBlock(</span><span class="s3">\n      </span><span class="s1">[</span><span class="s3">\n        </span><span class="s1">t.expressionStatement(</span><span class="s3">\n          </span><span class="s1">createLocalsAssignment(</span><span class="s3">\n            </span><span class="s1">elementLocals,</span><span class="s3">\n            </span><span class="s1">classLocals,</span><span class="s3">\n            </span><span class="s1">elementDecorations,</span><span class="s3">\n            </span><span class="s1">t.arrayExpression(classDecorations),</span><span class="s3">\n            </span><span class="s1">t.numericLiteral(classDecorationsFlag),</span><span class="s3">\n            </span><span class="s1">needsInstancePrivateBrandCheck ? lastInstancePrivateName : null,</span><span class="s3">\n            </span><span class="s1">t.cloneNode(superClass),</span><span class="s3">\n            </span><span class="s1">state,</span><span class="s3">\n            </span><span class="s1">version,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">requiresStaticInit &amp;&amp;</span><span class="s3">\n          </span><span class="s1">t.expressionStatement(</span><span class="s3">\n            </span><span class="s1">t.callExpression(t.cloneNode(staticInitLocal), [</span><span class="s3">\n              </span><span class="s1">t.thisExpression(),</span><span class="s3">\n            </span><span class="s1">]),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">].filter(Boolean),</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">// When path is a ClassExpression, path.insertBefore will convert `path`</span><span class="s3">\n  </span><span class="s1">// into a SequenceExpression</span><span class="s3">\n  </span><span class="s1">path.insertBefore(assignments.map(expr =&gt; t.expressionStatement(expr)));</span><span class="s3">\n\n  </span><span class="s1">// Recrawl the scope to make sure new identifiers are properly synced</span><span class="s3">\n  </span><span class="s1">path.scope.crawl();</span><span class="s3">\n\n  </span><span class="s1">return path;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createLocalsAssignment(</span><span class="s3">\n  </span><span class="s1">elementLocals: t.Identifier[],</span><span class="s3">\n  </span><span class="s1">classLocals: t.Identifier[],</span><span class="s3">\n  </span><span class="s1">elementDecorations: t.ArrayExpression,</span><span class="s3">\n  </span><span class="s1">classDecorations: t.ArrayExpression,</span><span class="s3">\n  </span><span class="s1">classDecorationsFlag: t.NumericLiteral,</span><span class="s3">\n  </span><span class="s1">maybePrivateBranName: t.PrivateName | null,</span><span class="s3">\n  </span><span class="s1">superClass: null | t.Expression,</span><span class="s3">\n  </span><span class="s1">state: PluginPass,</span><span class="s3">\n  </span><span class="s1">version: DecoratorVersionKind,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let lhs, rhs;</span><span class="s3">\n  </span><span class="s1">const args: t.Expression[] = [</span><span class="s3">\n    </span><span class="s1">t.thisExpression(),</span><span class="s3">\n    </span><span class="s1">elementDecorations,</span><span class="s3">\n    </span><span class="s1">classDecorations,</span><span class="s3">\n  </span><span class="s1">];</span><span class="s3">\n\n  </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">version === </span><span class="s3">\&quot;</span><span class="s1">2021-12</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">(version === </span><span class="s3">\&quot;</span><span class="s1">2022-03</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !state.availableHelper(</span><span class="s3">\&quot;</span><span class="s1">applyDecs2203R</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const lhs = t.arrayPattern([...elementLocals, ...classLocals]);</span><span class="s3">\n      </span><span class="s1">const rhs = t.callExpression(</span><span class="s3">\n        </span><span class="s1">state.addHelper(version === </span><span class="s3">\&quot;</span><span class="s1">2021-12</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">applyDecs</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">applyDecs2203</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">args,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">return t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, lhs, rhs);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.BABEL_8_BREAKING || version === </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">maybePrivateBranName ||</span><span class="s3">\n      </span><span class="s1">superClass ||</span><span class="s3">\n      </span><span class="s1">classDecorationsFlag.value !== 0</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">args.push(classDecorationsFlag);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (maybePrivateBranName) {</span><span class="s3">\n      </span><span class="s1">args.push(</span><span class="s3">\n        </span><span class="s1">template.expression.ast`</span><span class="s3">\n            </span><span class="s1">_ =&gt; ${t.cloneNode(maybePrivateBranName)} in _</span><span class="s3">\n          </span><span class="s1">` as t.ArrowFunctionExpression,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else if (superClass) {</span><span class="s3">\n      </span><span class="s1">args.push(t.unaryExpression(</span><span class="s3">\&quot;</span><span class="s1">void</span><span class="s3">\&quot;</span><span class="s1">, t.numericLiteral(0)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (superClass) args.push(superClass);</span><span class="s3">\n    </span><span class="s1">rhs = t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">applyDecs2305</span><span class="s3">\&quot;</span><span class="s1">), args);</span><span class="s3">\n  </span><span class="s1">} else if (version === </span><span class="s3">\&quot;</span><span class="s1">2023-01</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (maybePrivateBranName) {</span><span class="s3">\n      </span><span class="s1">args.push(</span><span class="s3">\n        </span><span class="s1">template.expression.ast`</span><span class="s3">\n            </span><span class="s1">_ =&gt; ${t.cloneNode(maybePrivateBranName)} in _</span><span class="s3">\n          </span><span class="s1">` as t.ArrowFunctionExpression,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">rhs = t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">applyDecs2301</span><span class="s3">\&quot;</span><span class="s1">), args);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">rhs = t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">applyDecs2203R</span><span class="s3">\&quot;</span><span class="s1">), args);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// optimize `{ c: [classLocals] } = applyapplyDecs2203R(...)` to</span><span class="s3">\n  </span><span class="s1">// `[classLocals] = applyapplyDecs2203R(...).c`</span><span class="s3">\n  </span><span class="s1">if (elementLocals.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">if (classLocals.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">lhs = t.objectPattern([</span><span class="s3">\n        </span><span class="s1">t.objectProperty(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">e</span><span class="s3">\&quot;</span><span class="s1">), t.arrayPattern(elementLocals)),</span><span class="s3">\n        </span><span class="s1">t.objectProperty(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">c</span><span class="s3">\&quot;</span><span class="s1">), t.arrayPattern(classLocals)),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">lhs = t.arrayPattern(elementLocals);</span><span class="s3">\n      </span><span class="s1">rhs = t.memberExpression(rhs, t.identifier(</span><span class="s3">\&quot;</span><span class="s1">e</span><span class="s3">\&quot;</span><span class="s1">), false, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// invariant: classLocals.length &gt; 0</span><span class="s3">\n    </span><span class="s1">lhs = t.arrayPattern(classLocals);</span><span class="s3">\n    </span><span class="s1">rhs = t.memberExpression(rhs, t.identifier(</span><span class="s3">\&quot;</span><span class="s1">c</span><span class="s3">\&quot;</span><span class="s1">), false, false);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, lhs, rhs);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default function (</span><span class="s3">\n  </span><span class="s1">{ assertVersion, assumption }: PluginAPI,</span><span class="s3">\n  </span><span class="s1">{ loose }: Options,</span><span class="s3">\n  </span><span class="s1">// TODO(Babel 8): Only keep 2023-05</span><span class="s3">\n  </span><span class="s1">version: </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">2023-01</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">2022-03</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">2021-12</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">): PluginObject {</span><span class="s3">\n  </span><span class="s1">if (process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">assertVersion(</span><span class="s3">\&quot;</span><span class="s1">^7.21.0</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (version === </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot; </span><span class="s1">|| version === </span><span class="s3">\&quot;</span><span class="s1">2023-01</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">assertVersion(</span><span class="s3">\&quot;</span><span class="s1">^7.21.0</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else if (version === </span><span class="s3">\&quot;</span><span class="s1">2021-12</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">assertVersion(</span><span class="s3">\&quot;</span><span class="s1">^7.16.0</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">assertVersion(</span><span class="s3">\&quot;</span><span class="s1">^7.19.0</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const VISITED = new WeakSet&lt;NodePath&gt;();</span><span class="s3">\n  </span><span class="s1">const constantSuper = assumption(</span><span class="s3">\&quot;</span><span class="s1">constantSuper</span><span class="s3">\&quot;</span><span class="s1">) ?? loose;</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">proposal-decorators</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">inherits: syntaxDecorators,</span><span class="s3">\n\n    </span><span class="s1">visitor: {</span><span class="s3">\n      \&quot;</span><span class="s1">ExportNamedDeclaration|ExportDefaultDeclaration</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\n        </span><span class="s1">path: NodePath&lt;t.ExportNamedDeclaration | t.ExportDefaultDeclaration&gt;,</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const { declaration } = path.node;</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">declaration?.type === </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n          </span><span class="s1">// When compiling class decorators we need to replace the class</span><span class="s3">\n          </span><span class="s1">// binding, so we must split it in two separate declarations.</span><span class="s3">\n          </span><span class="s1">declaration.decorators?.length &gt; 0</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">splitExportDeclaration(path);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n\n      </span><span class="s1">Class(path, state) {</span><span class="s3">\n        </span><span class="s1">if (VISITED.has(path)) return;</span><span class="s3">\n\n        </span><span class="s1">const newPath = transformClass(path, state, constantSuper, version);</span><span class="s3">\n        </span><span class="s1">if (newPath) VISITED.add(newPath);</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>