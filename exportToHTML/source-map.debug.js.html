<html>
<head>
<title>source-map.debug.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #cf8e6d;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #7a7e85;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
.s7 { color: #67a37c; font-style: italic;}
.s8 { color: #42c3d4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
source-map.debug.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s2">webpackUniversalModuleDefinition</span><span class="s0">(</span><span class="s2">root</span><span class="s0">, </span><span class="s2">factory</span><span class="s0">) {</span>
	<span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">exports </span><span class="s0">=== </span><span class="s3">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s2">module </span><span class="s0">=== </span><span class="s3">'object'</span><span class="s0">)</span>
		<span class="s2">module</span><span class="s0">.</span><span class="s2">exports </span><span class="s0">= </span><span class="s2">factory</span><span class="s0">();</span>
	<span class="s1">else if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">define </span><span class="s0">=== </span><span class="s3">'function' </span><span class="s0">&amp;&amp; </span><span class="s2">define</span><span class="s0">.</span><span class="s2">amd</span><span class="s0">)</span>
		<span class="s2">define</span><span class="s0">([], </span><span class="s2">factory</span><span class="s0">);</span>
	<span class="s1">else if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">exports </span><span class="s0">=== </span><span class="s3">'object'</span><span class="s0">)</span>
		<span class="s2">exports</span><span class="s0">[</span><span class="s3">&quot;sourceMap&quot;</span><span class="s0">] = </span><span class="s2">factory</span><span class="s0">();</span>
	<span class="s1">else</span>
		<span class="s2">root</span><span class="s0">[</span><span class="s3">&quot;sourceMap&quot;</span><span class="s0">] = </span><span class="s2">factory</span><span class="s0">();</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
<span class="s1">return </span><span class="s4">/******/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(</span><span class="s2">modules</span><span class="s0">) { </span><span class="s4">// webpackBootstrap</span>
<span class="s4">/******/ 	// The module cache</span>
<span class="s4">/******/ 	</span><span class="s1">var </span><span class="s2">installedModules </span><span class="s0">= {};</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 	// The require function</span>
<span class="s4">/******/ 	</span><span class="s1">function </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s2">moduleId</span><span class="s0">) {</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 		// Check if module is in cache</span>
<span class="s4">/******/ 		</span><span class="s1">if</span><span class="s0">(</span><span class="s2">installedModules</span><span class="s0">[</span><span class="s2">moduleId</span><span class="s0">])</span>
<span class="s4">/******/ 			</span><span class="s1">return </span><span class="s2">installedModules</span><span class="s0">[</span><span class="s2">moduleId</span><span class="s0">].</span><span class="s2">exports</span><span class="s0">;</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 		// Create a new module (and put it into the cache)</span>
<span class="s4">/******/ 		</span><span class="s1">var </span><span class="s2">module </span><span class="s0">= </span><span class="s2">installedModules</span><span class="s0">[</span><span class="s2">moduleId</span><span class="s0">] = {</span>
<span class="s4">/******/ 			</span><span class="s2">exports</span><span class="s0">: {},</span>
<span class="s4">/******/ 			</span><span class="s2">id</span><span class="s0">: </span><span class="s2">moduleId</span><span class="s0">,</span>
<span class="s4">/******/ 			</span><span class="s2">loaded</span><span class="s0">: </span><span class="s1">false</span>
<span class="s4">/******/ 		</span><span class="s0">};</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 		// Execute the module function</span>
<span class="s4">/******/ 		</span><span class="s2">modules</span><span class="s0">[</span><span class="s2">moduleId</span><span class="s0">].</span><span class="s2">call</span><span class="s0">(</span><span class="s2">module</span><span class="s0">.</span><span class="s2">exports</span><span class="s0">, </span><span class="s2">module</span><span class="s0">, </span><span class="s2">module</span><span class="s0">.</span><span class="s2">exports</span><span class="s0">, </span><span class="s2">__webpack_require__</span><span class="s0">);</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 		// Flag the module as loaded</span>
<span class="s4">/******/ 		</span><span class="s2">module</span><span class="s0">.</span><span class="s2">loaded </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 		// Return the exports of the module</span>
<span class="s4">/******/ 		</span><span class="s1">return </span><span class="s2">module</span><span class="s0">.</span><span class="s2">exports</span><span class="s0">;</span>
<span class="s4">/******/ 	</span><span class="s0">}</span>
<span class="s4">/******/</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 	// expose the modules object (__webpack_modules__)</span>
<span class="s4">/******/ 	</span><span class="s2">__webpack_require__</span><span class="s0">.</span><span class="s2">m </span><span class="s0">= </span><span class="s2">modules</span><span class="s0">;</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 	// expose the module cache</span>
<span class="s4">/******/ 	</span><span class="s2">__webpack_require__</span><span class="s0">.</span><span class="s2">c </span><span class="s0">= </span><span class="s2">installedModules</span><span class="s0">;</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 	// __webpack_public_path__</span>
<span class="s4">/******/ 	</span><span class="s2">__webpack_require__</span><span class="s0">.</span><span class="s2">p </span><span class="s0">= </span><span class="s3">&quot;&quot;</span><span class="s0">;</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 	// Load entry module and return exports</span>
<span class="s4">/******/ 	</span><span class="s1">return </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">0</span><span class="s0">);</span>
<span class="s4">/******/ </span><span class="s0">})</span>
<span class="s4">/************************************************************************/</span>
<span class="s4">/******/ </span><span class="s0">([</span>
<span class="s4">/* 0 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(</span><span class="s2">module</span><span class="s0">, </span><span class="s2">exports</span><span class="s0">, </span><span class="s2">__webpack_require__</span><span class="s0">) {</span>

	<span class="s4">/* 
     * Copyright 2009-2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE.txt or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">SourceMapGenerator </span><span class="s0">= </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">1</span><span class="s0">).</span><span class="s2">SourceMapGenerator</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">SourceMapConsumer </span><span class="s0">= </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">7</span><span class="s0">).</span><span class="s2">SourceMapConsumer</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">SourceNode </span><span class="s0">= </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">10</span><span class="s0">).</span><span class="s2">SourceNode</span><span class="s0">;</span>


<span class="s4">/***/ </span><span class="s0">}),</span>
<span class="s4">/* 1 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(</span><span class="s2">module</span><span class="s0">, </span><span class="s2">exports</span><span class="s0">, </span><span class="s2">__webpack_require__</span><span class="s0">) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s2">base64VLQ </span><span class="s0">= </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">2</span><span class="s0">);</span>
	<span class="s1">var </span><span class="s2">util </span><span class="s0">= </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">4</span><span class="s0">);</span>
	<span class="s1">var </span><span class="s2">ArraySet </span><span class="s0">= </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">5</span><span class="s0">).</span><span class="s2">ArraySet</span><span class="s0">;</span>
	<span class="s1">var </span><span class="s2">MappingList </span><span class="s0">= </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">6</span><span class="s0">).</span><span class="s2">MappingList</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* An instance of the SourceMapGenerator represents a source map which is</span>
	 <span class="s6">* being built incrementally. You may pass an object with the following</span>
	 <span class="s6">* properties:</span>
	 <span class="s6">*</span>
	 <span class="s6">*   - file: The filename of the generated source.</span>
	 <span class="s6">*   - sourceRoot: A root for all relative URLs in this source map.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">SourceMapGenerator</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">aArgs</span><span class="s0">) {</span>
	    <span class="s2">aArgs </span><span class="s0">= {};</span>
	  <span class="s0">}</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_file </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'file'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_sourceRoot </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'sourceRoot'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_skipValidation </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'skipValidation'</span><span class="s0">, </span><span class="s1">false</span><span class="s0">);</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_sources </span><span class="s0">= </span><span class="s1">new </span><span class="s2">ArraySet</span><span class="s0">();</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_names </span><span class="s0">= </span><span class="s1">new </span><span class="s2">ArraySet</span><span class="s0">();</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_mappings </span><span class="s0">= </span><span class="s1">new </span><span class="s2">MappingList</span><span class="s0">();</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_sourcesContents </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
	<span class="s0">}</span>
	
	<span class="s2">SourceMapGenerator</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">_version </span><span class="s0">= </span><span class="s5">3</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Creates a new SourceMapGenerator based on a SourceMapConsumer</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSourceMapConsumer The SourceMap.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceMapGenerator</span><span class="s0">.</span><span class="s2">fromSourceMap </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapGenerator_fromSourceMap</span><span class="s0">(</span><span class="s2">aSourceMapConsumer</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">sourceRoot </span><span class="s0">= </span><span class="s2">aSourceMapConsumer</span><span class="s0">.</span><span class="s2">sourceRoot</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">generator </span><span class="s0">= </span><span class="s1">new </span><span class="s2">SourceMapGenerator</span><span class="s0">({</span>
	      <span class="s2">file</span><span class="s0">: </span><span class="s2">aSourceMapConsumer</span><span class="s0">.</span><span class="s2">file</span><span class="s0">,</span>
	      <span class="s2">sourceRoot</span><span class="s0">: </span><span class="s2">sourceRoot</span>
	    <span class="s0">});</span>
	    <span class="s2">aSourceMapConsumer</span><span class="s0">.</span><span class="s2">eachMapping</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">newMapping </span><span class="s0">= {</span>
	        <span class="s2">generated</span><span class="s0">: {</span>
	          <span class="s2">line</span><span class="s0">: </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedLine</span><span class="s0">,</span>
	          <span class="s2">column</span><span class="s0">: </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedColumn</span>
	        <span class="s0">}</span>
	      <span class="s0">};</span>
	
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">source </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s2">newMapping</span><span class="s0">.</span><span class="s2">source </span><span class="s0">= </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">source</span><span class="s0">;</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">sourceRoot </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s2">newMapping</span><span class="s0">.</span><span class="s2">source </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">relative</span><span class="s0">(</span><span class="s2">sourceRoot</span><span class="s0">, </span><span class="s2">newMapping</span><span class="s0">.</span><span class="s2">source</span><span class="s0">);</span>
	        <span class="s0">}</span>
	
	        <span class="s2">newMapping</span><span class="s0">.</span><span class="s2">original </span><span class="s0">= {</span>
	          <span class="s2">line</span><span class="s0">: </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalLine</span><span class="s0">,</span>
	          <span class="s2">column</span><span class="s0">: </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalColumn</span>
	        <span class="s0">};</span>
	
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">name </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s2">newMapping</span><span class="s0">.</span><span class="s2">name </span><span class="s0">= </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">name</span><span class="s0">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	
	      <span class="s2">generator</span><span class="s0">.</span><span class="s2">addMapping</span><span class="s0">(</span><span class="s2">newMapping</span><span class="s0">);</span>
	    <span class="s0">});</span>
	    <span class="s2">aSourceMapConsumer</span><span class="s0">.</span><span class="s2">sources</span><span class="s0">.</span><span class="s2">forEach</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">sourceFile</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">sourceRelative </span><span class="s0">= </span><span class="s2">sourceFile</span><span class="s0">;</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">sourceRoot </span><span class="s0">!== </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s2">sourceRelative </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">relative</span><span class="s0">(</span><span class="s2">sourceRoot</span><span class="s0">, </span><span class="s2">sourceFile</span><span class="s0">);</span>
	      <span class="s0">}</span>
	
	      <span class="s1">if </span><span class="s0">(!</span><span class="s2">generator</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">sourceRelative</span><span class="s0">)) {</span>
	        <span class="s2">generator</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">sourceRelative</span><span class="s0">);</span>
	      <span class="s0">}</span>
	
	      <span class="s1">var </span><span class="s2">content </span><span class="s0">= </span><span class="s2">aSourceMapConsumer</span><span class="s0">.</span><span class="s2">sourceContentFor</span><span class="s0">(</span><span class="s2">sourceFile</span><span class="s0">);</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">content </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s2">generator</span><span class="s0">.</span><span class="s2">setSourceContent</span><span class="s0">(</span><span class="s2">sourceFile</span><span class="s0">, </span><span class="s2">content</span><span class="s0">);</span>
	      <span class="s0">}</span>
	    <span class="s0">});</span>
	    <span class="s1">return </span><span class="s2">generator</span><span class="s0">;</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Add a single mapping from original source line and column to the generated</span>
	 <span class="s6">* source's line and column for this source map being created. The mapping</span>
	 <span class="s6">* object should have the following properties:</span>
	 <span class="s6">*</span>
	 <span class="s6">*   - generated: An object with the generated line and column positions.</span>
	 <span class="s6">*   - original: An object with the original line and column positions.</span>
	 <span class="s6">*   - source: The original source file (relative to the sourceRoot).</span>
	 <span class="s6">*   - name: An optional original token name for this mapping.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceMapGenerator</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">addMapping </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapGenerator_addMapping</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">generated </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'generated'</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s2">original </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'original'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s2">source </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'source'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s2">name </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'name'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_skipValidation</span><span class="s0">) {</span>
	      <span class="s1">this</span><span class="s0">.</span><span class="s2">_validateMapping</span><span class="s0">(</span><span class="s2">generated</span><span class="s0">, </span><span class="s2">original</span><span class="s0">, </span><span class="s2">source</span><span class="s0">, </span><span class="s2">name</span><span class="s0">);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">source </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s2">source </span><span class="s0">= </span><span class="s2">String</span><span class="s0">(</span><span class="s2">source</span><span class="s0">);</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">source</span><span class="s0">)) {</span>
	        <span class="s1">this</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">source</span><span class="s0">);</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">name </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s2">name </span><span class="s0">= </span><span class="s2">String</span><span class="s0">(</span><span class="s2">name</span><span class="s0">);</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_names</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">name</span><span class="s0">)) {</span>
	        <span class="s1">this</span><span class="s0">.</span><span class="s2">_names</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">name</span><span class="s0">);</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">_mappings</span><span class="s0">.</span><span class="s2">add</span><span class="s0">({</span>
	      <span class="s2">generatedLine</span><span class="s0">: </span><span class="s2">generated</span><span class="s0">.</span><span class="s2">line</span><span class="s0">,</span>
	      <span class="s2">generatedColumn</span><span class="s0">: </span><span class="s2">generated</span><span class="s0">.</span><span class="s2">column</span><span class="s0">,</span>
	      <span class="s2">originalLine</span><span class="s0">: </span><span class="s2">original </span><span class="s0">!= </span><span class="s1">null </span><span class="s0">&amp;&amp; </span><span class="s2">original</span><span class="s0">.</span><span class="s2">line</span><span class="s0">,</span>
	      <span class="s2">originalColumn</span><span class="s0">: </span><span class="s2">original </span><span class="s0">!= </span><span class="s1">null </span><span class="s0">&amp;&amp; </span><span class="s2">original</span><span class="s0">.</span><span class="s2">column</span><span class="s0">,</span>
	      <span class="s2">source</span><span class="s0">: </span><span class="s2">source</span><span class="s0">,</span>
	      <span class="s2">name</span><span class="s0">: </span><span class="s2">name</span>
	    <span class="s0">});</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Set the source content for a source file.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceMapGenerator</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">setSourceContent </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapGenerator_setSourceContent</span><span class="s0">(</span><span class="s2">aSourceFile</span><span class="s0">, </span><span class="s2">aSourceContent</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">source </span><span class="s0">= </span><span class="s2">aSourceFile</span><span class="s0">;</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sourceRoot </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s2">source </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">relative</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sourceRoot</span><span class="s0">, </span><span class="s2">source</span><span class="s0">);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">aSourceContent </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s4">// Add the source content to the _sourcesContents map.</span>
	      <span class="s4">// Create a new _sourcesContents map if the property is null.</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sourcesContents</span><span class="s0">) {</span>
	        <span class="s1">this</span><span class="s0">.</span><span class="s2">_sourcesContents </span><span class="s0">= </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">create</span><span class="s0">(</span><span class="s1">null</span><span class="s0">);</span>
	      <span class="s0">}</span>
	      <span class="s1">this</span><span class="s0">.</span><span class="s2">_sourcesContents</span><span class="s0">[</span><span class="s2">util</span><span class="s0">.</span><span class="s2">toSetString</span><span class="s0">(</span><span class="s2">source</span><span class="s0">)] = </span><span class="s2">aSourceContent</span><span class="s0">;</span>
	    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sourcesContents</span><span class="s0">) {</span>
	      <span class="s4">// Remove the source file from the _sourcesContents map.</span>
	      <span class="s4">// If the _sourcesContents map is empty, set the property to null.</span>
	      <span class="s1">delete this</span><span class="s0">.</span><span class="s2">_sourcesContents</span><span class="s0">[</span><span class="s2">util</span><span class="s0">.</span><span class="s2">toSetString</span><span class="s0">(</span><span class="s2">source</span><span class="s0">)];</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">Object</span><span class="s0">.</span><span class="s2">keys</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sourcesContents</span><span class="s0">).</span><span class="s2">length </span><span class="s0">=== </span><span class="s5">0</span><span class="s0">) {</span>
	        <span class="s1">this</span><span class="s0">.</span><span class="s2">_sourcesContents </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Applies the mappings of a sub-source-map for a specific source file to the</span>
	 <span class="s6">* source map being generated. Each mapping to the supplied source file is</span>
	 <span class="s6">* rewritten using the supplied source map. Note: The resolution for the</span>
	 <span class="s6">* resulting mappings is the minimium of this map and the supplied map.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSourceMapConsumer The source map to be applied.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSourceFile Optional. The filename of the source file.</span>
	 <span class="s6">*        If omitted, SourceMapConsumer's file property will be used.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSourceMapPath Optional. The dirname of the path to the source map</span>
	 <span class="s6">*        to be applied. If relative, it is relative to the SourceMapConsumer.</span>
	 <span class="s6">*        This parameter is needed when the two source maps aren't in the same</span>
	 <span class="s6">*        directory, and the source map to be applied contains relative source</span>
	 <span class="s6">*        paths. If so, those relative source paths need to be rewritten</span>
	 <span class="s6">*        relative to the SourceMapGenerator.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceMapGenerator</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">applySourceMap </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapGenerator_applySourceMap</span><span class="s0">(</span><span class="s2">aSourceMapConsumer</span><span class="s0">, </span><span class="s2">aSourceFile</span><span class="s0">, </span><span class="s2">aSourceMapPath</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">sourceFile </span><span class="s0">= </span><span class="s2">aSourceFile</span><span class="s0">;</span>
	    <span class="s4">// If aSourceFile is omitted, we will use the file property of the SourceMap</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">aSourceFile </span><span class="s0">== </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">aSourceMapConsumer</span><span class="s0">.</span><span class="s2">file </span><span class="s0">== </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span>
	          <span class="s3">'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' </span><span class="s0">+</span>
	          <span class="s3">'or the source map</span><span class="s1">\'</span><span class="s3">s &quot;file&quot; property. Both were omitted.'</span>
	        <span class="s0">);</span>
	      <span class="s0">}</span>
	      <span class="s2">sourceFile </span><span class="s0">= </span><span class="s2">aSourceMapConsumer</span><span class="s0">.</span><span class="s2">file</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s1">var </span><span class="s2">sourceRoot </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sourceRoot</span><span class="s0">;</span>
	    <span class="s4">// Make &quot;sourceFile&quot; relative if an absolute Url is passed.</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">sourceRoot </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s2">sourceFile </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">relative</span><span class="s0">(</span><span class="s2">sourceRoot</span><span class="s0">, </span><span class="s2">sourceFile</span><span class="s0">);</span>
	    <span class="s0">}</span>
	    <span class="s4">// Applying the SourceMap can add and remove items from the sources and</span>
	    <span class="s4">// the names array.</span>
	    <span class="s1">var </span><span class="s2">newSources </span><span class="s0">= </span><span class="s1">new </span><span class="s2">ArraySet</span><span class="s0">();</span>
	    <span class="s1">var </span><span class="s2">newNames </span><span class="s0">= </span><span class="s1">new </span><span class="s2">ArraySet</span><span class="s0">();</span>
	
	    <span class="s4">// Find mappings for the &quot;sourceFile&quot;</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">_mappings</span><span class="s0">.</span><span class="s2">unsortedForEach</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">source </span><span class="s0">=== </span><span class="s2">sourceFile </span><span class="s0">&amp;&amp; </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalLine </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s4">// Check if it can be mapped by the source map, then update the mapping.</span>
	        <span class="s1">var </span><span class="s2">original </span><span class="s0">= </span><span class="s2">aSourceMapConsumer</span><span class="s0">.</span><span class="s2">originalPositionFor</span><span class="s0">({</span>
	          <span class="s2">line</span><span class="s0">: </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalLine</span><span class="s0">,</span>
	          <span class="s2">column</span><span class="s0">: </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalColumn</span>
	        <span class="s0">});</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">original</span><span class="s0">.</span><span class="s2">source </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s4">// Copy mapping</span>
	          <span class="s2">mapping</span><span class="s0">.</span><span class="s2">source </span><span class="s0">= </span><span class="s2">original</span><span class="s0">.</span><span class="s2">source</span><span class="s0">;</span>
	          <span class="s1">if </span><span class="s0">(</span><span class="s2">aSourceMapPath </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	            <span class="s2">mapping</span><span class="s0">.</span><span class="s2">source </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">join</span><span class="s0">(</span><span class="s2">aSourceMapPath</span><span class="s0">, </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">source</span><span class="s0">)</span>
	          <span class="s0">}</span>
	          <span class="s1">if </span><span class="s0">(</span><span class="s2">sourceRoot </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	            <span class="s2">mapping</span><span class="s0">.</span><span class="s2">source </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">relative</span><span class="s0">(</span><span class="s2">sourceRoot</span><span class="s0">, </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">source</span><span class="s0">);</span>
	          <span class="s0">}</span>
	          <span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalLine </span><span class="s0">= </span><span class="s2">original</span><span class="s0">.</span><span class="s2">line</span><span class="s0">;</span>
	          <span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalColumn </span><span class="s0">= </span><span class="s2">original</span><span class="s0">.</span><span class="s2">column</span><span class="s0">;</span>
	          <span class="s1">if </span><span class="s0">(</span><span class="s2">original</span><span class="s0">.</span><span class="s2">name </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	            <span class="s2">mapping</span><span class="s0">.</span><span class="s2">name </span><span class="s0">= </span><span class="s2">original</span><span class="s0">.</span><span class="s2">name</span><span class="s0">;</span>
	          <span class="s0">}</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	
	      <span class="s1">var </span><span class="s2">source </span><span class="s0">= </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">source</span><span class="s0">;</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">source </span><span class="s0">!= </span><span class="s1">null </span><span class="s0">&amp;&amp; !</span><span class="s2">newSources</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">source</span><span class="s0">)) {</span>
	        <span class="s2">newSources</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">source</span><span class="s0">);</span>
	      <span class="s0">}</span>
	
	      <span class="s1">var </span><span class="s2">name </span><span class="s0">= </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">name</span><span class="s0">;</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">name </span><span class="s0">!= </span><span class="s1">null </span><span class="s0">&amp;&amp; !</span><span class="s2">newNames</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">name</span><span class="s0">)) {</span>
	        <span class="s2">newNames</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">name</span><span class="s0">);</span>
	      <span class="s0">}</span>
	
	    <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">_sources </span><span class="s0">= </span><span class="s2">newSources</span><span class="s0">;</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">_names </span><span class="s0">= </span><span class="s2">newNames</span><span class="s0">;</span>
	
	    <span class="s4">// Copy sourcesContents of applied map.</span>
	    <span class="s2">aSourceMapConsumer</span><span class="s0">.</span><span class="s2">sources</span><span class="s0">.</span><span class="s2">forEach</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">sourceFile</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">content </span><span class="s0">= </span><span class="s2">aSourceMapConsumer</span><span class="s0">.</span><span class="s2">sourceContentFor</span><span class="s0">(</span><span class="s2">sourceFile</span><span class="s0">);</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">content </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">aSourceMapPath </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s2">sourceFile </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">join</span><span class="s0">(</span><span class="s2">aSourceMapPath</span><span class="s0">, </span><span class="s2">sourceFile</span><span class="s0">);</span>
	        <span class="s0">}</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">sourceRoot </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s2">sourceFile </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">relative</span><span class="s0">(</span><span class="s2">sourceRoot</span><span class="s0">, </span><span class="s2">sourceFile</span><span class="s0">);</span>
	        <span class="s0">}</span>
	        <span class="s1">this</span><span class="s0">.</span><span class="s2">setSourceContent</span><span class="s0">(</span><span class="s2">sourceFile</span><span class="s0">, </span><span class="s2">content</span><span class="s0">);</span>
	      <span class="s0">}</span>
	    <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* A mapping can have one of the three levels of data:</span>
	 <span class="s6">*</span>
	 <span class="s6">*   1. Just the generated position.</span>
	 <span class="s6">*   2. The Generated position, original position, and original source.</span>
	 <span class="s6">*   3. Generated and original position, original source, as well as a name</span>
	 <span class="s6">*      token.</span>
	 <span class="s6">*</span>
	 <span class="s6">* To maintain consistency, we validate that any new mapping being added falls</span>
	 <span class="s6">* in to one of these categories.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceMapGenerator</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">_validateMapping </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapGenerator_validateMapping</span><span class="s0">(</span><span class="s2">aGenerated</span><span class="s0">, </span><span class="s2">aOriginal</span><span class="s0">, </span><span class="s2">aSource</span><span class="s0">,</span>
	                                              <span class="s2">aName</span><span class="s0">) {</span>
	    <span class="s4">// When aOriginal is truthy but has empty values for .line and .column,</span>
	    <span class="s4">// it is most likely a programmer error. In this case we throw a very</span>
	    <span class="s4">// specific error message to try to guide them the right way.</span>
	    <span class="s4">// For example: https://github.com/Polymer/polymer-bundler/pull/519</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">aOriginal </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s2">aOriginal</span><span class="s0">.</span><span class="s2">line </span><span class="s0">!== </span><span class="s3">'number' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s2">aOriginal</span><span class="s0">.</span><span class="s2">column </span><span class="s0">!== </span><span class="s3">'number'</span><span class="s0">) {</span>
	        <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span>
	            <span class="s3">'original.line and original.column are not numbers -- you probably meant to omit ' </span><span class="s0">+</span>
	            <span class="s3">'the original mapping entirely and only map the generated position. If so, pass ' </span><span class="s0">+</span>
	            <span class="s3">'null for the original mapping instead of an object with empty or null values.'</span>
	        <span class="s0">);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">aGenerated </span><span class="s0">&amp;&amp; </span><span class="s3">'line' </span><span class="s1">in </span><span class="s2">aGenerated </span><span class="s0">&amp;&amp; </span><span class="s3">'column' </span><span class="s1">in </span><span class="s2">aGenerated</span>
	        <span class="s0">&amp;&amp; </span><span class="s2">aGenerated</span><span class="s0">.</span><span class="s2">line </span><span class="s0">&gt; </span><span class="s5">0 </span><span class="s0">&amp;&amp; </span><span class="s2">aGenerated</span><span class="s0">.</span><span class="s2">column </span><span class="s0">&gt;= </span><span class="s5">0</span>
	        <span class="s0">&amp;&amp; !</span><span class="s2">aOriginal </span><span class="s0">&amp;&amp; !</span><span class="s2">aSource </span><span class="s0">&amp;&amp; !</span><span class="s2">aName</span><span class="s0">) {</span>
	      <span class="s4">// Case 1.</span>
	      <span class="s1">return</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else if </span><span class="s0">(</span><span class="s2">aGenerated </span><span class="s0">&amp;&amp; </span><span class="s3">'line' </span><span class="s1">in </span><span class="s2">aGenerated </span><span class="s0">&amp;&amp; </span><span class="s3">'column' </span><span class="s1">in </span><span class="s2">aGenerated</span>
	             <span class="s0">&amp;&amp; </span><span class="s2">aOriginal </span><span class="s0">&amp;&amp; </span><span class="s3">'line' </span><span class="s1">in </span><span class="s2">aOriginal </span><span class="s0">&amp;&amp; </span><span class="s3">'column' </span><span class="s1">in </span><span class="s2">aOriginal</span>
	             <span class="s0">&amp;&amp; </span><span class="s2">aGenerated</span><span class="s0">.</span><span class="s2">line </span><span class="s0">&gt; </span><span class="s5">0 </span><span class="s0">&amp;&amp; </span><span class="s2">aGenerated</span><span class="s0">.</span><span class="s2">column </span><span class="s0">&gt;= </span><span class="s5">0</span>
	             <span class="s0">&amp;&amp; </span><span class="s2">aOriginal</span><span class="s0">.</span><span class="s2">line </span><span class="s0">&gt; </span><span class="s5">0 </span><span class="s0">&amp;&amp; </span><span class="s2">aOriginal</span><span class="s0">.</span><span class="s2">column </span><span class="s0">&gt;= </span><span class="s5">0</span>
	             <span class="s0">&amp;&amp; </span><span class="s2">aSource</span><span class="s0">) {</span>
	      <span class="s4">// Cases 2 and 3.</span>
	      <span class="s1">return</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">'Invalid mapping: ' </span><span class="s0">+ </span><span class="s2">JSON</span><span class="s0">.</span><span class="s2">stringify</span><span class="s0">({</span>
	        <span class="s2">generated</span><span class="s0">: </span><span class="s2">aGenerated</span><span class="s0">,</span>
	        <span class="s2">source</span><span class="s0">: </span><span class="s2">aSource</span><span class="s0">,</span>
	        <span class="s2">original</span><span class="s0">: </span><span class="s2">aOriginal</span><span class="s0">,</span>
	        <span class="s2">name</span><span class="s0">: </span><span class="s2">aName</span>
	      <span class="s0">}));</span>
	    <span class="s0">}</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Serialize the accumulated mappings in to the stream of base 64 VLQs</span>
	 <span class="s6">* specified by the source map format.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceMapGenerator</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">_serializeMappings </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapGenerator_serializeMappings</span><span class="s0">() {</span>
	    <span class="s1">var </span><span class="s2">previousGeneratedColumn </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">previousGeneratedLine </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">previousOriginalColumn </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">previousOriginalLine </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">previousName </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">previousSource </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">result </span><span class="s0">= </span><span class="s3">''</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">next</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">mapping</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">nameIdx</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">sourceIdx</span><span class="s0">;</span>
	
	    <span class="s1">var </span><span class="s2">mappings </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_mappings</span><span class="s0">.</span><span class="s2">toArray</span><span class="s0">();</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">, </span><span class="s2">len </span><span class="s0">= </span><span class="s2">mappings</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">len</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
	      <span class="s2">mapping </span><span class="s0">= </span><span class="s2">mappings</span><span class="s0">[</span><span class="s2">i</span><span class="s0">];</span>
	      <span class="s2">next </span><span class="s0">= </span><span class="s3">''</span>
	
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">!== </span><span class="s2">previousGeneratedLine</span><span class="s0">) {</span>
	        <span class="s2">previousGeneratedColumn </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	        <span class="s1">while </span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">!== </span><span class="s2">previousGeneratedLine</span><span class="s0">) {</span>
	          <span class="s2">next </span><span class="s0">+= </span><span class="s3">';'</span><span class="s0">;</span>
	          <span class="s2">previousGeneratedLine</span><span class="s0">++;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	      <span class="s1">else </span><span class="s0">{</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">&gt; </span><span class="s5">0</span><span class="s0">) {</span>
	          <span class="s1">if </span><span class="s0">(!</span><span class="s2">util</span><span class="s0">.</span><span class="s2">compareByGeneratedPositionsInflated</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">, </span><span class="s2">mappings</span><span class="s0">[</span><span class="s2">i </span><span class="s0">- </span><span class="s5">1</span><span class="s0">])) {</span>
	            <span class="s1">continue</span><span class="s0">;</span>
	          <span class="s0">}</span>
	          <span class="s2">next </span><span class="s0">+= </span><span class="s3">','</span><span class="s0">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	
	      <span class="s2">next </span><span class="s0">+= </span><span class="s2">base64VLQ</span><span class="s0">.</span><span class="s2">encode</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedColumn</span>
	                                 <span class="s0">- </span><span class="s2">previousGeneratedColumn</span><span class="s0">);</span>
	      <span class="s2">previousGeneratedColumn </span><span class="s0">= </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedColumn</span><span class="s0">;</span>
	
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">source </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s2">sourceIdx </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">indexOf</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">source</span><span class="s0">);</span>
	        <span class="s2">next </span><span class="s0">+= </span><span class="s2">base64VLQ</span><span class="s0">.</span><span class="s2">encode</span><span class="s0">(</span><span class="s2">sourceIdx </span><span class="s0">- </span><span class="s2">previousSource</span><span class="s0">);</span>
	        <span class="s2">previousSource </span><span class="s0">= </span><span class="s2">sourceIdx</span><span class="s0">;</span>
	
	        <span class="s4">// lines are stored 0-based in SourceMap spec version 3</span>
	        <span class="s2">next </span><span class="s0">+= </span><span class="s2">base64VLQ</span><span class="s0">.</span><span class="s2">encode</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalLine </span><span class="s0">- </span><span class="s5">1</span>
	                                   <span class="s0">- </span><span class="s2">previousOriginalLine</span><span class="s0">);</span>
	        <span class="s2">previousOriginalLine </span><span class="s0">= </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalLine </span><span class="s0">- </span><span class="s5">1</span><span class="s0">;</span>
	
	        <span class="s2">next </span><span class="s0">+= </span><span class="s2">base64VLQ</span><span class="s0">.</span><span class="s2">encode</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalColumn</span>
	                                   <span class="s0">- </span><span class="s2">previousOriginalColumn</span><span class="s0">);</span>
	        <span class="s2">previousOriginalColumn </span><span class="s0">= </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalColumn</span><span class="s0">;</span>
	
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">name </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s2">nameIdx </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_names</span><span class="s0">.</span><span class="s2">indexOf</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">name</span><span class="s0">);</span>
	          <span class="s2">next </span><span class="s0">+= </span><span class="s2">base64VLQ</span><span class="s0">.</span><span class="s2">encode</span><span class="s0">(</span><span class="s2">nameIdx </span><span class="s0">- </span><span class="s2">previousName</span><span class="s0">);</span>
	          <span class="s2">previousName </span><span class="s0">= </span><span class="s2">nameIdx</span><span class="s0">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	
	      <span class="s2">result </span><span class="s0">+= </span><span class="s2">next</span><span class="s0">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s2">result</span><span class="s0">;</span>
	  <span class="s0">};</span>
	
	<span class="s2">SourceMapGenerator</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">_generateSourcesContent </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapGenerator_generateSourcesContent</span><span class="s0">(</span><span class="s2">aSources</span><span class="s0">, </span><span class="s2">aSourceRoot</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">aSources</span><span class="s0">.</span><span class="s2">map</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">source</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sourcesContents</span><span class="s0">) {</span>
	        <span class="s1">return null</span><span class="s0">;</span>
	      <span class="s0">}</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">aSourceRoot </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s2">source </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">relative</span><span class="s0">(</span><span class="s2">aSourceRoot</span><span class="s0">, </span><span class="s2">source</span><span class="s0">);</span>
	      <span class="s0">}</span>
	      <span class="s1">var </span><span class="s2">key </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">toSetString</span><span class="s0">(</span><span class="s2">source</span><span class="s0">);</span>
	      <span class="s1">return </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">hasOwnProperty</span><span class="s0">.</span><span class="s2">call</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sourcesContents</span><span class="s0">, </span><span class="s2">key</span><span class="s0">)</span>
	        <span class="s0">? </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sourcesContents</span><span class="s0">[</span><span class="s2">key</span><span class="s0">]</span>
	        <span class="s0">: </span><span class="s1">null</span><span class="s0">;</span>
	    <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Externalize the source map.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceMapGenerator</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">toJSON </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapGenerator_toJSON</span><span class="s0">() {</span>
	    <span class="s1">var </span><span class="s2">map </span><span class="s0">= {</span>
	      <span class="s2">version</span><span class="s0">: </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_version</span><span class="s0">,</span>
	      <span class="s2">sources</span><span class="s0">: </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">toArray</span><span class="s0">(),</span>
	      <span class="s2">names</span><span class="s0">: </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_names</span><span class="s0">.</span><span class="s2">toArray</span><span class="s0">(),</span>
	      <span class="s2">mappings</span><span class="s0">: </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_serializeMappings</span><span class="s0">()</span>
	    <span class="s0">};</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_file </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s2">map</span><span class="s0">.</span><span class="s2">file </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_file</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sourceRoot </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s2">map</span><span class="s0">.</span><span class="s2">sourceRoot </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sourceRoot</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sourcesContents</span><span class="s0">) {</span>
	      <span class="s2">map</span><span class="s0">.</span><span class="s2">sourcesContent </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_generateSourcesContent</span><span class="s0">(</span><span class="s2">map</span><span class="s0">.</span><span class="s2">sources</span><span class="s0">, </span><span class="s2">map</span><span class="s0">.</span><span class="s2">sourceRoot</span><span class="s0">);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s2">map</span><span class="s0">;</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Render the source map being generated to a string.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceMapGenerator</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">toString </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapGenerator_toString</span><span class="s0">() {</span>
	    <span class="s1">return </span><span class="s2">JSON</span><span class="s0">.</span><span class="s2">stringify</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">toJSON</span><span class="s0">());</span>
	  <span class="s0">};</span>
	
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">SourceMapGenerator </span><span class="s0">= </span><span class="s2">SourceMapGenerator</span><span class="s0">;</span>


<span class="s4">/***/ </span><span class="s0">}),</span>
<span class="s4">/* 2 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(</span><span class="s2">module</span><span class="s0">, </span><span class="s2">exports</span><span class="s0">, </span><span class="s2">__webpack_require__</span><span class="s0">) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     * 
     * Based on the Base 64 VLQ implementation in Closure Compiler: 
     * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java 
     * 
     * Copyright 2011 The Closure Compiler Authors. All rights reserved. 
     * Redistribution and use in source and binary forms, with or without 
     * modification, are permitted provided that the following conditions are 
     * met: 
     * 
     *  * Redistributions of source code must retain the above copyright 
     *    notice, this list of conditions and the following disclaimer. 
     *  * Redistributions in binary form must reproduce the above 
     *    copyright notice, this list of conditions and the following 
     *    disclaimer in the documentation and/or other materials provided 
     *    with the distribution. 
     *  * Neither the name of Google Inc. nor the names of its 
     *    contributors may be used to endorse or promote products derived 
     *    from this software without specific prior written permission. 
     * 
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
     * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
     */</span>
	
	<span class="s1">var </span><span class="s2">base64 </span><span class="s0">= </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">3</span><span class="s0">);</span>
	
	<span class="s4">// A single base 64 digit can contain 6 bits of data. For the base 64 variable</span>
	<span class="s4">// length quantities we use in the source map spec, the first bit is the sign,</span>
	<span class="s4">// the next four bits are the actual value, and the 6th bit is the</span>
	<span class="s4">// continuation bit. The continuation bit tells us whether there are more</span>
	<span class="s4">// digits in this value following this digit.</span>
	<span class="s4">//</span>
	<span class="s4">//   Continuation</span>
	<span class="s4">//   |    Sign</span>
	<span class="s4">//   |    |</span>
	<span class="s4">//   V    V</span>
	<span class="s4">//   101011</span>
	
	<span class="s1">var </span><span class="s2">VLQ_BASE_SHIFT </span><span class="s0">= </span><span class="s5">5</span><span class="s0">;</span>
	
	<span class="s4">// binary: 100000</span>
	<span class="s1">var </span><span class="s2">VLQ_BASE </span><span class="s0">= </span><span class="s5">1 </span><span class="s0">&lt;&lt; </span><span class="s2">VLQ_BASE_SHIFT</span><span class="s0">;</span>
	
	<span class="s4">// binary: 011111</span>
	<span class="s1">var </span><span class="s2">VLQ_BASE_MASK </span><span class="s0">= </span><span class="s2">VLQ_BASE </span><span class="s0">- </span><span class="s5">1</span><span class="s0">;</span>
	
	<span class="s4">// binary: 100000</span>
	<span class="s1">var </span><span class="s2">VLQ_CONTINUATION_BIT </span><span class="s0">= </span><span class="s2">VLQ_BASE</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Converts from a two-complement value to a value where the sign bit is</span>
	 <span class="s6">* placed in the least significant bit.  For example, as decimals:</span>
	 <span class="s6">*   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)</span>
	 <span class="s6">*   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">toVLQSigned</span><span class="s0">(</span><span class="s2">aValue</span><span class="s0">) {</span>
	  <span class="s1">return </span><span class="s2">aValue </span><span class="s0">&lt; </span><span class="s5">0</span>
	    <span class="s0">? ((-</span><span class="s2">aValue</span><span class="s0">) &lt;&lt; </span><span class="s5">1</span><span class="s0">) + </span><span class="s5">1</span>
	    <span class="s0">: (</span><span class="s2">aValue </span><span class="s0">&lt;&lt; </span><span class="s5">1</span><span class="s0">) + </span><span class="s5">0</span><span class="s0">;</span>
	<span class="s0">}</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Converts to a two-complement value from a value where the sign bit is</span>
	 <span class="s6">* placed in the least significant bit.  For example, as decimals:</span>
	 <span class="s6">*   2 (10 binary) becomes 1, 3 (11 binary) becomes -1</span>
	 <span class="s6">*   4 (100 binary) becomes 2, 5 (101 binary) becomes -2</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">fromVLQSigned</span><span class="s0">(</span><span class="s2">aValue</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">isNegative </span><span class="s0">= (</span><span class="s2">aValue </span><span class="s0">&amp; </span><span class="s5">1</span><span class="s0">) === </span><span class="s5">1</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">shifted </span><span class="s0">= </span><span class="s2">aValue </span><span class="s0">&gt;&gt; </span><span class="s5">1</span><span class="s0">;</span>
	  <span class="s1">return </span><span class="s2">isNegative</span>
	    <span class="s0">? -</span><span class="s2">shifted</span>
	    <span class="s0">: </span><span class="s2">shifted</span><span class="s0">;</span>
	<span class="s0">}</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Returns the base 64 VLQ encoded value.</span>
	 <span class="s6">*/</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">encode </span><span class="s0">= </span><span class="s1">function </span><span class="s2">base64VLQ_encode</span><span class="s0">(</span><span class="s2">aValue</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">encoded </span><span class="s0">= </span><span class="s3">&quot;&quot;</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">digit</span><span class="s0">;</span>
	
	  <span class="s1">var </span><span class="s2">vlq </span><span class="s0">= </span><span class="s2">toVLQSigned</span><span class="s0">(</span><span class="s2">aValue</span><span class="s0">);</span>
	
	  <span class="s1">do </span><span class="s0">{</span>
	    <span class="s2">digit </span><span class="s0">= </span><span class="s2">vlq </span><span class="s0">&amp; </span><span class="s2">VLQ_BASE_MASK</span><span class="s0">;</span>
	    <span class="s2">vlq </span><span class="s0">&gt;&gt;&gt;= </span><span class="s2">VLQ_BASE_SHIFT</span><span class="s0">;</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">vlq </span><span class="s0">&gt; </span><span class="s5">0</span><span class="s0">) {</span>
	      <span class="s4">// There are still more digits in this value, so we must make sure the</span>
	      <span class="s4">// continuation bit is marked.</span>
	      <span class="s2">digit </span><span class="s0">|= </span><span class="s2">VLQ_CONTINUATION_BIT</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s2">encoded </span><span class="s0">+= </span><span class="s2">base64</span><span class="s0">.</span><span class="s2">encode</span><span class="s0">(</span><span class="s2">digit</span><span class="s0">);</span>
	  <span class="s0">} </span><span class="s1">while </span><span class="s0">(</span><span class="s2">vlq </span><span class="s0">&gt; </span><span class="s5">0</span><span class="s0">);</span>
	
	  <span class="s1">return </span><span class="s2">encoded</span><span class="s0">;</span>
	<span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Decodes the next base 64 VLQ value from the given string and returns the</span>
	 <span class="s6">* value and the rest of the string via the out parameter.</span>
	 <span class="s6">*/</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">decode </span><span class="s0">= </span><span class="s1">function </span><span class="s2">base64VLQ_decode</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">, </span><span class="s2">aIndex</span><span class="s0">, </span><span class="s2">aOutParam</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">strLen </span><span class="s0">= </span><span class="s2">aStr</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">result </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">shift </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">continuation</span><span class="s0">, </span><span class="s2">digit</span><span class="s0">;</span>
	
	  <span class="s1">do </span><span class="s0">{</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">aIndex </span><span class="s0">&gt;= </span><span class="s2">strLen</span><span class="s0">) {</span>
	      <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">&quot;Expected more digits in base 64 VLQ value.&quot;</span><span class="s0">);</span>
	    <span class="s0">}</span>
	
	    <span class="s2">digit </span><span class="s0">= </span><span class="s2">base64</span><span class="s0">.</span><span class="s2">decode</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">.</span><span class="s2">charCodeAt</span><span class="s0">(</span><span class="s2">aIndex</span><span class="s0">++));</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">digit </span><span class="s0">=== -</span><span class="s5">1</span><span class="s0">) {</span>
	      <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">&quot;Invalid base64 digit: &quot; </span><span class="s0">+ </span><span class="s2">aStr</span><span class="s0">.</span><span class="s2">charAt</span><span class="s0">(</span><span class="s2">aIndex </span><span class="s0">- </span><span class="s5">1</span><span class="s0">));</span>
	    <span class="s0">}</span>
	
	    <span class="s2">continuation </span><span class="s0">= !!(</span><span class="s2">digit </span><span class="s0">&amp; </span><span class="s2">VLQ_CONTINUATION_BIT</span><span class="s0">);</span>
	    <span class="s2">digit </span><span class="s0">&amp;= </span><span class="s2">VLQ_BASE_MASK</span><span class="s0">;</span>
	    <span class="s2">result </span><span class="s0">= </span><span class="s2">result </span><span class="s0">+ (</span><span class="s2">digit </span><span class="s0">&lt;&lt; </span><span class="s2">shift</span><span class="s0">);</span>
	    <span class="s2">shift </span><span class="s0">+= </span><span class="s2">VLQ_BASE_SHIFT</span><span class="s0">;</span>
	  <span class="s0">} </span><span class="s1">while </span><span class="s0">(</span><span class="s2">continuation</span><span class="s0">);</span>
	
	  <span class="s2">aOutParam</span><span class="s0">.</span><span class="s2">value </span><span class="s0">= </span><span class="s2">fromVLQSigned</span><span class="s0">(</span><span class="s2">result</span><span class="s0">);</span>
	  <span class="s2">aOutParam</span><span class="s0">.</span><span class="s2">rest </span><span class="s0">= </span><span class="s2">aIndex</span><span class="s0">;</span>
	<span class="s0">};</span>


<span class="s4">/***/ </span><span class="s0">}),</span>
<span class="s4">/* 3 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(</span><span class="s2">module</span><span class="s0">, </span><span class="s2">exports</span><span class="s0">) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s2">intToCharMap </span><span class="s0">= </span><span class="s3">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span><span class="s0">.</span><span class="s2">split</span><span class="s0">(</span><span class="s3">''</span><span class="s0">);</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Encode an integer in the range of 0 to 63 to a single base 64 digit.</span>
	 <span class="s6">*/</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">encode </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">number</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s5">0 </span><span class="s0">&lt;= </span><span class="s2">number </span><span class="s0">&amp;&amp; </span><span class="s2">number </span><span class="s0">&lt; </span><span class="s2">intToCharMap</span><span class="s0">.</span><span class="s2">length</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">intToCharMap</span><span class="s0">[</span><span class="s2">number</span><span class="s0">];</span>
	  <span class="s0">}</span>
	  <span class="s1">throw new </span><span class="s2">TypeError</span><span class="s0">(</span><span class="s3">&quot;Must be between 0 and 63: &quot; </span><span class="s0">+ </span><span class="s2">number</span><span class="s0">);</span>
	<span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Decode a single base 64 character code digit to an integer. Returns -1 on</span>
	 <span class="s6">* failure.</span>
	 <span class="s6">*/</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">decode </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">charCode</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">bigA </span><span class="s0">= </span><span class="s5">65</span><span class="s0">;     </span><span class="s4">// 'A'</span>
	  <span class="s1">var </span><span class="s2">bigZ </span><span class="s0">= </span><span class="s5">90</span><span class="s0">;     </span><span class="s4">// 'Z'</span>
	
	  <span class="s1">var </span><span class="s2">littleA </span><span class="s0">= </span><span class="s5">97</span><span class="s0">;  </span><span class="s4">// 'a'</span>
	  <span class="s1">var </span><span class="s2">littleZ </span><span class="s0">= </span><span class="s5">122</span><span class="s0">; </span><span class="s4">// 'z'</span>
	
	  <span class="s1">var </span><span class="s2">zero </span><span class="s0">= </span><span class="s5">48</span><span class="s0">;     </span><span class="s4">// '0'</span>
	  <span class="s1">var </span><span class="s2">nine </span><span class="s0">= </span><span class="s5">57</span><span class="s0">;     </span><span class="s4">// '9'</span>
	
	  <span class="s1">var </span><span class="s2">plus </span><span class="s0">= </span><span class="s5">43</span><span class="s0">;     </span><span class="s4">// '+'</span>
	  <span class="s1">var </span><span class="s2">slash </span><span class="s0">= </span><span class="s5">47</span><span class="s0">;    </span><span class="s4">// '/'</span>
	
	  <span class="s1">var </span><span class="s2">littleOffset </span><span class="s0">= </span><span class="s5">26</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">numberOffset </span><span class="s0">= </span><span class="s5">52</span><span class="s0">;</span>
	
	  <span class="s4">// 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">bigA </span><span class="s0">&lt;= </span><span class="s2">charCode </span><span class="s0">&amp;&amp; </span><span class="s2">charCode </span><span class="s0">&lt;= </span><span class="s2">bigZ</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">(</span><span class="s2">charCode </span><span class="s0">- </span><span class="s2">bigA</span><span class="s0">);</span>
	  <span class="s0">}</span>
	
	  <span class="s4">// 26 - 51: abcdefghijklmnopqrstuvwxyz</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">littleA </span><span class="s0">&lt;= </span><span class="s2">charCode </span><span class="s0">&amp;&amp; </span><span class="s2">charCode </span><span class="s0">&lt;= </span><span class="s2">littleZ</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">(</span><span class="s2">charCode </span><span class="s0">- </span><span class="s2">littleA </span><span class="s0">+ </span><span class="s2">littleOffset</span><span class="s0">);</span>
	  <span class="s0">}</span>
	
	  <span class="s4">// 52 - 61: 0123456789</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">zero </span><span class="s0">&lt;= </span><span class="s2">charCode </span><span class="s0">&amp;&amp; </span><span class="s2">charCode </span><span class="s0">&lt;= </span><span class="s2">nine</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">(</span><span class="s2">charCode </span><span class="s0">- </span><span class="s2">zero </span><span class="s0">+ </span><span class="s2">numberOffset</span><span class="s0">);</span>
	  <span class="s0">}</span>
	
	  <span class="s4">// 62: +</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">charCode </span><span class="s0">== </span><span class="s2">plus</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s5">62</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s4">// 63: /</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">charCode </span><span class="s0">== </span><span class="s2">slash</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s5">63</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s4">// Invalid base64 digit.</span>
	  <span class="s1">return </span><span class="s0">-</span><span class="s5">1</span><span class="s0">;</span>
	<span class="s0">};</span>


<span class="s4">/***/ </span><span class="s0">}),</span>
<span class="s4">/* 4 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(</span><span class="s2">module</span><span class="s0">, </span><span class="s2">exports</span><span class="s0">) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* This is a helper function for getting values from parameter/options</span>
	 <span class="s6">* objects.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">args The object we are extracting values from</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">name The name of the property we are getting.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">defaultValue An optional value to return if the property is missing</span>
	 <span class="s6">* from the object. If this is not specified and the property is missing, an</span>
	 <span class="s6">* error will be thrown.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s2">aName</span><span class="s0">, </span><span class="s2">aDefaultValue</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aName </span><span class="s1">in </span><span class="s2">aArgs</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">aArgs</span><span class="s0">[</span><span class="s2">aName</span><span class="s0">];</span>
	  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">arguments</span><span class="s0">.</span><span class="s2">length </span><span class="s0">=== </span><span class="s5">3</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">aDefaultValue</span><span class="s0">;</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">'&quot;' </span><span class="s0">+ </span><span class="s2">aName </span><span class="s0">+ </span><span class="s3">'&quot; is a required argument.'</span><span class="s0">);</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">getArg </span><span class="s0">= </span><span class="s2">getArg</span><span class="s0">;</span>
	
	<span class="s1">var </span><span class="s2">urlRegexp </span><span class="s0">= </span><span class="s8">/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/</span><span class="s0">;</span>
	<span class="s1">var </span><span class="s2">dataUrlRegexp </span><span class="s0">= </span><span class="s8">/^data:.+\,.+$/</span><span class="s0">;</span>
	
	<span class="s1">function </span><span class="s2">urlParse</span><span class="s0">(</span><span class="s2">aUrl</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">match </span><span class="s0">= </span><span class="s2">aUrl</span><span class="s0">.</span><span class="s2">match</span><span class="s0">(</span><span class="s2">urlRegexp</span><span class="s0">);</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">match</span><span class="s0">) {</span>
	    <span class="s1">return null</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s0">{</span>
	    <span class="s2">scheme</span><span class="s0">: </span><span class="s2">match</span><span class="s0">[</span><span class="s5">1</span><span class="s0">],</span>
	    <span class="s2">auth</span><span class="s0">: </span><span class="s2">match</span><span class="s0">[</span><span class="s5">2</span><span class="s0">],</span>
	    <span class="s2">host</span><span class="s0">: </span><span class="s2">match</span><span class="s0">[</span><span class="s5">3</span><span class="s0">],</span>
	    <span class="s2">port</span><span class="s0">: </span><span class="s2">match</span><span class="s0">[</span><span class="s5">4</span><span class="s0">],</span>
	    <span class="s2">path</span><span class="s0">: </span><span class="s2">match</span><span class="s0">[</span><span class="s5">5</span><span class="s0">]</span>
	  <span class="s0">};</span>
	<span class="s0">}</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">urlParse </span><span class="s0">= </span><span class="s2">urlParse</span><span class="s0">;</span>
	
	<span class="s1">function </span><span class="s2">urlGenerate</span><span class="s0">(</span><span class="s2">aParsedUrl</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">url </span><span class="s0">= </span><span class="s3">''</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aParsedUrl</span><span class="s0">.</span><span class="s2">scheme</span><span class="s0">) {</span>
	    <span class="s2">url </span><span class="s0">+= </span><span class="s2">aParsedUrl</span><span class="s0">.</span><span class="s2">scheme </span><span class="s0">+ </span><span class="s3">':'</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s2">url </span><span class="s0">+= </span><span class="s3">'//'</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aParsedUrl</span><span class="s0">.</span><span class="s2">auth</span><span class="s0">) {</span>
	    <span class="s2">url </span><span class="s0">+= </span><span class="s2">aParsedUrl</span><span class="s0">.</span><span class="s2">auth </span><span class="s0">+ </span><span class="s3">'@'</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aParsedUrl</span><span class="s0">.</span><span class="s2">host</span><span class="s0">) {</span>
	    <span class="s2">url </span><span class="s0">+= </span><span class="s2">aParsedUrl</span><span class="s0">.</span><span class="s2">host</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aParsedUrl</span><span class="s0">.</span><span class="s2">port</span><span class="s0">) {</span>
	    <span class="s2">url </span><span class="s0">+= </span><span class="s3">&quot;:&quot; </span><span class="s0">+ </span><span class="s2">aParsedUrl</span><span class="s0">.</span><span class="s2">port</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aParsedUrl</span><span class="s0">.</span><span class="s2">path</span><span class="s0">) {</span>
	    <span class="s2">url </span><span class="s0">+= </span><span class="s2">aParsedUrl</span><span class="s0">.</span><span class="s2">path</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s2">url</span><span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">urlGenerate </span><span class="s0">= </span><span class="s2">urlGenerate</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Normalizes a path, or the path portion of a URL:</span>
	 <span class="s6">*</span>
	 <span class="s6">* - Replaces consecutive slashes with one slash.</span>
	 <span class="s6">* - Removes unnecessary '.' parts.</span>
	 <span class="s6">* - Removes unnecessary '&lt;dir&gt;/..' parts.</span>
	 <span class="s6">*</span>
	 <span class="s6">* Based on code in the Node.js 'path' core module.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aPath The path or url to normalize.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">normalize</span><span class="s0">(</span><span class="s2">aPath</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">path </span><span class="s0">= </span><span class="s2">aPath</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">url </span><span class="s0">= </span><span class="s2">urlParse</span><span class="s0">(</span><span class="s2">aPath</span><span class="s0">);</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">url</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s2">url</span><span class="s0">.</span><span class="s2">path</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s2">aPath</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s2">path </span><span class="s0">= </span><span class="s2">url</span><span class="s0">.</span><span class="s2">path</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s1">var </span><span class="s2">isAbsolute </span><span class="s0">= </span><span class="s2">exports</span><span class="s0">.</span><span class="s2">isAbsolute</span><span class="s0">(</span><span class="s2">path</span><span class="s0">);</span>
	
	  <span class="s1">var </span><span class="s2">parts </span><span class="s0">= </span><span class="s2">path</span><span class="s0">.</span><span class="s2">split</span><span class="s0">(</span><span class="s8">/\/+/</span><span class="s0">);</span>
	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">part</span><span class="s0">, </span><span class="s2">up </span><span class="s0">= </span><span class="s5">0</span><span class="s0">, </span><span class="s2">i </span><span class="s0">= </span><span class="s2">parts</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s5">1</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&gt;= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">i</span><span class="s0">--) {</span>
	    <span class="s2">part </span><span class="s0">= </span><span class="s2">parts</span><span class="s0">[</span><span class="s2">i</span><span class="s0">];</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">part </span><span class="s0">=== </span><span class="s3">'.'</span><span class="s0">) {</span>
	      <span class="s2">parts</span><span class="s0">.</span><span class="s2">splice</span><span class="s0">(</span><span class="s2">i</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
	    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">part </span><span class="s0">=== </span><span class="s3">'..'</span><span class="s0">) {</span>
	      <span class="s2">up</span><span class="s0">++;</span>
	    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">up </span><span class="s0">&gt; </span><span class="s5">0</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">part </span><span class="s0">=== </span><span class="s3">''</span><span class="s0">) {</span>
	        <span class="s4">// The first part is blank if the path is absolute. Trying to go</span>
	        <span class="s4">// above the root is a no-op. Therefore we can remove all '..' parts</span>
	        <span class="s4">// directly after the root.</span>
	        <span class="s2">parts</span><span class="s0">.</span><span class="s2">splice</span><span class="s0">(</span><span class="s2">i </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s2">up</span><span class="s0">);</span>
	        <span class="s2">up </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	        <span class="s2">parts</span><span class="s0">.</span><span class="s2">splice</span><span class="s0">(</span><span class="s2">i</span><span class="s0">, </span><span class="s5">2</span><span class="s0">);</span>
	        <span class="s2">up</span><span class="s0">--;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	  <span class="s2">path </span><span class="s0">= </span><span class="s2">parts</span><span class="s0">.</span><span class="s2">join</span><span class="s0">(</span><span class="s3">'/'</span><span class="s0">);</span>
	
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">path </span><span class="s0">=== </span><span class="s3">''</span><span class="s0">) {</span>
	    <span class="s2">path </span><span class="s0">= </span><span class="s2">isAbsolute </span><span class="s0">? </span><span class="s3">'/' </span><span class="s0">: </span><span class="s3">'.'</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">url</span><span class="s0">) {</span>
	    <span class="s2">url</span><span class="s0">.</span><span class="s2">path </span><span class="s0">= </span><span class="s2">path</span><span class="s0">;</span>
	    <span class="s1">return </span><span class="s2">urlGenerate</span><span class="s0">(</span><span class="s2">url</span><span class="s0">);</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s2">path</span><span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">normalize </span><span class="s0">= </span><span class="s2">normalize</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Joins two paths/URLs.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aRoot The root path or URL.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aPath The path or URL to be joined with the root.</span>
	 <span class="s6">*</span>
	 <span class="s6">* - If aPath is a URL or a data URI, aPath is returned, unless aPath is a</span>
	 <span class="s6">*   scheme-relative URL: Then the scheme of aRoot, if any, is prepended</span>
	 <span class="s6">*   first.</span>
	 <span class="s6">* - Otherwise aPath is a path. If aRoot is a URL, then its path portion</span>
	 <span class="s6">*   is updated with the result and aRoot is returned. Otherwise the result</span>
	 <span class="s6">*   is returned.</span>
	 <span class="s6">*   - If aPath is absolute, the result is aPath.</span>
	 <span class="s6">*   - Otherwise the two paths are joined with a slash.</span>
	 <span class="s6">* - Joining for example 'http://' and 'www.example.com' is also supported.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">join</span><span class="s0">(</span><span class="s2">aRoot</span><span class="s0">, </span><span class="s2">aPath</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aRoot </span><span class="s0">=== </span><span class="s3">&quot;&quot;</span><span class="s0">) {</span>
	    <span class="s2">aRoot </span><span class="s0">= </span><span class="s3">&quot;.&quot;</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aPath </span><span class="s0">=== </span><span class="s3">&quot;&quot;</span><span class="s0">) {</span>
	    <span class="s2">aPath </span><span class="s0">= </span><span class="s3">&quot;.&quot;</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s1">var </span><span class="s2">aPathUrl </span><span class="s0">= </span><span class="s2">urlParse</span><span class="s0">(</span><span class="s2">aPath</span><span class="s0">);</span>
	  <span class="s1">var </span><span class="s2">aRootUrl </span><span class="s0">= </span><span class="s2">urlParse</span><span class="s0">(</span><span class="s2">aRoot</span><span class="s0">);</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aRootUrl</span><span class="s0">) {</span>
	    <span class="s2">aRoot </span><span class="s0">= </span><span class="s2">aRootUrl</span><span class="s0">.</span><span class="s2">path </span><span class="s0">|| </span><span class="s3">'/'</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s4">// `join(foo, '//www.example.org')`</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aPathUrl </span><span class="s0">&amp;&amp; !</span><span class="s2">aPathUrl</span><span class="s0">.</span><span class="s2">scheme</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">aRootUrl</span><span class="s0">) {</span>
	      <span class="s2">aPathUrl</span><span class="s0">.</span><span class="s2">scheme </span><span class="s0">= </span><span class="s2">aRootUrl</span><span class="s0">.</span><span class="s2">scheme</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s1">return </span><span class="s2">urlGenerate</span><span class="s0">(</span><span class="s2">aPathUrl</span><span class="s0">);</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aPathUrl </span><span class="s0">|| </span><span class="s2">aPath</span><span class="s0">.</span><span class="s2">match</span><span class="s0">(</span><span class="s2">dataUrlRegexp</span><span class="s0">)) {</span>
	    <span class="s1">return </span><span class="s2">aPath</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s4">// `join('http://', 'www.example.com')`</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aRootUrl </span><span class="s0">&amp;&amp; !</span><span class="s2">aRootUrl</span><span class="s0">.</span><span class="s2">host </span><span class="s0">&amp;&amp; !</span><span class="s2">aRootUrl</span><span class="s0">.</span><span class="s2">path</span><span class="s0">) {</span>
	    <span class="s2">aRootUrl</span><span class="s0">.</span><span class="s2">host </span><span class="s0">= </span><span class="s2">aPath</span><span class="s0">;</span>
	    <span class="s1">return </span><span class="s2">urlGenerate</span><span class="s0">(</span><span class="s2">aRootUrl</span><span class="s0">);</span>
	  <span class="s0">}</span>
	
	  <span class="s1">var </span><span class="s2">joined </span><span class="s0">= </span><span class="s2">aPath</span><span class="s0">.</span><span class="s2">charAt</span><span class="s0">(</span><span class="s5">0</span><span class="s0">) === </span><span class="s3">'/'</span>
	    <span class="s0">? </span><span class="s2">aPath</span>
	    <span class="s0">: </span><span class="s2">normalize</span><span class="s0">(</span><span class="s2">aRoot</span><span class="s0">.</span><span class="s2">replace</span><span class="s0">(</span><span class="s8">/\/+$/</span><span class="s0">, </span><span class="s3">''</span><span class="s0">) + </span><span class="s3">'/' </span><span class="s0">+ </span><span class="s2">aPath</span><span class="s0">);</span>
	
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aRootUrl</span><span class="s0">) {</span>
	    <span class="s2">aRootUrl</span><span class="s0">.</span><span class="s2">path </span><span class="s0">= </span><span class="s2">joined</span><span class="s0">;</span>
	    <span class="s1">return </span><span class="s2">urlGenerate</span><span class="s0">(</span><span class="s2">aRootUrl</span><span class="s0">);</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s2">joined</span><span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">join </span><span class="s0">= </span><span class="s2">join</span><span class="s0">;</span>
	
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">isAbsolute </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">aPath</span><span class="s0">) {</span>
	  <span class="s1">return </span><span class="s2">aPath</span><span class="s0">.</span><span class="s2">charAt</span><span class="s0">(</span><span class="s5">0</span><span class="s0">) === </span><span class="s3">'/' </span><span class="s0">|| </span><span class="s2">urlRegexp</span><span class="s0">.</span><span class="s2">test</span><span class="s0">(</span><span class="s2">aPath</span><span class="s0">);</span>
	<span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Make a path relative to a URL or another path.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aRoot The root path or URL.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aPath The path or URL to be made relative to aRoot.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">relative</span><span class="s0">(</span><span class="s2">aRoot</span><span class="s0">, </span><span class="s2">aPath</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aRoot </span><span class="s0">=== </span><span class="s3">&quot;&quot;</span><span class="s0">) {</span>
	    <span class="s2">aRoot </span><span class="s0">= </span><span class="s3">&quot;.&quot;</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s2">aRoot </span><span class="s0">= </span><span class="s2">aRoot</span><span class="s0">.</span><span class="s2">replace</span><span class="s0">(</span><span class="s8">/\/$/</span><span class="s0">, </span><span class="s3">''</span><span class="s0">);</span>
	
	  <span class="s4">// It is possible for the path to be above the root. In this case, simply</span>
	  <span class="s4">// checking whether the root is a prefix of the path won't work. Instead, we</span>
	  <span class="s4">// need to remove components from the root one by one, until either we find</span>
	  <span class="s4">// a prefix that fits, or we run out of components to remove.</span>
	  <span class="s1">var </span><span class="s2">level </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	  <span class="s1">while </span><span class="s0">(</span><span class="s2">aPath</span><span class="s0">.</span><span class="s2">indexOf</span><span class="s0">(</span><span class="s2">aRoot </span><span class="s0">+ </span><span class="s3">'/'</span><span class="s0">) !== </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">index </span><span class="s0">= </span><span class="s2">aRoot</span><span class="s0">.</span><span class="s2">lastIndexOf</span><span class="s0">(</span><span class="s3">&quot;/&quot;</span><span class="s0">);</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">index </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s2">aPath</span><span class="s0">;</span>
	    <span class="s0">}</span>
	
	    <span class="s4">// If the only part of the root that is left is the scheme (i.e. http://,</span>
	    <span class="s4">// file:///, etc.), one or more slashes (/), or simply nothing at all, we</span>
	    <span class="s4">// have exhausted all components, so the path is not relative to the root.</span>
	    <span class="s2">aRoot </span><span class="s0">= </span><span class="s2">aRoot</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">index</span><span class="s0">);</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">aRoot</span><span class="s0">.</span><span class="s2">match</span><span class="s0">(</span><span class="s8">/^([^\/]+:\/)?\/*$/</span><span class="s0">)) {</span>
	      <span class="s1">return </span><span class="s2">aPath</span><span class="s0">;</span>
	    <span class="s0">}</span>
	
	    <span class="s0">++</span><span class="s2">level</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s4">// Make sure we add a &quot;../&quot; for each component we removed from the root.</span>
	  <span class="s1">return </span><span class="s2">Array</span><span class="s0">(</span><span class="s2">level </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">).</span><span class="s2">join</span><span class="s0">(</span><span class="s3">&quot;../&quot;</span><span class="s0">) + </span><span class="s2">aPath</span><span class="s0">.</span><span class="s2">substr</span><span class="s0">(</span><span class="s2">aRoot</span><span class="s0">.</span><span class="s2">length </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">);</span>
	<span class="s0">}</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">relative </span><span class="s0">= </span><span class="s2">relative</span><span class="s0">;</span>
	
	<span class="s1">var </span><span class="s2">supportsNullProto </span><span class="s0">= (</span><span class="s1">function </span><span class="s0">() {</span>
	  <span class="s1">var </span><span class="s2">obj </span><span class="s0">= </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">create</span><span class="s0">(</span><span class="s1">null</span><span class="s0">);</span>
	  <span class="s1">return </span><span class="s0">!(</span><span class="s3">'__proto__' </span><span class="s1">in </span><span class="s2">obj</span><span class="s0">);</span>
	<span class="s0">}());</span>
	
	<span class="s1">function </span><span class="s2">identity </span><span class="s0">(</span><span class="s2">s</span><span class="s0">) {</span>
	  <span class="s1">return </span><span class="s2">s</span><span class="s0">;</span>
	<span class="s0">}</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Because behavior goes wacky when you set `__proto__` on objects, we</span>
	 <span class="s6">* have to prefix all the strings in our set with an arbitrary character.</span>
	 <span class="s6">*</span>
	 <span class="s6">* See https://github.com/mozilla/source-map/pull/31 and</span>
	 <span class="s6">* https://github.com/mozilla/source-map/issues/30</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">String aStr</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">toSetString</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">isProtoString</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">)) {</span>
	    <span class="s1">return </span><span class="s3">'$' </span><span class="s0">+ </span><span class="s2">aStr</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s2">aStr</span><span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">toSetString </span><span class="s0">= </span><span class="s2">supportsNullProto </span><span class="s0">? </span><span class="s2">identity </span><span class="s0">: </span><span class="s2">toSetString</span><span class="s0">;</span>
	
	<span class="s1">function </span><span class="s2">fromSetString</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">isProtoString</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">)) {</span>
	    <span class="s1">return </span><span class="s2">aStr</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">1</span><span class="s0">);</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s2">aStr</span><span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">fromSetString </span><span class="s0">= </span><span class="s2">supportsNullProto </span><span class="s0">? </span><span class="s2">identity </span><span class="s0">: </span><span class="s2">fromSetString</span><span class="s0">;</span>
	
	<span class="s1">function </span><span class="s2">isProtoString</span><span class="s0">(</span><span class="s2">s</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">s</span><span class="s0">) {</span>
	    <span class="s1">return false</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">var </span><span class="s2">length </span><span class="s0">= </span><span class="s2">s</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
	
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">length </span><span class="s0">&lt; </span><span class="s5">9 </span><span class="s4">/* &quot;__proto__&quot;.length */</span><span class="s0">) {</span>
	    <span class="s1">return false</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">s</span><span class="s0">.</span><span class="s2">charCodeAt</span><span class="s0">(</span><span class="s2">length </span><span class="s0">- </span><span class="s5">1</span><span class="s0">) !== </span><span class="s5">95  </span><span class="s4">/* '_' */ </span><span class="s0">||</span>
	      <span class="s2">s</span><span class="s0">.</span><span class="s2">charCodeAt</span><span class="s0">(</span><span class="s2">length </span><span class="s0">- </span><span class="s5">2</span><span class="s0">) !== </span><span class="s5">95  </span><span class="s4">/* '_' */ </span><span class="s0">||</span>
	      <span class="s2">s</span><span class="s0">.</span><span class="s2">charCodeAt</span><span class="s0">(</span><span class="s2">length </span><span class="s0">- </span><span class="s5">3</span><span class="s0">) !== </span><span class="s5">111 </span><span class="s4">/* 'o' */ </span><span class="s0">||</span>
	      <span class="s2">s</span><span class="s0">.</span><span class="s2">charCodeAt</span><span class="s0">(</span><span class="s2">length </span><span class="s0">- </span><span class="s5">4</span><span class="s0">) !== </span><span class="s5">116 </span><span class="s4">/* 't' */ </span><span class="s0">||</span>
	      <span class="s2">s</span><span class="s0">.</span><span class="s2">charCodeAt</span><span class="s0">(</span><span class="s2">length </span><span class="s0">- </span><span class="s5">5</span><span class="s0">) !== </span><span class="s5">111 </span><span class="s4">/* 'o' */ </span><span class="s0">||</span>
	      <span class="s2">s</span><span class="s0">.</span><span class="s2">charCodeAt</span><span class="s0">(</span><span class="s2">length </span><span class="s0">- </span><span class="s5">6</span><span class="s0">) !== </span><span class="s5">114 </span><span class="s4">/* 'r' */ </span><span class="s0">||</span>
	      <span class="s2">s</span><span class="s0">.</span><span class="s2">charCodeAt</span><span class="s0">(</span><span class="s2">length </span><span class="s0">- </span><span class="s5">7</span><span class="s0">) !== </span><span class="s5">112 </span><span class="s4">/* 'p' */ </span><span class="s0">||</span>
	      <span class="s2">s</span><span class="s0">.</span><span class="s2">charCodeAt</span><span class="s0">(</span><span class="s2">length </span><span class="s0">- </span><span class="s5">8</span><span class="s0">) !== </span><span class="s5">95  </span><span class="s4">/* '_' */ </span><span class="s0">||</span>
	      <span class="s2">s</span><span class="s0">.</span><span class="s2">charCodeAt</span><span class="s0">(</span><span class="s2">length </span><span class="s0">- </span><span class="s5">9</span><span class="s0">) !== </span><span class="s5">95  </span><span class="s4">/* '_' */</span><span class="s0">) {</span>
	    <span class="s1">return false</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s2">length </span><span class="s0">- </span><span class="s5">10</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&gt;= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">i</span><span class="s0">--) {</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">s</span><span class="s0">.</span><span class="s2">charCodeAt</span><span class="s0">(</span><span class="s2">i</span><span class="s0">) !== </span><span class="s5">36 </span><span class="s4">/* '$' */</span><span class="s0">) {</span>
	      <span class="s1">return false</span><span class="s0">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return true</span><span class="s0">;</span>
	<span class="s0">}</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Comparator between two mappings where the original positions are compared.</span>
	 <span class="s6">*</span>
	 <span class="s6">* Optionally pass in `true` as `onlyCompareGenerated` to consider two</span>
	 <span class="s6">* mappings with the same original source/line/column, but different generated</span>
	 <span class="s6">* line and column the same. Useful when searching for a mapping with a</span>
	 <span class="s6">* stubbed out mapping.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">compareByOriginalPositions</span><span class="s0">(</span><span class="s2">mappingA</span><span class="s0">, </span><span class="s2">mappingB</span><span class="s0">, </span><span class="s2">onlyCompareOriginal</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">cmp </span><span class="s0">= </span><span class="s2">strcmp</span><span class="s0">(</span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">source</span><span class="s0">, </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">source</span><span class="s0">);</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">!== </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">cmp</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s2">cmp </span><span class="s0">= </span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">originalLine </span><span class="s0">- </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">originalLine</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">!== </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">cmp</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s2">cmp </span><span class="s0">= </span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">originalColumn </span><span class="s0">- </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">originalColumn</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">!== </span><span class="s5">0 </span><span class="s0">|| </span><span class="s2">onlyCompareOriginal</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">cmp</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s2">cmp </span><span class="s0">= </span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">generatedColumn </span><span class="s0">- </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">generatedColumn</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">!== </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">cmp</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s2">cmp </span><span class="s0">= </span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">- </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">generatedLine</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">!== </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">cmp</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s2">strcmp</span><span class="s0">(</span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">name</span><span class="s0">, </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">name</span><span class="s0">);</span>
	<span class="s0">}</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">compareByOriginalPositions </span><span class="s0">= </span><span class="s2">compareByOriginalPositions</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Comparator between two mappings with deflated source and name indices where</span>
	 <span class="s6">* the generated positions are compared.</span>
	 <span class="s6">*</span>
	 <span class="s6">* Optionally pass in `true` as `onlyCompareGenerated` to consider two</span>
	 <span class="s6">* mappings with the same generated line and column, but different</span>
	 <span class="s6">* source/name/original line and column the same. Useful when searching for a</span>
	 <span class="s6">* mapping with a stubbed out mapping.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">compareByGeneratedPositionsDeflated</span><span class="s0">(</span><span class="s2">mappingA</span><span class="s0">, </span><span class="s2">mappingB</span><span class="s0">, </span><span class="s2">onlyCompareGenerated</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">cmp </span><span class="s0">= </span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">- </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">generatedLine</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">!== </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">cmp</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s2">cmp </span><span class="s0">= </span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">generatedColumn </span><span class="s0">- </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">generatedColumn</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">!== </span><span class="s5">0 </span><span class="s0">|| </span><span class="s2">onlyCompareGenerated</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">cmp</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s2">cmp </span><span class="s0">= </span><span class="s2">strcmp</span><span class="s0">(</span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">source</span><span class="s0">, </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">source</span><span class="s0">);</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">!== </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">cmp</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s2">cmp </span><span class="s0">= </span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">originalLine </span><span class="s0">- </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">originalLine</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">!== </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">cmp</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s2">cmp </span><span class="s0">= </span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">originalColumn </span><span class="s0">- </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">originalColumn</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">!== </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">cmp</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s2">strcmp</span><span class="s0">(</span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">name</span><span class="s0">, </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">name</span><span class="s0">);</span>
	<span class="s0">}</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">compareByGeneratedPositionsDeflated </span><span class="s0">= </span><span class="s2">compareByGeneratedPositionsDeflated</span><span class="s0">;</span>
	
	<span class="s1">function </span><span class="s2">strcmp</span><span class="s0">(</span><span class="s2">aStr1</span><span class="s0">, </span><span class="s2">aStr2</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aStr1 </span><span class="s0">=== </span><span class="s2">aStr2</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s5">0</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aStr1 </span><span class="s0">=== </span><span class="s1">null</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s5">1</span><span class="s0">; </span><span class="s4">// aStr2 !== null</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aStr2 </span><span class="s0">=== </span><span class="s1">null</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">-</span><span class="s5">1</span><span class="s0">; </span><span class="s4">// aStr1 !== null</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aStr1 </span><span class="s0">&gt; </span><span class="s2">aStr2</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s5">1</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">-</span><span class="s5">1</span><span class="s0">;</span>
	<span class="s0">}</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Comparator between two mappings with inflated source and name strings where</span>
	 <span class="s6">* the generated positions are compared.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">compareByGeneratedPositionsInflated</span><span class="s0">(</span><span class="s2">mappingA</span><span class="s0">, </span><span class="s2">mappingB</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">cmp </span><span class="s0">= </span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">- </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">generatedLine</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">!== </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">cmp</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s2">cmp </span><span class="s0">= </span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">generatedColumn </span><span class="s0">- </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">generatedColumn</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">!== </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">cmp</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s2">cmp </span><span class="s0">= </span><span class="s2">strcmp</span><span class="s0">(</span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">source</span><span class="s0">, </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">source</span><span class="s0">);</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">!== </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">cmp</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s2">cmp </span><span class="s0">= </span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">originalLine </span><span class="s0">- </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">originalLine</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">!== </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">cmp</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s2">cmp </span><span class="s0">= </span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">originalColumn </span><span class="s0">- </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">originalColumn</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">!== </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">cmp</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s2">strcmp</span><span class="s0">(</span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">name</span><span class="s0">, </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">name</span><span class="s0">);</span>
	<span class="s0">}</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">compareByGeneratedPositionsInflated </span><span class="s0">= </span><span class="s2">compareByGeneratedPositionsInflated</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Strip any JSON XSSI avoidance prefix from the string (as documented</span>
	 <span class="s6">* in the source maps specification), and then parse the string as</span>
	 <span class="s6">* JSON.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">parseSourceMapInput</span><span class="s0">(</span><span class="s2">str</span><span class="s0">) {</span>
	  <span class="s1">return </span><span class="s2">JSON</span><span class="s0">.</span><span class="s2">parse</span><span class="s0">(</span><span class="s2">str</span><span class="s0">.</span><span class="s2">replace</span><span class="s0">(</span><span class="s8">/^\)]}'[^\n]*\n/</span><span class="s0">, </span><span class="s3">''</span><span class="s0">));</span>
	<span class="s0">}</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">parseSourceMapInput </span><span class="s0">= </span><span class="s2">parseSourceMapInput</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Compute the URL of a source given the the source root, the source's</span>
	 <span class="s6">* URL, and the source map's URL.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">computeSourceURL</span><span class="s0">(</span><span class="s2">sourceRoot</span><span class="s0">, </span><span class="s2">sourceURL</span><span class="s0">, </span><span class="s2">sourceMapURL</span><span class="s0">) {</span>
	  <span class="s2">sourceURL </span><span class="s0">= </span><span class="s2">sourceURL </span><span class="s0">|| </span><span class="s3">''</span><span class="s0">;</span>
	
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">sourceRoot</span><span class="s0">) {</span>
	    <span class="s4">// This follows what Chrome does.</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">sourceRoot</span><span class="s0">[</span><span class="s2">sourceRoot</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s5">1</span><span class="s0">] !== </span><span class="s3">'/' </span><span class="s0">&amp;&amp; </span><span class="s2">sourceURL</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] !== </span><span class="s3">'/'</span><span class="s0">) {</span>
	      <span class="s2">sourceRoot </span><span class="s0">+= </span><span class="s3">'/'</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s4">// The spec says:</span>
	    <span class="s4">//   Line 4: An optional source root, useful for relocating source</span>
	    <span class="s4">//   files on a server or removing repeated values in the</span>
	    <span class="s4">//   “sources” entry.  This value is prepended to the individual</span>
	    <span class="s4">//   entries in the “source” field.</span>
	    <span class="s2">sourceURL </span><span class="s0">= </span><span class="s2">sourceRoot </span><span class="s0">+ </span><span class="s2">sourceURL</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s4">// Historically, SourceMapConsumer did not take the sourceMapURL as</span>
	  <span class="s4">// a parameter.  This mode is still somewhat supported, which is why</span>
	  <span class="s4">// this code block is conditional.  However, it's preferable to pass</span>
	  <span class="s4">// the source map URL to SourceMapConsumer, so that this function</span>
	  <span class="s4">// can implement the source URL resolution algorithm as outlined in</span>
	  <span class="s4">// the spec.  This block is basically the equivalent of:</span>
	  <span class="s4">//    new URL(sourceURL, sourceMapURL).toString()</span>
	  <span class="s4">// ... except it avoids using URL, which wasn't available in the</span>
	  <span class="s4">// older releases of node still supported by this library.</span>
	  <span class="s4">//</span>
	  <span class="s4">// The spec says:</span>
	  <span class="s4">//   If the sources are not absolute URLs after prepending of the</span>
	  <span class="s4">//   “sourceRoot”, the sources are resolved relative to the</span>
	  <span class="s4">//   SourceMap (like resolving script src in a html document).</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">sourceMapURL</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">parsed </span><span class="s0">= </span><span class="s2">urlParse</span><span class="s0">(</span><span class="s2">sourceMapURL</span><span class="s0">);</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s2">parsed</span><span class="s0">) {</span>
	      <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">&quot;sourceMapURL could not be parsed&quot;</span><span class="s0">);</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">parsed</span><span class="s0">.</span><span class="s2">path</span><span class="s0">) {</span>
	      <span class="s4">// Strip the last path component, but keep the &quot;/&quot;.</span>
	      <span class="s1">var </span><span class="s2">index </span><span class="s0">= </span><span class="s2">parsed</span><span class="s0">.</span><span class="s2">path</span><span class="s0">.</span><span class="s2">lastIndexOf</span><span class="s0">(</span><span class="s3">'/'</span><span class="s0">);</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">index </span><span class="s0">&gt;= </span><span class="s5">0</span><span class="s0">) {</span>
	        <span class="s2">parsed</span><span class="s0">.</span><span class="s2">path </span><span class="s0">= </span><span class="s2">parsed</span><span class="s0">.</span><span class="s2">path</span><span class="s0">.</span><span class="s2">substring</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">index </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">);</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	    <span class="s2">sourceURL </span><span class="s0">= </span><span class="s2">join</span><span class="s0">(</span><span class="s2">urlGenerate</span><span class="s0">(</span><span class="s2">parsed</span><span class="s0">), </span><span class="s2">sourceURL</span><span class="s0">);</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s2">normalize</span><span class="s0">(</span><span class="s2">sourceURL</span><span class="s0">);</span>
	<span class="s0">}</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">computeSourceURL </span><span class="s0">= </span><span class="s2">computeSourceURL</span><span class="s0">;</span>


<span class="s4">/***/ </span><span class="s0">}),</span>
<span class="s4">/* 5 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(</span><span class="s2">module</span><span class="s0">, </span><span class="s2">exports</span><span class="s0">, </span><span class="s2">__webpack_require__</span><span class="s0">) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s2">util </span><span class="s0">= </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">4</span><span class="s0">);</span>
	<span class="s1">var </span><span class="s2">has </span><span class="s0">= </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">hasOwnProperty</span><span class="s0">;</span>
	<span class="s1">var </span><span class="s2">hasNativeMap </span><span class="s0">= </span><span class="s1">typeof </span><span class="s2">Map </span><span class="s0">!== </span><span class="s3">&quot;undefined&quot;</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* A data structure which is a combination of an array and a set. Adding a new</span>
	 <span class="s6">* member is O(1), testing for membership is O(1), and finding the index of an</span>
	 <span class="s6">* element is O(1). Removing elements from the set is not supported. Only</span>
	 <span class="s6">* strings are supported for membership.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">ArraySet</span><span class="s0">() {</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_array </span><span class="s0">= [];</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_set </span><span class="s0">= </span><span class="s2">hasNativeMap </span><span class="s0">? </span><span class="s1">new </span><span class="s2">Map</span><span class="s0">() : </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">create</span><span class="s0">(</span><span class="s1">null</span><span class="s0">);</span>
	<span class="s0">}</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Static method for creating ArraySet instances from an existing array.</span>
	 <span class="s6">*/</span>
	<span class="s2">ArraySet</span><span class="s0">.</span><span class="s2">fromArray </span><span class="s0">= </span><span class="s1">function </span><span class="s2">ArraySet_fromArray</span><span class="s0">(</span><span class="s2">aArray</span><span class="s0">, </span><span class="s2">aAllowDuplicates</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">set </span><span class="s0">= </span><span class="s1">new </span><span class="s2">ArraySet</span><span class="s0">();</span>
	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">, </span><span class="s2">len </span><span class="s0">= </span><span class="s2">aArray</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">len</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
	    <span class="s2">set</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">aArray</span><span class="s0">[</span><span class="s2">i</span><span class="s0">], </span><span class="s2">aAllowDuplicates</span><span class="s0">);</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s2">set</span><span class="s0">;</span>
	<span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Return how many unique items are in this ArraySet. If duplicates have been</span>
	 <span class="s6">* added, than those do not count towards the size.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@returns </span><span class="s6">Number</span>
	 <span class="s6">*/</span>
	<span class="s2">ArraySet</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">size </span><span class="s0">= </span><span class="s1">function </span><span class="s2">ArraySet_size</span><span class="s0">() {</span>
	  <span class="s1">return </span><span class="s2">hasNativeMap </span><span class="s0">? </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_set</span><span class="s0">.</span><span class="s2">size </span><span class="s0">: </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">getOwnPropertyNames</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_set</span><span class="s0">).</span><span class="s2">length</span><span class="s0">;</span>
	<span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Add the given string to this set.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">String aStr</span>
	 <span class="s6">*/</span>
	<span class="s2">ArraySet</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">add </span><span class="s0">= </span><span class="s1">function </span><span class="s2">ArraySet_add</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">, </span><span class="s2">aAllowDuplicates</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">sStr </span><span class="s0">= </span><span class="s2">hasNativeMap </span><span class="s0">? </span><span class="s2">aStr </span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">toSetString</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">);</span>
	  <span class="s1">var </span><span class="s2">isDuplicate </span><span class="s0">= </span><span class="s2">hasNativeMap </span><span class="s0">? </span><span class="s1">this</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">) : </span><span class="s2">has</span><span class="s0">.</span><span class="s2">call</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_set</span><span class="s0">, </span><span class="s2">sStr</span><span class="s0">);</span>
	  <span class="s1">var </span><span class="s2">idx </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_array</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">isDuplicate </span><span class="s0">|| </span><span class="s2">aAllowDuplicates</span><span class="s0">) {</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">_array</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">);</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">isDuplicate</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">hasNativeMap</span><span class="s0">) {</span>
	      <span class="s1">this</span><span class="s0">.</span><span class="s2">_set</span><span class="s0">.</span><span class="s2">set</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">, </span><span class="s2">idx</span><span class="s0">);</span>
	    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">this</span><span class="s0">.</span><span class="s2">_set</span><span class="s0">[</span><span class="s2">sStr</span><span class="s0">] = </span><span class="s2">idx</span><span class="s0">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	<span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Is the given string a member of this set?</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">String aStr</span>
	 <span class="s6">*/</span>
	<span class="s2">ArraySet</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">has </span><span class="s0">= </span><span class="s1">function </span><span class="s2">ArraySet_has</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">hasNativeMap</span><span class="s0">) {</span>
	    <span class="s1">return this</span><span class="s0">.</span><span class="s2">_set</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">);</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">var </span><span class="s2">sStr </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">toSetString</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">);</span>
	    <span class="s1">return </span><span class="s2">has</span><span class="s0">.</span><span class="s2">call</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_set</span><span class="s0">, </span><span class="s2">sStr</span><span class="s0">);</span>
	  <span class="s0">}</span>
	<span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* What is the index of the given string in the array?</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">String aStr</span>
	 <span class="s6">*/</span>
	<span class="s2">ArraySet</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">indexOf </span><span class="s0">= </span><span class="s1">function </span><span class="s2">ArraySet_indexOf</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">hasNativeMap</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">idx </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_set</span><span class="s0">.</span><span class="s2">get</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">);</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">idx </span><span class="s0">&gt;= </span><span class="s5">0</span><span class="s0">) {</span>
	        <span class="s1">return </span><span class="s2">idx</span><span class="s0">;</span>
	    <span class="s0">}</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">var </span><span class="s2">sStr </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">toSetString</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">);</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">has</span><span class="s0">.</span><span class="s2">call</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_set</span><span class="s0">, </span><span class="s2">sStr</span><span class="s0">)) {</span>
	      <span class="s1">return this</span><span class="s0">.</span><span class="s2">_set</span><span class="s0">[</span><span class="s2">sStr</span><span class="s0">];</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	
	  <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">'&quot;' </span><span class="s0">+ </span><span class="s2">aStr </span><span class="s0">+ </span><span class="s3">'&quot; is not in the set.'</span><span class="s0">);</span>
	<span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* What is the element at the given index?</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">Number aIdx</span>
	 <span class="s6">*/</span>
	<span class="s2">ArraySet</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">at </span><span class="s0">= </span><span class="s1">function </span><span class="s2">ArraySet_at</span><span class="s0">(</span><span class="s2">aIdx</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aIdx </span><span class="s0">&gt;= </span><span class="s5">0 </span><span class="s0">&amp;&amp; </span><span class="s2">aIdx </span><span class="s0">&lt; </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_array</span><span class="s0">.</span><span class="s2">length</span><span class="s0">) {</span>
	    <span class="s1">return this</span><span class="s0">.</span><span class="s2">_array</span><span class="s0">[</span><span class="s2">aIdx</span><span class="s0">];</span>
	  <span class="s0">}</span>
	  <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">'No element indexed by ' </span><span class="s0">+ </span><span class="s2">aIdx</span><span class="s0">);</span>
	<span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Returns the array representation of this set (which has the proper indices</span>
	 <span class="s6">* indicated by indexOf). Note that this is a copy of the internal array used</span>
	 <span class="s6">* for storing the members so that no one can mess with internal state.</span>
	 <span class="s6">*/</span>
	<span class="s2">ArraySet</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">toArray </span><span class="s0">= </span><span class="s1">function </span><span class="s2">ArraySet_toArray</span><span class="s0">() {</span>
	  <span class="s1">return this</span><span class="s0">.</span><span class="s2">_array</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">();</span>
	<span class="s0">};</span>
	
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">ArraySet </span><span class="s0">= </span><span class="s2">ArraySet</span><span class="s0">;</span>


<span class="s4">/***/ </span><span class="s0">}),</span>
<span class="s4">/* 6 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(</span><span class="s2">module</span><span class="s0">, </span><span class="s2">exports</span><span class="s0">, </span><span class="s2">__webpack_require__</span><span class="s0">) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2014 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s2">util </span><span class="s0">= </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">4</span><span class="s0">);</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Determine whether mappingB is after mappingA with respect to generated</span>
	 <span class="s6">* position.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">generatedPositionAfter</span><span class="s0">(</span><span class="s2">mappingA</span><span class="s0">, </span><span class="s2">mappingB</span><span class="s0">) {</span>
	  <span class="s4">// Optimized for most common case</span>
	  <span class="s1">var </span><span class="s2">lineA </span><span class="s0">= </span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">generatedLine</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">lineB </span><span class="s0">= </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">generatedLine</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">columnA </span><span class="s0">= </span><span class="s2">mappingA</span><span class="s0">.</span><span class="s2">generatedColumn</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">columnB </span><span class="s0">= </span><span class="s2">mappingB</span><span class="s0">.</span><span class="s2">generatedColumn</span><span class="s0">;</span>
	  <span class="s1">return </span><span class="s2">lineB </span><span class="s0">&gt; </span><span class="s2">lineA </span><span class="s0">|| </span><span class="s2">lineB </span><span class="s0">== </span><span class="s2">lineA </span><span class="s0">&amp;&amp; </span><span class="s2">columnB </span><span class="s0">&gt;= </span><span class="s2">columnA </span><span class="s0">||</span>
	         <span class="s2">util</span><span class="s0">.</span><span class="s2">compareByGeneratedPositionsInflated</span><span class="s0">(</span><span class="s2">mappingA</span><span class="s0">, </span><span class="s2">mappingB</span><span class="s0">) &lt;= </span><span class="s5">0</span><span class="s0">;</span>
	<span class="s0">}</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* A data structure to provide a sorted view of accumulated mappings in a</span>
	 <span class="s6">* performance conscious manner. It trades a neglibable overhead in general</span>
	 <span class="s6">* case for a large speedup in case of mappings being added in order.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">MappingList</span><span class="s0">() {</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_array </span><span class="s0">= [];</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_sorted </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
	  <span class="s4">// Serves as infimum</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_last </span><span class="s0">= {</span><span class="s2">generatedLine</span><span class="s0">: -</span><span class="s5">1</span><span class="s0">, </span><span class="s2">generatedColumn</span><span class="s0">: </span><span class="s5">0</span><span class="s0">};</span>
	<span class="s0">}</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Iterate through internal items. This method takes the same arguments that</span>
	 <span class="s6">* `Array.prototype.forEach` takes.</span>
	 <span class="s6">*</span>
	 <span class="s6">* NOTE: The order of the mappings is NOT guaranteed.</span>
	 <span class="s6">*/</span>
	<span class="s2">MappingList</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">unsortedForEach </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">MappingList_forEach</span><span class="s0">(</span><span class="s2">aCallback</span><span class="s0">, </span><span class="s2">aThisArg</span><span class="s0">) {</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">_array</span><span class="s0">.</span><span class="s2">forEach</span><span class="s0">(</span><span class="s2">aCallback</span><span class="s0">, </span><span class="s2">aThisArg</span><span class="s0">);</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Add the given source mapping.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">Object aMapping</span>
	 <span class="s6">*/</span>
	<span class="s2">MappingList</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">add </span><span class="s0">= </span><span class="s1">function </span><span class="s2">MappingList_add</span><span class="s0">(</span><span class="s2">aMapping</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">generatedPositionAfter</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_last</span><span class="s0">, </span><span class="s2">aMapping</span><span class="s0">)) {</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">_last </span><span class="s0">= </span><span class="s2">aMapping</span><span class="s0">;</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">_array</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s2">aMapping</span><span class="s0">);</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">_sorted </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">_array</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s2">aMapping</span><span class="s0">);</span>
	  <span class="s0">}</span>
	<span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Returns the flat, sorted array of mappings. The mappings are sorted by</span>
	 <span class="s6">* generated position.</span>
	 <span class="s6">*</span>
	 <span class="s6">* WARNING: This method returns internal data without copying, for</span>
	 <span class="s6">* performance. The return value must NOT be mutated, and should be treated as</span>
	 <span class="s6">* an immutable borrow. If you want to take ownership, you must make your own</span>
	 <span class="s6">* copy.</span>
	 <span class="s6">*/</span>
	<span class="s2">MappingList</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">toArray </span><span class="s0">= </span><span class="s1">function </span><span class="s2">MappingList_toArray</span><span class="s0">() {</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sorted</span><span class="s0">) {</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">_array</span><span class="s0">.</span><span class="s2">sort</span><span class="s0">(</span><span class="s2">util</span><span class="s0">.</span><span class="s2">compareByGeneratedPositionsInflated</span><span class="s0">);</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">_sorted </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s0">.</span><span class="s2">_array</span><span class="s0">;</span>
	<span class="s0">};</span>
	
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">MappingList </span><span class="s0">= </span><span class="s2">MappingList</span><span class="s0">;</span>


<span class="s4">/***/ </span><span class="s0">}),</span>
<span class="s4">/* 7 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(</span><span class="s2">module</span><span class="s0">, </span><span class="s2">exports</span><span class="s0">, </span><span class="s2">__webpack_require__</span><span class="s0">) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s2">util </span><span class="s0">= </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">4</span><span class="s0">);</span>
	<span class="s1">var </span><span class="s2">binarySearch </span><span class="s0">= </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">8</span><span class="s0">);</span>
	<span class="s1">var </span><span class="s2">ArraySet </span><span class="s0">= </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">5</span><span class="s0">).</span><span class="s2">ArraySet</span><span class="s0">;</span>
	<span class="s1">var </span><span class="s2">base64VLQ </span><span class="s0">= </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">2</span><span class="s0">);</span>
	<span class="s1">var </span><span class="s2">quickSort </span><span class="s0">= </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">9</span><span class="s0">).</span><span class="s2">quickSort</span><span class="s0">;</span>
	
	<span class="s1">function </span><span class="s2">SourceMapConsumer</span><span class="s0">(</span><span class="s2">aSourceMap</span><span class="s0">, </span><span class="s2">aSourceMapURL</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">sourceMap </span><span class="s0">= </span><span class="s2">aSourceMap</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">aSourceMap </span><span class="s0">=== </span><span class="s3">'string'</span><span class="s0">) {</span>
	    <span class="s2">sourceMap </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">parseSourceMapInput</span><span class="s0">(</span><span class="s2">aSourceMap</span><span class="s0">);</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s2">sourceMap</span><span class="s0">.</span><span class="s2">sections </span><span class="s0">!= </span><span class="s1">null</span>
	    <span class="s0">? </span><span class="s1">new </span><span class="s2">IndexedSourceMapConsumer</span><span class="s0">(</span><span class="s2">sourceMap</span><span class="s0">, </span><span class="s2">aSourceMapURL</span><span class="s0">)</span>
	    <span class="s0">: </span><span class="s1">new </span><span class="s2">BasicSourceMapConsumer</span><span class="s0">(</span><span class="s2">sourceMap</span><span class="s0">, </span><span class="s2">aSourceMapURL</span><span class="s0">);</span>
	<span class="s0">}</span>
	
	<span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">fromSourceMap </span><span class="s0">= </span><span class="s1">function</span><span class="s0">(</span><span class="s2">aSourceMap</span><span class="s0">, </span><span class="s2">aSourceMapURL</span><span class="s0">) {</span>
	  <span class="s1">return </span><span class="s2">BasicSourceMapConsumer</span><span class="s0">.</span><span class="s2">fromSourceMap</span><span class="s0">(</span><span class="s2">aSourceMap</span><span class="s0">, </span><span class="s2">aSourceMapURL</span><span class="s0">);</span>
	<span class="s0">}</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* The version of the source mapping spec that we are consuming.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">_version </span><span class="s0">= </span><span class="s5">3</span><span class="s0">;</span>
	
	<span class="s4">// `__generatedMappings` and `__originalMappings` are arrays that hold the</span>
	<span class="s4">// parsed mapping coordinates from the source map's &quot;mappings&quot; attribute. They</span>
	<span class="s4">// are lazily instantiated, accessed via the `_generatedMappings` and</span>
	<span class="s4">// `_originalMappings` getters respectively, and we only parse the mappings</span>
	<span class="s4">// and create these arrays once queried for a source location. We jump through</span>
	<span class="s4">// these hoops because there can be many thousands of mappings, and parsing</span>
	<span class="s4">// them is expensive, so we only want to do it if we must.</span>
	<span class="s4">//</span>
	<span class="s4">// Each object in the arrays is of the form:</span>
	<span class="s4">//</span>
	<span class="s4">//     {</span>
	<span class="s4">//       generatedLine: The line number in the generated code,</span>
	<span class="s4">//       generatedColumn: The column number in the generated code,</span>
	<span class="s4">//       source: The path to the original source file that generated this</span>
	<span class="s4">//               chunk of code,</span>
	<span class="s4">//       originalLine: The line number in the original source that</span>
	<span class="s4">//                     corresponds to this chunk of generated code,</span>
	<span class="s4">//       originalColumn: The column number in the original source that</span>
	<span class="s4">//                       corresponds to this chunk of generated code,</span>
	<span class="s4">//       name: The name of the original symbol which generated this chunk of</span>
	<span class="s4">//             code.</span>
	<span class="s4">//     }</span>
	<span class="s4">//</span>
	<span class="s4">// All properties except for `generatedLine` and `generatedColumn` can be</span>
	<span class="s4">// `null`.</span>
	<span class="s4">//</span>
	<span class="s4">// `_generatedMappings` is ordered by the generated positions.</span>
	<span class="s4">//</span>
	<span class="s4">// `_originalMappings` is ordered by the original positions.</span>
	
	<span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">__generatedMappings </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
	<span class="s2">Object</span><span class="s0">.</span><span class="s2">defineProperty</span><span class="s0">(</span><span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">, </span><span class="s3">'_generatedMappings'</span><span class="s0">, {</span>
	  <span class="s2">configurable</span><span class="s0">: </span><span class="s1">true</span><span class="s0">,</span>
	  <span class="s2">enumerable</span><span class="s0">: </span><span class="s1">true</span><span class="s0">,</span>
	  <span class="s2">get</span><span class="s0">: </span><span class="s1">function </span><span class="s0">() {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">__generatedMappings</span><span class="s0">) {</span>
	      <span class="s1">this</span><span class="s0">.</span><span class="s2">_parseMappings</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_mappings</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.</span><span class="s2">sourceRoot</span><span class="s0">);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return this</span><span class="s0">.</span><span class="s2">__generatedMappings</span><span class="s0">;</span>
	  <span class="s0">}</span>
	<span class="s0">});</span>
	
	<span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">__originalMappings </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
	<span class="s2">Object</span><span class="s0">.</span><span class="s2">defineProperty</span><span class="s0">(</span><span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">, </span><span class="s3">'_originalMappings'</span><span class="s0">, {</span>
	  <span class="s2">configurable</span><span class="s0">: </span><span class="s1">true</span><span class="s0">,</span>
	  <span class="s2">enumerable</span><span class="s0">: </span><span class="s1">true</span><span class="s0">,</span>
	  <span class="s2">get</span><span class="s0">: </span><span class="s1">function </span><span class="s0">() {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">__originalMappings</span><span class="s0">) {</span>
	      <span class="s1">this</span><span class="s0">.</span><span class="s2">_parseMappings</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_mappings</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.</span><span class="s2">sourceRoot</span><span class="s0">);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return this</span><span class="s0">.</span><span class="s2">__originalMappings</span><span class="s0">;</span>
	  <span class="s0">}</span>
	<span class="s0">});</span>
	
	<span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">_charIsMappingSeparator </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapConsumer_charIsMappingSeparator</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">, </span><span class="s2">index</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">c </span><span class="s0">= </span><span class="s2">aStr</span><span class="s0">.</span><span class="s2">charAt</span><span class="s0">(</span><span class="s2">index</span><span class="s0">);</span>
	    <span class="s1">return </span><span class="s2">c </span><span class="s0">=== </span><span class="s3">&quot;;&quot; </span><span class="s0">|| </span><span class="s2">c </span><span class="s0">=== </span><span class="s3">&quot;,&quot;</span><span class="s0">;</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Parse the mappings in a string in to a data structure which we can easily</span>
	 <span class="s6">* query (the ordered arrays in the `this.__generatedMappings` and</span>
	 <span class="s6">* `this.__originalMappings` properties).</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">_parseMappings </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapConsumer_parseMappings</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">, </span><span class="s2">aSourceRoot</span><span class="s0">) {</span>
	    <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">&quot;Subclasses must implement _parseMappings&quot;</span><span class="s0">);</span>
	  <span class="s0">};</span>
	
	<span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">GENERATED_ORDER </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
	<span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">ORIGINAL_ORDER </span><span class="s0">= </span><span class="s5">2</span><span class="s0">;</span>
	
	<span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">GREATEST_LOWER_BOUND </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
	<span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">LEAST_UPPER_BOUND </span><span class="s0">= </span><span class="s5">2</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Iterate over each mapping between an original source/line/column and a</span>
	 <span class="s6">* generated line/column in this source map.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">Function aCallback</span>
	 <span class="s6">*        The function that is called with each mapping.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">Object aContext</span>
	 <span class="s6">*        Optional. If specified, this object will be the value of `this` every</span>
	 <span class="s6">*        time that `aCallback` is called.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aOrder</span>
	 <span class="s6">*        Either `SourceMapConsumer.GENERATED_ORDER` or</span>
	 <span class="s6">*        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to</span>
	 <span class="s6">*        iterate over the mappings sorted by the generated file's line/column</span>
	 <span class="s6">*        order or the original's source/line/column order, respectively. Defaults to</span>
	 <span class="s6">*        `SourceMapConsumer.GENERATED_ORDER`.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">eachMapping </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapConsumer_eachMapping</span><span class="s0">(</span><span class="s2">aCallback</span><span class="s0">, </span><span class="s2">aContext</span><span class="s0">, </span><span class="s2">aOrder</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">context </span><span class="s0">= </span><span class="s2">aContext </span><span class="s0">|| </span><span class="s1">null</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">order </span><span class="s0">= </span><span class="s2">aOrder </span><span class="s0">|| </span><span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">GENERATED_ORDER</span><span class="s0">;</span>
	
	    <span class="s1">var </span><span class="s2">mappings</span><span class="s0">;</span>
	    <span class="s1">switch </span><span class="s0">(</span><span class="s2">order</span><span class="s0">) {</span>
	    <span class="s1">case </span><span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">GENERATED_ORDER</span><span class="s0">:</span>
	      <span class="s2">mappings </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_generatedMappings</span><span class="s0">;</span>
	      <span class="s1">break</span><span class="s0">;</span>
	    <span class="s1">case </span><span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">ORIGINAL_ORDER</span><span class="s0">:</span>
	      <span class="s2">mappings </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_originalMappings</span><span class="s0">;</span>
	      <span class="s1">break</span><span class="s0">;</span>
	    <span class="s1">default</span><span class="s0">:</span>
	      <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">&quot;Unknown order of iteration.&quot;</span><span class="s0">);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">var </span><span class="s2">sourceRoot </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">sourceRoot</span><span class="s0">;</span>
	    <span class="s2">mappings</span><span class="s0">.</span><span class="s2">map</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">source </span><span class="s0">= </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">source </span><span class="s0">=== </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">at</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">source</span><span class="s0">);</span>
	      <span class="s2">source </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">computeSourceURL</span><span class="s0">(</span><span class="s2">sourceRoot</span><span class="s0">, </span><span class="s2">source</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sourceMapURL</span><span class="s0">);</span>
	      <span class="s1">return </span><span class="s0">{</span>
	        <span class="s2">source</span><span class="s0">: </span><span class="s2">source</span><span class="s0">,</span>
	        <span class="s2">generatedLine</span><span class="s0">: </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedLine</span><span class="s0">,</span>
	        <span class="s2">generatedColumn</span><span class="s0">: </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedColumn</span><span class="s0">,</span>
	        <span class="s2">originalLine</span><span class="s0">: </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalLine</span><span class="s0">,</span>
	        <span class="s2">originalColumn</span><span class="s0">: </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalColumn</span><span class="s0">,</span>
	        <span class="s2">name</span><span class="s0">: </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">name </span><span class="s0">=== </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_names</span><span class="s0">.</span><span class="s2">at</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">name</span><span class="s0">)</span>
	      <span class="s0">};</span>
	    <span class="s0">}, </span><span class="s1">this</span><span class="s0">).</span><span class="s2">forEach</span><span class="s0">(</span><span class="s2">aCallback</span><span class="s0">, </span><span class="s2">context</span><span class="s0">);</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Returns all generated line and column information for the original source,</span>
	 <span class="s6">* line, and column provided. If no column is provided, returns all mappings</span>
	 <span class="s6">* corresponding to a either the line we are searching for or the next</span>
	 <span class="s6">* closest line that has any mappings. Otherwise, returns all mappings</span>
	 <span class="s6">* corresponding to the given line and either the column we are searching for</span>
	 <span class="s6">* or the next closest column that has any offsets.</span>
	 <span class="s6">*</span>
	 <span class="s6">* The only argument is an object with the following properties:</span>
	 <span class="s6">*</span>
	 <span class="s6">*   - source: The filename of the original source.</span>
	 <span class="s6">*   - line: The line number in the original source.  The line number is 1-based.</span>
	 <span class="s6">*   - column: Optional. the column number in the original source.</span>
	 <span class="s6">*    The column number is 0-based.</span>
	 <span class="s6">*</span>
	 <span class="s6">* and an array of objects is returned, each with the following properties:</span>
	 <span class="s6">*</span>
	 <span class="s6">*   - line: The line number in the generated source, or null.  The</span>
	 <span class="s6">*    line number is 1-based.</span>
	 <span class="s6">*   - column: The column number in the generated source, or null.</span>
	 <span class="s6">*    The column number is 0-based.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">allGeneratedPositionsFor </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapConsumer_allGeneratedPositionsFor</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">line </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'line'</span><span class="s0">);</span>
	
	    <span class="s4">// When there is no exact match, BasicSourceMapConsumer.prototype._findMapping</span>
	    <span class="s4">// returns the index of the closest mapping less than the needle. By</span>
	    <span class="s4">// setting needle.originalColumn to 0, we thus find the last mapping for</span>
	    <span class="s4">// the given line, provided such a mapping exists.</span>
	    <span class="s1">var </span><span class="s2">needle </span><span class="s0">= {</span>
	      <span class="s2">source</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'source'</span><span class="s0">),</span>
	      <span class="s2">originalLine</span><span class="s0">: </span><span class="s2">line</span><span class="s0">,</span>
	      <span class="s2">originalColumn</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'column'</span><span class="s0">, </span><span class="s5">0</span><span class="s0">)</span>
	    <span class="s0">};</span>
	
	    <span class="s2">needle</span><span class="s0">.</span><span class="s2">source </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_findSourceIndex</span><span class="s0">(</span><span class="s2">needle</span><span class="s0">.</span><span class="s2">source</span><span class="s0">);</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">needle</span><span class="s0">.</span><span class="s2">source </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s0">[];</span>
	    <span class="s0">}</span>
	
	    <span class="s1">var </span><span class="s2">mappings </span><span class="s0">= [];</span>
	
	    <span class="s1">var </span><span class="s2">index </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_findMapping</span><span class="s0">(</span><span class="s2">needle</span><span class="s0">,</span>
	                                  <span class="s1">this</span><span class="s0">.</span><span class="s2">_originalMappings</span><span class="s0">,</span>
	                                  <span class="s3">&quot;originalLine&quot;</span><span class="s0">,</span>
	                                  <span class="s3">&quot;originalColumn&quot;</span><span class="s0">,</span>
	                                  <span class="s2">util</span><span class="s0">.</span><span class="s2">compareByOriginalPositions</span><span class="s0">,</span>
	                                  <span class="s2">binarySearch</span><span class="s0">.</span><span class="s2">LEAST_UPPER_BOUND</span><span class="s0">);</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">index </span><span class="s0">&gt;= </span><span class="s5">0</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">mapping </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_originalMappings</span><span class="s0">[</span><span class="s2">index</span><span class="s0">];</span>
	
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">.</span><span class="s2">column </span><span class="s0">=== </span><span class="s2">undefined</span><span class="s0">) {</span>
	        <span class="s1">var </span><span class="s2">originalLine </span><span class="s0">= </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalLine</span><span class="s0">;</span>
	
	        <span class="s4">// Iterate until either we run out of mappings, or we run into</span>
	        <span class="s4">// a mapping for a different line than the one we found. Since</span>
	        <span class="s4">// mappings are sorted, this is guaranteed to find all mappings for</span>
	        <span class="s4">// the line we found.</span>
	        <span class="s1">while </span><span class="s0">(</span><span class="s2">mapping </span><span class="s0">&amp;&amp; </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalLine </span><span class="s0">=== </span><span class="s2">originalLine</span><span class="s0">) {</span>
	          <span class="s2">mappings</span><span class="s0">.</span><span class="s2">push</span><span class="s0">({</span>
	            <span class="s2">line</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">, </span><span class="s3">'generatedLine'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">),</span>
	            <span class="s2">column</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">, </span><span class="s3">'generatedColumn'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">),</span>
	            <span class="s2">lastColumn</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">, </span><span class="s3">'lastGeneratedColumn'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">)</span>
	          <span class="s0">});</span>
	
	          <span class="s2">mapping </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_originalMappings</span><span class="s0">[++</span><span class="s2">index</span><span class="s0">];</span>
	        <span class="s0">}</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	        <span class="s1">var </span><span class="s2">originalColumn </span><span class="s0">= </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalColumn</span><span class="s0">;</span>
	
	        <span class="s4">// Iterate until either we run out of mappings, or we run into</span>
	        <span class="s4">// a mapping for a different line than the one we were searching for.</span>
	        <span class="s4">// Since mappings are sorted, this is guaranteed to find all mappings for</span>
	        <span class="s4">// the line we are searching for.</span>
	        <span class="s1">while </span><span class="s0">(</span><span class="s2">mapping </span><span class="s0">&amp;&amp;</span>
	               <span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalLine </span><span class="s0">=== </span><span class="s2">line </span><span class="s0">&amp;&amp;</span>
	               <span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalColumn </span><span class="s0">== </span><span class="s2">originalColumn</span><span class="s0">) {</span>
	          <span class="s2">mappings</span><span class="s0">.</span><span class="s2">push</span><span class="s0">({</span>
	            <span class="s2">line</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">, </span><span class="s3">'generatedLine'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">),</span>
	            <span class="s2">column</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">, </span><span class="s3">'generatedColumn'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">),</span>
	            <span class="s2">lastColumn</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">, </span><span class="s3">'lastGeneratedColumn'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">)</span>
	          <span class="s0">});</span>
	
	          <span class="s2">mapping </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_originalMappings</span><span class="s0">[++</span><span class="s2">index</span><span class="s0">];</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s2">mappings</span><span class="s0">;</span>
	  <span class="s0">};</span>
	
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">SourceMapConsumer </span><span class="s0">= </span><span class="s2">SourceMapConsumer</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* A BasicSourceMapConsumer instance represents a parsed source map which we can</span>
	 <span class="s6">* query for information about the original file positions by giving it a file</span>
	 <span class="s6">* position in the generated source.</span>
	 <span class="s6">*</span>
	 <span class="s6">* The first parameter is the raw source map (either as a JSON string, or</span>
	 <span class="s6">* already parsed to an object). According to the spec, source maps have the</span>
	 <span class="s6">* following attributes:</span>
	 <span class="s6">*</span>
	 <span class="s6">*   - version: Which version of the source map spec this map is following.</span>
	 <span class="s6">*   - sources: An array of URLs to the original source files.</span>
	 <span class="s6">*   - names: An array of identifiers which can be referrenced by individual mappings.</span>
	 <span class="s6">*   - sourceRoot: Optional. The URL root from which all sources are relative.</span>
	 <span class="s6">*   - sourcesContent: Optional. An array of contents of the original source files.</span>
	 <span class="s6">*   - mappings: A string of base64 VLQs which contain the actual mappings.</span>
	 <span class="s6">*   - file: Optional. The generated file this source map is associated with.</span>
	 <span class="s6">*</span>
	 <span class="s6">* Here is an example source map, taken from the source map spec[0]:</span>
	 <span class="s6">*</span>
	 <span class="s6">*     {</span>
	 <span class="s6">*       version : 3,</span>
	 <span class="s6">*       file: &quot;out.js&quot;,</span>
	 <span class="s6">*       sourceRoot : &quot;&quot;,</span>
	 <span class="s6">*       sources: [&quot;foo.js&quot;, &quot;bar.js&quot;],</span>
	 <span class="s6">*       names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;],</span>
	 <span class="s6">*       mappings: &quot;AA,AB;;ABCDE;&quot;</span>
	 <span class="s6">*     }</span>
	 <span class="s6">*</span>
	 <span class="s6">* The second parameter, if given, is a string whose value is the URL</span>
	 <span class="s6">* at which the source map was found.  This URL is used to compute the</span>
	 <span class="s6">* sources array.</span>
	 <span class="s6">*</span>
	 <span class="s6">* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">BasicSourceMapConsumer</span><span class="s0">(</span><span class="s2">aSourceMap</span><span class="s0">, </span><span class="s2">aSourceMapURL</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">sourceMap </span><span class="s0">= </span><span class="s2">aSourceMap</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">aSourceMap </span><span class="s0">=== </span><span class="s3">'string'</span><span class="s0">) {</span>
	    <span class="s2">sourceMap </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">parseSourceMapInput</span><span class="s0">(</span><span class="s2">aSourceMap</span><span class="s0">);</span>
	  <span class="s0">}</span>
	
	  <span class="s1">var </span><span class="s2">version </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">sourceMap</span><span class="s0">, </span><span class="s3">'version'</span><span class="s0">);</span>
	  <span class="s1">var </span><span class="s2">sources </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">sourceMap</span><span class="s0">, </span><span class="s3">'sources'</span><span class="s0">);</span>
	  <span class="s4">// Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which</span>
	  <span class="s4">// requires the array) to play nice here.</span>
	  <span class="s1">var </span><span class="s2">names </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">sourceMap</span><span class="s0">, </span><span class="s3">'names'</span><span class="s0">, []);</span>
	  <span class="s1">var </span><span class="s2">sourceRoot </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">sourceMap</span><span class="s0">, </span><span class="s3">'sourceRoot'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	  <span class="s1">var </span><span class="s2">sourcesContent </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">sourceMap</span><span class="s0">, </span><span class="s3">'sourcesContent'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	  <span class="s1">var </span><span class="s2">mappings </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">sourceMap</span><span class="s0">, </span><span class="s3">'mappings'</span><span class="s0">);</span>
	  <span class="s1">var </span><span class="s2">file </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">sourceMap</span><span class="s0">, </span><span class="s3">'file'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	
	  <span class="s4">// Once again, Sass deviates from the spec and supplies the version as a</span>
	  <span class="s4">// string rather than a number, so we use loose equality checking here.</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">version </span><span class="s0">!= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_version</span><span class="s0">) {</span>
	    <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">'Unsupported version: ' </span><span class="s0">+ </span><span class="s2">version</span><span class="s0">);</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">sourceRoot</span><span class="s0">) {</span>
	    <span class="s2">sourceRoot </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">normalize</span><span class="s0">(</span><span class="s2">sourceRoot</span><span class="s0">);</span>
	  <span class="s0">}</span>
	
	  <span class="s2">sources </span><span class="s0">= </span><span class="s2">sources</span>
	    <span class="s0">.</span><span class="s2">map</span><span class="s0">(</span><span class="s2">String</span><span class="s0">)</span>
	    <span class="s4">// Some source maps produce relative source paths like &quot;./foo.js&quot; instead of</span>
	    <span class="s4">// &quot;foo.js&quot;.  Normalize these first so that future comparisons will succeed.</span>
	    <span class="s4">// See bugzil.la/1090768.</span>
	    <span class="s0">.</span><span class="s2">map</span><span class="s0">(</span><span class="s2">util</span><span class="s0">.</span><span class="s2">normalize</span><span class="s0">)</span>
	    <span class="s4">// Always ensure that absolute sources are internally stored relative to</span>
	    <span class="s4">// the source root, if the source root is absolute. Not doing this would</span>
	    <span class="s4">// be particularly problematic when the source root is a prefix of the</span>
	    <span class="s4">// source (valid, but why??). See github issue #199 and bugzil.la/1188982.</span>
	    <span class="s0">.</span><span class="s2">map</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">source</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s2">sourceRoot </span><span class="s0">&amp;&amp; </span><span class="s2">util</span><span class="s0">.</span><span class="s2">isAbsolute</span><span class="s0">(</span><span class="s2">sourceRoot</span><span class="s0">) &amp;&amp; </span><span class="s2">util</span><span class="s0">.</span><span class="s2">isAbsolute</span><span class="s0">(</span><span class="s2">source</span><span class="s0">)</span>
	        <span class="s0">? </span><span class="s2">util</span><span class="s0">.</span><span class="s2">relative</span><span class="s0">(</span><span class="s2">sourceRoot</span><span class="s0">, </span><span class="s2">source</span><span class="s0">)</span>
	        <span class="s0">: </span><span class="s2">source</span><span class="s0">;</span>
	    <span class="s0">});</span>
	
	  <span class="s4">// Pass `true` below to allow duplicate names and sources. While source maps</span>
	  <span class="s4">// are intended to be compressed and deduplicated, the TypeScript compiler</span>
	  <span class="s4">// sometimes generates source maps with duplicates in them. See Github issue</span>
	  <span class="s4">// #72 and bugzil.la/889492.</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_names </span><span class="s0">= </span><span class="s2">ArraySet</span><span class="s0">.</span><span class="s2">fromArray</span><span class="s0">(</span><span class="s2">names</span><span class="s0">.</span><span class="s2">map</span><span class="s0">(</span><span class="s2">String</span><span class="s0">), </span><span class="s1">true</span><span class="s0">);</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_sources </span><span class="s0">= </span><span class="s2">ArraySet</span><span class="s0">.</span><span class="s2">fromArray</span><span class="s0">(</span><span class="s2">sources</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
	
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_absoluteSources </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">toArray</span><span class="s0">().</span><span class="s2">map</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">s</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">util</span><span class="s0">.</span><span class="s2">computeSourceURL</span><span class="s0">(</span><span class="s2">sourceRoot</span><span class="s0">, </span><span class="s2">s</span><span class="s0">, </span><span class="s2">aSourceMapURL</span><span class="s0">);</span>
	  <span class="s0">});</span>
	
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">sourceRoot </span><span class="s0">= </span><span class="s2">sourceRoot</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">sourcesContent </span><span class="s0">= </span><span class="s2">sourcesContent</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_mappings </span><span class="s0">= </span><span class="s2">mappings</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_sourceMapURL </span><span class="s0">= </span><span class="s2">aSourceMapURL</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">file </span><span class="s0">= </span><span class="s2">file</span><span class="s0">;</span>
	<span class="s0">}</span>
	
	<span class="s2">BasicSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype </span><span class="s0">= </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">create</span><span class="s0">(</span><span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">);</span>
	<span class="s2">BasicSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">consumer </span><span class="s0">= </span><span class="s2">SourceMapConsumer</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Utility function to find the index of a source.  Returns -1 if not</span>
	 <span class="s6">* found.</span>
	 <span class="s6">*/</span>
	<span class="s2">BasicSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">_findSourceIndex </span><span class="s0">= </span><span class="s1">function</span><span class="s0">(</span><span class="s2">aSource</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">relativeSource </span><span class="s0">= </span><span class="s2">aSource</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">sourceRoot </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	    <span class="s2">relativeSource </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">relative</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">sourceRoot</span><span class="s0">, </span><span class="s2">relativeSource</span><span class="s0">);</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">relativeSource</span><span class="s0">)) {</span>
	    <span class="s1">return this</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">indexOf</span><span class="s0">(</span><span class="s2">relativeSource</span><span class="s0">);</span>
	  <span class="s0">}</span>
	
	  <span class="s4">// Maybe aSource is an absolute URL as returned by |sources|.  In</span>
	  <span class="s4">// this case we can't simply undo the transform.</span>
	  <span class="s1">var </span><span class="s2">i</span><span class="s0">;</span>
	  <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_absoluteSources</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; ++</span><span class="s2">i</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_absoluteSources</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] == </span><span class="s2">aSource</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s2">i</span><span class="s0">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">-</span><span class="s5">1</span><span class="s0">;</span>
	<span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Create a BasicSourceMapConsumer from a SourceMapGenerator.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">SourceMapGenerator aSourceMap</span>
	 <span class="s6">*        The source map that will be consumed.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">String aSourceMapURL</span>
	 <span class="s6">*        The URL at which the source map can be found (optional)</span>
	 <span class="s6">* </span><span class="s7">@returns </span><span class="s6">BasicSourceMapConsumer</span>
	 <span class="s6">*/</span>
	<span class="s2">BasicSourceMapConsumer</span><span class="s0">.</span><span class="s2">fromSourceMap </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapConsumer_fromSourceMap</span><span class="s0">(</span><span class="s2">aSourceMap</span><span class="s0">, </span><span class="s2">aSourceMapURL</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">smc </span><span class="s0">= </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">create</span><span class="s0">(</span><span class="s2">BasicSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">);</span>
	
	    <span class="s1">var </span><span class="s2">names </span><span class="s0">= </span><span class="s2">smc</span><span class="s0">.</span><span class="s2">_names </span><span class="s0">= </span><span class="s2">ArraySet</span><span class="s0">.</span><span class="s2">fromArray</span><span class="s0">(</span><span class="s2">aSourceMap</span><span class="s0">.</span><span class="s2">_names</span><span class="s0">.</span><span class="s2">toArray</span><span class="s0">(), </span><span class="s1">true</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s2">sources </span><span class="s0">= </span><span class="s2">smc</span><span class="s0">.</span><span class="s2">_sources </span><span class="s0">= </span><span class="s2">ArraySet</span><span class="s0">.</span><span class="s2">fromArray</span><span class="s0">(</span><span class="s2">aSourceMap</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">toArray</span><span class="s0">(), </span><span class="s1">true</span><span class="s0">);</span>
	    <span class="s2">smc</span><span class="s0">.</span><span class="s2">sourceRoot </span><span class="s0">= </span><span class="s2">aSourceMap</span><span class="s0">.</span><span class="s2">_sourceRoot</span><span class="s0">;</span>
	    <span class="s2">smc</span><span class="s0">.</span><span class="s2">sourcesContent </span><span class="s0">= </span><span class="s2">aSourceMap</span><span class="s0">.</span><span class="s2">_generateSourcesContent</span><span class="s0">(</span><span class="s2">smc</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">toArray</span><span class="s0">(),</span>
	                                                            <span class="s2">smc</span><span class="s0">.</span><span class="s2">sourceRoot</span><span class="s0">);</span>
	    <span class="s2">smc</span><span class="s0">.</span><span class="s2">file </span><span class="s0">= </span><span class="s2">aSourceMap</span><span class="s0">.</span><span class="s2">_file</span><span class="s0">;</span>
	    <span class="s2">smc</span><span class="s0">.</span><span class="s2">_sourceMapURL </span><span class="s0">= </span><span class="s2">aSourceMapURL</span><span class="s0">;</span>
	    <span class="s2">smc</span><span class="s0">.</span><span class="s2">_absoluteSources </span><span class="s0">= </span><span class="s2">smc</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">toArray</span><span class="s0">().</span><span class="s2">map</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">s</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s2">util</span><span class="s0">.</span><span class="s2">computeSourceURL</span><span class="s0">(</span><span class="s2">smc</span><span class="s0">.</span><span class="s2">sourceRoot</span><span class="s0">, </span><span class="s2">s</span><span class="s0">, </span><span class="s2">aSourceMapURL</span><span class="s0">);</span>
	    <span class="s0">});</span>
	
	    <span class="s4">// Because we are modifying the entries (by converting string sources and</span>
	    <span class="s4">// names to indices into the sources and names ArraySets), we have to make</span>
	    <span class="s4">// a copy of the entry or else bad things happen. Shared mutable state</span>
	    <span class="s4">// strikes again! See github issue #191.</span>
	
	    <span class="s1">var </span><span class="s2">generatedMappings </span><span class="s0">= </span><span class="s2">aSourceMap</span><span class="s0">.</span><span class="s2">_mappings</span><span class="s0">.</span><span class="s2">toArray</span><span class="s0">().</span><span class="s2">slice</span><span class="s0">();</span>
	    <span class="s1">var </span><span class="s2">destGeneratedMappings </span><span class="s0">= </span><span class="s2">smc</span><span class="s0">.</span><span class="s2">__generatedMappings </span><span class="s0">= [];</span>
	    <span class="s1">var </span><span class="s2">destOriginalMappings </span><span class="s0">= </span><span class="s2">smc</span><span class="s0">.</span><span class="s2">__originalMappings </span><span class="s0">= [];</span>
	
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">, </span><span class="s2">length </span><span class="s0">= </span><span class="s2">generatedMappings</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">length</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
	      <span class="s1">var </span><span class="s2">srcMapping </span><span class="s0">= </span><span class="s2">generatedMappings</span><span class="s0">[</span><span class="s2">i</span><span class="s0">];</span>
	      <span class="s1">var </span><span class="s2">destMapping </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Mapping</span><span class="s0">;</span>
	      <span class="s2">destMapping</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">= </span><span class="s2">srcMapping</span><span class="s0">.</span><span class="s2">generatedLine</span><span class="s0">;</span>
	      <span class="s2">destMapping</span><span class="s0">.</span><span class="s2">generatedColumn </span><span class="s0">= </span><span class="s2">srcMapping</span><span class="s0">.</span><span class="s2">generatedColumn</span><span class="s0">;</span>
	
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">srcMapping</span><span class="s0">.</span><span class="s2">source</span><span class="s0">) {</span>
	        <span class="s2">destMapping</span><span class="s0">.</span><span class="s2">source </span><span class="s0">= </span><span class="s2">sources</span><span class="s0">.</span><span class="s2">indexOf</span><span class="s0">(</span><span class="s2">srcMapping</span><span class="s0">.</span><span class="s2">source</span><span class="s0">);</span>
	        <span class="s2">destMapping</span><span class="s0">.</span><span class="s2">originalLine </span><span class="s0">= </span><span class="s2">srcMapping</span><span class="s0">.</span><span class="s2">originalLine</span><span class="s0">;</span>
	        <span class="s2">destMapping</span><span class="s0">.</span><span class="s2">originalColumn </span><span class="s0">= </span><span class="s2">srcMapping</span><span class="s0">.</span><span class="s2">originalColumn</span><span class="s0">;</span>
	
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">srcMapping</span><span class="s0">.</span><span class="s2">name</span><span class="s0">) {</span>
	          <span class="s2">destMapping</span><span class="s0">.</span><span class="s2">name </span><span class="s0">= </span><span class="s2">names</span><span class="s0">.</span><span class="s2">indexOf</span><span class="s0">(</span><span class="s2">srcMapping</span><span class="s0">.</span><span class="s2">name</span><span class="s0">);</span>
	        <span class="s0">}</span>
	
	        <span class="s2">destOriginalMappings</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s2">destMapping</span><span class="s0">);</span>
	      <span class="s0">}</span>
	
	      <span class="s2">destGeneratedMappings</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s2">destMapping</span><span class="s0">);</span>
	    <span class="s0">}</span>
	
	    <span class="s2">quickSort</span><span class="s0">(</span><span class="s2">smc</span><span class="s0">.</span><span class="s2">__originalMappings</span><span class="s0">, </span><span class="s2">util</span><span class="s0">.</span><span class="s2">compareByOriginalPositions</span><span class="s0">);</span>
	
	    <span class="s1">return </span><span class="s2">smc</span><span class="s0">;</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* The version of the source mapping spec that we are consuming.</span>
	 <span class="s6">*/</span>
	<span class="s2">BasicSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">_version </span><span class="s0">= </span><span class="s5">3</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* The list of original sources.</span>
	 <span class="s6">*/</span>
	<span class="s2">Object</span><span class="s0">.</span><span class="s2">defineProperty</span><span class="s0">(</span><span class="s2">BasicSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">, </span><span class="s3">'sources'</span><span class="s0">, {</span>
	  <span class="s2">get</span><span class="s0">: </span><span class="s1">function </span><span class="s0">() {</span>
	    <span class="s1">return this</span><span class="s0">.</span><span class="s2">_absoluteSources</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">();</span>
	  <span class="s0">}</span>
	<span class="s0">});</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Provide the JIT with a nice shape / hidden class.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">Mapping</span><span class="s0">() {</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">generatedColumn </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">source </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">originalLine </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">originalColumn </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">name </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
	<span class="s0">}</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Parse the mappings in a string in to a data structure which we can easily</span>
	 <span class="s6">* query (the ordered arrays in the `this.__generatedMappings` and</span>
	 <span class="s6">* `this.__originalMappings` properties).</span>
	 <span class="s6">*/</span>
	<span class="s2">BasicSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">_parseMappings </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapConsumer_parseMappings</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">, </span><span class="s2">aSourceRoot</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">generatedLine </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">previousGeneratedColumn </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">previousOriginalLine </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">previousOriginalColumn </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">previousSource </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">previousName </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">length </span><span class="s0">= </span><span class="s2">aStr</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">index </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">cachedSegments </span><span class="s0">= {};</span>
	    <span class="s1">var </span><span class="s2">temp </span><span class="s0">= {};</span>
	    <span class="s1">var </span><span class="s2">originalMappings </span><span class="s0">= [];</span>
	    <span class="s1">var </span><span class="s2">generatedMappings </span><span class="s0">= [];</span>
	    <span class="s1">var </span><span class="s2">mapping</span><span class="s0">, </span><span class="s2">str</span><span class="s0">, </span><span class="s2">segment</span><span class="s0">, </span><span class="s2">end</span><span class="s0">, </span><span class="s2">value</span><span class="s0">;</span>
	
	    <span class="s1">while </span><span class="s0">(</span><span class="s2">index </span><span class="s0">&lt; </span><span class="s2">length</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">.</span><span class="s2">charAt</span><span class="s0">(</span><span class="s2">index</span><span class="s0">) === </span><span class="s3">';'</span><span class="s0">) {</span>
	        <span class="s2">generatedLine</span><span class="s0">++;</span>
	        <span class="s2">index</span><span class="s0">++;</span>
	        <span class="s2">previousGeneratedColumn </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	      <span class="s0">}</span>
	      <span class="s1">else if </span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">.</span><span class="s2">charAt</span><span class="s0">(</span><span class="s2">index</span><span class="s0">) === </span><span class="s3">','</span><span class="s0">) {</span>
	        <span class="s2">index</span><span class="s0">++;</span>
	      <span class="s0">}</span>
	      <span class="s1">else </span><span class="s0">{</span>
	        <span class="s2">mapping </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Mapping</span><span class="s0">();</span>
	        <span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">= </span><span class="s2">generatedLine</span><span class="s0">;</span>
	
	        <span class="s4">// Because each offset is encoded relative to the previous one,</span>
	        <span class="s4">// many segments often have the same encoding. We can exploit this</span>
	        <span class="s4">// fact by caching the parsed variable length fields of each segment,</span>
	        <span class="s4">// allowing us to avoid a second parse if we encounter the same</span>
	        <span class="s4">// segment again.</span>
	        <span class="s1">for </span><span class="s0">(</span><span class="s2">end </span><span class="s0">= </span><span class="s2">index</span><span class="s0">; </span><span class="s2">end </span><span class="s0">&lt; </span><span class="s2">length</span><span class="s0">; </span><span class="s2">end</span><span class="s0">++) {</span>
	          <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_charIsMappingSeparator</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">, </span><span class="s2">end</span><span class="s0">)) {</span>
	            <span class="s1">break</span><span class="s0">;</span>
	          <span class="s0">}</span>
	        <span class="s0">}</span>
	        <span class="s2">str </span><span class="s0">= </span><span class="s2">aStr</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s2">index</span><span class="s0">, </span><span class="s2">end</span><span class="s0">);</span>
	
	        <span class="s2">segment </span><span class="s0">= </span><span class="s2">cachedSegments</span><span class="s0">[</span><span class="s2">str</span><span class="s0">];</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">segment</span><span class="s0">) {</span>
	          <span class="s2">index </span><span class="s0">+= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
	        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	          <span class="s2">segment </span><span class="s0">= [];</span>
	          <span class="s1">while </span><span class="s0">(</span><span class="s2">index </span><span class="s0">&lt; </span><span class="s2">end</span><span class="s0">) {</span>
	            <span class="s2">base64VLQ</span><span class="s0">.</span><span class="s2">decode</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">, </span><span class="s2">index</span><span class="s0">, </span><span class="s2">temp</span><span class="s0">);</span>
	            <span class="s2">value </span><span class="s0">= </span><span class="s2">temp</span><span class="s0">.</span><span class="s2">value</span><span class="s0">;</span>
	            <span class="s2">index </span><span class="s0">= </span><span class="s2">temp</span><span class="s0">.</span><span class="s2">rest</span><span class="s0">;</span>
	            <span class="s2">segment</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s2">value</span><span class="s0">);</span>
	          <span class="s0">}</span>
	
	          <span class="s1">if </span><span class="s0">(</span><span class="s2">segment</span><span class="s0">.</span><span class="s2">length </span><span class="s0">=== </span><span class="s5">2</span><span class="s0">) {</span>
	            <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">'Found a source, but no line and column'</span><span class="s0">);</span>
	          <span class="s0">}</span>
	
	          <span class="s1">if </span><span class="s0">(</span><span class="s2">segment</span><span class="s0">.</span><span class="s2">length </span><span class="s0">=== </span><span class="s5">3</span><span class="s0">) {</span>
	            <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">'Found a source and line, but no column'</span><span class="s0">);</span>
	          <span class="s0">}</span>
	
	          <span class="s2">cachedSegments</span><span class="s0">[</span><span class="s2">str</span><span class="s0">] = </span><span class="s2">segment</span><span class="s0">;</span>
	        <span class="s0">}</span>
	
	        <span class="s4">// Generated column.</span>
	        <span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedColumn </span><span class="s0">= </span><span class="s2">previousGeneratedColumn </span><span class="s0">+ </span><span class="s2">segment</span><span class="s0">[</span><span class="s5">0</span><span class="s0">];</span>
	        <span class="s2">previousGeneratedColumn </span><span class="s0">= </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedColumn</span><span class="s0">;</span>
	
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">segment</span><span class="s0">.</span><span class="s2">length </span><span class="s0">&gt; </span><span class="s5">1</span><span class="s0">) {</span>
	          <span class="s4">// Original source.</span>
	          <span class="s2">mapping</span><span class="s0">.</span><span class="s2">source </span><span class="s0">= </span><span class="s2">previousSource </span><span class="s0">+ </span><span class="s2">segment</span><span class="s0">[</span><span class="s5">1</span><span class="s0">];</span>
	          <span class="s2">previousSource </span><span class="s0">+= </span><span class="s2">segment</span><span class="s0">[</span><span class="s5">1</span><span class="s0">];</span>
	
	          <span class="s4">// Original line.</span>
	          <span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalLine </span><span class="s0">= </span><span class="s2">previousOriginalLine </span><span class="s0">+ </span><span class="s2">segment</span><span class="s0">[</span><span class="s5">2</span><span class="s0">];</span>
	          <span class="s2">previousOriginalLine </span><span class="s0">= </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalLine</span><span class="s0">;</span>
	          <span class="s4">// Lines are stored 0-based</span>
	          <span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalLine </span><span class="s0">+= </span><span class="s5">1</span><span class="s0">;</span>
	
	          <span class="s4">// Original column.</span>
	          <span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalColumn </span><span class="s0">= </span><span class="s2">previousOriginalColumn </span><span class="s0">+ </span><span class="s2">segment</span><span class="s0">[</span><span class="s5">3</span><span class="s0">];</span>
	          <span class="s2">previousOriginalColumn </span><span class="s0">= </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalColumn</span><span class="s0">;</span>
	
	          <span class="s1">if </span><span class="s0">(</span><span class="s2">segment</span><span class="s0">.</span><span class="s2">length </span><span class="s0">&gt; </span><span class="s5">4</span><span class="s0">) {</span>
	            <span class="s4">// Original name.</span>
	            <span class="s2">mapping</span><span class="s0">.</span><span class="s2">name </span><span class="s0">= </span><span class="s2">previousName </span><span class="s0">+ </span><span class="s2">segment</span><span class="s0">[</span><span class="s5">4</span><span class="s0">];</span>
	            <span class="s2">previousName </span><span class="s0">+= </span><span class="s2">segment</span><span class="s0">[</span><span class="s5">4</span><span class="s0">];</span>
	          <span class="s0">}</span>
	        <span class="s0">}</span>
	
	        <span class="s2">generatedMappings</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">);</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalLine </span><span class="s0">=== </span><span class="s3">'number'</span><span class="s0">) {</span>
	          <span class="s2">originalMappings</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">);</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s2">quickSort</span><span class="s0">(</span><span class="s2">generatedMappings</span><span class="s0">, </span><span class="s2">util</span><span class="s0">.</span><span class="s2">compareByGeneratedPositionsDeflated</span><span class="s0">);</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">__generatedMappings </span><span class="s0">= </span><span class="s2">generatedMappings</span><span class="s0">;</span>
	
	    <span class="s2">quickSort</span><span class="s0">(</span><span class="s2">originalMappings</span><span class="s0">, </span><span class="s2">util</span><span class="s0">.</span><span class="s2">compareByOriginalPositions</span><span class="s0">);</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">__originalMappings </span><span class="s0">= </span><span class="s2">originalMappings</span><span class="s0">;</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Find the mapping that best matches the hypothetical &quot;needle&quot; mapping that</span>
	 <span class="s6">* we are searching for in the given &quot;haystack&quot; of mappings.</span>
	 <span class="s6">*/</span>
	<span class="s2">BasicSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">_findMapping </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapConsumer_findMapping</span><span class="s0">(</span><span class="s2">aNeedle</span><span class="s0">, </span><span class="s2">aMappings</span><span class="s0">, </span><span class="s2">aLineName</span><span class="s0">,</span>
	                                         <span class="s2">aColumnName</span><span class="s0">, </span><span class="s2">aComparator</span><span class="s0">, </span><span class="s2">aBias</span><span class="s0">) {</span>
	    <span class="s4">// To return the position we are searching for, we must first find the</span>
	    <span class="s4">// mapping for the given position and then return the opposite position it</span>
	    <span class="s4">// points to. Because the mappings are sorted, we can use binary search to</span>
	    <span class="s4">// find the best mapping.</span>
	
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">aNeedle</span><span class="s0">[</span><span class="s2">aLineName</span><span class="s0">] &lt;= </span><span class="s5">0</span><span class="s0">) {</span>
	      <span class="s1">throw new </span><span class="s2">TypeError</span><span class="s0">(</span><span class="s3">'Line must be greater than or equal to 1, got '</span>
	                          <span class="s0">+ </span><span class="s2">aNeedle</span><span class="s0">[</span><span class="s2">aLineName</span><span class="s0">]);</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">aNeedle</span><span class="s0">[</span><span class="s2">aColumnName</span><span class="s0">] &lt; </span><span class="s5">0</span><span class="s0">) {</span>
	      <span class="s1">throw new </span><span class="s2">TypeError</span><span class="s0">(</span><span class="s3">'Column must be greater than or equal to 0, got '</span>
	                          <span class="s0">+ </span><span class="s2">aNeedle</span><span class="s0">[</span><span class="s2">aColumnName</span><span class="s0">]);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s2">binarySearch</span><span class="s0">.</span><span class="s2">search</span><span class="s0">(</span><span class="s2">aNeedle</span><span class="s0">, </span><span class="s2">aMappings</span><span class="s0">, </span><span class="s2">aComparator</span><span class="s0">, </span><span class="s2">aBias</span><span class="s0">);</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Compute the last column for each generated mapping. The last column is</span>
	 <span class="s6">* inclusive.</span>
	 <span class="s6">*/</span>
	<span class="s2">BasicSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">computeColumnSpans </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapConsumer_computeColumnSpans</span><span class="s0">() {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">index </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">index </span><span class="s0">&lt; </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_generatedMappings</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; ++</span><span class="s2">index</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">mapping </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_generatedMappings</span><span class="s0">[</span><span class="s2">index</span><span class="s0">];</span>
	
	      <span class="s4">// Mappings do not contain a field for the last generated columnt. We</span>
	      <span class="s4">// can come up with an optimistic estimate, however, by assuming that</span>
	      <span class="s4">// mappings are contiguous (i.e. given two consecutive mappings, the</span>
	      <span class="s4">// first mapping ends where the second one starts).</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">index </span><span class="s0">+ </span><span class="s5">1 </span><span class="s0">&lt; </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_generatedMappings</span><span class="s0">.</span><span class="s2">length</span><span class="s0">) {</span>
	        <span class="s1">var </span><span class="s2">nextMapping </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_generatedMappings</span><span class="s0">[</span><span class="s2">index </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">];</span>
	
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">=== </span><span class="s2">nextMapping</span><span class="s0">.</span><span class="s2">generatedLine</span><span class="s0">) {</span>
	          <span class="s2">mapping</span><span class="s0">.</span><span class="s2">lastGeneratedColumn </span><span class="s0">= </span><span class="s2">nextMapping</span><span class="s0">.</span><span class="s2">generatedColumn </span><span class="s0">- </span><span class="s5">1</span><span class="s0">;</span>
	          <span class="s1">continue</span><span class="s0">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	
	      <span class="s4">// The last mapping for each line spans the entire line.</span>
	      <span class="s2">mapping</span><span class="s0">.</span><span class="s2">lastGeneratedColumn </span><span class="s0">= </span><span class="s2">Infinity</span><span class="s0">;</span>
	    <span class="s0">}</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Returns the original source, line, and column information for the generated</span>
	 <span class="s6">* source's line and column positions provided. The only argument is an object</span>
	 <span class="s6">* with the following properties:</span>
	 <span class="s6">*</span>
	 <span class="s6">*   - line: The line number in the generated source.  The line number</span>
	 <span class="s6">*     is 1-based.</span>
	 <span class="s6">*   - column: The column number in the generated source.  The column</span>
	 <span class="s6">*     number is 0-based.</span>
	 <span class="s6">*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or</span>
	 <span class="s6">*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the</span>
	 <span class="s6">*     closest element that is smaller than or greater than the one we are</span>
	 <span class="s6">*     searching for, respectively, if the exact element cannot be found.</span>
	 <span class="s6">*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.</span>
	 <span class="s6">*</span>
	 <span class="s6">* and an object is returned with the following properties:</span>
	 <span class="s6">*</span>
	 <span class="s6">*   - source: The original source file, or null.</span>
	 <span class="s6">*   - line: The line number in the original source, or null.  The</span>
	 <span class="s6">*     line number is 1-based.</span>
	 <span class="s6">*   - column: The column number in the original source, or null.  The</span>
	 <span class="s6">*     column number is 0-based.</span>
	 <span class="s6">*   - name: The original identifier, or null.</span>
	 <span class="s6">*/</span>
	<span class="s2">BasicSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">originalPositionFor </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapConsumer_originalPositionFor</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">needle </span><span class="s0">= {</span>
	      <span class="s2">generatedLine</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'line'</span><span class="s0">),</span>
	      <span class="s2">generatedColumn</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'column'</span><span class="s0">)</span>
	    <span class="s0">};</span>
	
	    <span class="s1">var </span><span class="s2">index </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_findMapping</span><span class="s0">(</span>
	      <span class="s2">needle</span><span class="s0">,</span>
	      <span class="s1">this</span><span class="s0">.</span><span class="s2">_generatedMappings</span><span class="s0">,</span>
	      <span class="s3">&quot;generatedLine&quot;</span><span class="s0">,</span>
	      <span class="s3">&quot;generatedColumn&quot;</span><span class="s0">,</span>
	      <span class="s2">util</span><span class="s0">.</span><span class="s2">compareByGeneratedPositionsDeflated</span><span class="s0">,</span>
	      <span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'bias'</span><span class="s0">, </span><span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">GREATEST_LOWER_BOUND</span><span class="s0">)</span>
	    <span class="s0">);</span>
	
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">index </span><span class="s0">&gt;= </span><span class="s5">0</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">mapping </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_generatedMappings</span><span class="s0">[</span><span class="s2">index</span><span class="s0">];</span>
	
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">=== </span><span class="s2">needle</span><span class="s0">.</span><span class="s2">generatedLine</span><span class="s0">) {</span>
	        <span class="s1">var </span><span class="s2">source </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">, </span><span class="s3">'source'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">source </span><span class="s0">!== </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s2">source </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">at</span><span class="s0">(</span><span class="s2">source</span><span class="s0">);</span>
	          <span class="s2">source </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">computeSourceURL</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">sourceRoot</span><span class="s0">, </span><span class="s2">source</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sourceMapURL</span><span class="s0">);</span>
	        <span class="s0">}</span>
	        <span class="s1">var </span><span class="s2">name </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">, </span><span class="s3">'name'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">name </span><span class="s0">!== </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s2">name </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_names</span><span class="s0">.</span><span class="s2">at</span><span class="s0">(</span><span class="s2">name</span><span class="s0">);</span>
	        <span class="s0">}</span>
	        <span class="s1">return </span><span class="s0">{</span>
	          <span class="s2">source</span><span class="s0">: </span><span class="s2">source</span><span class="s0">,</span>
	          <span class="s2">line</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">, </span><span class="s3">'originalLine'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">),</span>
	          <span class="s2">column</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">, </span><span class="s3">'originalColumn'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">),</span>
	          <span class="s2">name</span><span class="s0">: </span><span class="s2">name</span>
	        <span class="s0">};</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">{</span>
	      <span class="s2">source</span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
	      <span class="s2">line</span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
	      <span class="s2">column</span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
	      <span class="s2">name</span><span class="s0">: </span><span class="s1">null</span>
	    <span class="s0">};</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Return true if we have the source content for every source in the source</span>
	 <span class="s6">* map, false otherwise.</span>
	 <span class="s6">*/</span>
	<span class="s2">BasicSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">hasContentsOfAllSources </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">BasicSourceMapConsumer_hasContentsOfAllSources</span><span class="s0">() {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">sourcesContent</span><span class="s0">) {</span>
	      <span class="s1">return false</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s1">return this</span><span class="s0">.</span><span class="s2">sourcesContent</span><span class="s0">.</span><span class="s2">length </span><span class="s0">&gt;= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">size</span><span class="s0">() &amp;&amp;</span>
	      <span class="s0">!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">sourcesContent</span><span class="s0">.</span><span class="s2">some</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">sc</span><span class="s0">) { </span><span class="s1">return </span><span class="s2">sc </span><span class="s0">== </span><span class="s1">null</span><span class="s0">; });</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Returns the original source content. The only argument is the url of the</span>
	 <span class="s6">* original source file. Returns null if no original source content is</span>
	 <span class="s6">* available.</span>
	 <span class="s6">*/</span>
	<span class="s2">BasicSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">sourceContentFor </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapConsumer_sourceContentFor</span><span class="s0">(</span><span class="s2">aSource</span><span class="s0">, </span><span class="s2">nullOnMissing</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">sourcesContent</span><span class="s0">) {</span>
	      <span class="s1">return null</span><span class="s0">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">var </span><span class="s2">index </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_findSourceIndex</span><span class="s0">(</span><span class="s2">aSource</span><span class="s0">);</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">index </span><span class="s0">&gt;= </span><span class="s5">0</span><span class="s0">) {</span>
	      <span class="s1">return this</span><span class="s0">.</span><span class="s2">sourcesContent</span><span class="s0">[</span><span class="s2">index</span><span class="s0">];</span>
	    <span class="s0">}</span>
	
	    <span class="s1">var </span><span class="s2">relativeSource </span><span class="s0">= </span><span class="s2">aSource</span><span class="s0">;</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">sourceRoot </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s2">relativeSource </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">relative</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">sourceRoot</span><span class="s0">, </span><span class="s2">relativeSource</span><span class="s0">);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">var </span><span class="s2">url</span><span class="s0">;</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">sourceRoot </span><span class="s0">!= </span><span class="s1">null</span>
	        <span class="s0">&amp;&amp; (</span><span class="s2">url </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">urlParse</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">sourceRoot</span><span class="s0">))) {</span>
	      <span class="s4">// XXX: file:// URIs and absolute paths lead to unexpected behavior for</span>
	      <span class="s4">// many users. We can help them out when they expect file:// URIs to</span>
	      <span class="s4">// behave like it would if they were running a local HTTP server. See</span>
	      <span class="s4">// https://bugzilla.mozilla.org/show_bug.cgi?id=885597.</span>
	      <span class="s1">var </span><span class="s2">fileUriAbsPath </span><span class="s0">= </span><span class="s2">relativeSource</span><span class="s0">.</span><span class="s2">replace</span><span class="s0">(</span><span class="s8">/^file:\/\//</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s0">);</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">url</span><span class="s0">.</span><span class="s2">scheme </span><span class="s0">== </span><span class="s3">&quot;file&quot;</span>
	          <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">fileUriAbsPath</span><span class="s0">)) {</span>
	        <span class="s1">return this</span><span class="s0">.</span><span class="s2">sourcesContent</span><span class="s0">[</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">indexOf</span><span class="s0">(</span><span class="s2">fileUriAbsPath</span><span class="s0">)]</span>
	      <span class="s0">}</span>
	
	      <span class="s1">if </span><span class="s0">((!</span><span class="s2">url</span><span class="s0">.</span><span class="s2">path </span><span class="s0">|| </span><span class="s2">url</span><span class="s0">.</span><span class="s2">path </span><span class="s0">== </span><span class="s3">&quot;/&quot;</span><span class="s0">)</span>
	          <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s3">&quot;/&quot; </span><span class="s0">+ </span><span class="s2">relativeSource</span><span class="s0">)) {</span>
	        <span class="s1">return this</span><span class="s0">.</span><span class="s2">sourcesContent</span><span class="s0">[</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">indexOf</span><span class="s0">(</span><span class="s3">&quot;/&quot; </span><span class="s0">+ </span><span class="s2">relativeSource</span><span class="s0">)];</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s4">// This function is used recursively from</span>
	    <span class="s4">// IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we</span>
	    <span class="s4">// don't want to throw if we can't find the source - we just want to</span>
	    <span class="s4">// return null, so we provide a flag to exit gracefully.</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">nullOnMissing</span><span class="s0">) {</span>
	      <span class="s1">return null</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">'&quot;' </span><span class="s0">+ </span><span class="s2">relativeSource </span><span class="s0">+ </span><span class="s3">'&quot; is not in the SourceMap.'</span><span class="s0">);</span>
	    <span class="s0">}</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Returns the generated line and column information for the original source,</span>
	 <span class="s6">* line, and column positions provided. The only argument is an object with</span>
	 <span class="s6">* the following properties:</span>
	 <span class="s6">*</span>
	 <span class="s6">*   - source: The filename of the original source.</span>
	 <span class="s6">*   - line: The line number in the original source.  The line number</span>
	 <span class="s6">*     is 1-based.</span>
	 <span class="s6">*   - column: The column number in the original source.  The column</span>
	 <span class="s6">*     number is 0-based.</span>
	 <span class="s6">*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or</span>
	 <span class="s6">*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the</span>
	 <span class="s6">*     closest element that is smaller than or greater than the one we are</span>
	 <span class="s6">*     searching for, respectively, if the exact element cannot be found.</span>
	 <span class="s6">*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.</span>
	 <span class="s6">*</span>
	 <span class="s6">* and an object is returned with the following properties:</span>
	 <span class="s6">*</span>
	 <span class="s6">*   - line: The line number in the generated source, or null.  The</span>
	 <span class="s6">*     line number is 1-based.</span>
	 <span class="s6">*   - column: The column number in the generated source, or null.</span>
	 <span class="s6">*     The column number is 0-based.</span>
	 <span class="s6">*/</span>
	<span class="s2">BasicSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">generatedPositionFor </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceMapConsumer_generatedPositionFor</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">source </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'source'</span><span class="s0">);</span>
	    <span class="s2">source </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_findSourceIndex</span><span class="s0">(</span><span class="s2">source</span><span class="s0">);</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">source </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s0">{</span>
	        <span class="s2">line</span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
	        <span class="s2">column</span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
	        <span class="s2">lastColumn</span><span class="s0">: </span><span class="s1">null</span>
	      <span class="s0">};</span>
	    <span class="s0">}</span>
	
	    <span class="s1">var </span><span class="s2">needle </span><span class="s0">= {</span>
	      <span class="s2">source</span><span class="s0">: </span><span class="s2">source</span><span class="s0">,</span>
	      <span class="s2">originalLine</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'line'</span><span class="s0">),</span>
	      <span class="s2">originalColumn</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'column'</span><span class="s0">)</span>
	    <span class="s0">};</span>
	
	    <span class="s1">var </span><span class="s2">index </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_findMapping</span><span class="s0">(</span>
	      <span class="s2">needle</span><span class="s0">,</span>
	      <span class="s1">this</span><span class="s0">.</span><span class="s2">_originalMappings</span><span class="s0">,</span>
	      <span class="s3">&quot;originalLine&quot;</span><span class="s0">,</span>
	      <span class="s3">&quot;originalColumn&quot;</span><span class="s0">,</span>
	      <span class="s2">util</span><span class="s0">.</span><span class="s2">compareByOriginalPositions</span><span class="s0">,</span>
	      <span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'bias'</span><span class="s0">, </span><span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">GREATEST_LOWER_BOUND</span><span class="s0">)</span>
	    <span class="s0">);</span>
	
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">index </span><span class="s0">&gt;= </span><span class="s5">0</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">mapping </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_originalMappings</span><span class="s0">[</span><span class="s2">index</span><span class="s0">];</span>
	
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">source </span><span class="s0">=== </span><span class="s2">needle</span><span class="s0">.</span><span class="s2">source</span><span class="s0">) {</span>
	        <span class="s1">return </span><span class="s0">{</span>
	          <span class="s2">line</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">, </span><span class="s3">'generatedLine'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">),</span>
	          <span class="s2">column</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">, </span><span class="s3">'generatedColumn'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">),</span>
	          <span class="s2">lastColumn</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">, </span><span class="s3">'lastGeneratedColumn'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">)</span>
	        <span class="s0">};</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">{</span>
	      <span class="s2">line</span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
	      <span class="s2">column</span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
	      <span class="s2">lastColumn</span><span class="s0">: </span><span class="s1">null</span>
	    <span class="s0">};</span>
	  <span class="s0">};</span>
	
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">BasicSourceMapConsumer </span><span class="s0">= </span><span class="s2">BasicSourceMapConsumer</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* An IndexedSourceMapConsumer instance represents a parsed source map which</span>
	 <span class="s6">* we can query for information. It differs from BasicSourceMapConsumer in</span>
	 <span class="s6">* that it takes &quot;indexed&quot; source maps (i.e. ones with a &quot;sections&quot; field) as</span>
	 <span class="s6">* input.</span>
	 <span class="s6">*</span>
	 <span class="s6">* The first parameter is a raw source map (either as a JSON string, or already</span>
	 <span class="s6">* parsed to an object). According to the spec for indexed source maps, they</span>
	 <span class="s6">* have the following attributes:</span>
	 <span class="s6">*</span>
	 <span class="s6">*   - version: Which version of the source map spec this map is following.</span>
	 <span class="s6">*   - file: Optional. The generated file this source map is associated with.</span>
	 <span class="s6">*   - sections: A list of section definitions.</span>
	 <span class="s6">*</span>
	 <span class="s6">* Each value under the &quot;sections&quot; field has two fields:</span>
	 <span class="s6">*   - offset: The offset into the original specified at which this section</span>
	 <span class="s6">*       begins to apply, defined as an object with a &quot;line&quot; and &quot;column&quot;</span>
	 <span class="s6">*       field.</span>
	 <span class="s6">*   - map: A source map definition. This source map could also be indexed,</span>
	 <span class="s6">*       but doesn't have to be.</span>
	 <span class="s6">*</span>
	 <span class="s6">* Instead of the &quot;map&quot; field, it's also possible to have a &quot;url&quot; field</span>
	 <span class="s6">* specifying a URL to retrieve a source map from, but that's currently</span>
	 <span class="s6">* unsupported.</span>
	 <span class="s6">*</span>
	 <span class="s6">* Here's an example source map, taken from the source map spec[0], but</span>
	 <span class="s6">* modified to omit a section which uses the &quot;url&quot; field.</span>
	 <span class="s6">*</span>
	 <span class="s6">*  {</span>
	 <span class="s6">*    version : 3,</span>
	 <span class="s6">*    file: &quot;app.js&quot;,</span>
	 <span class="s6">*    sections: [{</span>
	 <span class="s6">*      offset: {line:100, column:10},</span>
	 <span class="s6">*      map: {</span>
	 <span class="s6">*        version : 3,</span>
	 <span class="s6">*        file: &quot;section.js&quot;,</span>
	 <span class="s6">*        sources: [&quot;foo.js&quot;, &quot;bar.js&quot;],</span>
	 <span class="s6">*        names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;],</span>
	 <span class="s6">*        mappings: &quot;AAAA,E;;ABCDE;&quot;</span>
	 <span class="s6">*      }</span>
	 <span class="s6">*    }],</span>
	 <span class="s6">*  }</span>
	 <span class="s6">*</span>
	 <span class="s6">* The second parameter, if given, is a string whose value is the URL</span>
	 <span class="s6">* at which the source map was found.  This URL is used to compute the</span>
	 <span class="s6">* sources array.</span>
	 <span class="s6">*</span>
	 <span class="s6">* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">IndexedSourceMapConsumer</span><span class="s0">(</span><span class="s2">aSourceMap</span><span class="s0">, </span><span class="s2">aSourceMapURL</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">sourceMap </span><span class="s0">= </span><span class="s2">aSourceMap</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">aSourceMap </span><span class="s0">=== </span><span class="s3">'string'</span><span class="s0">) {</span>
	    <span class="s2">sourceMap </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">parseSourceMapInput</span><span class="s0">(</span><span class="s2">aSourceMap</span><span class="s0">);</span>
	  <span class="s0">}</span>
	
	  <span class="s1">var </span><span class="s2">version </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">sourceMap</span><span class="s0">, </span><span class="s3">'version'</span><span class="s0">);</span>
	  <span class="s1">var </span><span class="s2">sections </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">sourceMap</span><span class="s0">, </span><span class="s3">'sections'</span><span class="s0">);</span>
	
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">version </span><span class="s0">!= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_version</span><span class="s0">) {</span>
	    <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">'Unsupported version: ' </span><span class="s0">+ </span><span class="s2">version</span><span class="s0">);</span>
	  <span class="s0">}</span>
	
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_sources </span><span class="s0">= </span><span class="s1">new </span><span class="s2">ArraySet</span><span class="s0">();</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_names </span><span class="s0">= </span><span class="s1">new </span><span class="s2">ArraySet</span><span class="s0">();</span>
	
	  <span class="s1">var </span><span class="s2">lastOffset </span><span class="s0">= {</span>
	    <span class="s2">line</span><span class="s0">: -</span><span class="s5">1</span><span class="s0">,</span>
	    <span class="s2">column</span><span class="s0">: </span><span class="s5">0</span>
	  <span class="s0">};</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">_sections </span><span class="s0">= </span><span class="s2">sections</span><span class="s0">.</span><span class="s2">map</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">s</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">s</span><span class="s0">.</span><span class="s2">url</span><span class="s0">) {</span>
	      <span class="s4">// The url field will require support for asynchronicity.</span>
	      <span class="s4">// See https://github.com/mozilla/source-map/issues/16</span>
	      <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">'Support for url field in sections not implemented.'</span><span class="s0">);</span>
	    <span class="s0">}</span>
	    <span class="s1">var </span><span class="s2">offset </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">s</span><span class="s0">, </span><span class="s3">'offset'</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s2">offsetLine </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">offset</span><span class="s0">, </span><span class="s3">'line'</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s2">offsetColumn </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">offset</span><span class="s0">, </span><span class="s3">'column'</span><span class="s0">);</span>
	
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">offsetLine </span><span class="s0">&lt; </span><span class="s2">lastOffset</span><span class="s0">.</span><span class="s2">line </span><span class="s0">||</span>
	        <span class="s0">(</span><span class="s2">offsetLine </span><span class="s0">=== </span><span class="s2">lastOffset</span><span class="s0">.</span><span class="s2">line </span><span class="s0">&amp;&amp; </span><span class="s2">offsetColumn </span><span class="s0">&lt; </span><span class="s2">lastOffset</span><span class="s0">.</span><span class="s2">column</span><span class="s0">)) {</span>
	      <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">'Section offsets must be ordered and non-overlapping.'</span><span class="s0">);</span>
	    <span class="s0">}</span>
	    <span class="s2">lastOffset </span><span class="s0">= </span><span class="s2">offset</span><span class="s0">;</span>
	
	    <span class="s1">return </span><span class="s0">{</span>
	      <span class="s2">generatedOffset</span><span class="s0">: {</span>
	        <span class="s4">// The offset fields are 0-based, but we use 1-based indices when</span>
	        <span class="s4">// encoding/decoding from VLQ.</span>
	        <span class="s2">generatedLine</span><span class="s0">: </span><span class="s2">offsetLine </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">,</span>
	        <span class="s2">generatedColumn</span><span class="s0">: </span><span class="s2">offsetColumn </span><span class="s0">+ </span><span class="s5">1</span>
	      <span class="s0">},</span>
	      <span class="s2">consumer</span><span class="s0">: </span><span class="s1">new </span><span class="s2">SourceMapConsumer</span><span class="s0">(</span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">s</span><span class="s0">, </span><span class="s3">'map'</span><span class="s0">), </span><span class="s2">aSourceMapURL</span><span class="s0">)</span>
	    <span class="s0">}</span>
	  <span class="s0">});</span>
	<span class="s0">}</span>
	
	<span class="s2">IndexedSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype </span><span class="s0">= </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">create</span><span class="s0">(</span><span class="s2">SourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">);</span>
	<span class="s2">IndexedSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">constructor </span><span class="s0">= </span><span class="s2">SourceMapConsumer</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* The version of the source mapping spec that we are consuming.</span>
	 <span class="s6">*/</span>
	<span class="s2">IndexedSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">_version </span><span class="s0">= </span><span class="s5">3</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* The list of original sources.</span>
	 <span class="s6">*/</span>
	<span class="s2">Object</span><span class="s0">.</span><span class="s2">defineProperty</span><span class="s0">(</span><span class="s2">IndexedSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">, </span><span class="s3">'sources'</span><span class="s0">, {</span>
	  <span class="s2">get</span><span class="s0">: </span><span class="s1">function </span><span class="s0">() {</span>
	    <span class="s1">var </span><span class="s2">sources </span><span class="s0">= [];</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sections</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
	      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">j </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">j </span><span class="s0">&lt; </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sections</span><span class="s0">[</span><span class="s2">i</span><span class="s0">].</span><span class="s2">consumer</span><span class="s0">.</span><span class="s2">sources</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">j</span><span class="s0">++) {</span>
	        <span class="s2">sources</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sections</span><span class="s0">[</span><span class="s2">i</span><span class="s0">].</span><span class="s2">consumer</span><span class="s0">.</span><span class="s2">sources</span><span class="s0">[</span><span class="s2">j</span><span class="s0">]);</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	    <span class="s1">return </span><span class="s2">sources</span><span class="s0">;</span>
	  <span class="s0">}</span>
	<span class="s0">});</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Returns the original source, line, and column information for the generated</span>
	 <span class="s6">* source's line and column positions provided. The only argument is an object</span>
	 <span class="s6">* with the following properties:</span>
	 <span class="s6">*</span>
	 <span class="s6">*   - line: The line number in the generated source.  The line number</span>
	 <span class="s6">*     is 1-based.</span>
	 <span class="s6">*   - column: The column number in the generated source.  The column</span>
	 <span class="s6">*     number is 0-based.</span>
	 <span class="s6">*</span>
	 <span class="s6">* and an object is returned with the following properties:</span>
	 <span class="s6">*</span>
	 <span class="s6">*   - source: The original source file, or null.</span>
	 <span class="s6">*   - line: The line number in the original source, or null.  The</span>
	 <span class="s6">*     line number is 1-based.</span>
	 <span class="s6">*   - column: The column number in the original source, or null.  The</span>
	 <span class="s6">*     column number is 0-based.</span>
	 <span class="s6">*   - name: The original identifier, or null.</span>
	 <span class="s6">*/</span>
	<span class="s2">IndexedSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">originalPositionFor </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">IndexedSourceMapConsumer_originalPositionFor</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">needle </span><span class="s0">= {</span>
	      <span class="s2">generatedLine</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'line'</span><span class="s0">),</span>
	      <span class="s2">generatedColumn</span><span class="s0">: </span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'column'</span><span class="s0">)</span>
	    <span class="s0">};</span>
	
	    <span class="s4">// Find the section containing the generated position we're trying to map</span>
	    <span class="s4">// to an original position.</span>
	    <span class="s1">var </span><span class="s2">sectionIndex </span><span class="s0">= </span><span class="s2">binarySearch</span><span class="s0">.</span><span class="s2">search</span><span class="s0">(</span><span class="s2">needle</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sections</span><span class="s0">,</span>
	      <span class="s1">function</span><span class="s0">(</span><span class="s2">needle</span><span class="s0">, </span><span class="s2">section</span><span class="s0">) {</span>
	        <span class="s1">var </span><span class="s2">cmp </span><span class="s0">= </span><span class="s2">needle</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">- </span><span class="s2">section</span><span class="s0">.</span><span class="s2">generatedOffset</span><span class="s0">.</span><span class="s2">generatedLine</span><span class="s0">;</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp</span><span class="s0">) {</span>
	          <span class="s1">return </span><span class="s2">cmp</span><span class="s0">;</span>
	        <span class="s0">}</span>
	
	        <span class="s1">return </span><span class="s0">(</span><span class="s2">needle</span><span class="s0">.</span><span class="s2">generatedColumn </span><span class="s0">-</span>
	                <span class="s2">section</span><span class="s0">.</span><span class="s2">generatedOffset</span><span class="s0">.</span><span class="s2">generatedColumn</span><span class="s0">);</span>
	      <span class="s0">});</span>
	    <span class="s1">var </span><span class="s2">section </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sections</span><span class="s0">[</span><span class="s2">sectionIndex</span><span class="s0">];</span>
	
	    <span class="s1">if </span><span class="s0">(!</span><span class="s2">section</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s0">{</span>
	        <span class="s2">source</span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
	        <span class="s2">line</span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
	        <span class="s2">column</span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
	        <span class="s2">name</span><span class="s0">: </span><span class="s1">null</span>
	      <span class="s0">};</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s2">section</span><span class="s0">.</span><span class="s2">consumer</span><span class="s0">.</span><span class="s2">originalPositionFor</span><span class="s0">({</span>
	      <span class="s2">line</span><span class="s0">: </span><span class="s2">needle</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">-</span>
	        <span class="s0">(</span><span class="s2">section</span><span class="s0">.</span><span class="s2">generatedOffset</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">- </span><span class="s5">1</span><span class="s0">),</span>
	      <span class="s2">column</span><span class="s0">: </span><span class="s2">needle</span><span class="s0">.</span><span class="s2">generatedColumn </span><span class="s0">-</span>
	        <span class="s0">(</span><span class="s2">section</span><span class="s0">.</span><span class="s2">generatedOffset</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">=== </span><span class="s2">needle</span><span class="s0">.</span><span class="s2">generatedLine</span>
	         <span class="s0">? </span><span class="s2">section</span><span class="s0">.</span><span class="s2">generatedOffset</span><span class="s0">.</span><span class="s2">generatedColumn </span><span class="s0">- </span><span class="s5">1</span>
	         <span class="s0">: </span><span class="s5">0</span><span class="s0">),</span>
	      <span class="s2">bias</span><span class="s0">: </span><span class="s2">aArgs</span><span class="s0">.</span><span class="s2">bias</span>
	    <span class="s0">});</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Return true if we have the source content for every source in the source</span>
	 <span class="s6">* map, false otherwise.</span>
	 <span class="s6">*/</span>
	<span class="s2">IndexedSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">hasContentsOfAllSources </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">IndexedSourceMapConsumer_hasContentsOfAllSources</span><span class="s0">() {</span>
	    <span class="s1">return this</span><span class="s0">.</span><span class="s2">_sections</span><span class="s0">.</span><span class="s2">every</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">s</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s2">s</span><span class="s0">.</span><span class="s2">consumer</span><span class="s0">.</span><span class="s2">hasContentsOfAllSources</span><span class="s0">();</span>
	    <span class="s0">});</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Returns the original source content. The only argument is the url of the</span>
	 <span class="s6">* original source file. Returns null if no original source content is</span>
	 <span class="s6">* available.</span>
	 <span class="s6">*/</span>
	<span class="s2">IndexedSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">sourceContentFor </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">IndexedSourceMapConsumer_sourceContentFor</span><span class="s0">(</span><span class="s2">aSource</span><span class="s0">, </span><span class="s2">nullOnMissing</span><span class="s0">) {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sections</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
	      <span class="s1">var </span><span class="s2">section </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sections</span><span class="s0">[</span><span class="s2">i</span><span class="s0">];</span>
	
	      <span class="s1">var </span><span class="s2">content </span><span class="s0">= </span><span class="s2">section</span><span class="s0">.</span><span class="s2">consumer</span><span class="s0">.</span><span class="s2">sourceContentFor</span><span class="s0">(</span><span class="s2">aSource</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">content</span><span class="s0">) {</span>
	        <span class="s1">return </span><span class="s2">content</span><span class="s0">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">nullOnMissing</span><span class="s0">) {</span>
	      <span class="s1">return null</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">'&quot;' </span><span class="s0">+ </span><span class="s2">aSource </span><span class="s0">+ </span><span class="s3">'&quot; is not in the SourceMap.'</span><span class="s0">);</span>
	    <span class="s0">}</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Returns the generated line and column information for the original source,</span>
	 <span class="s6">* line, and column positions provided. The only argument is an object with</span>
	 <span class="s6">* the following properties:</span>
	 <span class="s6">*</span>
	 <span class="s6">*   - source: The filename of the original source.</span>
	 <span class="s6">*   - line: The line number in the original source.  The line number</span>
	 <span class="s6">*     is 1-based.</span>
	 <span class="s6">*   - column: The column number in the original source.  The column</span>
	 <span class="s6">*     number is 0-based.</span>
	 <span class="s6">*</span>
	 <span class="s6">* and an object is returned with the following properties:</span>
	 <span class="s6">*</span>
	 <span class="s6">*   - line: The line number in the generated source, or null.  The</span>
	 <span class="s6">*     line number is 1-based. </span>
	 <span class="s6">*   - column: The column number in the generated source, or null.</span>
	 <span class="s6">*     The column number is 0-based.</span>
	 <span class="s6">*/</span>
	<span class="s2">IndexedSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">generatedPositionFor </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">IndexedSourceMapConsumer_generatedPositionFor</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">) {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sections</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
	      <span class="s1">var </span><span class="s2">section </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sections</span><span class="s0">[</span><span class="s2">i</span><span class="s0">];</span>
	
	      <span class="s4">// Only consider this section if the requested source is in the list of</span>
	      <span class="s4">// sources of the consumer.</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">section</span><span class="s0">.</span><span class="s2">consumer</span><span class="s0">.</span><span class="s2">_findSourceIndex</span><span class="s0">(</span><span class="s2">util</span><span class="s0">.</span><span class="s2">getArg</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">, </span><span class="s3">'source'</span><span class="s0">)) === -</span><span class="s5">1</span><span class="s0">) {</span>
	        <span class="s1">continue</span><span class="s0">;</span>
	      <span class="s0">}</span>
	      <span class="s1">var </span><span class="s2">generatedPosition </span><span class="s0">= </span><span class="s2">section</span><span class="s0">.</span><span class="s2">consumer</span><span class="s0">.</span><span class="s2">generatedPositionFor</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">);</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">generatedPosition</span><span class="s0">) {</span>
	        <span class="s1">var </span><span class="s2">ret </span><span class="s0">= {</span>
	          <span class="s2">line</span><span class="s0">: </span><span class="s2">generatedPosition</span><span class="s0">.</span><span class="s2">line </span><span class="s0">+</span>
	            <span class="s0">(</span><span class="s2">section</span><span class="s0">.</span><span class="s2">generatedOffset</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">- </span><span class="s5">1</span><span class="s0">),</span>
	          <span class="s2">column</span><span class="s0">: </span><span class="s2">generatedPosition</span><span class="s0">.</span><span class="s2">column </span><span class="s0">+</span>
	            <span class="s0">(</span><span class="s2">section</span><span class="s0">.</span><span class="s2">generatedOffset</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">=== </span><span class="s2">generatedPosition</span><span class="s0">.</span><span class="s2">line</span>
	             <span class="s0">? </span><span class="s2">section</span><span class="s0">.</span><span class="s2">generatedOffset</span><span class="s0">.</span><span class="s2">generatedColumn </span><span class="s0">- </span><span class="s5">1</span>
	             <span class="s0">: </span><span class="s5">0</span><span class="s0">)</span>
	        <span class="s0">};</span>
	        <span class="s1">return </span><span class="s2">ret</span><span class="s0">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">{</span>
	      <span class="s2">line</span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
	      <span class="s2">column</span><span class="s0">: </span><span class="s1">null</span>
	    <span class="s0">};</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Parse the mappings in a string in to a data structure which we can easily</span>
	 <span class="s6">* query (the ordered arrays in the `this.__generatedMappings` and</span>
	 <span class="s6">* `this.__originalMappings` properties).</span>
	 <span class="s6">*/</span>
	<span class="s2">IndexedSourceMapConsumer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">_parseMappings </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">IndexedSourceMapConsumer_parseMappings</span><span class="s0">(</span><span class="s2">aStr</span><span class="s0">, </span><span class="s2">aSourceRoot</span><span class="s0">) {</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">__generatedMappings </span><span class="s0">= [];</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">__originalMappings </span><span class="s0">= [];</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sections</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
	      <span class="s1">var </span><span class="s2">section </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sections</span><span class="s0">[</span><span class="s2">i</span><span class="s0">];</span>
	      <span class="s1">var </span><span class="s2">sectionMappings </span><span class="s0">= </span><span class="s2">section</span><span class="s0">.</span><span class="s2">consumer</span><span class="s0">.</span><span class="s2">_generatedMappings</span><span class="s0">;</span>
	      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">j </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">j </span><span class="s0">&lt; </span><span class="s2">sectionMappings</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">j</span><span class="s0">++) {</span>
	        <span class="s1">var </span><span class="s2">mapping </span><span class="s0">= </span><span class="s2">sectionMappings</span><span class="s0">[</span><span class="s2">j</span><span class="s0">];</span>
	
	        <span class="s1">var </span><span class="s2">source </span><span class="s0">= </span><span class="s2">section</span><span class="s0">.</span><span class="s2">consumer</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">at</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">source</span><span class="s0">);</span>
	        <span class="s2">source </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">computeSourceURL</span><span class="s0">(</span><span class="s2">section</span><span class="s0">.</span><span class="s2">consumer</span><span class="s0">.</span><span class="s2">sourceRoot</span><span class="s0">, </span><span class="s2">source</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sourceMapURL</span><span class="s0">);</span>
	        <span class="s1">this</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">source</span><span class="s0">);</span>
	        <span class="s2">source </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_sources</span><span class="s0">.</span><span class="s2">indexOf</span><span class="s0">(</span><span class="s2">source</span><span class="s0">);</span>
	
	        <span class="s1">var </span><span class="s2">name </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">name</span><span class="s0">) {</span>
	          <span class="s2">name </span><span class="s0">= </span><span class="s2">section</span><span class="s0">.</span><span class="s2">consumer</span><span class="s0">.</span><span class="s2">_names</span><span class="s0">.</span><span class="s2">at</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">name</span><span class="s0">);</span>
	          <span class="s1">this</span><span class="s0">.</span><span class="s2">_names</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">name</span><span class="s0">);</span>
	          <span class="s2">name </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">_names</span><span class="s0">.</span><span class="s2">indexOf</span><span class="s0">(</span><span class="s2">name</span><span class="s0">);</span>
	        <span class="s0">}</span>
	
	        <span class="s4">// The mappings coming from the consumer for the section have</span>
	        <span class="s4">// generated positions relative to the start of the section, so we</span>
	        <span class="s4">// need to offset them to be relative to the start of the concatenated</span>
	        <span class="s4">// generated file.</span>
	        <span class="s1">var </span><span class="s2">adjustedMapping </span><span class="s0">= {</span>
	          <span class="s2">source</span><span class="s0">: </span><span class="s2">source</span><span class="s0">,</span>
	          <span class="s2">generatedLine</span><span class="s0">: </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">+</span>
	            <span class="s0">(</span><span class="s2">section</span><span class="s0">.</span><span class="s2">generatedOffset</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">- </span><span class="s5">1</span><span class="s0">),</span>
	          <span class="s2">generatedColumn</span><span class="s0">: </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedColumn </span><span class="s0">+</span>
	            <span class="s0">(</span><span class="s2">section</span><span class="s0">.</span><span class="s2">generatedOffset</span><span class="s0">.</span><span class="s2">generatedLine </span><span class="s0">=== </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedLine</span>
	            <span class="s0">? </span><span class="s2">section</span><span class="s0">.</span><span class="s2">generatedOffset</span><span class="s0">.</span><span class="s2">generatedColumn </span><span class="s0">- </span><span class="s5">1</span>
	            <span class="s0">: </span><span class="s5">0</span><span class="s0">),</span>
	          <span class="s2">originalLine</span><span class="s0">: </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalLine</span><span class="s0">,</span>
	          <span class="s2">originalColumn</span><span class="s0">: </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalColumn</span><span class="s0">,</span>
	          <span class="s2">name</span><span class="s0">: </span><span class="s2">name</span>
	        <span class="s0">};</span>
	
	        <span class="s1">this</span><span class="s0">.</span><span class="s2">__generatedMappings</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s2">adjustedMapping</span><span class="s0">);</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">adjustedMapping</span><span class="s0">.</span><span class="s2">originalLine </span><span class="s0">=== </span><span class="s3">'number'</span><span class="s0">) {</span>
	          <span class="s1">this</span><span class="s0">.</span><span class="s2">__originalMappings</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s2">adjustedMapping</span><span class="s0">);</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s2">quickSort</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">__generatedMappings</span><span class="s0">, </span><span class="s2">util</span><span class="s0">.</span><span class="s2">compareByGeneratedPositionsDeflated</span><span class="s0">);</span>
	    <span class="s2">quickSort</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">__originalMappings</span><span class="s0">, </span><span class="s2">util</span><span class="s0">.</span><span class="s2">compareByOriginalPositions</span><span class="s0">);</span>
	  <span class="s0">};</span>
	
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">IndexedSourceMapConsumer </span><span class="s0">= </span><span class="s2">IndexedSourceMapConsumer</span><span class="s0">;</span>


<span class="s4">/***/ </span><span class="s0">}),</span>
<span class="s4">/* 8 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(</span><span class="s2">module</span><span class="s0">, </span><span class="s2">exports</span><span class="s0">) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">GREATEST_LOWER_BOUND </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">LEAST_UPPER_BOUND </span><span class="s0">= </span><span class="s5">2</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Recursive implementation of binary search.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aLow Indices here and lower do not contain the needle.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aHigh Indices here and higher do not contain the needle.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aNeedle The element being searched for.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aHaystack The non-empty array being searched.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aCompare Function which takes two elements and returns -1, 0, or 1.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or</span>
	 <span class="s6">*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the</span>
	 <span class="s6">*     closest element that is smaller than or greater than the one we are</span>
	 <span class="s6">*     searching for, respectively, if the exact element cannot be found.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">recursiveSearch</span><span class="s0">(</span><span class="s2">aLow</span><span class="s0">, </span><span class="s2">aHigh</span><span class="s0">, </span><span class="s2">aNeedle</span><span class="s0">, </span><span class="s2">aHaystack</span><span class="s0">, </span><span class="s2">aCompare</span><span class="s0">, </span><span class="s2">aBias</span><span class="s0">) {</span>
	  <span class="s4">// This function terminates when one of the following is true:</span>
	  <span class="s4">//</span>
	  <span class="s4">//   1. We find the exact element we are looking for.</span>
	  <span class="s4">//</span>
	  <span class="s4">//   2. We did not find the exact element, but we can return the index of</span>
	  <span class="s4">//      the next-closest element.</span>
	  <span class="s4">//</span>
	  <span class="s4">//   3. We did not find the exact element, and there is no next-closest</span>
	  <span class="s4">//      element than the one we are searching for, so we return -1.</span>
	  <span class="s1">var </span><span class="s2">mid </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">floor</span><span class="s0">((</span><span class="s2">aHigh </span><span class="s0">- </span><span class="s2">aLow</span><span class="s0">) / </span><span class="s5">2</span><span class="s0">) + </span><span class="s2">aLow</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">cmp </span><span class="s0">= </span><span class="s2">aCompare</span><span class="s0">(</span><span class="s2">aNeedle</span><span class="s0">, </span><span class="s2">aHaystack</span><span class="s0">[</span><span class="s2">mid</span><span class="s0">], </span><span class="s1">true</span><span class="s0">);</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">=== </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s4">// Found the element we are looking for.</span>
	    <span class="s1">return </span><span class="s2">mid</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s1">else if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">&gt; </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s4">// Our needle is greater than aHaystack[mid].</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">aHigh </span><span class="s0">- </span><span class="s2">mid </span><span class="s0">&gt; </span><span class="s5">1</span><span class="s0">) {</span>
	      <span class="s4">// The element is in the upper half.</span>
	      <span class="s1">return </span><span class="s2">recursiveSearch</span><span class="s0">(</span><span class="s2">mid</span><span class="s0">, </span><span class="s2">aHigh</span><span class="s0">, </span><span class="s2">aNeedle</span><span class="s0">, </span><span class="s2">aHaystack</span><span class="s0">, </span><span class="s2">aCompare</span><span class="s0">, </span><span class="s2">aBias</span><span class="s0">);</span>
	    <span class="s0">}</span>
	
	    <span class="s4">// The exact needle element was not found in this haystack. Determine if</span>
	    <span class="s4">// we are in termination case (3) or (2) and return the appropriate thing.</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">aBias </span><span class="s0">== </span><span class="s2">exports</span><span class="s0">.</span><span class="s2">LEAST_UPPER_BOUND</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s2">aHigh </span><span class="s0">&lt; </span><span class="s2">aHaystack</span><span class="s0">.</span><span class="s2">length </span><span class="s0">? </span><span class="s2">aHigh </span><span class="s0">: -</span><span class="s5">1</span><span class="s0">;</span>
	    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">return </span><span class="s2">mid</span><span class="s0">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	  <span class="s1">else </span><span class="s0">{</span>
	    <span class="s4">// Our needle is less than aHaystack[mid].</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">mid </span><span class="s0">- </span><span class="s2">aLow </span><span class="s0">&gt; </span><span class="s5">1</span><span class="s0">) {</span>
	      <span class="s4">// The element is in the lower half.</span>
	      <span class="s1">return </span><span class="s2">recursiveSearch</span><span class="s0">(</span><span class="s2">aLow</span><span class="s0">, </span><span class="s2">mid</span><span class="s0">, </span><span class="s2">aNeedle</span><span class="s0">, </span><span class="s2">aHaystack</span><span class="s0">, </span><span class="s2">aCompare</span><span class="s0">, </span><span class="s2">aBias</span><span class="s0">);</span>
	    <span class="s0">}</span>
	
	    <span class="s4">// we are in termination case (3) or (2) and return the appropriate thing.</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">aBias </span><span class="s0">== </span><span class="s2">exports</span><span class="s0">.</span><span class="s2">LEAST_UPPER_BOUND</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s2">mid</span><span class="s0">;</span>
	    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">return </span><span class="s2">aLow </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? -</span><span class="s5">1 </span><span class="s0">: </span><span class="s2">aLow</span><span class="s0">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* This is an implementation of binary search which will always try and return</span>
	 <span class="s6">* the index of the closest element if there is no exact hit. This is because</span>
	 <span class="s6">* mappings between original and generated line/col pairs are single points,</span>
	 <span class="s6">* and there is an implicit region between each of them, so a miss just means</span>
	 <span class="s6">* that you aren't on the very start of a region.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aNeedle The element you are looking for.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aHaystack The array that is being searched.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aCompare A function which takes the needle and an element in the</span>
	 <span class="s6">*     array and returns -1, 0, or 1 depending on whether the needle is less</span>
	 <span class="s6">*     than, equal to, or greater than the element, respectively.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or</span>
	 <span class="s6">*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the</span>
	 <span class="s6">*     closest element that is smaller than or greater than the one we are</span>
	 <span class="s6">*     searching for, respectively, if the exact element cannot be found.</span>
	 <span class="s6">*     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.</span>
	 <span class="s6">*/</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">search </span><span class="s0">= </span><span class="s1">function </span><span class="s2">search</span><span class="s0">(</span><span class="s2">aNeedle</span><span class="s0">, </span><span class="s2">aHaystack</span><span class="s0">, </span><span class="s2">aCompare</span><span class="s0">, </span><span class="s2">aBias</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aHaystack</span><span class="s0">.</span><span class="s2">length </span><span class="s0">=== </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">-</span><span class="s5">1</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">var </span><span class="s2">index </span><span class="s0">= </span><span class="s2">recursiveSearch</span><span class="s0">(-</span><span class="s5">1</span><span class="s0">, </span><span class="s2">aHaystack</span><span class="s0">.</span><span class="s2">length</span><span class="s0">, </span><span class="s2">aNeedle</span><span class="s0">, </span><span class="s2">aHaystack</span><span class="s0">,</span>
	                              <span class="s2">aCompare</span><span class="s0">, </span><span class="s2">aBias </span><span class="s0">|| </span><span class="s2">exports</span><span class="s0">.</span><span class="s2">GREATEST_LOWER_BOUND</span><span class="s0">);</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">index </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">-</span><span class="s5">1</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s4">// We have found either the exact element, or the next-closest element than</span>
	  <span class="s4">// the one we are searching for. However, there may be more than one such</span>
	  <span class="s4">// element. Make sure we always return the smallest of these.</span>
	  <span class="s1">while </span><span class="s0">(</span><span class="s2">index </span><span class="s0">- </span><span class="s5">1 </span><span class="s0">&gt;= </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">aCompare</span><span class="s0">(</span><span class="s2">aHaystack</span><span class="s0">[</span><span class="s2">index</span><span class="s0">], </span><span class="s2">aHaystack</span><span class="s0">[</span><span class="s2">index </span><span class="s0">- </span><span class="s5">1</span><span class="s0">], </span><span class="s1">true</span><span class="s0">) !== </span><span class="s5">0</span><span class="s0">) {</span>
	      <span class="s1">break</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s0">--</span><span class="s2">index</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s2">index</span><span class="s0">;</span>
	<span class="s0">};</span>


<span class="s4">/***/ </span><span class="s0">}),</span>
<span class="s4">/* 9 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(</span><span class="s2">module</span><span class="s0">, </span><span class="s2">exports</span><span class="s0">) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s4">// It turns out that some (most?) JavaScript engines don't self-host</span>
	<span class="s4">// `Array.prototype.sort`. This makes sense because C++ will likely remain</span>
	<span class="s4">// faster than JS when doing raw CPU-intensive sorting. However, when using a</span>
	<span class="s4">// custom comparator function, calling back and forth between the VM's C++ and</span>
	<span class="s4">// JIT'd JS is rather slow *and* loses JIT type information, resulting in</span>
	<span class="s4">// worse generated code for the comparator function than would be optimal. In</span>
	<span class="s4">// fact, when sorting with a comparator, these costs outweigh the benefits of</span>
	<span class="s4">// sorting in C++. By using our own JS-implemented Quick Sort (below), we get</span>
	<span class="s4">// a ~3500ms mean speed-up in `bench/bench.html`.</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Swap the elements indexed by `x` and `y` in the array `ary`.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Array} ary</span>
	 <span class="s6">*        The array.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} x</span>
	 <span class="s6">*        The index of the first item.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} y</span>
	 <span class="s6">*        The index of the second item.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">swap</span><span class="s0">(</span><span class="s2">ary</span><span class="s0">, </span><span class="s2">x</span><span class="s0">, </span><span class="s2">y</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">temp </span><span class="s0">= </span><span class="s2">ary</span><span class="s0">[</span><span class="s2">x</span><span class="s0">];</span>
	  <span class="s2">ary</span><span class="s0">[</span><span class="s2">x</span><span class="s0">] = </span><span class="s2">ary</span><span class="s0">[</span><span class="s2">y</span><span class="s0">];</span>
	  <span class="s2">ary</span><span class="s0">[</span><span class="s2">y</span><span class="s0">] = </span><span class="s2">temp</span><span class="s0">;</span>
	<span class="s0">}</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Returns a random integer within the range `low .. high` inclusive.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} low</span>
	 <span class="s6">*        The lower bound on the range.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} high</span>
	 <span class="s6">*        The upper bound on the range.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">randomIntInRange</span><span class="s0">(</span><span class="s2">low</span><span class="s0">, </span><span class="s2">high</span><span class="s0">) {</span>
	  <span class="s1">return </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">round</span><span class="s0">(</span><span class="s2">low </span><span class="s0">+ (</span><span class="s2">Math</span><span class="s0">.</span><span class="s2">random</span><span class="s0">() * (</span><span class="s2">high </span><span class="s0">- </span><span class="s2">low</span><span class="s0">)));</span>
	<span class="s0">}</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* The Quick Sort algorithm.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Array} ary</span>
	 <span class="s6">*        An array to sort.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{function} comparator</span>
	 <span class="s6">*        Function to use to compare two items.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} p</span>
	 <span class="s6">*        Start index of the array</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} r</span>
	 <span class="s6">*        End index of the array</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">doQuickSort</span><span class="s0">(</span><span class="s2">ary</span><span class="s0">, </span><span class="s2">comparator</span><span class="s0">, </span><span class="s2">p</span><span class="s0">, </span><span class="s2">r</span><span class="s0">) {</span>
	  <span class="s4">// If our lower bound is less than our upper bound, we (1) partition the</span>
	  <span class="s4">// array into two pieces and (2) recurse on each half. If it is not, this is</span>
	  <span class="s4">// the empty array and our base case.</span>
	
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">p </span><span class="s0">&lt; </span><span class="s2">r</span><span class="s0">) {</span>
	    <span class="s4">// (1) Partitioning.</span>
	    <span class="s4">//</span>
	    <span class="s4">// The partitioning chooses a pivot between `p` and `r` and moves all</span>
	    <span class="s4">// elements that are less than or equal to the pivot to the before it, and</span>
	    <span class="s4">// all the elements that are greater than it after it. The effect is that</span>
	    <span class="s4">// once partition is done, the pivot is in the exact place it will be when</span>
	    <span class="s4">// the array is put in sorted order, and it will not need to be moved</span>
	    <span class="s4">// again. This runs in O(n) time.</span>
	
	    <span class="s4">// Always choose a random pivot so that an input array which is reverse</span>
	    <span class="s4">// sorted does not cause O(n^2) running time.</span>
	    <span class="s1">var </span><span class="s2">pivotIndex </span><span class="s0">= </span><span class="s2">randomIntInRange</span><span class="s0">(</span><span class="s2">p</span><span class="s0">, </span><span class="s2">r</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s2">p </span><span class="s0">- </span><span class="s5">1</span><span class="s0">;</span>
	
	    <span class="s2">swap</span><span class="s0">(</span><span class="s2">ary</span><span class="s0">, </span><span class="s2">pivotIndex</span><span class="s0">, </span><span class="s2">r</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s2">pivot </span><span class="s0">= </span><span class="s2">ary</span><span class="s0">[</span><span class="s2">r</span><span class="s0">];</span>
	
	    <span class="s4">// Immediately after `j` is incremented in this loop, the following hold</span>
	    <span class="s4">// true:</span>
	    <span class="s4">//</span>
	    <span class="s4">//   * Every element in `ary[p .. i]` is less than or equal to the pivot.</span>
	    <span class="s4">//</span>
	    <span class="s4">//   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">j </span><span class="s0">= </span><span class="s2">p</span><span class="s0">; </span><span class="s2">j </span><span class="s0">&lt; </span><span class="s2">r</span><span class="s0">; </span><span class="s2">j</span><span class="s0">++) {</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">comparator</span><span class="s0">(</span><span class="s2">ary</span><span class="s0">[</span><span class="s2">j</span><span class="s0">], </span><span class="s2">pivot</span><span class="s0">) &lt;= </span><span class="s5">0</span><span class="s0">) {</span>
	        <span class="s2">i </span><span class="s0">+= </span><span class="s5">1</span><span class="s0">;</span>
	        <span class="s2">swap</span><span class="s0">(</span><span class="s2">ary</span><span class="s0">, </span><span class="s2">i</span><span class="s0">, </span><span class="s2">j</span><span class="s0">);</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s2">swap</span><span class="s0">(</span><span class="s2">ary</span><span class="s0">, </span><span class="s2">i </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s2">j</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s2">q </span><span class="s0">= </span><span class="s2">i </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">;</span>
	
	    <span class="s4">// (2) Recurse on each half.</span>
	
	    <span class="s2">doQuickSort</span><span class="s0">(</span><span class="s2">ary</span><span class="s0">, </span><span class="s2">comparator</span><span class="s0">, </span><span class="s2">p</span><span class="s0">, </span><span class="s2">q </span><span class="s0">- </span><span class="s5">1</span><span class="s0">);</span>
	    <span class="s2">doQuickSort</span><span class="s0">(</span><span class="s2">ary</span><span class="s0">, </span><span class="s2">comparator</span><span class="s0">, </span><span class="s2">q </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s2">r</span><span class="s0">);</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Sort the given array in-place with the given comparator function.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Array} ary</span>
	 <span class="s6">*        An array to sort.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{function} comparator</span>
	 <span class="s6">*        Function to use to compare two items.</span>
	 <span class="s6">*/</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">quickSort </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">ary</span><span class="s0">, </span><span class="s2">comparator</span><span class="s0">) {</span>
	  <span class="s2">doQuickSort</span><span class="s0">(</span><span class="s2">ary</span><span class="s0">, </span><span class="s2">comparator</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s2">ary</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s5">1</span><span class="s0">);</span>
	<span class="s0">};</span>


<span class="s4">/***/ </span><span class="s0">}),</span>
<span class="s4">/* 10 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(</span><span class="s2">module</span><span class="s0">, </span><span class="s2">exports</span><span class="s0">, </span><span class="s2">__webpack_require__</span><span class="s0">) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s2">SourceMapGenerator </span><span class="s0">= </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">1</span><span class="s0">).</span><span class="s2">SourceMapGenerator</span><span class="s0">;</span>
	<span class="s1">var </span><span class="s2">util </span><span class="s0">= </span><span class="s2">__webpack_require__</span><span class="s0">(</span><span class="s5">4</span><span class="s0">);</span>
	
	<span class="s4">// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other</span>
	<span class="s4">// operating systems these days (capturing the result).</span>
	<span class="s1">var </span><span class="s2">REGEX_NEWLINE </span><span class="s0">= </span><span class="s8">/(\r?\n)/</span><span class="s0">;</span>
	
	<span class="s4">// Newline character code for charCodeAt() comparisons</span>
	<span class="s1">var </span><span class="s2">NEWLINE_CODE </span><span class="s0">= </span><span class="s5">10</span><span class="s0">;</span>
	
	<span class="s4">// Private symbol for identifying `SourceNode`s when multiple versions of</span>
	<span class="s4">// the source-map library are loaded. This MUST NOT CHANGE across</span>
	<span class="s4">// versions!</span>
	<span class="s1">var </span><span class="s2">isSourceNode </span><span class="s0">= </span><span class="s3">&quot;$$$isSourceNode$$$&quot;</span><span class="s0">;</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* SourceNodes provide a way to abstract over interpolating/concatenating</span>
	 <span class="s6">* snippets of generated JavaScript source code while maintaining the line and</span>
	 <span class="s6">* column information associated with the original source code.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aLine The original line number.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aColumn The original column number.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSource The original source's filename.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aChunks Optional. An array of strings which are snippets of</span>
	 <span class="s6">*        generated JS, or other SourceNodes.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aName The original identifier.</span>
	 <span class="s6">*/</span>
	<span class="s1">function </span><span class="s2">SourceNode</span><span class="s0">(</span><span class="s2">aLine</span><span class="s0">, </span><span class="s2">aColumn</span><span class="s0">, </span><span class="s2">aSource</span><span class="s0">, </span><span class="s2">aChunks</span><span class="s0">, </span><span class="s2">aName</span><span class="s0">) {</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">children </span><span class="s0">= [];</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">sourceContents </span><span class="s0">= {};</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">line </span><span class="s0">= </span><span class="s2">aLine </span><span class="s0">== </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: </span><span class="s2">aLine</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">column </span><span class="s0">= </span><span class="s2">aColumn </span><span class="s0">== </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: </span><span class="s2">aColumn</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">source </span><span class="s0">= </span><span class="s2">aSource </span><span class="s0">== </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: </span><span class="s2">aSource</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">name </span><span class="s0">= </span><span class="s2">aName </span><span class="s0">== </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: </span><span class="s2">aName</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">[</span><span class="s2">isSourceNode</span><span class="s0">] = </span><span class="s1">true</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">aChunks </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) </span><span class="s1">this</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">aChunks</span><span class="s0">);</span>
	<span class="s0">}</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Creates a SourceNode from generated code and a SourceMapConsumer.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aGeneratedCode The generated code</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSourceMapConsumer The SourceMap for the generated code</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aRelativePath Optional. The path that relative sources in the</span>
	 <span class="s6">*        SourceMapConsumer should be relative to.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceNode</span><span class="s0">.</span><span class="s2">fromStringWithSourceMap </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceNode_fromStringWithSourceMap</span><span class="s0">(</span><span class="s2">aGeneratedCode</span><span class="s0">, </span><span class="s2">aSourceMapConsumer</span><span class="s0">, </span><span class="s2">aRelativePath</span><span class="s0">) {</span>
	    <span class="s4">// The SourceNode we want to fill with the generated code</span>
	    <span class="s4">// and the SourceMap</span>
	    <span class="s1">var </span><span class="s2">node </span><span class="s0">= </span><span class="s1">new </span><span class="s2">SourceNode</span><span class="s0">();</span>
	
	    <span class="s4">// All even indices of this array are one line of the generated code,</span>
	    <span class="s4">// while all odd indices are the newlines between two adjacent lines</span>
	    <span class="s4">// (since `REGEX_NEWLINE` captures its match).</span>
	    <span class="s4">// Processed fragments are accessed by calling `shiftNextLine`.</span>
	    <span class="s1">var </span><span class="s2">remainingLines </span><span class="s0">= </span><span class="s2">aGeneratedCode</span><span class="s0">.</span><span class="s2">split</span><span class="s0">(</span><span class="s2">REGEX_NEWLINE</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s2">remainingLinesIndex </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">shiftNextLine </span><span class="s0">= </span><span class="s1">function</span><span class="s0">() {</span>
	      <span class="s1">var </span><span class="s2">lineContents </span><span class="s0">= </span><span class="s2">getNextLine</span><span class="s0">();</span>
	      <span class="s4">// The last line of a file might not have a newline.</span>
	      <span class="s1">var </span><span class="s2">newLine </span><span class="s0">= </span><span class="s2">getNextLine</span><span class="s0">() || </span><span class="s3">&quot;&quot;</span><span class="s0">;</span>
	      <span class="s1">return </span><span class="s2">lineContents </span><span class="s0">+ </span><span class="s2">newLine</span><span class="s0">;</span>
	
	      <span class="s1">function </span><span class="s2">getNextLine</span><span class="s0">() {</span>
	        <span class="s1">return </span><span class="s2">remainingLinesIndex </span><span class="s0">&lt; </span><span class="s2">remainingLines</span><span class="s0">.</span><span class="s2">length </span><span class="s0">?</span>
	            <span class="s2">remainingLines</span><span class="s0">[</span><span class="s2">remainingLinesIndex</span><span class="s0">++] : </span><span class="s2">undefined</span><span class="s0">;</span>
	      <span class="s0">}</span>
	    <span class="s0">};</span>
	
	    <span class="s4">// We need to remember the position of &quot;remainingLines&quot;</span>
	    <span class="s1">var </span><span class="s2">lastGeneratedLine </span><span class="s0">= </span><span class="s5">1</span><span class="s0">, </span><span class="s2">lastGeneratedColumn </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	
	    <span class="s4">// The generate SourceNodes we need a code range.</span>
	    <span class="s4">// To extract it current and last mapping is used.</span>
	    <span class="s4">// Here we store the last mapping.</span>
	    <span class="s1">var </span><span class="s2">lastMapping </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
	
	    <span class="s2">aSourceMapConsumer</span><span class="s0">.</span><span class="s2">eachMapping</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">lastMapping </span><span class="s0">!== </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s4">// We add the code from &quot;lastMapping&quot; to &quot;mapping&quot;:</span>
	        <span class="s4">// First check if there is a new line in between.</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">lastGeneratedLine </span><span class="s0">&lt; </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedLine</span><span class="s0">) {</span>
	          <span class="s4">// Associate first line with &quot;lastMapping&quot;</span>
	          <span class="s2">addMappingWithCode</span><span class="s0">(</span><span class="s2">lastMapping</span><span class="s0">, </span><span class="s2">shiftNextLine</span><span class="s0">());</span>
	          <span class="s2">lastGeneratedLine</span><span class="s0">++;</span>
	          <span class="s2">lastGeneratedColumn </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	          <span class="s4">// The remaining code is added without mapping</span>
	        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	          <span class="s4">// There is no new line in between.</span>
	          <span class="s4">// Associate the code between &quot;lastGeneratedColumn&quot; and</span>
	          <span class="s4">// &quot;mapping.generatedColumn&quot; with &quot;lastMapping&quot;</span>
	          <span class="s1">var </span><span class="s2">nextLine </span><span class="s0">= </span><span class="s2">remainingLines</span><span class="s0">[</span><span class="s2">remainingLinesIndex</span><span class="s0">] || </span><span class="s3">''</span><span class="s0">;</span>
	          <span class="s1">var </span><span class="s2">code </span><span class="s0">= </span><span class="s2">nextLine</span><span class="s0">.</span><span class="s2">substr</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedColumn </span><span class="s0">-</span>
	                                        <span class="s2">lastGeneratedColumn</span><span class="s0">);</span>
	          <span class="s2">remainingLines</span><span class="s0">[</span><span class="s2">remainingLinesIndex</span><span class="s0">] = </span><span class="s2">nextLine</span><span class="s0">.</span><span class="s2">substr</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedColumn </span><span class="s0">-</span>
	                                              <span class="s2">lastGeneratedColumn</span><span class="s0">);</span>
	          <span class="s2">lastGeneratedColumn </span><span class="s0">= </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedColumn</span><span class="s0">;</span>
	          <span class="s2">addMappingWithCode</span><span class="s0">(</span><span class="s2">lastMapping</span><span class="s0">, </span><span class="s2">code</span><span class="s0">);</span>
	          <span class="s4">// No more remaining code, continue</span>
	          <span class="s2">lastMapping </span><span class="s0">= </span><span class="s2">mapping</span><span class="s0">;</span>
	          <span class="s1">return</span><span class="s0">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	      <span class="s4">// We add the generated code until the first mapping</span>
	      <span class="s4">// to the SourceNode without any mapping.</span>
	      <span class="s4">// Each line is added as separate string.</span>
	      <span class="s1">while </span><span class="s0">(</span><span class="s2">lastGeneratedLine </span><span class="s0">&lt; </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedLine</span><span class="s0">) {</span>
	        <span class="s2">node</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">shiftNextLine</span><span class="s0">());</span>
	        <span class="s2">lastGeneratedLine</span><span class="s0">++;</span>
	      <span class="s0">}</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">lastGeneratedColumn </span><span class="s0">&lt; </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedColumn</span><span class="s0">) {</span>
	        <span class="s1">var </span><span class="s2">nextLine </span><span class="s0">= </span><span class="s2">remainingLines</span><span class="s0">[</span><span class="s2">remainingLinesIndex</span><span class="s0">] || </span><span class="s3">''</span><span class="s0">;</span>
	        <span class="s2">node</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">nextLine</span><span class="s0">.</span><span class="s2">substr</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedColumn</span><span class="s0">));</span>
	        <span class="s2">remainingLines</span><span class="s0">[</span><span class="s2">remainingLinesIndex</span><span class="s0">] = </span><span class="s2">nextLine</span><span class="s0">.</span><span class="s2">substr</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedColumn</span><span class="s0">);</span>
	        <span class="s2">lastGeneratedColumn </span><span class="s0">= </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">generatedColumn</span><span class="s0">;</span>
	      <span class="s0">}</span>
	      <span class="s2">lastMapping </span><span class="s0">= </span><span class="s2">mapping</span><span class="s0">;</span>
	    <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
	    <span class="s4">// We have processed all mappings.</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">remainingLinesIndex </span><span class="s0">&lt; </span><span class="s2">remainingLines</span><span class="s0">.</span><span class="s2">length</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">lastMapping</span><span class="s0">) {</span>
	        <span class="s4">// Associate the remaining code in the current line with &quot;lastMapping&quot;</span>
	        <span class="s2">addMappingWithCode</span><span class="s0">(</span><span class="s2">lastMapping</span><span class="s0">, </span><span class="s2">shiftNextLine</span><span class="s0">());</span>
	      <span class="s0">}</span>
	      <span class="s4">// and add the remaining lines without any mapping</span>
	      <span class="s2">node</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">remainingLines</span><span class="s0">.</span><span class="s2">splice</span><span class="s0">(</span><span class="s2">remainingLinesIndex</span><span class="s0">).</span><span class="s2">join</span><span class="s0">(</span><span class="s3">&quot;&quot;</span><span class="s0">));</span>
	    <span class="s0">}</span>
	
	    <span class="s4">// Copy sourcesContent into SourceNode</span>
	    <span class="s2">aSourceMapConsumer</span><span class="s0">.</span><span class="s2">sources</span><span class="s0">.</span><span class="s2">forEach</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">sourceFile</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">content </span><span class="s0">= </span><span class="s2">aSourceMapConsumer</span><span class="s0">.</span><span class="s2">sourceContentFor</span><span class="s0">(</span><span class="s2">sourceFile</span><span class="s0">);</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">content </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">aRelativePath </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s2">sourceFile </span><span class="s0">= </span><span class="s2">util</span><span class="s0">.</span><span class="s2">join</span><span class="s0">(</span><span class="s2">aRelativePath</span><span class="s0">, </span><span class="s2">sourceFile</span><span class="s0">);</span>
	        <span class="s0">}</span>
	        <span class="s2">node</span><span class="s0">.</span><span class="s2">setSourceContent</span><span class="s0">(</span><span class="s2">sourceFile</span><span class="s0">, </span><span class="s2">content</span><span class="s0">);</span>
	      <span class="s0">}</span>
	    <span class="s0">});</span>
	
	    <span class="s1">return </span><span class="s2">node</span><span class="s0">;</span>
	
	    <span class="s1">function </span><span class="s2">addMappingWithCode</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">, </span><span class="s2">code</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">mapping </span><span class="s0">=== </span><span class="s1">null </span><span class="s0">|| </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">source </span><span class="s0">=== </span><span class="s2">undefined</span><span class="s0">) {</span>
	        <span class="s2">node</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">code</span><span class="s0">);</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	        <span class="s1">var </span><span class="s2">source </span><span class="s0">= </span><span class="s2">aRelativePath</span>
	          <span class="s0">? </span><span class="s2">util</span><span class="s0">.</span><span class="s2">join</span><span class="s0">(</span><span class="s2">aRelativePath</span><span class="s0">, </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">source</span><span class="s0">)</span>
	          <span class="s0">: </span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">source</span><span class="s0">;</span>
	        <span class="s2">node</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s1">new </span><span class="s2">SourceNode</span><span class="s0">(</span><span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalLine</span><span class="s0">,</span>
	                                <span class="s2">mapping</span><span class="s0">.</span><span class="s2">originalColumn</span><span class="s0">,</span>
	                                <span class="s2">source</span><span class="s0">,</span>
	                                <span class="s2">code</span><span class="s0">,</span>
	                                <span class="s2">mapping</span><span class="s0">.</span><span class="s2">name</span><span class="s0">));</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Add a chunk of generated JS to this source node.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aChunk A string snippet of generated JS code, another instance of</span>
	 <span class="s6">*        SourceNode, or an array where each member is one of those things.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceNode</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">add </span><span class="s0">= </span><span class="s1">function </span><span class="s2">SourceNode_add</span><span class="s0">(</span><span class="s2">aChunk</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">Array</span><span class="s0">.</span><span class="s2">isArray</span><span class="s0">(</span><span class="s2">aChunk</span><span class="s0">)) {</span>
	    <span class="s2">aChunk</span><span class="s0">.</span><span class="s2">forEach</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">chunk</span><span class="s0">) {</span>
	      <span class="s1">this</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">chunk</span><span class="s0">);</span>
	    <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
	  <span class="s0">}</span>
	  <span class="s1">else if </span><span class="s0">(</span><span class="s2">aChunk</span><span class="s0">[</span><span class="s2">isSourceNode</span><span class="s0">] || </span><span class="s1">typeof </span><span class="s2">aChunk </span><span class="s0">=== </span><span class="s3">&quot;string&quot;</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">aChunk</span><span class="s0">) {</span>
	      <span class="s1">this</span><span class="s0">.</span><span class="s2">children</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s2">aChunk</span><span class="s0">);</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	  <span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">throw new </span><span class="s2">TypeError</span><span class="s0">(</span>
	      <span class="s3">&quot;Expected a SourceNode, string, or an array of SourceNodes and strings. Got &quot; </span><span class="s0">+ </span><span class="s2">aChunk</span>
	    <span class="s0">);</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s0">;</span>
	<span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Add a chunk of generated JS to the beginning of this source node.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aChunk A string snippet of generated JS code, another instance of</span>
	 <span class="s6">*        SourceNode, or an array where each member is one of those things.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceNode</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">prepend </span><span class="s0">= </span><span class="s1">function </span><span class="s2">SourceNode_prepend</span><span class="s0">(</span><span class="s2">aChunk</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">Array</span><span class="s0">.</span><span class="s2">isArray</span><span class="s0">(</span><span class="s2">aChunk</span><span class="s0">)) {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s2">aChunk</span><span class="s0">.</span><span class="s2">length</span><span class="s0">-</span><span class="s5">1</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&gt;= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">i</span><span class="s0">--) {</span>
	      <span class="s1">this</span><span class="s0">.</span><span class="s2">prepend</span><span class="s0">(</span><span class="s2">aChunk</span><span class="s0">[</span><span class="s2">i</span><span class="s0">]);</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	  <span class="s1">else if </span><span class="s0">(</span><span class="s2">aChunk</span><span class="s0">[</span><span class="s2">isSourceNode</span><span class="s0">] || </span><span class="s1">typeof </span><span class="s2">aChunk </span><span class="s0">=== </span><span class="s3">&quot;string&quot;</span><span class="s0">) {</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">children</span><span class="s0">.</span><span class="s2">unshift</span><span class="s0">(</span><span class="s2">aChunk</span><span class="s0">);</span>
	  <span class="s0">}</span>
	  <span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">throw new </span><span class="s2">TypeError</span><span class="s0">(</span>
	      <span class="s3">&quot;Expected a SourceNode, string, or an array of SourceNodes and strings. Got &quot; </span><span class="s0">+ </span><span class="s2">aChunk</span>
	    <span class="s0">);</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s0">;</span>
	<span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Walk over the tree of JS snippets in this node and its children. The</span>
	 <span class="s6">* walking function is called once for each snippet of JS and is passed that</span>
	 <span class="s6">* snippet and the its original associated source's line/column location.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aFn The traversal function.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceNode</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">walk </span><span class="s0">= </span><span class="s1">function </span><span class="s2">SourceNode_walk</span><span class="s0">(</span><span class="s2">aFn</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">chunk</span><span class="s0">;</span>
	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">, </span><span class="s2">len </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">children</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">len</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
	    <span class="s2">chunk </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">children</span><span class="s0">[</span><span class="s2">i</span><span class="s0">];</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">chunk</span><span class="s0">[</span><span class="s2">isSourceNode</span><span class="s0">]) {</span>
	      <span class="s2">chunk</span><span class="s0">.</span><span class="s2">walk</span><span class="s0">(</span><span class="s2">aFn</span><span class="s0">);</span>
	    <span class="s0">}</span>
	    <span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">chunk </span><span class="s0">!== </span><span class="s3">''</span><span class="s0">) {</span>
	        <span class="s2">aFn</span><span class="s0">(</span><span class="s2">chunk</span><span class="s0">, { </span><span class="s2">source</span><span class="s0">: </span><span class="s1">this</span><span class="s0">.</span><span class="s2">source</span><span class="s0">,</span>
	                     <span class="s2">line</span><span class="s0">: </span><span class="s1">this</span><span class="s0">.</span><span class="s2">line</span><span class="s0">,</span>
	                     <span class="s2">column</span><span class="s0">: </span><span class="s1">this</span><span class="s0">.</span><span class="s2">column</span><span class="s0">,</span>
	                     <span class="s2">name</span><span class="s0">: </span><span class="s1">this</span><span class="s0">.</span><span class="s2">name </span><span class="s0">});</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	<span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between</span>
	 <span class="s6">* each of `this.children`.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSep The separator.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceNode</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">join </span><span class="s0">= </span><span class="s1">function </span><span class="s2">SourceNode_join</span><span class="s0">(</span><span class="s2">aSep</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">newChildren</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">i</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">len </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">children</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">len </span><span class="s0">&gt; </span><span class="s5">0</span><span class="s0">) {</span>
	    <span class="s2">newChildren </span><span class="s0">= [];</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">len</span><span class="s0">-</span><span class="s5">1</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
	      <span class="s2">newChildren</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">children</span><span class="s0">[</span><span class="s2">i</span><span class="s0">]);</span>
	      <span class="s2">newChildren</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s2">aSep</span><span class="s0">);</span>
	    <span class="s0">}</span>
	    <span class="s2">newChildren</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">children</span><span class="s0">[</span><span class="s2">i</span><span class="s0">]);</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">children </span><span class="s0">= </span><span class="s2">newChildren</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s0">;</span>
	<span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Call String.prototype.replace on the very right-most source snippet. Useful</span>
	 <span class="s6">* for trimming whitespace from the end of a source node, etc.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aPattern The pattern to replace.</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aReplacement The thing to replace the pattern with.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceNode</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">replaceRight </span><span class="s0">= </span><span class="s1">function </span><span class="s2">SourceNode_replaceRight</span><span class="s0">(</span><span class="s2">aPattern</span><span class="s0">, </span><span class="s2">aReplacement</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">lastChild </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">children</span><span class="s0">[</span><span class="s1">this</span><span class="s0">.</span><span class="s2">children</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s5">1</span><span class="s0">];</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">lastChild</span><span class="s0">[</span><span class="s2">isSourceNode</span><span class="s0">]) {</span>
	    <span class="s2">lastChild</span><span class="s0">.</span><span class="s2">replaceRight</span><span class="s0">(</span><span class="s2">aPattern</span><span class="s0">, </span><span class="s2">aReplacement</span><span class="s0">);</span>
	  <span class="s0">}</span>
	  <span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">lastChild </span><span class="s0">=== </span><span class="s3">'string'</span><span class="s0">) {</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">children</span><span class="s0">[</span><span class="s1">this</span><span class="s0">.</span><span class="s2">children</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s5">1</span><span class="s0">] = </span><span class="s2">lastChild</span><span class="s0">.</span><span class="s2">replace</span><span class="s0">(</span><span class="s2">aPattern</span><span class="s0">, </span><span class="s2">aReplacement</span><span class="s0">);</span>
	  <span class="s0">}</span>
	  <span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">children</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s3">''</span><span class="s0">.</span><span class="s2">replace</span><span class="s0">(</span><span class="s2">aPattern</span><span class="s0">, </span><span class="s2">aReplacement</span><span class="s0">));</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s0">;</span>
	<span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Set the source content for a source file. This will be added to the SourceMapGenerator</span>
	 <span class="s6">* in the sourcesContent field.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSourceFile The filename of the source file</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aSourceContent The content of the source file</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceNode</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">setSourceContent </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceNode_setSourceContent</span><span class="s0">(</span><span class="s2">aSourceFile</span><span class="s0">, </span><span class="s2">aSourceContent</span><span class="s0">) {</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">sourceContents</span><span class="s0">[</span><span class="s2">util</span><span class="s0">.</span><span class="s2">toSetString</span><span class="s0">(</span><span class="s2">aSourceFile</span><span class="s0">)] = </span><span class="s2">aSourceContent</span><span class="s0">;</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Walk over the tree of SourceNodes. The walking function is called for each</span>
	 <span class="s6">* source file content and is passed the filename and source content.</span>
	 <span class="s6">*</span>
	 <span class="s6">* </span><span class="s7">@param </span><span class="s6">aFn The traversal function.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceNode</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">walkSourceContents </span><span class="s0">=</span>
	  <span class="s1">function </span><span class="s2">SourceNode_walkSourceContents</span><span class="s0">(</span><span class="s2">aFn</span><span class="s0">) {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">, </span><span class="s2">len </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">children</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">len</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">children</span><span class="s0">[</span><span class="s2">i</span><span class="s0">][</span><span class="s2">isSourceNode</span><span class="s0">]) {</span>
	        <span class="s1">this</span><span class="s0">.</span><span class="s2">children</span><span class="s0">[</span><span class="s2">i</span><span class="s0">].</span><span class="s2">walkSourceContents</span><span class="s0">(</span><span class="s2">aFn</span><span class="s0">);</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">var </span><span class="s2">sources </span><span class="s0">= </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">keys</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">sourceContents</span><span class="s0">);</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">, </span><span class="s2">len </span><span class="s0">= </span><span class="s2">sources</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">len</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
	      <span class="s2">aFn</span><span class="s0">(</span><span class="s2">util</span><span class="s0">.</span><span class="s2">fromSetString</span><span class="s0">(</span><span class="s2">sources</span><span class="s0">[</span><span class="s2">i</span><span class="s0">]), </span><span class="s1">this</span><span class="s0">.</span><span class="s2">sourceContents</span><span class="s0">[</span><span class="s2">sources</span><span class="s0">[</span><span class="s2">i</span><span class="s0">]]);</span>
	    <span class="s0">}</span>
	  <span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Return the string representation of this source node. Walks over the tree</span>
	 <span class="s6">* and concatenates all the various snippets together to one string.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceNode</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">toString </span><span class="s0">= </span><span class="s1">function </span><span class="s2">SourceNode_toString</span><span class="s0">() {</span>
	  <span class="s1">var </span><span class="s2">str </span><span class="s0">= </span><span class="s3">&quot;&quot;</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">walk</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">chunk</span><span class="s0">) {</span>
	    <span class="s2">str </span><span class="s0">+= </span><span class="s2">chunk</span><span class="s0">;</span>
	  <span class="s0">});</span>
	  <span class="s1">return </span><span class="s2">str</span><span class="s0">;</span>
	<span class="s0">};</span>
	
	<span class="s6">/**</span>
	 <span class="s6">* Returns the string representation of this source node along with a source</span>
	 <span class="s6">* map.</span>
	 <span class="s6">*/</span>
	<span class="s2">SourceNode</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">toStringWithSourceMap </span><span class="s0">= </span><span class="s1">function </span><span class="s2">SourceNode_toStringWithSourceMap</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">generated </span><span class="s0">= {</span>
	    <span class="s2">code</span><span class="s0">: </span><span class="s3">&quot;&quot;</span><span class="s0">,</span>
	    <span class="s2">line</span><span class="s0">: </span><span class="s5">1</span><span class="s0">,</span>
	    <span class="s2">column</span><span class="s0">: </span><span class="s5">0</span>
	  <span class="s0">};</span>
	  <span class="s1">var </span><span class="s2">map </span><span class="s0">= </span><span class="s1">new </span><span class="s2">SourceMapGenerator</span><span class="s0">(</span><span class="s2">aArgs</span><span class="s0">);</span>
	  <span class="s1">var </span><span class="s2">sourceMappingActive </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">lastOriginalSource </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">lastOriginalLine </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">lastOriginalColumn </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">lastOriginalName </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">walk</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">chunk</span><span class="s0">, </span><span class="s2">original</span><span class="s0">) {</span>
	    <span class="s2">generated</span><span class="s0">.</span><span class="s2">code </span><span class="s0">+= </span><span class="s2">chunk</span><span class="s0">;</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">original</span><span class="s0">.</span><span class="s2">source </span><span class="s0">!== </span><span class="s1">null</span>
	        <span class="s0">&amp;&amp; </span><span class="s2">original</span><span class="s0">.</span><span class="s2">line </span><span class="s0">!== </span><span class="s1">null</span>
	        <span class="s0">&amp;&amp; </span><span class="s2">original</span><span class="s0">.</span><span class="s2">column </span><span class="s0">!== </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s1">if</span><span class="s0">(</span><span class="s2">lastOriginalSource </span><span class="s0">!== </span><span class="s2">original</span><span class="s0">.</span><span class="s2">source</span>
	         <span class="s0">|| </span><span class="s2">lastOriginalLine </span><span class="s0">!== </span><span class="s2">original</span><span class="s0">.</span><span class="s2">line</span>
	         <span class="s0">|| </span><span class="s2">lastOriginalColumn </span><span class="s0">!== </span><span class="s2">original</span><span class="s0">.</span><span class="s2">column</span>
	         <span class="s0">|| </span><span class="s2">lastOriginalName </span><span class="s0">!== </span><span class="s2">original</span><span class="s0">.</span><span class="s2">name</span><span class="s0">) {</span>
	        <span class="s2">map</span><span class="s0">.</span><span class="s2">addMapping</span><span class="s0">({</span>
	          <span class="s2">source</span><span class="s0">: </span><span class="s2">original</span><span class="s0">.</span><span class="s2">source</span><span class="s0">,</span>
	          <span class="s2">original</span><span class="s0">: {</span>
	            <span class="s2">line</span><span class="s0">: </span><span class="s2">original</span><span class="s0">.</span><span class="s2">line</span><span class="s0">,</span>
	            <span class="s2">column</span><span class="s0">: </span><span class="s2">original</span><span class="s0">.</span><span class="s2">column</span>
	          <span class="s0">},</span>
	          <span class="s2">generated</span><span class="s0">: {</span>
	            <span class="s2">line</span><span class="s0">: </span><span class="s2">generated</span><span class="s0">.</span><span class="s2">line</span><span class="s0">,</span>
	            <span class="s2">column</span><span class="s0">: </span><span class="s2">generated</span><span class="s0">.</span><span class="s2">column</span>
	          <span class="s0">},</span>
	          <span class="s2">name</span><span class="s0">: </span><span class="s2">original</span><span class="s0">.</span><span class="s2">name</span>
	        <span class="s0">});</span>
	      <span class="s0">}</span>
	      <span class="s2">lastOriginalSource </span><span class="s0">= </span><span class="s2">original</span><span class="s0">.</span><span class="s2">source</span><span class="s0">;</span>
	      <span class="s2">lastOriginalLine </span><span class="s0">= </span><span class="s2">original</span><span class="s0">.</span><span class="s2">line</span><span class="s0">;</span>
	      <span class="s2">lastOriginalColumn </span><span class="s0">= </span><span class="s2">original</span><span class="s0">.</span><span class="s2">column</span><span class="s0">;</span>
	      <span class="s2">lastOriginalName </span><span class="s0">= </span><span class="s2">original</span><span class="s0">.</span><span class="s2">name</span><span class="s0">;</span>
	      <span class="s2">sourceMappingActive </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
	    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">sourceMappingActive</span><span class="s0">) {</span>
	      <span class="s2">map</span><span class="s0">.</span><span class="s2">addMapping</span><span class="s0">({</span>
	        <span class="s2">generated</span><span class="s0">: {</span>
	          <span class="s2">line</span><span class="s0">: </span><span class="s2">generated</span><span class="s0">.</span><span class="s2">line</span><span class="s0">,</span>
	          <span class="s2">column</span><span class="s0">: </span><span class="s2">generated</span><span class="s0">.</span><span class="s2">column</span>
	        <span class="s0">}</span>
	      <span class="s0">});</span>
	      <span class="s2">lastOriginalSource </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
	      <span class="s2">sourceMappingActive </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">idx </span><span class="s0">= </span><span class="s5">0</span><span class="s0">, </span><span class="s2">length </span><span class="s0">= </span><span class="s2">chunk</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">idx </span><span class="s0">&lt; </span><span class="s2">length</span><span class="s0">; </span><span class="s2">idx</span><span class="s0">++) {</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">chunk</span><span class="s0">.</span><span class="s2">charCodeAt</span><span class="s0">(</span><span class="s2">idx</span><span class="s0">) === </span><span class="s2">NEWLINE_CODE</span><span class="s0">) {</span>
	        <span class="s2">generated</span><span class="s0">.</span><span class="s2">line</span><span class="s0">++;</span>
	        <span class="s2">generated</span><span class="s0">.</span><span class="s2">column </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
	        <span class="s4">// Mappings end at eol</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">idx </span><span class="s0">+ </span><span class="s5">1 </span><span class="s0">=== </span><span class="s2">length</span><span class="s0">) {</span>
	          <span class="s2">lastOriginalSource </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
	          <span class="s2">sourceMappingActive </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
	        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">sourceMappingActive</span><span class="s0">) {</span>
	          <span class="s2">map</span><span class="s0">.</span><span class="s2">addMapping</span><span class="s0">({</span>
	            <span class="s2">source</span><span class="s0">: </span><span class="s2">original</span><span class="s0">.</span><span class="s2">source</span><span class="s0">,</span>
	            <span class="s2">original</span><span class="s0">: {</span>
	              <span class="s2">line</span><span class="s0">: </span><span class="s2">original</span><span class="s0">.</span><span class="s2">line</span><span class="s0">,</span>
	              <span class="s2">column</span><span class="s0">: </span><span class="s2">original</span><span class="s0">.</span><span class="s2">column</span>
	            <span class="s0">},</span>
	            <span class="s2">generated</span><span class="s0">: {</span>
	              <span class="s2">line</span><span class="s0">: </span><span class="s2">generated</span><span class="s0">.</span><span class="s2">line</span><span class="s0">,</span>
	              <span class="s2">column</span><span class="s0">: </span><span class="s2">generated</span><span class="s0">.</span><span class="s2">column</span>
	            <span class="s0">},</span>
	            <span class="s2">name</span><span class="s0">: </span><span class="s2">original</span><span class="s0">.</span><span class="s2">name</span>
	          <span class="s0">});</span>
	        <span class="s0">}</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	        <span class="s2">generated</span><span class="s0">.</span><span class="s2">column</span><span class="s0">++;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">});</span>
	  <span class="s1">this</span><span class="s0">.</span><span class="s2">walkSourceContents</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">sourceFile</span><span class="s0">, </span><span class="s2">sourceContent</span><span class="s0">) {</span>
	    <span class="s2">map</span><span class="s0">.</span><span class="s2">setSourceContent</span><span class="s0">(</span><span class="s2">sourceFile</span><span class="s0">, </span><span class="s2">sourceContent</span><span class="s0">);</span>
	  <span class="s0">});</span>
	
	  <span class="s1">return </span><span class="s0">{ </span><span class="s2">code</span><span class="s0">: </span><span class="s2">generated</span><span class="s0">.</span><span class="s2">code</span><span class="s0">, </span><span class="s2">map</span><span class="s0">: </span><span class="s2">map </span><span class="s0">};</span>
	<span class="s0">};</span>
	
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">SourceNode </span><span class="s0">= </span><span class="s2">SourceNode</span><span class="s0">;</span>


<span class="s4">/***/ </span><span class="s0">})</span>
<span class="s4">/******/ </span><span class="s0">])</span>
<span class="s0">});</span>
<span class="s0">;</span>
<span class="s4">//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAxNjI0YzcyOTliODg3ZjdiZGY2NCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UtbWFwLmpzIiwid2VicGFjazovLy8uL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvYmFzZTY0LXZscS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvYmFzZTY0LmpzIiwid2VicGFjazovLy8uL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL2xpYi9hcnJheS1zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL21hcHBpbmctbGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvYmluYXJ5LXNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvcXVpY2stc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvc291cmNlLW5vZGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNQQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3hhQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBMkQ7QUFDM0QscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOzs7Ozs7O0FDM0lBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQixpQkFBZ0I7O0FBRWhCLG9CQUFtQjtBQUNuQixxQkFBb0I7O0FBRXBCLGlCQUFnQjtBQUNoQixpQkFBZ0I7O0FBRWhCLGlCQUFnQjtBQUNoQixrQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDbEVBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBLGVBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDdmVBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN4SEEsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM5RUEsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVEQUFzRCxZQUFZO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHdDQUF3QztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUErQyxtQkFBbUIsRUFBRTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsTUFBTTtBQUNuQztBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsMkJBQTJCO0FBQzlDLHNCQUFxQiwrQ0FBK0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLDJCQUEyQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQiwyQkFBMkI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0Esc0JBQXFCLDRCQUE0QjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3huQ0EsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUM5R0EsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakI7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqSEEsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLGNBQWM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxZQUFXO0FBQ1g7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHOztBQUVILFdBQVU7QUFDVjs7QUFFQSIsImZpbGUiOiJzb3VyY2UtbWFwLmRlYnVnLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wic291cmNlTWFwXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInNvdXJjZU1hcFwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAxNjI0YzcyOTliODg3ZjdiZGY2NCIsIi8qXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRS50eHQgb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1jb25zdW1lcicpLlNvdXJjZU1hcENvbnN1bWVyO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW5vZGUnKS5Tb3VyY2VOb2RlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UtbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICBpZiAoIWFBcmdzKSB7XG4gICAgYUFyZ3MgPSB7fTtcbiAgfVxuICB0aGlzLl9maWxlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdmaWxlJywgbnVsbCk7XG4gIHRoaXMuX3NvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG59XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICBmaWxlOiBhU291cmNlTWFwQ29uc3VtZXIuZmlsZSxcbiAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIHZhciBuZXdNYXBwaW5nID0ge1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG5ld01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBzb3VyY2VSZWxhdGl2ZSA9IHNvdXJjZUZpbGU7XG4gICAgICBpZiAoc291cmNlUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VSZWxhdGl2ZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZ2VuZXJhdG9yLl9zb3VyY2VzLmhhcyhzb3VyY2VSZWxhdGl2ZSkpIHtcbiAgICAgICAgZ2VuZXJhdG9yLl9zb3VyY2VzLmFkZChzb3VyY2VSZWxhdGl2ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRvci5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH07XG5cbi8qKlxuICogQWRkIGEgc2luZ2xlIG1hcHBpbmcgZnJvbSBvcmlnaW5hbCBzb3VyY2UgbGluZSBhbmQgY29sdW1uIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKHJlbGF0aXZlIHRvIHRoZSBzb3VyY2VSb290KS5cbiAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgdmFyIGdlbmVyYXRlZCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZ2VuZXJhdGVkJyk7XG4gICAgdmFyIG9yaWdpbmFsID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdvcmlnaW5hbCcsIG51bGwpO1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICduYW1lJywgbnVsbCk7XG5cbiAgICBpZiAoIXRoaXMuX3NraXBWYWxpZGF0aW9uKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IFN0cmluZyhzb3VyY2UpO1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgIGlmICghdGhpcy5fbmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9tYXBwaW5ncy5hZGQoe1xuICAgICAgZ2VuZXJhdGVkTGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmNvbHVtbixcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHZhciBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKGFTb3VyY2VDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0aGUgc291cmNlIGNvbnRlbnQgdG8gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgc291cmNlIGZpbGUgZnJvbSB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zb3VyY2VzQ29udGVudHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBtYXBwaW5ncyBvZiBhIHN1Yi1zb3VyY2UtbWFwIGZvciBhIHNwZWNpZmljIHNvdXJjZSBmaWxlIHRvIHRoZVxuICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICogcmVzdWx0aW5nIG1hcHBpbmdzIGlzIHRoZSBtaW5pbWl1bSBvZiB0aGlzIG1hcCBhbmQgdGhlIHN1cHBsaWVkIG1hcC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgT3B0aW9uYWwuIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGUuXG4gKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSBhU291cmNlTWFwUGF0aCBPcHRpb25hbC4gVGhlIGRpcm5hbWUgb2YgdGhlIHBhdGggdG8gdGhlIHNvdXJjZSBtYXBcbiAqICAgICAgICB0byBiZSBhcHBsaWVkLiBJZiByZWxhdGl2ZSwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyLlxuICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gKiAgICAgICAgZGlyZWN0b3J5LCBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZCBjb250YWlucyByZWxhdGl2ZSBzb3VyY2VcbiAqICAgICAgICBwYXRocy4gSWYgc28sIHRob3NlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBuZWVkIHRvIGJlIHJld3JpdHRlblxuICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICB2YXIgc291cmNlRmlsZSA9IGFTb3VyY2VGaWxlO1xuICAgIC8vIElmIGFTb3VyY2VGaWxlIGlzIG9taXR0ZWQsIHdlIHdpbGwgdXNlIHRoZSBmaWxlIHByb3BlcnR5IG9mIHRoZSBTb3VyY2VNYXBcbiAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgaWYgKGFTb3VyY2VNYXBDb25zdW1lci5maWxlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgJ29yIHRoZSBzb3VyY2UgbWFwXFwncyBcImZpbGVcIiBwcm9wZXJ0eS4gQm90aCB3ZXJlIG9taXR0ZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgIH1cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgLy8gTWFrZSBcInNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgIH1cbiAgICAvLyBBcHBseWluZyB0aGUgU291cmNlTWFwIGNhbiBhZGQgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2VzIGFuZFxuICAgIC8vIHRoZSBuYW1lcyBhcnJheS5cbiAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHZhciBuZXdOYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgLy8gRmluZCBtYXBwaW5ncyBmb3IgdGhlIFwic291cmNlRmlsZVwiXG4gICAgdGhpcy5fbWFwcGluZ3MudW5zb3J0ZWRGb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IHNvdXJjZUZpbGUgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgIT0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgdmFyIG9yaWdpbmFsID0gYVNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgaWYgKG9yaWdpbmFsLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIG5ld1NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiAhbmV3TmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG5ld05hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cblxuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXdTb3VyY2VzO1xuICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogQSBtYXBwaW5nIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgbGV2ZWxzIG9mIGRhdGE6XG4gKlxuICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKiAgIDIuIFRoZSBHZW5lcmF0ZWQgcG9zaXRpb24sIG9yaWdpbmFsIHBvc2l0aW9uLCBhbmQgb3JpZ2luYWwgc291cmNlLlxuICogICAzLiBHZW5lcmF0ZWQgYW5kIG9yaWdpbmFsIHBvc2l0aW9uLCBvcmlnaW5hbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBuYW1lXG4gKiAgICAgIHRva2VuLlxuICpcbiAqIFRvIG1haW50YWluIGNvbnNpc3RlbmN5LCB3ZSB2YWxpZGF0ZSB0aGF0IGFueSBuZXcgbWFwcGluZyBiZWluZyBhZGRlZCBmYWxsc1xuICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOYW1lKSB7XG4gICAgLy8gV2hlbiBhT3JpZ2luYWwgaXMgdHJ1dGh5IGJ1dCBoYXMgZW1wdHkgdmFsdWVzIGZvciAubGluZSBhbmQgLmNvbHVtbixcbiAgICAvLyBpdCBpcyBtb3N0IGxpa2VseSBhIHByb2dyYW1tZXIgZXJyb3IuIEluIHRoaXMgY2FzZSB3ZSB0aHJvdyBhIHZlcnlcbiAgICAvLyBzcGVjaWZpYyBlcnJvciBtZXNzYWdlIHRvIHRyeSB0byBndWlkZSB0aGVtIHRoZSByaWdodCB3YXkuXG4gICAgLy8gRm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXItYnVuZGxlci9wdWxsLzUxOVxuICAgIGlmIChhT3JpZ2luYWwgJiYgdHlwZW9mIGFPcmlnaW5hbC5saW5lICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgYU9yaWdpbmFsLmNvbHVtbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ29yaWdpbmFsLmxpbmUgYW5kIG9yaWdpbmFsLmNvbHVtbiBhcmUgbm90IG51bWJlcnMgLS0geW91IHByb2JhYmx5IG1lYW50IHRvIG9taXQgJyArXG4gICAgICAgICAgICAndGhlIG9yaWdpbmFsIG1hcHBpbmcgZW50aXJlbHkgYW5kIG9ubHkgbWFwIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uIElmIHNvLCBwYXNzICcgK1xuICAgICAgICAgICAgJ251bGwgZm9yIHRoZSBvcmlnaW5hbCBtYXBwaW5nIGluc3RlYWQgb2YgYW4gb2JqZWN0IHdpdGggZW1wdHkgb3IgbnVsbCB2YWx1ZXMuJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICYmICFhT3JpZ2luYWwgJiYgIWFTb3VyY2UgJiYgIWFOYW1lKSB7XG4gICAgICAvLyBDYXNlIDEuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbCAmJiAnbGluZScgaW4gYU9yaWdpbmFsICYmICdjb2x1bW4nIGluIGFPcmlnaW5hbFxuICAgICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhU291cmNlKSB7XG4gICAgICAvLyBDYXNlcyAyIGFuZCAzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgbmFtZTogYU5hbWVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICogc3BlY2lmaWVkIGJ5IHRoZSBzb3VyY2UgbWFwIGZvcm1hdC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2VyaWFsaXplTWFwcGluZ3MoKSB7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgbmV4dDtcbiAgICB2YXIgbWFwcGluZztcbiAgICB2YXIgbmFtZUlkeDtcbiAgICB2YXIgc291cmNlSWR4O1xuXG4gICAgdmFyIG1hcHBpbmdzID0gdGhpcy5fbWFwcGluZ3MudG9BcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuICAgICAgbmV4dCA9ICcnXG5cbiAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgIHdoaWxlIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG5leHQgKz0gJzsnO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkTGluZSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgaWYgKCF1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmcsIG1hcHBpbmdzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0ICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlSWR4ID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKHNvdXJjZUlkeCAtIHByZXZpb3VzU291cmNlKTtcbiAgICAgICAgcHJldmlvdXNTb3VyY2UgPSBzb3VyY2VJZHg7XG5cbiAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbExpbmUgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuYW1lSWR4ID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShuYW1lSWR4IC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICBwcmV2aW91c05hbWUgPSBuYW1lSWR4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSBuZXh0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZ2VuZXJhdGVTb3VyY2VzQ29udGVudChhU291cmNlcywgYVNvdXJjZVJvb3QpIHtcbiAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGFTb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZShhU291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSk7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cywga2V5KVxuICAgICAgICA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldXG4gICAgICAgIDogbnVsbDtcbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgIHZhciBtYXAgPSB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICBuYW1lczogdGhpcy5fbmFtZXMudG9BcnJheSgpLFxuICAgICAgbWFwcGluZ3M6IHRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKClcbiAgICB9O1xuICAgIGlmICh0aGlzLl9maWxlICE9IG51bGwpIHtcbiAgICAgIG1hcC5maWxlID0gdGhpcy5fZmlsZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbWFwLnNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSB0aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KG1hcC5zb3VyY2VzLCBtYXAuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKTtcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4vLyBBIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IGNhbiBjb250YWluIDYgYml0cyBvZiBkYXRhLiBGb3IgdGhlIGJhc2UgNjQgdmFyaWFibGVcbi8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4vLyBjb250aW51YXRpb24gYml0LiBUaGUgY29udGludWF0aW9uIGJpdCB0ZWxscyB1cyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlXG4vLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbi8vXG4vLyAgIENvbnRpbnVhdGlvblxuLy8gICB8ICAgIFNpZ25cbi8vICAgfCAgICB8XG4vLyAgIFYgICAgVlxuLy8gICAxMDEwMTFcblxudmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbi8vIGJpbmFyeTogMDExMTExXG52YXIgVkxRX0JBU0VfTUFTSyA9IFZMUV9CQVNFIC0gMTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4vKipcbiAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDEgYmVjb21lcyAyICgxMCBiaW5hcnkpLCAtMSBiZWNvbWVzIDMgKDExIGJpbmFyeSlcbiAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gKi9cbmZ1bmN0aW9uIHRvVkxRU2lnbmVkKGFWYWx1ZSkge1xuICByZXR1cm4gYVZhbHVlIDwgMFxuICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICA6IChhVmFsdWUgPDwgMSkgKyAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRvIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgZnJvbSBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAqICAgNCAoMTAwIGJpbmFyeSkgYmVjb21lcyAyLCA1ICgxMDEgYmluYXJ5KSBiZWNvbWVzIC0yXG4gKi9cbmZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHZhciBpc05lZ2F0aXZlID0gKGFWYWx1ZSAmIDEpID09PSAxO1xuICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xuICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgID8gLXNoaWZ0ZWRcbiAgICA6IHNoaWZ0ZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSkge1xuICB2YXIgZW5jb2RlZCA9IFwiXCI7XG4gIHZhciBkaWdpdDtcblxuICB2YXIgdmxxID0gdG9WTFFTaWduZWQoYVZhbHVlKTtcblxuICBkbyB7XG4gICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgIHZscSA+Pj49IFZMUV9CQVNFX1NISUZUO1xuICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAvLyBjb250aW51YXRpb24gYml0IGlzIG1hcmtlZC5cbiAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xuICAgIH1cbiAgICBlbmNvZGVkICs9IGJhc2U2NC5lbmNvZGUoZGlnaXQpO1xuICB9IHdoaWxlICh2bHEgPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gKiB2YWx1ZSBhbmQgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyB2aWEgdGhlIG91dCBwYXJhbWV0ZXIuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyLCBhSW5kZXgsIGFPdXRQYXJhbSkge1xuICB2YXIgc3RyTGVuID0gYVN0ci5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSAwO1xuICB2YXIgc2hpZnQgPSAwO1xuICB2YXIgY29udGludWF0aW9uLCBkaWdpdDtcblxuICBkbyB7XG4gICAgaWYgKGFJbmRleCA+PSBzdHJMZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG1vcmUgZGlnaXRzIGluIGJhc2UgNjQgVkxRIHZhbHVlLlwiKTtcbiAgICB9XG5cbiAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQ29kZUF0KGFJbmRleCsrKSk7XG4gICAgaWYgKGRpZ2l0ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgZGlnaXQ6IFwiICsgYVN0ci5jaGFyQXQoYUluZGV4IC0gMSkpO1xuICAgIH1cblxuICAgIGNvbnRpbnVhdGlvbiA9ICEhKGRpZ2l0ICYgVkxRX0NPTlRJTlVBVElPTl9CSVQpO1xuICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICBzaGlmdCArPSBWTFFfQkFTRV9TSElGVDtcbiAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcblxuICBhT3V0UGFyYW0udmFsdWUgPSBmcm9tVkxRU2lnbmVkKHJlc3VsdCk7XG4gIGFPdXRQYXJhbS5yZXN0ID0gYUluZGV4O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Jhc2U2NC12bHEuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgaW50VG9DaGFyTWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcblxuLyoqXG4gKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgaWYgKDAgPD0gbnVtYmVyICYmIG51bWJlciA8IGludFRvQ2hhck1hcC5sZW5ndGgpIHtcbiAgICByZXR1cm4gaW50VG9DaGFyTWFwW251bWJlcl07XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBudW1iZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZSBkaWdpdCB0byBhbiBpbnRlZ2VyLiBSZXR1cm5zIC0xIG9uXG4gKiBmYWlsdXJlLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICB2YXIgYmlnQSA9IDY1OyAgICAgLy8gJ0EnXG4gIHZhciBiaWdaID0gOTA7ICAgICAvLyAnWidcblxuICB2YXIgbGl0dGxlQSA9IDk3OyAgLy8gJ2EnXG4gIHZhciBsaXR0bGVaID0gMTIyOyAvLyAneidcblxuICB2YXIgemVybyA9IDQ4OyAgICAgLy8gJzAnXG4gIHZhciBuaW5lID0gNTc7ICAgICAvLyAnOSdcblxuICB2YXIgcGx1cyA9IDQzOyAgICAgLy8gJysnXG4gIHZhciBzbGFzaCA9IDQ3OyAgICAvLyAnLydcblxuICB2YXIgbGl0dGxlT2Zmc2V0ID0gMjY7XG4gIHZhciBudW1iZXJPZmZzZXQgPSA1MjtcblxuICAvLyAwIC0gMjU6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXG4gIGlmIChiaWdBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGJpZ1opIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gYmlnQSk7XG4gIH1cblxuICAvLyAyNiAtIDUxOiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxuICBpZiAobGl0dGxlQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBsaXR0bGVaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGxpdHRsZUEgKyBsaXR0bGVPZmZzZXQpO1xuICB9XG5cbiAgLy8gNTIgLSA2MTogMDEyMzQ1Njc4OVxuICBpZiAoemVybyA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBuaW5lKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIHplcm8gKyBudW1iZXJPZmZzZXQpO1xuICB9XG5cbiAgLy8gNjI6ICtcbiAgaWYgKGNoYXJDb2RlID09IHBsdXMpIHtcbiAgICByZXR1cm4gNjI7XG4gIH1cblxuICAvLyA2MzogL1xuICBpZiAoY2hhckNvZGUgPT0gc2xhc2gpIHtcbiAgICByZXR1cm4gNjM7XG4gIH1cblxuICAvLyBJbnZhbGlkIGJhc2U2NCBkaWdpdC5cbiAgcmV0dXJuIC0xO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Jhc2U2NC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8qKlxuICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICogb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2UgYXJlIGdldHRpbmcuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgcHJvcGVydHkgaXMgbWlzc2luZ1xuICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKi9cbmZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGFOYW1lIGluIGFBcmdzKSB7XG4gICAgcmV0dXJuIGFBcmdzW2FOYW1lXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuIGFEZWZhdWx0VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICB9XG59XG5leHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxudmFyIHVybFJlZ2V4cCA9IC9eKD86KFtcXHcrXFwtLl0rKTopP1xcL1xcLyg/OihcXHcrOlxcdyspQCk/KFtcXHcuLV0qKSg/OjooXFxkKykpPyguKikkLztcbnZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLiskLztcblxuZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgYXV0aDogbWF0Y2hbMl0sXG4gICAgaG9zdDogbWF0Y2hbM10sXG4gICAgcG9ydDogbWF0Y2hbNF0sXG4gICAgcGF0aDogbWF0Y2hbNV1cbiAgfTtcbn1cbmV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCkge1xuICB2YXIgdXJsID0gJyc7XG4gIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArICc6JztcbiAgfVxuICB1cmwgKz0gJy8vJztcbiAgaWYgKGFQYXJzZWRVcmwuYXV0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyAnQCc7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmhvc3Q7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgIHVybCArPSBcIjpcIiArIGFQYXJzZWRVcmwucG9ydFxuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5wYXRoO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5leHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbi8qKlxuICogTm9ybWFsaXplcyBhIHBhdGgsIG9yIHRoZSBwYXRoIHBvcnRpb24gb2YgYSBVUkw6XG4gKlxuICogLSBSZXBsYWNlcyBjb25zZWN1dGl2ZSBzbGFzaGVzIHdpdGggb25lIHNsYXNoLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICcuJyBwYXJ0cy5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnPGRpcj4vLi4nIHBhcnRzLlxuICpcbiAqIEJhc2VkIG9uIGNvZGUgaW4gdGhlIE5vZGUuanMgJ3BhdGgnIGNvcmUgbW9kdWxlLlxuICpcbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciB1cmwgdG8gbm9ybWFsaXplLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpIHtcbiAgdmFyIHBhdGggPSBhUGF0aDtcbiAgdmFyIHVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgaWYgKHVybCkge1xuICAgIGlmICghdXJsLnBhdGgpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG4gICAgcGF0aCA9IHVybC5wYXRoO1xuICB9XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpO1xuXG4gIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoL1xcLysvKTtcbiAgZm9yICh2YXIgcGFydCwgdXAgPSAwLCBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwID4gMCkge1xuICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJ0IGlzIGJsYW5rIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBUcnlpbmcgdG8gZ29cbiAgICAgICAgLy8gYWJvdmUgdGhlIHJvb3QgaXMgYSBuby1vcC4gVGhlcmVmb3JlIHdlIGNhbiByZW1vdmUgYWxsICcuLicgcGFydHNcbiAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG4gICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgdXApO1xuICAgICAgICB1cCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMik7XG4gICAgICAgIHVwLS07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgcGF0aCA9IGlzQWJzb2x1dGUgPyAnLycgOiAnLic7XG4gIH1cblxuICBpZiAodXJsKSB7XG4gICAgdXJsLnBhdGggPSBwYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbi8qKlxuICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAqXG4gKiAtIElmIGFQYXRoIGlzIGEgVVJMIG9yIGEgZGF0YSBVUkksIGFQYXRoIGlzIHJldHVybmVkLCB1bmxlc3MgYVBhdGggaXMgYVxuICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gKiAgIGZpcnN0LlxuICogLSBPdGhlcndpc2UgYVBhdGggaXMgYSBwYXRoLiBJZiBhUm9vdCBpcyBhIFVSTCwgdGhlbiBpdHMgcGF0aCBwb3J0aW9uXG4gKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAqICAgaXMgcmV0dXJuZWQuXG4gKiAgIC0gSWYgYVBhdGggaXMgYWJzb2x1dGUsIHRoZSByZXN1bHQgaXMgYVBhdGguXG4gKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuICBpZiAoYVBhdGggPT09IFwiXCIpIHtcbiAgICBhUGF0aCA9IFwiLlwiO1xuICB9XG4gIHZhciBhUGF0aFVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgdmFyIGFSb290VXJsID0gdXJsUGFyc2UoYVJvb3QpO1xuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdCA9IGFSb290VXJsLnBhdGggfHwgJy8nO1xuICB9XG5cbiAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgaWYgKGFQYXRoVXJsICYmICFhUGF0aFVybC5zY2hlbWUpIHtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICB9XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFQYXRoVXJsKTtcbiAgfVxuXG4gIGlmIChhUGF0aFVybCB8fCBhUGF0aC5tYXRjaChkYXRhVXJsUmVnZXhwKSkge1xuICAgIHJldHVybiBhUGF0aDtcbiAgfVxuXG4gIC8vIGBqb2luKCdodHRwOi8vJywgJ3d3dy5leGFtcGxlLmNvbScpYFxuICBpZiAoYVJvb3RVcmwgJiYgIWFSb290VXJsLmhvc3QgJiYgIWFSb290VXJsLnBhdGgpIHtcbiAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuXG4gIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgID8gYVBhdGhcbiAgICA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIGFQYXRoKTtcblxuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdFVybC5wYXRoID0gam9pbmVkO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cbiAgcmV0dXJuIGpvaW5lZDtcbn1cbmV4cG9ydHMuam9pbiA9IGpvaW47XG5cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uIChhUGF0aCkge1xuICByZXR1cm4gYVBhdGguY2hhckF0KDApID09PSAnLycgfHwgdXJsUmVnZXhwLnRlc3QoYVBhdGgpO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgcGF0aCByZWxhdGl2ZSB0byBhIFVSTCBvciBhbm90aGVyIHBhdGguXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBtYWRlIHJlbGF0aXZlIHRvIGFSb290LlxuICovXG5mdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuXG4gIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhdGggdG8gYmUgYWJvdmUgdGhlIHJvb3QuIEluIHRoaXMgY2FzZSwgc2ltcGx5XG4gIC8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlIHBhdGggd29uJ3Qgd29yay4gSW5zdGVhZCwgd2VcbiAgLy8gbmVlZCB0byByZW1vdmUgY29tcG9uZW50cyBmcm9tIHRoZSByb290IG9uZSBieSBvbmUsIHVudGlsIGVpdGhlciB3ZSBmaW5kXG4gIC8vIGEgcHJlZml4IHRoYXQgZml0cywgb3Igd2UgcnVuIG91dCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZS5cbiAgdmFyIGxldmVsID0gMDtcbiAgd2hpbGUgKGFQYXRoLmluZGV4T2YoYVJvb3QgKyAnLycpICE9PSAwKSB7XG4gICAgdmFyIGluZGV4ID0gYVJvb3QubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgb25seSBwYXJ0IG9mIHRoZSByb290IHRoYXQgaXMgbGVmdCBpcyB0aGUgc2NoZW1lIChpLmUuIGh0dHA6Ly8sXG4gICAgLy8gZmlsZTovLy8sIGV0Yy4pLCBvbmUgb3IgbW9yZSBzbGFzaGVzICgvKSwgb3Igc2ltcGx5IG5vdGhpbmcgYXQgYWxsLCB3ZVxuICAgIC8vIGhhdmUgZXhoYXVzdGVkIGFsbCBjb21wb25lbnRzLCBzbyB0aGUgcGF0aCBpcyBub3QgcmVsYXRpdmUgdG8gdGhlIHJvb3QuXG4gICAgYVJvb3QgPSBhUm9vdC5zbGljZSgwLCBpbmRleCk7XG4gICAgaWYgKGFSb290Lm1hdGNoKC9eKFteXFwvXSs6XFwvKT9cXC8qJC8pKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgKytsZXZlbDtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBhZGQgYSBcIi4uL1wiIGZvciBlYWNoIGNvbXBvbmVudCB3ZSByZW1vdmVkIGZyb20gdGhlIHJvb3QuXG4gIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4oXCIuLi9cIikgKyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSk7XG59XG5leHBvcnRzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG5cbnZhciBzdXBwb3J0c051bGxQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gISgnX19wcm90b19fJyBpbiBvYmopO1xufSgpKTtcblxuZnVuY3Rpb24gaWRlbnRpdHkgKHMpIHtcbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQmVjYXVzZSBiZWhhdmlvciBnb2VzIHdhY2t5IHdoZW4geW91IHNldCBgX19wcm90b19fYCBvbiBvYmplY3RzLCB3ZVxuICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL3B1bGwvMzEgYW5kXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5mdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMudG9TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogdG9TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiBhU3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLmZyb21TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogZnJvbVNldFN0cmluZztcblxuZnVuY3Rpb24gaXNQcm90b1N0cmluZyhzKSB7XG4gIGlmICghcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBzLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgOSAvKiBcIl9fcHJvdG9fX1wiLmxlbmd0aCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMSkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAyKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDMpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNCkgIT09IDExNiAvKiAndCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA1KSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDYpICE9PSAxMTQgLyogJ3InICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNykgIT09IDExMiAvKiAncCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA4KSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDkpICE9PSA5NSAgLyogJ18nICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDEwOyBpID49IDA7IGktLSkge1xuICAgIGlmIChzLmNoYXJDb2RlQXQoaSkgIT09IDM2IC8qICckJyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4sIGJ1dCBkaWZmZXJlbnQgZ2VuZXJhdGVkXG4gKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gIHZhciBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGRlZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBpbmRpY2VzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gKiBzb3VyY2UvbmFtZS9vcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYVxuICogbWFwcGluZyB3aXRoIGEgc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZDtcblxuZnVuY3Rpb24gc3RyY21wKGFTdHIxLCBhU3RyMikge1xuICBpZiAoYVN0cjEgPT09IGFTdHIyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoYVN0cjEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMTsgLy8gYVN0cjIgIT09IG51bGxcbiAgfVxuXG4gIGlmIChhU3RyMiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAtMTsgLy8gYVN0cjEgIT09IG51bGxcbiAgfVxuXG4gIGlmIChhU3RyMSA+IGFTdHIyKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGluZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBzdHJpbmdzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZDtcblxuLyoqXG4gKiBTdHJpcCBhbnkgSlNPTiBYU1NJIGF2b2lkYW5jZSBwcmVmaXggZnJvbSB0aGUgc3RyaW5nIChhcyBkb2N1bWVudGVkXG4gKiBpbiB0aGUgc291cmNlIG1hcHMgc3BlY2lmaWNhdGlvbiksIGFuZCB0aGVuIHBhcnNlIHRoZSBzdHJpbmcgYXNcbiAqIEpTT04uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU291cmNlTWFwSW5wdXQoc3RyKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKHN0ci5yZXBsYWNlKC9eXFwpXX0nW15cXG5dKlxcbi8sICcnKSk7XG59XG5leHBvcnRzLnBhcnNlU291cmNlTWFwSW5wdXQgPSBwYXJzZVNvdXJjZU1hcElucHV0O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIFVSTCBvZiBhIHNvdXJjZSBnaXZlbiB0aGUgdGhlIHNvdXJjZSByb290LCB0aGUgc291cmNlJ3NcbiAqIFVSTCwgYW5kIHRoZSBzb3VyY2UgbWFwJ3MgVVJMLlxuICovXG5mdW5jdGlvbiBjb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHNvdXJjZVVSTCwgc291cmNlTWFwVVJMKSB7XG4gIHNvdXJjZVVSTCA9IHNvdXJjZVVSTCB8fCAnJztcblxuICBpZiAoc291cmNlUm9vdCkge1xuICAgIC8vIFRoaXMgZm9sbG93cyB3aGF0IENocm9tZSBkb2VzLlxuICAgIGlmIChzb3VyY2VSb290W3NvdXJjZVJvb3QubGVuZ3RoIC0gMV0gIT09ICcvJyAmJiBzb3VyY2VVUkxbMF0gIT09ICcvJykge1xuICAgICAgc291cmNlUm9vdCArPSAnLyc7XG4gICAgfVxuICAgIC8vIFRoZSBzcGVjIHNheXM6XG4gICAgLy8gICBMaW5lIDQ6IEFuIG9wdGlvbmFsIHNvdXJjZSByb290LCB1c2VmdWwgZm9yIHJlbG9jYXRpbmcgc291cmNlXG4gICAgLy8gICBmaWxlcyBvbiBhIHNlcnZlciBvciByZW1vdmluZyByZXBlYXRlZCB2YWx1ZXMgaW4gdGhlXG4gICAgLy8gICDigJxzb3VyY2Vz4oCdIGVudHJ5LiAgVGhpcyB2YWx1ZSBpcyBwcmVwZW5kZWQgdG8gdGhlIGluZGl2aWR1YWxcbiAgICAvLyAgIGVudHJpZXMgaW4gdGhlIOKAnHNvdXJjZeKAnSBmaWVsZC5cbiAgICBzb3VyY2VVUkwgPSBzb3VyY2VSb290ICsgc291cmNlVVJMO1xuICB9XG5cbiAgLy8gSGlzdG9yaWNhbGx5LCBTb3VyY2VNYXBDb25zdW1lciBkaWQgbm90IHRha2UgdGhlIHNvdXJjZU1hcFVSTCBhc1xuICAvLyBhIHBhcmFtZXRlci4gIFRoaXMgbW9kZSBpcyBzdGlsbCBzb21ld2hhdCBzdXBwb3J0ZWQsIHdoaWNoIGlzIHdoeVxuICAvLyB0aGlzIGNvZGUgYmxvY2sgaXMgY29uZGl0aW9uYWwuICBIb3dldmVyLCBpdCdzIHByZWZlcmFibGUgdG8gcGFzc1xuICAvLyB0aGUgc291cmNlIG1hcCBVUkwgdG8gU291cmNlTWFwQ29uc3VtZXIsIHNvIHRoYXQgdGhpcyBmdW5jdGlvblxuICAvLyBjYW4gaW1wbGVtZW50IHRoZSBzb3VyY2UgVVJMIHJlc29sdXRpb24gYWxnb3JpdGhtIGFzIG91dGxpbmVkIGluXG4gIC8vIHRoZSBzcGVjLiAgVGhpcyBibG9jayBpcyBiYXNpY2FsbHkgdGhlIGVxdWl2YWxlbnQgb2Y6XG4gIC8vICAgIG5ldyBVUkwoc291cmNlVVJMLCBzb3VyY2VNYXBVUkwpLnRvU3RyaW5nKClcbiAgLy8gLi4uIGV4Y2VwdCBpdCBhdm9pZHMgdXNpbmcgVVJMLCB3aGljaCB3YXNuJ3QgYXZhaWxhYmxlIGluIHRoZVxuICAvLyBvbGRlciByZWxlYXNlcyBvZiBub2RlIHN0aWxsIHN1cHBvcnRlZCBieSB0aGlzIGxpYnJhcnkuXG4gIC8vXG4gIC8vIFRoZSBzcGVjIHNheXM6XG4gIC8vICAgSWYgdGhlIHNvdXJjZXMgYXJlIG5vdCBhYnNvbHV0ZSBVUkxzIGFmdGVyIHByZXBlbmRpbmcgb2YgdGhlXG4gIC8vICAg4oCcc291cmNlUm9vdOKAnSwgdGhlIHNvdXJjZXMgYXJlIHJlc29sdmVkIHJlbGF0aXZlIHRvIHRoZVxuICAvLyAgIFNvdXJjZU1hcCAobGlrZSByZXNvbHZpbmcgc2NyaXB0IHNyYyBpbiBhIGh0bWwgZG9jdW1lbnQpLlxuICBpZiAoc291cmNlTWFwVVJMKSB7XG4gICAgdmFyIHBhcnNlZCA9IHVybFBhcnNlKHNvdXJjZU1hcFVSTCk7XG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNvdXJjZU1hcFVSTCBjb3VsZCBub3QgYmUgcGFyc2VkXCIpO1xuICAgIH1cbiAgICBpZiAocGFyc2VkLnBhdGgpIHtcbiAgICAgIC8vIFN0cmlwIHRoZSBsYXN0IHBhdGggY29tcG9uZW50LCBidXQga2VlcCB0aGUgXCIvXCIuXG4gICAgICB2YXIgaW5kZXggPSBwYXJzZWQucGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgcGFyc2VkLnBhdGggPSBwYXJzZWQucGF0aC5zdWJzdHJpbmcoMCwgaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlVVJMID0gam9pbih1cmxHZW5lcmF0ZShwYXJzZWQpLCBzb3VyY2VVUkwpO1xuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZShzb3VyY2VVUkwpO1xufVxuZXhwb3J0cy5jb21wdXRlU291cmNlVVJMID0gY29tcHV0ZVNvdXJjZVVSTDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaGFzTmF0aXZlTWFwID0gdHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIjtcblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHdoaWNoIGlzIGEgY29tYmluYXRpb24gb2YgYW4gYXJyYXkgYW5kIGEgc2V0LiBBZGRpbmcgYSBuZXdcbiAqIG1lbWJlciBpcyBPKDEpLCB0ZXN0aW5nIGZvciBtZW1iZXJzaGlwIGlzIE8oMSksIGFuZCBmaW5kaW5nIHRoZSBpbmRleCBvZiBhblxuICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICogc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBtZW1iZXJzaGlwLlxuICovXG5mdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc2V0ID0gaGFzTmF0aXZlTWFwID8gbmV3IE1hcCgpIDogT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuLyoqXG4gKiBTdGF0aWMgbWV0aG9kIGZvciBjcmVhdGluZyBBcnJheVNldCBpbnN0YW5jZXMgZnJvbSBhbiBleGlzdGluZyBhcnJheS5cbiAqL1xuQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHNldDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhvdyBtYW55IHVuaXF1ZSBpdGVtcyBhcmUgaW4gdGhpcyBBcnJheVNldC4gSWYgZHVwbGljYXRlcyBoYXZlIGJlZW5cbiAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICpcbiAqIEByZXR1cm5zIE51bWJlclxuICovXG5BcnJheVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKSB7XG4gIHJldHVybiBoYXNOYXRpdmVNYXAgPyB0aGlzLl9zZXQuc2l6ZSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzU3RyID0gaGFzTmF0aXZlTWFwID8gYVN0ciA6IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIHZhciBpc0R1cGxpY2F0ZSA9IGhhc05hdGl2ZU1hcCA/IHRoaXMuaGFzKGFTdHIpIDogaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgfVxuICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgICAgdGhpcy5fc2V0LnNldChhU3RyLCBpZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRbc1N0cl0gPSBpZHg7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldC5oYXMoYVN0cik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB9XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIEFycmF5U2V0X2luZGV4T2YoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX3NldC5nZXQoYVN0cik7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFtzU3RyXTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICpcbiAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBBcnJheVNldF9hdChhSWR4KSB7XG4gIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICByZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTtcbn07XG5cbmV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2FycmF5LXNldC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICogcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIC8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICB2YXIgbGluZUEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgbGluZUIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgdmFyIGNvbHVtbkIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIHJldHVybiBsaW5lQiA+IGxpbmVBIHx8IGxpbmVCID09IGxpbmVBICYmIGNvbHVtbkIgPj0gY29sdW1uQSB8fFxuICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIDw9IDA7XG59XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICogcGVyZm9ybWFuY2UgY29uc2Npb3VzIG1hbm5lci4gSXQgdHJhZGVzIGEgbmVnbGliYWJsZSBvdmVyaGVhZCBpbiBnZW5lcmFsXG4gKiBjYXNlIGZvciBhIGxhcmdlIHNwZWVkdXAgaW4gY2FzZSBvZiBtYXBwaW5ncyBiZWluZyBhZGRlZCBpbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZ0xpc3QoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIC8vIFNlcnZlcyBhcyBpbmZpbXVtXG4gIHRoaXMuX2xhc3QgPSB7Z2VuZXJhdGVkTGluZTogLTEsIGdlbmVyYXRlZENvbHVtbjogMH07XG59XG5cbi8qKlxuICogSXRlcmF0ZSB0aHJvdWdoIGludGVybmFsIGl0ZW1zLiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgdGhhdFxuICogYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCB0YWtlcy5cbiAqXG4gKiBOT1RFOiBUaGUgb3JkZXIgb2YgdGhlIG1hcHBpbmdzIGlzIE5PVCBndWFyYW50ZWVkLlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudW5zb3J0ZWRGb3JFYWNoID1cbiAgZnVuY3Rpb24gTWFwcGluZ0xpc3RfZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKSB7XG4gICAgdGhpcy5fYXJyYXkuZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKTtcbiAgfTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHNvdXJjZSBtYXBwaW5nLlxuICpcbiAqIEBwYXJhbSBPYmplY3QgYU1hcHBpbmdcbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2FkZChhTWFwcGluZykge1xuICBpZiAoZ2VuZXJhdGVkUG9zaXRpb25BZnRlcih0aGlzLl9sYXN0LCBhTWFwcGluZykpIHtcbiAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmxhdCwgc29ydGVkIGFycmF5IG9mIG1hcHBpbmdzLiBUaGUgbWFwcGluZ3MgYXJlIHNvcnRlZCBieVxuICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICpcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHJldHVybnMgaW50ZXJuYWwgZGF0YSB3aXRob3V0IGNvcHlpbmcsIGZvclxuICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gKiBhbiBpbW11dGFibGUgYm9ycm93LiBJZiB5b3Ugd2FudCB0byB0YWtlIG93bmVyc2hpcCwgeW91IG11c3QgbWFrZSB5b3VyIG93blxuICogY29weS5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF90b0FycmF5KCkge1xuICBpZiAoIXRoaXMuX3NvcnRlZCkge1xuICAgIHRoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCk7XG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXk7XG59O1xuXG5leHBvcnRzLk1hcHBpbmdMaXN0ID0gTWFwcGluZ0xpc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9tYXBwaW5nLWxpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoJy4vYmluYXJ5LXNlYXJjaCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciBxdWlja1NvcnQgPSByZXF1aXJlKCcuL3F1aWNrLXNvcnQnKS5xdWlja1NvcnQ7XG5cbmZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICByZXR1cm4gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLCBhU291cmNlTWFwVVJMKVxuICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLCBhU291cmNlTWFwVVJMKTtcbn1cblxuU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKTtcbn1cblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4vLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3Ncbi8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4vLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4vL1xuLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbi8vXG4vLyAgICAge1xuLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2Zcbi8vICAgICAgICAgICAgIGNvZGUuXG4vLyAgICAgfVxuLy9cbi8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbi8vIGBudWxsYC5cbi8vXG4vLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuLy9cbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX2dlbmVyYXRlZE1hcHBpbmdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gIH1cbn0pO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19vcmlnaW5hbE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fY2hhcklzTWFwcGluZ1NlcGFyYXRvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgaW5kZXgpIHtcbiAgICB2YXIgYyA9IGFTdHIuY2hhckF0KGluZGV4KTtcbiAgICByZXR1cm4gYyA9PT0gXCI7XCIgfHwgYyA9PT0gXCIsXCI7XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBfcGFyc2VNYXBwaW5nc1wiKTtcbiAgfTtcblxuU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSID0gMTtcblNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBlYWNoIG1hcHBpbmcgYmV0d2VlbiBhbiBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4gYW5kIGFcbiAqIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKlxuICogQHBhcmFtIEZ1bmN0aW9uIGFDYWxsYmFja1xuICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGVhY2ggbWFwcGluZy5cbiAqIEBwYXJhbSBPYmplY3QgYUNvbnRleHRcbiAqICAgICAgICBPcHRpb25hbC4gSWYgc3BlY2lmaWVkLCB0aGlzIG9iamVjdCB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBgdGhpc2AgZXZlcnlcbiAqICAgICAgICB0aW1lIHRoYXQgYGFDYWxsYmFja2AgaXMgY2FsbGVkLlxuICogQHBhcmFtIGFPcmRlclxuICogICAgICAgIEVpdGhlciBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYCBvclxuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUmAuIFNwZWNpZmllcyB3aGV0aGVyIHlvdSB3YW50IHRvXG4gKiAgICAgICAgaXRlcmF0ZSBvdmVyIHRoZSBtYXBwaW5ncyBzb3J0ZWQgYnkgdGhlIGdlbmVyYXRlZCBmaWxlJ3MgbGluZS9jb2x1bW5cbiAqICAgICAgICBvcmRlciBvciB0aGUgb3JpZ2luYWwncyBzb3VyY2UvbGluZS9jb2x1bW4gb3JkZXIsIHJlc3BlY3RpdmVseS4gRGVmYXVsdHMgdG9cbiAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmVhY2hNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZWFjaE1hcHBpbmcoYUNhbGxiYWNrLCBhQ29udGV4dCwgYU9yZGVyKSB7XG4gICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgIHZhciBvcmRlciA9IGFPcmRlciB8fCBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI7XG5cbiAgICB2YXIgbWFwcGluZ3M7XG4gICAgc3dpdGNoIChvcmRlcikge1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSOlxuICAgICAgbWFwcGluZ3MgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcmRlciBvZiBpdGVyYXRpb24uXCIpO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5zb3VyY2VSb290O1xuICAgIG1hcHBpbmdzLm1hcChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlID09PSBudWxsID8gbnVsbCA6IHRoaXMuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgc291cmNlID0gdXRpbC5jb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICBuYW1lOiBtYXBwaW5nLm5hbWUgPT09IG51bGwgPyBudWxsIDogdGhpcy5fbmFtZXMuYXQobWFwcGluZy5uYW1lKVxuICAgICAgfTtcbiAgICB9LCB0aGlzKS5mb3JFYWNoKGFDYWxsYmFjaywgY29udGV4dCk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcHJvdmlkZWQuIElmIG5vIGNvbHVtbiBpcyBwcm92aWRlZCwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gYSBlaXRoZXIgdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3Igb3IgdGhlIG5leHRcbiAqIGNsb3Nlc3QgbGluZSB0aGF0IGhhcyBhbnkgbWFwcGluZ3MuIE90aGVyd2lzZSwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgYW5kIGVpdGhlciB0aGUgY29sdW1uIHdlIGFyZSBzZWFyY2hpbmcgZm9yXG4gKiBvciB0aGUgbmV4dCBjbG9zZXN0IGNvbHVtbiB0aGF0IGhhcyBhbnkgb2Zmc2V0cy5cbiAqXG4gKiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IE9wdGlvbmFsLiB0aGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpcyByZXR1cm5lZCwgZWFjaCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKSB7XG4gICAgdmFyIGxpbmUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKTtcblxuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gZXhhY3QgbWF0Y2gsIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZ1xuICAgIC8vIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IG1hcHBpbmcgbGVzcyB0aGFuIHRoZSBuZWVkbGUuIEJ5XG4gICAgLy8gc2V0dGluZyBuZWVkbGUub3JpZ2luYWxDb2x1bW4gdG8gMCwgd2UgdGh1cyBmaW5kIHRoZSBsYXN0IG1hcHBpbmcgZm9yXG4gICAgLy8gdGhlIGdpdmVuIGxpbmUsIHByb3ZpZGVkIHN1Y2ggYSBtYXBwaW5nIGV4aXN0cy5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpLFxuICAgICAgb3JpZ2luYWxMaW5lOiBsaW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJywgMClcbiAgICB9O1xuXG4gICAgbmVlZGxlLnNvdXJjZSA9IHRoaXMuX2ZpbmRTb3VyY2VJbmRleChuZWVkbGUuc291cmNlKTtcbiAgICBpZiAobmVlZGxlLnNvdXJjZSA8IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgbWFwcGluZ3MgPSBbXTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKG5lZWRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKGFBcmdzLmNvbHVtbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIGZvdW5kLiBTaW5jZVxuICAgICAgICAvLyBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGZvdW5kLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gb3JpZ2luYWxMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIHdlcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgLy8gU2luY2UgbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBsaW5lICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID09IG9yaWdpbmFsQ29sdW1uKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5ncztcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIEEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2ggd2UgY2FuXG4gKiBxdWVyeSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGZpbGUgcG9zaXRpb25zIGJ5IGdpdmluZyBpdCBhIGZpbGVcbiAqIHBvc2l0aW9uIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICpcbiAqIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAqIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIHNvdXJjZXM6IEFuIGFycmF5IG9mIFVSTHMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAqICAgLSBzb3VyY2VzQ29udGVudDogT3B0aW9uYWwuIEFuIGFycmF5IG9mIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKlxuICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAqXG4gKiAgICAge1xuICogICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICBmaWxlOiBcIm91dC5qc1wiLFxuICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICogICAgIH1cbiAqXG4gKiBUaGUgc2Vjb25kIHBhcmFtZXRlciwgaWYgZ2l2ZW4sIGlzIGEgc3RyaW5nIHdob3NlIHZhbHVlIGlzIHRoZSBVUkxcbiAqIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIHdhcyBmb3VuZC4gIFRoaXMgVVJMIGlzIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIHNvdXJjZXMgYXJyYXkuXG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQ/cGxpPTEjXG4gKi9cbmZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgLy8gU2FzcyAzLjMgbGVhdmVzIG91dCB0aGUgJ25hbWVzJyBhcnJheSwgc28gd2UgZGV2aWF0ZSBmcm9tIHRoZSBzcGVjICh3aGljaFxuICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgdmFyIHNvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gIHZhciBmaWxlID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnZmlsZScsIG51bGwpO1xuXG4gIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICBpZiAoc291cmNlUm9vdCkge1xuICAgIHNvdXJjZVJvb3QgPSB1dGlsLm5vcm1hbGl6ZShzb3VyY2VSb290KTtcbiAgfVxuXG4gIHNvdXJjZXMgPSBzb3VyY2VzXG4gICAgLm1hcChTdHJpbmcpXG4gICAgLy8gU29tZSBzb3VyY2UgbWFwcyBwcm9kdWNlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBsaWtlIFwiLi9mb28uanNcIiBpbnN0ZWFkIG9mXG4gICAgLy8gXCJmb28uanNcIi4gIE5vcm1hbGl6ZSB0aGVzZSBmaXJzdCBzbyB0aGF0IGZ1dHVyZSBjb21wYXJpc29ucyB3aWxsIHN1Y2NlZWQuXG4gICAgLy8gU2VlIGJ1Z3ppbC5sYS8xMDkwNzY4LlxuICAgIC5tYXAodXRpbC5ub3JtYWxpemUpXG4gICAgLy8gQWx3YXlzIGVuc3VyZSB0aGF0IGFic29sdXRlIHNvdXJjZXMgYXJlIGludGVybmFsbHkgc3RvcmVkIHJlbGF0aXZlIHRvXG4gICAgLy8gdGhlIHNvdXJjZSByb290LCBpZiB0aGUgc291cmNlIHJvb3QgaXMgYWJzb2x1dGUuIE5vdCBkb2luZyB0aGlzIHdvdWxkXG4gICAgLy8gYmUgcGFydGljdWxhcmx5IHByb2JsZW1hdGljIHdoZW4gdGhlIHNvdXJjZSByb290IGlzIGEgcHJlZml4IG9mIHRoZVxuICAgIC8vIHNvdXJjZSAodmFsaWQsIGJ1dCB3aHk/PykuIFNlZSBnaXRodWIgaXNzdWUgIzE5OSBhbmQgYnVnemlsLmxhLzExODg5ODIuXG4gICAgLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlUm9vdCAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlUm9vdCkgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZSlcbiAgICAgICAgPyB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZSlcbiAgICAgICAgOiBzb3VyY2U7XG4gICAgfSk7XG5cbiAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAvLyBhcmUgaW50ZW5kZWQgdG8gYmUgY29tcHJlc3NlZCBhbmQgZGVkdXBsaWNhdGVkLCB0aGUgVHlwZVNjcmlwdCBjb21waWxlclxuICAvLyBzb21ldGltZXMgZ2VuZXJhdGVzIHNvdXJjZSBtYXBzIHdpdGggZHVwbGljYXRlcyBpbiB0aGVtLiBTZWUgR2l0aHViIGlzc3VlXG4gIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgdGhpcy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkobmFtZXMubWFwKFN0cmluZyksIHRydWUpO1xuICB0aGlzLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KHNvdXJjZXMsIHRydWUpO1xuXG4gIHRoaXMuX2Fic29sdXRlU291cmNlcyA9IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgcywgYVNvdXJjZU1hcFVSTCk7XG4gIH0pO1xuXG4gIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgdGhpcy5fbWFwcGluZ3MgPSBtYXBwaW5ncztcbiAgdGhpcy5fc291cmNlTWFwVVJMID0gYVNvdXJjZU1hcFVSTDtcbiAgdGhpcy5maWxlID0gZmlsZTtcbn1cblxuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZmluZCB0aGUgaW5kZXggb2YgYSBzb3VyY2UuICBSZXR1cm5zIC0xIGlmIG5vdFxuICogZm91bmQuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kU291cmNlSW5kZXggPSBmdW5jdGlvbihhU291cmNlKSB7XG4gIHZhciByZWxhdGl2ZVNvdXJjZSA9IGFTb3VyY2U7XG4gIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgIHJlbGF0aXZlU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHJlbGF0aXZlU291cmNlKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9zb3VyY2VzLmhhcyhyZWxhdGl2ZVNvdXJjZSkpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlcy5pbmRleE9mKHJlbGF0aXZlU291cmNlKTtcbiAgfVxuXG4gIC8vIE1heWJlIGFTb3VyY2UgaXMgYW4gYWJzb2x1dGUgVVJMIGFzIHJldHVybmVkIGJ5IHxzb3VyY2VzfC4gIEluXG4gIC8vIHRoaXMgY2FzZSB3ZSBjYW4ndCBzaW1wbHkgdW5kbyB0aGUgdHJhbnNmb3JtLlxuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2Fic29sdXRlU291cmNlcy5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0aGlzLl9hYnNvbHV0ZVNvdXJjZXNbaV0gPT0gYVNvdXJjZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICogQHBhcmFtIFN0cmluZyBhU291cmNlTWFwVVJMXG4gKiAgICAgICAgVGhlIFVSTCBhdCB3aGljaCB0aGUgc291cmNlIG1hcCBjYW4gYmUgZm91bmQgKG9wdGlvbmFsKVxuICogQHJldHVybnMgQmFzaWNTb3VyY2VNYXBDb25zdW1lclxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgICB2YXIgc21jID0gT2JqZWN0LmNyZWF0ZShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICB2YXIgbmFtZXMgPSBzbWMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX25hbWVzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgdmFyIHNvdXJjZXMgPSBzbWMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fc291cmNlcy50b0FycmF5KCksIHRydWUpO1xuICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbWMuc291cmNlUm9vdCk7XG4gICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuICAgIHNtYy5fc291cmNlTWFwVVJMID0gYVNvdXJjZU1hcFVSTDtcbiAgICBzbWMuX2Fic29sdXRlU291cmNlcyA9IHNtYy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gdXRpbC5jb21wdXRlU291cmNlVVJMKHNtYy5zb3VyY2VSb290LCBzLCBhU291cmNlTWFwVVJMKTtcbiAgICB9KTtcblxuICAgIC8vIEJlY2F1c2Ugd2UgYXJlIG1vZGlmeWluZyB0aGUgZW50cmllcyAoYnkgY29udmVydGluZyBzdHJpbmcgc291cmNlcyBhbmRcbiAgICAvLyBuYW1lcyB0byBpbmRpY2VzIGludG8gdGhlIHNvdXJjZXMgYW5kIG5hbWVzIEFycmF5U2V0cyksIHdlIGhhdmUgdG8gbWFrZVxuICAgIC8vIGEgY29weSBvZiB0aGUgZW50cnkgb3IgZWxzZSBiYWQgdGhpbmdzIGhhcHBlbi4gU2hhcmVkIG11dGFibGUgc3RhdGVcbiAgICAvLyBzdHJpa2VzIGFnYWluISBTZWUgZ2l0aHViIGlzc3VlICMxOTEuXG5cbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy50b0FycmF5KCkuc2xpY2UoKTtcbiAgICB2YXIgZGVzdEdlbmVyYXRlZE1hcHBpbmdzID0gc21jLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZGVzdE9yaWdpbmFsTWFwcGluZ3MgPSBzbWMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzcmNNYXBwaW5nID0gZ2VuZXJhdGVkTWFwcGluZ3NbaV07XG4gICAgICB2YXIgZGVzdE1hcHBpbmcgPSBuZXcgTWFwcGluZztcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBzcmNNYXBwaW5nLmdlbmVyYXRlZExpbmU7XG4gICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBzcmNNYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKHNyY01hcHBpbmcuc291cmNlKSB7XG4gICAgICAgIGRlc3RNYXBwaW5nLnNvdXJjZSA9IHNvdXJjZXMuaW5kZXhPZihzcmNNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsTGluZSA9IHNyY01hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHNyY01hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgaWYgKHNyY01hcHBpbmcubmFtZSkge1xuICAgICAgICAgIGRlc3RNYXBwaW5nLm5hbWUgPSBuYW1lcy5pbmRleE9mKHNyY01hcHBpbmcubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0T3JpZ2luYWxNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICAgIH1cblxuICAgICAgZGVzdEdlbmVyYXRlZE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgIH1cblxuICAgIHF1aWNrU29ydChzbWMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcblxuICAgIHJldHVybiBzbWM7XG4gIH07XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fic29sdXRlU291cmNlcy5zbGljZSgpO1xuICB9XG59KTtcblxuLyoqXG4gKiBQcm92aWRlIHRoZSBKSVQgd2l0aCBhIG5pY2Ugc2hhcGUgLyBoaWRkZW4gY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmcoKSB7XG4gIHRoaXMuZ2VuZXJhdGVkTGluZSA9IDA7XG4gIHRoaXMuZ2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICB0aGlzLm9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB0aGlzLm5hbWUgPSBudWxsO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdmFyIGdlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gYVN0ci5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY2FjaGVkU2VnbWVudHMgPSB7fTtcbiAgICB2YXIgdGVtcCA9IHt9O1xuICAgIHZhciBvcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdmFyIG1hcHBpbmcsIHN0ciwgc2VnbWVudCwgZW5kLCB2YWx1ZTtcblxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJzsnKSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnLCcpIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtYXBwaW5nID0gbmV3IE1hcHBpbmcoKTtcbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gZ2VuZXJhdGVkTGluZTtcblxuICAgICAgICAvLyBCZWNhdXNlIGVhY2ggb2Zmc2V0IGlzIGVuY29kZWQgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIG9uZSxcbiAgICAgICAgLy8gbWFueSBzZWdtZW50cyBvZnRlbiBoYXZlIHRoZSBzYW1lIGVuY29kaW5nLiBXZSBjYW4gZXhwbG9pdCB0aGlzXG4gICAgICAgIC8vIGZhY3QgYnkgY2FjaGluZyB0aGUgcGFyc2VkIHZhcmlhYmxlIGxlbmd0aCBmaWVsZHMgb2YgZWFjaCBzZWdtZW50LFxuICAgICAgICAvLyBhbGxvd2luZyB1cyB0byBhdm9pZCBhIHNlY29uZCBwYXJzZSBpZiB3ZSBlbmNvdW50ZXIgdGhlIHNhbWVcbiAgICAgICAgLy8gc2VnbWVudCBhZ2Fpbi5cbiAgICAgICAgZm9yIChlbmQgPSBpbmRleDsgZW5kIDwgbGVuZ3RoOyBlbmQrKykge1xuICAgICAgICAgIGlmICh0aGlzLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGVuZCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBhU3RyLnNsaWNlKGluZGV4LCBlbmQpO1xuXG4gICAgICAgIHNlZ21lbnQgPSBjYWNoZWRTZWdtZW50c1tzdHJdO1xuICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgIGluZGV4ICs9IHN0ci5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VnbWVudCA9IFtdO1xuICAgICAgICAgIHdoaWxlIChpbmRleCA8IGVuZCkge1xuICAgICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShhU3RyLCBpbmRleCwgdGVtcCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICBpbmRleCA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIHNlZ21lbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlIGFuZCBsaW5lLCBidXQgbm8gY29sdW1uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FjaGVkU2VnbWVudHNbc3RyXSA9IHNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uICsgc2VnbWVudFswXTtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gcHJldmlvdXNTb3VyY2UgKyBzZWdtZW50WzFdO1xuICAgICAgICAgIHByZXZpb3VzU291cmNlICs9IHNlZ21lbnRbMV07XG5cbiAgICAgICAgICAvLyBPcmlnaW5hbCBsaW5lLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gcHJldmlvdXNPcmlnaW5hbExpbmUgKyBzZWdtZW50WzJdO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgLy8gTGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgKz0gMTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGNvbHVtbi5cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gcHJldmlvdXNPcmlnaW5hbENvbHVtbiArIHNlZ21lbnRbM107XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gcHJldmlvdXNOYW1lICsgc2VnbWVudFs0XTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSArPSBzZWdtZW50WzRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRlZE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgb3JpZ2luYWxNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KGdlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBnZW5lcmF0ZWRNYXBwaW5ncztcblxuICAgIHF1aWNrU29ydChvcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG9yaWdpbmFsTWFwcGluZ3M7XG4gIH07XG5cbi8qKlxuICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gKiB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpbiB0aGUgZ2l2ZW4gXCJoYXlzdGFja1wiIG9mIG1hcHBpbmdzLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9maW5kTWFwcGluZyhhTmVlZGxlLCBhTWFwcGluZ3MsIGFMaW5lTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbHVtbk5hbWUsIGFDb21wYXJhdG9yLCBhQmlhcykge1xuICAgIC8vIFRvIHJldHVybiB0aGUgcG9zaXRpb24gd2UgYXJlIHNlYXJjaGluZyBmb3IsIHdlIG11c3QgZmlyc3QgZmluZCB0aGVcbiAgICAvLyBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHRoZW4gcmV0dXJuIHRoZSBvcHBvc2l0ZSBwb3NpdGlvbiBpdFxuICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgLy8gZmluZCB0aGUgYmVzdCBtYXBwaW5nLlxuXG4gICAgaWYgKGFOZWVkbGVbYUxpbmVOYW1lXSA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthTGluZU5hbWVdKTtcbiAgICB9XG4gICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthQ29sdW1uTmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBiaW5hcnlTZWFyY2guc2VhcmNoKGFOZWVkbGUsIGFNYXBwaW5ncywgYUNvbXBhcmF0b3IsIGFCaWFzKTtcbiAgfTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gKiBpbmNsdXNpdmUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbXB1dGVDb2x1bW5TcGFucyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucygpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgLy8gTWFwcGluZ3MgZG8gbm90IGNvbnRhaW4gYSBmaWVsZCBmb3IgdGhlIGxhc3QgZ2VuZXJhdGVkIGNvbHVtbnQuIFdlXG4gICAgICAvLyBjYW4gY29tZSB1cCB3aXRoIGFuIG9wdGltaXN0aWMgZXN0aW1hdGUsIGhvd2V2ZXIsIGJ5IGFzc3VtaW5nIHRoYXRcbiAgICAgIC8vIG1hcHBpbmdzIGFyZSBjb250aWd1b3VzIChpLmUuIGdpdmVuIHR3byBjb25zZWN1dGl2ZSBtYXBwaW5ncywgdGhlXG4gICAgICAvLyBmaXJzdCBtYXBwaW5nIGVuZHMgd2hlcmUgdGhlIHNlY29uZCBvbmUgc3RhcnRzKS5cbiAgICAgIGlmIChpbmRleCArIDEgPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRNYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXggKyAxXTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgbGFzdCBtYXBwaW5nIGZvciBlYWNoIGxpbmUgc3BhbnMgdGhlIGVudGlyZSBsaW5lLlxuICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gSW5maW5pdHk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwodGhpcy5zb3VyY2VSb290LCBzb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpO1xuICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5hdChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIG5hbWU6IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoID49IHRoaXMuX3NvdXJjZXMuc2l6ZSgpICYmXG4gICAgICAhdGhpcy5zb3VyY2VzQ29udGVudC5zb21lKGZ1bmN0aW9uIChzYykgeyByZXR1cm4gc2MgPT0gbnVsbDsgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRTb3VyY2VJbmRleChhU291cmNlKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbaW5kZXhdO1xuICAgIH1cblxuICAgIHZhciByZWxhdGl2ZVNvdXJjZSA9IGFTb3VyY2U7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICByZWxhdGl2ZVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCByZWxhdGl2ZVNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIHVybDtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGxcbiAgICAgICAgJiYgKHVybCA9IHV0aWwudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpIHtcbiAgICAgIC8vIFhYWDogZmlsZTovLyBVUklzIGFuZCBhYnNvbHV0ZSBwYXRocyBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yXG4gICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgLy8gYmVoYXZlIGxpa2UgaXQgd291bGQgaWYgdGhleSB3ZXJlIHJ1bm5pbmcgYSBsb2NhbCBIVFRQIHNlcnZlci4gU2VlXG4gICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODU1OTcuXG4gICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSByZWxhdGl2ZVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICB9XG5cbiAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgcmVsYXRpdmVTb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIiArIHJlbGF0aXZlU291cmNlKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IGZyb21cbiAgICAvLyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IuIEluIHRoYXQgY2FzZSwgd2VcbiAgICAvLyBkb24ndCB3YW50IHRvIHRocm93IGlmIHdlIGNhbid0IGZpbmQgdGhlIHNvdXJjZSAtIHdlIGp1c3Qgd2FudCB0b1xuICAgIC8vIHJldHVybiBudWxsLCBzbyB3ZSBwcm92aWRlIGEgZmxhZyB0byBleGl0IGdyYWNlZnVsbHkuXG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgcmVsYXRpdmVTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyk7XG4gICAgc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KHNvdXJjZSk7XG4gICAgaWYgKHNvdXJjZSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gbmVlZGxlLnNvdXJjZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbmV4cG9ydHMuQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IEJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICogaW5wdXQuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyBhIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3IgYWxyZWFkeVxuICogcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYyBmb3IgaW5kZXhlZCBzb3VyY2UgbWFwcywgdGhleVxuICogaGF2ZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICogICAtIHNlY3Rpb25zOiBBIGxpc3Qgb2Ygc2VjdGlvbiBkZWZpbml0aW9ucy5cbiAqXG4gKiBFYWNoIHZhbHVlIHVuZGVyIHRoZSBcInNlY3Rpb25zXCIgZmllbGQgaGFzIHR3byBmaWVsZHM6XG4gKiAgIC0gb2Zmc2V0OiBUaGUgb2Zmc2V0IGludG8gdGhlIG9yaWdpbmFsIHNwZWNpZmllZCBhdCB3aGljaCB0aGlzIHNlY3Rpb25cbiAqICAgICAgIGJlZ2lucyB0byBhcHBseSwgZGVmaW5lZCBhcyBhbiBvYmplY3Qgd2l0aCBhIFwibGluZVwiIGFuZCBcImNvbHVtblwiXG4gKiAgICAgICBmaWVsZC5cbiAqICAgLSBtYXA6IEEgc291cmNlIG1hcCBkZWZpbml0aW9uLiBUaGlzIHNvdXJjZSBtYXAgY291bGQgYWxzbyBiZSBpbmRleGVkLFxuICogICAgICAgYnV0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbiAqXG4gKiBJbnN0ZWFkIG9mIHRoZSBcIm1hcFwiIGZpZWxkLCBpdCdzIGFsc28gcG9zc2libGUgdG8gaGF2ZSBhIFwidXJsXCIgZmllbGRcbiAqIHNwZWNpZnlpbmcgYSBVUkwgdG8gcmV0cmlldmUgYSBzb3VyY2UgbWFwIGZyb20sIGJ1dCB0aGF0J3MgY3VycmVudGx5XG4gKiB1bnN1cHBvcnRlZC5cbiAqXG4gKiBIZXJlJ3MgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF0sIGJ1dFxuICogbW9kaWZpZWQgdG8gb21pdCBhIHNlY3Rpb24gd2hpY2ggdXNlcyB0aGUgXCJ1cmxcIiBmaWVsZC5cbiAqXG4gKiAge1xuICogICAgdmVyc2lvbiA6IDMsXG4gKiAgICBmaWxlOiBcImFwcC5qc1wiLFxuICogICAgc2VjdGlvbnM6IFt7XG4gKiAgICAgIG9mZnNldDoge2xpbmU6MTAwLCBjb2x1bW46MTB9LFxuICogICAgICBtYXA6IHtcbiAqICAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgICBmaWxlOiBcInNlY3Rpb24uanNcIixcbiAqICAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICAgbWFwcGluZ3M6IFwiQUFBQSxFOztBQkNERTtcIlxuICogICAgICB9XG4gKiAgICB9XSxcbiAqICB9XG4gKlxuICogVGhlIHNlY29uZCBwYXJhbWV0ZXIsIGlmIGdpdmVuLCBpcyBhIHN0cmluZyB3aG9zZSB2YWx1ZSBpcyB0aGUgVVJMXG4gKiBhdCB3aGljaCB0aGUgc291cmNlIG1hcCB3YXMgZm91bmQuICBUaGlzIFVSTCBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlXG4gKiBzb3VyY2VzIGFycmF5LlxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0I2hlYWRpbmc9aC41MzVlczN4ZXByZ3RcbiAqL1xuZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgdmFyIHNlY3Rpb25zID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc2VjdGlvbnMnKTtcblxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgdmFyIGxhc3RPZmZzZXQgPSB7XG4gICAgbGluZTogLTEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHRoaXMuX3NlY3Rpb25zID0gc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMudXJsKSB7XG4gICAgICAvLyBUaGUgdXJsIGZpZWxkIHdpbGwgcmVxdWlyZSBzdXBwb3J0IGZvciBhc3luY2hyb25pY2l0eS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8xNlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciB1cmwgZmllbGQgaW4gc2VjdGlvbnMgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gdXRpbC5nZXRBcmcocywgJ29mZnNldCcpO1xuICAgIHZhciBvZmZzZXRMaW5lID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnbGluZScpO1xuICAgIHZhciBvZmZzZXRDb2x1bW4gPSB1dGlsLmdldEFyZyhvZmZzZXQsICdjb2x1bW4nKTtcblxuICAgIGlmIChvZmZzZXRMaW5lIDwgbGFzdE9mZnNldC5saW5lIHx8XG4gICAgICAgIChvZmZzZXRMaW5lID09PSBsYXN0T2Zmc2V0LmxpbmUgJiYgb2Zmc2V0Q29sdW1uIDwgbGFzdE9mZnNldC5jb2x1bW4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3Rpb24gb2Zmc2V0cyBtdXN0IGJlIG9yZGVyZWQgYW5kIG5vbi1vdmVybGFwcGluZy4nKTtcbiAgICB9XG4gICAgbGFzdE9mZnNldCA9IG9mZnNldDtcblxuICAgIHJldHVybiB7XG4gICAgICBnZW5lcmF0ZWRPZmZzZXQ6IHtcbiAgICAgICAgLy8gVGhlIG9mZnNldCBmaWVsZHMgYXJlIDAtYmFzZWQsIGJ1dCB3ZSB1c2UgMS1iYXNlZCBpbmRpY2VzIHdoZW5cbiAgICAgICAgLy8gZW5jb2RpbmcvZGVjb2RpbmcgZnJvbSBWTFEuXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG9mZnNldExpbmUgKyAxLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG9mZnNldENvbHVtbiArIDFcbiAgICAgIH0sXG4gICAgICBjb25zdW1lcjogbmV3IFNvdXJjZU1hcENvbnN1bWVyKHV0aWwuZ2V0QXJnKHMsICdtYXAnKSwgYVNvdXJjZU1hcFVSTClcbiAgICB9XG4gIH0pO1xufVxuXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBzb3VyY2VzLnB1c2godGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VzO1xuICB9XG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbiB3ZSdyZSB0cnlpbmcgdG8gbWFwXG4gICAgLy8gdG8gYW4gb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgdmFyIHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uKG5lZWRsZSwgc2VjdGlvbikge1xuICAgICAgICB2YXIgY21wID0gbmVlZGxlLmdlbmVyYXRlZExpbmUgLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIH0pO1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgIGlmICghc2VjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICBsaW5lOiBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmVcbiAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgOiAwKSxcbiAgICAgIGJpYXM6IGFBcmdzLmJpYXNcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTtcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIHZhciBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuIFxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIC8vIE9ubHkgY29uc2lkZXIgdGhpcyBzZWN0aW9uIGlmIHRoZSByZXF1ZXN0ZWQgc291cmNlIGlzIGluIHRoZSBsaXN0IG9mXG4gICAgICAvLyBzb3VyY2VzIG9mIHRoZSBjb25zdW1lci5cbiAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLl9maW5kU291cmNlSW5kZXgodXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSkgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7XG4gICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWRQb3NpdGlvbi5jb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmVcbiAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICA6IDApXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgdmFyIHNlY3Rpb25NYXBwaW5ncyA9IHNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBzZWN0aW9uTWFwcGluZ3Nbal07XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IHNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290LCBzb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgICAgIHZhciBuYW1lID0gbnVsbDtcbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSkge1xuICAgICAgICAgIG5hbWUgPSBzZWN0aW9uLmNvbnN1bWVyLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBtYXBwaW5ncyBjb21pbmcgZnJvbSB0aGUgY29uc3VtZXIgZm9yIHRoZSBzZWN0aW9uIGhhdmVcbiAgICAgICAgLy8gZ2VuZXJhdGVkIHBvc2l0aW9ucyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNlY3Rpb24sIHNvIHdlXG4gICAgICAgIC8vIG5lZWQgdG8gb2Zmc2V0IHRoZW0gdG8gYmUgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb25jYXRlbmF0ZWRcbiAgICAgICAgLy8gZ2VuZXJhdGVkIGZpbGUuXG4gICAgICAgIHZhciBhZGp1c3RlZE1hcHBpbmcgPSB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbWFwcGluZy5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgIDogMCksXG4gICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhZGp1c3RlZE1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHF1aWNrU29ydCh0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHF1aWNrU29ydCh0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gIH07XG5cbmV4cG9ydHMuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyID0gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvc291cmNlLW1hcC1jb25zdW1lci5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbmV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gKlxuICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gIC8vXG4gIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gIC8vXG4gIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gIC8vXG4gIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gIC8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbiAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gIGlmIChjbXAgPT09IDApIHtcbiAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgcmV0dXJuIG1pZDtcbiAgfVxuICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZXhhY3QgbmVlZGxlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZCBpbiB0aGlzIGhheXN0YWNrLiBEZXRlcm1pbmUgaWZcbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gYUhpZ2ggPCBhSGF5c3RhY2subGVuZ3RoID8gYUhpZ2ggOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBsZXNzIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFMb3cgPCAwID8gLTEgOiBhTG93O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICogdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzIGJlY2F1c2VcbiAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gKiB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gKlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqL1xuZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB2YXIgaW5kZXggPSByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb21wYXJlLCBhQmlhcyB8fCBleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIFdlIGhhdmUgZm91bmQgZWl0aGVyIHRoZSBleGFjdCBlbGVtZW50LCBvciB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQgdGhhblxuICAvLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoXG4gIC8vIGVsZW1lbnQuIE1ha2Ugc3VyZSB3ZSBhbHdheXMgcmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0aGVzZS5cbiAgd2hpbGUgKGluZGV4IC0gMSA+PSAwKSB7XG4gICAgaWYgKGFDb21wYXJlKGFIYXlzdGFja1tpbmRleF0sIGFIYXlzdGFja1tpbmRleCAtIDFdLCB0cnVlKSAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC0taW5kZXg7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvYmluYXJ5LXNlYXJjaC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8vIEl0IHR1cm5zIG91dCB0aGF0IHNvbWUgKG1vc3Q/KSBKYXZhU2NyaXB0IGVuZ2luZXMgZG9uJ3Qgc2VsZi1ob3N0XG4vLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgLiBUaGlzIG1ha2VzIHNlbnNlIGJlY2F1c2UgQysrIHdpbGwgbGlrZWx5IHJlbWFpblxuLy8gZmFzdGVyIHRoYW4gSlMgd2hlbiBkb2luZyByYXcgQ1BVLWludGVuc2l2ZSBzb3J0aW5nLiBIb3dldmVyLCB3aGVuIHVzaW5nIGFcbi8vIGN1c3RvbSBjb21wYXJhdG9yIGZ1bmN0aW9uLCBjYWxsaW5nIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGhlIFZNJ3MgQysrIGFuZFxuLy8gSklUJ2QgSlMgaXMgcmF0aGVyIHNsb3cgKmFuZCogbG9zZXMgSklUIHR5cGUgaW5mb3JtYXRpb24sIHJlc3VsdGluZyBpblxuLy8gd29yc2UgZ2VuZXJhdGVkIGNvZGUgZm9yIHRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYW4gd291bGQgYmUgb3B0aW1hbC4gSW5cbi8vIGZhY3QsIHdoZW4gc29ydGluZyB3aXRoIGEgY29tcGFyYXRvciwgdGhlc2UgY29zdHMgb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIG9mXG4vLyBzb3J0aW5nIGluIEMrKy4gQnkgdXNpbmcgb3VyIG93biBKUy1pbXBsZW1lbnRlZCBRdWljayBTb3J0IChiZWxvdyksIHdlIGdldFxuLy8gYSB+MzUwMG1zIG1lYW4gc3BlZWQtdXAgaW4gYGJlbmNoL2JlbmNoLmh0bWxgLlxuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnRzIGluZGV4ZWQgYnkgYHhgIGFuZCBgeWAgaW4gdGhlIGFycmF5IGBhcnlgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIFRoZSBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLlxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHNlY29uZCBpdGVtLlxuICovXG5mdW5jdGlvbiBzd2FwKGFyeSwgeCwgeSkge1xuICB2YXIgdGVtcCA9IGFyeVt4XTtcbiAgYXJ5W3hdID0gYXJ5W3ldO1xuICBhcnlbeV0gPSB0ZW1wO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIGBsb3cgLi4gaGlnaGAgaW5jbHVzaXZlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dcbiAqICAgICAgICBUaGUgbG93ZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2hcbiAqICAgICAgICBUaGUgdXBwZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICovXG5mdW5jdGlvbiByYW5kb21JbnRJblJhbmdlKGxvdywgaGlnaCkge1xuICByZXR1cm4gTWF0aC5yb3VuZChsb3cgKyAoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KSkpO1xufVxuXG4vKipcbiAqIFRoZSBRdWljayBTb3J0IGFsZ29yaXRobS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwXG4gKiAgICAgICAgU3RhcnQgaW5kZXggb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gclxuICogICAgICAgIEVuZCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqL1xuZnVuY3Rpb24gZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCByKSB7XG4gIC8vIElmIG91ciBsb3dlciBib3VuZCBpcyBsZXNzIHRoYW4gb3VyIHVwcGVyIGJvdW5kLCB3ZSAoMSkgcGFydGl0aW9uIHRoZVxuICAvLyBhcnJheSBpbnRvIHR3byBwaWVjZXMgYW5kICgyKSByZWN1cnNlIG9uIGVhY2ggaGFsZi4gSWYgaXQgaXMgbm90LCB0aGlzIGlzXG4gIC8vIHRoZSBlbXB0eSBhcnJheSBhbmQgb3VyIGJhc2UgY2FzZS5cblxuICBpZiAocCA8IHIpIHtcbiAgICAvLyAoMSkgUGFydGl0aW9uaW5nLlxuICAgIC8vXG4gICAgLy8gVGhlIHBhcnRpdGlvbmluZyBjaG9vc2VzIGEgcGl2b3QgYmV0d2VlbiBgcGAgYW5kIGByYCBhbmQgbW92ZXMgYWxsXG4gICAgLy8gZWxlbWVudHMgdGhhdCBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdCB0byB0aGUgYmVmb3JlIGl0LCBhbmRcbiAgICAvLyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgYXJlIGdyZWF0ZXIgdGhhbiBpdCBhZnRlciBpdC4gVGhlIGVmZmVjdCBpcyB0aGF0XG4gICAgLy8gb25jZSBwYXJ0aXRpb24gaXMgZG9uZSwgdGhlIHBpdm90IGlzIGluIHRoZSBleGFjdCBwbGFjZSBpdCB3aWxsIGJlIHdoZW5cbiAgICAvLyB0aGUgYXJyYXkgaXMgcHV0IGluIHNvcnRlZCBvcmRlciwgYW5kIGl0IHdpbGwgbm90IG5lZWQgdG8gYmUgbW92ZWRcbiAgICAvLyBhZ2Fpbi4gVGhpcyBydW5zIGluIE8obikgdGltZS5cblxuICAgIC8vIEFsd2F5cyBjaG9vc2UgYSByYW5kb20gcGl2b3Qgc28gdGhhdCBhbiBpbnB1dCBhcnJheSB3aGljaCBpcyByZXZlcnNlXG4gICAgLy8gc29ydGVkIGRvZXMgbm90IGNhdXNlIE8obl4yKSBydW5uaW5nIHRpbWUuXG4gICAgdmFyIHBpdm90SW5kZXggPSByYW5kb21JbnRJblJhbmdlKHAsIHIpO1xuICAgIHZhciBpID0gcCAtIDE7XG5cbiAgICBzd2FwKGFyeSwgcGl2b3RJbmRleCwgcik7XG4gICAgdmFyIHBpdm90ID0gYXJ5W3JdO1xuXG4gICAgLy8gSW1tZWRpYXRlbHkgYWZ0ZXIgYGpgIGlzIGluY3JlbWVudGVkIGluIHRoaXMgbG9vcCwgdGhlIGZvbGxvd2luZyBob2xkXG4gICAgLy8gdHJ1ZTpcbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbcCAuLiBpXWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdC5cbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbaSsxIC4uIGotMV1gIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcGl2b3QuXG4gICAgZm9yICh2YXIgaiA9IHA7IGogPCByOyBqKyspIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFyeVtqXSwgcGl2b3QpIDw9IDApIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBzd2FwKGFyeSwgaSwgaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dhcChhcnksIGkgKyAxLCBqKTtcbiAgICB2YXIgcSA9IGkgKyAxO1xuXG4gICAgLy8gKDIpIFJlY3Vyc2Ugb24gZWFjaCBoYWxmLlxuXG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCBxIC0gMSk7XG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBxICsgMSwgcik7XG4gIH1cbn1cblxuLyoqXG4gKiBTb3J0IHRoZSBnaXZlbiBhcnJheSBpbi1wbGFjZSB3aXRoIHRoZSBnaXZlbiBjb21wYXJhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICovXG5leHBvcnRzLnF1aWNrU29ydCA9IGZ1bmN0aW9uIChhcnksIGNvbXBhcmF0b3IpIHtcbiAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCAwLCBhcnkubGVuZ3RoIC0gMSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvcXVpY2stc29ydC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLy8gTWF0Y2hlcyBhIFdpbmRvd3Mtc3R5bGUgYFxcclxcbmAgbmV3bGluZSBvciBhIGBcXG5gIG5ld2xpbmUgdXNlZCBieSBhbGwgb3RoZXJcbi8vIG9wZXJhdGluZyBzeXN0ZW1zIHRoZXNlIGRheXMgKGNhcHR1cmluZyB0aGUgcmVzdWx0KS5cbnZhciBSRUdFWF9ORVdMSU5FID0gLyhcXHI/XFxuKS87XG5cbi8vIE5ld2xpbmUgY2hhcmFjdGVyIGNvZGUgZm9yIGNoYXJDb2RlQXQoKSBjb21wYXJpc29uc1xudmFyIE5FV0xJTkVfQ09ERSA9IDEwO1xuXG4vLyBQcml2YXRlIHN5bWJvbCBmb3IgaWRlbnRpZnlpbmcgYFNvdXJjZU5vZGVgcyB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mXG4vLyB0aGUgc291cmNlLW1hcCBsaWJyYXJ5IGFyZSBsb2FkZWQuIFRoaXMgTVVTVCBOT1QgQ0hBTkdFIGFjcm9zc1xuLy8gdmVyc2lvbnMhXG52YXIgaXNTb3VyY2VOb2RlID0gXCIkJCRpc1NvdXJjZU5vZGUkJCRcIjtcblxuLyoqXG4gKiBTb3VyY2VOb2RlcyBwcm92aWRlIGEgd2F5IHRvIGFic3RyYWN0IG92ZXIgaW50ZXJwb2xhdGluZy9jb25jYXRlbmF0aW5nXG4gKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAqIGNvbHVtbiBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gKiBAcGFyYW0gYUNvbHVtbiBUaGUgb3JpZ2luYWwgY29sdW1uIG51bWJlci5cbiAqIEBwYXJhbSBhU291cmNlIFRoZSBvcmlnaW5hbCBzb3VyY2UncyBmaWxlbmFtZS5cbiAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICogICAgICAgIGdlbmVyYXRlZCBKUywgb3Igb3RoZXIgU291cmNlTm9kZXMuXG4gKiBAcGFyYW0gYU5hbWUgVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU5vZGUoYUxpbmUsIGFDb2x1bW4sIGFTb3VyY2UsIGFDaHVua3MsIGFOYW1lKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICB0aGlzLmxpbmUgPSBhTGluZSA9PSBudWxsID8gbnVsbCA6IGFMaW5lO1xuICB0aGlzLmNvbHVtbiA9IGFDb2x1bW4gPT0gbnVsbCA/IG51bGwgOiBhQ29sdW1uO1xuICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT0gbnVsbCA/IG51bGwgOiBhU291cmNlO1xuICB0aGlzLm5hbWUgPSBhTmFtZSA9PSBudWxsID8gbnVsbCA6IGFOYW1lO1xuICB0aGlzW2lzU291cmNlTm9kZV0gPSB0cnVlO1xuICBpZiAoYUNodW5rcyAhPSBudWxsKSB0aGlzLmFkZChhQ2h1bmtzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgU291cmNlTm9kZSBmcm9tIGdlbmVyYXRlZCBjb2RlIGFuZCBhIFNvdXJjZU1hcENvbnN1bWVyLlxuICpcbiAqIEBwYXJhbSBhR2VuZXJhdGVkQ29kZSBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVJlbGF0aXZlUGF0aCBPcHRpb25hbC4gVGhlIHBhdGggdGhhdCByZWxhdGl2ZSBzb3VyY2VzIGluIHRoZVxuICogICAgICAgIFNvdXJjZU1hcENvbnN1bWVyIHNob3VsZCBiZSByZWxhdGl2ZSB0by5cbiAqL1xuU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAoYUdlbmVyYXRlZENvZGUsIGFTb3VyY2VNYXBDb25zdW1lciwgYVJlbGF0aXZlUGF0aCkge1xuICAgIC8vIFRoZSBTb3VyY2VOb2RlIHdlIHdhbnQgdG8gZmlsbCB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgIC8vIGFuZCB0aGUgU291cmNlTWFwXG4gICAgdmFyIG5vZGUgPSBuZXcgU291cmNlTm9kZSgpO1xuXG4gICAgLy8gQWxsIGV2ZW4gaW5kaWNlcyBvZiB0aGlzIGFycmF5IGFyZSBvbmUgbGluZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gICAgLy8gd2hpbGUgYWxsIG9kZCBpbmRpY2VzIGFyZSB0aGUgbmV3bGluZXMgYmV0d2VlbiB0d28gYWRqYWNlbnQgbGluZXNcbiAgICAvLyAoc2luY2UgYFJFR0VYX05FV0xJTkVgIGNhcHR1cmVzIGl0cyBtYXRjaCkuXG4gICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgYWNjZXNzZWQgYnkgY2FsbGluZyBgc2hpZnROZXh0TGluZWAuXG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzSW5kZXggPSAwO1xuICAgIHZhciBzaGlmdE5leHRMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZUNvbnRlbnRzID0gZ2V0TmV4dExpbmUoKTtcbiAgICAgIC8vIFRoZSBsYXN0IGxpbmUgb2YgYSBmaWxlIG1pZ2h0IG5vdCBoYXZlIGEgbmV3bGluZS5cbiAgICAgIHZhciBuZXdMaW5lID0gZ2V0TmV4dExpbmUoKSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIGxpbmVDb250ZW50cyArIG5ld0xpbmU7XG5cbiAgICAgIGZ1bmN0aW9uIGdldE5leHRMaW5lKCkge1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nTGluZXNJbmRleCA8IHJlbWFpbmluZ0xpbmVzLmxlbmd0aCA/XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4KytdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiBcInJlbWFpbmluZ0xpbmVzXCJcbiAgICB2YXIgbGFzdEdlbmVyYXRlZExpbmUgPSAxLCBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcblxuICAgIC8vIFRoZSBnZW5lcmF0ZSBTb3VyY2VOb2RlcyB3ZSBuZWVkIGEgY29kZSByYW5nZS5cbiAgICAvLyBUbyBleHRyYWN0IGl0IGN1cnJlbnQgYW5kIGxhc3QgbWFwcGluZyBpcyB1c2VkLlxuICAgIC8vIEhlcmUgd2Ugc3RvcmUgdGhlIGxhc3QgbWFwcGluZy5cbiAgICB2YXIgbGFzdE1hcHBpbmcgPSBudWxsO1xuXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobGFzdE1hcHBpbmcgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UgYWRkIHRoZSBjb2RlIGZyb20gXCJsYXN0TWFwcGluZ1wiIHRvIFwibWFwcGluZ1wiOlxuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgIGlmIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIC8vIEFzc29jaWF0ZSBmaXJzdCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyBjb2RlIGlzIGFkZGVkIHdpdGhvdXQgbWFwcGluZ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSBjb2RlIGJldHdlZW4gXCJsYXN0R2VuZXJhdGVkQ29sdW1uXCIgYW5kXG4gICAgICAgICAgLy8gXCJtYXBwaW5nLmdlbmVyYXRlZENvbHVtblwiIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gfHwgJyc7XG4gICAgICAgICAgdmFyIGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBjb2RlKTtcbiAgICAgICAgICAvLyBObyBtb3JlIHJlbWFpbmluZyBjb2RlLCBjb250aW51ZVxuICAgICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlIGFkZCB0aGUgZ2VuZXJhdGVkIGNvZGUgdW50aWwgdGhlIGZpcnN0IG1hcHBpbmdcbiAgICAgIC8vIHRvIHRoZSBTb3VyY2VOb2RlIHdpdGhvdXQgYW55IG1hcHBpbmcuXG4gICAgICAvLyBFYWNoIGxpbmUgaXMgYWRkZWQgYXMgc2VwYXJhdGUgc3RyaW5nLlxuICAgICAgd2hpbGUgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIG5vZGUuYWRkKHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICB9XG4gICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdIHx8ICcnO1xuICAgICAgICBub2RlLmFkZChuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pKTtcbiAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICB9XG4gICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgfSwgdGhpcyk7XG4gICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG1hcHBpbmdzLlxuICAgIGlmIChyZW1haW5pbmdMaW5lc0luZGV4IDwgcmVtYWluaW5nTGluZXMubGVuZ3RoKSB7XG4gICAgICBpZiAobGFzdE1hcHBpbmcpIHtcbiAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSByZW1haW5pbmcgY29kZSBpbiB0aGUgY3VycmVudCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgIH1cbiAgICAgIC8vIGFuZCBhZGQgdGhlIHJlbWFpbmluZyBsaW5lcyB3aXRob3V0IGFueSBtYXBwaW5nXG4gICAgICBub2RlLmFkZChyZW1haW5pbmdMaW5lcy5zcGxpY2UocmVtYWluaW5nTGluZXNJbmRleCkuam9pbihcIlwiKSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVJlbGF0aXZlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9kZTtcblxuICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICBpZiAobWFwcGluZyA9PT0gbnVsbCB8fCBtYXBwaW5nLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFSZWxhdGl2ZVBhdGhcbiAgICAgICAgICA/IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICA6IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGFDaHVuaykge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gU291cmNlTm9kZV9wcmVwZW5kKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMucHJlcGVuZChhQ2h1bmtbaV0pO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgSlMgc25pcHBldHMgaW4gdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFRoZVxuICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2FsayhhRm4pIHtcbiAgdmFyIGNodW5rO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNodW5rID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICBpZiAoY2h1bmtbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgY2h1bmsud2FsayhhRm4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICpcbiAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCkge1xuICB2YXIgbmV3Q2hpbGRyZW47XG4gIHZhciBpO1xuICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuLTE7IGkrKykge1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgfVxuICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gKlxuICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHRoaXMuc291cmNlQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhhU291cmNlRmlsZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gIH07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIFNvdXJjZU5vZGVzLiBUaGUgd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2hcbiAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV93YWxrU291cmNlQ29udGVudHMoYUZuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhRm4odXRpbC5mcm9tU2V0U3RyaW5nKHNvdXJjZXNbaV0pLCB0aGlzLnNvdXJjZUNvbnRlbnRzW3NvdXJjZXNbaV1dKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHN0ciArPSBjaHVuaztcbiAgfSk7XG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlIGFsb25nIHdpdGggYSBzb3VyY2VcbiAqIG1hcC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZ1dpdGhTb3VyY2VNYXAoYUFyZ3MpIHtcbiAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICBjb2RlOiBcIlwiLFxuICAgIGxpbmU6IDEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHZhciBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKTtcbiAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaywgb3JpZ2luYWwpIHtcbiAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmxpbmUgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTGluZSAhPT0gb3JpZ2luYWwubGluZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgIGxhc3RPcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IGNodW5rLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgIGdlbmVyYXRlZC5saW5lKys7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4gPSAwO1xuICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgIGlmIChpZHggKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdGhpcy53YWxrU291cmNlQ29udGVudHMoZnVuY3Rpb24gKHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpIHtcbiAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgY29kZTogZ2VuZXJhdGVkLmNvZGUsIG1hcDogbWFwIH07XG59O1xuXG5leHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvc291cmNlLW5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=</span></pre>
</body>
</html>