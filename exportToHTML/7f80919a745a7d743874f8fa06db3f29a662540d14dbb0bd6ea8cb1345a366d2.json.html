<html>
<head>
<title>7f80919a745a7d743874f8fa06db3f29a662540d14dbb0bd6ea8cb1345a366d2.json</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #cf8e6d;}
.s3 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
7f80919a745a7d743874f8fa06db3f29a662540d14dbb0bd6ea8cb1345a366d2.json</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;ast&quot;</span><span class="s0">:</span><span class="s2">null</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">:</span><span class="s1">&quot;import </span><span class="s2">\&quot;</span><span class="s1">core-js/modules/es.array.push.js</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import </span><span class="s2">\&quot;</span><span class="s1">core-js/modules/es.array.unshift.js</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">/*!</span><span class="s2">\n  </span><span class="s1">* vue-router v3.6.5</span><span class="s2">\n  </span><span class="s1">* (c) 2022 Evan You</span><span class="s2">\n  </span><span class="s1">* @license MIT</span><span class="s2">\n  </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">function assert(condition, message) {</span><span class="s2">\n  </span><span class="s1">if (!condition) {</span><span class="s2">\n    </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">[vue-router] </span><span class="s2">\&quot; </span><span class="s1">+ message);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function warn(condition, message) {</span><span class="s2">\n  </span><span class="s1">if (!condition) {</span><span class="s2">\n    </span><span class="s1">typeof console !== 'undefined' &amp;&amp; console.warn(</span><span class="s2">\&quot;</span><span class="s1">[vue-router] </span><span class="s2">\&quot; </span><span class="s1">+ message);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function extend(a, b) {</span><span class="s2">\n  </span><span class="s1">for (var key in b) {</span><span class="s2">\n    </span><span class="s1">a[key] = b[key];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return a;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var encodeReserveRE = /[!'()*]/g;</span><span class="s2">\n</span><span class="s1">var encodeReserveReplacer = function (c) {</span><span class="s2">\n  </span><span class="s1">return '%' + c.charCodeAt(0).toString(16);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var commaRE = /%2C/g;</span><span class="s2">\n\n</span><span class="s1">// fixed encodeURIComponent which is more conformant to RFC3986:</span><span class="s2">\n</span><span class="s1">// - escapes [!'()*]</span><span class="s2">\n</span><span class="s1">// - preserve commas</span><span class="s2">\n</span><span class="s1">var encode = function (str) {</span><span class="s2">\n  </span><span class="s1">return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function decode(str) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">return decodeURIComponent(str);</span><span class="s2">\n  </span><span class="s1">} catch (err) {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">warn(false, </span><span class="s2">\&quot;</span><span class="s1">Error decoding </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ str + </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">. Leaving it intact.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return str;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveQuery(query, extraQuery, _parseQuery) {</span><span class="s2">\n  </span><span class="s1">if (extraQuery === void 0) extraQuery = {};</span><span class="s2">\n  </span><span class="s1">var parse = _parseQuery || parseQuery;</span><span class="s2">\n  </span><span class="s1">var parsedQuery;</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">parsedQuery = parse(query || '');</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(false, e.message);</span><span class="s2">\n    </span><span class="s1">parsedQuery = {};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">for (var key in extraQuery) {</span><span class="s2">\n    </span><span class="s1">var value = extraQuery[key];</span><span class="s2">\n    </span><span class="s1">parsedQuery[key] = Array.isArray(value) ? value.map(castQueryParamValue) : castQueryParamValue(value);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return parsedQuery;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var castQueryParamValue = function (value) {</span><span class="s2">\n  </span><span class="s1">return value == null || typeof value === 'object' ? value : String(value);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function parseQuery(query) {</span><span class="s2">\n  </span><span class="s1">var res = {};</span><span class="s2">\n  </span><span class="s1">query = query.trim().replace(/^(</span><span class="s2">\\</span><span class="s1">?|#|&amp;)/, '');</span><span class="s2">\n  </span><span class="s1">if (!query) {</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">query.split('&amp;').forEach(function (param) {</span><span class="s2">\n    </span><span class="s1">var parts = param.replace(/</span><span class="s2">\\</span><span class="s1">+/g, ' ').split('=');</span><span class="s2">\n    </span><span class="s1">var key = decode(parts.shift());</span><span class="s2">\n    </span><span class="s1">var val = parts.length &gt; 0 ? decode(parts.join('=')) : null;</span><span class="s2">\n    </span><span class="s1">if (res[key] === undefined) {</span><span class="s2">\n      </span><span class="s1">res[key] = val;</span><span class="s2">\n    </span><span class="s1">} else if (Array.isArray(res[key])) {</span><span class="s2">\n      </span><span class="s1">res[key].push(val);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">res[key] = [res[key], val];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stringifyQuery(obj) {</span><span class="s2">\n  </span><span class="s1">var res = obj ? Object.keys(obj).map(function (key) {</span><span class="s2">\n    </span><span class="s1">var val = obj[key];</span><span class="s2">\n    </span><span class="s1">if (val === undefined) {</span><span class="s2">\n      </span><span class="s1">return '';</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (val === null) {</span><span class="s2">\n      </span><span class="s1">return encode(key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (Array.isArray(val)) {</span><span class="s2">\n      </span><span class="s1">var result = [];</span><span class="s2">\n      </span><span class="s1">val.forEach(function (val2) {</span><span class="s2">\n        </span><span class="s1">if (val2 === undefined) {</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (val2 === null) {</span><span class="s2">\n          </span><span class="s1">result.push(encode(key));</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">result.push(encode(key) + '=' + encode(val2));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return result.join('&amp;');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return encode(key) + '=' + encode(val);</span><span class="s2">\n  </span><span class="s1">}).filter(function (x) {</span><span class="s2">\n    </span><span class="s1">return x.length &gt; 0;</span><span class="s2">\n  </span><span class="s1">}).join('&amp;') : null;</span><span class="s2">\n  </span><span class="s1">return res ? </span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot; </span><span class="s1">+ res : '';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var trailingSlashRE = /</span><span class="s2">\\</span><span class="s1">/?$/;</span><span class="s2">\n</span><span class="s1">function createRoute(record, location, redirectedFrom, router) {</span><span class="s2">\n  </span><span class="s1">var stringifyQuery = router &amp;&amp; router.options.stringifyQuery;</span><span class="s2">\n  </span><span class="s1">var query = location.query || {};</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">query = clone(query);</span><span class="s2">\n  </span><span class="s1">} catch (e) {}</span><span class="s2">\n  </span><span class="s1">var route = {</span><span class="s2">\n    </span><span class="s1">name: location.name || record &amp;&amp; record.name,</span><span class="s2">\n    </span><span class="s1">meta: record &amp;&amp; record.meta || {},</span><span class="s2">\n    </span><span class="s1">path: location.path || '/',</span><span class="s2">\n    </span><span class="s1">hash: location.hash || '',</span><span class="s2">\n    </span><span class="s1">query: query,</span><span class="s2">\n    </span><span class="s1">params: location.params || {},</span><span class="s2">\n    </span><span class="s1">fullPath: getFullPath(location, stringifyQuery),</span><span class="s2">\n    </span><span class="s1">matched: record ? formatMatch(record) : []</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (redirectedFrom) {</span><span class="s2">\n    </span><span class="s1">route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return Object.freeze(route);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function clone(value) {</span><span class="s2">\n  </span><span class="s1">if (Array.isArray(value)) {</span><span class="s2">\n    </span><span class="s1">return value.map(clone);</span><span class="s2">\n  </span><span class="s1">} else if (value &amp;&amp; typeof value === 'object') {</span><span class="s2">\n    </span><span class="s1">var res = {};</span><span class="s2">\n    </span><span class="s1">for (var key in value) {</span><span class="s2">\n      </span><span class="s1">res[key] = clone(value[key]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return value;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// the starting route that represents the initial state</span><span class="s2">\n</span><span class="s1">var START = createRoute(null, {</span><span class="s2">\n  </span><span class="s1">path: '/'</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">function formatMatch(record) {</span><span class="s2">\n  </span><span class="s1">var res = [];</span><span class="s2">\n  </span><span class="s1">while (record) {</span><span class="s2">\n    </span><span class="s1">res.unshift(record);</span><span class="s2">\n    </span><span class="s1">record = record.parent;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getFullPath(ref, _stringifyQuery) {</span><span class="s2">\n  </span><span class="s1">var path = ref.path;</span><span class="s2">\n  </span><span class="s1">var query = ref.query;</span><span class="s2">\n  </span><span class="s1">if (query === void 0) query = {};</span><span class="s2">\n  </span><span class="s1">var hash = ref.hash;</span><span class="s2">\n  </span><span class="s1">if (hash === void 0) hash = '';</span><span class="s2">\n  </span><span class="s1">var stringify = _stringifyQuery || stringifyQuery;</span><span class="s2">\n  </span><span class="s1">return (path || '/') + stringify(query) + hash;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isSameRoute(a, b, onlyPath) {</span><span class="s2">\n  </span><span class="s1">if (b === START) {</span><span class="s2">\n    </span><span class="s1">return a === b;</span><span class="s2">\n  </span><span class="s1">} else if (!b) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">} else if (a.path &amp;&amp; b.path) {</span><span class="s2">\n    </span><span class="s1">return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &amp;&amp; (onlyPath || a.hash === b.hash &amp;&amp; isObjectEqual(a.query, b.query));</span><span class="s2">\n  </span><span class="s1">} else if (a.name &amp;&amp; b.name) {</span><span class="s2">\n    </span><span class="s1">return a.name === b.name &amp;&amp; (onlyPath || a.hash === b.hash &amp;&amp; isObjectEqual(a.query, b.query) &amp;&amp; isObjectEqual(a.params, b.params));</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isObjectEqual(a, b) {</span><span class="s2">\n  </span><span class="s1">if (a === void 0) a = {};</span><span class="s2">\n  </span><span class="s1">if (b === void 0) b = {};</span><span class="s2">\n\n  </span><span class="s1">// handle null value #1566</span><span class="s2">\n  </span><span class="s1">if (!a || !b) {</span><span class="s2">\n    </span><span class="s1">return a === b;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var aKeys = Object.keys(a).sort();</span><span class="s2">\n  </span><span class="s1">var bKeys = Object.keys(b).sort();</span><span class="s2">\n  </span><span class="s1">if (aKeys.length !== bKeys.length) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return aKeys.every(function (key, i) {</span><span class="s2">\n    </span><span class="s1">var aVal = a[key];</span><span class="s2">\n    </span><span class="s1">var bKey = bKeys[i];</span><span class="s2">\n    </span><span class="s1">if (bKey !== key) {</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var bVal = b[key];</span><span class="s2">\n    </span><span class="s1">// query values can be null and undefined</span><span class="s2">\n    </span><span class="s1">if (aVal == null || bVal == null) {</span><span class="s2">\n      </span><span class="s1">return aVal === bVal;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// check nested equality</span><span class="s2">\n    </span><span class="s1">if (typeof aVal === 'object' &amp;&amp; typeof bVal === 'object') {</span><span class="s2">\n      </span><span class="s1">return isObjectEqual(aVal, bVal);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return String(aVal) === String(bVal);</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isIncludedRoute(current, target) {</span><span class="s2">\n  </span><span class="s1">return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 &amp;&amp; (!target.hash || current.hash === target.hash) &amp;&amp; queryIncludes(current.query, target.query);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function queryIncludes(current, target) {</span><span class="s2">\n  </span><span class="s1">for (var key in target) {</span><span class="s2">\n    </span><span class="s1">if (!(key in current)) {</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function handleRouteEntered(route) {</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; route.matched.length; i++) {</span><span class="s2">\n    </span><span class="s1">var record = route.matched[i];</span><span class="s2">\n    </span><span class="s1">for (var name in record.instances) {</span><span class="s2">\n      </span><span class="s1">var instance = record.instances[name];</span><span class="s2">\n      </span><span class="s1">var cbs = record.enteredCbs[name];</span><span class="s2">\n      </span><span class="s1">if (!instance || !cbs) {</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">delete record.enteredCbs[name];</span><span class="s2">\n      </span><span class="s1">for (var i$1 = 0; i$1 &lt; cbs.length; i$1++) {</span><span class="s2">\n        </span><span class="s1">if (!instance._isBeingDestroyed) {</span><span class="s2">\n          </span><span class="s1">cbs[i$1](instance);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var View = {</span><span class="s2">\n  </span><span class="s1">name: 'RouterView',</span><span class="s2">\n  </span><span class="s1">functional: true,</span><span class="s2">\n  </span><span class="s1">props: {</span><span class="s2">\n    </span><span class="s1">name: {</span><span class="s2">\n      </span><span class="s1">type: String,</span><span class="s2">\n      </span><span class="s1">default: 'default'</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">render: function render(_, ref) {</span><span class="s2">\n    </span><span class="s1">var props = ref.props;</span><span class="s2">\n    </span><span class="s1">var children = ref.children;</span><span class="s2">\n    </span><span class="s1">var parent = ref.parent;</span><span class="s2">\n    </span><span class="s1">var data = ref.data;</span><span class="s2">\n\n    </span><span class="s1">// used by devtools to display a router-view badge</span><span class="s2">\n    </span><span class="s1">data.routerView = true;</span><span class="s2">\n\n    </span><span class="s1">// directly use parent context's createElement() function</span><span class="s2">\n    </span><span class="s1">// so that components rendered by router-view can resolve named slots</span><span class="s2">\n    </span><span class="s1">var h = parent.$createElement;</span><span class="s2">\n    </span><span class="s1">var name = props.name;</span><span class="s2">\n    </span><span class="s1">var route = parent.$route;</span><span class="s2">\n    </span><span class="s1">var cache = parent._routerViewCache || (parent._routerViewCache = {});</span><span class="s2">\n\n    </span><span class="s1">// determine current view depth, also check to see if the tree</span><span class="s2">\n    </span><span class="s1">// has been toggled inactive but kept-alive.</span><span class="s2">\n    </span><span class="s1">var depth = 0;</span><span class="s2">\n    </span><span class="s1">var inactive = false;</span><span class="s2">\n    </span><span class="s1">while (parent &amp;&amp; parent._routerRoot !== parent) {</span><span class="s2">\n      </span><span class="s1">var vnodeData = parent.$vnode ? parent.$vnode.data : {};</span><span class="s2">\n      </span><span class="s1">if (vnodeData.routerView) {</span><span class="s2">\n        </span><span class="s1">depth++;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (vnodeData.keepAlive &amp;&amp; parent._directInactive &amp;&amp; parent._inactive) {</span><span class="s2">\n        </span><span class="s1">inactive = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">parent = parent.$parent;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">data.routerViewDepth = depth;</span><span class="s2">\n\n    </span><span class="s1">// render previous view if the tree is inactive and kept-alive</span><span class="s2">\n    </span><span class="s1">if (inactive) {</span><span class="s2">\n      </span><span class="s1">var cachedData = cache[name];</span><span class="s2">\n      </span><span class="s1">var cachedComponent = cachedData &amp;&amp; cachedData.component;</span><span class="s2">\n      </span><span class="s1">if (cachedComponent) {</span><span class="s2">\n        </span><span class="s1">// #2301</span><span class="s2">\n        </span><span class="s1">// pass props</span><span class="s2">\n        </span><span class="s1">if (cachedData.configProps) {</span><span class="s2">\n          </span><span class="s1">fillPropsinData(cachedComponent, data, cachedData.route, cachedData.configProps);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return h(cachedComponent, data, children);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">// render previous empty view</span><span class="s2">\n        </span><span class="s1">return h();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var matched = route.matched[depth];</span><span class="s2">\n    </span><span class="s1">var component = matched &amp;&amp; matched.components[name];</span><span class="s2">\n\n    </span><span class="s1">// render empty node if no matched route or no config component</span><span class="s2">\n    </span><span class="s1">if (!matched || !component) {</span><span class="s2">\n      </span><span class="s1">cache[name] = null;</span><span class="s2">\n      </span><span class="s1">return h();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// cache component</span><span class="s2">\n    </span><span class="s1">cache[name] = {</span><span class="s2">\n      </span><span class="s1">component: component</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n\n    </span><span class="s1">// attach instance registration hook</span><span class="s2">\n    </span><span class="s1">// this will be called in the instance's injected lifecycle hooks</span><span class="s2">\n    </span><span class="s1">data.registerRouteInstance = function (vm, val) {</span><span class="s2">\n      </span><span class="s1">// val could be undefined for unregistration</span><span class="s2">\n      </span><span class="s1">var current = matched.instances[name];</span><span class="s2">\n      </span><span class="s1">if (val &amp;&amp; current !== vm || !val &amp;&amp; current === vm) {</span><span class="s2">\n        </span><span class="s1">matched.instances[name] = val;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// also register instance in prepatch hook</span><span class="s2">\n    </span><span class="s1">// in case the same component instance is reused across different routes</span><span class="s2">\n    </span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">(data.hook || (data.hook = {})).prepatch = function (_, vnode) {</span><span class="s2">\n      </span><span class="s1">matched.instances[name] = vnode.componentInstance;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n\n    </span><span class="s1">// register instance in init hook</span><span class="s2">\n    </span><span class="s1">// in case kept-alive component be actived when routes changed</span><span class="s2">\n    </span><span class="s1">data.hook.init = function (vnode) {</span><span class="s2">\n      </span><span class="s1">if (vnode.data.keepAlive &amp;&amp; vnode.componentInstance &amp;&amp; vnode.componentInstance !== matched.instances[name]) {</span><span class="s2">\n        </span><span class="s1">matched.instances[name] = vnode.componentInstance;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// if the route transition has already been confirmed then we weren't</span><span class="s2">\n      </span><span class="s1">// able to call the cbs during confirmation as the component was not</span><span class="s2">\n      </span><span class="s1">// registered yet, so we call it here.</span><span class="s2">\n      </span><span class="s1">handleRouteEntered(route);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var configProps = matched.props &amp;&amp; matched.props[name];</span><span class="s2">\n    </span><span class="s1">// save route and configProps in cache</span><span class="s2">\n    </span><span class="s1">if (configProps) {</span><span class="s2">\n      </span><span class="s1">extend(cache[name], {</span><span class="s2">\n        </span><span class="s1">route: route,</span><span class="s2">\n        </span><span class="s1">configProps: configProps</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">fillPropsinData(component, data, route, configProps);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return h(component, data, children);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function fillPropsinData(component, data, route, configProps) {</span><span class="s2">\n  </span><span class="s1">// resolve props</span><span class="s2">\n  </span><span class="s1">var propsToPass = data.props = resolveProps(route, configProps);</span><span class="s2">\n  </span><span class="s1">if (propsToPass) {</span><span class="s2">\n    </span><span class="s1">// clone to prevent mutation</span><span class="s2">\n    </span><span class="s1">propsToPass = data.props = extend({}, propsToPass);</span><span class="s2">\n    </span><span class="s1">// pass non-declared props as attrs</span><span class="s2">\n    </span><span class="s1">var attrs = data.attrs = data.attrs || {};</span><span class="s2">\n    </span><span class="s1">for (var key in propsToPass) {</span><span class="s2">\n      </span><span class="s1">if (!component.props || !(key in component.props)) {</span><span class="s2">\n        </span><span class="s1">attrs[key] = propsToPass[key];</span><span class="s2">\n        </span><span class="s1">delete propsToPass[key];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveProps(route, config) {</span><span class="s2">\n  </span><span class="s1">switch (typeof config) {</span><span class="s2">\n    </span><span class="s1">case 'undefined':</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">case 'object':</span><span class="s2">\n      </span><span class="s1">return config;</span><span class="s2">\n    </span><span class="s1">case 'function':</span><span class="s2">\n      </span><span class="s1">return config(route);</span><span class="s2">\n    </span><span class="s1">case 'boolean':</span><span class="s2">\n      </span><span class="s1">return config ? route.params : undefined;</span><span class="s2">\n    </span><span class="s1">default:</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">warn(false, </span><span class="s2">\&quot;</span><span class="s1">props in </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ route.path + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is a </span><span class="s2">\&quot; </span><span class="s1">+ typeof config + </span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">expecting an object, function or boolean.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">function resolvePath(relative, base, append) {</span><span class="s2">\n  </span><span class="s1">var firstChar = relative.charAt(0);</span><span class="s2">\n  </span><span class="s1">if (firstChar === '/') {</span><span class="s2">\n    </span><span class="s1">return relative;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (firstChar === '?' || firstChar === '#') {</span><span class="s2">\n    </span><span class="s1">return base + relative;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var stack = base.split('/');</span><span class="s2">\n\n  </span><span class="s1">// remove trailing segment if:</span><span class="s2">\n  </span><span class="s1">// - not appending</span><span class="s2">\n  </span><span class="s1">// - appending to trailing slash (last segment is empty)</span><span class="s2">\n  </span><span class="s1">if (!append || !stack[stack.length - 1]) {</span><span class="s2">\n    </span><span class="s1">stack.pop();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// resolve relative path</span><span class="s2">\n  </span><span class="s1">var segments = relative.replace(/^</span><span class="s2">\\</span><span class="s1">//, '').split('/');</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; segments.length; i++) {</span><span class="s2">\n    </span><span class="s1">var segment = segments[i];</span><span class="s2">\n    </span><span class="s1">if (segment === '..') {</span><span class="s2">\n      </span><span class="s1">stack.pop();</span><span class="s2">\n    </span><span class="s1">} else if (segment !== '.') {</span><span class="s2">\n      </span><span class="s1">stack.push(segment);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// ensure leading slash</span><span class="s2">\n  </span><span class="s1">if (stack[0] !== '') {</span><span class="s2">\n    </span><span class="s1">stack.unshift('');</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return stack.join('/');</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function parsePath(path) {</span><span class="s2">\n  </span><span class="s1">var hash = '';</span><span class="s2">\n  </span><span class="s1">var query = '';</span><span class="s2">\n  </span><span class="s1">var hashIndex = path.indexOf('#');</span><span class="s2">\n  </span><span class="s1">if (hashIndex &gt;= 0) {</span><span class="s2">\n    </span><span class="s1">hash = path.slice(hashIndex);</span><span class="s2">\n    </span><span class="s1">path = path.slice(0, hashIndex);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var queryIndex = path.indexOf('?');</span><span class="s2">\n  </span><span class="s1">if (queryIndex &gt;= 0) {</span><span class="s2">\n    </span><span class="s1">query = path.slice(queryIndex + 1);</span><span class="s2">\n    </span><span class="s1">path = path.slice(0, queryIndex);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">path: path,</span><span class="s2">\n    </span><span class="s1">query: query,</span><span class="s2">\n    </span><span class="s1">hash: hash</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function cleanPath(path) {</span><span class="s2">\n  </span><span class="s1">return path.replace(/</span><span class="s2">\\</span><span class="s1">/(?:</span><span class="s2">\\</span><span class="s1">s*</span><span class="s2">\\</span><span class="s1">/)+/g, '/');</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var isarray = Array.isArray || function (arr) {</span><span class="s2">\n  </span><span class="s1">return Object.prototype.toString.call(arr) == '[object Array]';</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Expose `pathToRegexp`.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var pathToRegexp_1 = pathToRegexp;</span><span class="s2">\n</span><span class="s1">var parse_1 = parse;</span><span class="s2">\n</span><span class="s1">var compile_1 = compile;</span><span class="s2">\n</span><span class="s1">var tokensToFunction_1 = tokensToFunction;</span><span class="s2">\n</span><span class="s1">var tokensToRegExp_1 = tokensToRegExp;</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* The main path matching regexp utility.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @type {RegExp}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var PATH_REGEXP = new RegExp([</span><span class="s2">\n</span><span class="s1">// Match escaped characters that would otherwise appear in future matches.</span><span class="s2">\n</span><span class="s1">// This allows the user to escape special characters that won't transform.</span><span class="s2">\n</span><span class="s1">'(</span><span class="s2">\\\\\\\\</span><span class="s1">.)',</span><span class="s2">\n</span><span class="s1">// Match Express-style parameters and un-named parameters with a prefix</span><span class="s2">\n</span><span class="s1">// and optional suffixes. Matches appear as:</span><span class="s2">\n</span><span class="s1">//</span><span class="s2">\n</span><span class="s1">// </span><span class="s2">\&quot;</span><span class="s1">/:test(</span><span class="s2">\\\\</span><span class="s1">d+)?</span><span class="s2">\&quot; </span><span class="s1">=&gt; [</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">test</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;\\</span><span class="s1">d+</span><span class="s2">\&quot;</span><span class="s1">, undefined, </span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot;</span><span class="s1">, undefined]</span><span class="s2">\n</span><span class="s1">// </span><span class="s2">\&quot;</span><span class="s1">/route(</span><span class="s2">\\\\</span><span class="s1">d+)</span><span class="s2">\&quot;  </span><span class="s1">=&gt; [undefined, undefined, undefined, </span><span class="s2">\&quot;\\</span><span class="s1">d+</span><span class="s2">\&quot;</span><span class="s1">, undefined, undefined]</span><span class="s2">\n</span><span class="s1">// </span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot;            </span><span class="s1">=&gt; [</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">, undefined, undefined, undefined, undefined, </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\n</span><span class="s1">'([</span><span class="s2">\\\\</span><span class="s1">/.])?(?:(?:</span><span class="s2">\\\\</span><span class="s1">:(</span><span class="s2">\\\\</span><span class="s1">w+)(?:</span><span class="s2">\\\\</span><span class="s1">(((?:</span><span class="s2">\\\\\\\\</span><span class="s1">.|[^</span><span class="s2">\\\\\\\\</span><span class="s1">()])+)</span><span class="s2">\\\\</span><span class="s1">))?|</span><span class="s2">\\\\</span><span class="s1">(((?:</span><span class="s2">\\\\\\\\</span><span class="s1">.|[^</span><span class="s2">\\\\\\\\</span><span class="s1">()])+)</span><span class="s2">\\\\</span><span class="s1">))([+*?])?|(</span><span class="s2">\\\\</span><span class="s1">*))'].join('|'), 'g');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Parse a string for the raw tokens.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {string}  str</span><span class="s2">\n </span><span class="s1">* @param  {Object=} options</span><span class="s2">\n </span><span class="s1">* @return {!Array}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function parse(str, options) {</span><span class="s2">\n  </span><span class="s1">var tokens = [];</span><span class="s2">\n  </span><span class="s1">var key = 0;</span><span class="s2">\n  </span><span class="s1">var index = 0;</span><span class="s2">\n  </span><span class="s1">var path = '';</span><span class="s2">\n  </span><span class="s1">var defaultDelimiter = options &amp;&amp; options.delimiter || '/';</span><span class="s2">\n  </span><span class="s1">var res;</span><span class="s2">\n  </span><span class="s1">while ((res = PATH_REGEXP.exec(str)) != null) {</span><span class="s2">\n    </span><span class="s1">var m = res[0];</span><span class="s2">\n    </span><span class="s1">var escaped = res[1];</span><span class="s2">\n    </span><span class="s1">var offset = res.index;</span><span class="s2">\n    </span><span class="s1">path += str.slice(index, offset);</span><span class="s2">\n    </span><span class="s1">index = offset + m.length;</span><span class="s2">\n\n    </span><span class="s1">// Ignore already escaped sequences.</span><span class="s2">\n    </span><span class="s1">if (escaped) {</span><span class="s2">\n      </span><span class="s1">path += escaped[1];</span><span class="s2">\n      </span><span class="s1">continue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var next = str[index];</span><span class="s2">\n    </span><span class="s1">var prefix = res[2];</span><span class="s2">\n    </span><span class="s1">var name = res[3];</span><span class="s2">\n    </span><span class="s1">var capture = res[4];</span><span class="s2">\n    </span><span class="s1">var group = res[5];</span><span class="s2">\n    </span><span class="s1">var modifier = res[6];</span><span class="s2">\n    </span><span class="s1">var asterisk = res[7];</span><span class="s2">\n\n    </span><span class="s1">// Push the current path onto the tokens.</span><span class="s2">\n    </span><span class="s1">if (path) {</span><span class="s2">\n      </span><span class="s1">tokens.push(path);</span><span class="s2">\n      </span><span class="s1">path = '';</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var partial = prefix != null &amp;&amp; next != null &amp;&amp; next !== prefix;</span><span class="s2">\n    </span><span class="s1">var repeat = modifier === '+' || modifier === '*';</span><span class="s2">\n    </span><span class="s1">var optional = modifier === '?' || modifier === '*';</span><span class="s2">\n    </span><span class="s1">var delimiter = res[2] || defaultDelimiter;</span><span class="s2">\n    </span><span class="s1">var pattern = capture || group;</span><span class="s2">\n    </span><span class="s1">tokens.push({</span><span class="s2">\n      </span><span class="s1">name: name || key++,</span><span class="s2">\n      </span><span class="s1">prefix: prefix || '',</span><span class="s2">\n      </span><span class="s1">delimiter: delimiter,</span><span class="s2">\n      </span><span class="s1">optional: optional,</span><span class="s2">\n      </span><span class="s1">repeat: repeat,</span><span class="s2">\n      </span><span class="s1">partial: partial,</span><span class="s2">\n      </span><span class="s1">asterisk: !!asterisk,</span><span class="s2">\n      </span><span class="s1">pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Match any characters still remaining.</span><span class="s2">\n  </span><span class="s1">if (index &lt; str.length) {</span><span class="s2">\n    </span><span class="s1">path += str.substr(index);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// If the path exists, push it onto the end.</span><span class="s2">\n  </span><span class="s1">if (path) {</span><span class="s2">\n    </span><span class="s1">tokens.push(path);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return tokens;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Compile a string to a template function for the path.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {string}             str</span><span class="s2">\n </span><span class="s1">* @param  {Object=}            options</span><span class="s2">\n </span><span class="s1">* @return {!function(Object=, Object=)}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function compile(str, options) {</span><span class="s2">\n  </span><span class="s1">return tokensToFunction(parse(str, options), options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Prettier encoding of URI path segments.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {string}</span><span class="s2">\n </span><span class="s1">* @return {string}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function encodeURIComponentPretty(str) {</span><span class="s2">\n  </span><span class="s1">return encodeURI(str).replace(/[</span><span class="s2">\\</span><span class="s1">/?#]/g, function (c) {</span><span class="s2">\n    </span><span class="s1">return '%' + c.charCodeAt(0).toString(16).toUpperCase();</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Encode the asterisk parameter. Similar to `pretty`, but allows slashes.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {string}</span><span class="s2">\n </span><span class="s1">* @return {string}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function encodeAsterisk(str) {</span><span class="s2">\n  </span><span class="s1">return encodeURI(str).replace(/[?#]/g, function (c) {</span><span class="s2">\n    </span><span class="s1">return '%' + c.charCodeAt(0).toString(16).toUpperCase();</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Expose a method for transforming tokens into the path function.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function tokensToFunction(tokens, options) {</span><span class="s2">\n  </span><span class="s1">// Compile all the tokens into regexps.</span><span class="s2">\n  </span><span class="s1">var matches = new Array(tokens.length);</span><span class="s2">\n\n  </span><span class="s1">// Compile all the patterns before compilation.</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; tokens.length; i++) {</span><span class="s2">\n    </span><span class="s1">if (typeof tokens[i] === 'object') {</span><span class="s2">\n      </span><span class="s1">matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return function (obj, opts) {</span><span class="s2">\n    </span><span class="s1">var path = '';</span><span class="s2">\n    </span><span class="s1">var data = obj || {};</span><span class="s2">\n    </span><span class="s1">var options = opts || {};</span><span class="s2">\n    </span><span class="s1">var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; tokens.length; i++) {</span><span class="s2">\n      </span><span class="s1">var token = tokens[i];</span><span class="s2">\n      </span><span class="s1">if (typeof token === 'string') {</span><span class="s2">\n        </span><span class="s1">path += token;</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">var value = data[token.name];</span><span class="s2">\n      </span><span class="s1">var segment;</span><span class="s2">\n      </span><span class="s1">if (value == null) {</span><span class="s2">\n        </span><span class="s1">if (token.optional) {</span><span class="s2">\n          </span><span class="s1">// Prepend partial segment prefixes.</span><span class="s2">\n          </span><span class="s1">if (token.partial) {</span><span class="s2">\n            </span><span class="s1">path += token.prefix;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">throw new TypeError('Expected </span><span class="s2">\&quot;</span><span class="s1">' + token.name + '</span><span class="s2">\&quot; </span><span class="s1">to be defined');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (isarray(value)) {</span><span class="s2">\n        </span><span class="s1">if (!token.repeat) {</span><span class="s2">\n          </span><span class="s1">throw new TypeError('Expected </span><span class="s2">\&quot;</span><span class="s1">' + token.name + '</span><span class="s2">\&quot; </span><span class="s1">to not repeat, but received `' + JSON.stringify(value) + '`');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (value.length === 0) {</span><span class="s2">\n          </span><span class="s1">if (token.optional) {</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">throw new TypeError('Expected </span><span class="s2">\&quot;</span><span class="s1">' + token.name + '</span><span class="s2">\&quot; </span><span class="s1">to not be empty');</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">for (var j = 0; j &lt; value.length; j++) {</span><span class="s2">\n          </span><span class="s1">segment = encode(value[j]);</span><span class="s2">\n          </span><span class="s1">if (!matches[i].test(segment)) {</span><span class="s2">\n            </span><span class="s1">throw new TypeError('Expected all </span><span class="s2">\&quot;</span><span class="s1">' + token.name + '</span><span class="s2">\&quot; </span><span class="s1">to match </span><span class="s2">\&quot;</span><span class="s1">' + token.pattern + '</span><span class="s2">\&quot;</span><span class="s1">, but received `' + JSON.stringify(segment) + '`');</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">path += (j === 0 ? token.prefix : token.delimiter) + segment;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">segment = token.asterisk ? encodeAsterisk(value) : encode(value);</span><span class="s2">\n      </span><span class="s1">if (!matches[i].test(segment)) {</span><span class="s2">\n        </span><span class="s1">throw new TypeError('Expected </span><span class="s2">\&quot;</span><span class="s1">' + token.name + '</span><span class="s2">\&quot; </span><span class="s1">to match </span><span class="s2">\&quot;</span><span class="s1">' + token.pattern + '</span><span class="s2">\&quot;</span><span class="s1">, but received </span><span class="s2">\&quot;</span><span class="s1">' + segment + '</span><span class="s2">\&quot;</span><span class="s1">');</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">path += token.prefix + segment;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return path;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Escape a regular expression string.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {string} str</span><span class="s2">\n </span><span class="s1">* @return {string}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function escapeString(str) {</span><span class="s2">\n  </span><span class="s1">return str.replace(/([.+*?=^!:${}()[</span><span class="s2">\\</span><span class="s1">]|</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\\\</span><span class="s1">])/g, '</span><span class="s2">\\\\</span><span class="s1">$1');</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Escape the capturing group by escaping special characters and meaning.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {string} group</span><span class="s2">\n </span><span class="s1">* @return {string}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function escapeGroup(group) {</span><span class="s2">\n  </span><span class="s1">return group.replace(/([=!:$</span><span class="s2">\\</span><span class="s1">/()])/g, '</span><span class="s2">\\\\</span><span class="s1">$1');</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Attach the keys as a property of the regexp.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {!RegExp} re</span><span class="s2">\n </span><span class="s1">* @param  {Array}   keys</span><span class="s2">\n </span><span class="s1">* @return {!RegExp}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function attachKeys(re, keys) {</span><span class="s2">\n  </span><span class="s1">re.keys = keys;</span><span class="s2">\n  </span><span class="s1">return re;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Get the flags for a regexp from the options.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {Object} options</span><span class="s2">\n </span><span class="s1">* @return {string}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function flags(options) {</span><span class="s2">\n  </span><span class="s1">return options &amp;&amp; options.sensitive ? '' : 'i';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Pull out keys from a regexp.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {!RegExp} path</span><span class="s2">\n </span><span class="s1">* @param  {!Array}  keys</span><span class="s2">\n </span><span class="s1">* @return {!RegExp}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function regexpToRegexp(path, keys) {</span><span class="s2">\n  </span><span class="s1">// Use a negative lookahead to match only capturing groups.</span><span class="s2">\n  </span><span class="s1">var groups = path.source.match(/</span><span class="s2">\\</span><span class="s1">((?!</span><span class="s2">\\</span><span class="s1">?)/g);</span><span class="s2">\n  </span><span class="s1">if (groups) {</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; groups.length; i++) {</span><span class="s2">\n      </span><span class="s1">keys.push({</span><span class="s2">\n        </span><span class="s1">name: i,</span><span class="s2">\n        </span><span class="s1">prefix: null,</span><span class="s2">\n        </span><span class="s1">delimiter: null,</span><span class="s2">\n        </span><span class="s1">optional: false,</span><span class="s2">\n        </span><span class="s1">repeat: false,</span><span class="s2">\n        </span><span class="s1">partial: false,</span><span class="s2">\n        </span><span class="s1">asterisk: false,</span><span class="s2">\n        </span><span class="s1">pattern: null</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return attachKeys(path, keys);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Transform an array into a regexp.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {!Array}  path</span><span class="s2">\n </span><span class="s1">* @param  {Array}   keys</span><span class="s2">\n </span><span class="s1">* @param  {!Object} options</span><span class="s2">\n </span><span class="s1">* @return {!RegExp}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function arrayToRegexp(path, keys, options) {</span><span class="s2">\n  </span><span class="s1">var parts = [];</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; path.length; i++) {</span><span class="s2">\n    </span><span class="s1">parts.push(pathToRegexp(path[i], keys, options).source);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));</span><span class="s2">\n  </span><span class="s1">return attachKeys(regexp, keys);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Create a path regexp from string input.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {string}  path</span><span class="s2">\n </span><span class="s1">* @param  {!Array}  keys</span><span class="s2">\n </span><span class="s1">* @param  {!Object} options</span><span class="s2">\n </span><span class="s1">* @return {!RegExp}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function stringToRegexp(path, keys, options) {</span><span class="s2">\n  </span><span class="s1">return tokensToRegExp(parse(path, options), keys, options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Expose a function for taking tokens and returning a RegExp.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {!Array}          tokens</span><span class="s2">\n </span><span class="s1">* @param  {(Array|Object)=} keys</span><span class="s2">\n </span><span class="s1">* @param  {Object=}         options</span><span class="s2">\n </span><span class="s1">* @return {!RegExp}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function tokensToRegExp(tokens, keys, options) {</span><span class="s2">\n  </span><span class="s1">if (!isarray(keys)) {</span><span class="s2">\n    </span><span class="s1">options = /** @type {!Object} */keys || options;</span><span class="s2">\n    </span><span class="s1">keys = [];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">options = options || {};</span><span class="s2">\n  </span><span class="s1">var strict = options.strict;</span><span class="s2">\n  </span><span class="s1">var end = options.end !== false;</span><span class="s2">\n  </span><span class="s1">var route = '';</span><span class="s2">\n\n  </span><span class="s1">// Iterate over the tokens and create our regexp string.</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; tokens.length; i++) {</span><span class="s2">\n    </span><span class="s1">var token = tokens[i];</span><span class="s2">\n    </span><span class="s1">if (typeof token === 'string') {</span><span class="s2">\n      </span><span class="s1">route += escapeString(token);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">var prefix = escapeString(token.prefix);</span><span class="s2">\n      </span><span class="s1">var capture = '(?:' + token.pattern + ')';</span><span class="s2">\n      </span><span class="s1">keys.push(token);</span><span class="s2">\n      </span><span class="s1">if (token.repeat) {</span><span class="s2">\n        </span><span class="s1">capture += '(?:' + prefix + capture + ')*';</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (token.optional) {</span><span class="s2">\n        </span><span class="s1">if (!token.partial) {</span><span class="s2">\n          </span><span class="s1">capture = '(?:' + prefix + '(' + capture + '))?';</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">capture = prefix + '(' + capture + ')?';</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">capture = prefix + '(' + capture + ')';</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">route += capture;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var delimiter = escapeString(options.delimiter || '/');</span><span class="s2">\n  </span><span class="s1">var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;</span><span class="s2">\n\n  </span><span class="s1">// In non-strict mode we allow a slash at the end of match. If the path to</span><span class="s2">\n  </span><span class="s1">// match already ends with a slash, we remove it for consistency. The slash</span><span class="s2">\n  </span><span class="s1">// is valid at the end of a path match, not in the middle. This is important</span><span class="s2">\n  </span><span class="s1">// in non-ending mode, where </span><span class="s2">\&quot;</span><span class="s1">/test/</span><span class="s2">\&quot; </span><span class="s1">shouldn't match </span><span class="s2">\&quot;</span><span class="s1">/test//route</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\n  </span><span class="s1">if (!strict) {</span><span class="s2">\n    </span><span class="s1">route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (end) {</span><span class="s2">\n    </span><span class="s1">route += '$';</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">// In non-ending mode, we need the capturing groups to match as much as</span><span class="s2">\n    </span><span class="s1">// possible by using a positive lookahead to the end or next path segment.</span><span class="s2">\n    </span><span class="s1">route += strict &amp;&amp; endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return attachKeys(new RegExp('^' + route, flags(options)), keys);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Normalize the given path string, returning a regular expression.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* An empty array can be passed in for the keys, which will hold the</span><span class="s2">\n </span><span class="s1">* placeholder key descriptions. For example, using `/user/:id`, `keys` will</span><span class="s2">\n </span><span class="s1">* contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {(string|RegExp|Array)} path</span><span class="s2">\n </span><span class="s1">* @param  {(Array|Object)=}       keys</span><span class="s2">\n </span><span class="s1">* @param  {Object=}               options</span><span class="s2">\n </span><span class="s1">* @return {!RegExp}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function pathToRegexp(path, keys, options) {</span><span class="s2">\n  </span><span class="s1">if (!isarray(keys)) {</span><span class="s2">\n    </span><span class="s1">options = /** @type {!Object} */keys || options;</span><span class="s2">\n    </span><span class="s1">keys = [];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">options = options || {};</span><span class="s2">\n  </span><span class="s1">if (path instanceof RegExp) {</span><span class="s2">\n    </span><span class="s1">return regexpToRegexp(path, /** @type {!Array} */keys);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isarray(path)) {</span><span class="s2">\n    </span><span class="s1">return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">pathToRegexp_1.parse = parse_1;</span><span class="s2">\n</span><span class="s1">pathToRegexp_1.compile = compile_1;</span><span class="s2">\n</span><span class="s1">pathToRegexp_1.tokensToFunction = tokensToFunction_1;</span><span class="s2">\n</span><span class="s1">pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">// $flow-disable-line</span><span class="s2">\n</span><span class="s1">var regexpCompileCache = Object.create(null);</span><span class="s2">\n</span><span class="s1">function fillParams(path, params, routeMsg) {</span><span class="s2">\n  </span><span class="s1">params = params || {};</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">var filler = regexpCompileCache[path] || (regexpCompileCache[path] = pathToRegexp_1.compile(path));</span><span class="s2">\n\n    </span><span class="s1">// Fix #2505 resolving asterisk routes { name: 'not-found', params: { pathMatch: '/not-found' }}</span><span class="s2">\n    </span><span class="s1">// and fix #3106 so that you can work with location descriptor object having params.pathMatch equal to empty string</span><span class="s2">\n    </span><span class="s1">if (typeof params.pathMatch === 'string') {</span><span class="s2">\n      </span><span class="s1">params[0] = params.pathMatch;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return filler(params, {</span><span class="s2">\n      </span><span class="s1">pretty: true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">// Fix #3072 no warn if `pathMatch` is string</span><span class="s2">\n      </span><span class="s1">warn(typeof params.pathMatch === 'string', </span><span class="s2">\&quot;</span><span class="s1">missing param for </span><span class="s2">\&quot; </span><span class="s1">+ routeMsg + </span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot; </span><span class="s1">+ e.message);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return '';</span><span class="s2">\n  </span><span class="s1">} finally {</span><span class="s2">\n    </span><span class="s1">// delete the 0 if it was added</span><span class="s2">\n    </span><span class="s1">delete params[0];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">function normalizeLocation(raw, current, append, router) {</span><span class="s2">\n  </span><span class="s1">var next = typeof raw === 'string' ? {</span><span class="s2">\n    </span><span class="s1">path: raw</span><span class="s2">\n  </span><span class="s1">} : raw;</span><span class="s2">\n  </span><span class="s1">// named target</span><span class="s2">\n  </span><span class="s1">if (next._normalized) {</span><span class="s2">\n    </span><span class="s1">return next;</span><span class="s2">\n  </span><span class="s1">} else if (next.name) {</span><span class="s2">\n    </span><span class="s1">next = extend({}, raw);</span><span class="s2">\n    </span><span class="s1">var params = next.params;</span><span class="s2">\n    </span><span class="s1">if (params &amp;&amp; typeof params === 'object') {</span><span class="s2">\n      </span><span class="s1">next.params = extend({}, params);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return next;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// relative params</span><span class="s2">\n  </span><span class="s1">if (!next.path &amp;&amp; next.params &amp;&amp; current) {</span><span class="s2">\n    </span><span class="s1">next = extend({}, next);</span><span class="s2">\n    </span><span class="s1">next._normalized = true;</span><span class="s2">\n    </span><span class="s1">var params$1 = extend(extend({}, current.params), next.params);</span><span class="s2">\n    </span><span class="s1">if (current.name) {</span><span class="s2">\n      </span><span class="s1">next.name = current.name;</span><span class="s2">\n      </span><span class="s1">next.params = params$1;</span><span class="s2">\n    </span><span class="s1">} else if (current.matched.length) {</span><span class="s2">\n      </span><span class="s1">var rawPath = current.matched[current.matched.length - 1].path;</span><span class="s2">\n      </span><span class="s1">next.path = fillParams(rawPath, params$1, </span><span class="s2">\&quot;</span><span class="s1">path </span><span class="s2">\&quot; </span><span class="s1">+ current.path);</span><span class="s2">\n    </span><span class="s1">} else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">warn(false, </span><span class="s2">\&quot;</span><span class="s1">relative params navigation requires a current route.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return next;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var parsedPath = parsePath(next.path || '');</span><span class="s2">\n  </span><span class="s1">var basePath = current &amp;&amp; current.path || '/';</span><span class="s2">\n  </span><span class="s1">var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;</span><span class="s2">\n  </span><span class="s1">var query = resolveQuery(parsedPath.query, next.query, router &amp;&amp; router.options.parseQuery);</span><span class="s2">\n  </span><span class="s1">var hash = next.hash || parsedPath.hash;</span><span class="s2">\n  </span><span class="s1">if (hash &amp;&amp; hash.charAt(0) !== '#') {</span><span class="s2">\n    </span><span class="s1">hash = </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">+ hash;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">_normalized: true,</span><span class="s2">\n    </span><span class="s1">path: path,</span><span class="s2">\n    </span><span class="s1">query: query,</span><span class="s2">\n    </span><span class="s1">hash: hash</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">// work around weird flow bug</span><span class="s2">\n</span><span class="s1">var toTypes = [String, Object];</span><span class="s2">\n</span><span class="s1">var eventTypes = [String, Array];</span><span class="s2">\n</span><span class="s1">var noop = function () {};</span><span class="s2">\n</span><span class="s1">var warnedCustomSlot;</span><span class="s2">\n</span><span class="s1">var warnedTagProp;</span><span class="s2">\n</span><span class="s1">var warnedEventProp;</span><span class="s2">\n</span><span class="s1">var Link = {</span><span class="s2">\n  </span><span class="s1">name: 'RouterLink',</span><span class="s2">\n  </span><span class="s1">props: {</span><span class="s2">\n    </span><span class="s1">to: {</span><span class="s2">\n      </span><span class="s1">type: toTypes,</span><span class="s2">\n      </span><span class="s1">required: true</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">tag: {</span><span class="s2">\n      </span><span class="s1">type: String,</span><span class="s2">\n      </span><span class="s1">default: 'a'</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">custom: Boolean,</span><span class="s2">\n    </span><span class="s1">exact: Boolean,</span><span class="s2">\n    </span><span class="s1">exactPath: Boolean,</span><span class="s2">\n    </span><span class="s1">append: Boolean,</span><span class="s2">\n    </span><span class="s1">replace: Boolean,</span><span class="s2">\n    </span><span class="s1">activeClass: String,</span><span class="s2">\n    </span><span class="s1">exactActiveClass: String,</span><span class="s2">\n    </span><span class="s1">ariaCurrentValue: {</span><span class="s2">\n      </span><span class="s1">type: String,</span><span class="s2">\n      </span><span class="s1">default: 'page'</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">event: {</span><span class="s2">\n      </span><span class="s1">type: eventTypes,</span><span class="s2">\n      </span><span class="s1">default: 'click'</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">render: function render(h) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n    </span><span class="s1">var router = this.$router;</span><span class="s2">\n    </span><span class="s1">var current = this.$route;</span><span class="s2">\n    </span><span class="s1">var ref = router.resolve(this.to, current, this.append);</span><span class="s2">\n    </span><span class="s1">var location = ref.location;</span><span class="s2">\n    </span><span class="s1">var route = ref.route;</span><span class="s2">\n    </span><span class="s1">var href = ref.href;</span><span class="s2">\n    </span><span class="s1">var classes = {};</span><span class="s2">\n    </span><span class="s1">var globalActiveClass = router.options.linkActiveClass;</span><span class="s2">\n    </span><span class="s1">var globalExactActiveClass = router.options.linkExactActiveClass;</span><span class="s2">\n    </span><span class="s1">// Support global empty active class</span><span class="s2">\n    </span><span class="s1">var activeClassFallback = globalActiveClass == null ? 'router-link-active' : globalActiveClass;</span><span class="s2">\n    </span><span class="s1">var exactActiveClassFallback = globalExactActiveClass == null ? 'router-link-exact-active' : globalExactActiveClass;</span><span class="s2">\n    </span><span class="s1">var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;</span><span class="s2">\n    </span><span class="s1">var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;</span><span class="s2">\n    </span><span class="s1">var compareTarget = route.redirectedFrom ? createRoute(null, normalizeLocation(route.redirectedFrom), null, router) : route;</span><span class="s2">\n    </span><span class="s1">classes[exactActiveClass] = isSameRoute(current, compareTarget, this.exactPath);</span><span class="s2">\n    </span><span class="s1">classes[activeClass] = this.exact || this.exactPath ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);</span><span class="s2">\n    </span><span class="s1">var ariaCurrentValue = classes[exactActiveClass] ? this.ariaCurrentValue : null;</span><span class="s2">\n    </span><span class="s1">var handler = function (e) {</span><span class="s2">\n      </span><span class="s1">if (guardEvent(e)) {</span><span class="s2">\n        </span><span class="s1">if (this$1$1.replace) {</span><span class="s2">\n          </span><span class="s1">router.replace(location, noop);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">router.push(location, noop);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var on = {</span><span class="s2">\n      </span><span class="s1">click: guardEvent</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (Array.isArray(this.event)) {</span><span class="s2">\n      </span><span class="s1">this.event.forEach(function (e) {</span><span class="s2">\n        </span><span class="s1">on[e] = handler;</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">on[this.event] = handler;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var data = {</span><span class="s2">\n      </span><span class="s1">class: classes</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var scopedSlot = !this.$scopedSlots.$hasNormal &amp;&amp; this.$scopedSlots.default &amp;&amp; this.$scopedSlots.default({</span><span class="s2">\n      </span><span class="s1">href: href,</span><span class="s2">\n      </span><span class="s1">route: route,</span><span class="s2">\n      </span><span class="s1">navigate: handler,</span><span class="s2">\n      </span><span class="s1">isActive: classes[activeClass],</span><span class="s2">\n      </span><span class="s1">isExactActive: classes[exactActiveClass]</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (scopedSlot) {</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !this.custom) {</span><span class="s2">\n        </span><span class="s1">!warnedCustomSlot &amp;&amp; warn(false, 'In Vue Router 4, the v-slot API will by default wrap its content with an &lt;a&gt; element. Use the custom prop to remove this warning:</span><span class="s2">\\</span><span class="s1">n&lt;router-link v-slot=</span><span class="s2">\&quot;</span><span class="s1">{ navigate, href }</span><span class="s2">\&quot; </span><span class="s1">custom&gt;&lt;/router-link&gt;</span><span class="s2">\\</span><span class="s1">n');</span><span class="s2">\n        </span><span class="s1">warnedCustomSlot = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (scopedSlot.length === 1) {</span><span class="s2">\n        </span><span class="s1">return scopedSlot[0];</span><span class="s2">\n      </span><span class="s1">} else if (scopedSlot.length &gt; 1 || !scopedSlot.length) {</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n          </span><span class="s1">warn(false, </span><span class="s2">\&quot;</span><span class="s1">&lt;router-link&gt; with to=</span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ this.to + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is trying to use a scoped slot but it didn't provide exactly one child. Wrapping the content with a span element.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return scopedSlot.length === 0 ? h() : h('span', {}, scopedSlot);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">if ('tag' in this.$options.propsData &amp;&amp; !warnedTagProp) {</span><span class="s2">\n        </span><span class="s1">warn(false, </span><span class="s2">\&quot;</span><span class="s1">&lt;router-link&gt;'s tag prop is deprecated and has been removed in Vue Router 4. Use the v-slot API to remove this warning: https://next.router.vuejs.org/guide/migration/#removal-of-event-and-tag-props-in-router-link.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">warnedTagProp = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if ('event' in this.$options.propsData &amp;&amp; !warnedEventProp) {</span><span class="s2">\n        </span><span class="s1">warn(false, </span><span class="s2">\&quot;</span><span class="s1">&lt;router-link&gt;'s event prop is deprecated and has been removed in Vue Router 4. Use the v-slot API to remove this warning: https://next.router.vuejs.org/guide/migration/#removal-of-event-and-tag-props-in-router-link.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">warnedEventProp = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (this.tag === 'a') {</span><span class="s2">\n      </span><span class="s1">data.on = on;</span><span class="s2">\n      </span><span class="s1">data.attrs = {</span><span class="s2">\n        </span><span class="s1">href: href,</span><span class="s2">\n        </span><span class="s1">'aria-current': ariaCurrentValue</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">// find the first &lt;a&gt; child and apply listener and href</span><span class="s2">\n      </span><span class="s1">var a = findAnchor(this.$slots.default);</span><span class="s2">\n      </span><span class="s1">if (a) {</span><span class="s2">\n        </span><span class="s1">// in case the &lt;a&gt; is a static node</span><span class="s2">\n        </span><span class="s1">a.isStatic = false;</span><span class="s2">\n        </span><span class="s1">var aData = a.data = extend({}, a.data);</span><span class="s2">\n        </span><span class="s1">aData.on = aData.on || {};</span><span class="s2">\n        </span><span class="s1">// transform existing events in both objects into arrays so we can push later</span><span class="s2">\n        </span><span class="s1">for (var event in aData.on) {</span><span class="s2">\n          </span><span class="s1">var handler$1 = aData.on[event];</span><span class="s2">\n          </span><span class="s1">if (event in on) {</span><span class="s2">\n            </span><span class="s1">aData.on[event] = Array.isArray(handler$1) ? handler$1 : [handler$1];</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// append new listeners for router-link</span><span class="s2">\n        </span><span class="s1">for (var event$1 in on) {</span><span class="s2">\n          </span><span class="s1">if (event$1 in aData.on) {</span><span class="s2">\n            </span><span class="s1">// on[event] is always a function</span><span class="s2">\n            </span><span class="s1">aData.on[event$1].push(on[event$1]);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">aData.on[event$1] = handler;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var aAttrs = a.data.attrs = extend({}, a.data.attrs);</span><span class="s2">\n        </span><span class="s1">aAttrs.href = href;</span><span class="s2">\n        </span><span class="s1">aAttrs['aria-current'] = ariaCurrentValue;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">// doesn't have &lt;a&gt; child, apply listener to self</span><span class="s2">\n        </span><span class="s1">data.on = on;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return h(this.tag, data, this.$slots.default);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function guardEvent(e) {</span><span class="s2">\n  </span><span class="s1">// don't redirect with control keys</span><span class="s2">\n  </span><span class="s1">if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// don't redirect when preventDefault called</span><span class="s2">\n  </span><span class="s1">if (e.defaultPrevented) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// don't redirect on right click</span><span class="s2">\n  </span><span class="s1">if (e.button !== undefined &amp;&amp; e.button !== 0) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// don't redirect if `target=</span><span class="s2">\&quot;</span><span class="s1">_blank</span><span class="s2">\&quot;</span><span class="s1">`</span><span class="s2">\n  </span><span class="s1">if (e.currentTarget &amp;&amp; e.currentTarget.getAttribute) {</span><span class="s2">\n    </span><span class="s1">var target = e.currentTarget.getAttribute('target');</span><span class="s2">\n    </span><span class="s1">if (/</span><span class="s2">\\</span><span class="s1">b_blank</span><span class="s2">\\</span><span class="s1">b/i.test(target)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// this may be a Weex event which doesn't have this method</span><span class="s2">\n  </span><span class="s1">if (e.preventDefault) {</span><span class="s2">\n    </span><span class="s1">e.preventDefault();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function findAnchor(children) {</span><span class="s2">\n  </span><span class="s1">if (children) {</span><span class="s2">\n    </span><span class="s1">var child;</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; children.length; i++) {</span><span class="s2">\n      </span><span class="s1">child = children[i];</span><span class="s2">\n      </span><span class="s1">if (child.tag === 'a') {</span><span class="s2">\n        </span><span class="s1">return child;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (child.children &amp;&amp; (child = findAnchor(child.children))) {</span><span class="s2">\n        </span><span class="s1">return child;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var _Vue;</span><span class="s2">\n</span><span class="s1">function install(Vue) {</span><span class="s2">\n  </span><span class="s1">if (install.installed &amp;&amp; _Vue === Vue) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">install.installed = true;</span><span class="s2">\n  </span><span class="s1">_Vue = Vue;</span><span class="s2">\n  </span><span class="s1">var isDef = function (v) {</span><span class="s2">\n    </span><span class="s1">return v !== undefined;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">var registerInstance = function (vm, callVal) {</span><span class="s2">\n    </span><span class="s1">var i = vm.$options._parentVnode;</span><span class="s2">\n    </span><span class="s1">if (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)) {</span><span class="s2">\n      </span><span class="s1">i(vm, callVal);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">Vue.mixin({</span><span class="s2">\n    </span><span class="s1">beforeCreate: function beforeCreate() {</span><span class="s2">\n      </span><span class="s1">if (isDef(this.$options.router)) {</span><span class="s2">\n        </span><span class="s1">this._routerRoot = this;</span><span class="s2">\n        </span><span class="s1">this._router = this.$options.router;</span><span class="s2">\n        </span><span class="s1">this._router.init(this);</span><span class="s2">\n        </span><span class="s1">Vue.util.defineReactive(this, '_route', this._router.history.current);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this._routerRoot = this.$parent &amp;&amp; this.$parent._routerRoot || this;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">registerInstance(this, this);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">destroyed: function destroyed() {</span><span class="s2">\n      </span><span class="s1">registerInstance(this);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">Object.defineProperty(Vue.prototype, '$router', {</span><span class="s2">\n    </span><span class="s1">get: function get() {</span><span class="s2">\n      </span><span class="s1">return this._routerRoot._router;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">Object.defineProperty(Vue.prototype, '$route', {</span><span class="s2">\n    </span><span class="s1">get: function get() {</span><span class="s2">\n      </span><span class="s1">return this._routerRoot._route;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">Vue.component('RouterView', View);</span><span class="s2">\n  </span><span class="s1">Vue.component('RouterLink', Link);</span><span class="s2">\n  </span><span class="s1">var strats = Vue.config.optionMergeStrategies;</span><span class="s2">\n  </span><span class="s1">// use the same hook merging strategy for route hooks</span><span class="s2">\n  </span><span class="s1">strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var inBrowser = typeof window !== 'undefined';</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">function createRouteMap(routes, oldPathList, oldPathMap, oldNameMap, parentRoute) {</span><span class="s2">\n  </span><span class="s1">// the path list is used to control path matching priority</span><span class="s2">\n  </span><span class="s1">var pathList = oldPathList || [];</span><span class="s2">\n  </span><span class="s1">// $flow-disable-line</span><span class="s2">\n  </span><span class="s1">var pathMap = oldPathMap || Object.create(null);</span><span class="s2">\n  </span><span class="s1">// $flow-disable-line</span><span class="s2">\n  </span><span class="s1">var nameMap = oldNameMap || Object.create(null);</span><span class="s2">\n  </span><span class="s1">routes.forEach(function (route) {</span><span class="s2">\n    </span><span class="s1">addRouteRecord(pathList, pathMap, nameMap, route, parentRoute);</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n\n  </span><span class="s1">// ensure wildcard routes are always at the end</span><span class="s2">\n  </span><span class="s1">for (var i = 0, l = pathList.length; i &lt; l; i++) {</span><span class="s2">\n    </span><span class="s1">if (pathList[i] === '*') {</span><span class="s2">\n      </span><span class="s1">pathList.push(pathList.splice(i, 1)[0]);</span><span class="s2">\n      </span><span class="s1">l--;</span><span class="s2">\n      </span><span class="s1">i--;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s2">\n    </span><span class="s1">// warn if routes do not include leading slashes</span><span class="s2">\n    </span><span class="s1">var found = pathList</span><span class="s2">\n    </span><span class="s1">// check for missing leading slash</span><span class="s2">\n    </span><span class="s1">.filter(function (path) {</span><span class="s2">\n      </span><span class="s1">return path &amp;&amp; path.charAt(0) !== '*' &amp;&amp; path.charAt(0) !== '/';</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (found.length &gt; 0) {</span><span class="s2">\n      </span><span class="s1">var pathNames = found.map(function (path) {</span><span class="s2">\n        </span><span class="s1">return </span><span class="s2">\&quot;</span><span class="s1">- </span><span class="s2">\&quot; </span><span class="s1">+ path;</span><span class="s2">\n      </span><span class="s1">}).join('</span><span class="s2">\\</span><span class="s1">n');</span><span class="s2">\n      </span><span class="s1">warn(false, </span><span class="s2">\&quot;</span><span class="s1">Non-nested routes must include a leading slash character. Fix the following routes: </span><span class="s2">\\</span><span class="s1">n</span><span class="s2">\&quot; </span><span class="s1">+ pathNames);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">pathList: pathList,</span><span class="s2">\n    </span><span class="s1">pathMap: pathMap,</span><span class="s2">\n    </span><span class="s1">nameMap: nameMap</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {</span><span class="s2">\n  </span><span class="s1">var path = route.path;</span><span class="s2">\n  </span><span class="s1">var name = route.name;</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">assert(path != null, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">path</span><span class="s2">\\\&quot; </span><span class="s1">is required in a route configuration.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">assert(typeof route.component !== 'string', </span><span class="s2">\&quot;</span><span class="s1">route config </span><span class="s2">\\\&quot;</span><span class="s1">component</span><span class="s2">\\\&quot; </span><span class="s1">for path: </span><span class="s2">\&quot; </span><span class="s1">+ String(path || name) + </span><span class="s2">\&quot; </span><span class="s1">cannot be a </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">string id. Use an actual component instead.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">warn(</span><span class="s2">\n    </span><span class="s1">// eslint-disable-next-line no-control-regex</span><span class="s2">\n    </span><span class="s1">!/[^</span><span class="s2">\\</span><span class="s1">u0000-</span><span class="s2">\\</span><span class="s1">u007F]+/.test(path), </span><span class="s2">\&quot;</span><span class="s1">Route with path </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ path + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">contains unencoded characters, make sure </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">your path is correctly encoded before passing it to the router. Use </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">encodeURI to encode static segments of your path.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var pathToRegexpOptions = route.pathToRegexpOptions || {};</span><span class="s2">\n  </span><span class="s1">var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);</span><span class="s2">\n  </span><span class="s1">if (typeof route.caseSensitive === 'boolean') {</span><span class="s2">\n    </span><span class="s1">pathToRegexpOptions.sensitive = route.caseSensitive;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var record = {</span><span class="s2">\n    </span><span class="s1">path: normalizedPath,</span><span class="s2">\n    </span><span class="s1">regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),</span><span class="s2">\n    </span><span class="s1">components: route.components || {</span><span class="s2">\n      </span><span class="s1">default: route.component</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">alias: route.alias ? typeof route.alias === 'string' ? [route.alias] : route.alias : [],</span><span class="s2">\n    </span><span class="s1">instances: {},</span><span class="s2">\n    </span><span class="s1">enteredCbs: {},</span><span class="s2">\n    </span><span class="s1">name: name,</span><span class="s2">\n    </span><span class="s1">parent: parent,</span><span class="s2">\n    </span><span class="s1">matchAs: matchAs,</span><span class="s2">\n    </span><span class="s1">redirect: route.redirect,</span><span class="s2">\n    </span><span class="s1">beforeEnter: route.beforeEnter,</span><span class="s2">\n    </span><span class="s1">meta: route.meta || {},</span><span class="s2">\n    </span><span class="s1">props: route.props == null ? {} : route.components ? route.props : {</span><span class="s2">\n      </span><span class="s1">default: route.props</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (route.children) {</span><span class="s2">\n    </span><span class="s1">// Warn if route is named, does not redirect and has a default child route.</span><span class="s2">\n    </span><span class="s1">// If users navigate to this route by name, the default child will</span><span class="s2">\n    </span><span class="s1">// not be rendered (GH Issue #629)</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">if (route.name &amp;&amp; !route.redirect &amp;&amp; route.children.some(function (child) {</span><span class="s2">\n        </span><span class="s1">return /^</span><span class="s2">\\</span><span class="s1">/?$/.test(child.path);</span><span class="s2">\n      </span><span class="s1">})) {</span><span class="s2">\n        </span><span class="s1">warn(false, </span><span class="s2">\&quot;</span><span class="s1">Named Route '</span><span class="s2">\&quot; </span><span class="s1">+ route.name + </span><span class="s2">\&quot;</span><span class="s1">' has a default child route. </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">When navigating to this named route (:to=</span><span class="s2">\\\&quot;</span><span class="s1">{name: '</span><span class="s2">\&quot; </span><span class="s1">+ route.name + </span><span class="s2">\&quot;</span><span class="s1">'}</span><span class="s2">\\\&quot;</span><span class="s1">), </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">the default child route will not be rendered. Remove the name from </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">this route and use the name of the default child route for named </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">links instead.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">route.children.forEach(function (child) {</span><span class="s2">\n      </span><span class="s1">var childMatchAs = matchAs ? cleanPath(matchAs + </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">+ child.path) : undefined;</span><span class="s2">\n      </span><span class="s1">addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!pathMap[record.path]) {</span><span class="s2">\n    </span><span class="s1">pathList.push(record.path);</span><span class="s2">\n    </span><span class="s1">pathMap[record.path] = record;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (route.alias !== undefined) {</span><span class="s2">\n    </span><span class="s1">var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; aliases.length; ++i) {</span><span class="s2">\n      </span><span class="s1">var alias = aliases[i];</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; alias === path) {</span><span class="s2">\n        </span><span class="s1">warn(false, </span><span class="s2">\&quot;</span><span class="s1">Found an alias with the same value as the path: </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ path + </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">. You have to remove that alias. It will be ignored in development.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">// skip in dev to make it work</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">var aliasRoute = {</span><span class="s2">\n        </span><span class="s1">path: alias,</span><span class="s2">\n        </span><span class="s1">children: route.children</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (name) {</span><span class="s2">\n    </span><span class="s1">if (!nameMap[name]) {</span><span class="s2">\n      </span><span class="s1">nameMap[name] = record;</span><span class="s2">\n    </span><span class="s1">} else if (process.env.NODE_ENV !== 'production' &amp;&amp; !matchAs) {</span><span class="s2">\n      </span><span class="s1">warn(false, </span><span class="s2">\&quot;</span><span class="s1">Duplicate named routes definition: </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">{ name: </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ name + </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">, path: </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ record.path + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">}</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function compileRouteRegex(path, pathToRegexpOptions) {</span><span class="s2">\n  </span><span class="s1">var regex = pathToRegexp_1(path, [], pathToRegexpOptions);</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">var keys = Object.create(null);</span><span class="s2">\n    </span><span class="s1">regex.keys.forEach(function (key) {</span><span class="s2">\n      </span><span class="s1">warn(!keys[key.name], </span><span class="s2">\&quot;</span><span class="s1">Duplicate param keys in route with path: </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ path + </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">keys[key.name] = true;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return regex;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizePath(path, parent, strict) {</span><span class="s2">\n  </span><span class="s1">if (!strict) {</span><span class="s2">\n    </span><span class="s1">path = path.replace(/</span><span class="s2">\\</span><span class="s1">/$/, '');</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (path[0] === '/') {</span><span class="s2">\n    </span><span class="s1">return path;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (parent == null) {</span><span class="s2">\n    </span><span class="s1">return path;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return cleanPath(parent.path + </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">+ path);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">function createMatcher(routes, router) {</span><span class="s2">\n  </span><span class="s1">var ref = createRouteMap(routes);</span><span class="s2">\n  </span><span class="s1">var pathList = ref.pathList;</span><span class="s2">\n  </span><span class="s1">var pathMap = ref.pathMap;</span><span class="s2">\n  </span><span class="s1">var nameMap = ref.nameMap;</span><span class="s2">\n  </span><span class="s1">function addRoutes(routes) {</span><span class="s2">\n    </span><span class="s1">createRouteMap(routes, pathList, pathMap, nameMap);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function addRoute(parentOrRoute, route) {</span><span class="s2">\n    </span><span class="s1">var parent = typeof parentOrRoute !== 'object' ? nameMap[parentOrRoute] : undefined;</span><span class="s2">\n    </span><span class="s1">// $flow-disable-line</span><span class="s2">\n    </span><span class="s1">createRouteMap([route || parentOrRoute], pathList, pathMap, nameMap, parent);</span><span class="s2">\n\n    </span><span class="s1">// add aliases of parent</span><span class="s2">\n    </span><span class="s1">if (parent &amp;&amp; parent.alias.length) {</span><span class="s2">\n      </span><span class="s1">createRouteMap(</span><span class="s2">\n      </span><span class="s1">// $flow-disable-line route is defined if parent is</span><span class="s2">\n      </span><span class="s1">parent.alias.map(function (alias) {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">path: alias,</span><span class="s2">\n          </span><span class="s1">children: [route]</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}), pathList, pathMap, nameMap, parent);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function getRoutes() {</span><span class="s2">\n    </span><span class="s1">return pathList.map(function (path) {</span><span class="s2">\n      </span><span class="s1">return pathMap[path];</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function match(raw, currentRoute, redirectedFrom) {</span><span class="s2">\n    </span><span class="s1">var location = normalizeLocation(raw, currentRoute, false, router);</span><span class="s2">\n    </span><span class="s1">var name = location.name;</span><span class="s2">\n    </span><span class="s1">if (name) {</span><span class="s2">\n      </span><span class="s1">var record = nameMap[name];</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">warn(record, </span><span class="s2">\&quot;</span><span class="s1">Route with name '</span><span class="s2">\&quot; </span><span class="s1">+ name + </span><span class="s2">\&quot;</span><span class="s1">' does not exist</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (!record) {</span><span class="s2">\n        </span><span class="s1">return _createRoute(null, location);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">var paramNames = record.regex.keys.filter(function (key) {</span><span class="s2">\n        </span><span class="s1">return !key.optional;</span><span class="s2">\n      </span><span class="s1">}).map(function (key) {</span><span class="s2">\n        </span><span class="s1">return key.name;</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">if (typeof location.params !== 'object') {</span><span class="s2">\n        </span><span class="s1">location.params = {};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (currentRoute &amp;&amp; typeof currentRoute.params === 'object') {</span><span class="s2">\n        </span><span class="s1">for (var key in currentRoute.params) {</span><span class="s2">\n          </span><span class="s1">if (!(key in location.params) &amp;&amp; paramNames.indexOf(key) &gt; -1) {</span><span class="s2">\n            </span><span class="s1">location.params[key] = currentRoute.params[key];</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">location.path = fillParams(record.path, location.params, </span><span class="s2">\&quot;</span><span class="s1">named route </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ name + </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return _createRoute(record, location, redirectedFrom);</span><span class="s2">\n    </span><span class="s1">} else if (location.path) {</span><span class="s2">\n      </span><span class="s1">location.params = {};</span><span class="s2">\n      </span><span class="s1">for (var i = 0; i &lt; pathList.length; i++) {</span><span class="s2">\n        </span><span class="s1">var path = pathList[i];</span><span class="s2">\n        </span><span class="s1">var record$1 = pathMap[path];</span><span class="s2">\n        </span><span class="s1">if (matchRoute(record$1.regex, location.path, location.params)) {</span><span class="s2">\n          </span><span class="s1">return _createRoute(record$1, location, redirectedFrom);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// no match</span><span class="s2">\n    </span><span class="s1">return _createRoute(null, location);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function redirect(record, location) {</span><span class="s2">\n    </span><span class="s1">var originalRedirect = record.redirect;</span><span class="s2">\n    </span><span class="s1">var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;</span><span class="s2">\n    </span><span class="s1">if (typeof redirect === 'string') {</span><span class="s2">\n      </span><span class="s1">redirect = {</span><span class="s2">\n        </span><span class="s1">path: redirect</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!redirect || typeof redirect !== 'object') {</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">warn(false, </span><span class="s2">\&quot;</span><span class="s1">invalid redirect option: </span><span class="s2">\&quot; </span><span class="s1">+ JSON.stringify(redirect));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return _createRoute(null, location);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var re = redirect;</span><span class="s2">\n    </span><span class="s1">var name = re.name;</span><span class="s2">\n    </span><span class="s1">var path = re.path;</span><span class="s2">\n    </span><span class="s1">var query = location.query;</span><span class="s2">\n    </span><span class="s1">var hash = location.hash;</span><span class="s2">\n    </span><span class="s1">var params = location.params;</span><span class="s2">\n    </span><span class="s1">query = re.hasOwnProperty('query') ? re.query : query;</span><span class="s2">\n    </span><span class="s1">hash = re.hasOwnProperty('hash') ? re.hash : hash;</span><span class="s2">\n    </span><span class="s1">params = re.hasOwnProperty('params') ? re.params : params;</span><span class="s2">\n    </span><span class="s1">if (name) {</span><span class="s2">\n      </span><span class="s1">// resolved named direct</span><span class="s2">\n      </span><span class="s1">var targetRecord = nameMap[name];</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">assert(targetRecord, </span><span class="s2">\&quot;</span><span class="s1">redirect failed: named route </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ name + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">not found.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return match({</span><span class="s2">\n        </span><span class="s1">_normalized: true,</span><span class="s2">\n        </span><span class="s1">name: name,</span><span class="s2">\n        </span><span class="s1">query: query,</span><span class="s2">\n        </span><span class="s1">hash: hash,</span><span class="s2">\n        </span><span class="s1">params: params</span><span class="s2">\n      </span><span class="s1">}, undefined, location);</span><span class="s2">\n    </span><span class="s1">} else if (path) {</span><span class="s2">\n      </span><span class="s1">// 1. resolve relative redirect</span><span class="s2">\n      </span><span class="s1">var rawPath = resolveRecordPath(path, record);</span><span class="s2">\n      </span><span class="s1">// 2. resolve params</span><span class="s2">\n      </span><span class="s1">var resolvedPath = fillParams(rawPath, params, </span><span class="s2">\&quot;</span><span class="s1">redirect route with path </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ rawPath + </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">// 3. rematch with existing query and hash</span><span class="s2">\n      </span><span class="s1">return match({</span><span class="s2">\n        </span><span class="s1">_normalized: true,</span><span class="s2">\n        </span><span class="s1">path: resolvedPath,</span><span class="s2">\n        </span><span class="s1">query: query,</span><span class="s2">\n        </span><span class="s1">hash: hash</span><span class="s2">\n      </span><span class="s1">}, undefined, location);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">warn(false, </span><span class="s2">\&quot;</span><span class="s1">invalid redirect option: </span><span class="s2">\&quot; </span><span class="s1">+ JSON.stringify(redirect));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return _createRoute(null, location);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function alias(record, location, matchAs) {</span><span class="s2">\n    </span><span class="s1">var aliasedPath = fillParams(matchAs, location.params, </span><span class="s2">\&quot;</span><span class="s1">aliased route with path </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ matchAs + </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">var aliasedMatch = match({</span><span class="s2">\n      </span><span class="s1">_normalized: true,</span><span class="s2">\n      </span><span class="s1">path: aliasedPath</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (aliasedMatch) {</span><span class="s2">\n      </span><span class="s1">var matched = aliasedMatch.matched;</span><span class="s2">\n      </span><span class="s1">var aliasedRecord = matched[matched.length - 1];</span><span class="s2">\n      </span><span class="s1">location.params = aliasedMatch.params;</span><span class="s2">\n      </span><span class="s1">return _createRoute(aliasedRecord, location);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return _createRoute(null, location);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function _createRoute(record, location, redirectedFrom) {</span><span class="s2">\n    </span><span class="s1">if (record &amp;&amp; record.redirect) {</span><span class="s2">\n      </span><span class="s1">return redirect(record, redirectedFrom || location);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (record &amp;&amp; record.matchAs) {</span><span class="s2">\n      </span><span class="s1">return alias(record, location, record.matchAs);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return createRoute(record, location, redirectedFrom, router);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">match: match,</span><span class="s2">\n    </span><span class="s1">addRoute: addRoute,</span><span class="s2">\n    </span><span class="s1">getRoutes: getRoutes,</span><span class="s2">\n    </span><span class="s1">addRoutes: addRoutes</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function matchRoute(regex, path, params) {</span><span class="s2">\n  </span><span class="s1">var m = path.match(regex);</span><span class="s2">\n  </span><span class="s1">if (!m) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">} else if (!params) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">for (var i = 1, len = m.length; i &lt; len; ++i) {</span><span class="s2">\n    </span><span class="s1">var key = regex.keys[i - 1];</span><span class="s2">\n    </span><span class="s1">if (key) {</span><span class="s2">\n      </span><span class="s1">// Fix #1994: using * with props: true generates a param named 0</span><span class="s2">\n      </span><span class="s1">params[key.name || 'pathMatch'] = typeof m[i] === 'string' ? decode(m[i]) : m[i];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveRecordPath(path, record) {</span><span class="s2">\n  </span><span class="s1">return resolvePath(path, record.parent ? record.parent.path : '/', true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">// use User Timing api (if present) for more accurate key precision</span><span class="s2">\n</span><span class="s1">var Time = inBrowser &amp;&amp; window.performance &amp;&amp; window.performance.now ? window.performance : Date;</span><span class="s2">\n</span><span class="s1">function genStateKey() {</span><span class="s2">\n  </span><span class="s1">return Time.now().toFixed(3);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var _key = genStateKey();</span><span class="s2">\n</span><span class="s1">function getStateKey() {</span><span class="s2">\n  </span><span class="s1">return _key;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setStateKey(key) {</span><span class="s2">\n  </span><span class="s1">return _key = key;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var positionStore = Object.create(null);</span><span class="s2">\n</span><span class="s1">function setupScroll() {</span><span class="s2">\n  </span><span class="s1">// Prevent browser scroll behavior on History popstate</span><span class="s2">\n  </span><span class="s1">if ('scrollRestoration' in window.history) {</span><span class="s2">\n    </span><span class="s1">window.history.scrollRestoration = 'manual';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// Fix for #1585 for Firefox</span><span class="s2">\n  </span><span class="s1">// Fix for #2195 Add optional third attribute to workaround a bug in safari https://bugs.webkit.org/show_bug.cgi?id=182678</span><span class="s2">\n  </span><span class="s1">// Fix for #2774 Support for apps loaded from Windows file shares not mapped to network drives: replaced location.origin with</span><span class="s2">\n  </span><span class="s1">// window.location.protocol + '//' + window.location.host</span><span class="s2">\n  </span><span class="s1">// location.host contains the port and location.hostname doesn't</span><span class="s2">\n  </span><span class="s1">var protocolAndPath = window.location.protocol + '//' + window.location.host;</span><span class="s2">\n  </span><span class="s1">var absolutePath = window.location.href.replace(protocolAndPath, '');</span><span class="s2">\n  </span><span class="s1">// preserve existing history state as it could be overriden by the user</span><span class="s2">\n  </span><span class="s1">var stateCopy = extend({}, window.history.state);</span><span class="s2">\n  </span><span class="s1">stateCopy.key = getStateKey();</span><span class="s2">\n  </span><span class="s1">window.history.replaceState(stateCopy, '', absolutePath);</span><span class="s2">\n  </span><span class="s1">window.addEventListener('popstate', handlePopState);</span><span class="s2">\n  </span><span class="s1">return function () {</span><span class="s2">\n    </span><span class="s1">window.removeEventListener('popstate', handlePopState);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function handleScroll(router, to, from, isPop) {</span><span class="s2">\n  </span><span class="s1">if (!router.app) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var behavior = router.options.scrollBehavior;</span><span class="s2">\n  </span><span class="s1">if (!behavior) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">assert(typeof behavior === 'function', </span><span class="s2">\&quot;</span><span class="s1">scrollBehavior must be a function</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// wait until re-render finishes before scrolling</span><span class="s2">\n  </span><span class="s1">router.app.$nextTick(function () {</span><span class="s2">\n    </span><span class="s1">var position = getScrollPosition();</span><span class="s2">\n    </span><span class="s1">var shouldScroll = behavior.call(router, to, from, isPop ? position : null);</span><span class="s2">\n    </span><span class="s1">if (!shouldScroll) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (typeof shouldScroll.then === 'function') {</span><span class="s2">\n      </span><span class="s1">shouldScroll.then(function (shouldScroll) {</span><span class="s2">\n        </span><span class="s1">scrollToPosition(shouldScroll, position);</span><span class="s2">\n      </span><span class="s1">}).catch(function (err) {</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n          </span><span class="s1">assert(false, err.toString());</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">scrollToPosition(shouldScroll, position);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function saveScrollPosition() {</span><span class="s2">\n  </span><span class="s1">var key = getStateKey();</span><span class="s2">\n  </span><span class="s1">if (key) {</span><span class="s2">\n    </span><span class="s1">positionStore[key] = {</span><span class="s2">\n      </span><span class="s1">x: window.pageXOffset,</span><span class="s2">\n      </span><span class="s1">y: window.pageYOffset</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function handlePopState(e) {</span><span class="s2">\n  </span><span class="s1">saveScrollPosition();</span><span class="s2">\n  </span><span class="s1">if (e.state &amp;&amp; e.state.key) {</span><span class="s2">\n    </span><span class="s1">setStateKey(e.state.key);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getScrollPosition() {</span><span class="s2">\n  </span><span class="s1">var key = getStateKey();</span><span class="s2">\n  </span><span class="s1">if (key) {</span><span class="s2">\n    </span><span class="s1">return positionStore[key];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getElementPosition(el, offset) {</span><span class="s2">\n  </span><span class="s1">var docEl = document.documentElement;</span><span class="s2">\n  </span><span class="s1">var docRect = docEl.getBoundingClientRect();</span><span class="s2">\n  </span><span class="s1">var elRect = el.getBoundingClientRect();</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">x: elRect.left - docRect.left - offset.x,</span><span class="s2">\n    </span><span class="s1">y: elRect.top - docRect.top - offset.y</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isValidPosition(obj) {</span><span class="s2">\n  </span><span class="s1">return isNumber(obj.x) || isNumber(obj.y);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizePosition(obj) {</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">x: isNumber(obj.x) ? obj.x : window.pageXOffset,</span><span class="s2">\n    </span><span class="s1">y: isNumber(obj.y) ? obj.y : window.pageYOffset</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeOffset(obj) {</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">x: isNumber(obj.x) ? obj.x : 0,</span><span class="s2">\n    </span><span class="s1">y: isNumber(obj.y) ? obj.y : 0</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isNumber(v) {</span><span class="s2">\n  </span><span class="s1">return typeof v === 'number';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var hashStartsWithNumberRE = /^#</span><span class="s2">\\</span><span class="s1">d/;</span><span class="s2">\n</span><span class="s1">function scrollToPosition(shouldScroll, position) {</span><span class="s2">\n  </span><span class="s1">var isObject = typeof shouldScroll === 'object';</span><span class="s2">\n  </span><span class="s1">if (isObject &amp;&amp; typeof shouldScroll.selector === 'string') {</span><span class="s2">\n    </span><span class="s1">// getElementById would still fail if the selector contains a more complicated query like #main[data-attr]</span><span class="s2">\n    </span><span class="s1">// but at the same time, it doesn't make much sense to select an element with an id and an extra selector</span><span class="s2">\n    </span><span class="s1">var el = hashStartsWithNumberRE.test(shouldScroll.selector) // $flow-disable-line</span><span class="s2">\n    </span><span class="s1">? document.getElementById(shouldScroll.selector.slice(1)) // $flow-disable-line</span><span class="s2">\n    </span><span class="s1">: document.querySelector(shouldScroll.selector);</span><span class="s2">\n    </span><span class="s1">if (el) {</span><span class="s2">\n      </span><span class="s1">var offset = shouldScroll.offset &amp;&amp; typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};</span><span class="s2">\n      </span><span class="s1">offset = normalizeOffset(offset);</span><span class="s2">\n      </span><span class="s1">position = getElementPosition(el, offset);</span><span class="s2">\n    </span><span class="s1">} else if (isValidPosition(shouldScroll)) {</span><span class="s2">\n      </span><span class="s1">position = normalizePosition(shouldScroll);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (isObject &amp;&amp; isValidPosition(shouldScroll)) {</span><span class="s2">\n    </span><span class="s1">position = normalizePosition(shouldScroll);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (position) {</span><span class="s2">\n    </span><span class="s1">// $flow-disable-line</span><span class="s2">\n    </span><span class="s1">if ('scrollBehavior' in document.documentElement.style) {</span><span class="s2">\n      </span><span class="s1">window.scrollTo({</span><span class="s2">\n        </span><span class="s1">left: position.x,</span><span class="s2">\n        </span><span class="s1">top: position.y,</span><span class="s2">\n        </span><span class="s1">// $flow-disable-line</span><span class="s2">\n        </span><span class="s1">behavior: shouldScroll.behavior</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">window.scrollTo(position.x, position.y);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var supportsPushState = inBrowser &amp;&amp; function () {</span><span class="s2">\n  </span><span class="s1">var ua = window.navigator.userAgent;</span><span class="s2">\n  </span><span class="s1">if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &amp;&amp; ua.indexOf('Mobile Safari') !== -1 &amp;&amp; ua.indexOf('Chrome') === -1 &amp;&amp; ua.indexOf('Windows Phone') === -1) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return window.history &amp;&amp; typeof window.history.pushState === 'function';</span><span class="s2">\n</span><span class="s1">}();</span><span class="s2">\n</span><span class="s1">function pushState(url, replace) {</span><span class="s2">\n  </span><span class="s1">saveScrollPosition();</span><span class="s2">\n  </span><span class="s1">// try...catch the pushState call to get around Safari</span><span class="s2">\n  </span><span class="s1">// DOM Exception 18 where it limits to 100 pushState calls</span><span class="s2">\n  </span><span class="s1">var history = window.history;</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">if (replace) {</span><span class="s2">\n      </span><span class="s1">// preserve existing history state as it could be overriden by the user</span><span class="s2">\n      </span><span class="s1">var stateCopy = extend({}, history.state);</span><span class="s2">\n      </span><span class="s1">stateCopy.key = getStateKey();</span><span class="s2">\n      </span><span class="s1">history.replaceState(stateCopy, '', url);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">history.pushState({</span><span class="s2">\n        </span><span class="s1">key: setStateKey(genStateKey())</span><span class="s2">\n      </span><span class="s1">}, '', url);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">window.location[replace ? 'replace' : 'assign'](url);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function replaceState(url) {</span><span class="s2">\n  </span><span class="s1">pushState(url, true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// When changing thing, also edit router.d.ts</span><span class="s2">\n</span><span class="s1">var NavigationFailureType = {</span><span class="s2">\n  </span><span class="s1">redirected: 2,</span><span class="s2">\n  </span><span class="s1">aborted: 4,</span><span class="s2">\n  </span><span class="s1">cancelled: 8,</span><span class="s2">\n  </span><span class="s1">duplicated: 16</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function createNavigationRedirectedError(from, to) {</span><span class="s2">\n  </span><span class="s1">return createRouterError(from, to, NavigationFailureType.redirected, </span><span class="s2">\&quot;</span><span class="s1">Redirected when going from </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ from.fullPath + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">to </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ stringifyRoute(to) + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">via a navigation guard.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createNavigationDuplicatedError(from, to) {</span><span class="s2">\n  </span><span class="s1">var error = createRouterError(from, to, NavigationFailureType.duplicated, </span><span class="s2">\&quot;</span><span class="s1">Avoided redundant navigation to current location: </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ from.fullPath + </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">// backwards compatible with the first introduction of Errors</span><span class="s2">\n  </span><span class="s1">error.name = 'NavigationDuplicated';</span><span class="s2">\n  </span><span class="s1">return error;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createNavigationCancelledError(from, to) {</span><span class="s2">\n  </span><span class="s1">return createRouterError(from, to, NavigationFailureType.cancelled, </span><span class="s2">\&quot;</span><span class="s1">Navigation cancelled from </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ from.fullPath + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">to </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ to.fullPath + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">with a new navigation.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createNavigationAbortedError(from, to) {</span><span class="s2">\n  </span><span class="s1">return createRouterError(from, to, NavigationFailureType.aborted, </span><span class="s2">\&quot;</span><span class="s1">Navigation aborted from </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ from.fullPath + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">to </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ to.fullPath + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">via a navigation guard.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createRouterError(from, to, type, message) {</span><span class="s2">\n  </span><span class="s1">var error = new Error(message);</span><span class="s2">\n  </span><span class="s1">error._isRouter = true;</span><span class="s2">\n  </span><span class="s1">error.from = from;</span><span class="s2">\n  </span><span class="s1">error.to = to;</span><span class="s2">\n  </span><span class="s1">error.type = type;</span><span class="s2">\n  </span><span class="s1">return error;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var propertiesToLog = ['params', 'query', 'hash'];</span><span class="s2">\n</span><span class="s1">function stringifyRoute(to) {</span><span class="s2">\n  </span><span class="s1">if (typeof to === 'string') {</span><span class="s2">\n    </span><span class="s1">return to;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if ('path' in to) {</span><span class="s2">\n    </span><span class="s1">return to.path;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var location = {};</span><span class="s2">\n  </span><span class="s1">propertiesToLog.forEach(function (key) {</span><span class="s2">\n    </span><span class="s1">if (key in to) {</span><span class="s2">\n      </span><span class="s1">location[key] = to[key];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return JSON.stringify(location, null, 2);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isError(err) {</span><span class="s2">\n  </span><span class="s1">return Object.prototype.toString.call(err).indexOf('Error') &gt; -1;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isNavigationFailure(err, errorType) {</span><span class="s2">\n  </span><span class="s1">return isError(err) &amp;&amp; err._isRouter &amp;&amp; (errorType == null || err.type === errorType);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">function runQueue(queue, fn, cb) {</span><span class="s2">\n  </span><span class="s1">var step = function (index) {</span><span class="s2">\n    </span><span class="s1">if (index &gt;= queue.length) {</span><span class="s2">\n      </span><span class="s1">cb();</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">if (queue[index]) {</span><span class="s2">\n        </span><span class="s1">fn(queue[index], function () {</span><span class="s2">\n          </span><span class="s1">step(index + 1);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">step(index + 1);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">step(0);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">function resolveAsyncComponents(matched) {</span><span class="s2">\n  </span><span class="s1">return function (to, from, next) {</span><span class="s2">\n    </span><span class="s1">var hasAsync = false;</span><span class="s2">\n    </span><span class="s1">var pending = 0;</span><span class="s2">\n    </span><span class="s1">var error = null;</span><span class="s2">\n    </span><span class="s1">flatMapComponents(matched, function (def, _, match, key) {</span><span class="s2">\n      </span><span class="s1">// if it's a function and doesn't have cid attached,</span><span class="s2">\n      </span><span class="s1">// assume it's an async component resolve function.</span><span class="s2">\n      </span><span class="s1">// we are not using Vue's default async resolving mechanism because</span><span class="s2">\n      </span><span class="s1">// we want to halt the navigation until the incoming component has been</span><span class="s2">\n      </span><span class="s1">// resolved.</span><span class="s2">\n      </span><span class="s1">if (typeof def === 'function' &amp;&amp; def.cid === undefined) {</span><span class="s2">\n        </span><span class="s1">hasAsync = true;</span><span class="s2">\n        </span><span class="s1">pending++;</span><span class="s2">\n        </span><span class="s1">var resolve = once(function (resolvedDef) {</span><span class="s2">\n          </span><span class="s1">if (isESModule(resolvedDef)) {</span><span class="s2">\n            </span><span class="s1">resolvedDef = resolvedDef.default;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">// save resolved on async factory in case it's used elsewhere</span><span class="s2">\n          </span><span class="s1">def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef);</span><span class="s2">\n          </span><span class="s1">match.components[key] = resolvedDef;</span><span class="s2">\n          </span><span class="s1">pending--;</span><span class="s2">\n          </span><span class="s1">if (pending &lt;= 0) {</span><span class="s2">\n            </span><span class="s1">next();</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">var reject = once(function (reason) {</span><span class="s2">\n          </span><span class="s1">var msg = </span><span class="s2">\&quot;</span><span class="s1">Failed to resolve async component </span><span class="s2">\&quot; </span><span class="s1">+ key + </span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot; </span><span class="s1">+ reason;</span><span class="s2">\n          </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(false, msg);</span><span class="s2">\n          </span><span class="s1">if (!error) {</span><span class="s2">\n            </span><span class="s1">error = isError(reason) ? reason : new Error(msg);</span><span class="s2">\n            </span><span class="s1">next(error);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">var res;</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n          </span><span class="s1">res = def(resolve, reject);</span><span class="s2">\n        </span><span class="s1">} catch (e) {</span><span class="s2">\n          </span><span class="s1">reject(e);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (res) {</span><span class="s2">\n          </span><span class="s1">if (typeof res.then === 'function') {</span><span class="s2">\n            </span><span class="s1">res.then(resolve, reject);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">// new syntax in Vue 2.3</span><span class="s2">\n            </span><span class="s1">var comp = res.component;</span><span class="s2">\n            </span><span class="s1">if (comp &amp;&amp; typeof comp.then === 'function') {</span><span class="s2">\n              </span><span class="s1">comp.then(resolve, reject);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (!hasAsync) {</span><span class="s2">\n      </span><span class="s1">next();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function flatMapComponents(matched, fn) {</span><span class="s2">\n  </span><span class="s1">return flatten(matched.map(function (m) {</span><span class="s2">\n    </span><span class="s1">return Object.keys(m.components).map(function (key) {</span><span class="s2">\n      </span><span class="s1">return fn(m.components[key], m.instances[key], m, key);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function flatten(arr) {</span><span class="s2">\n  </span><span class="s1">return Array.prototype.concat.apply([], arr);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var hasSymbol = typeof Symbol === 'function' &amp;&amp; typeof Symbol.toStringTag === 'symbol';</span><span class="s2">\n</span><span class="s1">function isESModule(obj) {</span><span class="s2">\n  </span><span class="s1">return obj.__esModule || hasSymbol &amp;&amp; obj[Symbol.toStringTag] === 'Module';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// in Webpack 2, require.ensure now also returns a Promise</span><span class="s2">\n</span><span class="s1">// so the resolve/reject functions may get called an extra time</span><span class="s2">\n</span><span class="s1">// if the user uses an arrow function shorthand that happens to</span><span class="s2">\n</span><span class="s1">// return that Promise.</span><span class="s2">\n</span><span class="s1">function once(fn) {</span><span class="s2">\n  </span><span class="s1">var called = false;</span><span class="s2">\n  </span><span class="s1">return function () {</span><span class="s2">\n    </span><span class="s1">var args = [],</span><span class="s2">\n      </span><span class="s1">len = arguments.length;</span><span class="s2">\n    </span><span class="s1">while (len--) args[len] = arguments[len];</span><span class="s2">\n    </span><span class="s1">if (called) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">called = true;</span><span class="s2">\n    </span><span class="s1">return fn.apply(this, args);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var History = function History(router, base) {</span><span class="s2">\n  </span><span class="s1">this.router = router;</span><span class="s2">\n  </span><span class="s1">this.base = normalizeBase(base);</span><span class="s2">\n  </span><span class="s1">// start with a route object that stands for </span><span class="s2">\&quot;</span><span class="s1">nowhere</span><span class="s2">\&quot;\n  </span><span class="s1">this.current = START;</span><span class="s2">\n  </span><span class="s1">this.pending = null;</span><span class="s2">\n  </span><span class="s1">this.ready = false;</span><span class="s2">\n  </span><span class="s1">this.readyCbs = [];</span><span class="s2">\n  </span><span class="s1">this.readyErrorCbs = [];</span><span class="s2">\n  </span><span class="s1">this.errorCbs = [];</span><span class="s2">\n  </span><span class="s1">this.listeners = [];</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">History.prototype.listen = function listen(cb) {</span><span class="s2">\n  </span><span class="s1">this.cb = cb;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">History.prototype.onReady = function onReady(cb, errorCb) {</span><span class="s2">\n  </span><span class="s1">if (this.ready) {</span><span class="s2">\n    </span><span class="s1">cb();</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">this.readyCbs.push(cb);</span><span class="s2">\n    </span><span class="s1">if (errorCb) {</span><span class="s2">\n      </span><span class="s1">this.readyErrorCbs.push(errorCb);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">History.prototype.onError = function onError(errorCb) {</span><span class="s2">\n  </span><span class="s1">this.errorCbs.push(errorCb);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {</span><span class="s2">\n  </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n  </span><span class="s1">var route;</span><span class="s2">\n  </span><span class="s1">// catch redirect option https://github.com/vuejs/vue-router/issues/3201</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">route = this.router.match(location, this.current);</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">this.errorCbs.forEach(function (cb) {</span><span class="s2">\n      </span><span class="s1">cb(e);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">// Exception should still be thrown</span><span class="s2">\n    </span><span class="s1">throw e;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var prev = this.current;</span><span class="s2">\n  </span><span class="s1">this.confirmTransition(route, function () {</span><span class="s2">\n    </span><span class="s1">this$1$1.updateRoute(route);</span><span class="s2">\n    </span><span class="s1">onComplete &amp;&amp; onComplete(route);</span><span class="s2">\n    </span><span class="s1">this$1$1.ensureURL();</span><span class="s2">\n    </span><span class="s1">this$1$1.router.afterHooks.forEach(function (hook) {</span><span class="s2">\n      </span><span class="s1">hook &amp;&amp; hook(route, prev);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n\n    </span><span class="s1">// fire ready cbs once</span><span class="s2">\n    </span><span class="s1">if (!this$1$1.ready) {</span><span class="s2">\n      </span><span class="s1">this$1$1.ready = true;</span><span class="s2">\n      </span><span class="s1">this$1$1.readyCbs.forEach(function (cb) {</span><span class="s2">\n        </span><span class="s1">cb(route);</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, function (err) {</span><span class="s2">\n    </span><span class="s1">if (onAbort) {</span><span class="s2">\n      </span><span class="s1">onAbort(err);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (err &amp;&amp; !this$1$1.ready) {</span><span class="s2">\n      </span><span class="s1">// Initial redirection should not mark the history as ready yet</span><span class="s2">\n      </span><span class="s1">// because it's triggered by the redirection instead</span><span class="s2">\n      </span><span class="s1">// https://github.com/vuejs/vue-router/issues/3225</span><span class="s2">\n      </span><span class="s1">// https://github.com/vuejs/vue-router/issues/3331</span><span class="s2">\n      </span><span class="s1">if (!isNavigationFailure(err, NavigationFailureType.redirected) || prev !== START) {</span><span class="s2">\n        </span><span class="s1">this$1$1.ready = true;</span><span class="s2">\n        </span><span class="s1">this$1$1.readyErrorCbs.forEach(function (cb) {</span><span class="s2">\n          </span><span class="s1">cb(err);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {</span><span class="s2">\n  </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n  </span><span class="s1">var current = this.current;</span><span class="s2">\n  </span><span class="s1">this.pending = route;</span><span class="s2">\n  </span><span class="s1">var abort = function (err) {</span><span class="s2">\n    </span><span class="s1">// changed after adding errors with</span><span class="s2">\n    </span><span class="s1">// https://github.com/vuejs/vue-router/pull/3047 before that change,</span><span class="s2">\n    </span><span class="s1">// redirect and aborted navigation would produce an err == null</span><span class="s2">\n    </span><span class="s1">if (!isNavigationFailure(err) &amp;&amp; isError(err)) {</span><span class="s2">\n      </span><span class="s1">if (this$1$1.errorCbs.length) {</span><span class="s2">\n        </span><span class="s1">this$1$1.errorCbs.forEach(function (cb) {</span><span class="s2">\n          </span><span class="s1">cb(err);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n          </span><span class="s1">warn(false, 'uncaught error during route navigation:');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">console.error(err);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">onAbort &amp;&amp; onAbort(err);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">var lastRouteIndex = route.matched.length - 1;</span><span class="s2">\n  </span><span class="s1">var lastCurrentIndex = current.matched.length - 1;</span><span class="s2">\n  </span><span class="s1">if (isSameRoute(route, current) &amp;&amp;</span><span class="s2">\n  </span><span class="s1">// in the case the route map has been dynamically appended to</span><span class="s2">\n  </span><span class="s1">lastRouteIndex === lastCurrentIndex &amp;&amp; route.matched[lastRouteIndex] === current.matched[lastCurrentIndex]) {</span><span class="s2">\n    </span><span class="s1">this.ensureURL();</span><span class="s2">\n    </span><span class="s1">if (route.hash) {</span><span class="s2">\n      </span><span class="s1">handleScroll(this.router, current, route, false);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return abort(createNavigationDuplicatedError(current, route));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var ref = resolveQueue(this.current.matched, route.matched);</span><span class="s2">\n  </span><span class="s1">var updated = ref.updated;</span><span class="s2">\n  </span><span class="s1">var deactivated = ref.deactivated;</span><span class="s2">\n  </span><span class="s1">var activated = ref.activated;</span><span class="s2">\n  </span><span class="s1">var queue = [].concat(</span><span class="s2">\n  </span><span class="s1">// in-component leave guards</span><span class="s2">\n  </span><span class="s1">extractLeaveGuards(deactivated),</span><span class="s2">\n  </span><span class="s1">// global before hooks</span><span class="s2">\n  </span><span class="s1">this.router.beforeHooks,</span><span class="s2">\n  </span><span class="s1">// in-component update hooks</span><span class="s2">\n  </span><span class="s1">extractUpdateHooks(updated),</span><span class="s2">\n  </span><span class="s1">// in-config enter guards</span><span class="s2">\n  </span><span class="s1">activated.map(function (m) {</span><span class="s2">\n    </span><span class="s1">return m.beforeEnter;</span><span class="s2">\n  </span><span class="s1">}),</span><span class="s2">\n  </span><span class="s1">// async components</span><span class="s2">\n  </span><span class="s1">resolveAsyncComponents(activated));</span><span class="s2">\n  </span><span class="s1">var iterator = function (hook, next) {</span><span class="s2">\n    </span><span class="s1">if (this$1$1.pending !== route) {</span><span class="s2">\n      </span><span class="s1">return abort(createNavigationCancelledError(current, route));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">hook(route, current, function (to) {</span><span class="s2">\n        </span><span class="s1">if (to === false) {</span><span class="s2">\n          </span><span class="s1">// next(false) -&gt; abort navigation, ensure current URL</span><span class="s2">\n          </span><span class="s1">this$1$1.ensureURL(true);</span><span class="s2">\n          </span><span class="s1">abort(createNavigationAbortedError(current, route));</span><span class="s2">\n        </span><span class="s1">} else if (isError(to)) {</span><span class="s2">\n          </span><span class="s1">this$1$1.ensureURL(true);</span><span class="s2">\n          </span><span class="s1">abort(to);</span><span class="s2">\n        </span><span class="s1">} else if (typeof to === 'string' || typeof to === 'object' &amp;&amp; (typeof to.path === 'string' || typeof to.name === 'string')) {</span><span class="s2">\n          </span><span class="s1">// next('/') or next({ path: '/' }) -&gt; redirect</span><span class="s2">\n          </span><span class="s1">abort(createNavigationRedirectedError(current, route));</span><span class="s2">\n          </span><span class="s1">if (typeof to === 'object' &amp;&amp; to.replace) {</span><span class="s2">\n            </span><span class="s1">this$1$1.replace(to);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">this$1$1.push(to);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">// confirm transition and pass on the value</span><span class="s2">\n          </span><span class="s1">next(to);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">abort(e);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">runQueue(queue, iterator, function () {</span><span class="s2">\n    </span><span class="s1">// wait until async components are resolved before</span><span class="s2">\n    </span><span class="s1">// extracting in-component enter guards</span><span class="s2">\n    </span><span class="s1">var enterGuards = extractEnterGuards(activated);</span><span class="s2">\n    </span><span class="s1">var queue = enterGuards.concat(this$1$1.router.resolveHooks);</span><span class="s2">\n    </span><span class="s1">runQueue(queue, iterator, function () {</span><span class="s2">\n      </span><span class="s1">if (this$1$1.pending !== route) {</span><span class="s2">\n        </span><span class="s1">return abort(createNavigationCancelledError(current, route));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this$1$1.pending = null;</span><span class="s2">\n      </span><span class="s1">onComplete(route);</span><span class="s2">\n      </span><span class="s1">if (this$1$1.router.app) {</span><span class="s2">\n        </span><span class="s1">this$1$1.router.app.$nextTick(function () {</span><span class="s2">\n          </span><span class="s1">handleRouteEntered(route);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">History.prototype.updateRoute = function updateRoute(route) {</span><span class="s2">\n  </span><span class="s1">this.current = route;</span><span class="s2">\n  </span><span class="s1">this.cb &amp;&amp; this.cb(route);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">History.prototype.setupListeners = function setupListeners() {</span><span class="s2">\n  </span><span class="s1">// Default implementation is empty</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">History.prototype.teardown = function teardown() {</span><span class="s2">\n  </span><span class="s1">// clean up event listeners</span><span class="s2">\n  </span><span class="s1">// https://github.com/vuejs/vue-router/issues/2341</span><span class="s2">\n  </span><span class="s1">this.listeners.forEach(function (cleanupListener) {</span><span class="s2">\n    </span><span class="s1">cleanupListener();</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">this.listeners = [];</span><span class="s2">\n\n  </span><span class="s1">// reset current history route</span><span class="s2">\n  </span><span class="s1">// https://github.com/vuejs/vue-router/issues/3294</span><span class="s2">\n  </span><span class="s1">this.current = START;</span><span class="s2">\n  </span><span class="s1">this.pending = null;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function normalizeBase(base) {</span><span class="s2">\n  </span><span class="s1">if (!base) {</span><span class="s2">\n    </span><span class="s1">if (inBrowser) {</span><span class="s2">\n      </span><span class="s1">// respect &lt;base&gt; tag</span><span class="s2">\n      </span><span class="s1">var baseEl = document.querySelector('base');</span><span class="s2">\n      </span><span class="s1">base = baseEl &amp;&amp; baseEl.getAttribute('href') || '/';</span><span class="s2">\n      </span><span class="s1">// strip full URL origin</span><span class="s2">\n      </span><span class="s1">base = base.replace(/^https?:</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">/[^</span><span class="s2">\\</span><span class="s1">/]+/, '');</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">base = '/';</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// make sure there's the starting slash</span><span class="s2">\n  </span><span class="s1">if (base.charAt(0) !== '/') {</span><span class="s2">\n    </span><span class="s1">base = '/' + base;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// remove trailing slash</span><span class="s2">\n  </span><span class="s1">return base.replace(/</span><span class="s2">\\</span><span class="s1">/$/, '');</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveQueue(current, next) {</span><span class="s2">\n  </span><span class="s1">var i;</span><span class="s2">\n  </span><span class="s1">var max = Math.max(current.length, next.length);</span><span class="s2">\n  </span><span class="s1">for (i = 0; i &lt; max; i++) {</span><span class="s2">\n    </span><span class="s1">if (current[i] !== next[i]) {</span><span class="s2">\n      </span><span class="s1">break;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">updated: next.slice(0, i),</span><span class="s2">\n    </span><span class="s1">activated: next.slice(i),</span><span class="s2">\n    </span><span class="s1">deactivated: current.slice(i)</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function extractGuards(records, name, bind, reverse) {</span><span class="s2">\n  </span><span class="s1">var guards = flatMapComponents(records, function (def, instance, match, key) {</span><span class="s2">\n    </span><span class="s1">var guard = extractGuard(def, name);</span><span class="s2">\n    </span><span class="s1">if (guard) {</span><span class="s2">\n      </span><span class="s1">return Array.isArray(guard) ? guard.map(function (guard) {</span><span class="s2">\n        </span><span class="s1">return bind(guard, instance, match, key);</span><span class="s2">\n      </span><span class="s1">}) : bind(guard, instance, match, key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return flatten(reverse ? guards.reverse() : guards);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function extractGuard(def, key) {</span><span class="s2">\n  </span><span class="s1">if (typeof def !== 'function') {</span><span class="s2">\n    </span><span class="s1">// extend now so that global mixins are applied.</span><span class="s2">\n    </span><span class="s1">def = _Vue.extend(def);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return def.options[key];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function extractLeaveGuards(deactivated) {</span><span class="s2">\n  </span><span class="s1">return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function extractUpdateHooks(updated) {</span><span class="s2">\n  </span><span class="s1">return extractGuards(updated, 'beforeRouteUpdate', bindGuard);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function bindGuard(guard, instance) {</span><span class="s2">\n  </span><span class="s1">if (instance) {</span><span class="s2">\n    </span><span class="s1">return function boundRouteGuard() {</span><span class="s2">\n      </span><span class="s1">return guard.apply(instance, arguments);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function extractEnterGuards(activated) {</span><span class="s2">\n  </span><span class="s1">return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {</span><span class="s2">\n    </span><span class="s1">return bindEnterGuard(guard, match, key);</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function bindEnterGuard(guard, match, key) {</span><span class="s2">\n  </span><span class="s1">return function routeEnterGuard(to, from, next) {</span><span class="s2">\n    </span><span class="s1">return guard(to, from, function (cb) {</span><span class="s2">\n      </span><span class="s1">if (typeof cb === 'function') {</span><span class="s2">\n        </span><span class="s1">if (!match.enteredCbs[key]) {</span><span class="s2">\n          </span><span class="s1">match.enteredCbs[key] = [];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">match.enteredCbs[key].push(cb);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">next(cb);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var HTML5History = /*@__PURE__*/function (History) {</span><span class="s2">\n  </span><span class="s1">function HTML5History(router, base) {</span><span class="s2">\n    </span><span class="s1">History.call(this, router, base);</span><span class="s2">\n    </span><span class="s1">this._startLocation = getLocation(this.base);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (History) HTML5History.__proto__ = History;</span><span class="s2">\n  </span><span class="s1">HTML5History.prototype = Object.create(History &amp;&amp; History.prototype);</span><span class="s2">\n  </span><span class="s1">HTML5History.prototype.constructor = HTML5History;</span><span class="s2">\n  </span><span class="s1">HTML5History.prototype.setupListeners = function setupListeners() {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n    </span><span class="s1">if (this.listeners.length &gt; 0) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var router = this.router;</span><span class="s2">\n    </span><span class="s1">var expectScroll = router.options.scrollBehavior;</span><span class="s2">\n    </span><span class="s1">var supportsScroll = supportsPushState &amp;&amp; expectScroll;</span><span class="s2">\n    </span><span class="s1">if (supportsScroll) {</span><span class="s2">\n      </span><span class="s1">this.listeners.push(setupScroll());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var handleRoutingEvent = function () {</span><span class="s2">\n      </span><span class="s1">var current = this$1$1.current;</span><span class="s2">\n\n      </span><span class="s1">// Avoiding first `popstate` event dispatched in some browsers but first</span><span class="s2">\n      </span><span class="s1">// history route not updated since async guard at the same time.</span><span class="s2">\n      </span><span class="s1">var location = getLocation(this$1$1.base);</span><span class="s2">\n      </span><span class="s1">if (this$1$1.current === START &amp;&amp; location === this$1$1._startLocation) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this$1$1.transitionTo(location, function (route) {</span><span class="s2">\n        </span><span class="s1">if (supportsScroll) {</span><span class="s2">\n          </span><span class="s1">handleScroll(router, route, current, true);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">window.addEventListener('popstate', handleRoutingEvent);</span><span class="s2">\n    </span><span class="s1">this.listeners.push(function () {</span><span class="s2">\n      </span><span class="s1">window.removeEventListener('popstate', handleRoutingEvent);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">HTML5History.prototype.go = function go(n) {</span><span class="s2">\n    </span><span class="s1">window.history.go(n);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">HTML5History.prototype.push = function push(location, onComplete, onAbort) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n    </span><span class="s1">var ref = this;</span><span class="s2">\n    </span><span class="s1">var fromRoute = ref.current;</span><span class="s2">\n    </span><span class="s1">this.transitionTo(location, function (route) {</span><span class="s2">\n      </span><span class="s1">pushState(cleanPath(this$1$1.base + route.fullPath));</span><span class="s2">\n      </span><span class="s1">handleScroll(this$1$1.router, route, fromRoute, false);</span><span class="s2">\n      </span><span class="s1">onComplete &amp;&amp; onComplete(route);</span><span class="s2">\n    </span><span class="s1">}, onAbort);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n    </span><span class="s1">var ref = this;</span><span class="s2">\n    </span><span class="s1">var fromRoute = ref.current;</span><span class="s2">\n    </span><span class="s1">this.transitionTo(location, function (route) {</span><span class="s2">\n      </span><span class="s1">replaceState(cleanPath(this$1$1.base + route.fullPath));</span><span class="s2">\n      </span><span class="s1">handleScroll(this$1$1.router, route, fromRoute, false);</span><span class="s2">\n      </span><span class="s1">onComplete &amp;&amp; onComplete(route);</span><span class="s2">\n    </span><span class="s1">}, onAbort);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">HTML5History.prototype.ensureURL = function ensureURL(push) {</span><span class="s2">\n    </span><span class="s1">if (getLocation(this.base) !== this.current.fullPath) {</span><span class="s2">\n      </span><span class="s1">var current = cleanPath(this.base + this.current.fullPath);</span><span class="s2">\n      </span><span class="s1">push ? pushState(current) : replaceState(current);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {</span><span class="s2">\n    </span><span class="s1">return getLocation(this.base);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return HTML5History;</span><span class="s2">\n</span><span class="s1">}(History);</span><span class="s2">\n</span><span class="s1">function getLocation(base) {</span><span class="s2">\n  </span><span class="s1">var path = window.location.pathname;</span><span class="s2">\n  </span><span class="s1">var pathLowerCase = path.toLowerCase();</span><span class="s2">\n  </span><span class="s1">var baseLowerCase = base.toLowerCase();</span><span class="s2">\n  </span><span class="s1">// base=</span><span class="s2">\&quot;</span><span class="s1">/a</span><span class="s2">\&quot; </span><span class="s1">shouldn't turn path=</span><span class="s2">\&quot;</span><span class="s1">/app</span><span class="s2">\&quot; </span><span class="s1">into </span><span class="s2">\&quot;</span><span class="s1">/a/pp</span><span class="s2">\&quot;\n  </span><span class="s1">// https://github.com/vuejs/vue-router/issues/3555</span><span class="s2">\n  </span><span class="s1">// so we ensure the trailing slash in the base</span><span class="s2">\n  </span><span class="s1">if (base &amp;&amp; (pathLowerCase === baseLowerCase || pathLowerCase.indexOf(cleanPath(baseLowerCase + '/')) === 0)) {</span><span class="s2">\n    </span><span class="s1">path = path.slice(base.length);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return (path || '/') + window.location.search + window.location.hash;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var HashHistory = /*@__PURE__*/function (History) {</span><span class="s2">\n  </span><span class="s1">function HashHistory(router, base, fallback) {</span><span class="s2">\n    </span><span class="s1">History.call(this, router, base);</span><span class="s2">\n    </span><span class="s1">// check history fallback deeplinking</span><span class="s2">\n    </span><span class="s1">if (fallback &amp;&amp; checkFallback(this.base)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">ensureSlash();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (History) HashHistory.__proto__ = History;</span><span class="s2">\n  </span><span class="s1">HashHistory.prototype = Object.create(History &amp;&amp; History.prototype);</span><span class="s2">\n  </span><span class="s1">HashHistory.prototype.constructor = HashHistory;</span><span class="s2">\n\n  </span><span class="s1">// this is delayed until the app mounts</span><span class="s2">\n  </span><span class="s1">// to avoid the hashchange listener being fired too early</span><span class="s2">\n  </span><span class="s1">HashHistory.prototype.setupListeners = function setupListeners() {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n    </span><span class="s1">if (this.listeners.length &gt; 0) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var router = this.router;</span><span class="s2">\n    </span><span class="s1">var expectScroll = router.options.scrollBehavior;</span><span class="s2">\n    </span><span class="s1">var supportsScroll = supportsPushState &amp;&amp; expectScroll;</span><span class="s2">\n    </span><span class="s1">if (supportsScroll) {</span><span class="s2">\n      </span><span class="s1">this.listeners.push(setupScroll());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var handleRoutingEvent = function () {</span><span class="s2">\n      </span><span class="s1">var current = this$1$1.current;</span><span class="s2">\n      </span><span class="s1">if (!ensureSlash()) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this$1$1.transitionTo(getHash(), function (route) {</span><span class="s2">\n        </span><span class="s1">if (supportsScroll) {</span><span class="s2">\n          </span><span class="s1">handleScroll(this$1$1.router, route, current, true);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (!supportsPushState) {</span><span class="s2">\n          </span><span class="s1">replaceHash(route.fullPath);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var eventType = supportsPushState ? 'popstate' : 'hashchange';</span><span class="s2">\n    </span><span class="s1">window.addEventListener(eventType, handleRoutingEvent);</span><span class="s2">\n    </span><span class="s1">this.listeners.push(function () {</span><span class="s2">\n      </span><span class="s1">window.removeEventListener(eventType, handleRoutingEvent);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">HashHistory.prototype.push = function push(location, onComplete, onAbort) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n    </span><span class="s1">var ref = this;</span><span class="s2">\n    </span><span class="s1">var fromRoute = ref.current;</span><span class="s2">\n    </span><span class="s1">this.transitionTo(location, function (route) {</span><span class="s2">\n      </span><span class="s1">pushHash(route.fullPath);</span><span class="s2">\n      </span><span class="s1">handleScroll(this$1$1.router, route, fromRoute, false);</span><span class="s2">\n      </span><span class="s1">onComplete &amp;&amp; onComplete(route);</span><span class="s2">\n    </span><span class="s1">}, onAbort);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n    </span><span class="s1">var ref = this;</span><span class="s2">\n    </span><span class="s1">var fromRoute = ref.current;</span><span class="s2">\n    </span><span class="s1">this.transitionTo(location, function (route) {</span><span class="s2">\n      </span><span class="s1">replaceHash(route.fullPath);</span><span class="s2">\n      </span><span class="s1">handleScroll(this$1$1.router, route, fromRoute, false);</span><span class="s2">\n      </span><span class="s1">onComplete &amp;&amp; onComplete(route);</span><span class="s2">\n    </span><span class="s1">}, onAbort);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">HashHistory.prototype.go = function go(n) {</span><span class="s2">\n    </span><span class="s1">window.history.go(n);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">HashHistory.prototype.ensureURL = function ensureURL(push) {</span><span class="s2">\n    </span><span class="s1">var current = this.current.fullPath;</span><span class="s2">\n    </span><span class="s1">if (getHash() !== current) {</span><span class="s2">\n      </span><span class="s1">push ? pushHash(current) : replaceHash(current);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {</span><span class="s2">\n    </span><span class="s1">return getHash();</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return HashHistory;</span><span class="s2">\n</span><span class="s1">}(History);</span><span class="s2">\n</span><span class="s1">function checkFallback(base) {</span><span class="s2">\n  </span><span class="s1">var location = getLocation(base);</span><span class="s2">\n  </span><span class="s1">if (!/^</span><span class="s2">\\</span><span class="s1">/#/.test(location)) {</span><span class="s2">\n    </span><span class="s1">window.location.replace(cleanPath(base + '/#' + location));</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function ensureSlash() {</span><span class="s2">\n  </span><span class="s1">var path = getHash();</span><span class="s2">\n  </span><span class="s1">if (path.charAt(0) === '/') {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">replaceHash('/' + path);</span><span class="s2">\n  </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getHash() {</span><span class="s2">\n  </span><span class="s1">// We can't use window.location.hash here because it's not</span><span class="s2">\n  </span><span class="s1">// consistent across browsers - Firefox will pre-decode it!</span><span class="s2">\n  </span><span class="s1">var href = window.location.href;</span><span class="s2">\n  </span><span class="s1">var index = href.indexOf('#');</span><span class="s2">\n  </span><span class="s1">// empty path</span><span class="s2">\n  </span><span class="s1">if (index &lt; 0) {</span><span class="s2">\n    </span><span class="s1">return '';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">href = href.slice(index + 1);</span><span class="s2">\n  </span><span class="s1">return href;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getUrl(path) {</span><span class="s2">\n  </span><span class="s1">var href = window.location.href;</span><span class="s2">\n  </span><span class="s1">var i = href.indexOf('#');</span><span class="s2">\n  </span><span class="s1">var base = i &gt;= 0 ? href.slice(0, i) : href;</span><span class="s2">\n  </span><span class="s1">return base + </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">+ path;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function pushHash(path) {</span><span class="s2">\n  </span><span class="s1">if (supportsPushState) {</span><span class="s2">\n    </span><span class="s1">pushState(getUrl(path));</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">window.location.hash = path;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function replaceHash(path) {</span><span class="s2">\n  </span><span class="s1">if (supportsPushState) {</span><span class="s2">\n    </span><span class="s1">replaceState(getUrl(path));</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">window.location.replace(getUrl(path));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var AbstractHistory = /*@__PURE__*/function (History) {</span><span class="s2">\n  </span><span class="s1">function AbstractHistory(router, base) {</span><span class="s2">\n    </span><span class="s1">History.call(this, router, base);</span><span class="s2">\n    </span><span class="s1">this.stack = [];</span><span class="s2">\n    </span><span class="s1">this.index = -1;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (History) AbstractHistory.__proto__ = History;</span><span class="s2">\n  </span><span class="s1">AbstractHistory.prototype = Object.create(History &amp;&amp; History.prototype);</span><span class="s2">\n  </span><span class="s1">AbstractHistory.prototype.constructor = AbstractHistory;</span><span class="s2">\n  </span><span class="s1">AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n    </span><span class="s1">this.transitionTo(location, function (route) {</span><span class="s2">\n      </span><span class="s1">this$1$1.stack = this$1$1.stack.slice(0, this$1$1.index + 1).concat(route);</span><span class="s2">\n      </span><span class="s1">this$1$1.index++;</span><span class="s2">\n      </span><span class="s1">onComplete &amp;&amp; onComplete(route);</span><span class="s2">\n    </span><span class="s1">}, onAbort);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n    </span><span class="s1">this.transitionTo(location, function (route) {</span><span class="s2">\n      </span><span class="s1">this$1$1.stack = this$1$1.stack.slice(0, this$1$1.index).concat(route);</span><span class="s2">\n      </span><span class="s1">onComplete &amp;&amp; onComplete(route);</span><span class="s2">\n    </span><span class="s1">}, onAbort);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">AbstractHistory.prototype.go = function go(n) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n    </span><span class="s1">var targetIndex = this.index + n;</span><span class="s2">\n    </span><span class="s1">if (targetIndex &lt; 0 || targetIndex &gt;= this.stack.length) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var route = this.stack[targetIndex];</span><span class="s2">\n    </span><span class="s1">this.confirmTransition(route, function () {</span><span class="s2">\n      </span><span class="s1">var prev = this$1$1.current;</span><span class="s2">\n      </span><span class="s1">this$1$1.index = targetIndex;</span><span class="s2">\n      </span><span class="s1">this$1$1.updateRoute(route);</span><span class="s2">\n      </span><span class="s1">this$1$1.router.afterHooks.forEach(function (hook) {</span><span class="s2">\n        </span><span class="s1">hook &amp;&amp; hook(route, prev);</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}, function (err) {</span><span class="s2">\n      </span><span class="s1">if (isNavigationFailure(err, NavigationFailureType.duplicated)) {</span><span class="s2">\n        </span><span class="s1">this$1$1.index = targetIndex;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {</span><span class="s2">\n    </span><span class="s1">var current = this.stack[this.stack.length - 1];</span><span class="s2">\n    </span><span class="s1">return current ? current.fullPath : '/';</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">AbstractHistory.prototype.ensureURL = function ensureURL() {</span><span class="s2">\n    </span><span class="s1">// noop</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return AbstractHistory;</span><span class="s2">\n</span><span class="s1">}(History);</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var VueRouter = function VueRouter(options) {</span><span class="s2">\n  </span><span class="s1">if (options === void 0) options = {};</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">warn(this instanceof VueRouter, </span><span class="s2">\&quot;</span><span class="s1">Router must be called with the new operator.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">this.app = null;</span><span class="s2">\n  </span><span class="s1">this.apps = [];</span><span class="s2">\n  </span><span class="s1">this.options = options;</span><span class="s2">\n  </span><span class="s1">this.beforeHooks = [];</span><span class="s2">\n  </span><span class="s1">this.resolveHooks = [];</span><span class="s2">\n  </span><span class="s1">this.afterHooks = [];</span><span class="s2">\n  </span><span class="s1">this.matcher = createMatcher(options.routes || [], this);</span><span class="s2">\n  </span><span class="s1">var mode = options.mode || 'hash';</span><span class="s2">\n  </span><span class="s1">this.fallback = mode === 'history' &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false;</span><span class="s2">\n  </span><span class="s1">if (this.fallback) {</span><span class="s2">\n    </span><span class="s1">mode = 'hash';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!inBrowser) {</span><span class="s2">\n    </span><span class="s1">mode = 'abstract';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">this.mode = mode;</span><span class="s2">\n  </span><span class="s1">switch (mode) {</span><span class="s2">\n    </span><span class="s1">case 'history':</span><span class="s2">\n      </span><span class="s1">this.history = new HTML5History(this, options.base);</span><span class="s2">\n      </span><span class="s1">break;</span><span class="s2">\n    </span><span class="s1">case 'hash':</span><span class="s2">\n      </span><span class="s1">this.history = new HashHistory(this, options.base, this.fallback);</span><span class="s2">\n      </span><span class="s1">break;</span><span class="s2">\n    </span><span class="s1">case 'abstract':</span><span class="s2">\n      </span><span class="s1">this.history = new AbstractHistory(this, options.base);</span><span class="s2">\n      </span><span class="s1">break;</span><span class="s2">\n    </span><span class="s1">default:</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">assert(false, </span><span class="s2">\&quot;</span><span class="s1">invalid mode: </span><span class="s2">\&quot; </span><span class="s1">+ mode);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var prototypeAccessors = {</span><span class="s2">\n  </span><span class="s1">currentRoute: {</span><span class="s2">\n    </span><span class="s1">configurable: true</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">VueRouter.prototype.match = function match(raw, current, redirectedFrom) {</span><span class="s2">\n  </span><span class="s1">return this.matcher.match(raw, current, redirectedFrom);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">prototypeAccessors.currentRoute.get = function () {</span><span class="s2">\n  </span><span class="s1">return this.history &amp;&amp; this.history.current;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">VueRouter.prototype.init = function init(app /* Vue component instance */) {</span><span class="s2">\n  </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n  </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; assert(install.installed, </span><span class="s2">\&quot;</span><span class="s1">not installed. Make sure to call `Vue.use(VueRouter)` </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">before creating root instance.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">this.apps.push(app);</span><span class="s2">\n\n  </span><span class="s1">// set up app destroyed handler</span><span class="s2">\n  </span><span class="s1">// https://github.com/vuejs/vue-router/issues/2639</span><span class="s2">\n  </span><span class="s1">app.$once('hook:destroyed', function () {</span><span class="s2">\n    </span><span class="s1">// clean out app from this.apps array once destroyed</span><span class="s2">\n    </span><span class="s1">var index = this$1$1.apps.indexOf(app);</span><span class="s2">\n    </span><span class="s1">if (index &gt; -1) {</span><span class="s2">\n      </span><span class="s1">this$1$1.apps.splice(index, 1);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// ensure we still have a main app or null if no apps</span><span class="s2">\n    </span><span class="s1">// we do not release the router so it can be reused</span><span class="s2">\n    </span><span class="s1">if (this$1$1.app === app) {</span><span class="s2">\n      </span><span class="s1">this$1$1.app = this$1$1.apps[0] || null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!this$1$1.app) {</span><span class="s2">\n      </span><span class="s1">this$1$1.history.teardown();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n\n  </span><span class="s1">// main app previously initialized</span><span class="s2">\n  </span><span class="s1">// return as we don't need to set up new history listener</span><span class="s2">\n  </span><span class="s1">if (this.app) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">this.app = app;</span><span class="s2">\n  </span><span class="s1">var history = this.history;</span><span class="s2">\n  </span><span class="s1">if (history instanceof HTML5History || history instanceof HashHistory) {</span><span class="s2">\n    </span><span class="s1">var handleInitialScroll = function (routeOrError) {</span><span class="s2">\n      </span><span class="s1">var from = history.current;</span><span class="s2">\n      </span><span class="s1">var expectScroll = this$1$1.options.scrollBehavior;</span><span class="s2">\n      </span><span class="s1">var supportsScroll = supportsPushState &amp;&amp; expectScroll;</span><span class="s2">\n      </span><span class="s1">if (supportsScroll &amp;&amp; 'fullPath' in routeOrError) {</span><span class="s2">\n        </span><span class="s1">handleScroll(this$1$1, routeOrError, from, false);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var setupListeners = function (routeOrError) {</span><span class="s2">\n      </span><span class="s1">history.setupListeners();</span><span class="s2">\n      </span><span class="s1">handleInitialScroll(routeOrError);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">history.transitionTo(history.getCurrentLocation(), setupListeners, setupListeners);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">history.listen(function (route) {</span><span class="s2">\n    </span><span class="s1">this$1$1.apps.forEach(function (app) {</span><span class="s2">\n      </span><span class="s1">app._route = route;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">VueRouter.prototype.beforeEach = function beforeEach(fn) {</span><span class="s2">\n  </span><span class="s1">return registerHook(this.beforeHooks, fn);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">VueRouter.prototype.beforeResolve = function beforeResolve(fn) {</span><span class="s2">\n  </span><span class="s1">return registerHook(this.resolveHooks, fn);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">VueRouter.prototype.afterEach = function afterEach(fn) {</span><span class="s2">\n  </span><span class="s1">return registerHook(this.afterHooks, fn);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">VueRouter.prototype.onReady = function onReady(cb, errorCb) {</span><span class="s2">\n  </span><span class="s1">this.history.onReady(cb, errorCb);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">VueRouter.prototype.onError = function onError(errorCb) {</span><span class="s2">\n  </span><span class="s1">this.history.onError(errorCb);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">VueRouter.prototype.push = function push(location, onComplete, onAbort) {</span><span class="s2">\n  </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n\n  </span><span class="s1">// $flow-disable-line</span><span class="s2">\n  </span><span class="s1">if (!onComplete &amp;&amp; !onAbort &amp;&amp; typeof Promise !== 'undefined') {</span><span class="s2">\n    </span><span class="s1">return new Promise(function (resolve, reject) {</span><span class="s2">\n      </span><span class="s1">this$1$1.history.push(location, resolve, reject);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">this.history.push(location, onComplete, onAbort);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {</span><span class="s2">\n  </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n\n  </span><span class="s1">// $flow-disable-line</span><span class="s2">\n  </span><span class="s1">if (!onComplete &amp;&amp; !onAbort &amp;&amp; typeof Promise !== 'undefined') {</span><span class="s2">\n    </span><span class="s1">return new Promise(function (resolve, reject) {</span><span class="s2">\n      </span><span class="s1">this$1$1.history.replace(location, resolve, reject);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">this.history.replace(location, onComplete, onAbort);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">VueRouter.prototype.go = function go(n) {</span><span class="s2">\n  </span><span class="s1">this.history.go(n);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">VueRouter.prototype.back = function back() {</span><span class="s2">\n  </span><span class="s1">this.go(-1);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">VueRouter.prototype.forward = function forward() {</span><span class="s2">\n  </span><span class="s1">this.go(1);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {</span><span class="s2">\n  </span><span class="s1">var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;</span><span class="s2">\n  </span><span class="s1">if (!route) {</span><span class="s2">\n    </span><span class="s1">return [];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return [].concat.apply([], route.matched.map(function (m) {</span><span class="s2">\n    </span><span class="s1">return Object.keys(m.components).map(function (key) {</span><span class="s2">\n      </span><span class="s1">return m.components[key];</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}));</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">VueRouter.prototype.resolve = function resolve(to, current, append) {</span><span class="s2">\n  </span><span class="s1">current = current || this.history.current;</span><span class="s2">\n  </span><span class="s1">var location = normalizeLocation(to, current, append, this);</span><span class="s2">\n  </span><span class="s1">var route = this.match(location, current);</span><span class="s2">\n  </span><span class="s1">var fullPath = route.redirectedFrom || route.fullPath;</span><span class="s2">\n  </span><span class="s1">var base = this.history.base;</span><span class="s2">\n  </span><span class="s1">var href = createHref(base, fullPath, this.mode);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">location: location,</span><span class="s2">\n    </span><span class="s1">route: route,</span><span class="s2">\n    </span><span class="s1">href: href,</span><span class="s2">\n    </span><span class="s1">// for backwards compat</span><span class="s2">\n    </span><span class="s1">normalizedTo: location,</span><span class="s2">\n    </span><span class="s1">resolved: route</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">VueRouter.prototype.getRoutes = function getRoutes() {</span><span class="s2">\n  </span><span class="s1">return this.matcher.getRoutes();</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">VueRouter.prototype.addRoute = function addRoute(parentOrRoute, route) {</span><span class="s2">\n  </span><span class="s1">this.matcher.addRoute(parentOrRoute, route);</span><span class="s2">\n  </span><span class="s1">if (this.history.current !== START) {</span><span class="s2">\n    </span><span class="s1">this.history.transitionTo(this.history.getCurrentLocation());</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">VueRouter.prototype.addRoutes = function addRoutes(routes) {</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">warn(false, 'router.addRoutes() is deprecated and has been removed in Vue Router 4. Use router.addRoute() instead.');</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">this.matcher.addRoutes(routes);</span><span class="s2">\n  </span><span class="s1">if (this.history.current !== START) {</span><span class="s2">\n    </span><span class="s1">this.history.transitionTo(this.history.getCurrentLocation());</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">Object.defineProperties(VueRouter.prototype, prototypeAccessors);</span><span class="s2">\n</span><span class="s1">var VueRouter$1 = VueRouter;</span><span class="s2">\n</span><span class="s1">function registerHook(list, fn) {</span><span class="s2">\n  </span><span class="s1">list.push(fn);</span><span class="s2">\n  </span><span class="s1">return function () {</span><span class="s2">\n    </span><span class="s1">var i = list.indexOf(fn);</span><span class="s2">\n    </span><span class="s1">if (i &gt; -1) {</span><span class="s2">\n      </span><span class="s1">list.splice(i, 1);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createHref(base, fullPath, mode) {</span><span class="s2">\n  </span><span class="s1">var path = mode === 'hash' ? '#' + fullPath : fullPath;</span><span class="s2">\n  </span><span class="s1">return base ? cleanPath(base + '/' + path) : path;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// We cannot remove this as it would be a breaking change</span><span class="s2">\n</span><span class="s1">VueRouter.install = install;</span><span class="s2">\n</span><span class="s1">VueRouter.version = '3.6.5';</span><span class="s2">\n</span><span class="s1">VueRouter.isNavigationFailure = isNavigationFailure;</span><span class="s2">\n</span><span class="s1">VueRouter.NavigationFailureType = NavigationFailureType;</span><span class="s2">\n</span><span class="s1">VueRouter.START_LOCATION = START;</span><span class="s2">\n</span><span class="s1">if (inBrowser &amp;&amp; window.Vue) {</span><span class="s2">\n  </span><span class="s1">window.Vue.use(VueRouter);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var version = '3.6.5';</span><span class="s2">\n</span><span class="s1">export { NavigationFailureType, Link as RouterLink, View as RouterView, START as START_LOCATION, VueRouter$1 as default, isNavigationFailure, version };&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">:{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s3">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;assert&quot;</span><span class="s0">,</span><span class="s1">&quot;condition&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;extend&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeReserveRE&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeReserveReplacer&quot;</span><span class="s0">,</span><span class="s1">&quot;c&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;commaRE&quot;</span><span class="s0">,</span><span class="s1">&quot;encode&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;decode&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;extraQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;_parseQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;parseQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;castQueryParamValue&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;trim&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;parts&quot;</span><span class="s0">,</span><span class="s1">&quot;shift&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;stringifyQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;val2&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;x&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingSlashRE&quot;</span><span class="s0">,</span><span class="s1">&quot;createRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;record&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectedFrom&quot;</span><span class="s0">,</span><span class="s1">&quot;router&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;clone&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;fullPath&quot;</span><span class="s0">,</span><span class="s1">&quot;getFullPath&quot;</span><span class="s0">,</span><span class="s1">&quot;matched&quot;</span><span class="s0">,</span><span class="s1">&quot;formatMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;freeze&quot;</span><span class="s0">,</span><span class="s1">&quot;START&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;_stringifyQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;isSameRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;onlyPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectEqual&quot;</span><span class="s0">,</span><span class="s1">&quot;aKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">,</span><span class="s1">&quot;bKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;aVal&quot;</span><span class="s0">,</span><span class="s1">&quot;bKey&quot;</span><span class="s0">,</span><span class="s1">&quot;bVal&quot;</span><span class="s0">,</span><span class="s1">&quot;isIncludedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;queryIncludes&quot;</span><span class="s0">,</span><span class="s1">&quot;handleRouteEntered&quot;</span><span class="s0">,</span><span class="s1">&quot;instances&quot;</span><span class="s0">,</span><span class="s1">&quot;instance&quot;</span><span class="s0">,</span><span class="s1">&quot;cbs&quot;</span><span class="s0">,</span><span class="s1">&quot;enteredCbs&quot;</span><span class="s0">,</span><span class="s1">&quot;i$1&quot;</span><span class="s0">,</span><span class="s1">&quot;_isBeingDestroyed&quot;</span><span class="s0">,</span><span class="s1">&quot;View&quot;</span><span class="s0">,</span><span class="s1">&quot;functional&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">,</span><span class="s1">&quot;render&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;routerView&quot;</span><span class="s0">,</span><span class="s1">&quot;h&quot;</span><span class="s0">,</span><span class="s1">&quot;$createElement&quot;</span><span class="s0">,</span><span class="s1">&quot;$route&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;_routerViewCache&quot;</span><span class="s0">,</span><span class="s1">&quot;depth&quot;</span><span class="s0">,</span><span class="s1">&quot;inactive&quot;</span><span class="s0">,</span><span class="s1">&quot;_routerRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;vnodeData&quot;</span><span class="s0">,</span><span class="s1">&quot;$vnode&quot;</span><span class="s0">,</span><span class="s1">&quot;keepAlive&quot;</span><span class="s0">,</span><span class="s1">&quot;_directInactive&quot;</span><span class="s0">,</span><span class="s1">&quot;_inactive&quot;</span><span class="s0">,</span><span class="s1">&quot;$parent&quot;</span><span class="s0">,</span><span class="s1">&quot;routerViewDepth&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedData&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;component&quot;</span><span class="s0">,</span><span class="s1">&quot;configProps&quot;</span><span class="s0">,</span><span class="s1">&quot;fillPropsinData&quot;</span><span class="s0">,</span><span class="s1">&quot;components&quot;</span><span class="s0">,</span><span class="s1">&quot;registerRouteInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;vm&quot;</span><span class="s0">,</span><span class="s1">&quot;hook&quot;</span><span class="s0">,</span><span class="s1">&quot;prepatch&quot;</span><span class="s0">,</span><span class="s1">&quot;vnode&quot;</span><span class="s0">,</span><span class="s1">&quot;componentInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;propsToPass&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveProps&quot;</span><span class="s0">,</span><span class="s1">&quot;attrs&quot;</span><span class="s0">,</span><span class="s1">&quot;config&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvePath&quot;</span><span class="s0">,</span><span class="s1">&quot;relative&quot;</span><span class="s0">,</span><span class="s1">&quot;base&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;firstChar&quot;</span><span class="s0">,</span><span class="s1">&quot;charAt&quot;</span><span class="s0">,</span><span class="s1">&quot;stack&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;segments&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;parsePath&quot;</span><span class="s0">,</span><span class="s1">&quot;hashIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;queryIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isarray&quot;</span><span class="s0">,</span><span class="s1">&quot;arr&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToRegexp_1&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;parse_1&quot;</span><span class="s0">,</span><span class="s1">&quot;compile_1&quot;</span><span class="s0">,</span><span class="s1">&quot;compile&quot;</span><span class="s0">,</span><span class="s1">&quot;tokensToFunction_1&quot;</span><span class="s0">,</span><span class="s1">&quot;tokensToFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;tokensToRegExp_1&quot;</span><span class="s0">,</span><span class="s1">&quot;tokensToRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;PATH_REGEXP&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;tokens&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultDelimiter&quot;</span><span class="s0">,</span><span class="s1">&quot;delimiter&quot;</span><span class="s0">,</span><span class="s1">&quot;exec&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;escaped&quot;</span><span class="s0">,</span><span class="s1">&quot;offset&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;capture&quot;</span><span class="s0">,</span><span class="s1">&quot;group&quot;</span><span class="s0">,</span><span class="s1">&quot;modifier&quot;</span><span class="s0">,</span><span class="s1">&quot;asterisk&quot;</span><span class="s0">,</span><span class="s1">&quot;partial&quot;</span><span class="s0">,</span><span class="s1">&quot;repeat&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;escapeGroup&quot;</span><span class="s0">,</span><span class="s1">&quot;escapeString&quot;</span><span class="s0">,</span><span class="s1">&quot;substr&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeURIComponentPretty&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeURI&quot;</span><span class="s0">,</span><span class="s1">&quot;toUpperCase&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeAsterisk&quot;</span><span class="s0">,</span><span class="s1">&quot;matches&quot;</span><span class="s0">,</span><span class="s1">&quot;flags&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">,</span><span class="s1">&quot;pretty&quot;</span><span class="s0">,</span><span class="s1">&quot;token&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;j&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;attachKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;re&quot;</span><span class="s0">,</span><span class="s1">&quot;sensitive&quot;</span><span class="s0">,</span><span class="s1">&quot;regexpToRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;groups&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayToRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;regexp&quot;</span><span class="s0">,</span><span class="s1">&quot;stringToRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;strict&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWithDelimiter&quot;</span><span class="s0">,</span><span class="s1">&quot;regexpCompileCache&quot;</span><span class="s0">,</span><span class="s1">&quot;create&quot;</span><span class="s0">,</span><span class="s1">&quot;fillParams&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMsg&quot;</span><span class="s0">,</span><span class="s1">&quot;filler&quot;</span><span class="s0">,</span><span class="s1">&quot;pathMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;raw&quot;</span><span class="s0">,</span><span class="s1">&quot;_normalized&quot;</span><span class="s0">,</span><span class="s1">&quot;params$1&quot;</span><span class="s0">,</span><span class="s1">&quot;rawPath&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;basePath&quot;</span><span class="s0">,</span><span class="s1">&quot;toTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;eventTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;noop&quot;</span><span class="s0">,</span><span class="s1">&quot;warnedCustomSlot&quot;</span><span class="s0">,</span><span class="s1">&quot;warnedTagProp&quot;</span><span class="s0">,</span><span class="s1">&quot;warnedEventProp&quot;</span><span class="s0">,</span><span class="s1">&quot;Link&quot;</span><span class="s0">,</span><span class="s1">&quot;to&quot;</span><span class="s0">,</span><span class="s1">&quot;required&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;custom&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;exact&quot;</span><span class="s0">,</span><span class="s1">&quot;exactPath&quot;</span><span class="s0">,</span><span class="s1">&quot;activeClass&quot;</span><span class="s0">,</span><span class="s1">&quot;exactActiveClass&quot;</span><span class="s0">,</span><span class="s1">&quot;ariaCurrentValue&quot;</span><span class="s0">,</span><span class="s1">&quot;event&quot;</span><span class="s0">,</span><span class="s1">&quot;this$1$1&quot;</span><span class="s0">,</span><span class="s1">&quot;$router&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;classes&quot;</span><span class="s0">,</span><span class="s1">&quot;globalActiveClass&quot;</span><span class="s0">,</span><span class="s1">&quot;linkActiveClass&quot;</span><span class="s0">,</span><span class="s1">&quot;globalExactActiveClass&quot;</span><span class="s0">,</span><span class="s1">&quot;linkExactActiveClass&quot;</span><span class="s0">,</span><span class="s1">&quot;activeClassFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;exactActiveClassFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;compareTarget&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;guardEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;on&quot;</span><span class="s0">,</span><span class="s1">&quot;click&quot;</span><span class="s0">,</span><span class="s1">&quot;class&quot;</span><span class="s0">,</span><span class="s1">&quot;scopedSlot&quot;</span><span class="s0">,</span><span class="s1">&quot;$scopedSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;$hasNormal&quot;</span><span class="s0">,</span><span class="s1">&quot;navigate&quot;</span><span class="s0">,</span><span class="s1">&quot;isActive&quot;</span><span class="s0">,</span><span class="s1">&quot;isExactActive&quot;</span><span class="s0">,</span><span class="s1">&quot;$options&quot;</span><span class="s0">,</span><span class="s1">&quot;propsData&quot;</span><span class="s0">,</span><span class="s1">&quot;findAnchor&quot;</span><span class="s0">,</span><span class="s1">&quot;$slots&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;aData&quot;</span><span class="s0">,</span><span class="s1">&quot;handler$1&quot;</span><span class="s0">,</span><span class="s1">&quot;event$1&quot;</span><span class="s0">,</span><span class="s1">&quot;aAttrs&quot;</span><span class="s0">,</span><span class="s1">&quot;metaKey&quot;</span><span class="s0">,</span><span class="s1">&quot;altKey&quot;</span><span class="s0">,</span><span class="s1">&quot;ctrlKey&quot;</span><span class="s0">,</span><span class="s1">&quot;shiftKey&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultPrevented&quot;</span><span class="s0">,</span><span class="s1">&quot;button&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTarget&quot;</span><span class="s0">,</span><span class="s1">&quot;getAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;preventDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;child&quot;</span><span class="s0">,</span><span class="s1">&quot;_Vue&quot;</span><span class="s0">,</span><span class="s1">&quot;install&quot;</span><span class="s0">,</span><span class="s1">&quot;Vue&quot;</span><span class="s0">,</span><span class="s1">&quot;installed&quot;</span><span class="s0">,</span><span class="s1">&quot;isDef&quot;</span><span class="s0">,</span><span class="s1">&quot;v&quot;</span><span class="s0">,</span><span class="s1">&quot;registerInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;callVal&quot;</span><span class="s0">,</span><span class="s1">&quot;_parentVnode&quot;</span><span class="s0">,</span><span class="s1">&quot;mixin&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeCreate&quot;</span><span class="s0">,</span><span class="s1">&quot;_router&quot;</span><span class="s0">,</span><span class="s1">&quot;util&quot;</span><span class="s0">,</span><span class="s1">&quot;defineReactive&quot;</span><span class="s0">,</span><span class="s1">&quot;history&quot;</span><span class="s0">,</span><span class="s1">&quot;destroyed&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;_route&quot;</span><span class="s0">,</span><span class="s1">&quot;strats&quot;</span><span class="s0">,</span><span class="s1">&quot;optionMergeStrategies&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeRouteEnter&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeRouteLeave&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeRouteUpdate&quot;</span><span class="s0">,</span><span class="s1">&quot;created&quot;</span><span class="s0">,</span><span class="s1">&quot;inBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouteMap&quot;</span><span class="s0">,</span><span class="s1">&quot;routes&quot;</span><span class="s0">,</span><span class="s1">&quot;oldPathList&quot;</span><span class="s0">,</span><span class="s1">&quot;oldPathMap&quot;</span><span class="s0">,</span><span class="s1">&quot;oldNameMap&quot;</span><span class="s0">,</span><span class="s1">&quot;parentRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;pathList&quot;</span><span class="s0">,</span><span class="s1">&quot;pathMap&quot;</span><span class="s0">,</span><span class="s1">&quot;nameMap&quot;</span><span class="s0">,</span><span class="s1">&quot;addRouteRecord&quot;</span><span class="s0">,</span><span class="s1">&quot;l&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;found&quot;</span><span class="s0">,</span><span class="s1">&quot;pathNames&quot;</span><span class="s0">,</span><span class="s1">&quot;matchAs&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToRegexpOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizePath&quot;</span><span class="s0">,</span><span class="s1">&quot;caseSensitive&quot;</span><span class="s0">,</span><span class="s1">&quot;regex&quot;</span><span class="s0">,</span><span class="s1">&quot;compileRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;alias&quot;</span><span class="s0">,</span><span class="s1">&quot;redirect&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeEnter&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;childMatchAs&quot;</span><span class="s0">,</span><span class="s1">&quot;aliases&quot;</span><span class="s0">,</span><span class="s1">&quot;aliasRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;createMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;addRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;addRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;parentOrRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;getRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;currentRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;_createRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;paramNames&quot;</span><span class="s0">,</span><span class="s1">&quot;record$1&quot;</span><span class="s0">,</span><span class="s1">&quot;matchRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;originalRedirect&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;targetRecord&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveRecordPath&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;aliasedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;aliasedMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;aliasedRecord&quot;</span><span class="s0">,</span><span class="s1">&quot;len&quot;</span><span class="s0">,</span><span class="s1">&quot;Time&quot;</span><span class="s0">,</span><span class="s1">&quot;performance&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;genStateKey&quot;</span><span class="s0">,</span><span class="s1">&quot;toFixed&quot;</span><span class="s0">,</span><span class="s1">&quot;_key&quot;</span><span class="s0">,</span><span class="s1">&quot;getStateKey&quot;</span><span class="s0">,</span><span class="s1">&quot;setStateKey&quot;</span><span class="s0">,</span><span class="s1">&quot;positionStore&quot;</span><span class="s0">,</span><span class="s1">&quot;setupScroll&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollRestoration&quot;</span><span class="s0">,</span><span class="s1">&quot;protocolAndPath&quot;</span><span class="s0">,</span><span class="s1">&quot;protocol&quot;</span><span class="s0">,</span><span class="s1">&quot;host&quot;</span><span class="s0">,</span><span class="s1">&quot;absolutePath&quot;</span><span class="s0">,</span><span class="s1">&quot;stateCopy&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceState&quot;</span><span class="s0">,</span><span class="s1">&quot;addEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;handlePopState&quot;</span><span class="s0">,</span><span class="s1">&quot;removeEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;handleScroll&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;isPop&quot;</span><span class="s0">,</span><span class="s1">&quot;app&quot;</span><span class="s0">,</span><span class="s1">&quot;behavior&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollBehavior&quot;</span><span class="s0">,</span><span class="s1">&quot;$nextTick&quot;</span><span class="s0">,</span><span class="s1">&quot;position&quot;</span><span class="s0">,</span><span class="s1">&quot;getScrollPosition&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldScroll&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollToPosition&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;saveScrollPosition&quot;</span><span class="s0">,</span><span class="s1">&quot;pageXOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;y&quot;</span><span class="s0">,</span><span class="s1">&quot;pageYOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;getElementPosition&quot;</span><span class="s0">,</span><span class="s1">&quot;el&quot;</span><span class="s0">,</span><span class="s1">&quot;docEl&quot;</span><span class="s0">,</span><span class="s1">&quot;document&quot;</span><span class="s0">,</span><span class="s1">&quot;documentElement&quot;</span><span class="s0">,</span><span class="s1">&quot;docRect&quot;</span><span class="s0">,</span><span class="s1">&quot;getBoundingClientRect&quot;</span><span class="s0">,</span><span class="s1">&quot;elRect&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;top&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidPosition&quot;</span><span class="s0">,</span><span class="s1">&quot;isNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizePosition&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;hashStartsWithNumberRE&quot;</span><span class="s0">,</span><span class="s1">&quot;isObject&quot;</span><span class="s0">,</span><span class="s1">&quot;selector&quot;</span><span class="s0">,</span><span class="s1">&quot;getElementById&quot;</span><span class="s0">,</span><span class="s1">&quot;querySelector&quot;</span><span class="s0">,</span><span class="s1">&quot;style&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollTo&quot;</span><span class="s0">,</span><span class="s1">&quot;supportsPushState&quot;</span><span class="s0">,</span><span class="s1">&quot;ua&quot;</span><span class="s0">,</span><span class="s1">&quot;navigator&quot;</span><span class="s0">,</span><span class="s1">&quot;userAgent&quot;</span><span class="s0">,</span><span class="s1">&quot;pushState&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;NavigationFailureType&quot;</span><span class="s0">,</span><span class="s1">&quot;redirected&quot;</span><span class="s0">,</span><span class="s1">&quot;aborted&quot;</span><span class="s0">,</span><span class="s1">&quot;cancelled&quot;</span><span class="s0">,</span><span class="s1">&quot;duplicated&quot;</span><span class="s0">,</span><span class="s1">&quot;createNavigationRedirectedError&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouterError&quot;</span><span class="s0">,</span><span class="s1">&quot;stringifyRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;createNavigationDuplicatedError&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;createNavigationCancelledError&quot;</span><span class="s0">,</span><span class="s1">&quot;createNavigationAbortedError&quot;</span><span class="s0">,</span><span class="s1">&quot;_isRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;propertiesToLog&quot;</span><span class="s0">,</span><span class="s1">&quot;isError&quot;</span><span class="s0">,</span><span class="s1">&quot;isNavigationFailure&quot;</span><span class="s0">,</span><span class="s1">&quot;errorType&quot;</span><span class="s0">,</span><span class="s1">&quot;runQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;queue&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;step&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveAsyncComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;hasAsync&quot;</span><span class="s0">,</span><span class="s1">&quot;pending&quot;</span><span class="s0">,</span><span class="s1">&quot;flatMapComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;def&quot;</span><span class="s0">,</span><span class="s1">&quot;cid&quot;</span><span class="s0">,</span><span class="s1">&quot;once&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedDef&quot;</span><span class="s0">,</span><span class="s1">&quot;isESModule&quot;</span><span class="s0">,</span><span class="s1">&quot;resolved&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;reason&quot;</span><span class="s0">,</span><span class="s1">&quot;msg&quot;</span><span class="s0">,</span><span class="s1">&quot;comp&quot;</span><span class="s0">,</span><span class="s1">&quot;flatten&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;hasSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;toStringTag&quot;</span><span class="s0">,</span><span class="s1">&quot;__esModule&quot;</span><span class="s0">,</span><span class="s1">&quot;called&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;History&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeBase&quot;</span><span class="s0">,</span><span class="s1">&quot;ready&quot;</span><span class="s0">,</span><span class="s1">&quot;readyCbs&quot;</span><span class="s0">,</span><span class="s1">&quot;readyErrorCbs&quot;</span><span class="s0">,</span><span class="s1">&quot;errorCbs&quot;</span><span class="s0">,</span><span class="s1">&quot;listeners&quot;</span><span class="s0">,</span><span class="s1">&quot;listen&quot;</span><span class="s0">,</span><span class="s1">&quot;onReady&quot;</span><span class="s0">,</span><span class="s1">&quot;errorCb&quot;</span><span class="s0">,</span><span class="s1">&quot;onError&quot;</span><span class="s0">,</span><span class="s1">&quot;transitionTo&quot;</span><span class="s0">,</span><span class="s1">&quot;onComplete&quot;</span><span class="s0">,</span><span class="s1">&quot;onAbort&quot;</span><span class="s0">,</span><span class="s1">&quot;prev&quot;</span><span class="s0">,</span><span class="s1">&quot;confirmTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;updateRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureURL&quot;</span><span class="s0">,</span><span class="s1">&quot;afterHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;abort&quot;</span><span class="s0">,</span><span class="s1">&quot;lastRouteIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;lastCurrentIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;updated&quot;</span><span class="s0">,</span><span class="s1">&quot;deactivated&quot;</span><span class="s0">,</span><span class="s1">&quot;activated&quot;</span><span class="s0">,</span><span class="s1">&quot;extractLeaveGuards&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;extractUpdateHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;enterGuards&quot;</span><span class="s0">,</span><span class="s1">&quot;extractEnterGuards&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;setupListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;teardown&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanupListener&quot;</span><span class="s0">,</span><span class="s1">&quot;baseEl&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;extractGuards&quot;</span><span class="s0">,</span><span class="s1">&quot;records&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;reverse&quot;</span><span class="s0">,</span><span class="s1">&quot;guards&quot;</span><span class="s0">,</span><span class="s1">&quot;guard&quot;</span><span class="s0">,</span><span class="s1">&quot;extractGuard&quot;</span><span class="s0">,</span><span class="s1">&quot;bindGuard&quot;</span><span class="s0">,</span><span class="s1">&quot;boundRouteGuard&quot;</span><span class="s0">,</span><span class="s1">&quot;bindEnterGuard&quot;</span><span class="s0">,</span><span class="s1">&quot;routeEnterGuard&quot;</span><span class="s0">,</span><span class="s1">&quot;HTML5History&quot;</span><span class="s0">,</span><span class="s1">&quot;_startLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;getLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;__proto__&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;expectScroll&quot;</span><span class="s0">,</span><span class="s1">&quot;supportsScroll&quot;</span><span class="s0">,</span><span class="s1">&quot;handleRoutingEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;go&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;fromRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;pathLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;baseLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;HashHistory&quot;</span><span class="s0">,</span><span class="s1">&quot;fallback&quot;</span><span class="s0">,</span><span class="s1">&quot;checkFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;getHash&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceHash&quot;</span><span class="s0">,</span><span class="s1">&quot;eventType&quot;</span><span class="s0">,</span><span class="s1">&quot;pushHash&quot;</span><span class="s0">,</span><span class="s1">&quot;getUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;AbstractHistory&quot;</span><span class="s0">,</span><span class="s1">&quot;targetIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;VueRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;apps&quot;</span><span class="s0">,</span><span class="s1">&quot;matcher&quot;</span><span class="s0">,</span><span class="s1">&quot;mode&quot;</span><span class="s0">,</span><span class="s1">&quot;prototypeAccessors&quot;</span><span class="s0">,</span><span class="s1">&quot;configurable&quot;</span><span class="s0">,</span><span class="s1">&quot;$once&quot;</span><span class="s0">,</span><span class="s1">&quot;handleInitialScroll&quot;</span><span class="s0">,</span><span class="s1">&quot;routeOrError&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeEach&quot;</span><span class="s0">,</span><span class="s1">&quot;registerHook&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeResolve&quot;</span><span class="s0">,</span><span class="s1">&quot;afterEach&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;back&quot;</span><span class="s0">,</span><span class="s1">&quot;forward&quot;</span><span class="s0">,</span><span class="s1">&quot;getMatchedComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;createHref&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedTo&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;VueRouter$1&quot;</span><span class="s0">,</span><span class="s1">&quot;list&quot;</span><span class="s0">,</span><span class="s1">&quot;version&quot;</span><span class="s0">,</span><span class="s1">&quot;START_LOCATION&quot;</span><span class="s0">,</span><span class="s1">&quot;use&quot;</span><span class="s0">,</span><span class="s1">&quot;RouterLink&quot;</span><span class="s0">,</span><span class="s1">&quot;RouterView&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;E:/work/project/manager/vue/node_modules/vue-router/dist/vue-router.esm.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/*!</span><span class="s2">\n  </span><span class="s1">* vue-router v3.6.5</span><span class="s2">\n  </span><span class="s1">* (c) 2022 Evan You</span><span class="s2">\n  </span><span class="s1">* @license MIT</span><span class="s2">\n  </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">function assert (condition, message) {</span><span class="s2">\n  </span><span class="s1">if (!condition) {</span><span class="s2">\n    </span><span class="s1">throw new Error((</span><span class="s2">\&quot;</span><span class="s1">[vue-router] </span><span class="s2">\&quot; </span><span class="s1">+ message))</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function warn (condition, message) {</span><span class="s2">\n  </span><span class="s1">if (!condition) {</span><span class="s2">\n    </span><span class="s1">typeof console !== 'undefined' &amp;&amp; console.warn((</span><span class="s2">\&quot;</span><span class="s1">[vue-router] </span><span class="s2">\&quot; </span><span class="s1">+ message));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function extend (a, b) {</span><span class="s2">\n  </span><span class="s1">for (var key in b) {</span><span class="s2">\n    </span><span class="s1">a[key] = b[key];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return a</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var encodeReserveRE = /[!'()*]/g;</span><span class="s2">\n</span><span class="s1">var encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };</span><span class="s2">\n</span><span class="s1">var commaRE = /%2C/g;</span><span class="s2">\n\n</span><span class="s1">// fixed encodeURIComponent which is more conformant to RFC3986:</span><span class="s2">\n</span><span class="s1">// - escapes [!'()*]</span><span class="s2">\n</span><span class="s1">// - preserve commas</span><span class="s2">\n</span><span class="s1">var encode = function (str) { return encodeURIComponent(str)</span><span class="s2">\n    </span><span class="s1">.replace(encodeReserveRE, encodeReserveReplacer)</span><span class="s2">\n    </span><span class="s1">.replace(commaRE, ','); };</span><span class="s2">\n\n</span><span class="s1">function decode (str) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">return decodeURIComponent(str)</span><span class="s2">\n  </span><span class="s1">} catch (err) {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">warn(false, (</span><span class="s2">\&quot;</span><span class="s1">Error decoding </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ str + </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">. Leaving it intact.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return str</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function resolveQuery (</span><span class="s2">\n  </span><span class="s1">query,</span><span class="s2">\n  </span><span class="s1">extraQuery,</span><span class="s2">\n  </span><span class="s1">_parseQuery</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">if ( extraQuery === void 0 ) extraQuery = {};</span><span class="s2">\n\n  </span><span class="s1">var parse = _parseQuery || parseQuery;</span><span class="s2">\n  </span><span class="s1">var parsedQuery;</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">parsedQuery = parse(query || '');</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(false, e.message);</span><span class="s2">\n    </span><span class="s1">parsedQuery = {};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">for (var key in extraQuery) {</span><span class="s2">\n    </span><span class="s1">var value = extraQuery[key];</span><span class="s2">\n    </span><span class="s1">parsedQuery[key] = Array.isArray(value)</span><span class="s2">\n      </span><span class="s1">? value.map(castQueryParamValue)</span><span class="s2">\n      </span><span class="s1">: castQueryParamValue(value);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return parsedQuery</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var castQueryParamValue = function (value) { return (value == null || typeof value === 'object' ? value : String(value)); };</span><span class="s2">\n\n</span><span class="s1">function parseQuery (query) {</span><span class="s2">\n  </span><span class="s1">var res = {};</span><span class="s2">\n\n  </span><span class="s1">query = query.trim().replace(/^(</span><span class="s2">\\</span><span class="s1">?|#|&amp;)/, '');</span><span class="s2">\n\n  </span><span class="s1">if (!query) {</span><span class="s2">\n    </span><span class="s1">return res</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">query.split('&amp;').forEach(function (param) {</span><span class="s2">\n    </span><span class="s1">var parts = param.replace(/</span><span class="s2">\\</span><span class="s1">+/g, ' ').split('=');</span><span class="s2">\n    </span><span class="s1">var key = decode(parts.shift());</span><span class="s2">\n    </span><span class="s1">var val = parts.length &gt; 0 ? decode(parts.join('=')) : null;</span><span class="s2">\n\n    </span><span class="s1">if (res[key] === undefined) {</span><span class="s2">\n      </span><span class="s1">res[key] = val;</span><span class="s2">\n    </span><span class="s1">} else if (Array.isArray(res[key])) {</span><span class="s2">\n      </span><span class="s1">res[key].push(val);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">res[key] = [res[key], val];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n\n  </span><span class="s1">return res</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function stringifyQuery (obj) {</span><span class="s2">\n  </span><span class="s1">var res = obj</span><span class="s2">\n    </span><span class="s1">? Object.keys(obj)</span><span class="s2">\n      </span><span class="s1">.map(function (key) {</span><span class="s2">\n        </span><span class="s1">var val = obj[key];</span><span class="s2">\n\n        </span><span class="s1">if (val === undefined) {</span><span class="s2">\n          </span><span class="s1">return ''</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (val === null) {</span><span class="s2">\n          </span><span class="s1">return encode(key)</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (Array.isArray(val)) {</span><span class="s2">\n          </span><span class="s1">var result = [];</span><span class="s2">\n          </span><span class="s1">val.forEach(function (val2) {</span><span class="s2">\n            </span><span class="s1">if (val2 === undefined) {</span><span class="s2">\n              </span><span class="s1">return</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (val2 === null) {</span><span class="s2">\n              </span><span class="s1">result.push(encode(key));</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">result.push(encode(key) + '=' + encode(val2));</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">return result.join('&amp;')</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">return encode(key) + '=' + encode(val)</span><span class="s2">\n      </span><span class="s1">})</span><span class="s2">\n      </span><span class="s1">.filter(function (x) { return x.length &gt; 0; })</span><span class="s2">\n      </span><span class="s1">.join('&amp;')</span><span class="s2">\n    </span><span class="s1">: null;</span><span class="s2">\n  </span><span class="s1">return res ? (</span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot; </span><span class="s1">+ res) : ''</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var trailingSlashRE = /</span><span class="s2">\\</span><span class="s1">/?$/;</span><span class="s2">\n\n</span><span class="s1">function createRoute (</span><span class="s2">\n  </span><span class="s1">record,</span><span class="s2">\n  </span><span class="s1">location,</span><span class="s2">\n  </span><span class="s1">redirectedFrom,</span><span class="s2">\n  </span><span class="s1">router</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">var stringifyQuery = router &amp;&amp; router.options.stringifyQuery;</span><span class="s2">\n\n  </span><span class="s1">var query = location.query || {};</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">query = clone(query);</span><span class="s2">\n  </span><span class="s1">} catch (e) {}</span><span class="s2">\n\n  </span><span class="s1">var route = {</span><span class="s2">\n    </span><span class="s1">name: location.name || (record &amp;&amp; record.name),</span><span class="s2">\n    </span><span class="s1">meta: (record &amp;&amp; record.meta) || {},</span><span class="s2">\n    </span><span class="s1">path: location.path || '/',</span><span class="s2">\n    </span><span class="s1">hash: location.hash || '',</span><span class="s2">\n    </span><span class="s1">query: query,</span><span class="s2">\n    </span><span class="s1">params: location.params || {},</span><span class="s2">\n    </span><span class="s1">fullPath: getFullPath(location, stringifyQuery),</span><span class="s2">\n    </span><span class="s1">matched: record ? formatMatch(record) : []</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (redirectedFrom) {</span><span class="s2">\n    </span><span class="s1">route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return Object.freeze(route)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function clone (value) {</span><span class="s2">\n  </span><span class="s1">if (Array.isArray(value)) {</span><span class="s2">\n    </span><span class="s1">return value.map(clone)</span><span class="s2">\n  </span><span class="s1">} else if (value &amp;&amp; typeof value === 'object') {</span><span class="s2">\n    </span><span class="s1">var res = {};</span><span class="s2">\n    </span><span class="s1">for (var key in value) {</span><span class="s2">\n      </span><span class="s1">res[key] = clone(value[key]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return value</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// the starting route that represents the initial state</span><span class="s2">\n</span><span class="s1">var START = createRoute(null, {</span><span class="s2">\n  </span><span class="s1">path: '/'</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n\n</span><span class="s1">function formatMatch (record) {</span><span class="s2">\n  </span><span class="s1">var res = [];</span><span class="s2">\n  </span><span class="s1">while (record) {</span><span class="s2">\n    </span><span class="s1">res.unshift(record);</span><span class="s2">\n    </span><span class="s1">record = record.parent;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return res</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function getFullPath (</span><span class="s2">\n  </span><span class="s1">ref,</span><span class="s2">\n  </span><span class="s1">_stringifyQuery</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">var path = ref.path;</span><span class="s2">\n  </span><span class="s1">var query = ref.query; if ( query === void 0 ) query = {};</span><span class="s2">\n  </span><span class="s1">var hash = ref.hash; if ( hash === void 0 ) hash = '';</span><span class="s2">\n\n  </span><span class="s1">var stringify = _stringifyQuery || stringifyQuery;</span><span class="s2">\n  </span><span class="s1">return (path || '/') + stringify(query) + hash</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function isSameRoute (a, b, onlyPath) {</span><span class="s2">\n  </span><span class="s1">if (b === START) {</span><span class="s2">\n    </span><span class="s1">return a === b</span><span class="s2">\n  </span><span class="s1">} else if (!b) {</span><span class="s2">\n    </span><span class="s1">return false</span><span class="s2">\n  </span><span class="s1">} else if (a.path &amp;&amp; b.path) {</span><span class="s2">\n    </span><span class="s1">return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &amp;&amp; (onlyPath ||</span><span class="s2">\n      </span><span class="s1">a.hash === b.hash &amp;&amp;</span><span class="s2">\n      </span><span class="s1">isObjectEqual(a.query, b.query))</span><span class="s2">\n  </span><span class="s1">} else if (a.name &amp;&amp; b.name) {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">a.name === b.name &amp;&amp;</span><span class="s2">\n      </span><span class="s1">(onlyPath || (</span><span class="s2">\n        </span><span class="s1">a.hash === b.hash &amp;&amp;</span><span class="s2">\n      </span><span class="s1">isObjectEqual(a.query, b.query) &amp;&amp;</span><span class="s2">\n      </span><span class="s1">isObjectEqual(a.params, b.params))</span><span class="s2">\n      </span><span class="s1">)</span><span class="s2">\n    </span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return false</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function isObjectEqual (a, b) {</span><span class="s2">\n  </span><span class="s1">if ( a === void 0 ) a = {};</span><span class="s2">\n  </span><span class="s1">if ( b === void 0 ) b = {};</span><span class="s2">\n\n  </span><span class="s1">// handle null value #1566</span><span class="s2">\n  </span><span class="s1">if (!a || !b) { return a === b }</span><span class="s2">\n  </span><span class="s1">var aKeys = Object.keys(a).sort();</span><span class="s2">\n  </span><span class="s1">var bKeys = Object.keys(b).sort();</span><span class="s2">\n  </span><span class="s1">if (aKeys.length !== bKeys.length) {</span><span class="s2">\n    </span><span class="s1">return false</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return aKeys.every(function (key, i) {</span><span class="s2">\n    </span><span class="s1">var aVal = a[key];</span><span class="s2">\n    </span><span class="s1">var bKey = bKeys[i];</span><span class="s2">\n    </span><span class="s1">if (bKey !== key) { return false }</span><span class="s2">\n    </span><span class="s1">var bVal = b[key];</span><span class="s2">\n    </span><span class="s1">// query values can be null and undefined</span><span class="s2">\n    </span><span class="s1">if (aVal == null || bVal == null) { return aVal === bVal }</span><span class="s2">\n    </span><span class="s1">// check nested equality</span><span class="s2">\n    </span><span class="s1">if (typeof aVal === 'object' &amp;&amp; typeof bVal === 'object') {</span><span class="s2">\n      </span><span class="s1">return isObjectEqual(aVal, bVal)</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return String(aVal) === String(bVal)</span><span class="s2">\n  </span><span class="s1">})</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function isIncludedRoute (current, target) {</span><span class="s2">\n  </span><span class="s1">return (</span><span class="s2">\n    </span><span class="s1">current.path.replace(trailingSlashRE, '/').indexOf(</span><span class="s2">\n      </span><span class="s1">target.path.replace(trailingSlashRE, '/')</span><span class="s2">\n    </span><span class="s1">) === 0 &amp;&amp;</span><span class="s2">\n    </span><span class="s1">(!target.hash || current.hash === target.hash) &amp;&amp;</span><span class="s2">\n    </span><span class="s1">queryIncludes(current.query, target.query)</span><span class="s2">\n  </span><span class="s1">)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function queryIncludes (current, target) {</span><span class="s2">\n  </span><span class="s1">for (var key in target) {</span><span class="s2">\n    </span><span class="s1">if (!(key in current)) {</span><span class="s2">\n      </span><span class="s1">return false</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return true</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function handleRouteEntered (route) {</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; route.matched.length; i++) {</span><span class="s2">\n    </span><span class="s1">var record = route.matched[i];</span><span class="s2">\n    </span><span class="s1">for (var name in record.instances) {</span><span class="s2">\n      </span><span class="s1">var instance = record.instances[name];</span><span class="s2">\n      </span><span class="s1">var cbs = record.enteredCbs[name];</span><span class="s2">\n      </span><span class="s1">if (!instance || !cbs) { continue }</span><span class="s2">\n      </span><span class="s1">delete record.enteredCbs[name];</span><span class="s2">\n      </span><span class="s1">for (var i$1 = 0; i$1 &lt; cbs.length; i$1++) {</span><span class="s2">\n        </span><span class="s1">if (!instance._isBeingDestroyed) { cbs[i$1](instance); }</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var View = {</span><span class="s2">\n  </span><span class="s1">name: 'RouterView',</span><span class="s2">\n  </span><span class="s1">functional: true,</span><span class="s2">\n  </span><span class="s1">props: {</span><span class="s2">\n    </span><span class="s1">name: {</span><span class="s2">\n      </span><span class="s1">type: String,</span><span class="s2">\n      </span><span class="s1">default: 'default'</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">render: function render (_, ref) {</span><span class="s2">\n    </span><span class="s1">var props = ref.props;</span><span class="s2">\n    </span><span class="s1">var children = ref.children;</span><span class="s2">\n    </span><span class="s1">var parent = ref.parent;</span><span class="s2">\n    </span><span class="s1">var data = ref.data;</span><span class="s2">\n\n    </span><span class="s1">// used by devtools to display a router-view badge</span><span class="s2">\n    </span><span class="s1">data.routerView = true;</span><span class="s2">\n\n    </span><span class="s1">// directly use parent context's createElement() function</span><span class="s2">\n    </span><span class="s1">// so that components rendered by router-view can resolve named slots</span><span class="s2">\n    </span><span class="s1">var h = parent.$createElement;</span><span class="s2">\n    </span><span class="s1">var name = props.name;</span><span class="s2">\n    </span><span class="s1">var route = parent.$route;</span><span class="s2">\n    </span><span class="s1">var cache = parent._routerViewCache || (parent._routerViewCache = {});</span><span class="s2">\n\n    </span><span class="s1">// determine current view depth, also check to see if the tree</span><span class="s2">\n    </span><span class="s1">// has been toggled inactive but kept-alive.</span><span class="s2">\n    </span><span class="s1">var depth = 0;</span><span class="s2">\n    </span><span class="s1">var inactive = false;</span><span class="s2">\n    </span><span class="s1">while (parent &amp;&amp; parent._routerRoot !== parent) {</span><span class="s2">\n      </span><span class="s1">var vnodeData = parent.$vnode ? parent.$vnode.data : {};</span><span class="s2">\n      </span><span class="s1">if (vnodeData.routerView) {</span><span class="s2">\n        </span><span class="s1">depth++;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (vnodeData.keepAlive &amp;&amp; parent._directInactive &amp;&amp; parent._inactive) {</span><span class="s2">\n        </span><span class="s1">inactive = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">parent = parent.$parent;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">data.routerViewDepth = depth;</span><span class="s2">\n\n    </span><span class="s1">// render previous view if the tree is inactive and kept-alive</span><span class="s2">\n    </span><span class="s1">if (inactive) {</span><span class="s2">\n      </span><span class="s1">var cachedData = cache[name];</span><span class="s2">\n      </span><span class="s1">var cachedComponent = cachedData &amp;&amp; cachedData.component;</span><span class="s2">\n      </span><span class="s1">if (cachedComponent) {</span><span class="s2">\n        </span><span class="s1">// #2301</span><span class="s2">\n        </span><span class="s1">// pass props</span><span class="s2">\n        </span><span class="s1">if (cachedData.configProps) {</span><span class="s2">\n          </span><span class="s1">fillPropsinData(cachedComponent, data, cachedData.route, cachedData.configProps);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return h(cachedComponent, data, children)</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">// render previous empty view</span><span class="s2">\n        </span><span class="s1">return h()</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">var matched = route.matched[depth];</span><span class="s2">\n    </span><span class="s1">var component = matched &amp;&amp; matched.components[name];</span><span class="s2">\n\n    </span><span class="s1">// render empty node if no matched route or no config component</span><span class="s2">\n    </span><span class="s1">if (!matched || !component) {</span><span class="s2">\n      </span><span class="s1">cache[name] = null;</span><span class="s2">\n      </span><span class="s1">return h()</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// cache component</span><span class="s2">\n    </span><span class="s1">cache[name] = { component: component };</span><span class="s2">\n\n    </span><span class="s1">// attach instance registration hook</span><span class="s2">\n    </span><span class="s1">// this will be called in the instance's injected lifecycle hooks</span><span class="s2">\n    </span><span class="s1">data.registerRouteInstance = function (vm, val) {</span><span class="s2">\n      </span><span class="s1">// val could be undefined for unregistration</span><span class="s2">\n      </span><span class="s1">var current = matched.instances[name];</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">(val &amp;&amp; current !== vm) ||</span><span class="s2">\n        </span><span class="s1">(!val &amp;&amp; current === vm)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">matched.instances[name] = val;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// also register instance in prepatch hook</span><span class="s2">\n    </span><span class="s1">// in case the same component instance is reused across different routes</span><span class="s2">\n    </span><span class="s1">;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {</span><span class="s2">\n      </span><span class="s1">matched.instances[name] = vnode.componentInstance;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n\n    </span><span class="s1">// register instance in init hook</span><span class="s2">\n    </span><span class="s1">// in case kept-alive component be actived when routes changed</span><span class="s2">\n    </span><span class="s1">data.hook.init = function (vnode) {</span><span class="s2">\n      </span><span class="s1">if (vnode.data.keepAlive &amp;&amp;</span><span class="s2">\n        </span><span class="s1">vnode.componentInstance &amp;&amp;</span><span class="s2">\n        </span><span class="s1">vnode.componentInstance !== matched.instances[name]</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">matched.instances[name] = vnode.componentInstance;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// if the route transition has already been confirmed then we weren't</span><span class="s2">\n      </span><span class="s1">// able to call the cbs during confirmation as the component was not</span><span class="s2">\n      </span><span class="s1">// registered yet, so we call it here.</span><span class="s2">\n      </span><span class="s1">handleRouteEntered(route);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n\n    </span><span class="s1">var configProps = matched.props &amp;&amp; matched.props[name];</span><span class="s2">\n    </span><span class="s1">// save route and configProps in cache</span><span class="s2">\n    </span><span class="s1">if (configProps) {</span><span class="s2">\n      </span><span class="s1">extend(cache[name], {</span><span class="s2">\n        </span><span class="s1">route: route,</span><span class="s2">\n        </span><span class="s1">configProps: configProps</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">fillPropsinData(component, data, route, configProps);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return h(component, data, children)</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">function fillPropsinData (component, data, route, configProps) {</span><span class="s2">\n  </span><span class="s1">// resolve props</span><span class="s2">\n  </span><span class="s1">var propsToPass = data.props = resolveProps(route, configProps);</span><span class="s2">\n  </span><span class="s1">if (propsToPass) {</span><span class="s2">\n    </span><span class="s1">// clone to prevent mutation</span><span class="s2">\n    </span><span class="s1">propsToPass = data.props = extend({}, propsToPass);</span><span class="s2">\n    </span><span class="s1">// pass non-declared props as attrs</span><span class="s2">\n    </span><span class="s1">var attrs = data.attrs = data.attrs || {};</span><span class="s2">\n    </span><span class="s1">for (var key in propsToPass) {</span><span class="s2">\n      </span><span class="s1">if (!component.props || !(key in component.props)) {</span><span class="s2">\n        </span><span class="s1">attrs[key] = propsToPass[key];</span><span class="s2">\n        </span><span class="s1">delete propsToPass[key];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function resolveProps (route, config) {</span><span class="s2">\n  </span><span class="s1">switch (typeof config) {</span><span class="s2">\n    </span><span class="s1">case 'undefined':</span><span class="s2">\n      </span><span class="s1">return</span><span class="s2">\n    </span><span class="s1">case 'object':</span><span class="s2">\n      </span><span class="s1">return config</span><span class="s2">\n    </span><span class="s1">case 'function':</span><span class="s2">\n      </span><span class="s1">return config(route)</span><span class="s2">\n    </span><span class="s1">case 'boolean':</span><span class="s2">\n      </span><span class="s1">return config ? route.params : undefined</span><span class="s2">\n    </span><span class="s1">default:</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\n          </span><span class="s1">false,</span><span class="s2">\n          \&quot;</span><span class="s1">props in </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ (route.path) + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is a </span><span class="s2">\&quot; </span><span class="s1">+ (typeof config) + </span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n          \&quot;</span><span class="s1">expecting an object, function or boolean.</span><span class="s2">\&quot;\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">function resolvePath (</span><span class="s2">\n  </span><span class="s1">relative,</span><span class="s2">\n  </span><span class="s1">base,</span><span class="s2">\n  </span><span class="s1">append</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">var firstChar = relative.charAt(0);</span><span class="s2">\n  </span><span class="s1">if (firstChar === '/') {</span><span class="s2">\n    </span><span class="s1">return relative</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (firstChar === '?' || firstChar === '#') {</span><span class="s2">\n    </span><span class="s1">return base + relative</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">var stack = base.split('/');</span><span class="s2">\n\n  </span><span class="s1">// remove trailing segment if:</span><span class="s2">\n  </span><span class="s1">// - not appending</span><span class="s2">\n  </span><span class="s1">// - appending to trailing slash (last segment is empty)</span><span class="s2">\n  </span><span class="s1">if (!append || !stack[stack.length - 1]) {</span><span class="s2">\n    </span><span class="s1">stack.pop();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// resolve relative path</span><span class="s2">\n  </span><span class="s1">var segments = relative.replace(/^</span><span class="s2">\\</span><span class="s1">//, '').split('/');</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; segments.length; i++) {</span><span class="s2">\n    </span><span class="s1">var segment = segments[i];</span><span class="s2">\n    </span><span class="s1">if (segment === '..') {</span><span class="s2">\n      </span><span class="s1">stack.pop();</span><span class="s2">\n    </span><span class="s1">} else if (segment !== '.') {</span><span class="s2">\n      </span><span class="s1">stack.push(segment);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// ensure leading slash</span><span class="s2">\n  </span><span class="s1">if (stack[0] !== '') {</span><span class="s2">\n    </span><span class="s1">stack.unshift('');</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return stack.join('/')</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function parsePath (path) {</span><span class="s2">\n  </span><span class="s1">var hash = '';</span><span class="s2">\n  </span><span class="s1">var query = '';</span><span class="s2">\n\n  </span><span class="s1">var hashIndex = path.indexOf('#');</span><span class="s2">\n  </span><span class="s1">if (hashIndex &gt;= 0) {</span><span class="s2">\n    </span><span class="s1">hash = path.slice(hashIndex);</span><span class="s2">\n    </span><span class="s1">path = path.slice(0, hashIndex);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">var queryIndex = path.indexOf('?');</span><span class="s2">\n  </span><span class="s1">if (queryIndex &gt;= 0) {</span><span class="s2">\n    </span><span class="s1">query = path.slice(queryIndex + 1);</span><span class="s2">\n    </span><span class="s1">path = path.slice(0, queryIndex);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">path: path,</span><span class="s2">\n    </span><span class="s1">query: query,</span><span class="s2">\n    </span><span class="s1">hash: hash</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function cleanPath (path) {</span><span class="s2">\n  </span><span class="s1">return path.replace(/</span><span class="s2">\\</span><span class="s1">/(?:</span><span class="s2">\\</span><span class="s1">s*</span><span class="s2">\\</span><span class="s1">/)+/g, '/')</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var isarray = Array.isArray || function (arr) {</span><span class="s2">\n  </span><span class="s1">return Object.prototype.toString.call(arr) == '[object Array]';</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Expose `pathToRegexp`.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var pathToRegexp_1 = pathToRegexp;</span><span class="s2">\n</span><span class="s1">var parse_1 = parse;</span><span class="s2">\n</span><span class="s1">var compile_1 = compile;</span><span class="s2">\n</span><span class="s1">var tokensToFunction_1 = tokensToFunction;</span><span class="s2">\n</span><span class="s1">var tokensToRegExp_1 = tokensToRegExp;</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* The main path matching regexp utility.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @type {RegExp}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var PATH_REGEXP = new RegExp([</span><span class="s2">\n  </span><span class="s1">// Match escaped characters that would otherwise appear in future matches.</span><span class="s2">\n  </span><span class="s1">// This allows the user to escape special characters that won't transform.</span><span class="s2">\n  </span><span class="s1">'(</span><span class="s2">\\\\\\\\</span><span class="s1">.)',</span><span class="s2">\n  </span><span class="s1">// Match Express-style parameters and un-named parameters with a prefix</span><span class="s2">\n  </span><span class="s1">// and optional suffixes. Matches appear as:</span><span class="s2">\n  </span><span class="s1">//</span><span class="s2">\n  </span><span class="s1">// </span><span class="s2">\&quot;</span><span class="s1">/:test(</span><span class="s2">\\\\</span><span class="s1">d+)?</span><span class="s2">\&quot; </span><span class="s1">=&gt; [</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">test</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;\\</span><span class="s1">d+</span><span class="s2">\&quot;</span><span class="s1">, undefined, </span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot;</span><span class="s1">, undefined]</span><span class="s2">\n  </span><span class="s1">// </span><span class="s2">\&quot;</span><span class="s1">/route(</span><span class="s2">\\\\</span><span class="s1">d+)</span><span class="s2">\&quot;  </span><span class="s1">=&gt; [undefined, undefined, undefined, </span><span class="s2">\&quot;\\</span><span class="s1">d+</span><span class="s2">\&quot;</span><span class="s1">, undefined, undefined]</span><span class="s2">\n  </span><span class="s1">// </span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot;            </span><span class="s1">=&gt; [</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">, undefined, undefined, undefined, undefined, </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\n  </span><span class="s1">'([</span><span class="s2">\\\\</span><span class="s1">/.])?(?:(?:</span><span class="s2">\\\\</span><span class="s1">:(</span><span class="s2">\\\\</span><span class="s1">w+)(?:</span><span class="s2">\\\\</span><span class="s1">(((?:</span><span class="s2">\\\\\\\\</span><span class="s1">.|[^</span><span class="s2">\\\\\\\\</span><span class="s1">()])+)</span><span class="s2">\\\\</span><span class="s1">))?|</span><span class="s2">\\\\</span><span class="s1">(((?:</span><span class="s2">\\\\\\\\</span><span class="s1">.|[^</span><span class="s2">\\\\\\\\</span><span class="s1">()])+)</span><span class="s2">\\\\</span><span class="s1">))([+*?])?|(</span><span class="s2">\\\\</span><span class="s1">*))'</span><span class="s2">\n</span><span class="s1">].join('|'), 'g');</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Parse a string for the raw tokens.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {string}  str</span><span class="s2">\n </span><span class="s1">* @param  {Object=} options</span><span class="s2">\n </span><span class="s1">* @return {!Array}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function parse (str, options) {</span><span class="s2">\n  </span><span class="s1">var tokens = [];</span><span class="s2">\n  </span><span class="s1">var key = 0;</span><span class="s2">\n  </span><span class="s1">var index = 0;</span><span class="s2">\n  </span><span class="s1">var path = '';</span><span class="s2">\n  </span><span class="s1">var defaultDelimiter = options &amp;&amp; options.delimiter || '/';</span><span class="s2">\n  </span><span class="s1">var res;</span><span class="s2">\n\n  </span><span class="s1">while ((res = PATH_REGEXP.exec(str)) != null) {</span><span class="s2">\n    </span><span class="s1">var m = res[0];</span><span class="s2">\n    </span><span class="s1">var escaped = res[1];</span><span class="s2">\n    </span><span class="s1">var offset = res.index;</span><span class="s2">\n    </span><span class="s1">path += str.slice(index, offset);</span><span class="s2">\n    </span><span class="s1">index = offset + m.length;</span><span class="s2">\n\n    </span><span class="s1">// Ignore already escaped sequences.</span><span class="s2">\n    </span><span class="s1">if (escaped) {</span><span class="s2">\n      </span><span class="s1">path += escaped[1];</span><span class="s2">\n      </span><span class="s1">continue</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">var next = str[index];</span><span class="s2">\n    </span><span class="s1">var prefix = res[2];</span><span class="s2">\n    </span><span class="s1">var name = res[3];</span><span class="s2">\n    </span><span class="s1">var capture = res[4];</span><span class="s2">\n    </span><span class="s1">var group = res[5];</span><span class="s2">\n    </span><span class="s1">var modifier = res[6];</span><span class="s2">\n    </span><span class="s1">var asterisk = res[7];</span><span class="s2">\n\n    </span><span class="s1">// Push the current path onto the tokens.</span><span class="s2">\n    </span><span class="s1">if (path) {</span><span class="s2">\n      </span><span class="s1">tokens.push(path);</span><span class="s2">\n      </span><span class="s1">path = '';</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">var partial = prefix != null &amp;&amp; next != null &amp;&amp; next !== prefix;</span><span class="s2">\n    </span><span class="s1">var repeat = modifier === '+' || modifier === '*';</span><span class="s2">\n    </span><span class="s1">var optional = modifier === '?' || modifier === '*';</span><span class="s2">\n    </span><span class="s1">var delimiter = res[2] || defaultDelimiter;</span><span class="s2">\n    </span><span class="s1">var pattern = capture || group;</span><span class="s2">\n\n    </span><span class="s1">tokens.push({</span><span class="s2">\n      </span><span class="s1">name: name || key++,</span><span class="s2">\n      </span><span class="s1">prefix: prefix || '',</span><span class="s2">\n      </span><span class="s1">delimiter: delimiter,</span><span class="s2">\n      </span><span class="s1">optional: optional,</span><span class="s2">\n      </span><span class="s1">repeat: repeat,</span><span class="s2">\n      </span><span class="s1">partial: partial,</span><span class="s2">\n      </span><span class="s1">asterisk: !!asterisk,</span><span class="s2">\n      </span><span class="s1">pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Match any characters still remaining.</span><span class="s2">\n  </span><span class="s1">if (index &lt; str.length) {</span><span class="s2">\n    </span><span class="s1">path += str.substr(index);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// If the path exists, push it onto the end.</span><span class="s2">\n  </span><span class="s1">if (path) {</span><span class="s2">\n    </span><span class="s1">tokens.push(path);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return tokens</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Compile a string to a template function for the path.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {string}             str</span><span class="s2">\n </span><span class="s1">* @param  {Object=}            options</span><span class="s2">\n </span><span class="s1">* @return {!function(Object=, Object=)}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function compile (str, options) {</span><span class="s2">\n  </span><span class="s1">return tokensToFunction(parse(str, options), options)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Prettier encoding of URI path segments.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {string}</span><span class="s2">\n </span><span class="s1">* @return {string}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function encodeURIComponentPretty (str) {</span><span class="s2">\n  </span><span class="s1">return encodeURI(str).replace(/[</span><span class="s2">\\</span><span class="s1">/?#]/g, function (c) {</span><span class="s2">\n    </span><span class="s1">return '%' + c.charCodeAt(0).toString(16).toUpperCase()</span><span class="s2">\n  </span><span class="s1">})</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Encode the asterisk parameter. Similar to `pretty`, but allows slashes.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {string}</span><span class="s2">\n </span><span class="s1">* @return {string}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function encodeAsterisk (str) {</span><span class="s2">\n  </span><span class="s1">return encodeURI(str).replace(/[?#]/g, function (c) {</span><span class="s2">\n    </span><span class="s1">return '%' + c.charCodeAt(0).toString(16).toUpperCase()</span><span class="s2">\n  </span><span class="s1">})</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Expose a method for transforming tokens into the path function.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function tokensToFunction (tokens, options) {</span><span class="s2">\n  </span><span class="s1">// Compile all the tokens into regexps.</span><span class="s2">\n  </span><span class="s1">var matches = new Array(tokens.length);</span><span class="s2">\n\n  </span><span class="s1">// Compile all the patterns before compilation.</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; tokens.length; i++) {</span><span class="s2">\n    </span><span class="s1">if (typeof tokens[i] === 'object') {</span><span class="s2">\n      </span><span class="s1">matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return function (obj, opts) {</span><span class="s2">\n    </span><span class="s1">var path = '';</span><span class="s2">\n    </span><span class="s1">var data = obj || {};</span><span class="s2">\n    </span><span class="s1">var options = opts || {};</span><span class="s2">\n    </span><span class="s1">var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;</span><span class="s2">\n\n    </span><span class="s1">for (var i = 0; i &lt; tokens.length; i++) {</span><span class="s2">\n      </span><span class="s1">var token = tokens[i];</span><span class="s2">\n\n      </span><span class="s1">if (typeof token === 'string') {</span><span class="s2">\n        </span><span class="s1">path += token;</span><span class="s2">\n\n        </span><span class="s1">continue</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">var value = data[token.name];</span><span class="s2">\n      </span><span class="s1">var segment;</span><span class="s2">\n\n      </span><span class="s1">if (value == null) {</span><span class="s2">\n        </span><span class="s1">if (token.optional) {</span><span class="s2">\n          </span><span class="s1">// Prepend partial segment prefixes.</span><span class="s2">\n          </span><span class="s1">if (token.partial) {</span><span class="s2">\n            </span><span class="s1">path += token.prefix;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">continue</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">throw new TypeError('Expected </span><span class="s2">\&quot;</span><span class="s1">' + token.name + '</span><span class="s2">\&quot; </span><span class="s1">to be defined')</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (isarray(value)) {</span><span class="s2">\n        </span><span class="s1">if (!token.repeat) {</span><span class="s2">\n          </span><span class="s1">throw new TypeError('Expected </span><span class="s2">\&quot;</span><span class="s1">' + token.name + '</span><span class="s2">\&quot; </span><span class="s1">to not repeat, but received `' + JSON.stringify(value) + '`')</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (value.length === 0) {</span><span class="s2">\n          </span><span class="s1">if (token.optional) {</span><span class="s2">\n            </span><span class="s1">continue</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">throw new TypeError('Expected </span><span class="s2">\&quot;</span><span class="s1">' + token.name + '</span><span class="s2">\&quot; </span><span class="s1">to not be empty')</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">for (var j = 0; j &lt; value.length; j++) {</span><span class="s2">\n          </span><span class="s1">segment = encode(value[j]);</span><span class="s2">\n\n          </span><span class="s1">if (!matches[i].test(segment)) {</span><span class="s2">\n            </span><span class="s1">throw new TypeError('Expected all </span><span class="s2">\&quot;</span><span class="s1">' + token.name + '</span><span class="s2">\&quot; </span><span class="s1">to match </span><span class="s2">\&quot;</span><span class="s1">' + token.pattern + '</span><span class="s2">\&quot;</span><span class="s1">, but received `' + JSON.stringify(segment) + '`')</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">path += (j === 0 ? token.prefix : token.delimiter) + segment;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">continue</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">segment = token.asterisk ? encodeAsterisk(value) : encode(value);</span><span class="s2">\n\n      </span><span class="s1">if (!matches[i].test(segment)) {</span><span class="s2">\n        </span><span class="s1">throw new TypeError('Expected </span><span class="s2">\&quot;</span><span class="s1">' + token.name + '</span><span class="s2">\&quot; </span><span class="s1">to match </span><span class="s2">\&quot;</span><span class="s1">' + token.pattern + '</span><span class="s2">\&quot;</span><span class="s1">, but received </span><span class="s2">\&quot;</span><span class="s1">' + segment + '</span><span class="s2">\&quot;</span><span class="s1">')</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">path += token.prefix + segment;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return path</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Escape a regular expression string.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {string} str</span><span class="s2">\n </span><span class="s1">* @return {string}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function escapeString (str) {</span><span class="s2">\n  </span><span class="s1">return str.replace(/([.+*?=^!:${}()[</span><span class="s2">\\</span><span class="s1">]|</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\\\</span><span class="s1">])/g, '</span><span class="s2">\\\\</span><span class="s1">$1')</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Escape the capturing group by escaping special characters and meaning.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {string} group</span><span class="s2">\n </span><span class="s1">* @return {string}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function escapeGroup (group) {</span><span class="s2">\n  </span><span class="s1">return group.replace(/([=!:$</span><span class="s2">\\</span><span class="s1">/()])/g, '</span><span class="s2">\\\\</span><span class="s1">$1')</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Attach the keys as a property of the regexp.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {!RegExp} re</span><span class="s2">\n </span><span class="s1">* @param  {Array}   keys</span><span class="s2">\n </span><span class="s1">* @return {!RegExp}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function attachKeys (re, keys) {</span><span class="s2">\n  </span><span class="s1">re.keys = keys;</span><span class="s2">\n  </span><span class="s1">return re</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Get the flags for a regexp from the options.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {Object} options</span><span class="s2">\n </span><span class="s1">* @return {string}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function flags (options) {</span><span class="s2">\n  </span><span class="s1">return options &amp;&amp; options.sensitive ? '' : 'i'</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Pull out keys from a regexp.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {!RegExp} path</span><span class="s2">\n </span><span class="s1">* @param  {!Array}  keys</span><span class="s2">\n </span><span class="s1">* @return {!RegExp}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function regexpToRegexp (path, keys) {</span><span class="s2">\n  </span><span class="s1">// Use a negative lookahead to match only capturing groups.</span><span class="s2">\n  </span><span class="s1">var groups = path.source.match(/</span><span class="s2">\\</span><span class="s1">((?!</span><span class="s2">\\</span><span class="s1">?)/g);</span><span class="s2">\n\n  </span><span class="s1">if (groups) {</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; groups.length; i++) {</span><span class="s2">\n      </span><span class="s1">keys.push({</span><span class="s2">\n        </span><span class="s1">name: i,</span><span class="s2">\n        </span><span class="s1">prefix: null,</span><span class="s2">\n        </span><span class="s1">delimiter: null,</span><span class="s2">\n        </span><span class="s1">optional: false,</span><span class="s2">\n        </span><span class="s1">repeat: false,</span><span class="s2">\n        </span><span class="s1">partial: false,</span><span class="s2">\n        </span><span class="s1">asterisk: false,</span><span class="s2">\n        </span><span class="s1">pattern: null</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return attachKeys(path, keys)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Transform an array into a regexp.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {!Array}  path</span><span class="s2">\n </span><span class="s1">* @param  {Array}   keys</span><span class="s2">\n </span><span class="s1">* @param  {!Object} options</span><span class="s2">\n </span><span class="s1">* @return {!RegExp}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function arrayToRegexp (path, keys, options) {</span><span class="s2">\n  </span><span class="s1">var parts = [];</span><span class="s2">\n\n  </span><span class="s1">for (var i = 0; i &lt; path.length; i++) {</span><span class="s2">\n    </span><span class="s1">parts.push(pathToRegexp(path[i], keys, options).source);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));</span><span class="s2">\n\n  </span><span class="s1">return attachKeys(regexp, keys)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Create a path regexp from string input.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {string}  path</span><span class="s2">\n </span><span class="s1">* @param  {!Array}  keys</span><span class="s2">\n </span><span class="s1">* @param  {!Object} options</span><span class="s2">\n </span><span class="s1">* @return {!RegExp}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function stringToRegexp (path, keys, options) {</span><span class="s2">\n  </span><span class="s1">return tokensToRegExp(parse(path, options), keys, options)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Expose a function for taking tokens and returning a RegExp.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {!Array}          tokens</span><span class="s2">\n </span><span class="s1">* @param  {(Array|Object)=} keys</span><span class="s2">\n </span><span class="s1">* @param  {Object=}         options</span><span class="s2">\n </span><span class="s1">* @return {!RegExp}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function tokensToRegExp (tokens, keys, options) {</span><span class="s2">\n  </span><span class="s1">if (!isarray(keys)) {</span><span class="s2">\n    </span><span class="s1">options = /** @type {!Object} */ (keys || options);</span><span class="s2">\n    </span><span class="s1">keys = [];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">options = options || {};</span><span class="s2">\n\n  </span><span class="s1">var strict = options.strict;</span><span class="s2">\n  </span><span class="s1">var end = options.end !== false;</span><span class="s2">\n  </span><span class="s1">var route = '';</span><span class="s2">\n\n  </span><span class="s1">// Iterate over the tokens and create our regexp string.</span><span class="s2">\n  </span><span class="s1">for (var i = 0; i &lt; tokens.length; i++) {</span><span class="s2">\n    </span><span class="s1">var token = tokens[i];</span><span class="s2">\n\n    </span><span class="s1">if (typeof token === 'string') {</span><span class="s2">\n      </span><span class="s1">route += escapeString(token);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">var prefix = escapeString(token.prefix);</span><span class="s2">\n      </span><span class="s1">var capture = '(?:' + token.pattern + ')';</span><span class="s2">\n\n      </span><span class="s1">keys.push(token);</span><span class="s2">\n\n      </span><span class="s1">if (token.repeat) {</span><span class="s2">\n        </span><span class="s1">capture += '(?:' + prefix + capture + ')*';</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (token.optional) {</span><span class="s2">\n        </span><span class="s1">if (!token.partial) {</span><span class="s2">\n          </span><span class="s1">capture = '(?:' + prefix + '(' + capture + '))?';</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">capture = prefix + '(' + capture + ')?';</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">capture = prefix + '(' + capture + ')';</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">route += capture;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">var delimiter = escapeString(options.delimiter || '/');</span><span class="s2">\n  </span><span class="s1">var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;</span><span class="s2">\n\n  </span><span class="s1">// In non-strict mode we allow a slash at the end of match. If the path to</span><span class="s2">\n  </span><span class="s1">// match already ends with a slash, we remove it for consistency. The slash</span><span class="s2">\n  </span><span class="s1">// is valid at the end of a path match, not in the middle. This is important</span><span class="s2">\n  </span><span class="s1">// in non-ending mode, where </span><span class="s2">\&quot;</span><span class="s1">/test/</span><span class="s2">\&quot; </span><span class="s1">shouldn't match </span><span class="s2">\&quot;</span><span class="s1">/test//route</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\n  </span><span class="s1">if (!strict) {</span><span class="s2">\n    </span><span class="s1">route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (end) {</span><span class="s2">\n    </span><span class="s1">route += '$';</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">// In non-ending mode, we need the capturing groups to match as much as</span><span class="s2">\n    </span><span class="s1">// possible by using a positive lookahead to the end or next path segment.</span><span class="s2">\n    </span><span class="s1">route += strict &amp;&amp; endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return attachKeys(new RegExp('^' + route, flags(options)), keys)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Normalize the given path string, returning a regular expression.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* An empty array can be passed in for the keys, which will hold the</span><span class="s2">\n </span><span class="s1">* placeholder key descriptions. For example, using `/user/:id`, `keys` will</span><span class="s2">\n </span><span class="s1">* contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @param  {(string|RegExp|Array)} path</span><span class="s2">\n </span><span class="s1">* @param  {(Array|Object)=}       keys</span><span class="s2">\n </span><span class="s1">* @param  {Object=}               options</span><span class="s2">\n </span><span class="s1">* @return {!RegExp}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function pathToRegexp (path, keys, options) {</span><span class="s2">\n  </span><span class="s1">if (!isarray(keys)) {</span><span class="s2">\n    </span><span class="s1">options = /** @type {!Object} */ (keys || options);</span><span class="s2">\n    </span><span class="s1">keys = [];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">options = options || {};</span><span class="s2">\n\n  </span><span class="s1">if (path instanceof RegExp) {</span><span class="s2">\n    </span><span class="s1">return regexpToRegexp(path, /** @type {!Array} */ (keys))</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (isarray(path)) {</span><span class="s2">\n    </span><span class="s1">return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">pathToRegexp_1.parse = parse_1;</span><span class="s2">\n</span><span class="s1">pathToRegexp_1.compile = compile_1;</span><span class="s2">\n</span><span class="s1">pathToRegexp_1.tokensToFunction = tokensToFunction_1;</span><span class="s2">\n</span><span class="s1">pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">// $flow-disable-line</span><span class="s2">\n</span><span class="s1">var regexpCompileCache = Object.create(null);</span><span class="s2">\n\n</span><span class="s1">function fillParams (</span><span class="s2">\n  </span><span class="s1">path,</span><span class="s2">\n  </span><span class="s1">params,</span><span class="s2">\n  </span><span class="s1">routeMsg</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">params = params || {};</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">var filler =</span><span class="s2">\n      </span><span class="s1">regexpCompileCache[path] ||</span><span class="s2">\n      </span><span class="s1">(regexpCompileCache[path] = pathToRegexp_1.compile(path));</span><span class="s2">\n\n    </span><span class="s1">// Fix #2505 resolving asterisk routes { name: 'not-found', params: { pathMatch: '/not-found' }}</span><span class="s2">\n    </span><span class="s1">// and fix #3106 so that you can work with location descriptor object having params.pathMatch equal to empty string</span><span class="s2">\n    </span><span class="s1">if (typeof params.pathMatch === 'string') { params[0] = params.pathMatch; }</span><span class="s2">\n\n    </span><span class="s1">return filler(params, { pretty: true })</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">// Fix #3072 no warn if `pathMatch` is string</span><span class="s2">\n      </span><span class="s1">warn(typeof params.pathMatch === 'string', (</span><span class="s2">\&quot;</span><span class="s1">missing param for </span><span class="s2">\&quot; </span><span class="s1">+ routeMsg + </span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot; </span><span class="s1">+ (e.message)));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return ''</span><span class="s2">\n  </span><span class="s1">} finally {</span><span class="s2">\n    </span><span class="s1">// delete the 0 if it was added</span><span class="s2">\n    </span><span class="s1">delete params[0];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">function normalizeLocation (</span><span class="s2">\n  </span><span class="s1">raw,</span><span class="s2">\n  </span><span class="s1">current,</span><span class="s2">\n  </span><span class="s1">append,</span><span class="s2">\n  </span><span class="s1">router</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">var next = typeof raw === 'string' ? { path: raw } : raw;</span><span class="s2">\n  </span><span class="s1">// named target</span><span class="s2">\n  </span><span class="s1">if (next._normalized) {</span><span class="s2">\n    </span><span class="s1">return next</span><span class="s2">\n  </span><span class="s1">} else if (next.name) {</span><span class="s2">\n    </span><span class="s1">next = extend({}, raw);</span><span class="s2">\n    </span><span class="s1">var params = next.params;</span><span class="s2">\n    </span><span class="s1">if (params &amp;&amp; typeof params === 'object') {</span><span class="s2">\n      </span><span class="s1">next.params = extend({}, params);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return next</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// relative params</span><span class="s2">\n  </span><span class="s1">if (!next.path &amp;&amp; next.params &amp;&amp; current) {</span><span class="s2">\n    </span><span class="s1">next = extend({}, next);</span><span class="s2">\n    </span><span class="s1">next._normalized = true;</span><span class="s2">\n    </span><span class="s1">var params$1 = extend(extend({}, current.params), next.params);</span><span class="s2">\n    </span><span class="s1">if (current.name) {</span><span class="s2">\n      </span><span class="s1">next.name = current.name;</span><span class="s2">\n      </span><span class="s1">next.params = params$1;</span><span class="s2">\n    </span><span class="s1">} else if (current.matched.length) {</span><span class="s2">\n      </span><span class="s1">var rawPath = current.matched[current.matched.length - 1].path;</span><span class="s2">\n      </span><span class="s1">next.path = fillParams(rawPath, params$1, (</span><span class="s2">\&quot;</span><span class="s1">path </span><span class="s2">\&quot; </span><span class="s1">+ (current.path)));</span><span class="s2">\n    </span><span class="s1">} else if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">warn(false, </span><span class="s2">\&quot;</span><span class="s1">relative params navigation requires a current route.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return next</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">var parsedPath = parsePath(next.path || '');</span><span class="s2">\n  </span><span class="s1">var basePath = (current &amp;&amp; current.path) || '/';</span><span class="s2">\n  </span><span class="s1">var path = parsedPath.path</span><span class="s2">\n    </span><span class="s1">? resolvePath(parsedPath.path, basePath, append || next.append)</span><span class="s2">\n    </span><span class="s1">: basePath;</span><span class="s2">\n\n  </span><span class="s1">var query = resolveQuery(</span><span class="s2">\n    </span><span class="s1">parsedPath.query,</span><span class="s2">\n    </span><span class="s1">next.query,</span><span class="s2">\n    </span><span class="s1">router &amp;&amp; router.options.parseQuery</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n\n  </span><span class="s1">var hash = next.hash || parsedPath.hash;</span><span class="s2">\n  </span><span class="s1">if (hash &amp;&amp; hash.charAt(0) !== '#') {</span><span class="s2">\n    </span><span class="s1">hash = </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">+ hash;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">_normalized: true,</span><span class="s2">\n    </span><span class="s1">path: path,</span><span class="s2">\n    </span><span class="s1">query: query,</span><span class="s2">\n    </span><span class="s1">hash: hash</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">// work around weird flow bug</span><span class="s2">\n</span><span class="s1">var toTypes = [String, Object];</span><span class="s2">\n</span><span class="s1">var eventTypes = [String, Array];</span><span class="s2">\n\n</span><span class="s1">var noop = function () {};</span><span class="s2">\n\n</span><span class="s1">var warnedCustomSlot;</span><span class="s2">\n</span><span class="s1">var warnedTagProp;</span><span class="s2">\n</span><span class="s1">var warnedEventProp;</span><span class="s2">\n\n</span><span class="s1">var Link = {</span><span class="s2">\n  </span><span class="s1">name: 'RouterLink',</span><span class="s2">\n  </span><span class="s1">props: {</span><span class="s2">\n    </span><span class="s1">to: {</span><span class="s2">\n      </span><span class="s1">type: toTypes,</span><span class="s2">\n      </span><span class="s1">required: true</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">tag: {</span><span class="s2">\n      </span><span class="s1">type: String,</span><span class="s2">\n      </span><span class="s1">default: 'a'</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">custom: Boolean,</span><span class="s2">\n    </span><span class="s1">exact: Boolean,</span><span class="s2">\n    </span><span class="s1">exactPath: Boolean,</span><span class="s2">\n    </span><span class="s1">append: Boolean,</span><span class="s2">\n    </span><span class="s1">replace: Boolean,</span><span class="s2">\n    </span><span class="s1">activeClass: String,</span><span class="s2">\n    </span><span class="s1">exactActiveClass: String,</span><span class="s2">\n    </span><span class="s1">ariaCurrentValue: {</span><span class="s2">\n      </span><span class="s1">type: String,</span><span class="s2">\n      </span><span class="s1">default: 'page'</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">event: {</span><span class="s2">\n      </span><span class="s1">type: eventTypes,</span><span class="s2">\n      </span><span class="s1">default: 'click'</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">render: function render (h) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n\n    </span><span class="s1">var router = this.$router;</span><span class="s2">\n    </span><span class="s1">var current = this.$route;</span><span class="s2">\n    </span><span class="s1">var ref = router.resolve(</span><span class="s2">\n      </span><span class="s1">this.to,</span><span class="s2">\n      </span><span class="s1">current,</span><span class="s2">\n      </span><span class="s1">this.append</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">var location = ref.location;</span><span class="s2">\n    </span><span class="s1">var route = ref.route;</span><span class="s2">\n    </span><span class="s1">var href = ref.href;</span><span class="s2">\n\n    </span><span class="s1">var classes = {};</span><span class="s2">\n    </span><span class="s1">var globalActiveClass = router.options.linkActiveClass;</span><span class="s2">\n    </span><span class="s1">var globalExactActiveClass = router.options.linkExactActiveClass;</span><span class="s2">\n    </span><span class="s1">// Support global empty active class</span><span class="s2">\n    </span><span class="s1">var activeClassFallback =</span><span class="s2">\n      </span><span class="s1">globalActiveClass == null ? 'router-link-active' : globalActiveClass;</span><span class="s2">\n    </span><span class="s1">var exactActiveClassFallback =</span><span class="s2">\n      </span><span class="s1">globalExactActiveClass == null</span><span class="s2">\n        </span><span class="s1">? 'router-link-exact-active'</span><span class="s2">\n        </span><span class="s1">: globalExactActiveClass;</span><span class="s2">\n    </span><span class="s1">var activeClass =</span><span class="s2">\n      </span><span class="s1">this.activeClass == null ? activeClassFallback : this.activeClass;</span><span class="s2">\n    </span><span class="s1">var exactActiveClass =</span><span class="s2">\n      </span><span class="s1">this.exactActiveClass == null</span><span class="s2">\n        </span><span class="s1">? exactActiveClassFallback</span><span class="s2">\n        </span><span class="s1">: this.exactActiveClass;</span><span class="s2">\n\n    </span><span class="s1">var compareTarget = route.redirectedFrom</span><span class="s2">\n      </span><span class="s1">? createRoute(null, normalizeLocation(route.redirectedFrom), null, router)</span><span class="s2">\n      </span><span class="s1">: route;</span><span class="s2">\n\n    </span><span class="s1">classes[exactActiveClass] = isSameRoute(current, compareTarget, this.exactPath);</span><span class="s2">\n    </span><span class="s1">classes[activeClass] = this.exact || this.exactPath</span><span class="s2">\n      </span><span class="s1">? classes[exactActiveClass]</span><span class="s2">\n      </span><span class="s1">: isIncludedRoute(current, compareTarget);</span><span class="s2">\n\n    </span><span class="s1">var ariaCurrentValue = classes[exactActiveClass] ? this.ariaCurrentValue : null;</span><span class="s2">\n\n    </span><span class="s1">var handler = function (e) {</span><span class="s2">\n      </span><span class="s1">if (guardEvent(e)) {</span><span class="s2">\n        </span><span class="s1">if (this$1$1.replace) {</span><span class="s2">\n          </span><span class="s1">router.replace(location, noop);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">router.push(location, noop);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n\n    </span><span class="s1">var on = { click: guardEvent };</span><span class="s2">\n    </span><span class="s1">if (Array.isArray(this.event)) {</span><span class="s2">\n      </span><span class="s1">this.event.forEach(function (e) {</span><span class="s2">\n        </span><span class="s1">on[e] = handler;</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">on[this.event] = handler;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">var data = { class: classes };</span><span class="s2">\n\n    </span><span class="s1">var scopedSlot =</span><span class="s2">\n      </span><span class="s1">!this.$scopedSlots.$hasNormal &amp;&amp;</span><span class="s2">\n      </span><span class="s1">this.$scopedSlots.default &amp;&amp;</span><span class="s2">\n      </span><span class="s1">this.$scopedSlots.default({</span><span class="s2">\n        </span><span class="s1">href: href,</span><span class="s2">\n        </span><span class="s1">route: route,</span><span class="s2">\n        </span><span class="s1">navigate: handler,</span><span class="s2">\n        </span><span class="s1">isActive: classes[activeClass],</span><span class="s2">\n        </span><span class="s1">isExactActive: classes[exactActiveClass]</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n\n    </span><span class="s1">if (scopedSlot) {</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !this.custom) {</span><span class="s2">\n        </span><span class="s1">!warnedCustomSlot &amp;&amp; warn(false, 'In Vue Router 4, the v-slot API will by default wrap its content with an &lt;a&gt; element. Use the custom prop to remove this warning:</span><span class="s2">\\</span><span class="s1">n&lt;router-link v-slot=</span><span class="s2">\&quot;</span><span class="s1">{ navigate, href }</span><span class="s2">\&quot; </span><span class="s1">custom&gt;&lt;/router-link&gt;</span><span class="s2">\\</span><span class="s1">n');</span><span class="s2">\n        </span><span class="s1">warnedCustomSlot = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (scopedSlot.length === 1) {</span><span class="s2">\n        </span><span class="s1">return scopedSlot[0]</span><span class="s2">\n      </span><span class="s1">} else if (scopedSlot.length &gt; 1 || !scopedSlot.length) {</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n          </span><span class="s1">warn(</span><span class="s2">\n            </span><span class="s1">false,</span><span class="s2">\n            </span><span class="s1">(</span><span class="s2">\&quot;</span><span class="s1">&lt;router-link&gt; with to=</span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ (this.to) + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">is trying to use a scoped slot but it didn't provide exactly one child. Wrapping the content with a span element.</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return scopedSlot.length === 0 ? h() : h('span', {}, scopedSlot)</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">if ('tag' in this.$options.propsData &amp;&amp; !warnedTagProp) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\n          </span><span class="s1">false,</span><span class="s2">\n          \&quot;</span><span class="s1">&lt;router-link&gt;'s tag prop is deprecated and has been removed in Vue Router 4. Use the v-slot API to remove this warning: https://next.router.vuejs.org/guide/migration/#removal-of-event-and-tag-props-in-router-link.</span><span class="s2">\&quot;\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">warnedTagProp = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if ('event' in this.$options.propsData &amp;&amp; !warnedEventProp) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\n          </span><span class="s1">false,</span><span class="s2">\n          \&quot;</span><span class="s1">&lt;router-link&gt;'s event prop is deprecated and has been removed in Vue Router 4. Use the v-slot API to remove this warning: https://next.router.vuejs.org/guide/migration/#removal-of-event-and-tag-props-in-router-link.</span><span class="s2">\&quot;\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">warnedEventProp = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (this.tag === 'a') {</span><span class="s2">\n      </span><span class="s1">data.on = on;</span><span class="s2">\n      </span><span class="s1">data.attrs = { href: href, 'aria-current': ariaCurrentValue };</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">// find the first &lt;a&gt; child and apply listener and href</span><span class="s2">\n      </span><span class="s1">var a = findAnchor(this.$slots.default);</span><span class="s2">\n      </span><span class="s1">if (a) {</span><span class="s2">\n        </span><span class="s1">// in case the &lt;a&gt; is a static node</span><span class="s2">\n        </span><span class="s1">a.isStatic = false;</span><span class="s2">\n        </span><span class="s1">var aData = (a.data = extend({}, a.data));</span><span class="s2">\n        </span><span class="s1">aData.on = aData.on || {};</span><span class="s2">\n        </span><span class="s1">// transform existing events in both objects into arrays so we can push later</span><span class="s2">\n        </span><span class="s1">for (var event in aData.on) {</span><span class="s2">\n          </span><span class="s1">var handler$1 = aData.on[event];</span><span class="s2">\n          </span><span class="s1">if (event in on) {</span><span class="s2">\n            </span><span class="s1">aData.on[event] = Array.isArray(handler$1) ? handler$1 : [handler$1];</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// append new listeners for router-link</span><span class="s2">\n        </span><span class="s1">for (var event$1 in on) {</span><span class="s2">\n          </span><span class="s1">if (event$1 in aData.on) {</span><span class="s2">\n            </span><span class="s1">// on[event] is always a function</span><span class="s2">\n            </span><span class="s1">aData.on[event$1].push(on[event$1]);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">aData.on[event$1] = handler;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">var aAttrs = (a.data.attrs = extend({}, a.data.attrs));</span><span class="s2">\n        </span><span class="s1">aAttrs.href = href;</span><span class="s2">\n        </span><span class="s1">aAttrs['aria-current'] = ariaCurrentValue;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">// doesn't have &lt;a&gt; child, apply listener to self</span><span class="s2">\n        </span><span class="s1">data.on = on;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return h(this.tag, data, this.$slots.default)</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">function guardEvent (e) {</span><span class="s2">\n  </span><span class="s1">// don't redirect with control keys</span><span class="s2">\n  </span><span class="s1">if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }</span><span class="s2">\n  </span><span class="s1">// don't redirect when preventDefault called</span><span class="s2">\n  </span><span class="s1">if (e.defaultPrevented) { return }</span><span class="s2">\n  </span><span class="s1">// don't redirect on right click</span><span class="s2">\n  </span><span class="s1">if (e.button !== undefined &amp;&amp; e.button !== 0) { return }</span><span class="s2">\n  </span><span class="s1">// don't redirect if `target=</span><span class="s2">\&quot;</span><span class="s1">_blank</span><span class="s2">\&quot;</span><span class="s1">`</span><span class="s2">\n  </span><span class="s1">if (e.currentTarget &amp;&amp; e.currentTarget.getAttribute) {</span><span class="s2">\n    </span><span class="s1">var target = e.currentTarget.getAttribute('target');</span><span class="s2">\n    </span><span class="s1">if (/</span><span class="s2">\\</span><span class="s1">b_blank</span><span class="s2">\\</span><span class="s1">b/i.test(target)) { return }</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// this may be a Weex event which doesn't have this method</span><span class="s2">\n  </span><span class="s1">if (e.preventDefault) {</span><span class="s2">\n    </span><span class="s1">e.preventDefault();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return true</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function findAnchor (children) {</span><span class="s2">\n  </span><span class="s1">if (children) {</span><span class="s2">\n    </span><span class="s1">var child;</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; children.length; i++) {</span><span class="s2">\n      </span><span class="s1">child = children[i];</span><span class="s2">\n      </span><span class="s1">if (child.tag === 'a') {</span><span class="s2">\n        </span><span class="s1">return child</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (child.children &amp;&amp; (child = findAnchor(child.children))) {</span><span class="s2">\n        </span><span class="s1">return child</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var _Vue;</span><span class="s2">\n\n</span><span class="s1">function install (Vue) {</span><span class="s2">\n  </span><span class="s1">if (install.installed &amp;&amp; _Vue === Vue) { return }</span><span class="s2">\n  </span><span class="s1">install.installed = true;</span><span class="s2">\n\n  </span><span class="s1">_Vue = Vue;</span><span class="s2">\n\n  </span><span class="s1">var isDef = function (v) { return v !== undefined; };</span><span class="s2">\n\n  </span><span class="s1">var registerInstance = function (vm, callVal) {</span><span class="s2">\n    </span><span class="s1">var i = vm.$options._parentVnode;</span><span class="s2">\n    </span><span class="s1">if (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)) {</span><span class="s2">\n      </span><span class="s1">i(vm, callVal);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">Vue.mixin({</span><span class="s2">\n    </span><span class="s1">beforeCreate: function beforeCreate () {</span><span class="s2">\n      </span><span class="s1">if (isDef(this.$options.router)) {</span><span class="s2">\n        </span><span class="s1">this._routerRoot = this;</span><span class="s2">\n        </span><span class="s1">this._router = this.$options.router;</span><span class="s2">\n        </span><span class="s1">this._router.init(this);</span><span class="s2">\n        </span><span class="s1">Vue.util.defineReactive(this, '_route', this._router.history.current);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">registerInstance(this, this);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">destroyed: function destroyed () {</span><span class="s2">\n      </span><span class="s1">registerInstance(this);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n\n  </span><span class="s1">Object.defineProperty(Vue.prototype, '$router', {</span><span class="s2">\n    </span><span class="s1">get: function get () { return this._routerRoot._router }</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n\n  </span><span class="s1">Object.defineProperty(Vue.prototype, '$route', {</span><span class="s2">\n    </span><span class="s1">get: function get () { return this._routerRoot._route }</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n\n  </span><span class="s1">Vue.component('RouterView', View);</span><span class="s2">\n  </span><span class="s1">Vue.component('RouterLink', Link);</span><span class="s2">\n\n  </span><span class="s1">var strats = Vue.config.optionMergeStrategies;</span><span class="s2">\n  </span><span class="s1">// use the same hook merging strategy for route hooks</span><span class="s2">\n  </span><span class="s1">strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var inBrowser = typeof window !== 'undefined';</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">function createRouteMap (</span><span class="s2">\n  </span><span class="s1">routes,</span><span class="s2">\n  </span><span class="s1">oldPathList,</span><span class="s2">\n  </span><span class="s1">oldPathMap,</span><span class="s2">\n  </span><span class="s1">oldNameMap,</span><span class="s2">\n  </span><span class="s1">parentRoute</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">// the path list is used to control path matching priority</span><span class="s2">\n  </span><span class="s1">var pathList = oldPathList || [];</span><span class="s2">\n  </span><span class="s1">// $flow-disable-line</span><span class="s2">\n  </span><span class="s1">var pathMap = oldPathMap || Object.create(null);</span><span class="s2">\n  </span><span class="s1">// $flow-disable-line</span><span class="s2">\n  </span><span class="s1">var nameMap = oldNameMap || Object.create(null);</span><span class="s2">\n\n  </span><span class="s1">routes.forEach(function (route) {</span><span class="s2">\n    </span><span class="s1">addRouteRecord(pathList, pathMap, nameMap, route, parentRoute);</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n\n  </span><span class="s1">// ensure wildcard routes are always at the end</span><span class="s2">\n  </span><span class="s1">for (var i = 0, l = pathList.length; i &lt; l; i++) {</span><span class="s2">\n    </span><span class="s1">if (pathList[i] === '*') {</span><span class="s2">\n      </span><span class="s1">pathList.push(pathList.splice(i, 1)[0]);</span><span class="s2">\n      </span><span class="s1">l--;</span><span class="s2">\n      </span><span class="s1">i--;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s2">\n    </span><span class="s1">// warn if routes do not include leading slashes</span><span class="s2">\n    </span><span class="s1">var found = pathList</span><span class="s2">\n    </span><span class="s1">// check for missing leading slash</span><span class="s2">\n      </span><span class="s1">.filter(function (path) { return path &amp;&amp; path.charAt(0) !== '*' &amp;&amp; path.charAt(0) !== '/'; });</span><span class="s2">\n\n    </span><span class="s1">if (found.length &gt; 0) {</span><span class="s2">\n      </span><span class="s1">var pathNames = found.map(function (path) { return (</span><span class="s2">\&quot;</span><span class="s1">- </span><span class="s2">\&quot; </span><span class="s1">+ path); }).join('</span><span class="s2">\\</span><span class="s1">n');</span><span class="s2">\n      </span><span class="s1">warn(false, (</span><span class="s2">\&quot;</span><span class="s1">Non-nested routes must include a leading slash character. Fix the following routes: </span><span class="s2">\\</span><span class="s1">n</span><span class="s2">\&quot; </span><span class="s1">+ pathNames));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">pathList: pathList,</span><span class="s2">\n    </span><span class="s1">pathMap: pathMap,</span><span class="s2">\n    </span><span class="s1">nameMap: nameMap</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function addRouteRecord (</span><span class="s2">\n  </span><span class="s1">pathList,</span><span class="s2">\n  </span><span class="s1">pathMap,</span><span class="s2">\n  </span><span class="s1">nameMap,</span><span class="s2">\n  </span><span class="s1">route,</span><span class="s2">\n  </span><span class="s1">parent,</span><span class="s2">\n  </span><span class="s1">matchAs</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">var path = route.path;</span><span class="s2">\n  </span><span class="s1">var name = route.name;</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">assert(path != null, </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">path</span><span class="s2">\\\&quot; </span><span class="s1">is required in a route configuration.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">assert(</span><span class="s2">\n      </span><span class="s1">typeof route.component !== 'string',</span><span class="s2">\n      \&quot;</span><span class="s1">route config </span><span class="s2">\\\&quot;</span><span class="s1">component</span><span class="s2">\\\&quot; </span><span class="s1">for path: </span><span class="s2">\&quot; </span><span class="s1">+ (String(</span><span class="s2">\n        </span><span class="s1">path || name</span><span class="s2">\n      </span><span class="s1">)) + </span><span class="s2">\&quot; </span><span class="s1">cannot be a </span><span class="s2">\&quot; </span><span class="s1">+ </span><span class="s2">\&quot;</span><span class="s1">string id. Use an actual component instead.</span><span class="s2">\&quot;\n    </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">warn(</span><span class="s2">\n      </span><span class="s1">// eslint-disable-next-line no-control-regex</span><span class="s2">\n      </span><span class="s1">!/[^</span><span class="s2">\\</span><span class="s1">u0000-</span><span class="s2">\\</span><span class="s1">u007F]+/.test(path),</span><span class="s2">\n      \&quot;</span><span class="s1">Route with path </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ path + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">contains unencoded characters, make sure </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n        \&quot;</span><span class="s1">your path is correctly encoded before passing it to the router. Use </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n        \&quot;</span><span class="s1">encodeURI to encode static segments of your path.</span><span class="s2">\&quot;\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">var pathToRegexpOptions =</span><span class="s2">\n    </span><span class="s1">route.pathToRegexpOptions || {};</span><span class="s2">\n  </span><span class="s1">var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);</span><span class="s2">\n\n  </span><span class="s1">if (typeof route.caseSensitive === 'boolean') {</span><span class="s2">\n    </span><span class="s1">pathToRegexpOptions.sensitive = route.caseSensitive;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">var record = {</span><span class="s2">\n    </span><span class="s1">path: normalizedPath,</span><span class="s2">\n    </span><span class="s1">regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),</span><span class="s2">\n    </span><span class="s1">components: route.components || { default: route.component },</span><span class="s2">\n    </span><span class="s1">alias: route.alias</span><span class="s2">\n      </span><span class="s1">? typeof route.alias === 'string'</span><span class="s2">\n        </span><span class="s1">? [route.alias]</span><span class="s2">\n        </span><span class="s1">: route.alias</span><span class="s2">\n      </span><span class="s1">: [],</span><span class="s2">\n    </span><span class="s1">instances: {},</span><span class="s2">\n    </span><span class="s1">enteredCbs: {},</span><span class="s2">\n    </span><span class="s1">name: name,</span><span class="s2">\n    </span><span class="s1">parent: parent,</span><span class="s2">\n    </span><span class="s1">matchAs: matchAs,</span><span class="s2">\n    </span><span class="s1">redirect: route.redirect,</span><span class="s2">\n    </span><span class="s1">beforeEnter: route.beforeEnter,</span><span class="s2">\n    </span><span class="s1">meta: route.meta || {},</span><span class="s2">\n    </span><span class="s1">props:</span><span class="s2">\n      </span><span class="s1">route.props == null</span><span class="s2">\n        </span><span class="s1">? {}</span><span class="s2">\n        </span><span class="s1">: route.components</span><span class="s2">\n          </span><span class="s1">? route.props</span><span class="s2">\n          </span><span class="s1">: { default: route.props }</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">if (route.children) {</span><span class="s2">\n    </span><span class="s1">// Warn if route is named, does not redirect and has a default child route.</span><span class="s2">\n    </span><span class="s1">// If users navigate to this route by name, the default child will</span><span class="s2">\n    </span><span class="s1">// not be rendered (GH Issue #629)</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">route.name &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!route.redirect &amp;&amp;</span><span class="s2">\n        </span><span class="s1">route.children.some(function (child) { return /^</span><span class="s2">\\</span><span class="s1">/?$/.test(child.path); })</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\n          </span><span class="s1">false,</span><span class="s2">\n          \&quot;</span><span class="s1">Named Route '</span><span class="s2">\&quot; </span><span class="s1">+ (route.name) + </span><span class="s2">\&quot;</span><span class="s1">' has a default child route. </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n            \&quot;</span><span class="s1">When navigating to this named route (:to=</span><span class="s2">\\\&quot;</span><span class="s1">{name: '</span><span class="s2">\&quot; </span><span class="s1">+ (route.name) + </span><span class="s2">\&quot;</span><span class="s1">'}</span><span class="s2">\\\&quot;</span><span class="s1">), </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n            \&quot;</span><span class="s1">the default child route will not be rendered. Remove the name from </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n            \&quot;</span><span class="s1">this route and use the name of the default child route for named </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n            \&quot;</span><span class="s1">links instead.</span><span class="s2">\&quot;\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">route.children.forEach(function (child) {</span><span class="s2">\n      </span><span class="s1">var childMatchAs = matchAs</span><span class="s2">\n        </span><span class="s1">? cleanPath((matchAs + </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">+ (child.path)))</span><span class="s2">\n        </span><span class="s1">: undefined;</span><span class="s2">\n      </span><span class="s1">addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (!pathMap[record.path]) {</span><span class="s2">\n    </span><span class="s1">pathList.push(record.path);</span><span class="s2">\n    </span><span class="s1">pathMap[record.path] = record;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (route.alias !== undefined) {</span><span class="s2">\n    </span><span class="s1">var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];</span><span class="s2">\n    </span><span class="s1">for (var i = 0; i &lt; aliases.length; ++i) {</span><span class="s2">\n      </span><span class="s1">var alias = aliases[i];</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; alias === path) {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\n          </span><span class="s1">false,</span><span class="s2">\n          </span><span class="s1">(</span><span class="s2">\&quot;</span><span class="s1">Found an alias with the same value as the path: </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ path + </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">. You have to remove that alias. It will be ignored in development.</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">// skip in dev to make it work</span><span class="s2">\n        </span><span class="s1">continue</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">var aliasRoute = {</span><span class="s2">\n        </span><span class="s1">path: alias,</span><span class="s2">\n        </span><span class="s1">children: route.children</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">addRouteRecord(</span><span class="s2">\n        </span><span class="s1">pathList,</span><span class="s2">\n        </span><span class="s1">pathMap,</span><span class="s2">\n        </span><span class="s1">nameMap,</span><span class="s2">\n        </span><span class="s1">aliasRoute,</span><span class="s2">\n        </span><span class="s1">parent,</span><span class="s2">\n        </span><span class="s1">record.path || '/' // matchAs</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (name) {</span><span class="s2">\n    </span><span class="s1">if (!nameMap[name]) {</span><span class="s2">\n      </span><span class="s1">nameMap[name] = record;</span><span class="s2">\n    </span><span class="s1">} else if (process.env.NODE_ENV !== 'production' &amp;&amp; !matchAs) {</span><span class="s2">\n      </span><span class="s1">warn(</span><span class="s2">\n        </span><span class="s1">false,</span><span class="s2">\n        \&quot;</span><span class="s1">Duplicate named routes definition: </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n          \&quot;</span><span class="s1">{ name: </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ name + </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">, path: </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ (record.path) + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">}</span><span class="s2">\&quot;\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function compileRouteRegex (</span><span class="s2">\n  </span><span class="s1">path,</span><span class="s2">\n  </span><span class="s1">pathToRegexpOptions</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">var regex = pathToRegexp_1(path, [], pathToRegexpOptions);</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">var keys = Object.create(null);</span><span class="s2">\n    </span><span class="s1">regex.keys.forEach(function (key) {</span><span class="s2">\n      </span><span class="s1">warn(</span><span class="s2">\n        </span><span class="s1">!keys[key.name],</span><span class="s2">\n        </span><span class="s1">(</span><span class="s2">\&quot;</span><span class="s1">Duplicate param keys in route with path: </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ path + </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">)</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">keys[key.name] = true;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return regex</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function normalizePath (</span><span class="s2">\n  </span><span class="s1">path,</span><span class="s2">\n  </span><span class="s1">parent,</span><span class="s2">\n  </span><span class="s1">strict</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">if (!strict) { path = path.replace(/</span><span class="s2">\\</span><span class="s1">/$/, ''); }</span><span class="s2">\n  </span><span class="s1">if (path[0] === '/') { return path }</span><span class="s2">\n  </span><span class="s1">if (parent == null) { return path }</span><span class="s2">\n  </span><span class="s1">return cleanPath(((parent.path) + </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">+ path))</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n\n\n</span><span class="s1">function createMatcher (</span><span class="s2">\n  </span><span class="s1">routes,</span><span class="s2">\n  </span><span class="s1">router</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">var ref = createRouteMap(routes);</span><span class="s2">\n  </span><span class="s1">var pathList = ref.pathList;</span><span class="s2">\n  </span><span class="s1">var pathMap = ref.pathMap;</span><span class="s2">\n  </span><span class="s1">var nameMap = ref.nameMap;</span><span class="s2">\n\n  </span><span class="s1">function addRoutes (routes) {</span><span class="s2">\n    </span><span class="s1">createRouteMap(routes, pathList, pathMap, nameMap);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">function addRoute (parentOrRoute, route) {</span><span class="s2">\n    </span><span class="s1">var parent = (typeof parentOrRoute !== 'object') ? nameMap[parentOrRoute] : undefined;</span><span class="s2">\n    </span><span class="s1">// $flow-disable-line</span><span class="s2">\n    </span><span class="s1">createRouteMap([route || parentOrRoute], pathList, pathMap, nameMap, parent);</span><span class="s2">\n\n    </span><span class="s1">// add aliases of parent</span><span class="s2">\n    </span><span class="s1">if (parent &amp;&amp; parent.alias.length) {</span><span class="s2">\n      </span><span class="s1">createRouteMap(</span><span class="s2">\n        </span><span class="s1">// $flow-disable-line route is defined if parent is</span><span class="s2">\n        </span><span class="s1">parent.alias.map(function (alias) { return ({ path: alias, children: [route] }); }),</span><span class="s2">\n        </span><span class="s1">pathList,</span><span class="s2">\n        </span><span class="s1">pathMap,</span><span class="s2">\n        </span><span class="s1">nameMap,</span><span class="s2">\n        </span><span class="s1">parent</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">function getRoutes () {</span><span class="s2">\n    </span><span class="s1">return pathList.map(function (path) { return pathMap[path]; })</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">function match (</span><span class="s2">\n    </span><span class="s1">raw,</span><span class="s2">\n    </span><span class="s1">currentRoute,</span><span class="s2">\n    </span><span class="s1">redirectedFrom</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">var location = normalizeLocation(raw, currentRoute, false, router);</span><span class="s2">\n    </span><span class="s1">var name = location.name;</span><span class="s2">\n\n    </span><span class="s1">if (name) {</span><span class="s2">\n      </span><span class="s1">var record = nameMap[name];</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">warn(record, (</span><span class="s2">\&quot;</span><span class="s1">Route with name '</span><span class="s2">\&quot; </span><span class="s1">+ name + </span><span class="s2">\&quot;</span><span class="s1">' does not exist</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (!record) { return _createRoute(null, location) }</span><span class="s2">\n      </span><span class="s1">var paramNames = record.regex.keys</span><span class="s2">\n        </span><span class="s1">.filter(function (key) { return !key.optional; })</span><span class="s2">\n        </span><span class="s1">.map(function (key) { return key.name; });</span><span class="s2">\n\n      </span><span class="s1">if (typeof location.params !== 'object') {</span><span class="s2">\n        </span><span class="s1">location.params = {};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (currentRoute &amp;&amp; typeof currentRoute.params === 'object') {</span><span class="s2">\n        </span><span class="s1">for (var key in currentRoute.params) {</span><span class="s2">\n          </span><span class="s1">if (!(key in location.params) &amp;&amp; paramNames.indexOf(key) &gt; -1) {</span><span class="s2">\n            </span><span class="s1">location.params[key] = currentRoute.params[key];</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">location.path = fillParams(record.path, location.params, (</span><span class="s2">\&quot;</span><span class="s1">named route </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ name + </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">));</span><span class="s2">\n      </span><span class="s1">return _createRoute(record, location, redirectedFrom)</span><span class="s2">\n    </span><span class="s1">} else if (location.path) {</span><span class="s2">\n      </span><span class="s1">location.params = {};</span><span class="s2">\n      </span><span class="s1">for (var i = 0; i &lt; pathList.length; i++) {</span><span class="s2">\n        </span><span class="s1">var path = pathList[i];</span><span class="s2">\n        </span><span class="s1">var record$1 = pathMap[path];</span><span class="s2">\n        </span><span class="s1">if (matchRoute(record$1.regex, location.path, location.params)) {</span><span class="s2">\n          </span><span class="s1">return _createRoute(record$1, location, redirectedFrom)</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// no match</span><span class="s2">\n    </span><span class="s1">return _createRoute(null, location)</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">function redirect (</span><span class="s2">\n    </span><span class="s1">record,</span><span class="s2">\n    </span><span class="s1">location</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">var originalRedirect = record.redirect;</span><span class="s2">\n    </span><span class="s1">var redirect = typeof originalRedirect === 'function'</span><span class="s2">\n      </span><span class="s1">? originalRedirect(createRoute(record, location, null, router))</span><span class="s2">\n      </span><span class="s1">: originalRedirect;</span><span class="s2">\n\n    </span><span class="s1">if (typeof redirect === 'string') {</span><span class="s2">\n      </span><span class="s1">redirect = { path: redirect };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (!redirect || typeof redirect !== 'object') {</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">warn(</span><span class="s2">\n          </span><span class="s1">false, (</span><span class="s2">\&quot;</span><span class="s1">invalid redirect option: </span><span class="s2">\&quot; </span><span class="s1">+ (JSON.stringify(redirect)))</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return _createRoute(null, location)</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">var re = redirect;</span><span class="s2">\n    </span><span class="s1">var name = re.name;</span><span class="s2">\n    </span><span class="s1">var path = re.path;</span><span class="s2">\n    </span><span class="s1">var query = location.query;</span><span class="s2">\n    </span><span class="s1">var hash = location.hash;</span><span class="s2">\n    </span><span class="s1">var params = location.params;</span><span class="s2">\n    </span><span class="s1">query = re.hasOwnProperty('query') ? re.query : query;</span><span class="s2">\n    </span><span class="s1">hash = re.hasOwnProperty('hash') ? re.hash : hash;</span><span class="s2">\n    </span><span class="s1">params = re.hasOwnProperty('params') ? re.params : params;</span><span class="s2">\n\n    </span><span class="s1">if (name) {</span><span class="s2">\n      </span><span class="s1">// resolved named direct</span><span class="s2">\n      </span><span class="s1">var targetRecord = nameMap[name];</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">assert(targetRecord, (</span><span class="s2">\&quot;</span><span class="s1">redirect failed: named route </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ name + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">not found.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return match({</span><span class="s2">\n        </span><span class="s1">_normalized: true,</span><span class="s2">\n        </span><span class="s1">name: name,</span><span class="s2">\n        </span><span class="s1">query: query,</span><span class="s2">\n        </span><span class="s1">hash: hash,</span><span class="s2">\n        </span><span class="s1">params: params</span><span class="s2">\n      </span><span class="s1">}, undefined, location)</span><span class="s2">\n    </span><span class="s1">} else if (path) {</span><span class="s2">\n      </span><span class="s1">// 1. resolve relative redirect</span><span class="s2">\n      </span><span class="s1">var rawPath = resolveRecordPath(path, record);</span><span class="s2">\n      </span><span class="s1">// 2. resolve params</span><span class="s2">\n      </span><span class="s1">var resolvedPath = fillParams(rawPath, params, (</span><span class="s2">\&quot;</span><span class="s1">redirect route with path </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ rawPath + </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">));</span><span class="s2">\n      </span><span class="s1">// 3. rematch with existing query and hash</span><span class="s2">\n      </span><span class="s1">return match({</span><span class="s2">\n        </span><span class="s1">_normalized: true,</span><span class="s2">\n        </span><span class="s1">path: resolvedPath,</span><span class="s2">\n        </span><span class="s1">query: query,</span><span class="s2">\n        </span><span class="s1">hash: hash</span><span class="s2">\n      </span><span class="s1">}, undefined, location)</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">warn(false, (</span><span class="s2">\&quot;</span><span class="s1">invalid redirect option: </span><span class="s2">\&quot; </span><span class="s1">+ (JSON.stringify(redirect))));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return _createRoute(null, location)</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">function alias (</span><span class="s2">\n    </span><span class="s1">record,</span><span class="s2">\n    </span><span class="s1">location,</span><span class="s2">\n    </span><span class="s1">matchAs</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">var aliasedPath = fillParams(matchAs, location.params, (</span><span class="s2">\&quot;</span><span class="s1">aliased route with path </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ matchAs + </span><span class="s2">\&quot;\\\&quot;\&quot;</span><span class="s1">));</span><span class="s2">\n    </span><span class="s1">var aliasedMatch = match({</span><span class="s2">\n      </span><span class="s1">_normalized: true,</span><span class="s2">\n      </span><span class="s1">path: aliasedPath</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (aliasedMatch) {</span><span class="s2">\n      </span><span class="s1">var matched = aliasedMatch.matched;</span><span class="s2">\n      </span><span class="s1">var aliasedRecord = matched[matched.length - 1];</span><span class="s2">\n      </span><span class="s1">location.params = aliasedMatch.params;</span><span class="s2">\n      </span><span class="s1">return _createRoute(aliasedRecord, location)</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return _createRoute(null, location)</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">function _createRoute (</span><span class="s2">\n    </span><span class="s1">record,</span><span class="s2">\n    </span><span class="s1">location,</span><span class="s2">\n    </span><span class="s1">redirectedFrom</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">if (record &amp;&amp; record.redirect) {</span><span class="s2">\n      </span><span class="s1">return redirect(record, redirectedFrom || location)</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (record &amp;&amp; record.matchAs) {</span><span class="s2">\n      </span><span class="s1">return alias(record, location, record.matchAs)</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return createRoute(record, location, redirectedFrom, router)</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">match: match,</span><span class="s2">\n    </span><span class="s1">addRoute: addRoute,</span><span class="s2">\n    </span><span class="s1">getRoutes: getRoutes,</span><span class="s2">\n    </span><span class="s1">addRoutes: addRoutes</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function matchRoute (</span><span class="s2">\n  </span><span class="s1">regex,</span><span class="s2">\n  </span><span class="s1">path,</span><span class="s2">\n  </span><span class="s1">params</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">var m = path.match(regex);</span><span class="s2">\n\n  </span><span class="s1">if (!m) {</span><span class="s2">\n    </span><span class="s1">return false</span><span class="s2">\n  </span><span class="s1">} else if (!params) {</span><span class="s2">\n    </span><span class="s1">return true</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">for (var i = 1, len = m.length; i &lt; len; ++i) {</span><span class="s2">\n    </span><span class="s1">var key = regex.keys[i - 1];</span><span class="s2">\n    </span><span class="s1">if (key) {</span><span class="s2">\n      </span><span class="s1">// Fix #1994: using * with props: true generates a param named 0</span><span class="s2">\n      </span><span class="s1">params[key.name || 'pathMatch'] = typeof m[i] === 'string' ? decode(m[i]) : m[i];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return true</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function resolveRecordPath (path, record) {</span><span class="s2">\n  </span><span class="s1">return resolvePath(path, record.parent ? record.parent.path : '/', true)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">// use User Timing api (if present) for more accurate key precision</span><span class="s2">\n</span><span class="s1">var Time =</span><span class="s2">\n  </span><span class="s1">inBrowser &amp;&amp; window.performance &amp;&amp; window.performance.now</span><span class="s2">\n    </span><span class="s1">? window.performance</span><span class="s2">\n    </span><span class="s1">: Date;</span><span class="s2">\n\n</span><span class="s1">function genStateKey () {</span><span class="s2">\n  </span><span class="s1">return Time.now().toFixed(3)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var _key = genStateKey();</span><span class="s2">\n\n</span><span class="s1">function getStateKey () {</span><span class="s2">\n  </span><span class="s1">return _key</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function setStateKey (key) {</span><span class="s2">\n  </span><span class="s1">return (_key = key)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var positionStore = Object.create(null);</span><span class="s2">\n\n</span><span class="s1">function setupScroll () {</span><span class="s2">\n  </span><span class="s1">// Prevent browser scroll behavior on History popstate</span><span class="s2">\n  </span><span class="s1">if ('scrollRestoration' in window.history) {</span><span class="s2">\n    </span><span class="s1">window.history.scrollRestoration = 'manual';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// Fix for #1585 for Firefox</span><span class="s2">\n  </span><span class="s1">// Fix for #2195 Add optional third attribute to workaround a bug in safari https://bugs.webkit.org/show_bug.cgi?id=182678</span><span class="s2">\n  </span><span class="s1">// Fix for #2774 Support for apps loaded from Windows file shares not mapped to network drives: replaced location.origin with</span><span class="s2">\n  </span><span class="s1">// window.location.protocol + '//' + window.location.host</span><span class="s2">\n  </span><span class="s1">// location.host contains the port and location.hostname doesn't</span><span class="s2">\n  </span><span class="s1">var protocolAndPath = window.location.protocol + '//' + window.location.host;</span><span class="s2">\n  </span><span class="s1">var absolutePath = window.location.href.replace(protocolAndPath, '');</span><span class="s2">\n  </span><span class="s1">// preserve existing history state as it could be overriden by the user</span><span class="s2">\n  </span><span class="s1">var stateCopy = extend({}, window.history.state);</span><span class="s2">\n  </span><span class="s1">stateCopy.key = getStateKey();</span><span class="s2">\n  </span><span class="s1">window.history.replaceState(stateCopy, '', absolutePath);</span><span class="s2">\n  </span><span class="s1">window.addEventListener('popstate', handlePopState);</span><span class="s2">\n  </span><span class="s1">return function () {</span><span class="s2">\n    </span><span class="s1">window.removeEventListener('popstate', handlePopState);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function handleScroll (</span><span class="s2">\n  </span><span class="s1">router,</span><span class="s2">\n  </span><span class="s1">to,</span><span class="s2">\n  </span><span class="s1">from,</span><span class="s2">\n  </span><span class="s1">isPop</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">if (!router.app) {</span><span class="s2">\n    </span><span class="s1">return</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">var behavior = router.options.scrollBehavior;</span><span class="s2">\n  </span><span class="s1">if (!behavior) {</span><span class="s2">\n    </span><span class="s1">return</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">assert(typeof behavior === 'function', </span><span class="s2">\&quot;</span><span class="s1">scrollBehavior must be a function</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// wait until re-render finishes before scrolling</span><span class="s2">\n  </span><span class="s1">router.app.$nextTick(function () {</span><span class="s2">\n    </span><span class="s1">var position = getScrollPosition();</span><span class="s2">\n    </span><span class="s1">var shouldScroll = behavior.call(</span><span class="s2">\n      </span><span class="s1">router,</span><span class="s2">\n      </span><span class="s1">to,</span><span class="s2">\n      </span><span class="s1">from,</span><span class="s2">\n      </span><span class="s1">isPop ? position : null</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">if (!shouldScroll) {</span><span class="s2">\n      </span><span class="s1">return</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (typeof shouldScroll.then === 'function') {</span><span class="s2">\n      </span><span class="s1">shouldScroll</span><span class="s2">\n        </span><span class="s1">.then(function (shouldScroll) {</span><span class="s2">\n          </span><span class="s1">scrollToPosition((shouldScroll), position);</span><span class="s2">\n        </span><span class="s1">})</span><span class="s2">\n        </span><span class="s1">.catch(function (err) {</span><span class="s2">\n          </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n            </span><span class="s1">assert(false, err.toString());</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">scrollToPosition(shouldScroll, position);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function saveScrollPosition () {</span><span class="s2">\n  </span><span class="s1">var key = getStateKey();</span><span class="s2">\n  </span><span class="s1">if (key) {</span><span class="s2">\n    </span><span class="s1">positionStore[key] = {</span><span class="s2">\n      </span><span class="s1">x: window.pageXOffset,</span><span class="s2">\n      </span><span class="s1">y: window.pageYOffset</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function handlePopState (e) {</span><span class="s2">\n  </span><span class="s1">saveScrollPosition();</span><span class="s2">\n  </span><span class="s1">if (e.state &amp;&amp; e.state.key) {</span><span class="s2">\n    </span><span class="s1">setStateKey(e.state.key);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function getScrollPosition () {</span><span class="s2">\n  </span><span class="s1">var key = getStateKey();</span><span class="s2">\n  </span><span class="s1">if (key) {</span><span class="s2">\n    </span><span class="s1">return positionStore[key]</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function getElementPosition (el, offset) {</span><span class="s2">\n  </span><span class="s1">var docEl = document.documentElement;</span><span class="s2">\n  </span><span class="s1">var docRect = docEl.getBoundingClientRect();</span><span class="s2">\n  </span><span class="s1">var elRect = el.getBoundingClientRect();</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">x: elRect.left - docRect.left - offset.x,</span><span class="s2">\n    </span><span class="s1">y: elRect.top - docRect.top - offset.y</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function isValidPosition (obj) {</span><span class="s2">\n  </span><span class="s1">return isNumber(obj.x) || isNumber(obj.y)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function normalizePosition (obj) {</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">x: isNumber(obj.x) ? obj.x : window.pageXOffset,</span><span class="s2">\n    </span><span class="s1">y: isNumber(obj.y) ? obj.y : window.pageYOffset</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function normalizeOffset (obj) {</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">x: isNumber(obj.x) ? obj.x : 0,</span><span class="s2">\n    </span><span class="s1">y: isNumber(obj.y) ? obj.y : 0</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function isNumber (v) {</span><span class="s2">\n  </span><span class="s1">return typeof v === 'number'</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var hashStartsWithNumberRE = /^#</span><span class="s2">\\</span><span class="s1">d/;</span><span class="s2">\n\n</span><span class="s1">function scrollToPosition (shouldScroll, position) {</span><span class="s2">\n  </span><span class="s1">var isObject = typeof shouldScroll === 'object';</span><span class="s2">\n  </span><span class="s1">if (isObject &amp;&amp; typeof shouldScroll.selector === 'string') {</span><span class="s2">\n    </span><span class="s1">// getElementById would still fail if the selector contains a more complicated query like #main[data-attr]</span><span class="s2">\n    </span><span class="s1">// but at the same time, it doesn't make much sense to select an element with an id and an extra selector</span><span class="s2">\n    </span><span class="s1">var el = hashStartsWithNumberRE.test(shouldScroll.selector) // $flow-disable-line</span><span class="s2">\n      </span><span class="s1">? document.getElementById(shouldScroll.selector.slice(1)) // $flow-disable-line</span><span class="s2">\n      </span><span class="s1">: document.querySelector(shouldScroll.selector);</span><span class="s2">\n\n    </span><span class="s1">if (el) {</span><span class="s2">\n      </span><span class="s1">var offset =</span><span class="s2">\n        </span><span class="s1">shouldScroll.offset &amp;&amp; typeof shouldScroll.offset === 'object'</span><span class="s2">\n          </span><span class="s1">? shouldScroll.offset</span><span class="s2">\n          </span><span class="s1">: {};</span><span class="s2">\n      </span><span class="s1">offset = normalizeOffset(offset);</span><span class="s2">\n      </span><span class="s1">position = getElementPosition(el, offset);</span><span class="s2">\n    </span><span class="s1">} else if (isValidPosition(shouldScroll)) {</span><span class="s2">\n      </span><span class="s1">position = normalizePosition(shouldScroll);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (isObject &amp;&amp; isValidPosition(shouldScroll)) {</span><span class="s2">\n    </span><span class="s1">position = normalizePosition(shouldScroll);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (position) {</span><span class="s2">\n    </span><span class="s1">// $flow-disable-line</span><span class="s2">\n    </span><span class="s1">if ('scrollBehavior' in document.documentElement.style) {</span><span class="s2">\n      </span><span class="s1">window.scrollTo({</span><span class="s2">\n        </span><span class="s1">left: position.x,</span><span class="s2">\n        </span><span class="s1">top: position.y,</span><span class="s2">\n        </span><span class="s1">// $flow-disable-line</span><span class="s2">\n        </span><span class="s1">behavior: shouldScroll.behavior</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">window.scrollTo(position.x, position.y);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var supportsPushState =</span><span class="s2">\n  </span><span class="s1">inBrowser &amp;&amp;</span><span class="s2">\n  </span><span class="s1">(function () {</span><span class="s2">\n    </span><span class="s1">var ua = window.navigator.userAgent;</span><span class="s2">\n\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">(ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &amp;&amp;</span><span class="s2">\n      </span><span class="s1">ua.indexOf('Mobile Safari') !== -1 &amp;&amp;</span><span class="s2">\n      </span><span class="s1">ua.indexOf('Chrome') === -1 &amp;&amp;</span><span class="s2">\n      </span><span class="s1">ua.indexOf('Windows Phone') === -1</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return false</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return window.history &amp;&amp; typeof window.history.pushState === 'function'</span><span class="s2">\n  </span><span class="s1">})();</span><span class="s2">\n\n</span><span class="s1">function pushState (url, replace) {</span><span class="s2">\n  </span><span class="s1">saveScrollPosition();</span><span class="s2">\n  </span><span class="s1">// try...catch the pushState call to get around Safari</span><span class="s2">\n  </span><span class="s1">// DOM Exception 18 where it limits to 100 pushState calls</span><span class="s2">\n  </span><span class="s1">var history = window.history;</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">if (replace) {</span><span class="s2">\n      </span><span class="s1">// preserve existing history state as it could be overriden by the user</span><span class="s2">\n      </span><span class="s1">var stateCopy = extend({}, history.state);</span><span class="s2">\n      </span><span class="s1">stateCopy.key = getStateKey();</span><span class="s2">\n      </span><span class="s1">history.replaceState(stateCopy, '', url);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">history.pushState({ key: setStateKey(genStateKey()) }, '', url);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">window.location[replace ? 'replace' : 'assign'](url);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function replaceState (url) {</span><span class="s2">\n  </span><span class="s1">pushState(url, true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// When changing thing, also edit router.d.ts</span><span class="s2">\n</span><span class="s1">var NavigationFailureType = {</span><span class="s2">\n  </span><span class="s1">redirected: 2,</span><span class="s2">\n  </span><span class="s1">aborted: 4,</span><span class="s2">\n  </span><span class="s1">cancelled: 8,</span><span class="s2">\n  </span><span class="s1">duplicated: 16</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">function createNavigationRedirectedError (from, to) {</span><span class="s2">\n  </span><span class="s1">return createRouterError(</span><span class="s2">\n    </span><span class="s1">from,</span><span class="s2">\n    </span><span class="s1">to,</span><span class="s2">\n    </span><span class="s1">NavigationFailureType.redirected,</span><span class="s2">\n    </span><span class="s1">(</span><span class="s2">\&quot;</span><span class="s1">Redirected when going from </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ (from.fullPath) + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">to </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ (stringifyRoute(</span><span class="s2">\n      </span><span class="s1">to</span><span class="s2">\n    </span><span class="s1">)) + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">via a navigation guard.</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function createNavigationDuplicatedError (from, to) {</span><span class="s2">\n  </span><span class="s1">var error = createRouterError(</span><span class="s2">\n    </span><span class="s1">from,</span><span class="s2">\n    </span><span class="s1">to,</span><span class="s2">\n    </span><span class="s1">NavigationFailureType.duplicated,</span><span class="s2">\n    </span><span class="s1">(</span><span class="s2">\&quot;</span><span class="s1">Avoided redundant navigation to current location: </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ (from.fullPath) + </span><span class="s2">\&quot;\\\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">// backwards compatible with the first introduction of Errors</span><span class="s2">\n  </span><span class="s1">error.name = 'NavigationDuplicated';</span><span class="s2">\n  </span><span class="s1">return error</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function createNavigationCancelledError (from, to) {</span><span class="s2">\n  </span><span class="s1">return createRouterError(</span><span class="s2">\n    </span><span class="s1">from,</span><span class="s2">\n    </span><span class="s1">to,</span><span class="s2">\n    </span><span class="s1">NavigationFailureType.cancelled,</span><span class="s2">\n    </span><span class="s1">(</span><span class="s2">\&quot;</span><span class="s1">Navigation cancelled from </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ (from.fullPath) + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">to </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ (to.fullPath) + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">with a new navigation.</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function createNavigationAbortedError (from, to) {</span><span class="s2">\n  </span><span class="s1">return createRouterError(</span><span class="s2">\n    </span><span class="s1">from,</span><span class="s2">\n    </span><span class="s1">to,</span><span class="s2">\n    </span><span class="s1">NavigationFailureType.aborted,</span><span class="s2">\n    </span><span class="s1">(</span><span class="s2">\&quot;</span><span class="s1">Navigation aborted from </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ (from.fullPath) + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">to </span><span class="s2">\\\&quot;\&quot; </span><span class="s1">+ (to.fullPath) + </span><span class="s2">\&quot;\\\&quot; </span><span class="s1">via a navigation guard.</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function createRouterError (from, to, type, message) {</span><span class="s2">\n  </span><span class="s1">var error = new Error(message);</span><span class="s2">\n  </span><span class="s1">error._isRouter = true;</span><span class="s2">\n  </span><span class="s1">error.from = from;</span><span class="s2">\n  </span><span class="s1">error.to = to;</span><span class="s2">\n  </span><span class="s1">error.type = type;</span><span class="s2">\n\n  </span><span class="s1">return error</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var propertiesToLog = ['params', 'query', 'hash'];</span><span class="s2">\n\n</span><span class="s1">function stringifyRoute (to) {</span><span class="s2">\n  </span><span class="s1">if (typeof to === 'string') { return to }</span><span class="s2">\n  </span><span class="s1">if ('path' in to) { return to.path }</span><span class="s2">\n  </span><span class="s1">var location = {};</span><span class="s2">\n  </span><span class="s1">propertiesToLog.forEach(function (key) {</span><span class="s2">\n    </span><span class="s1">if (key in to) { location[key] = to[key]; }</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return JSON.stringify(location, null, 2)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function isError (err) {</span><span class="s2">\n  </span><span class="s1">return Object.prototype.toString.call(err).indexOf('Error') &gt; -1</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function isNavigationFailure (err, errorType) {</span><span class="s2">\n  </span><span class="s1">return (</span><span class="s2">\n    </span><span class="s1">isError(err) &amp;&amp;</span><span class="s2">\n    </span><span class="s1">err._isRouter &amp;&amp;</span><span class="s2">\n    </span><span class="s1">(errorType == null || err.type === errorType)</span><span class="s2">\n  </span><span class="s1">)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">function runQueue (queue, fn, cb) {</span><span class="s2">\n  </span><span class="s1">var step = function (index) {</span><span class="s2">\n    </span><span class="s1">if (index &gt;= queue.length) {</span><span class="s2">\n      </span><span class="s1">cb();</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">if (queue[index]) {</span><span class="s2">\n        </span><span class="s1">fn(queue[index], function () {</span><span class="s2">\n          </span><span class="s1">step(index + 1);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">step(index + 1);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">step(0);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">function resolveAsyncComponents (matched) {</span><span class="s2">\n  </span><span class="s1">return function (to, from, next) {</span><span class="s2">\n    </span><span class="s1">var hasAsync = false;</span><span class="s2">\n    </span><span class="s1">var pending = 0;</span><span class="s2">\n    </span><span class="s1">var error = null;</span><span class="s2">\n\n    </span><span class="s1">flatMapComponents(matched, function (def, _, match, key) {</span><span class="s2">\n      </span><span class="s1">// if it's a function and doesn't have cid attached,</span><span class="s2">\n      </span><span class="s1">// assume it's an async component resolve function.</span><span class="s2">\n      </span><span class="s1">// we are not using Vue's default async resolving mechanism because</span><span class="s2">\n      </span><span class="s1">// we want to halt the navigation until the incoming component has been</span><span class="s2">\n      </span><span class="s1">// resolved.</span><span class="s2">\n      </span><span class="s1">if (typeof def === 'function' &amp;&amp; def.cid === undefined) {</span><span class="s2">\n        </span><span class="s1">hasAsync = true;</span><span class="s2">\n        </span><span class="s1">pending++;</span><span class="s2">\n\n        </span><span class="s1">var resolve = once(function (resolvedDef) {</span><span class="s2">\n          </span><span class="s1">if (isESModule(resolvedDef)) {</span><span class="s2">\n            </span><span class="s1">resolvedDef = resolvedDef.default;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">// save resolved on async factory in case it's used elsewhere</span><span class="s2">\n          </span><span class="s1">def.resolved = typeof resolvedDef === 'function'</span><span class="s2">\n            </span><span class="s1">? resolvedDef</span><span class="s2">\n            </span><span class="s1">: _Vue.extend(resolvedDef);</span><span class="s2">\n          </span><span class="s1">match.components[key] = resolvedDef;</span><span class="s2">\n          </span><span class="s1">pending--;</span><span class="s2">\n          </span><span class="s1">if (pending &lt;= 0) {</span><span class="s2">\n            </span><span class="s1">next();</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n\n        </span><span class="s1">var reject = once(function (reason) {</span><span class="s2">\n          </span><span class="s1">var msg = </span><span class="s2">\&quot;</span><span class="s1">Failed to resolve async component </span><span class="s2">\&quot; </span><span class="s1">+ key + </span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot; </span><span class="s1">+ reason;</span><span class="s2">\n          </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp; warn(false, msg);</span><span class="s2">\n          </span><span class="s1">if (!error) {</span><span class="s2">\n            </span><span class="s1">error = isError(reason)</span><span class="s2">\n              </span><span class="s1">? reason</span><span class="s2">\n              </span><span class="s1">: new Error(msg);</span><span class="s2">\n            </span><span class="s1">next(error);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n\n        </span><span class="s1">var res;</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n          </span><span class="s1">res = def(resolve, reject);</span><span class="s2">\n        </span><span class="s1">} catch (e) {</span><span class="s2">\n          </span><span class="s1">reject(e);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (res) {</span><span class="s2">\n          </span><span class="s1">if (typeof res.then === 'function') {</span><span class="s2">\n            </span><span class="s1">res.then(resolve, reject);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">// new syntax in Vue 2.3</span><span class="s2">\n            </span><span class="s1">var comp = res.component;</span><span class="s2">\n            </span><span class="s1">if (comp &amp;&amp; typeof comp.then === 'function') {</span><span class="s2">\n              </span><span class="s1">comp.then(resolve, reject);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n\n    </span><span class="s1">if (!hasAsync) { next(); }</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function flatMapComponents (</span><span class="s2">\n  </span><span class="s1">matched,</span><span class="s2">\n  </span><span class="s1">fn</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">return flatten(matched.map(function (m) {</span><span class="s2">\n    </span><span class="s1">return Object.keys(m.components).map(function (key) { return fn(</span><span class="s2">\n      </span><span class="s1">m.components[key],</span><span class="s2">\n      </span><span class="s1">m.instances[key],</span><span class="s2">\n      </span><span class="s1">m, key</span><span class="s2">\n    </span><span class="s1">); })</span><span class="s2">\n  </span><span class="s1">}))</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function flatten (arr) {</span><span class="s2">\n  </span><span class="s1">return Array.prototype.concat.apply([], arr)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var hasSymbol =</span><span class="s2">\n  </span><span class="s1">typeof Symbol === 'function' &amp;&amp;</span><span class="s2">\n  </span><span class="s1">typeof Symbol.toStringTag === 'symbol';</span><span class="s2">\n\n</span><span class="s1">function isESModule (obj) {</span><span class="s2">\n  </span><span class="s1">return obj.__esModule || (hasSymbol &amp;&amp; obj[Symbol.toStringTag] === 'Module')</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// in Webpack 2, require.ensure now also returns a Promise</span><span class="s2">\n</span><span class="s1">// so the resolve/reject functions may get called an extra time</span><span class="s2">\n</span><span class="s1">// if the user uses an arrow function shorthand that happens to</span><span class="s2">\n</span><span class="s1">// return that Promise.</span><span class="s2">\n</span><span class="s1">function once (fn) {</span><span class="s2">\n  </span><span class="s1">var called = false;</span><span class="s2">\n  </span><span class="s1">return function () {</span><span class="s2">\n    </span><span class="s1">var args = [], len = arguments.length;</span><span class="s2">\n    </span><span class="s1">while ( len-- ) args[ len ] = arguments[ len ];</span><span class="s2">\n\n    </span><span class="s1">if (called) { return }</span><span class="s2">\n    </span><span class="s1">called = true;</span><span class="s2">\n    </span><span class="s1">return fn.apply(this, args)</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var History = function History (router, base) {</span><span class="s2">\n  </span><span class="s1">this.router = router;</span><span class="s2">\n  </span><span class="s1">this.base = normalizeBase(base);</span><span class="s2">\n  </span><span class="s1">// start with a route object that stands for </span><span class="s2">\&quot;</span><span class="s1">nowhere</span><span class="s2">\&quot;\n  </span><span class="s1">this.current = START;</span><span class="s2">\n  </span><span class="s1">this.pending = null;</span><span class="s2">\n  </span><span class="s1">this.ready = false;</span><span class="s2">\n  </span><span class="s1">this.readyCbs = [];</span><span class="s2">\n  </span><span class="s1">this.readyErrorCbs = [];</span><span class="s2">\n  </span><span class="s1">this.errorCbs = [];</span><span class="s2">\n  </span><span class="s1">this.listeners = [];</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">History.prototype.listen = function listen (cb) {</span><span class="s2">\n  </span><span class="s1">this.cb = cb;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">History.prototype.onReady = function onReady (cb, errorCb) {</span><span class="s2">\n  </span><span class="s1">if (this.ready) {</span><span class="s2">\n    </span><span class="s1">cb();</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">this.readyCbs.push(cb);</span><span class="s2">\n    </span><span class="s1">if (errorCb) {</span><span class="s2">\n      </span><span class="s1">this.readyErrorCbs.push(errorCb);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">History.prototype.onError = function onError (errorCb) {</span><span class="s2">\n  </span><span class="s1">this.errorCbs.push(errorCb);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">History.prototype.transitionTo = function transitionTo (</span><span class="s2">\n  </span><span class="s1">location,</span><span class="s2">\n  </span><span class="s1">onComplete,</span><span class="s2">\n  </span><span class="s1">onAbort</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n\n  </span><span class="s1">var route;</span><span class="s2">\n  </span><span class="s1">// catch redirect option https://github.com/vuejs/vue-router/issues/3201</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">route = this.router.match(location, this.current);</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">this.errorCbs.forEach(function (cb) {</span><span class="s2">\n      </span><span class="s1">cb(e);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">// Exception should still be thrown</span><span class="s2">\n    </span><span class="s1">throw e</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">var prev = this.current;</span><span class="s2">\n  </span><span class="s1">this.confirmTransition(</span><span class="s2">\n    </span><span class="s1">route,</span><span class="s2">\n    </span><span class="s1">function () {</span><span class="s2">\n      </span><span class="s1">this$1$1.updateRoute(route);</span><span class="s2">\n      </span><span class="s1">onComplete &amp;&amp; onComplete(route);</span><span class="s2">\n      </span><span class="s1">this$1$1.ensureURL();</span><span class="s2">\n      </span><span class="s1">this$1$1.router.afterHooks.forEach(function (hook) {</span><span class="s2">\n        </span><span class="s1">hook &amp;&amp; hook(route, prev);</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n\n      </span><span class="s1">// fire ready cbs once</span><span class="s2">\n      </span><span class="s1">if (!this$1$1.ready) {</span><span class="s2">\n        </span><span class="s1">this$1$1.ready = true;</span><span class="s2">\n        </span><span class="s1">this$1$1.readyCbs.forEach(function (cb) {</span><span class="s2">\n          </span><span class="s1">cb(route);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">function (err) {</span><span class="s2">\n      </span><span class="s1">if (onAbort) {</span><span class="s2">\n        </span><span class="s1">onAbort(err);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (err &amp;&amp; !this$1$1.ready) {</span><span class="s2">\n        </span><span class="s1">// Initial redirection should not mark the history as ready yet</span><span class="s2">\n        </span><span class="s1">// because it's triggered by the redirection instead</span><span class="s2">\n        </span><span class="s1">// https://github.com/vuejs/vue-router/issues/3225</span><span class="s2">\n        </span><span class="s1">// https://github.com/vuejs/vue-router/issues/3331</span><span class="s2">\n        </span><span class="s1">if (!isNavigationFailure(err, NavigationFailureType.redirected) || prev !== START) {</span><span class="s2">\n          </span><span class="s1">this$1$1.ready = true;</span><span class="s2">\n          </span><span class="s1">this$1$1.readyErrorCbs.forEach(function (cb) {</span><span class="s2">\n            </span><span class="s1">cb(err);</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">History.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n\n  </span><span class="s1">var current = this.current;</span><span class="s2">\n  </span><span class="s1">this.pending = route;</span><span class="s2">\n  </span><span class="s1">var abort = function (err) {</span><span class="s2">\n    </span><span class="s1">// changed after adding errors with</span><span class="s2">\n    </span><span class="s1">// https://github.com/vuejs/vue-router/pull/3047 before that change,</span><span class="s2">\n    </span><span class="s1">// redirect and aborted navigation would produce an err == null</span><span class="s2">\n    </span><span class="s1">if (!isNavigationFailure(err) &amp;&amp; isError(err)) {</span><span class="s2">\n      </span><span class="s1">if (this$1$1.errorCbs.length) {</span><span class="s2">\n        </span><span class="s1">this$1$1.errorCbs.forEach(function (cb) {</span><span class="s2">\n          </span><span class="s1">cb(err);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n          </span><span class="s1">warn(false, 'uncaught error during route navigation:');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">console.error(err);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">onAbort &amp;&amp; onAbort(err);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">var lastRouteIndex = route.matched.length - 1;</span><span class="s2">\n  </span><span class="s1">var lastCurrentIndex = current.matched.length - 1;</span><span class="s2">\n  </span><span class="s1">if (</span><span class="s2">\n    </span><span class="s1">isSameRoute(route, current) &amp;&amp;</span><span class="s2">\n    </span><span class="s1">// in the case the route map has been dynamically appended to</span><span class="s2">\n    </span><span class="s1">lastRouteIndex === lastCurrentIndex &amp;&amp;</span><span class="s2">\n    </span><span class="s1">route.matched[lastRouteIndex] === current.matched[lastCurrentIndex]</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">this.ensureURL();</span><span class="s2">\n    </span><span class="s1">if (route.hash) {</span><span class="s2">\n      </span><span class="s1">handleScroll(this.router, current, route, false);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return abort(createNavigationDuplicatedError(current, route))</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">var ref = resolveQueue(</span><span class="s2">\n    </span><span class="s1">this.current.matched,</span><span class="s2">\n    </span><span class="s1">route.matched</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">var updated = ref.updated;</span><span class="s2">\n    </span><span class="s1">var deactivated = ref.deactivated;</span><span class="s2">\n    </span><span class="s1">var activated = ref.activated;</span><span class="s2">\n\n  </span><span class="s1">var queue = [].concat(</span><span class="s2">\n    </span><span class="s1">// in-component leave guards</span><span class="s2">\n    </span><span class="s1">extractLeaveGuards(deactivated),</span><span class="s2">\n    </span><span class="s1">// global before hooks</span><span class="s2">\n    </span><span class="s1">this.router.beforeHooks,</span><span class="s2">\n    </span><span class="s1">// in-component update hooks</span><span class="s2">\n    </span><span class="s1">extractUpdateHooks(updated),</span><span class="s2">\n    </span><span class="s1">// in-config enter guards</span><span class="s2">\n    </span><span class="s1">activated.map(function (m) { return m.beforeEnter; }),</span><span class="s2">\n    </span><span class="s1">// async components</span><span class="s2">\n    </span><span class="s1">resolveAsyncComponents(activated)</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n\n  </span><span class="s1">var iterator = function (hook, next) {</span><span class="s2">\n    </span><span class="s1">if (this$1$1.pending !== route) {</span><span class="s2">\n      </span><span class="s1">return abort(createNavigationCancelledError(current, route))</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">hook(route, current, function (to) {</span><span class="s2">\n        </span><span class="s1">if (to === false) {</span><span class="s2">\n          </span><span class="s1">// next(false) -&gt; abort navigation, ensure current URL</span><span class="s2">\n          </span><span class="s1">this$1$1.ensureURL(true);</span><span class="s2">\n          </span><span class="s1">abort(createNavigationAbortedError(current, route));</span><span class="s2">\n        </span><span class="s1">} else if (isError(to)) {</span><span class="s2">\n          </span><span class="s1">this$1$1.ensureURL(true);</span><span class="s2">\n          </span><span class="s1">abort(to);</span><span class="s2">\n        </span><span class="s1">} else if (</span><span class="s2">\n          </span><span class="s1">typeof to === 'string' ||</span><span class="s2">\n          </span><span class="s1">(typeof to === 'object' &amp;&amp;</span><span class="s2">\n            </span><span class="s1">(typeof to.path === 'string' || typeof to.name === 'string'))</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">// next('/') or next({ path: '/' }) -&gt; redirect</span><span class="s2">\n          </span><span class="s1">abort(createNavigationRedirectedError(current, route));</span><span class="s2">\n          </span><span class="s1">if (typeof to === 'object' &amp;&amp; to.replace) {</span><span class="s2">\n            </span><span class="s1">this$1$1.replace(to);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">this$1$1.push(to);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">// confirm transition and pass on the value</span><span class="s2">\n          </span><span class="s1">next(to);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">abort(e);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">runQueue(queue, iterator, function () {</span><span class="s2">\n    </span><span class="s1">// wait until async components are resolved before</span><span class="s2">\n    </span><span class="s1">// extracting in-component enter guards</span><span class="s2">\n    </span><span class="s1">var enterGuards = extractEnterGuards(activated);</span><span class="s2">\n    </span><span class="s1">var queue = enterGuards.concat(this$1$1.router.resolveHooks);</span><span class="s2">\n    </span><span class="s1">runQueue(queue, iterator, function () {</span><span class="s2">\n      </span><span class="s1">if (this$1$1.pending !== route) {</span><span class="s2">\n        </span><span class="s1">return abort(createNavigationCancelledError(current, route))</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this$1$1.pending = null;</span><span class="s2">\n      </span><span class="s1">onComplete(route);</span><span class="s2">\n      </span><span class="s1">if (this$1$1.router.app) {</span><span class="s2">\n        </span><span class="s1">this$1$1.router.app.$nextTick(function () {</span><span class="s2">\n          </span><span class="s1">handleRouteEntered(route);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">History.prototype.updateRoute = function updateRoute (route) {</span><span class="s2">\n  </span><span class="s1">this.current = route;</span><span class="s2">\n  </span><span class="s1">this.cb &amp;&amp; this.cb(route);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">History.prototype.setupListeners = function setupListeners () {</span><span class="s2">\n  </span><span class="s1">// Default implementation is empty</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">History.prototype.teardown = function teardown () {</span><span class="s2">\n  </span><span class="s1">// clean up event listeners</span><span class="s2">\n  </span><span class="s1">// https://github.com/vuejs/vue-router/issues/2341</span><span class="s2">\n  </span><span class="s1">this.listeners.forEach(function (cleanupListener) {</span><span class="s2">\n    </span><span class="s1">cleanupListener();</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">this.listeners = [];</span><span class="s2">\n\n  </span><span class="s1">// reset current history route</span><span class="s2">\n  </span><span class="s1">// https://github.com/vuejs/vue-router/issues/3294</span><span class="s2">\n  </span><span class="s1">this.current = START;</span><span class="s2">\n  </span><span class="s1">this.pending = null;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">function normalizeBase (base) {</span><span class="s2">\n  </span><span class="s1">if (!base) {</span><span class="s2">\n    </span><span class="s1">if (inBrowser) {</span><span class="s2">\n      </span><span class="s1">// respect &lt;base&gt; tag</span><span class="s2">\n      </span><span class="s1">var baseEl = document.querySelector('base');</span><span class="s2">\n      </span><span class="s1">base = (baseEl &amp;&amp; baseEl.getAttribute('href')) || '/';</span><span class="s2">\n      </span><span class="s1">// strip full URL origin</span><span class="s2">\n      </span><span class="s1">base = base.replace(/^https?:</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">/[^</span><span class="s2">\\</span><span class="s1">/]+/, '');</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">base = '/';</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// make sure there's the starting slash</span><span class="s2">\n  </span><span class="s1">if (base.charAt(0) !== '/') {</span><span class="s2">\n    </span><span class="s1">base = '/' + base;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">// remove trailing slash</span><span class="s2">\n  </span><span class="s1">return base.replace(/</span><span class="s2">\\</span><span class="s1">/$/, '')</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function resolveQueue (</span><span class="s2">\n  </span><span class="s1">current,</span><span class="s2">\n  </span><span class="s1">next</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">var i;</span><span class="s2">\n  </span><span class="s1">var max = Math.max(current.length, next.length);</span><span class="s2">\n  </span><span class="s1">for (i = 0; i &lt; max; i++) {</span><span class="s2">\n    </span><span class="s1">if (current[i] !== next[i]) {</span><span class="s2">\n      </span><span class="s1">break</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">updated: next.slice(0, i),</span><span class="s2">\n    </span><span class="s1">activated: next.slice(i),</span><span class="s2">\n    </span><span class="s1">deactivated: current.slice(i)</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function extractGuards (</span><span class="s2">\n  </span><span class="s1">records,</span><span class="s2">\n  </span><span class="s1">name,</span><span class="s2">\n  </span><span class="s1">bind,</span><span class="s2">\n  </span><span class="s1">reverse</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">var guards = flatMapComponents(records, function (def, instance, match, key) {</span><span class="s2">\n    </span><span class="s1">var guard = extractGuard(def, name);</span><span class="s2">\n    </span><span class="s1">if (guard) {</span><span class="s2">\n      </span><span class="s1">return Array.isArray(guard)</span><span class="s2">\n        </span><span class="s1">? guard.map(function (guard) { return bind(guard, instance, match, key); })</span><span class="s2">\n        </span><span class="s1">: bind(guard, instance, match, key)</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return flatten(reverse ? guards.reverse() : guards)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function extractGuard (</span><span class="s2">\n  </span><span class="s1">def,</span><span class="s2">\n  </span><span class="s1">key</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">if (typeof def !== 'function') {</span><span class="s2">\n    </span><span class="s1">// extend now so that global mixins are applied.</span><span class="s2">\n    </span><span class="s1">def = _Vue.extend(def);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return def.options[key]</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function extractLeaveGuards (deactivated) {</span><span class="s2">\n  </span><span class="s1">return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function extractUpdateHooks (updated) {</span><span class="s2">\n  </span><span class="s1">return extractGuards(updated, 'beforeRouteUpdate', bindGuard)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function bindGuard (guard, instance) {</span><span class="s2">\n  </span><span class="s1">if (instance) {</span><span class="s2">\n    </span><span class="s1">return function boundRouteGuard () {</span><span class="s2">\n      </span><span class="s1">return guard.apply(instance, arguments)</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function extractEnterGuards (</span><span class="s2">\n  </span><span class="s1">activated</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">return extractGuards(</span><span class="s2">\n    </span><span class="s1">activated,</span><span class="s2">\n    </span><span class="s1">'beforeRouteEnter',</span><span class="s2">\n    </span><span class="s1">function (guard, _, match, key) {</span><span class="s2">\n      </span><span class="s1">return bindEnterGuard(guard, match, key)</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function bindEnterGuard (</span><span class="s2">\n  </span><span class="s1">guard,</span><span class="s2">\n  </span><span class="s1">match,</span><span class="s2">\n  </span><span class="s1">key</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">return function routeEnterGuard (to, from, next) {</span><span class="s2">\n    </span><span class="s1">return guard(to, from, function (cb) {</span><span class="s2">\n      </span><span class="s1">if (typeof cb === 'function') {</span><span class="s2">\n        </span><span class="s1">if (!match.enteredCbs[key]) {</span><span class="s2">\n          </span><span class="s1">match.enteredCbs[key] = [];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">match.enteredCbs[key].push(cb);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">next(cb);</span><span class="s2">\n    </span><span class="s1">})</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var HTML5History = /*@__PURE__*/(function (History) {</span><span class="s2">\n  </span><span class="s1">function HTML5History (router, base) {</span><span class="s2">\n    </span><span class="s1">History.call(this, router, base);</span><span class="s2">\n\n    </span><span class="s1">this._startLocation = getLocation(this.base);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if ( History ) HTML5History.__proto__ = History;</span><span class="s2">\n  </span><span class="s1">HTML5History.prototype = Object.create( History &amp;&amp; History.prototype );</span><span class="s2">\n  </span><span class="s1">HTML5History.prototype.constructor = HTML5History;</span><span class="s2">\n\n  </span><span class="s1">HTML5History.prototype.setupListeners = function setupListeners () {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n\n    </span><span class="s1">if (this.listeners.length &gt; 0) {</span><span class="s2">\n      </span><span class="s1">return</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">var router = this.router;</span><span class="s2">\n    </span><span class="s1">var expectScroll = router.options.scrollBehavior;</span><span class="s2">\n    </span><span class="s1">var supportsScroll = supportsPushState &amp;&amp; expectScroll;</span><span class="s2">\n\n    </span><span class="s1">if (supportsScroll) {</span><span class="s2">\n      </span><span class="s1">this.listeners.push(setupScroll());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">var handleRoutingEvent = function () {</span><span class="s2">\n      </span><span class="s1">var current = this$1$1.current;</span><span class="s2">\n\n      </span><span class="s1">// Avoiding first `popstate` event dispatched in some browsers but first</span><span class="s2">\n      </span><span class="s1">// history route not updated since async guard at the same time.</span><span class="s2">\n      </span><span class="s1">var location = getLocation(this$1$1.base);</span><span class="s2">\n      </span><span class="s1">if (this$1$1.current === START &amp;&amp; location === this$1$1._startLocation) {</span><span class="s2">\n        </span><span class="s1">return</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this$1$1.transitionTo(location, function (route) {</span><span class="s2">\n        </span><span class="s1">if (supportsScroll) {</span><span class="s2">\n          </span><span class="s1">handleScroll(router, route, current, true);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">window.addEventListener('popstate', handleRoutingEvent);</span><span class="s2">\n    </span><span class="s1">this.listeners.push(function () {</span><span class="s2">\n      </span><span class="s1">window.removeEventListener('popstate', handleRoutingEvent);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">HTML5History.prototype.go = function go (n) {</span><span class="s2">\n    </span><span class="s1">window.history.go(n);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">HTML5History.prototype.push = function push (location, onComplete, onAbort) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n\n    </span><span class="s1">var ref = this;</span><span class="s2">\n    </span><span class="s1">var fromRoute = ref.current;</span><span class="s2">\n    </span><span class="s1">this.transitionTo(location, function (route) {</span><span class="s2">\n      </span><span class="s1">pushState(cleanPath(this$1$1.base + route.fullPath));</span><span class="s2">\n      </span><span class="s1">handleScroll(this$1$1.router, route, fromRoute, false);</span><span class="s2">\n      </span><span class="s1">onComplete &amp;&amp; onComplete(route);</span><span class="s2">\n    </span><span class="s1">}, onAbort);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n\n    </span><span class="s1">var ref = this;</span><span class="s2">\n    </span><span class="s1">var fromRoute = ref.current;</span><span class="s2">\n    </span><span class="s1">this.transitionTo(location, function (route) {</span><span class="s2">\n      </span><span class="s1">replaceState(cleanPath(this$1$1.base + route.fullPath));</span><span class="s2">\n      </span><span class="s1">handleScroll(this$1$1.router, route, fromRoute, false);</span><span class="s2">\n      </span><span class="s1">onComplete &amp;&amp; onComplete(route);</span><span class="s2">\n    </span><span class="s1">}, onAbort);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">HTML5History.prototype.ensureURL = function ensureURL (push) {</span><span class="s2">\n    </span><span class="s1">if (getLocation(this.base) !== this.current.fullPath) {</span><span class="s2">\n      </span><span class="s1">var current = cleanPath(this.base + this.current.fullPath);</span><span class="s2">\n      </span><span class="s1">push ? pushState(current) : replaceState(current);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {</span><span class="s2">\n    </span><span class="s1">return getLocation(this.base)</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">return HTML5History;</span><span class="s2">\n</span><span class="s1">}(History));</span><span class="s2">\n\n</span><span class="s1">function getLocation (base) {</span><span class="s2">\n  </span><span class="s1">var path = window.location.pathname;</span><span class="s2">\n  </span><span class="s1">var pathLowerCase = path.toLowerCase();</span><span class="s2">\n  </span><span class="s1">var baseLowerCase = base.toLowerCase();</span><span class="s2">\n  </span><span class="s1">// base=</span><span class="s2">\&quot;</span><span class="s1">/a</span><span class="s2">\&quot; </span><span class="s1">shouldn't turn path=</span><span class="s2">\&quot;</span><span class="s1">/app</span><span class="s2">\&quot; </span><span class="s1">into </span><span class="s2">\&quot;</span><span class="s1">/a/pp</span><span class="s2">\&quot;\n  </span><span class="s1">// https://github.com/vuejs/vue-router/issues/3555</span><span class="s2">\n  </span><span class="s1">// so we ensure the trailing slash in the base</span><span class="s2">\n  </span><span class="s1">if (base &amp;&amp; ((pathLowerCase === baseLowerCase) ||</span><span class="s2">\n    </span><span class="s1">(pathLowerCase.indexOf(cleanPath(baseLowerCase + '/')) === 0))) {</span><span class="s2">\n    </span><span class="s1">path = path.slice(base.length);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return (path || '/') + window.location.search + window.location.hash</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var HashHistory = /*@__PURE__*/(function (History) {</span><span class="s2">\n  </span><span class="s1">function HashHistory (router, base, fallback) {</span><span class="s2">\n    </span><span class="s1">History.call(this, router, base);</span><span class="s2">\n    </span><span class="s1">// check history fallback deeplinking</span><span class="s2">\n    </span><span class="s1">if (fallback &amp;&amp; checkFallback(this.base)) {</span><span class="s2">\n      </span><span class="s1">return</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">ensureSlash();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if ( History ) HashHistory.__proto__ = History;</span><span class="s2">\n  </span><span class="s1">HashHistory.prototype = Object.create( History &amp;&amp; History.prototype );</span><span class="s2">\n  </span><span class="s1">HashHistory.prototype.constructor = HashHistory;</span><span class="s2">\n\n  </span><span class="s1">// this is delayed until the app mounts</span><span class="s2">\n  </span><span class="s1">// to avoid the hashchange listener being fired too early</span><span class="s2">\n  </span><span class="s1">HashHistory.prototype.setupListeners = function setupListeners () {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n\n    </span><span class="s1">if (this.listeners.length &gt; 0) {</span><span class="s2">\n      </span><span class="s1">return</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">var router = this.router;</span><span class="s2">\n    </span><span class="s1">var expectScroll = router.options.scrollBehavior;</span><span class="s2">\n    </span><span class="s1">var supportsScroll = supportsPushState &amp;&amp; expectScroll;</span><span class="s2">\n\n    </span><span class="s1">if (supportsScroll) {</span><span class="s2">\n      </span><span class="s1">this.listeners.push(setupScroll());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">var handleRoutingEvent = function () {</span><span class="s2">\n      </span><span class="s1">var current = this$1$1.current;</span><span class="s2">\n      </span><span class="s1">if (!ensureSlash()) {</span><span class="s2">\n        </span><span class="s1">return</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this$1$1.transitionTo(getHash(), function (route) {</span><span class="s2">\n        </span><span class="s1">if (supportsScroll) {</span><span class="s2">\n          </span><span class="s1">handleScroll(this$1$1.router, route, current, true);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (!supportsPushState) {</span><span class="s2">\n          </span><span class="s1">replaceHash(route.fullPath);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var eventType = supportsPushState ? 'popstate' : 'hashchange';</span><span class="s2">\n    </span><span class="s1">window.addEventListener(</span><span class="s2">\n      </span><span class="s1">eventType,</span><span class="s2">\n      </span><span class="s1">handleRoutingEvent</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">this.listeners.push(function () {</span><span class="s2">\n      </span><span class="s1">window.removeEventListener(eventType, handleRoutingEvent);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">HashHistory.prototype.push = function push (location, onComplete, onAbort) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n\n    </span><span class="s1">var ref = this;</span><span class="s2">\n    </span><span class="s1">var fromRoute = ref.current;</span><span class="s2">\n    </span><span class="s1">this.transitionTo(</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">function (route) {</span><span class="s2">\n        </span><span class="s1">pushHash(route.fullPath);</span><span class="s2">\n        </span><span class="s1">handleScroll(this$1$1.router, route, fromRoute, false);</span><span class="s2">\n        </span><span class="s1">onComplete &amp;&amp; onComplete(route);</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">onAbort</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n\n    </span><span class="s1">var ref = this;</span><span class="s2">\n    </span><span class="s1">var fromRoute = ref.current;</span><span class="s2">\n    </span><span class="s1">this.transitionTo(</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">function (route) {</span><span class="s2">\n        </span><span class="s1">replaceHash(route.fullPath);</span><span class="s2">\n        </span><span class="s1">handleScroll(this$1$1.router, route, fromRoute, false);</span><span class="s2">\n        </span><span class="s1">onComplete &amp;&amp; onComplete(route);</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">onAbort</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">HashHistory.prototype.go = function go (n) {</span><span class="s2">\n    </span><span class="s1">window.history.go(n);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">HashHistory.prototype.ensureURL = function ensureURL (push) {</span><span class="s2">\n    </span><span class="s1">var current = this.current.fullPath;</span><span class="s2">\n    </span><span class="s1">if (getHash() !== current) {</span><span class="s2">\n      </span><span class="s1">push ? pushHash(current) : replaceHash(current);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {</span><span class="s2">\n    </span><span class="s1">return getHash()</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">return HashHistory;</span><span class="s2">\n</span><span class="s1">}(History));</span><span class="s2">\n\n</span><span class="s1">function checkFallback (base) {</span><span class="s2">\n  </span><span class="s1">var location = getLocation(base);</span><span class="s2">\n  </span><span class="s1">if (!/^</span><span class="s2">\\</span><span class="s1">/#/.test(location)) {</span><span class="s2">\n    </span><span class="s1">window.location.replace(cleanPath(base + '/#' + location));</span><span class="s2">\n    </span><span class="s1">return true</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function ensureSlash () {</span><span class="s2">\n  </span><span class="s1">var path = getHash();</span><span class="s2">\n  </span><span class="s1">if (path.charAt(0) === '/') {</span><span class="s2">\n    </span><span class="s1">return true</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">replaceHash('/' + path);</span><span class="s2">\n  </span><span class="s1">return false</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function getHash () {</span><span class="s2">\n  </span><span class="s1">// We can't use window.location.hash here because it's not</span><span class="s2">\n  </span><span class="s1">// consistent across browsers - Firefox will pre-decode it!</span><span class="s2">\n  </span><span class="s1">var href = window.location.href;</span><span class="s2">\n  </span><span class="s1">var index = href.indexOf('#');</span><span class="s2">\n  </span><span class="s1">// empty path</span><span class="s2">\n  </span><span class="s1">if (index &lt; 0) { return '' }</span><span class="s2">\n\n  </span><span class="s1">href = href.slice(index + 1);</span><span class="s2">\n\n  </span><span class="s1">return href</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function getUrl (path) {</span><span class="s2">\n  </span><span class="s1">var href = window.location.href;</span><span class="s2">\n  </span><span class="s1">var i = href.indexOf('#');</span><span class="s2">\n  </span><span class="s1">var base = i &gt;= 0 ? href.slice(0, i) : href;</span><span class="s2">\n  </span><span class="s1">return (base + </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">+ path)</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function pushHash (path) {</span><span class="s2">\n  </span><span class="s1">if (supportsPushState) {</span><span class="s2">\n    </span><span class="s1">pushState(getUrl(path));</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">window.location.hash = path;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function replaceHash (path) {</span><span class="s2">\n  </span><span class="s1">if (supportsPushState) {</span><span class="s2">\n    </span><span class="s1">replaceState(getUrl(path));</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">window.location.replace(getUrl(path));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n</span><span class="s1">var AbstractHistory = /*@__PURE__*/(function (History) {</span><span class="s2">\n  </span><span class="s1">function AbstractHistory (router, base) {</span><span class="s2">\n    </span><span class="s1">History.call(this, router, base);</span><span class="s2">\n    </span><span class="s1">this.stack = [];</span><span class="s2">\n    </span><span class="s1">this.index = -1;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if ( History ) AbstractHistory.__proto__ = History;</span><span class="s2">\n  </span><span class="s1">AbstractHistory.prototype = Object.create( History &amp;&amp; History.prototype );</span><span class="s2">\n  </span><span class="s1">AbstractHistory.prototype.constructor = AbstractHistory;</span><span class="s2">\n\n  </span><span class="s1">AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n\n    </span><span class="s1">this.transitionTo(</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">function (route) {</span><span class="s2">\n        </span><span class="s1">this$1$1.stack = this$1$1.stack.slice(0, this$1$1.index + 1).concat(route);</span><span class="s2">\n        </span><span class="s1">this$1$1.index++;</span><span class="s2">\n        </span><span class="s1">onComplete &amp;&amp; onComplete(route);</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">onAbort</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n\n    </span><span class="s1">this.transitionTo(</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">function (route) {</span><span class="s2">\n        </span><span class="s1">this$1$1.stack = this$1$1.stack.slice(0, this$1$1.index).concat(route);</span><span class="s2">\n        </span><span class="s1">onComplete &amp;&amp; onComplete(route);</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">onAbort</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">AbstractHistory.prototype.go = function go (n) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n\n    </span><span class="s1">var targetIndex = this.index + n;</span><span class="s2">\n    </span><span class="s1">if (targetIndex &lt; 0 || targetIndex &gt;= this.stack.length) {</span><span class="s2">\n      </span><span class="s1">return</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var route = this.stack[targetIndex];</span><span class="s2">\n    </span><span class="s1">this.confirmTransition(</span><span class="s2">\n      </span><span class="s1">route,</span><span class="s2">\n      </span><span class="s1">function () {</span><span class="s2">\n        </span><span class="s1">var prev = this$1$1.current;</span><span class="s2">\n        </span><span class="s1">this$1$1.index = targetIndex;</span><span class="s2">\n        </span><span class="s1">this$1$1.updateRoute(route);</span><span class="s2">\n        </span><span class="s1">this$1$1.router.afterHooks.forEach(function (hook) {</span><span class="s2">\n          </span><span class="s1">hook &amp;&amp; hook(route, prev);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">function (err) {</span><span class="s2">\n        </span><span class="s1">if (isNavigationFailure(err, NavigationFailureType.duplicated)) {</span><span class="s2">\n          </span><span class="s1">this$1$1.index = targetIndex;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {</span><span class="s2">\n    </span><span class="s1">var current = this.stack[this.stack.length - 1];</span><span class="s2">\n    </span><span class="s1">return current ? current.fullPath : '/'</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">AbstractHistory.prototype.ensureURL = function ensureURL () {</span><span class="s2">\n    </span><span class="s1">// noop</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">return AbstractHistory;</span><span class="s2">\n</span><span class="s1">}(History));</span><span class="s2">\n\n</span><span class="s1">/*  */</span><span class="s2">\n\n\n\n</span><span class="s1">var VueRouter = function VueRouter (options) {</span><span class="s2">\n  </span><span class="s1">if ( options === void 0 ) options = {};</span><span class="s2">\n\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">warn(this instanceof VueRouter, </span><span class="s2">\&quot;</span><span class="s1">Router must be called with the new operator.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">this.app = null;</span><span class="s2">\n  </span><span class="s1">this.apps = [];</span><span class="s2">\n  </span><span class="s1">this.options = options;</span><span class="s2">\n  </span><span class="s1">this.beforeHooks = [];</span><span class="s2">\n  </span><span class="s1">this.resolveHooks = [];</span><span class="s2">\n  </span><span class="s1">this.afterHooks = [];</span><span class="s2">\n  </span><span class="s1">this.matcher = createMatcher(options.routes || [], this);</span><span class="s2">\n\n  </span><span class="s1">var mode = options.mode || 'hash';</span><span class="s2">\n  </span><span class="s1">this.fallback =</span><span class="s2">\n    </span><span class="s1">mode === 'history' &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false;</span><span class="s2">\n  </span><span class="s1">if (this.fallback) {</span><span class="s2">\n    </span><span class="s1">mode = 'hash';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!inBrowser) {</span><span class="s2">\n    </span><span class="s1">mode = 'abstract';</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">this.mode = mode;</span><span class="s2">\n\n  </span><span class="s1">switch (mode) {</span><span class="s2">\n    </span><span class="s1">case 'history':</span><span class="s2">\n      </span><span class="s1">this.history = new HTML5History(this, options.base);</span><span class="s2">\n      </span><span class="s1">break</span><span class="s2">\n    </span><span class="s1">case 'hash':</span><span class="s2">\n      </span><span class="s1">this.history = new HashHistory(this, options.base, this.fallback);</span><span class="s2">\n      </span><span class="s1">break</span><span class="s2">\n    </span><span class="s1">case 'abstract':</span><span class="s2">\n      </span><span class="s1">this.history = new AbstractHistory(this, options.base);</span><span class="s2">\n      </span><span class="s1">break</span><span class="s2">\n    </span><span class="s1">default:</span><span class="s2">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n        </span><span class="s1">assert(false, (</span><span class="s2">\&quot;</span><span class="s1">invalid mode: </span><span class="s2">\&quot; </span><span class="s1">+ mode));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">var prototypeAccessors = { currentRoute: { configurable: true } };</span><span class="s2">\n\n</span><span class="s1">VueRouter.prototype.match = function match (raw, current, redirectedFrom) {</span><span class="s2">\n  </span><span class="s1">return this.matcher.match(raw, current, redirectedFrom)</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">prototypeAccessors.currentRoute.get = function () {</span><span class="s2">\n  </span><span class="s1">return this.history &amp;&amp; this.history.current</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">VueRouter.prototype.init = function init (app /* Vue component instance */) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n\n  </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s2">\n    </span><span class="s1">assert(</span><span class="s2">\n      </span><span class="s1">install.installed,</span><span class="s2">\n      \&quot;</span><span class="s1">not installed. Make sure to call `Vue.use(VueRouter)` </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n        \&quot;</span><span class="s1">before creating root instance.</span><span class="s2">\&quot;\n    </span><span class="s1">);</span><span class="s2">\n\n  </span><span class="s1">this.apps.push(app);</span><span class="s2">\n\n  </span><span class="s1">// set up app destroyed handler</span><span class="s2">\n  </span><span class="s1">// https://github.com/vuejs/vue-router/issues/2639</span><span class="s2">\n  </span><span class="s1">app.$once('hook:destroyed', function () {</span><span class="s2">\n    </span><span class="s1">// clean out app from this.apps array once destroyed</span><span class="s2">\n    </span><span class="s1">var index = this$1$1.apps.indexOf(app);</span><span class="s2">\n    </span><span class="s1">if (index &gt; -1) { this$1$1.apps.splice(index, 1); }</span><span class="s2">\n    </span><span class="s1">// ensure we still have a main app or null if no apps</span><span class="s2">\n    </span><span class="s1">// we do not release the router so it can be reused</span><span class="s2">\n    </span><span class="s1">if (this$1$1.app === app) { this$1$1.app = this$1$1.apps[0] || null; }</span><span class="s2">\n\n    </span><span class="s1">if (!this$1$1.app) { this$1$1.history.teardown(); }</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n\n  </span><span class="s1">// main app previously initialized</span><span class="s2">\n  </span><span class="s1">// return as we don't need to set up new history listener</span><span class="s2">\n  </span><span class="s1">if (this.app) {</span><span class="s2">\n    </span><span class="s1">return</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">this.app = app;</span><span class="s2">\n\n  </span><span class="s1">var history = this.history;</span><span class="s2">\n\n  </span><span class="s1">if (history instanceof HTML5History || history instanceof HashHistory) {</span><span class="s2">\n    </span><span class="s1">var handleInitialScroll = function (routeOrError) {</span><span class="s2">\n      </span><span class="s1">var from = history.current;</span><span class="s2">\n      </span><span class="s1">var expectScroll = this$1$1.options.scrollBehavior;</span><span class="s2">\n      </span><span class="s1">var supportsScroll = supportsPushState &amp;&amp; expectScroll;</span><span class="s2">\n\n      </span><span class="s1">if (supportsScroll &amp;&amp; 'fullPath' in routeOrError) {</span><span class="s2">\n        </span><span class="s1">handleScroll(this$1$1, routeOrError, from, false);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var setupListeners = function (routeOrError) {</span><span class="s2">\n      </span><span class="s1">history.setupListeners();</span><span class="s2">\n      </span><span class="s1">handleInitialScroll(routeOrError);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">history.transitionTo(</span><span class="s2">\n      </span><span class="s1">history.getCurrentLocation(),</span><span class="s2">\n      </span><span class="s1">setupListeners,</span><span class="s2">\n      </span><span class="s1">setupListeners</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">history.listen(function (route) {</span><span class="s2">\n    </span><span class="s1">this$1$1.apps.forEach(function (app) {</span><span class="s2">\n      </span><span class="s1">app._route = route;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">VueRouter.prototype.beforeEach = function beforeEach (fn) {</span><span class="s2">\n  </span><span class="s1">return registerHook(this.beforeHooks, fn)</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">VueRouter.prototype.beforeResolve = function beforeResolve (fn) {</span><span class="s2">\n  </span><span class="s1">return registerHook(this.resolveHooks, fn)</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">VueRouter.prototype.afterEach = function afterEach (fn) {</span><span class="s2">\n  </span><span class="s1">return registerHook(this.afterHooks, fn)</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">VueRouter.prototype.onReady = function onReady (cb, errorCb) {</span><span class="s2">\n  </span><span class="s1">this.history.onReady(cb, errorCb);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">VueRouter.prototype.onError = function onError (errorCb) {</span><span class="s2">\n  </span><span class="s1">this.history.onError(errorCb);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">VueRouter.prototype.push = function push (location, onComplete, onAbort) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n\n  </span><span class="s1">// $flow-disable-line</span><span class="s2">\n  </span><span class="s1">if (!onComplete &amp;&amp; !onAbort &amp;&amp; typeof Promise !== 'undefined') {</span><span class="s2">\n    </span><span class="s1">return new Promise(function (resolve, reject) {</span><span class="s2">\n      </span><span class="s1">this$1$1.history.push(location, resolve, reject);</span><span class="s2">\n    </span><span class="s1">})</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">this.history.push(location, onComplete, onAbort);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">VueRouter.prototype.replace = function replace (location, onComplete, onAbort) {</span><span class="s2">\n    </span><span class="s1">var this$1$1 = this;</span><span class="s2">\n\n  </span><span class="s1">// $flow-disable-line</span><span class="s2">\n  </span><span class="s1">if (!onComplete &amp;&amp; !onAbort &amp;&amp; typeof Promise !== 'undefined') {</span><span class="s2">\n    </span><span class="s1">return new Promise(function (resolve, reject) {</span><span class="s2">\n      </span><span class="s1">this$1$1.history.replace(location, resolve, reject);</span><span class="s2">\n    </span><span class="s1">})</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">this.history.replace(location, onComplete, onAbort);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">VueRouter.prototype.go = function go (n) {</span><span class="s2">\n  </span><span class="s1">this.history.go(n);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">VueRouter.prototype.back = function back () {</span><span class="s2">\n  </span><span class="s1">this.go(-1);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">VueRouter.prototype.forward = function forward () {</span><span class="s2">\n  </span><span class="s1">this.go(1);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">VueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {</span><span class="s2">\n  </span><span class="s1">var route = to</span><span class="s2">\n    </span><span class="s1">? to.matched</span><span class="s2">\n      </span><span class="s1">? to</span><span class="s2">\n      </span><span class="s1">: this.resolve(to).route</span><span class="s2">\n    </span><span class="s1">: this.currentRoute;</span><span class="s2">\n  </span><span class="s1">if (!route) {</span><span class="s2">\n    </span><span class="s1">return []</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return [].concat.apply(</span><span class="s2">\n    </span><span class="s1">[],</span><span class="s2">\n    </span><span class="s1">route.matched.map(function (m) {</span><span class="s2">\n      </span><span class="s1">return Object.keys(m.components).map(function (key) {</span><span class="s2">\n        </span><span class="s1">return m.components[key]</span><span class="s2">\n      </span><span class="s1">})</span><span class="s2">\n    </span><span class="s1">})</span><span class="s2">\n  </span><span class="s1">)</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">VueRouter.prototype.resolve = function resolve (</span><span class="s2">\n  </span><span class="s1">to,</span><span class="s2">\n  </span><span class="s1">current,</span><span class="s2">\n  </span><span class="s1">append</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">current = current || this.history.current;</span><span class="s2">\n  </span><span class="s1">var location = normalizeLocation(to, current, append, this);</span><span class="s2">\n  </span><span class="s1">var route = this.match(location, current);</span><span class="s2">\n  </span><span class="s1">var fullPath = route.redirectedFrom || route.fullPath;</span><span class="s2">\n  </span><span class="s1">var base = this.history.base;</span><span class="s2">\n  </span><span class="s1">var href = createHref(base, fullPath, this.mode);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">location: location,</span><span class="s2">\n    </span><span class="s1">route: route,</span><span class="s2">\n    </span><span class="s1">href: href,</span><span class="s2">\n    </span><span class="s1">// for backwards compat</span><span class="s2">\n    </span><span class="s1">normalizedTo: location,</span><span class="s2">\n    </span><span class="s1">resolved: route</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">VueRouter.prototype.getRoutes = function getRoutes () {</span><span class="s2">\n  </span><span class="s1">return this.matcher.getRoutes()</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">VueRouter.prototype.addRoute = function addRoute (parentOrRoute, route) {</span><span class="s2">\n  </span><span class="s1">this.matcher.addRoute(parentOrRoute, route);</span><span class="s2">\n  </span><span class="s1">if (this.history.current !== START) {</span><span class="s2">\n    </span><span class="s1">this.history.transitionTo(this.history.getCurrentLocation());</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">VueRouter.prototype.addRoutes = function addRoutes (routes) {</span><span class="s2">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s2">\n    </span><span class="s1">warn(false, 'router.addRoutes() is deprecated and has been removed in Vue Router 4. Use router.addRoute() instead.');</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">this.matcher.addRoutes(routes);</span><span class="s2">\n  </span><span class="s1">if (this.history.current !== START) {</span><span class="s2">\n    </span><span class="s1">this.history.transitionTo(this.history.getCurrentLocation());</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">Object.defineProperties( VueRouter.prototype, prototypeAccessors );</span><span class="s2">\n\n</span><span class="s1">var VueRouter$1 = VueRouter;</span><span class="s2">\n\n</span><span class="s1">function registerHook (list, fn) {</span><span class="s2">\n  </span><span class="s1">list.push(fn);</span><span class="s2">\n  </span><span class="s1">return function () {</span><span class="s2">\n    </span><span class="s1">var i = list.indexOf(fn);</span><span class="s2">\n    </span><span class="s1">if (i &gt; -1) { list.splice(i, 1); }</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function createHref (base, fullPath, mode) {</span><span class="s2">\n  </span><span class="s1">var path = mode === 'hash' ? '#' + fullPath : fullPath;</span><span class="s2">\n  </span><span class="s1">return base ? cleanPath(base + '/' + path) : path</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// We cannot remove this as it would be a breaking change</span><span class="s2">\n</span><span class="s1">VueRouter.install = install;</span><span class="s2">\n</span><span class="s1">VueRouter.version = '3.6.5';</span><span class="s2">\n</span><span class="s1">VueRouter.isNavigationFailure = isNavigationFailure;</span><span class="s2">\n</span><span class="s1">VueRouter.NavigationFailureType = NavigationFailureType;</span><span class="s2">\n</span><span class="s1">VueRouter.START_LOCATION = START;</span><span class="s2">\n\n</span><span class="s1">if (inBrowser &amp;&amp; window.Vue) {</span><span class="s2">\n  </span><span class="s1">window.Vue.use(VueRouter);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var version = '3.6.5';</span><span class="s2">\n\n</span><span class="s1">export { NavigationFailureType, Link as RouterLink, View as RouterView, START as START_LOCATION, VueRouter$1 as default, isNavigationFailure, version };</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">},</span><span class="s1">&quot;metadata&quot;</span><span class="s0">:{},</span><span class="s1">&quot;sourceType&quot;</span><span class="s0">:</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;externalDependencies&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>