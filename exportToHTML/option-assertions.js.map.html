<html>
<head>
<title>option-assertions.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
option-assertions.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_helperCompilationTargets&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_options&quot;</span><span class="s0">,</span><span class="s1">&quot;msg&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;access&quot;</span><span class="s0">,</span><span class="s1">&quot;assertRootMode&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;assertSourceMaps&quot;</span><span class="s0">,</span><span class="s1">&quot;assertCompact&quot;</span><span class="s0">,</span><span class="s1">&quot;assertSourceType&quot;</span><span class="s0">,</span><span class="s1">&quot;assertCallerMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;assertObject&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;propLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;assertInputSourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;assertString&quot;</span><span class="s0">,</span><span class="s1">&quot;assertFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;assertBoolean&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;assertArray&quot;</span><span class="s0">,</span><span class="s1">&quot;assertIgnoreList&quot;</span><span class="s0">,</span><span class="s1">&quot;arr&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;assertIgnoreItem&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;assertConfigApplicableTest&quot;</span><span class="s0">,</span><span class="s1">&quot;checkValidTest&quot;</span><span class="s0">,</span><span class="s1">&quot;assertConfigFileSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;assertBabelrcSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;assertPluginList&quot;</span><span class="s0">,</span><span class="s1">&quot;assertPluginItem&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;assertPluginTarget&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">,</span><span class="s1">&quot;assertTargets&quot;</span><span class="s0">,</span><span class="s1">&quot;isBrowsersQueryValid&quot;</span><span class="s0">,</span><span class="s1">&quot;browsersLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;esmodulesLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;assertBrowsersList&quot;</span><span class="s0">,</span><span class="s1">&quot;browsers&quot;</span><span class="s0">,</span><span class="s1">&quot;esmodules&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;subLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;TargetNames&quot;</span><span class="s0">,</span><span class="s1">&quot;validTargets&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;assertBrowserVersion&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;round&quot;</span><span class="s0">,</span><span class="s1">&quot;assertAssumptions&quot;</span><span class="s0">,</span><span class="s1">&quot;root&quot;</span><span class="s0">,</span><span class="s1">&quot;inPreset&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;assumptionsNames&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/config/validation/option-assertions.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">isBrowsersQueryValid,</span><span class="s3">\n  </span><span class="s1">TargetNames,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-compilation-targets</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ConfigFileSearch,</span><span class="s3">\n  </span><span class="s1">BabelrcSearch,</span><span class="s3">\n  </span><span class="s1">IgnoreList,</span><span class="s3">\n  </span><span class="s1">IgnoreItem,</span><span class="s3">\n  </span><span class="s1">PluginList,</span><span class="s3">\n  </span><span class="s1">PluginItem,</span><span class="s3">\n  </span><span class="s1">PluginTarget,</span><span class="s3">\n  </span><span class="s1">ConfigApplicableTest,</span><span class="s3">\n  </span><span class="s1">SourceMapsOption,</span><span class="s3">\n  </span><span class="s1">SourceTypeOption,</span><span class="s3">\n  </span><span class="s1">CompactOption,</span><span class="s3">\n  </span><span class="s1">RootInputSourceMapOption,</span><span class="s3">\n  </span><span class="s1">NestingPath,</span><span class="s3">\n  </span><span class="s1">CallerMetadata,</span><span class="s3">\n  </span><span class="s1">RootMode,</span><span class="s3">\n  </span><span class="s1">TargetsListOrObject,</span><span class="s3">\n  </span><span class="s1">AssumptionName,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./options.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import { assumptionsNames } from </span><span class="s3">\&quot;</span><span class="s1">./options.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export type { RootPath } from </span><span class="s3">\&quot;</span><span class="s1">./options.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export type ValidatorSet = {</span><span class="s3">\n  </span><span class="s1">[name: string]: Validator&lt;any&gt;;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export type Validator&lt;T&gt; = (loc: OptionPath, value: unknown) =&gt; T;</span><span class="s3">\n\n</span><span class="s1">export function msg(loc: NestingPath | GeneralPath): string {</span><span class="s3">\n  </span><span class="s1">switch (loc.type) {</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">root</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return ``;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">env</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return `${msg(loc.parent)}.env[</span><span class="s3">\&quot;</span><span class="s1">${loc.name}</span><span class="s3">\&quot;</span><span class="s1">]`;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">overrides</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return `${msg(loc.parent)}.overrides[${loc.index}]`;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">option</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return `${msg(loc.parent)}.${loc.name}`;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">access</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error should not happen when code is type checked</span><span class="s3">\n      </span><span class="s1">throw new Error(`Assertion failure: Unknown type ${loc.type}`);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function access(loc: GeneralPath, name: string | number): AccessPath {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">access</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n    </span><span class="s1">parent: loc,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type OptionPath = Readonly&lt;{</span><span class="s3">\n  </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">option</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">name: string;</span><span class="s3">\n  </span><span class="s1">parent: NestingPath;</span><span class="s3">\n</span><span class="s1">}&gt;;</span><span class="s3">\n</span><span class="s1">type AccessPath = Readonly&lt;{</span><span class="s3">\n  </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">access</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">name: string | number;</span><span class="s3">\n  </span><span class="s1">parent: GeneralPath;</span><span class="s3">\n</span><span class="s1">}&gt;;</span><span class="s3">\n</span><span class="s1">type GeneralPath = OptionPath | AccessPath;</span><span class="s3">\n\n</span><span class="s1">export function assertRootMode(</span><span class="s3">\n  </span><span class="s1">loc: OptionPath,</span><span class="s3">\n  </span><span class="s1">value: unknown,</span><span class="s3">\n</span><span class="s1">): RootMode | void {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">value !== undefined &amp;&amp;</span><span class="s3">\n    </span><span class="s1">value !== </span><span class="s3">\&quot;</span><span class="s1">root</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">value !== </span><span class="s3">\&quot;</span><span class="s1">upward</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">value !== </span><span class="s3">\&quot;</span><span class="s1">upward-optional</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`${msg(loc)} must be a </span><span class="s3">\&quot;</span><span class="s1">root</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">upward</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">upward-optional</span><span class="s3">\&quot; </span><span class="s1">or undefined`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error: TS can only narrow down the type when </span><span class="s3">\&quot;</span><span class="s1">strictNullCheck</span><span class="s3">\&quot; </span><span class="s1">is true</span><span class="s3">\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assertSourceMaps(</span><span class="s3">\n  </span><span class="s1">loc: OptionPath,</span><span class="s3">\n  </span><span class="s1">value: unknown,</span><span class="s3">\n</span><span class="s1">): SourceMapsOption | void {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">value !== undefined &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof value !== </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">value !== </span><span class="s3">\&quot;</span><span class="s1">inline</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">value !== </span><span class="s3">\&quot;</span><span class="s1">both</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`${msg(loc)} must be a boolean, </span><span class="s3">\&quot;</span><span class="s1">inline</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">both</span><span class="s3">\&quot;</span><span class="s1">, or undefined`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error: TS can only narrow down the type when </span><span class="s3">\&quot;</span><span class="s1">strictNullCheck</span><span class="s3">\&quot; </span><span class="s1">is true</span><span class="s3">\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assertCompact(</span><span class="s3">\n  </span><span class="s1">loc: OptionPath,</span><span class="s3">\n  </span><span class="s1">value: unknown,</span><span class="s3">\n</span><span class="s1">): CompactOption | void {</span><span class="s3">\n  </span><span class="s1">if (value !== undefined &amp;&amp; typeof value !== </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; value !== </span><span class="s3">\&quot;</span><span class="s1">auto</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(`${msg(loc)} must be a boolean, </span><span class="s3">\&quot;</span><span class="s1">auto</span><span class="s3">\&quot;</span><span class="s1">, or undefined`);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error: TS can only narrow down the type when </span><span class="s3">\&quot;</span><span class="s1">strictNullCheck</span><span class="s3">\&quot; </span><span class="s1">is true</span><span class="s3">\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assertSourceType(</span><span class="s3">\n  </span><span class="s1">loc: OptionPath,</span><span class="s3">\n  </span><span class="s1">value: unknown,</span><span class="s3">\n</span><span class="s1">): SourceTypeOption | void {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">value !== undefined &amp;&amp;</span><span class="s3">\n    </span><span class="s1">value !== </span><span class="s3">\&quot;</span><span class="s1">module</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">value !== </span><span class="s3">\&quot;</span><span class="s1">script</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">value !== </span><span class="s3">\&quot;</span><span class="s1">unambiguous</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`${msg(loc)} must be </span><span class="s3">\&quot;</span><span class="s1">module</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">script</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">unambiguous</span><span class="s3">\&quot;</span><span class="s1">, or undefined`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error: TS can only narrow down the type when </span><span class="s3">\&quot;</span><span class="s1">strictNullCheck</span><span class="s3">\&quot; </span><span class="s1">is true</span><span class="s3">\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assertCallerMetadata(</span><span class="s3">\n  </span><span class="s1">loc: OptionPath,</span><span class="s3">\n  </span><span class="s1">value: unknown,</span><span class="s3">\n</span><span class="s1">): CallerMetadata | undefined {</span><span class="s3">\n  </span><span class="s1">const obj = assertObject(loc, value);</span><span class="s3">\n  </span><span class="s1">if (obj) {</span><span class="s3">\n    </span><span class="s1">if (typeof obj.name !== </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`${msg(loc)} set but does not contain </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot; </span><span class="s1">property string`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const prop of Object.keys(obj)) {</span><span class="s3">\n      </span><span class="s1">const propLoc = access(loc, prop);</span><span class="s3">\n      </span><span class="s1">const value = obj[prop];</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">value != null &amp;&amp;</span><span class="s3">\n        </span><span class="s1">typeof value !== </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">typeof value !== </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">typeof value !== </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// NOTE(logan): I'm limiting the type here so that we can guarantee that</span><span class="s3">\n        </span><span class="s1">// the </span><span class="s3">\&quot;</span><span class="s1">caller</span><span class="s3">\&quot; </span><span class="s1">value will serialize to JSON nicely. We can always</span><span class="s3">\n        </span><span class="s1">// allow more complex structures later though.</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`${msg(</span><span class="s3">\n            </span><span class="s1">propLoc,</span><span class="s3">\n          </span><span class="s1">)} must be null, undefined, a boolean, a string, or a number.`,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s3">\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assertInputSourceMap(</span><span class="s3">\n  </span><span class="s1">loc: OptionPath,</span><span class="s3">\n  </span><span class="s1">value: unknown,</span><span class="s3">\n</span><span class="s1">): RootInputSourceMapOption | void {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">value !== undefined &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof value !== </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">(typeof value !== </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">|| !value)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assertString(loc: GeneralPath, value: unknown): string | void {</span><span class="s3">\n  </span><span class="s1">if (value !== undefined &amp;&amp; typeof value !== </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(`${msg(loc)} must be a string, or undefined`);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error: TS can only narrow down the type when </span><span class="s3">\&quot;</span><span class="s1">strictNullCheck</span><span class="s3">\&quot; </span><span class="s1">is true</span><span class="s3">\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assertFunction(</span><span class="s3">\n  </span><span class="s1">loc: GeneralPath,</span><span class="s3">\n  </span><span class="s1">value: unknown,</span><span class="s3">\n</span><span class="s1">): Function | void {</span><span class="s3">\n  </span><span class="s1">if (value !== undefined &amp;&amp; typeof value !== </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(`${msg(loc)} must be a function, or undefined`);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error: TS can only narrow down the type when </span><span class="s3">\&quot;</span><span class="s1">strictNullCheck</span><span class="s3">\&quot; </span><span class="s1">is true</span><span class="s3">\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assertBoolean(</span><span class="s3">\n  </span><span class="s1">loc: GeneralPath,</span><span class="s3">\n  </span><span class="s1">value: unknown,</span><span class="s3">\n</span><span class="s1">): boolean | void {</span><span class="s3">\n  </span><span class="s1">if (value !== undefined &amp;&amp; typeof value !== </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(`${msg(loc)} must be a boolean, or undefined`);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error: TS can only narrow down the type when </span><span class="s3">\&quot;</span><span class="s1">strictNullCheck</span><span class="s3">\&quot; </span><span class="s1">is true</span><span class="s3">\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assertObject(</span><span class="s3">\n  </span><span class="s1">loc: GeneralPath,</span><span class="s3">\n  </span><span class="s1">value: unknown,</span><span class="s3">\n</span><span class="s1">): { readonly [key: string]: unknown } | void {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">value !== undefined &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(typeof value !== </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">|| Array.isArray(value) || !value)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(`${msg(loc)} must be an object, or undefined`);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) value is still typed as unknown, also assert function typically should not return a value</span><span class="s3">\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assertArray&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">loc: GeneralPath,</span><span class="s3">\n  </span><span class="s1">value: Array&lt;T&gt; | undefined | null,</span><span class="s3">\n</span><span class="s1">): ReadonlyArray&lt;T&gt; | undefined | null {</span><span class="s3">\n  </span><span class="s1">if (value != null &amp;&amp; !Array.isArray(value)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(`${msg(loc)} must be an array, or undefined`);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assertIgnoreList(</span><span class="s3">\n  </span><span class="s1">loc: OptionPath,</span><span class="s3">\n  </span><span class="s1">value: unknown[] | undefined,</span><span class="s3">\n</span><span class="s1">): IgnoreList | void {</span><span class="s3">\n  </span><span class="s1">const arr = assertArray(loc, value);</span><span class="s3">\n  </span><span class="s1">arr?.forEach((item, i) =&gt; assertIgnoreItem(access(loc, i), item));</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s3">\n  </span><span class="s1">return arr;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function assertIgnoreItem(loc: GeneralPath, value: unknown): IgnoreItem {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">typeof value !== </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof value !== </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">!(value instanceof RegExp)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`${msg(</span><span class="s3">\n        </span><span class="s1">loc,</span><span class="s3">\n      </span><span class="s1">)} must be an array of string/Function/RegExp values, or undefined`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return value as IgnoreItem;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assertConfigApplicableTest(</span><span class="s3">\n  </span><span class="s1">loc: OptionPath,</span><span class="s3">\n  </span><span class="s1">value: unknown,</span><span class="s3">\n</span><span class="s1">): ConfigApplicableTest | void {</span><span class="s3">\n  </span><span class="s1">if (value === undefined) {</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error: TS can only narrow down the type when </span><span class="s3">\&quot;</span><span class="s1">strictNullCheck</span><span class="s3">\&quot; </span><span class="s1">is true</span><span class="s3">\n    </span><span class="s1">return value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n    </span><span class="s1">value.forEach((item, i) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (!checkValidTest(item)) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`${msg(access(loc, i))} must be a string/Function/RegExp.`,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">} else if (!checkValidTest(value)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`${msg(loc)} must be a string/Function/RegExp, or an array of those`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return value as ConfigApplicableTest;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function checkValidTest(value: unknown): value is string | Function | RegExp {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">typeof value === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">typeof value === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">value instanceof RegExp</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assertConfigFileSearch(</span><span class="s3">\n  </span><span class="s1">loc: OptionPath,</span><span class="s3">\n  </span><span class="s1">value: unknown,</span><span class="s3">\n</span><span class="s1">): ConfigFileSearch | void {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">value !== undefined &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof value !== </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof value !== </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`${msg(loc)} must be a undefined, a boolean, a string, ` +</span><span class="s3">\n        </span><span class="s1">`got ${JSON.stringify(value)}`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error: TS can only narrow down the type when </span><span class="s3">\&quot;</span><span class="s1">strictNullCheck</span><span class="s3">\&quot; </span><span class="s1">is true</span><span class="s3">\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assertBabelrcSearch(</span><span class="s3">\n  </span><span class="s1">loc: OptionPath,</span><span class="s3">\n  </span><span class="s1">value: unknown,</span><span class="s3">\n</span><span class="s1">): BabelrcSearch | void {</span><span class="s3">\n  </span><span class="s1">if (value === undefined || typeof value === </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error: TS can only narrow down the type when </span><span class="s3">\&quot;</span><span class="s1">strictNullCheck</span><span class="s3">\&quot; </span><span class="s1">is true</span><span class="s3">\n    </span><span class="s1">return value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n    </span><span class="s1">value.forEach((item, i) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (!checkValidTest(item)) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`${msg(access(loc, i))} must be a string/Function/RegExp.`,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">} else if (!checkValidTest(value)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp ` +</span><span class="s3">\n        </span><span class="s1">`or an array of those, got ${JSON.stringify(value as any)}`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return value as BabelrcSearch;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assertPluginList(</span><span class="s3">\n  </span><span class="s1">loc: OptionPath,</span><span class="s3">\n  </span><span class="s1">value: unknown[] | null | undefined,</span><span class="s3">\n</span><span class="s1">): PluginList | void {</span><span class="s3">\n  </span><span class="s1">const arr = assertArray(loc, value);</span><span class="s3">\n  </span><span class="s1">if (arr) {</span><span class="s3">\n    </span><span class="s1">// Loop instead of using `.map` in order to preserve object identity</span><span class="s3">\n    </span><span class="s1">// for plugin array for use during config chain processing.</span><span class="s3">\n    </span><span class="s1">arr.forEach((item, i) =&gt; assertPluginItem(access(loc, i), item));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return arr as any;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function assertPluginItem(loc: GeneralPath, value: unknown): PluginItem {</span><span class="s3">\n  </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n    </span><span class="s1">if (value.length === 0) {</span><span class="s3">\n      </span><span class="s1">throw new Error(`${msg(loc)} must include an object`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (value.length &gt; 3) {</span><span class="s3">\n      </span><span class="s1">throw new Error(`${msg(loc)} may only be a two-tuple or three-tuple`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">assertPluginTarget(access(loc, 0), value[0]);</span><span class="s3">\n\n    </span><span class="s1">if (value.length &gt; 1) {</span><span class="s3">\n      </span><span class="s1">const opts = value[1];</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">opts !== undefined &amp;&amp;</span><span class="s3">\n        </span><span class="s1">opts !== false &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(typeof opts !== </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">|| Array.isArray(opts) || opts === null)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`${msg(access(loc, 1))} must be an object, false, or undefined`,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (value.length === 3) {</span><span class="s3">\n      </span><span class="s1">const name = value[2];</span><span class="s3">\n      </span><span class="s1">if (name !== undefined &amp;&amp; typeof name !== </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`${msg(access(loc, 2))} must be a string, or undefined`,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">assertPluginTarget(loc, value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s3">\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function assertPluginTarget(loc: GeneralPath, value: unknown): PluginTarget {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">(typeof value !== </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">|| !value) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof value !== </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof value !== </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(`${msg(loc)} must be a string, object, function`);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assertTargets(</span><span class="s3">\n  </span><span class="s1">loc: GeneralPath,</span><span class="s3">\n  </span><span class="s1">value: any,</span><span class="s3">\n</span><span class="s1">): TargetsListOrObject {</span><span class="s3">\n  </span><span class="s1">if (isBrowsersQueryValid(value)) return value;</span><span class="s3">\n\n  </span><span class="s1">if (typeof value !== </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">|| !value || Array.isArray(value)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`${msg(loc)} must be a string, an array of strings or an object`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const browsersLoc = access(loc, </span><span class="s3">\&quot;</span><span class="s1">browsers</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const esmodulesLoc = access(loc, </span><span class="s3">\&quot;</span><span class="s1">esmodules</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">assertBrowsersList(browsersLoc, value.browsers);</span><span class="s3">\n  </span><span class="s1">assertBoolean(esmodulesLoc, value.esmodules);</span><span class="s3">\n\n  </span><span class="s1">for (const key of Object.keys(value)) {</span><span class="s3">\n    </span><span class="s1">const val = value[key];</span><span class="s3">\n    </span><span class="s1">const subLoc = access(loc, key);</span><span class="s3">\n\n    </span><span class="s1">if (key === </span><span class="s3">\&quot;</span><span class="s1">esmodules</span><span class="s3">\&quot;</span><span class="s1">) assertBoolean(subLoc, val);</span><span class="s3">\n    </span><span class="s1">else if (key === </span><span class="s3">\&quot;</span><span class="s1">browsers</span><span class="s3">\&quot;</span><span class="s1">) assertBrowsersList(subLoc, val);</span><span class="s3">\n    </span><span class="s1">else if (!Object.hasOwnProperty.call(TargetNames, key)) {</span><span class="s3">\n      </span><span class="s1">const validTargets = Object.keys(TargetNames).join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`${msg(</span><span class="s3">\n          </span><span class="s1">subLoc,</span><span class="s3">\n        </span><span class="s1">)} is not a valid target. Supported targets are ${validTargets}`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else assertBrowserVersion(subLoc, val);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function assertBrowsersList(loc: GeneralPath, value: unknown) {</span><span class="s3">\n  </span><span class="s1">if (value !== undefined &amp;&amp; !isBrowsersQueryValid(value)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`${msg(loc)} must be undefined, a string or an array of strings`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function assertBrowserVersion(loc: GeneralPath, value: unknown) {</span><span class="s3">\n  </span><span class="s1">if (typeof value === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; Math.round(value) === value) return;</span><span class="s3">\n  </span><span class="s1">if (typeof value === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) return;</span><span class="s3">\n\n  </span><span class="s1">throw new Error(`${msg(loc)} must be a string or an integer number`);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assertAssumptions(</span><span class="s3">\n  </span><span class="s1">loc: GeneralPath,</span><span class="s3">\n  </span><span class="s1">value: { [key: string]: unknown },</span><span class="s3">\n</span><span class="s1">): { [name: string]: boolean } | void {</span><span class="s3">\n  </span><span class="s1">if (value === undefined) return;</span><span class="s3">\n\n  </span><span class="s1">if (typeof value !== </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">|| value === null) {</span><span class="s3">\n    </span><span class="s1">throw new Error(`${msg(loc)} must be an object or undefined.`);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// todo(flow-&gt;ts): remove any</span><span class="s3">\n  </span><span class="s1">let root: any = loc;</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">root = root.parent;</span><span class="s3">\n  </span><span class="s1">} while (root.type !== </span><span class="s3">\&quot;</span><span class="s1">root</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const inPreset = root.source === </span><span class="s3">\&quot;</span><span class="s1">preset</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n  </span><span class="s1">for (const name of Object.keys(value)) {</span><span class="s3">\n    </span><span class="s1">const subLoc = access(loc, name);</span><span class="s3">\n    </span><span class="s1">if (!assumptionsNames.has(name as AssumptionName)) {</span><span class="s3">\n      </span><span class="s1">throw new Error(`${msg(subLoc)} is not a supported assumption.`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof value[name] !== </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">throw new Error(`${msg(subLoc)} must be a boolean.`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (inPreset &amp;&amp; value[name] === false) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`${msg(subLoc)} cannot be set to 'false' inside presets.`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s3">\n  </span><span class="s1">return value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>