<html>
<head>
<title>transformer-legacy.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
transformer-legacy.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;buildClassDecorator&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;buildClassPrototype&quot;</span><span class="s0">,</span><span class="s1">&quot;buildGetDescriptor&quot;</span><span class="s0">,</span><span class="s1">&quot;buildGetObjectInitializer&quot;</span><span class="s0">,</span><span class="s1">&quot;WARNING_CALLS&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakSet&quot;</span><span class="s0">,</span><span class="s1">&quot;applyEnsureOrdering&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;decorators&quot;</span><span class="s0">,</span><span class="s1">&quot;isClass&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;acc&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;identDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;decorator&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDeclaredUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;applyClassDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;classPath&quot;</span><span class="s0">,</span><span class="s1">&quot;hasClassDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;dec&quot;</span><span class="s0">,</span><span class="s1">&quot;reverse&quot;</span><span class="s0">,</span><span class="s1">&quot;CLASS_REF&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;DECORATOR&quot;</span><span class="s0">,</span><span class="s1">&quot;INNER&quot;</span><span class="s0">,</span><span class="s1">&quot;classNode&quot;</span><span class="s0">,</span><span class="s1">&quot;_classNode$decorators&quot;</span><span class="s0">,</span><span class="s1">&quot;applyMethodDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;hasMethodDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;applyTargetDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$decorators&quot;</span><span class="s0">,</span><span class="s1">&quot;applyObjectDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;properties&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;decoratedProps&quot;</span><span class="s0">,</span><span class="s1">&quot;exprs&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;isLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;static&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;descriptor&quot;</span><span class="s0">,</span><span class="s1">&quot;initializer&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;functionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;returnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;nullLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;addHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;objectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;objectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;booleanLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;TEMP&quot;</span><span class="s0">,</span><span class="s1">&quot;TARGET&quot;</span><span class="s0">,</span><span class="s1">&quot;PROPERTY&quot;</span><span class="s0">,</span><span class="s1">&quot;decoratedClassToExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;toExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;visitor&quot;</span><span class="s0">,</span><span class="s1">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;decl&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;replacement&quot;</span><span class="s0">,</span><span class="s1">&quot;varDeclPath&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWithMultiple&quot;</span><span class="s0">,</span><span class="s1">&quot;exportNamedDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;exportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;declarations&quot;</span><span class="s0">,</span><span class="s1">&quot;registerDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;newPath&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;binding&quot;</span><span class="s0">,</span><span class="s1">&quot;getOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;decoratedClass&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;decoratedObject&quot;</span><span class="s0">,</span><span class="s1">&quot;AssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;CallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;_default&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/transformer-legacy.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// Fork of https://github.com/loganfsmyth/babel-plugin-proposal-decorators-legacy</span><span class="s3">\n\n</span><span class="s1">import { template, types as t, type PluginPass } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath, Visitor } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const buildClassDecorator = template.statement(`</span><span class="s3">\n  </span><span class="s1">DECORATOR(CLASS_REF = INNER) || CLASS_REF;</span><span class="s3">\n</span><span class="s1">`) as (replacements: {</span><span class="s3">\n  </span><span class="s1">DECORATOR: t.Expression;</span><span class="s3">\n  </span><span class="s1">CLASS_REF: t.Identifier;</span><span class="s3">\n  </span><span class="s1">INNER: t.Expression;</span><span class="s3">\n</span><span class="s1">}) =&gt; t.ExpressionStatement;</span><span class="s3">\n\n</span><span class="s1">const buildClassPrototype = template(`</span><span class="s3">\n  </span><span class="s1">CLASS_REF.prototype;</span><span class="s3">\n</span><span class="s1">`) as (replacements: { CLASS_REF: t.Identifier }) =&gt; t.ExpressionStatement;</span><span class="s3">\n\n</span><span class="s1">const buildGetDescriptor = template(`</span><span class="s3">\n    </span><span class="s1">Object.getOwnPropertyDescriptor(TARGET, PROPERTY);</span><span class="s3">\n</span><span class="s1">`) as (replacements: {</span><span class="s3">\n  </span><span class="s1">TARGET: t.Expression;</span><span class="s3">\n  </span><span class="s1">PROPERTY: t.Literal;</span><span class="s3">\n</span><span class="s1">}) =&gt; t.ExpressionStatement;</span><span class="s3">\n\n</span><span class="s1">const buildGetObjectInitializer = template(`</span><span class="s3">\n    </span><span class="s1">(TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {</span><span class="s3">\n        </span><span class="s1">enumerable: true,</span><span class="s3">\n        </span><span class="s1">configurable: true,</span><span class="s3">\n        </span><span class="s1">writable: true,</span><span class="s3">\n        </span><span class="s1">initializer: function(){</span><span class="s3">\n            </span><span class="s1">return TEMP;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">`) as (replacements: {</span><span class="s3">\n  </span><span class="s1">TEMP: t.Identifier;</span><span class="s3">\n  </span><span class="s1">TARGET: t.Expression;</span><span class="s3">\n  </span><span class="s1">PROPERTY: t.Literal;</span><span class="s3">\n</span><span class="s1">}) =&gt; t.ExpressionStatement;</span><span class="s3">\n\n</span><span class="s1">const WARNING_CALLS = new WeakSet();</span><span class="s3">\n\n</span><span class="s1">// legacy decorator does not support ClassAccessorProperty</span><span class="s3">\n</span><span class="s1">type ClassDecoratableElement =</span><span class="s3">\n  </span><span class="s1">| t.ClassMethod</span><span class="s3">\n  </span><span class="s1">| t.ClassPrivateMethod</span><span class="s3">\n  </span><span class="s1">| t.ClassProperty</span><span class="s3">\n  </span><span class="s1">| t.ClassPrivateProperty;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* If the decorator expressions are non-identifiers, hoist them to before the class so we can be sure</span><span class="s3">\n </span><span class="s1">* that they are evaluated in order.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function applyEnsureOrdering(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.ClassExpression | t.ObjectExpression&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// TODO: This should probably also hoist computed properties.</span><span class="s3">\n  </span><span class="s1">const decorators: t.Decorator[] = (</span><span class="s3">\n    </span><span class="s1">path.isClass()</span><span class="s3">\n      </span><span class="s1">? [</span><span class="s3">\n          </span><span class="s1">path,</span><span class="s3">\n          </span><span class="s1">...(path.get(</span><span class="s3">\&quot;</span><span class="s1">body.body</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;ClassDecoratableElement&gt;[]),</span><span class="s3">\n        </span><span class="s1">]</span><span class="s3">\n      </span><span class="s1">: path.get(</span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">).reduce(</span><span class="s3">\n    </span><span class="s1">(</span><span class="s3">\n      </span><span class="s1">acc: t.Decorator[],</span><span class="s3">\n      </span><span class="s1">prop: NodePath&lt;</span><span class="s3">\n        </span><span class="s1">t.ObjectMember | t.ClassExpression | ClassDecoratableElement</span><span class="s3">\n      </span><span class="s1">&gt;,</span><span class="s3">\n    </span><span class="s1">) =&gt; acc.concat(prop.node.decorators || []),</span><span class="s3">\n    </span><span class="s1">[],</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">const identDecorators = decorators.filter(</span><span class="s3">\n    </span><span class="s1">decorator =&gt; !t.isIdentifier(decorator.expression),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">if (identDecorators.length === 0) return;</span><span class="s3">\n\n  </span><span class="s1">return t.sequenceExpression(</span><span class="s3">\n    </span><span class="s1">identDecorators</span><span class="s3">\n      </span><span class="s1">.map((decorator): t.Expression =&gt; {</span><span class="s3">\n        </span><span class="s1">const expression = decorator.expression;</span><span class="s3">\n        </span><span class="s1">const id = (decorator.expression =</span><span class="s3">\n          </span><span class="s1">path.scope.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">dec</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">return t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, id, expression);</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">.concat([path.node]),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Given a class expression with class-level decorators, create a new expression</span><span class="s3">\n </span><span class="s1">* with the proper decorated behavior.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function applyClassDecorators(classPath: NodePath&lt;t.ClassExpression&gt;) {</span><span class="s3">\n  </span><span class="s1">if (!hasClassDecorators(classPath.node)) return;</span><span class="s3">\n\n  </span><span class="s1">const decorators = classPath.node.decorators || [];</span><span class="s3">\n  </span><span class="s1">classPath.node.decorators = null;</span><span class="s3">\n\n  </span><span class="s1">const name = classPath.scope.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">return decorators</span><span class="s3">\n    </span><span class="s1">.map(dec =&gt; dec.expression)</span><span class="s3">\n    </span><span class="s1">.reverse()</span><span class="s3">\n    </span><span class="s1">.reduce(function (acc, decorator) {</span><span class="s3">\n      </span><span class="s1">return buildClassDecorator({</span><span class="s3">\n        </span><span class="s1">CLASS_REF: t.cloneNode(name),</span><span class="s3">\n        </span><span class="s1">DECORATOR: t.cloneNode(decorator),</span><span class="s3">\n        </span><span class="s1">INNER: acc,</span><span class="s3">\n      </span><span class="s1">}).expression;</span><span class="s3">\n    </span><span class="s1">}, classPath.node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function hasClassDecorators(classNode: t.Class) {</span><span class="s3">\n  </span><span class="s1">return !!classNode.decorators?.length;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Given a class expression with method-level decorators, create a new expression</span><span class="s3">\n </span><span class="s1">* with the proper decorated behavior.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function applyMethodDecorators(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.ClassExpression&gt;,</span><span class="s3">\n  </span><span class="s1">state: PluginPass,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!hasMethodDecorators(path.node.body.body)) return;</span><span class="s3">\n\n  </span><span class="s1">return applyTargetDecorators(</span><span class="s3">\n    </span><span class="s1">path,</span><span class="s3">\n    </span><span class="s1">state,</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error ClassAccessorProperty is not supported in legacy decorator</span><span class="s3">\n    </span><span class="s1">path.node.body.body,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function hasMethodDecorators(</span><span class="s3">\n  </span><span class="s1">body: t.ClassBody[</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">] | t.ObjectExpression[</span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return body.some(</span><span class="s3">\n    </span><span class="s1">node =&gt;</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error decorators not in SpreadElement/StaticBlock</span><span class="s3">\n      </span><span class="s1">node.decorators?.length,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Given an object expression with property decorators, create a new expression</span><span class="s3">\n </span><span class="s1">* with the proper decorated behavior.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function applyObjectDecorators(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.ObjectExpression&gt;,</span><span class="s3">\n  </span><span class="s1">state: PluginPass,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!hasMethodDecorators(path.node.properties)) return;</span><span class="s3">\n\n  </span><span class="s1">return applyTargetDecorators(</span><span class="s3">\n    </span><span class="s1">path,</span><span class="s3">\n    </span><span class="s1">state,</span><span class="s3">\n    </span><span class="s1">path.node.properties.filter(</span><span class="s3">\n      </span><span class="s1">(prop): prop is t.ObjectMember =&gt; prop.type !== </span><span class="s3">\&quot;</span><span class="s1">SpreadElement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A helper to pull out property decorators into a sequence expression.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function applyTargetDecorators(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.ClassExpression | t.ObjectExpression&gt;,</span><span class="s3">\n  </span><span class="s1">state: PluginPass,</span><span class="s3">\n  </span><span class="s1">decoratedProps: (t.ObjectMember | ClassDecoratableElement)[],</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const name = path.scope.generateDeclaredUidIdentifier(</span><span class="s3">\n    </span><span class="s1">path.isClass() ? </span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">obj</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">const exprs = decoratedProps.reduce(function (acc, node) {</span><span class="s3">\n    </span><span class="s1">let decorators: t.Decorator[] = [];</span><span class="s3">\n    </span><span class="s1">if (node.decorators != null) {</span><span class="s3">\n      </span><span class="s1">decorators = node.decorators;</span><span class="s3">\n      </span><span class="s1">node.decorators = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (decorators.length === 0) return acc;</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error computed is not in ClassPrivateProperty</span><span class="s3">\n      </span><span class="s1">node.computed</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n        \&quot;</span><span class="s1">Computed method/property decorators are not yet supported.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const property: t.Literal = t.isLiteral(node.key)</span><span class="s3">\n      </span><span class="s1">? node.key</span><span class="s3">\n      </span><span class="s1">: t.stringLiteral(</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error: should we handle ClassPrivateProperty?</span><span class="s3">\n          </span><span class="s1">node.key.name,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">const target =</span><span class="s3">\n      </span><span class="s1">path.isClass() &amp;&amp; !(node as ClassDecoratableElement).static</span><span class="s3">\n        </span><span class="s1">? buildClassPrototype({</span><span class="s3">\n            </span><span class="s1">CLASS_REF: name,</span><span class="s3">\n          </span><span class="s1">}).expression</span><span class="s3">\n        </span><span class="s1">: name;</span><span class="s3">\n\n    </span><span class="s1">if (t.isClassProperty(node, { static: false })) {</span><span class="s3">\n      </span><span class="s1">const descriptor = path.scope.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">descriptor</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">const initializer = node.value</span><span class="s3">\n        </span><span class="s1">? t.functionExpression(</span><span class="s3">\n            </span><span class="s1">null,</span><span class="s3">\n            </span><span class="s1">[],</span><span class="s3">\n            </span><span class="s1">t.blockStatement([t.returnStatement(node.value)]),</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">: t.nullLiteral();</span><span class="s3">\n\n      </span><span class="s1">node.value = t.callExpression(</span><span class="s3">\n        </span><span class="s1">state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">initializerWarningHelper</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">[descriptor, t.thisExpression()],</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">WARNING_CALLS.add(node.value);</span><span class="s3">\n\n      </span><span class="s1">acc.push(</span><span class="s3">\n        </span><span class="s1">t.assignmentExpression(</span><span class="s3">\n          \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">t.cloneNode(descriptor),</span><span class="s3">\n          </span><span class="s1">t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">applyDecoratedDescriptor</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n            </span><span class="s1">t.cloneNode(target),</span><span class="s3">\n            </span><span class="s1">t.cloneNode(property),</span><span class="s3">\n            </span><span class="s1">t.arrayExpression(</span><span class="s3">\n              </span><span class="s1">decorators.map(dec =&gt; t.cloneNode(dec.expression)),</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">t.objectExpression([</span><span class="s3">\n              </span><span class="s1">t.objectProperty(</span><span class="s3">\n                </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">configurable</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n                </span><span class="s1">t.booleanLiteral(true),</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">t.objectProperty(</span><span class="s3">\n                </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">enumerable</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n                </span><span class="s1">t.booleanLiteral(true),</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">t.objectProperty(</span><span class="s3">\n                </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">writable</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n                </span><span class="s1">t.booleanLiteral(true),</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">t.objectProperty(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">initializer</span><span class="s3">\&quot;</span><span class="s1">), initializer),</span><span class="s3">\n            </span><span class="s1">]),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">acc.push(</span><span class="s3">\n        </span><span class="s1">t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">applyDecoratedDescriptor</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n          </span><span class="s1">t.cloneNode(target),</span><span class="s3">\n          </span><span class="s1">t.cloneNode(property),</span><span class="s3">\n          </span><span class="s1">t.arrayExpression(decorators.map(dec =&gt; t.cloneNode(dec.expression))),</span><span class="s3">\n          </span><span class="s1">t.isObjectProperty(node) || t.isClassProperty(node, { static: true })</span><span class="s3">\n            </span><span class="s1">? buildGetObjectInitializer({</span><span class="s3">\n                </span><span class="s1">TEMP: path.scope.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n                </span><span class="s1">TARGET: t.cloneNode(target),</span><span class="s3">\n                </span><span class="s1">PROPERTY: t.cloneNode(property),</span><span class="s3">\n              </span><span class="s1">}).expression</span><span class="s3">\n            </span><span class="s1">: buildGetDescriptor({</span><span class="s3">\n                </span><span class="s1">TARGET: t.cloneNode(target),</span><span class="s3">\n                </span><span class="s1">PROPERTY: t.cloneNode(property),</span><span class="s3">\n              </span><span class="s1">}).expression,</span><span class="s3">\n          </span><span class="s1">t.cloneNode(target),</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return acc;</span><span class="s3">\n  </span><span class="s1">}, []);</span><span class="s3">\n\n  </span><span class="s1">return t.sequenceExpression([</span><span class="s3">\n    </span><span class="s1">t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, t.cloneNode(name), path.node),</span><span class="s3">\n    </span><span class="s1">t.sequenceExpression(exprs),</span><span class="s3">\n    </span><span class="s1">t.cloneNode(name),</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function decoratedClassToExpression({ node, scope }: NodePath&lt;t.Class&gt;) {</span><span class="s3">\n  </span><span class="s1">if (!hasClassDecorators(node) &amp;&amp; !hasMethodDecorators(node.body.body)) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const ref = node.id</span><span class="s3">\n    </span><span class="s1">? t.cloneNode(node.id)</span><span class="s3">\n    </span><span class="s1">: scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">return t.variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n    </span><span class="s1">t.variableDeclarator(ref, t.toExpression(node)),</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const visitor: Visitor&lt;PluginPass&gt; = {</span><span class="s3">\n  </span><span class="s1">ExportDefaultDeclaration(path) {</span><span class="s3">\n    </span><span class="s1">const decl = path.get(</span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (!decl.isClassDeclaration()) return;</span><span class="s3">\n\n    </span><span class="s1">const replacement = decoratedClassToExpression(decl);</span><span class="s3">\n    </span><span class="s1">if (replacement) {</span><span class="s3">\n      </span><span class="s1">const [varDeclPath] = path.replaceWithMultiple([</span><span class="s3">\n        </span><span class="s1">replacement,</span><span class="s3">\n        </span><span class="s1">t.exportNamedDeclaration(null, [</span><span class="s3">\n          </span><span class="s1">t.exportSpecifier(</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) might be add more specific return type for decoratedClassToExpression</span><span class="s3">\n            </span><span class="s1">t.cloneNode(replacement.declarations[0].id),</span><span class="s3">\n            </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n\n      </span><span class="s1">if (!decl.node.id) {</span><span class="s3">\n        </span><span class="s1">path.scope.registerDeclaration(varDeclPath);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">ClassDeclaration(path) {</span><span class="s3">\n    </span><span class="s1">const replacement = decoratedClassToExpression(path);</span><span class="s3">\n    </span><span class="s1">if (replacement) {</span><span class="s3">\n      </span><span class="s1">const [newPath] = path.replaceWith(replacement);</span><span class="s3">\n\n      </span><span class="s1">const decl = newPath.get(</span><span class="s3">\&quot;</span><span class="s1">declarations.0</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const id = decl.node.id as t.Identifier;</span><span class="s3">\n\n      </span><span class="s1">// TODO: Maybe add this logic to @babel/traverse</span><span class="s3">\n      </span><span class="s1">const binding = path.scope.getOwnBinding(id.name);</span><span class="s3">\n      </span><span class="s1">binding.identifier = id;</span><span class="s3">\n      </span><span class="s1">binding.path = decl;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">ClassExpression(path, state) {</span><span class="s3">\n    </span><span class="s1">// Create a replacement for the class node if there is one. We do one pass to replace classes with</span><span class="s3">\n    </span><span class="s1">// class decorators, and a second pass to process method decorators.</span><span class="s3">\n    </span><span class="s1">const decoratedClass =</span><span class="s3">\n      </span><span class="s1">applyEnsureOrdering(path) ||</span><span class="s3">\n      </span><span class="s1">applyClassDecorators(path) ||</span><span class="s3">\n      </span><span class="s1">applyMethodDecorators(path, state);</span><span class="s3">\n\n    </span><span class="s1">if (decoratedClass) path.replaceWith(decoratedClass);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">ObjectExpression(path, state) {</span><span class="s3">\n    </span><span class="s1">const decoratedObject =</span><span class="s3">\n      </span><span class="s1">applyEnsureOrdering(path) || applyObjectDecorators(path, state);</span><span class="s3">\n\n    </span><span class="s1">if (decoratedObject) path.replaceWith(decoratedObject);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">AssignmentExpression(path, state) {</span><span class="s3">\n    </span><span class="s1">if (!WARNING_CALLS.has(path.node.right)) return;</span><span class="s3">\n\n    </span><span class="s1">path.replaceWith(</span><span class="s3">\n      </span><span class="s1">t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">initializerDefineProperty</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) typesafe NodePath.get</span><span class="s3">\n        </span><span class="s1">t.cloneNode(path.get(</span><span class="s3">\&quot;</span><span class="s1">left.object</span><span class="s3">\&quot;</span><span class="s1">).node),</span><span class="s3">\n        </span><span class="s1">t.stringLiteral(</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) typesafe NodePath.get</span><span class="s3">\n          </span><span class="s1">path.get(</span><span class="s3">\&quot;</span><span class="s1">left.property</span><span class="s3">\&quot;</span><span class="s1">).node.name ||</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) typesafe NodePath.get</span><span class="s3">\n            </span><span class="s1">path.get(</span><span class="s3">\&quot;</span><span class="s1">left.property</span><span class="s3">\&quot;</span><span class="s1">).node.value,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s3">\n        </span><span class="s1">t.cloneNode(path.get(</span><span class="s3">\&quot;</span><span class="s1">right.arguments</span><span class="s3">\&quot;</span><span class="s1">)[0].node),</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s3">\n        </span><span class="s1">t.cloneNode(path.get(</span><span class="s3">\&quot;</span><span class="s1">right.arguments</span><span class="s3">\&quot;</span><span class="s1">)[1].node),</span><span class="s3">\n      </span><span class="s1">]),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">CallExpression(path, state) {</span><span class="s3">\n    </span><span class="s1">if (path.node.arguments.length !== 3) return;</span><span class="s3">\n    </span><span class="s1">if (!WARNING_CALLS.has(path.node.arguments[2])) return;</span><span class="s3">\n\n    </span><span class="s1">// If the class properties plugin isn't enabled, this line will add an unused helper</span><span class="s3">\n    </span><span class="s1">// to the code. It's not ideal, but it's ok since the configuration is not valid anyway.</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) check that `callee` is Identifier</span><span class="s3">\n    </span><span class="s1">if (path.node.callee.name !== state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">defineProperty</span><span class="s3">\&quot;</span><span class="s1">).name) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">path.replaceWith(</span><span class="s3">\n      </span><span class="s1">t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">initializerDefineProperty</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n        </span><span class="s1">t.cloneNode(path.get(</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">)[0].node),</span><span class="s3">\n        </span><span class="s1">t.cloneNode(path.get(</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">)[1].node),</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s3">\n        </span><span class="s1">t.cloneNode(path.get(</span><span class="s3">\&quot;</span><span class="s1">arguments.2.arguments</span><span class="s3">\&quot;</span><span class="s1">)[0].node),</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s3">\n        </span><span class="s1">t.cloneNode(path.get(</span><span class="s3">\&quot;</span><span class="s1">arguments.2.arguments</span><span class="s3">\&quot;</span><span class="s1">)[1].node),</span><span class="s3">\n      </span><span class="s1">]),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default visitor;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>