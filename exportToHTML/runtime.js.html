<html>
<head>
<title>runtime.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
runtime.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Copyright (c) 2014-present, Facebook, Inc.</span>
 <span class="s0">*</span>
 <span class="s0">* This source code is licensed under the MIT license found in the</span>
 <span class="s0">* LICENSE file in the root directory of this source tree.</span>
 <span class="s0">*/</span>

<span class="s2">var </span><span class="s1">runtime </span><span class="s3">= (</span><span class="s2">function </span><span class="s3">(</span><span class="s1">exports</span><span class="s3">) {</span>
  <span class="s4">&quot;use strict&quot;</span><span class="s3">;</span>

  <span class="s2">var </span><span class="s1">Op </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">hasOwn </span><span class="s3">= </span><span class="s1">Op</span><span class="s3">.</span><span class="s1">hasOwnProperty</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">defineProperty </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">defineProperty </span><span class="s3">|| </span><span class="s2">function </span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">desc</span><span class="s3">) { </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">desc</span><span class="s3">.</span><span class="s1">value</span><span class="s3">; };</span>
  <span class="s2">var </span><span class="s1">undefined</span><span class="s3">; </span><span class="s5">// More compressible than void 0.</span>
  <span class="s2">var </span><span class="s1">$Symbol </span><span class="s3">= </span><span class="s2">typeof </span><span class="s1">Symbol </span><span class="s3">=== </span><span class="s4">&quot;function&quot; </span><span class="s3">? </span><span class="s1">Symbol </span><span class="s3">: {};</span>
  <span class="s2">var </span><span class="s1">iteratorSymbol </span><span class="s3">= </span><span class="s1">$Symbol</span><span class="s3">.</span><span class="s1">iterator </span><span class="s3">|| </span><span class="s4">&quot;@@iterator&quot;</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">asyncIteratorSymbol </span><span class="s3">= </span><span class="s1">$Symbol</span><span class="s3">.</span><span class="s1">asyncIterator </span><span class="s3">|| </span><span class="s4">&quot;@@asyncIterator&quot;</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">toStringTagSymbol </span><span class="s3">= </span><span class="s1">$Symbol</span><span class="s3">.</span><span class="s1">toStringTag </span><span class="s3">|| </span><span class="s4">&quot;@@toStringTag&quot;</span><span class="s3">;</span>

  <span class="s2">function </span><span class="s1">define</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">) {</span>
    <span class="s1">Object</span><span class="s3">.</span><span class="s1">defineProperty</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, {</span>
      <span class="s1">value</span><span class="s3">: </span><span class="s1">value</span><span class="s3">,</span>
      <span class="s1">enumerable</span><span class="s3">: </span><span class="s2">true</span><span class="s3">,</span>
      <span class="s1">configurable</span><span class="s3">: </span><span class="s2">true</span><span class="s3">,</span>
      <span class="s1">writable</span><span class="s3">: </span><span class="s2">true</span>
    <span class="s3">});</span>
    <span class="s2">return </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
  <span class="s3">}</span>
  <span class="s2">try </span><span class="s3">{</span>
    <span class="s5">// IE 8 has a broken Object.defineProperty that only works on DOM objects.</span>
    <span class="s1">define</span><span class="s3">({}, </span><span class="s4">&quot;&quot;</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">catch </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
    <span class="s1">define </span><span class="s3">= </span><span class="s2">function</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">) {</span>
      <span class="s2">return </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">value</span><span class="s3">;</span>
    <span class="s3">};</span>
  <span class="s3">}</span>

  <span class="s2">function </span><span class="s1">wrap</span><span class="s3">(</span><span class="s1">innerFn</span><span class="s3">, </span><span class="s1">outerFn</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">tryLocsList</span><span class="s3">) {</span>
    <span class="s5">// If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.</span>
    <span class="s2">var </span><span class="s1">protoGenerator </span><span class="s3">= </span><span class="s1">outerFn </span><span class="s3">&amp;&amp; </span><span class="s1">outerFn</span><span class="s3">.</span><span class="s1">prototype </span><span class="s2">instanceof </span><span class="s1">Generator </span><span class="s3">? </span><span class="s1">outerFn </span><span class="s3">: </span><span class="s1">Generator</span><span class="s3">;</span>
    <span class="s2">var </span><span class="s1">generator </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s1">protoGenerator</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">);</span>
    <span class="s2">var </span><span class="s1">context </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Context</span><span class="s3">(</span><span class="s1">tryLocsList </span><span class="s3">|| []);</span>

    <span class="s5">// The ._invoke method unifies the implementations of the .next,</span>
    <span class="s5">// .throw, and .return methods.</span>
    <span class="s1">defineProperty</span><span class="s3">(</span><span class="s1">generator</span><span class="s3">, </span><span class="s4">&quot;_invoke&quot;</span><span class="s3">, { </span><span class="s1">value</span><span class="s3">: </span><span class="s1">makeInvokeMethod</span><span class="s3">(</span><span class="s1">innerFn</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) });</span>

    <span class="s2">return </span><span class="s1">generator</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s1">exports</span><span class="s3">.</span><span class="s1">wrap </span><span class="s3">= </span><span class="s1">wrap</span><span class="s3">;</span>

  <span class="s5">// Try/catch helper to minimize deoptimizations. Returns a completion</span>
  <span class="s5">// record like context.tryEntries[i].completion. This interface could</span>
  <span class="s5">// have been (and was previously) designed to take a closure to be</span>
  <span class="s5">// invoked without arguments, but in all the cases we care about we</span>
  <span class="s5">// already have an existing method we want to call, so there's no need</span>
  <span class="s5">// to create a new function object. We can even get away with assuming</span>
  <span class="s5">// the method takes exactly one argument, since that happens to be true</span>
  <span class="s5">// in every case, so we don't have to touch the arguments object. The</span>
  <span class="s5">// only additional allocation required is the completion record, which</span>
  <span class="s5">// has a stable shape and so hopefully should be cheap to allocate.</span>
  <span class="s2">function </span><span class="s1">tryCatch</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">) {</span>
    <span class="s2">try </span><span class="s3">{</span>
      <span class="s2">return </span><span class="s3">{ </span><span class="s1">type</span><span class="s3">: </span><span class="s4">&quot;normal&quot;</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">: </span><span class="s1">fn</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">) };</span>
    <span class="s3">} </span><span class="s2">catch </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
      <span class="s2">return </span><span class="s3">{ </span><span class="s1">type</span><span class="s3">: </span><span class="s4">&quot;throw&quot;</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">: </span><span class="s1">err </span><span class="s3">};</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s2">var </span><span class="s1">GenStateSuspendedStart </span><span class="s3">= </span><span class="s4">&quot;suspendedStart&quot;</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">GenStateSuspendedYield </span><span class="s3">= </span><span class="s4">&quot;suspendedYield&quot;</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">GenStateExecuting </span><span class="s3">= </span><span class="s4">&quot;executing&quot;</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">GenStateCompleted </span><span class="s3">= </span><span class="s4">&quot;completed&quot;</span><span class="s3">;</span>

  <span class="s5">// Returning this object from the innerFn has the same effect as</span>
  <span class="s5">// breaking out of the dispatch switch statement.</span>
  <span class="s2">var </span><span class="s1">ContinueSentinel </span><span class="s3">= {};</span>

  <span class="s5">// Dummy constructor functions that we use as the .constructor and</span>
  <span class="s5">// .constructor.prototype properties for functions that return Generator</span>
  <span class="s5">// objects. For full spec compliance, you may wish to configure your</span>
  <span class="s5">// minifier not to mangle the names of these two functions.</span>
  <span class="s2">function </span><span class="s1">Generator</span><span class="s3">() {}</span>
  <span class="s2">function </span><span class="s1">GeneratorFunction</span><span class="s3">() {}</span>
  <span class="s2">function </span><span class="s1">GeneratorFunctionPrototype</span><span class="s3">() {}</span>

  <span class="s5">// This is a polyfill for %IteratorPrototype% for environments that</span>
  <span class="s5">// don't natively support it.</span>
  <span class="s2">var </span><span class="s1">IteratorPrototype </span><span class="s3">= {};</span>
  <span class="s1">define</span><span class="s3">(</span><span class="s1">IteratorPrototype</span><span class="s3">, </span><span class="s1">iteratorSymbol</span><span class="s3">, </span><span class="s2">function </span><span class="s3">() {</span>
    <span class="s2">return this</span><span class="s3">;</span>
  <span class="s3">});</span>

  <span class="s2">var </span><span class="s1">getProto </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">getPrototypeOf</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">NativeIteratorPrototype </span><span class="s3">= </span><span class="s1">getProto </span><span class="s3">&amp;&amp; </span><span class="s1">getProto</span><span class="s3">(</span><span class="s1">getProto</span><span class="s3">(</span><span class="s1">values</span><span class="s3">([])));</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">NativeIteratorPrototype </span><span class="s3">&amp;&amp;</span>
      <span class="s1">NativeIteratorPrototype </span><span class="s3">!== </span><span class="s1">Op </span><span class="s3">&amp;&amp;</span>
      <span class="s1">hasOwn</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">NativeIteratorPrototype</span><span class="s3">, </span><span class="s1">iteratorSymbol</span><span class="s3">)) {</span>
    <span class="s5">// This environment has a native %IteratorPrototype%; use it instead</span>
    <span class="s5">// of the polyfill.</span>
    <span class="s1">IteratorPrototype </span><span class="s3">= </span><span class="s1">NativeIteratorPrototype</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s2">var </span><span class="s1">Gp </span><span class="s3">= </span><span class="s1">GeneratorFunctionPrototype</span><span class="s3">.</span><span class="s1">prototype </span><span class="s3">=</span>
    <span class="s1">Generator</span><span class="s3">.</span><span class="s1">prototype </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s1">IteratorPrototype</span><span class="s3">);</span>
  <span class="s1">GeneratorFunction</span><span class="s3">.</span><span class="s1">prototype </span><span class="s3">= </span><span class="s1">GeneratorFunctionPrototype</span><span class="s3">;</span>
  <span class="s1">defineProperty</span><span class="s3">(</span><span class="s1">Gp</span><span class="s3">, </span><span class="s4">&quot;constructor&quot;</span><span class="s3">, { </span><span class="s1">value</span><span class="s3">: </span><span class="s1">GeneratorFunctionPrototype</span><span class="s3">, </span><span class="s1">configurable</span><span class="s3">: </span><span class="s2">true </span><span class="s3">});</span>
  <span class="s1">defineProperty</span><span class="s3">(</span>
    <span class="s1">GeneratorFunctionPrototype</span><span class="s3">,</span>
    <span class="s4">&quot;constructor&quot;</span><span class="s3">,</span>
    <span class="s3">{ </span><span class="s1">value</span><span class="s3">: </span><span class="s1">GeneratorFunction</span><span class="s3">, </span><span class="s1">configurable</span><span class="s3">: </span><span class="s2">true </span><span class="s3">}</span>
  <span class="s3">);</span>
  <span class="s1">GeneratorFunction</span><span class="s3">.</span><span class="s1">displayName </span><span class="s3">= </span><span class="s1">define</span><span class="s3">(</span>
    <span class="s1">GeneratorFunctionPrototype</span><span class="s3">,</span>
    <span class="s1">toStringTagSymbol</span><span class="s3">,</span>
    <span class="s4">&quot;GeneratorFunction&quot;</span>
  <span class="s3">);</span>

  <span class="s5">// Helper for defining the .next, .throw, and .return methods of the</span>
  <span class="s5">// Iterator interface in terms of a single ._invoke method.</span>
  <span class="s2">function </span><span class="s1">defineIteratorMethods</span><span class="s3">(</span><span class="s1">prototype</span><span class="s3">) {</span>
    <span class="s3">[</span><span class="s4">&quot;next&quot;</span><span class="s3">, </span><span class="s4">&quot;throw&quot;</span><span class="s3">, </span><span class="s4">&quot;return&quot;</span><span class="s3">].</span><span class="s1">forEach</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">method</span><span class="s3">) {</span>
      <span class="s1">define</span><span class="s3">(</span><span class="s1">prototype</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">) {</span>
        <span class="s2">return this</span><span class="s3">.</span><span class="s1">_invoke</span><span class="s3">(</span><span class="s1">method</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">);</span>
      <span class="s3">});</span>
    <span class="s3">});</span>
  <span class="s3">}</span>

  <span class="s1">exports</span><span class="s3">.</span><span class="s1">isGeneratorFunction </span><span class="s3">= </span><span class="s2">function</span><span class="s3">(</span><span class="s1">genFun</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">ctor </span><span class="s3">= </span><span class="s2">typeof </span><span class="s1">genFun </span><span class="s3">=== </span><span class="s4">&quot;function&quot; </span><span class="s3">&amp;&amp; </span><span class="s1">genFun</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>
    <span class="s2">return </span><span class="s1">ctor</span>
      <span class="s3">? </span><span class="s1">ctor </span><span class="s3">=== </span><span class="s1">GeneratorFunction </span><span class="s3">||</span>
        <span class="s5">// For the native GeneratorFunction constructor, the best we can</span>
        <span class="s5">// do is to check its .name property.</span>
        <span class="s3">(</span><span class="s1">ctor</span><span class="s3">.</span><span class="s1">displayName </span><span class="s3">|| </span><span class="s1">ctor</span><span class="s3">.</span><span class="s1">name</span><span class="s3">) === </span><span class="s4">&quot;GeneratorFunction&quot;</span>
      <span class="s3">: </span><span class="s2">false</span><span class="s3">;</span>
  <span class="s3">};</span>

  <span class="s1">exports</span><span class="s3">.</span><span class="s1">mark </span><span class="s3">= </span><span class="s2">function</span><span class="s3">(</span><span class="s1">genFun</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">Object</span><span class="s3">.</span><span class="s1">setPrototypeOf</span><span class="s3">) {</span>
      <span class="s1">Object</span><span class="s3">.</span><span class="s1">setPrototypeOf</span><span class="s3">(</span><span class="s1">genFun</span><span class="s3">, </span><span class="s1">GeneratorFunctionPrototype</span><span class="s3">);</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s1">genFun</span><span class="s3">.</span><span class="s1">__proto__ </span><span class="s3">= </span><span class="s1">GeneratorFunctionPrototype</span><span class="s3">;</span>
      <span class="s1">define</span><span class="s3">(</span><span class="s1">genFun</span><span class="s3">, </span><span class="s1">toStringTagSymbol</span><span class="s3">, </span><span class="s4">&quot;GeneratorFunction&quot;</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s1">genFun</span><span class="s3">.</span><span class="s1">prototype </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s1">Gp</span><span class="s3">);</span>
    <span class="s2">return </span><span class="s1">genFun</span><span class="s3">;</span>
  <span class="s3">};</span>

  <span class="s5">// Within the body of any async function, `await x` is transformed to</span>
  <span class="s5">// `yield regeneratorRuntime.awrap(x)`, so that the runtime can test</span>
  <span class="s5">// `hasOwn.call(value, &quot;__await&quot;)` to determine if the yielded value is</span>
  <span class="s5">// meant to be awaited.</span>
  <span class="s1">exports</span><span class="s3">.</span><span class="s1">awrap </span><span class="s3">= </span><span class="s2">function</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">) {</span>
    <span class="s2">return </span><span class="s3">{ </span><span class="s1">__await</span><span class="s3">: </span><span class="s1">arg </span><span class="s3">};</span>
  <span class="s3">};</span>

  <span class="s2">function </span><span class="s1">AsyncIterator</span><span class="s3">(</span><span class="s1">generator</span><span class="s3">, </span><span class="s1">PromiseImpl</span><span class="s3">) {</span>
    <span class="s2">function </span><span class="s1">invoke</span><span class="s3">(</span><span class="s1">method</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">, </span><span class="s1">resolve</span><span class="s3">, </span><span class="s1">reject</span><span class="s3">) {</span>
      <span class="s2">var </span><span class="s1">record </span><span class="s3">= </span><span class="s1">tryCatch</span><span class="s3">(</span><span class="s1">generator</span><span class="s3">[</span><span class="s1">method</span><span class="s3">], </span><span class="s1">generator</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">);</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">record</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">&quot;throw&quot;</span><span class="s3">) {</span>
        <span class="s1">reject</span><span class="s3">(</span><span class="s1">record</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">);</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
        <span class="s2">var </span><span class="s1">result </span><span class="s3">= </span><span class="s1">record</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">;</span>
        <span class="s2">var </span><span class="s1">value </span><span class="s3">= </span><span class="s1">result</span><span class="s3">.</span><span class="s1">value</span><span class="s3">;</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">value </span><span class="s3">&amp;&amp;</span>
            <span class="s2">typeof </span><span class="s1">value </span><span class="s3">=== </span><span class="s4">&quot;object&quot; </span><span class="s3">&amp;&amp;</span>
            <span class="s1">hasOwn</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s4">&quot;__await&quot;</span><span class="s3">)) {</span>
          <span class="s2">return </span><span class="s1">PromiseImpl</span><span class="s3">.</span><span class="s1">resolve</span><span class="s3">(</span><span class="s1">value</span><span class="s3">.</span><span class="s1">__await</span><span class="s3">).</span><span class="s1">then</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">value</span><span class="s3">) {</span>
            <span class="s1">invoke</span><span class="s3">(</span><span class="s4">&quot;next&quot;</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">resolve</span><span class="s3">, </span><span class="s1">reject</span><span class="s3">);</span>
          <span class="s3">}, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
            <span class="s1">invoke</span><span class="s3">(</span><span class="s4">&quot;throw&quot;</span><span class="s3">, </span><span class="s1">err</span><span class="s3">, </span><span class="s1">resolve</span><span class="s3">, </span><span class="s1">reject</span><span class="s3">);</span>
          <span class="s3">});</span>
        <span class="s3">}</span>

        <span class="s2">return </span><span class="s1">PromiseImpl</span><span class="s3">.</span><span class="s1">resolve</span><span class="s3">(</span><span class="s1">value</span><span class="s3">).</span><span class="s1">then</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">unwrapped</span><span class="s3">) {</span>
          <span class="s5">// When a yielded Promise is resolved, its final value becomes</span>
          <span class="s5">// the .value of the Promise&lt;{value,done}&gt; result for the</span>
          <span class="s5">// current iteration.</span>
          <span class="s1">result</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">unwrapped</span><span class="s3">;</span>
          <span class="s1">resolve</span><span class="s3">(</span><span class="s1">result</span><span class="s3">);</span>
        <span class="s3">}, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">error</span><span class="s3">) {</span>
          <span class="s5">// If a rejected Promise was yielded, throw the rejection back</span>
          <span class="s5">// into the async generator function so it can be handled there.</span>
          <span class="s2">return </span><span class="s1">invoke</span><span class="s3">(</span><span class="s4">&quot;throw&quot;</span><span class="s3">, </span><span class="s1">error</span><span class="s3">, </span><span class="s1">resolve</span><span class="s3">, </span><span class="s1">reject</span><span class="s3">);</span>
        <span class="s3">});</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s2">var </span><span class="s1">previousPromise</span><span class="s3">;</span>

    <span class="s2">function </span><span class="s1">enqueue</span><span class="s3">(</span><span class="s1">method</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">) {</span>
      <span class="s2">function </span><span class="s1">callInvokeWithMethodAndArg</span><span class="s3">() {</span>
        <span class="s2">return new </span><span class="s1">PromiseImpl</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">resolve</span><span class="s3">, </span><span class="s1">reject</span><span class="s3">) {</span>
          <span class="s1">invoke</span><span class="s3">(</span><span class="s1">method</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">, </span><span class="s1">resolve</span><span class="s3">, </span><span class="s1">reject</span><span class="s3">);</span>
        <span class="s3">});</span>
      <span class="s3">}</span>

      <span class="s2">return </span><span class="s1">previousPromise </span><span class="s3">=</span>
        <span class="s5">// If enqueue has been called before, then we want to wait until</span>
        <span class="s5">// all previous Promises have been resolved before calling invoke,</span>
        <span class="s5">// so that results are always delivered in the correct order. If</span>
        <span class="s5">// enqueue has not been called before, then it is important to</span>
        <span class="s5">// call invoke immediately, without waiting on a callback to fire,</span>
        <span class="s5">// so that the async generator function has the opportunity to do</span>
        <span class="s5">// any necessary setup in a predictable way. This predictability</span>
        <span class="s5">// is why the Promise constructor synchronously invokes its</span>
        <span class="s5">// executor callback, and why async functions synchronously</span>
        <span class="s5">// execute code before the first await. Since we implement simple</span>
        <span class="s5">// async functions in terms of async generators, it is especially</span>
        <span class="s5">// important to get this right, even though it requires care.</span>
        <span class="s1">previousPromise </span><span class="s3">? </span><span class="s1">previousPromise</span><span class="s3">.</span><span class="s1">then</span><span class="s3">(</span>
          <span class="s1">callInvokeWithMethodAndArg</span><span class="s3">,</span>
          <span class="s5">// Avoid propagating failures to Promises returned by later</span>
          <span class="s5">// invocations of the iterator.</span>
          <span class="s1">callInvokeWithMethodAndArg</span>
        <span class="s3">) : </span><span class="s1">callInvokeWithMethodAndArg</span><span class="s3">();</span>
    <span class="s3">}</span>

    <span class="s5">// Define the unified helper method that is used to implement .next,</span>
    <span class="s5">// .throw, and .return (see defineIteratorMethods).</span>
    <span class="s1">defineProperty</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s4">&quot;_invoke&quot;</span><span class="s3">, { </span><span class="s1">value</span><span class="s3">: </span><span class="s1">enqueue </span><span class="s3">});</span>
  <span class="s3">}</span>

  <span class="s1">defineIteratorMethods</span><span class="s3">(</span><span class="s1">AsyncIterator</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">);</span>
  <span class="s1">define</span><span class="s3">(</span><span class="s1">AsyncIterator</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">, </span><span class="s1">asyncIteratorSymbol</span><span class="s3">, </span><span class="s2">function </span><span class="s3">() {</span>
    <span class="s2">return this</span><span class="s3">;</span>
  <span class="s3">});</span>
  <span class="s1">exports</span><span class="s3">.</span><span class="s1">AsyncIterator </span><span class="s3">= </span><span class="s1">AsyncIterator</span><span class="s3">;</span>

  <span class="s5">// Note that simple async functions are implemented on top of</span>
  <span class="s5">// AsyncIterator objects; they just return a Promise for the value of</span>
  <span class="s5">// the final result produced by the iterator.</span>
  <span class="s1">exports</span><span class="s3">.</span><span class="s1">async </span><span class="s3">= </span><span class="s2">function</span><span class="s3">(</span><span class="s1">innerFn</span><span class="s3">, </span><span class="s1">outerFn</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">tryLocsList</span><span class="s3">, </span><span class="s1">PromiseImpl</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">PromiseImpl </span><span class="s3">=== </span><span class="s2">void </span><span class="s6">0</span><span class="s3">) </span><span class="s1">PromiseImpl </span><span class="s3">= </span><span class="s1">Promise</span><span class="s3">;</span>

    <span class="s2">var </span><span class="s1">iter </span><span class="s3">= </span><span class="s2">new </span><span class="s1">AsyncIterator</span><span class="s3">(</span>
      <span class="s1">wrap</span><span class="s3">(</span><span class="s1">innerFn</span><span class="s3">, </span><span class="s1">outerFn</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">tryLocsList</span><span class="s3">),</span>
      <span class="s1">PromiseImpl</span>
    <span class="s3">);</span>

    <span class="s2">return </span><span class="s1">exports</span><span class="s3">.</span><span class="s1">isGeneratorFunction</span><span class="s3">(</span><span class="s1">outerFn</span><span class="s3">)</span>
      <span class="s3">? </span><span class="s1">iter </span><span class="s5">// If outerFn is a generator, return the full iterator.</span>
      <span class="s3">: </span><span class="s1">iter</span><span class="s3">.</span><span class="s1">next</span><span class="s3">().</span><span class="s1">then</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">result</span><span class="s3">) {</span>
          <span class="s2">return </span><span class="s1">result</span><span class="s3">.</span><span class="s1">done </span><span class="s3">? </span><span class="s1">result</span><span class="s3">.</span><span class="s1">value </span><span class="s3">: </span><span class="s1">iter</span><span class="s3">.</span><span class="s1">next</span><span class="s3">();</span>
        <span class="s3">});</span>
  <span class="s3">};</span>

  <span class="s2">function </span><span class="s1">makeInvokeMethod</span><span class="s3">(</span><span class="s1">innerFn</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">state </span><span class="s3">= </span><span class="s1">GenStateSuspendedStart</span><span class="s3">;</span>

    <span class="s2">return function </span><span class="s1">invoke</span><span class="s3">(</span><span class="s1">method</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">state </span><span class="s3">=== </span><span class="s1">GenStateExecuting</span><span class="s3">) {</span>
        <span class="s2">throw new </span><span class="s1">Error</span><span class="s3">(</span><span class="s4">&quot;Generator is already running&quot;</span><span class="s3">);</span>
      <span class="s3">}</span>

      <span class="s2">if </span><span class="s3">(</span><span class="s1">state </span><span class="s3">=== </span><span class="s1">GenStateCompleted</span><span class="s3">) {</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">method </span><span class="s3">=== </span><span class="s4">&quot;throw&quot;</span><span class="s3">) {</span>
          <span class="s2">throw </span><span class="s1">arg</span><span class="s3">;</span>
        <span class="s3">}</span>

        <span class="s5">// Be forgiving, per 25.3.3.3.3 of the spec:</span>
        <span class="s5">// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume</span>
        <span class="s2">return </span><span class="s1">doneResult</span><span class="s3">();</span>
      <span class="s3">}</span>

      <span class="s1">context</span><span class="s3">.</span><span class="s1">method </span><span class="s3">= </span><span class="s1">method</span><span class="s3">;</span>
      <span class="s1">context</span><span class="s3">.</span><span class="s1">arg </span><span class="s3">= </span><span class="s1">arg</span><span class="s3">;</span>

      <span class="s2">while </span><span class="s3">(</span><span class="s2">true</span><span class="s3">) {</span>
        <span class="s2">var </span><span class="s1">delegate </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">delegate</span><span class="s3">;</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">delegate</span><span class="s3">) {</span>
          <span class="s2">var </span><span class="s1">delegateResult </span><span class="s3">= </span><span class="s1">maybeInvokeDelegate</span><span class="s3">(</span><span class="s1">delegate</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
          <span class="s2">if </span><span class="s3">(</span><span class="s1">delegateResult</span><span class="s3">) {</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">delegateResult </span><span class="s3">=== </span><span class="s1">ContinueSentinel</span><span class="s3">) </span><span class="s2">continue</span><span class="s3">;</span>
            <span class="s2">return </span><span class="s1">delegateResult</span><span class="s3">;</span>
          <span class="s3">}</span>
        <span class="s3">}</span>

        <span class="s2">if </span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">method </span><span class="s3">=== </span><span class="s4">&quot;next&quot;</span><span class="s3">) {</span>
          <span class="s5">// Setting context._sent for legacy support of Babel's</span>
          <span class="s5">// function.sent implementation.</span>
          <span class="s1">context</span><span class="s3">.</span><span class="s1">sent </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">_sent </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">;</span>

        <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">method </span><span class="s3">=== </span><span class="s4">&quot;throw&quot;</span><span class="s3">) {</span>
          <span class="s2">if </span><span class="s3">(</span><span class="s1">state </span><span class="s3">=== </span><span class="s1">GenStateSuspendedStart</span><span class="s3">) {</span>
            <span class="s1">state </span><span class="s3">= </span><span class="s1">GenStateCompleted</span><span class="s3">;</span>
            <span class="s2">throw </span><span class="s1">context</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">;</span>
          <span class="s3">}</span>

          <span class="s1">context</span><span class="s3">.</span><span class="s1">dispatchException</span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">);</span>

        <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">method </span><span class="s3">=== </span><span class="s4">&quot;return&quot;</span><span class="s3">) {</span>
          <span class="s1">context</span><span class="s3">.</span><span class="s1">abrupt</span><span class="s3">(</span><span class="s4">&quot;return&quot;</span><span class="s3">, </span><span class="s1">context</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">);</span>
        <span class="s3">}</span>

        <span class="s1">state </span><span class="s3">= </span><span class="s1">GenStateExecuting</span><span class="s3">;</span>

        <span class="s2">var </span><span class="s1">record </span><span class="s3">= </span><span class="s1">tryCatch</span><span class="s3">(</span><span class="s1">innerFn</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">record</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">&quot;normal&quot;</span><span class="s3">) {</span>
          <span class="s5">// If an exception is thrown from innerFn, we leave state ===</span>
          <span class="s5">// GenStateExecuting and loop back for another invocation.</span>
          <span class="s1">state </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">done</span>
            <span class="s3">? </span><span class="s1">GenStateCompleted</span>
            <span class="s3">: </span><span class="s1">GenStateSuspendedYield</span><span class="s3">;</span>

          <span class="s2">if </span><span class="s3">(</span><span class="s1">record</span><span class="s3">.</span><span class="s1">arg </span><span class="s3">=== </span><span class="s1">ContinueSentinel</span><span class="s3">) {</span>
            <span class="s2">continue</span><span class="s3">;</span>
          <span class="s3">}</span>

          <span class="s2">return </span><span class="s3">{</span>
            <span class="s1">value</span><span class="s3">: </span><span class="s1">record</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">,</span>
            <span class="s1">done</span><span class="s3">: </span><span class="s1">context</span><span class="s3">.</span><span class="s1">done</span>
          <span class="s3">};</span>

        <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">record</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">&quot;throw&quot;</span><span class="s3">) {</span>
          <span class="s1">state </span><span class="s3">= </span><span class="s1">GenStateCompleted</span><span class="s3">;</span>
          <span class="s5">// Dispatch the exception by looping back around to the</span>
          <span class="s5">// context.dispatchException(context.arg) call above.</span>
          <span class="s1">context</span><span class="s3">.</span><span class="s1">method </span><span class="s3">= </span><span class="s4">&quot;throw&quot;</span><span class="s3">;</span>
          <span class="s1">context</span><span class="s3">.</span><span class="s1">arg </span><span class="s3">= </span><span class="s1">record</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">;</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
    <span class="s3">};</span>
  <span class="s3">}</span>

  <span class="s5">// Call delegate.iterator[context.method](context.arg) and handle the</span>
  <span class="s5">// result, either by returning a { value, done } result from the</span>
  <span class="s5">// delegate iterator, or by modifying context.method and context.arg,</span>
  <span class="s5">// setting context.delegate to null, and returning the ContinueSentinel.</span>
  <span class="s2">function </span><span class="s1">maybeInvokeDelegate</span><span class="s3">(</span><span class="s1">delegate</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">methodName </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">method</span><span class="s3">;</span>
    <span class="s2">var </span><span class="s1">method </span><span class="s3">= </span><span class="s1">delegate</span><span class="s3">.</span><span class="s1">iterator</span><span class="s3">[</span><span class="s1">methodName</span><span class="s3">];</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">method </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
      <span class="s5">// A .throw or .return when the delegate iterator has no .throw</span>
      <span class="s5">// method, or a missing .next mehtod, always terminate the</span>
      <span class="s5">// yield* loop.</span>
      <span class="s1">context</span><span class="s3">.</span><span class="s1">delegate </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>

      <span class="s5">// Note: [&quot;return&quot;] must be used for ES3 parsing compatibility.</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">methodName </span><span class="s3">=== </span><span class="s4">&quot;throw&quot; </span><span class="s3">&amp;&amp; </span><span class="s1">delegate</span><span class="s3">.</span><span class="s1">iterator</span><span class="s3">[</span><span class="s4">&quot;return&quot;</span><span class="s3">]) {</span>
        <span class="s5">// If the delegate iterator has a return method, give it a</span>
        <span class="s5">// chance to clean up.</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">method </span><span class="s3">= </span><span class="s4">&quot;return&quot;</span><span class="s3">;</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">arg </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s1">maybeInvokeDelegate</span><span class="s3">(</span><span class="s1">delegate</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>

        <span class="s2">if </span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">method </span><span class="s3">=== </span><span class="s4">&quot;throw&quot;</span><span class="s3">) {</span>
          <span class="s5">// If maybeInvokeDelegate(context) changed context.method from</span>
          <span class="s5">// &quot;return&quot; to &quot;throw&quot;, let that override the TypeError below.</span>
          <span class="s2">return </span><span class="s1">ContinueSentinel</span><span class="s3">;</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">methodName </span><span class="s3">!== </span><span class="s4">&quot;return&quot;</span><span class="s3">) {</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">method </span><span class="s3">= </span><span class="s4">&quot;throw&quot;</span><span class="s3">;</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">arg </span><span class="s3">= </span><span class="s2">new </span><span class="s1">TypeError</span><span class="s3">(</span>
          <span class="s4">&quot;The iterator does not provide a '&quot; </span><span class="s3">+ </span><span class="s1">methodName </span><span class="s3">+ </span><span class="s4">&quot;' method&quot;</span><span class="s3">);</span>
      <span class="s3">}</span>

      <span class="s2">return </span><span class="s1">ContinueSentinel</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s2">var </span><span class="s1">record </span><span class="s3">= </span><span class="s1">tryCatch</span><span class="s3">(</span><span class="s1">method</span><span class="s3">, </span><span class="s1">delegate</span><span class="s3">.</span><span class="s1">iterator</span><span class="s3">, </span><span class="s1">context</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">);</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">record</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">&quot;throw&quot;</span><span class="s3">) {</span>
      <span class="s1">context</span><span class="s3">.</span><span class="s1">method </span><span class="s3">= </span><span class="s4">&quot;throw&quot;</span><span class="s3">;</span>
      <span class="s1">context</span><span class="s3">.</span><span class="s1">arg </span><span class="s3">= </span><span class="s1">record</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">;</span>
      <span class="s1">context</span><span class="s3">.</span><span class="s1">delegate </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
      <span class="s2">return </span><span class="s1">ContinueSentinel</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s2">var </span><span class="s1">info </span><span class="s3">= </span><span class="s1">record</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">;</span>

    <span class="s2">if </span><span class="s3">(! </span><span class="s1">info</span><span class="s3">) {</span>
      <span class="s1">context</span><span class="s3">.</span><span class="s1">method </span><span class="s3">= </span><span class="s4">&quot;throw&quot;</span><span class="s3">;</span>
      <span class="s1">context</span><span class="s3">.</span><span class="s1">arg </span><span class="s3">= </span><span class="s2">new </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;iterator result is not an object&quot;</span><span class="s3">);</span>
      <span class="s1">context</span><span class="s3">.</span><span class="s1">delegate </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
      <span class="s2">return </span><span class="s1">ContinueSentinel</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">done</span><span class="s3">) {</span>
      <span class="s5">// Assign the result of the finished delegate to the temporary</span>
      <span class="s5">// variable specified by delegate.resultName (see delegateYield).</span>
      <span class="s1">context</span><span class="s3">[</span><span class="s1">delegate</span><span class="s3">.</span><span class="s1">resultName</span><span class="s3">] = </span><span class="s1">info</span><span class="s3">.</span><span class="s1">value</span><span class="s3">;</span>

      <span class="s5">// Resume execution at the desired location (see delegateYield).</span>
      <span class="s1">context</span><span class="s3">.</span><span class="s1">next </span><span class="s3">= </span><span class="s1">delegate</span><span class="s3">.</span><span class="s1">nextLoc</span><span class="s3">;</span>

      <span class="s5">// If context.method was &quot;throw&quot; but the delegate handled the</span>
      <span class="s5">// exception, let the outer generator proceed normally. If</span>
      <span class="s5">// context.method was &quot;next&quot;, forget context.arg since it has been</span>
      <span class="s5">// &quot;consumed&quot; by the delegate iterator. If context.method was</span>
      <span class="s5">// &quot;return&quot;, allow the original .return call to continue in the</span>
      <span class="s5">// outer generator.</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">method </span><span class="s3">!== </span><span class="s4">&quot;return&quot;</span><span class="s3">) {</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">method </span><span class="s3">= </span><span class="s4">&quot;next&quot;</span><span class="s3">;</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">arg </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
      <span class="s3">}</span>

    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s5">// Re-yield the result returned by the delegate method.</span>
      <span class="s2">return </span><span class="s1">info</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s5">// The delegate iterator is finished, so forget it and continue with</span>
    <span class="s5">// the outer generator.</span>
    <span class="s1">context</span><span class="s3">.</span><span class="s1">delegate </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
    <span class="s2">return </span><span class="s1">ContinueSentinel</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s5">// Define Generator.prototype.{next,throw,return} in terms of the</span>
  <span class="s5">// unified ._invoke helper method.</span>
  <span class="s1">defineIteratorMethods</span><span class="s3">(</span><span class="s1">Gp</span><span class="s3">);</span>

  <span class="s1">define</span><span class="s3">(</span><span class="s1">Gp</span><span class="s3">, </span><span class="s1">toStringTagSymbol</span><span class="s3">, </span><span class="s4">&quot;Generator&quot;</span><span class="s3">);</span>

  <span class="s5">// A Generator should always return itself as the iterator object when the</span>
  <span class="s5">// @@iterator function is called on it. Some browsers' implementations of the</span>
  <span class="s5">// iterator prototype chain incorrectly implement this, causing the Generator</span>
  <span class="s5">// object to not be returned from this call. This ensures that doesn't happen.</span>
  <span class="s5">// See https://github.com/facebook/regenerator/issues/274 for more details.</span>
  <span class="s1">define</span><span class="s3">(</span><span class="s1">Gp</span><span class="s3">, </span><span class="s1">iteratorSymbol</span><span class="s3">, </span><span class="s2">function</span><span class="s3">() {</span>
    <span class="s2">return this</span><span class="s3">;</span>
  <span class="s3">});</span>

  <span class="s1">define</span><span class="s3">(</span><span class="s1">Gp</span><span class="s3">, </span><span class="s4">&quot;toString&quot;</span><span class="s3">, </span><span class="s2">function</span><span class="s3">() {</span>
    <span class="s2">return </span><span class="s4">&quot;[object Generator]&quot;</span><span class="s3">;</span>
  <span class="s3">});</span>

  <span class="s2">function </span><span class="s1">pushTryEntry</span><span class="s3">(</span><span class="s1">locs</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">entry </span><span class="s3">= { </span><span class="s1">tryLoc</span><span class="s3">: </span><span class="s1">locs</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] };</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s6">1 </span><span class="s2">in </span><span class="s1">locs</span><span class="s3">) {</span>
      <span class="s1">entry</span><span class="s3">.</span><span class="s1">catchLoc </span><span class="s3">= </span><span class="s1">locs</span><span class="s3">[</span><span class="s6">1</span><span class="s3">];</span>
    <span class="s3">}</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s6">2 </span><span class="s2">in </span><span class="s1">locs</span><span class="s3">) {</span>
      <span class="s1">entry</span><span class="s3">.</span><span class="s1">finallyLoc </span><span class="s3">= </span><span class="s1">locs</span><span class="s3">[</span><span class="s6">2</span><span class="s3">];</span>
      <span class="s1">entry</span><span class="s3">.</span><span class="s1">afterLoc </span><span class="s3">= </span><span class="s1">locs</span><span class="s3">[</span><span class="s6">3</span><span class="s3">];</span>
    <span class="s3">}</span>

    <span class="s2">this</span><span class="s3">.</span><span class="s1">tryEntries</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s2">function </span><span class="s1">resetTryEntry</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">record </span><span class="s3">= </span><span class="s1">entry</span><span class="s3">.</span><span class="s1">completion </span><span class="s3">|| {};</span>
    <span class="s1">record</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">&quot;normal&quot;</span><span class="s3">;</span>
    <span class="s2">delete </span><span class="s1">record</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">;</span>
    <span class="s1">entry</span><span class="s3">.</span><span class="s1">completion </span><span class="s3">= </span><span class="s1">record</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s2">function </span><span class="s1">Context</span><span class="s3">(</span><span class="s1">tryLocsList</span><span class="s3">) {</span>
    <span class="s5">// The root entry object (effectively a try statement without a catch</span>
    <span class="s5">// or a finally block) gives us a place to store values thrown from</span>
    <span class="s5">// locations where there is no enclosing try statement.</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">tryEntries </span><span class="s3">= [{ </span><span class="s1">tryLoc</span><span class="s3">: </span><span class="s4">&quot;root&quot; </span><span class="s3">}];</span>
    <span class="s1">tryLocsList</span><span class="s3">.</span><span class="s1">forEach</span><span class="s3">(</span><span class="s1">pushTryEntry</span><span class="s3">, </span><span class="s2">this</span><span class="s3">);</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">reset</span><span class="s3">(</span><span class="s2">true</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s1">exports</span><span class="s3">.</span><span class="s1">keys </span><span class="s3">= </span><span class="s2">function</span><span class="s3">(</span><span class="s1">val</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">object </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">(</span><span class="s1">val</span><span class="s3">);</span>
    <span class="s2">var </span><span class="s1">keys </span><span class="s3">= [];</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">object</span><span class="s3">) {</span>
      <span class="s1">keys</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s1">keys</span><span class="s3">.</span><span class="s1">reverse</span><span class="s3">();</span>

    <span class="s5">// Rather than returning an object with a next method, we keep</span>
    <span class="s5">// things simple and return the next function itself.</span>
    <span class="s2">return function </span><span class="s1">next</span><span class="s3">() {</span>
      <span class="s2">while </span><span class="s3">(</span><span class="s1">keys</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) {</span>
        <span class="s2">var </span><span class="s1">key </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">();</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">key </span><span class="s2">in </span><span class="s1">object</span><span class="s3">) {</span>
          <span class="s1">next</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">key</span><span class="s3">;</span>
          <span class="s1">next</span><span class="s3">.</span><span class="s1">done </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
          <span class="s2">return </span><span class="s1">next</span><span class="s3">;</span>
        <span class="s3">}</span>
      <span class="s3">}</span>

      <span class="s5">// To avoid creating an additional object, we just hang the .value</span>
      <span class="s5">// and .done properties off the next function object itself. This</span>
      <span class="s5">// also ensures that the minifier will not anonymize the function.</span>
      <span class="s1">next</span><span class="s3">.</span><span class="s1">done </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>
      <span class="s2">return </span><span class="s1">next</span><span class="s3">;</span>
    <span class="s3">};</span>
  <span class="s3">};</span>

  <span class="s2">function </span><span class="s1">values</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">iterable </span><span class="s3">|| </span><span class="s1">iterable </span><span class="s3">=== </span><span class="s4">&quot;&quot;</span><span class="s3">) {</span>
      <span class="s2">var </span><span class="s1">iteratorMethod </span><span class="s3">= </span><span class="s1">iterable</span><span class="s3">[</span><span class="s1">iteratorSymbol</span><span class="s3">];</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">iteratorMethod</span><span class="s3">) {</span>
        <span class="s2">return </span><span class="s1">iteratorMethod</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">);</span>
      <span class="s3">}</span>

      <span class="s2">if </span><span class="s3">(</span><span class="s2">typeof </span><span class="s1">iterable</span><span class="s3">.</span><span class="s1">next </span><span class="s3">=== </span><span class="s4">&quot;function&quot;</span><span class="s3">) {</span>
        <span class="s2">return </span><span class="s1">iterable</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s2">if </span><span class="s3">(!</span><span class="s1">isNaN</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">.</span><span class="s1">length</span><span class="s3">)) {</span>
        <span class="s2">var </span><span class="s1">i </span><span class="s3">= -</span><span class="s6">1</span><span class="s3">, </span><span class="s1">next </span><span class="s3">= </span><span class="s2">function </span><span class="s1">next</span><span class="s3">() {</span>
          <span class="s2">while </span><span class="s3">(++</span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">iterable</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) {</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">hasOwn</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)) {</span>
              <span class="s1">next</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">iterable</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
              <span class="s1">next</span><span class="s3">.</span><span class="s1">done </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
              <span class="s2">return </span><span class="s1">next</span><span class="s3">;</span>
            <span class="s3">}</span>
          <span class="s3">}</span>

          <span class="s1">next</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
          <span class="s1">next</span><span class="s3">.</span><span class="s1">done </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>

          <span class="s2">return </span><span class="s1">next</span><span class="s3">;</span>
        <span class="s3">};</span>

        <span class="s2">return </span><span class="s1">next</span><span class="s3">.</span><span class="s1">next </span><span class="s3">= </span><span class="s1">next</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s2">throw new </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s2">typeof </span><span class="s1">iterable </span><span class="s3">+ </span><span class="s4">&quot; is not iterable&quot;</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s1">exports</span><span class="s3">.</span><span class="s1">values </span><span class="s3">= </span><span class="s1">values</span><span class="s3">;</span>

  <span class="s2">function </span><span class="s1">doneResult</span><span class="s3">() {</span>
    <span class="s2">return </span><span class="s3">{ </span><span class="s1">value</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">, </span><span class="s1">done</span><span class="s3">: </span><span class="s2">true </span><span class="s3">};</span>
  <span class="s3">}</span>

  <span class="s1">Context</span><span class="s3">.</span><span class="s1">prototype </span><span class="s3">= {</span>
    <span class="s1">constructor</span><span class="s3">: </span><span class="s1">Context</span><span class="s3">,</span>

    <span class="s1">reset</span><span class="s3">: </span><span class="s2">function</span><span class="s3">(</span><span class="s1">skipTempReset</span><span class="s3">) {</span>
      <span class="s2">this</span><span class="s3">.</span><span class="s1">prev </span><span class="s3">= </span><span class="s6">0</span><span class="s3">;</span>
      <span class="s2">this</span><span class="s3">.</span><span class="s1">next </span><span class="s3">= </span><span class="s6">0</span><span class="s3">;</span>
      <span class="s5">// Resetting context._sent for legacy support of Babel's</span>
      <span class="s5">// function.sent implementation.</span>
      <span class="s2">this</span><span class="s3">.</span><span class="s1">sent </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">_sent </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
      <span class="s2">this</span><span class="s3">.</span><span class="s1">done </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
      <span class="s2">this</span><span class="s3">.</span><span class="s1">delegate </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>

      <span class="s2">this</span><span class="s3">.</span><span class="s1">method </span><span class="s3">= </span><span class="s4">&quot;next&quot;</span><span class="s3">;</span>
      <span class="s2">this</span><span class="s3">.</span><span class="s1">arg </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>

      <span class="s2">this</span><span class="s3">.</span><span class="s1">tryEntries</span><span class="s3">.</span><span class="s1">forEach</span><span class="s3">(</span><span class="s1">resetTryEntry</span><span class="s3">);</span>

      <span class="s2">if </span><span class="s3">(!</span><span class="s1">skipTempReset</span><span class="s3">) {</span>
        <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in this</span><span class="s3">) {</span>
          <span class="s5">// Not sure about the optimal order of these conditions:</span>
          <span class="s2">if </span><span class="s3">(</span><span class="s1">name</span><span class="s3">.</span><span class="s1">charAt</span><span class="s3">(</span><span class="s6">0</span><span class="s3">) === </span><span class="s4">&quot;t&quot; </span><span class="s3">&amp;&amp;</span>
              <span class="s1">hasOwn</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">name</span><span class="s3">) &amp;&amp;</span>
              <span class="s3">!</span><span class="s1">isNaN</span><span class="s3">(+</span><span class="s1">name</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s6">1</span><span class="s3">))) {</span>
            <span class="s2">this</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">undefined</span><span class="s3">;</span>
          <span class="s3">}</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
    <span class="s3">},</span>

    <span class="s1">stop</span><span class="s3">: </span><span class="s2">function</span><span class="s3">() {</span>
      <span class="s2">this</span><span class="s3">.</span><span class="s1">done </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>

      <span class="s2">var </span><span class="s1">rootEntry </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">tryEntries</span><span class="s3">[</span><span class="s6">0</span><span class="s3">];</span>
      <span class="s2">var </span><span class="s1">rootRecord </span><span class="s3">= </span><span class="s1">rootEntry</span><span class="s3">.</span><span class="s1">completion</span><span class="s3">;</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">rootRecord</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">&quot;throw&quot;</span><span class="s3">) {</span>
        <span class="s2">throw </span><span class="s1">rootRecord</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s2">return this</span><span class="s3">.</span><span class="s1">rval</span><span class="s3">;</span>
    <span class="s3">},</span>

    <span class="s1">dispatchException</span><span class="s3">: </span><span class="s2">function</span><span class="s3">(</span><span class="s1">exception</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">done</span><span class="s3">) {</span>
        <span class="s2">throw </span><span class="s1">exception</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s2">var </span><span class="s1">context </span><span class="s3">= </span><span class="s2">this</span><span class="s3">;</span>
      <span class="s2">function </span><span class="s1">handle</span><span class="s3">(</span><span class="s1">loc</span><span class="s3">, </span><span class="s1">caught</span><span class="s3">) {</span>
        <span class="s1">record</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">&quot;throw&quot;</span><span class="s3">;</span>
        <span class="s1">record</span><span class="s3">.</span><span class="s1">arg </span><span class="s3">= </span><span class="s1">exception</span><span class="s3">;</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">next </span><span class="s3">= </span><span class="s1">loc</span><span class="s3">;</span>

        <span class="s2">if </span><span class="s3">(</span><span class="s1">caught</span><span class="s3">) {</span>
          <span class="s5">// If the dispatched exception was caught by a catch block,</span>
          <span class="s5">// then let that catch block handle the exception normally.</span>
          <span class="s1">context</span><span class="s3">.</span><span class="s1">method </span><span class="s3">= </span><span class="s4">&quot;next&quot;</span><span class="s3">;</span>
          <span class="s1">context</span><span class="s3">.</span><span class="s1">arg </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">}</span>

        <span class="s2">return </span><span class="s3">!! </span><span class="s1">caught</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">tryEntries</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s6">1</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">; --</span><span class="s1">i</span><span class="s3">) {</span>
        <span class="s2">var </span><span class="s1">entry </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">tryEntries</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
        <span class="s2">var </span><span class="s1">record </span><span class="s3">= </span><span class="s1">entry</span><span class="s3">.</span><span class="s1">completion</span><span class="s3">;</span>

        <span class="s2">if </span><span class="s3">(</span><span class="s1">entry</span><span class="s3">.</span><span class="s1">tryLoc </span><span class="s3">=== </span><span class="s4">&quot;root&quot;</span><span class="s3">) {</span>
          <span class="s5">// Exception thrown outside of any try block that could handle</span>
          <span class="s5">// it, so set the completion value of the entire function to</span>
          <span class="s5">// throw the exception.</span>
          <span class="s2">return </span><span class="s1">handle</span><span class="s3">(</span><span class="s4">&quot;end&quot;</span><span class="s3">);</span>
        <span class="s3">}</span>

        <span class="s2">if </span><span class="s3">(</span><span class="s1">entry</span><span class="s3">.</span><span class="s1">tryLoc </span><span class="s3">&lt;= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">prev</span><span class="s3">) {</span>
          <span class="s2">var </span><span class="s1">hasCatch </span><span class="s3">= </span><span class="s1">hasOwn</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">, </span><span class="s4">&quot;catchLoc&quot;</span><span class="s3">);</span>
          <span class="s2">var </span><span class="s1">hasFinally </span><span class="s3">= </span><span class="s1">hasOwn</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">, </span><span class="s4">&quot;finallyLoc&quot;</span><span class="s3">);</span>

          <span class="s2">if </span><span class="s3">(</span><span class="s1">hasCatch </span><span class="s3">&amp;&amp; </span><span class="s1">hasFinally</span><span class="s3">) {</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">prev </span><span class="s3">&lt; </span><span class="s1">entry</span><span class="s3">.</span><span class="s1">catchLoc</span><span class="s3">) {</span>
              <span class="s2">return </span><span class="s1">handle</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">.</span><span class="s1">catchLoc</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
            <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">prev </span><span class="s3">&lt; </span><span class="s1">entry</span><span class="s3">.</span><span class="s1">finallyLoc</span><span class="s3">) {</span>
              <span class="s2">return </span><span class="s1">handle</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">.</span><span class="s1">finallyLoc</span><span class="s3">);</span>
            <span class="s3">}</span>

          <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">hasCatch</span><span class="s3">) {</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">prev </span><span class="s3">&lt; </span><span class="s1">entry</span><span class="s3">.</span><span class="s1">catchLoc</span><span class="s3">) {</span>
              <span class="s2">return </span><span class="s1">handle</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">.</span><span class="s1">catchLoc</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
            <span class="s3">}</span>

          <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">hasFinally</span><span class="s3">) {</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">prev </span><span class="s3">&lt; </span><span class="s1">entry</span><span class="s3">.</span><span class="s1">finallyLoc</span><span class="s3">) {</span>
              <span class="s2">return </span><span class="s1">handle</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">.</span><span class="s1">finallyLoc</span><span class="s3">);</span>
            <span class="s3">}</span>

          <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
            <span class="s2">throw new </span><span class="s1">Error</span><span class="s3">(</span><span class="s4">&quot;try statement without catch or finally&quot;</span><span class="s3">);</span>
          <span class="s3">}</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
    <span class="s3">},</span>

    <span class="s1">abrupt</span><span class="s3">: </span><span class="s2">function</span><span class="s3">(</span><span class="s1">type</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">) {</span>
      <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">tryEntries</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s6">1</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">; --</span><span class="s1">i</span><span class="s3">) {</span>
        <span class="s2">var </span><span class="s1">entry </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">tryEntries</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">entry</span><span class="s3">.</span><span class="s1">tryLoc </span><span class="s3">&lt;= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">prev </span><span class="s3">&amp;&amp;</span>
            <span class="s1">hasOwn</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">, </span><span class="s4">&quot;finallyLoc&quot;</span><span class="s3">) &amp;&amp;</span>
            <span class="s2">this</span><span class="s3">.</span><span class="s1">prev </span><span class="s3">&lt; </span><span class="s1">entry</span><span class="s3">.</span><span class="s1">finallyLoc</span><span class="s3">) {</span>
          <span class="s2">var </span><span class="s1">finallyEntry </span><span class="s3">= </span><span class="s1">entry</span><span class="s3">;</span>
          <span class="s2">break</span><span class="s3">;</span>
        <span class="s3">}</span>
      <span class="s3">}</span>

      <span class="s2">if </span><span class="s3">(</span><span class="s1">finallyEntry </span><span class="s3">&amp;&amp;</span>
          <span class="s3">(</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">&quot;break&quot; </span><span class="s3">||</span>
           <span class="s1">type </span><span class="s3">=== </span><span class="s4">&quot;continue&quot;</span><span class="s3">) &amp;&amp;</span>
          <span class="s1">finallyEntry</span><span class="s3">.</span><span class="s1">tryLoc </span><span class="s3">&lt;= </span><span class="s1">arg </span><span class="s3">&amp;&amp;</span>
          <span class="s1">arg </span><span class="s3">&lt;= </span><span class="s1">finallyEntry</span><span class="s3">.</span><span class="s1">finallyLoc</span><span class="s3">) {</span>
        <span class="s5">// Ignore the finally entry if control is not jumping to a</span>
        <span class="s5">// location outside the try/catch block.</span>
        <span class="s1">finallyEntry </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s2">var </span><span class="s1">record </span><span class="s3">= </span><span class="s1">finallyEntry </span><span class="s3">? </span><span class="s1">finallyEntry</span><span class="s3">.</span><span class="s1">completion </span><span class="s3">: {};</span>
      <span class="s1">record</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">type</span><span class="s3">;</span>
      <span class="s1">record</span><span class="s3">.</span><span class="s1">arg </span><span class="s3">= </span><span class="s1">arg</span><span class="s3">;</span>

      <span class="s2">if </span><span class="s3">(</span><span class="s1">finallyEntry</span><span class="s3">) {</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s1">method </span><span class="s3">= </span><span class="s4">&quot;next&quot;</span><span class="s3">;</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s1">next </span><span class="s3">= </span><span class="s1">finallyEntry</span><span class="s3">.</span><span class="s1">finallyLoc</span><span class="s3">;</span>
        <span class="s2">return </span><span class="s1">ContinueSentinel</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s2">return this</span><span class="s3">.</span><span class="s1">complete</span><span class="s3">(</span><span class="s1">record</span><span class="s3">);</span>
    <span class="s3">},</span>

    <span class="s1">complete</span><span class="s3">: </span><span class="s2">function</span><span class="s3">(</span><span class="s1">record</span><span class="s3">, </span><span class="s1">afterLoc</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">record</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">&quot;throw&quot;</span><span class="s3">) {</span>
        <span class="s2">throw </span><span class="s1">record</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s2">if </span><span class="s3">(</span><span class="s1">record</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">&quot;break&quot; </span><span class="s3">||</span>
          <span class="s1">record</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">&quot;continue&quot;</span><span class="s3">) {</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s1">next </span><span class="s3">= </span><span class="s1">record</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">;</span>
      <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">record</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">&quot;return&quot;</span><span class="s3">) {</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s1">rval </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">arg </span><span class="s3">= </span><span class="s1">record</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">;</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s1">method </span><span class="s3">= </span><span class="s4">&quot;return&quot;</span><span class="s3">;</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s1">next </span><span class="s3">= </span><span class="s4">&quot;end&quot;</span><span class="s3">;</span>
      <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">record</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">&quot;normal&quot; </span><span class="s3">&amp;&amp; </span><span class="s1">afterLoc</span><span class="s3">) {</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s1">next </span><span class="s3">= </span><span class="s1">afterLoc</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s2">return </span><span class="s1">ContinueSentinel</span><span class="s3">;</span>
    <span class="s3">},</span>

    <span class="s1">finish</span><span class="s3">: </span><span class="s2">function</span><span class="s3">(</span><span class="s1">finallyLoc</span><span class="s3">) {</span>
      <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">tryEntries</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s6">1</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">; --</span><span class="s1">i</span><span class="s3">) {</span>
        <span class="s2">var </span><span class="s1">entry </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">tryEntries</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">entry</span><span class="s3">.</span><span class="s1">finallyLoc </span><span class="s3">=== </span><span class="s1">finallyLoc</span><span class="s3">) {</span>
          <span class="s2">this</span><span class="s3">.</span><span class="s1">complete</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">.</span><span class="s1">completion</span><span class="s3">, </span><span class="s1">entry</span><span class="s3">.</span><span class="s1">afterLoc</span><span class="s3">);</span>
          <span class="s1">resetTryEntry</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">);</span>
          <span class="s2">return </span><span class="s1">ContinueSentinel</span><span class="s3">;</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
    <span class="s3">},</span>

    <span class="s4">&quot;catch&quot;</span><span class="s3">: </span><span class="s2">function</span><span class="s3">(</span><span class="s1">tryLoc</span><span class="s3">) {</span>
      <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">tryEntries</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s6">1</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">; --</span><span class="s1">i</span><span class="s3">) {</span>
        <span class="s2">var </span><span class="s1">entry </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">tryEntries</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">entry</span><span class="s3">.</span><span class="s1">tryLoc </span><span class="s3">=== </span><span class="s1">tryLoc</span><span class="s3">) {</span>
          <span class="s2">var </span><span class="s1">record </span><span class="s3">= </span><span class="s1">entry</span><span class="s3">.</span><span class="s1">completion</span><span class="s3">;</span>
          <span class="s2">if </span><span class="s3">(</span><span class="s1">record</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s4">&quot;throw&quot;</span><span class="s3">) {</span>
            <span class="s2">var </span><span class="s1">thrown </span><span class="s3">= </span><span class="s1">record</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">;</span>
            <span class="s1">resetTryEntry</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">);</span>
          <span class="s3">}</span>
          <span class="s2">return </span><span class="s1">thrown</span><span class="s3">;</span>
        <span class="s3">}</span>
      <span class="s3">}</span>

      <span class="s5">// The context.catch method must only be called with a location</span>
      <span class="s5">// argument that corresponds to a known catch block.</span>
      <span class="s2">throw new </span><span class="s1">Error</span><span class="s3">(</span><span class="s4">&quot;illegal catch attempt&quot;</span><span class="s3">);</span>
    <span class="s3">},</span>

    <span class="s1">delegateYield</span><span class="s3">: </span><span class="s2">function</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">resultName</span><span class="s3">, </span><span class="s1">nextLoc</span><span class="s3">) {</span>
      <span class="s2">this</span><span class="s3">.</span><span class="s1">delegate </span><span class="s3">= {</span>
        <span class="s1">iterator</span><span class="s3">: </span><span class="s1">values</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">),</span>
        <span class="s1">resultName</span><span class="s3">: </span><span class="s1">resultName</span><span class="s3">,</span>
        <span class="s1">nextLoc</span><span class="s3">: </span><span class="s1">nextLoc</span>
      <span class="s3">};</span>

      <span class="s2">if </span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">method </span><span class="s3">=== </span><span class="s4">&quot;next&quot;</span><span class="s3">) {</span>
        <span class="s5">// Deliberately forget the last sent value so that we don't</span>
        <span class="s5">// accidentally pass it on to the delegate.</span>
        <span class="s2">this</span><span class="s3">.</span><span class="s1">arg </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s2">return </span><span class="s1">ContinueSentinel</span><span class="s3">;</span>
    <span class="s3">}</span>
  <span class="s3">};</span>

  <span class="s5">// Regardless of whether this script is executing as a CommonJS module</span>
  <span class="s5">// or not, return the runtime object so that we can declare the variable</span>
  <span class="s5">// regeneratorRuntime in the outer scope, which allows this module to be</span>
  <span class="s5">// injected easily by `bin/regenerator --include-runtime script.js`.</span>
  <span class="s2">return </span><span class="s1">exports</span><span class="s3">;</span>

<span class="s3">}(</span>
  <span class="s5">// If this script is executing as a CommonJS module, use module.exports</span>
  <span class="s5">// as the regeneratorRuntime namespace. Otherwise create a new empty</span>
  <span class="s5">// object. Either way, the resulting object will be used to initialize</span>
  <span class="s5">// the regeneratorRuntime variable at the top of this file.</span>
  <span class="s2">typeof </span><span class="s1">module </span><span class="s3">=== </span><span class="s4">&quot;object&quot; </span><span class="s3">? </span><span class="s1">module</span><span class="s3">.</span><span class="s1">exports </span><span class="s3">: {}</span>
<span class="s3">));</span>

<span class="s2">try </span><span class="s3">{</span>
  <span class="s1">regeneratorRuntime </span><span class="s3">= </span><span class="s1">runtime</span><span class="s3">;</span>
<span class="s3">} </span><span class="s2">catch </span><span class="s3">(</span><span class="s1">accidentalStrictMode</span><span class="s3">) {</span>
  <span class="s5">// This module should not be running in strict mode, so the above</span>
  <span class="s5">// assignment should always work unless something is misconfigured. Just</span>
  <span class="s5">// in case runtime.js accidentally runs in strict mode, in modern engines</span>
  <span class="s5">// we can explicitly access globalThis. In older engines we can escape</span>
  <span class="s5">// strict mode using a global Function call. This could conceivably fail</span>
  <span class="s5">// if a Content Security Policy forbids using Function, but in that case</span>
  <span class="s5">// the proper solution is to fix the accidental strict mode problem. If</span>
  <span class="s5">// you've misconfigured your bundler to force strict mode and applied a</span>
  <span class="s5">// CSP to forbid Function, and you're not willing to fix either of those</span>
  <span class="s5">// problems, please detail your unique predicament in a GitHub issue.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s2">typeof </span><span class="s1">globalThis </span><span class="s3">=== </span><span class="s4">&quot;object&quot;</span><span class="s3">) {</span>
    <span class="s1">globalThis</span><span class="s3">.</span><span class="s1">regeneratorRuntime </span><span class="s3">= </span><span class="s1">runtime</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">Function</span><span class="s3">(</span><span class="s4">&quot;r&quot;</span><span class="s3">, </span><span class="s4">&quot;regeneratorRuntime = r&quot;</span><span class="s3">)(</span><span class="s1">runtime</span><span class="s3">);</span>
  <span class="s3">}</span>
<span class="s3">}</span>
</pre>
</body>
</html>