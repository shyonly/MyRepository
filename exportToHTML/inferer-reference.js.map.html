<html>
<head>
<title>inferer-reference.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
inferer-reference.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_util&quot;</span><span class="s0">,</span><span class="s1">&quot;BOOLEAN_NUMBER_BINARY_OPERATORS&quot;</span><span class="s0">,</span><span class="s1">&quot;createTypeAnnotationBasedOnTypeof&quot;</span><span class="s0">,</span><span class="s1">&quot;numberTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;voidTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;_default&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;isReferenced&quot;</span><span class="s0">,</span><span class="s1">&quot;binding&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;getBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;typeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;getTypeAnnotationBindingConstantViolations&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;types&quot;</span><span class="s0">,</span><span class="s1">&quot;functionConstantViolations&quot;</span><span class="s0">,</span><span class="s1">&quot;constantViolations&quot;</span><span class="s0">,</span><span class="s1">&quot;getConstantViolationsBefore&quot;</span><span class="s0">,</span><span class="s1">&quot;testType&quot;</span><span class="s0">,</span><span class="s1">&quot;getConditionalAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;testConstantViolations&quot;</span><span class="s0">,</span><span class="s1">&quot;ifStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;violation&quot;</span><span class="s0">,</span><span class="s1">&quot;getTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;createUnionType&quot;</span><span class="s0">,</span><span class="s1">&quot;functions&quot;</span><span class="s0">,</span><span class="s1">&quot;violations&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;_guessExecutionStatusRelativeTo&quot;</span><span class="s0">,</span><span class="s1">&quot;inferAnnotationFromBinaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;typeofPath&quot;</span><span class="s0">,</span><span class="s1">&quot;typePath&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;typeValue&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;getParentConditionalPath&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isIfStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isConditionalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;isLogicalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isBinaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/path/inference/inferer-reference.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type NodePath from </span><span class="s3">\&quot;</span><span class="s1">../index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">BOOLEAN_NUMBER_BINARY_OPERATORS,</span><span class="s3">\n  </span><span class="s1">createTypeAnnotationBasedOnTypeof,</span><span class="s3">\n  </span><span class="s1">numberTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">voidTypeAnnotation,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type Binding from </span><span class="s3">\&quot;</span><span class="s1">../../scope/binding.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import { createUnionType } from </span><span class="s3">\&quot;</span><span class="s1">./util.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export default function (this: NodePath&lt;t.Identifier&gt;, node: t.Identifier) {</span><span class="s3">\n  </span><span class="s1">if (!this.isReferenced()) return;</span><span class="s3">\n\n  </span><span class="s1">// check if a binding exists of this value and if so then return a union type of all</span><span class="s3">\n  </span><span class="s1">// possible types that the binding could be</span><span class="s3">\n  </span><span class="s1">const binding = this.scope.getBinding(node.name);</span><span class="s3">\n  </span><span class="s1">if (binding) {</span><span class="s3">\n    </span><span class="s1">if (binding.identifier.typeAnnotation) {</span><span class="s3">\n      </span><span class="s1">return binding.identifier.typeAnnotation;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return getTypeAnnotationBindingConstantViolations(</span><span class="s3">\n        </span><span class="s1">binding,</span><span class="s3">\n        </span><span class="s1">this,</span><span class="s3">\n        </span><span class="s1">node.name,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// built-in values</span><span class="s3">\n  </span><span class="s1">if (node.name === </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return voidTypeAnnotation();</span><span class="s3">\n  </span><span class="s1">} else if (node.name === </span><span class="s3">\&quot;</span><span class="s1">NaN</span><span class="s3">\&quot; </span><span class="s1">|| node.name === </span><span class="s3">\&quot;</span><span class="s1">Infinity</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return numberTypeAnnotation();</span><span class="s3">\n  </span><span class="s1">} else if (node.name === </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// todo</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getTypeAnnotationBindingConstantViolations(</span><span class="s3">\n  </span><span class="s1">binding: Binding,</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Identifier&gt;,</span><span class="s3">\n  </span><span class="s1">name: string,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const types = [];</span><span class="s3">\n\n  </span><span class="s1">const functionConstantViolations: NodePath[] = [];</span><span class="s3">\n  </span><span class="s1">let constantViolations = getConstantViolationsBefore(</span><span class="s3">\n    </span><span class="s1">binding,</span><span class="s3">\n    </span><span class="s1">path,</span><span class="s3">\n    </span><span class="s1">functionConstantViolations,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">const testType = getConditionalAnnotation(binding, path, name);</span><span class="s3">\n  </span><span class="s1">if (testType) {</span><span class="s3">\n    </span><span class="s1">const testConstantViolations = getConstantViolationsBefore(</span><span class="s3">\n      </span><span class="s1">binding,</span><span class="s3">\n      </span><span class="s1">testType.ifStatement,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">// remove constant violations observed before the IfStatement</span><span class="s3">\n    </span><span class="s1">constantViolations = constantViolations.filter(</span><span class="s3">\n      </span><span class="s1">path =&gt; testConstantViolations.indexOf(path) &lt; 0,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">// clear current types and add in observed test type</span><span class="s3">\n    </span><span class="s1">types.push(testType.typeAnnotation);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (constantViolations.length) {</span><span class="s3">\n    </span><span class="s1">// pick one constant from each scope which will represent the last possible</span><span class="s3">\n    </span><span class="s1">// control flow path that it could've taken/been</span><span class="s3">\n    </span><span class="s1">/* This code is broken for the following problems:</span><span class="s3">\n     </span><span class="s1">* It thinks that assignments can only happen in scopes.</span><span class="s3">\n     </span><span class="s1">* What about conditionals, if statements without block,</span><span class="s3">\n     </span><span class="s1">* or guarded assignments.</span><span class="s3">\n     </span><span class="s1">* It also checks to see if one of the assignments is in the</span><span class="s3">\n     </span><span class="s1">* same scope and uses that as the only </span><span class="s3">\&quot;</span><span class="s1">violation</span><span class="s3">\&quot;</span><span class="s1">. However,</span><span class="s3">\n     </span><span class="s1">* the binding is returned by `getConstantViolationsBefore` so we for</span><span class="s3">\n     </span><span class="s1">* sure always going to return that as the only </span><span class="s3">\&quot;</span><span class="s1">violation</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n    </span><span class="s1">let rawConstantViolations = constantViolations.reverse();</span><span class="s3">\n    </span><span class="s1">let visitedScopes = [];</span><span class="s3">\n    </span><span class="s1">constantViolations = [];</span><span class="s3">\n    </span><span class="s1">for (let violation of (rawConstantViolations: Array&lt;NodePath&gt;)) {</span><span class="s3">\n      </span><span class="s1">let violationScope = violation.scope;</span><span class="s3">\n      </span><span class="s1">if (visitedScopes.indexOf(violationScope) &gt;= 0) continue;</span><span class="s3">\n\n      </span><span class="s1">visitedScopes.push(violationScope);</span><span class="s3">\n      </span><span class="s1">constantViolations.push(violation);</span><span class="s3">\n\n      </span><span class="s1">if (violationScope === path.scope) {</span><span class="s3">\n        </span><span class="s1">constantViolations = [violation];</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}*/</span><span class="s3">\n\n    </span><span class="s1">// add back on function constant violations since we can't track calls</span><span class="s3">\n    </span><span class="s1">constantViolations.push(...functionConstantViolations);</span><span class="s3">\n\n    </span><span class="s1">// push on inferred types of violated paths</span><span class="s3">\n    </span><span class="s1">for (const violation of constantViolations) {</span><span class="s3">\n      </span><span class="s1">types.push(violation.getTypeAnnotation());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!types.length) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return createUnionType(types);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getConstantViolationsBefore(</span><span class="s3">\n  </span><span class="s1">binding: Binding,</span><span class="s3">\n  </span><span class="s1">path: NodePath,</span><span class="s3">\n  </span><span class="s1">functions?: NodePath[],</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const violations = binding.constantViolations.slice();</span><span class="s3">\n  </span><span class="s1">violations.unshift(binding.path);</span><span class="s3">\n  </span><span class="s1">return violations.filter(violation =&gt; {</span><span class="s3">\n    </span><span class="s1">violation = violation.resolve();</span><span class="s3">\n    </span><span class="s1">const status = violation._guessExecutionStatusRelativeTo(path);</span><span class="s3">\n    </span><span class="s1">if (functions &amp;&amp; status === </span><span class="s3">\&quot;</span><span class="s1">unknown</span><span class="s3">\&quot;</span><span class="s1">) functions.push(violation);</span><span class="s3">\n    </span><span class="s1">return status === </span><span class="s3">\&quot;</span><span class="s1">before</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function inferAnnotationFromBinaryExpression(</span><span class="s3">\n  </span><span class="s1">name: string,</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.BinaryExpression&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const operator = path.node.operator;</span><span class="s3">\n\n  </span><span class="s1">const right = path.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">).resolve();</span><span class="s3">\n  </span><span class="s1">const left = path.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">).resolve();</span><span class="s3">\n\n  </span><span class="s1">let target;</span><span class="s3">\n  </span><span class="s1">if (left.isIdentifier({ name })) {</span><span class="s3">\n    </span><span class="s1">target = right;</span><span class="s3">\n  </span><span class="s1">} else if (right.isIdentifier({ name })) {</span><span class="s3">\n    </span><span class="s1">target = left;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (target) {</span><span class="s3">\n    </span><span class="s1">if (operator === </span><span class="s3">\&quot;</span><span class="s1">===</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return target.getTypeAnnotation();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) &gt;= 0) {</span><span class="s3">\n      </span><span class="s1">return numberTypeAnnotation();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (operator !== </span><span class="s3">\&quot;</span><span class="s1">===</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; operator !== </span><span class="s3">\&quot;</span><span class="s1">==</span><span class="s3">\&quot;</span><span class="s1">) return;</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">let typeofPath: NodePath&lt;t.UnaryExpression&gt;;</span><span class="s3">\n  </span><span class="s1">let typePath: NodePath&lt;t.Expression&gt;;</span><span class="s3">\n  </span><span class="s1">if (left.isUnaryExpression({ operator: </span><span class="s3">\&quot;</span><span class="s1">typeof</span><span class="s3">\&quot; </span><span class="s1">})) {</span><span class="s3">\n    </span><span class="s1">typeofPath = left;</span><span class="s3">\n    </span><span class="s1">typePath = right as NodePath&lt;t.Expression&gt;;</span><span class="s3">\n  </span><span class="s1">} else if (right.isUnaryExpression({ operator: </span><span class="s3">\&quot;</span><span class="s1">typeof</span><span class="s3">\&quot; </span><span class="s1">})) {</span><span class="s3">\n    </span><span class="s1">typeofPath = right;</span><span class="s3">\n    </span><span class="s1">typePath = left as NodePath&lt;t.Expression&gt;;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!typeofPath) return;</span><span class="s3">\n  </span><span class="s1">// and that the argument of the typeof path references us!</span><span class="s3">\n  </span><span class="s1">if (!typeofPath.get(</span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">).isIdentifier({ name })) return;</span><span class="s3">\n\n  </span><span class="s1">// ensure that the type path is a Literal</span><span class="s3">\n  </span><span class="s1">typePath = typePath.resolve() as NodePath&lt;t.Expression&gt;;</span><span class="s3">\n  </span><span class="s1">if (!typePath.isLiteral()) return;</span><span class="s3">\n\n  </span><span class="s1">// and that it's a string so we can infer it</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): value is not defined for NullLiteral and some other</span><span class="s3">\n  </span><span class="s1">const typeValue = typePath.node.value;</span><span class="s3">\n  </span><span class="s1">if (typeof typeValue !== </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) return;</span><span class="s3">\n\n  </span><span class="s1">// turn type value into a type annotation</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): move validation from helper or relax type constraint to just a string</span><span class="s3">\n  </span><span class="s1">return createTypeAnnotationBasedOnTypeof(typeValue);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getParentConditionalPath(</span><span class="s3">\n  </span><span class="s1">binding: Binding,</span><span class="s3">\n  </span><span class="s1">path: NodePath,</span><span class="s3">\n  </span><span class="s1">name: string,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let parentPath;</span><span class="s3">\n  </span><span class="s1">while ((parentPath = path.parentPath)) {</span><span class="s3">\n    </span><span class="s1">if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {</span><span class="s3">\n      </span><span class="s1">if (path.key === </span><span class="s3">\&quot;</span><span class="s1">test</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return parentPath as NodePath&lt;t.IfStatement | t.ConditionalExpression&gt;;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (parentPath.isFunction()) {</span><span class="s3">\n      </span><span class="s1">if (parentPath.parentPath.scope.getBinding(name) !== binding) return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">path = parentPath;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getConditionalAnnotation&lt;T extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">binding: Binding,</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">name?: string,</span><span class="s3">\n</span><span class="s1">): {</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.FlowType | t.TSType;</span><span class="s3">\n  </span><span class="s1">ifStatement: NodePath&lt;t.IfStatement | t.ConditionalExpression&gt;;</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">const ifStatement = getParentConditionalPath(binding, path, name);</span><span class="s3">\n  </span><span class="s1">if (!ifStatement) return;</span><span class="s3">\n\n  </span><span class="s1">const test = ifStatement.get(</span><span class="s3">\&quot;</span><span class="s1">test</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const paths = [test];</span><span class="s3">\n  </span><span class="s1">const types = [];</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; paths.length; i++) {</span><span class="s3">\n    </span><span class="s1">const path = paths[i];</span><span class="s3">\n\n    </span><span class="s1">if (path.isLogicalExpression()) {</span><span class="s3">\n      </span><span class="s1">if (path.node.operator === </span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">paths.push(path.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">paths.push(path.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (path.isBinaryExpression()) {</span><span class="s3">\n      </span><span class="s1">const type = inferAnnotationFromBinaryExpression(name, path);</span><span class="s3">\n      </span><span class="s1">if (type) types.push(type);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (types.length) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">typeAnnotation: createUnionType(types),</span><span class="s3">\n      </span><span class="s1">ifStatement,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return getConditionalAnnotation(binding, ifStatement, name);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>