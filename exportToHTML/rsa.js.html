<html>
<head>
<title>rsa.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #67a37c; font-style: italic;}
.s2 { color: #bcbec4;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #7a7e85;}
.s7 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
rsa.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Javascript implementation of basic RSA algorithms.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Dave Longley</span>
 <span class="s0">*</span>
 <span class="s0">* Copyright (c) 2010-2014 Digital Bazaar, Inc.</span>
 <span class="s0">*</span>
 <span class="s0">* The only algorithm currently supported for PKI is RSA.</span>
 <span class="s0">*</span>
 <span class="s0">* An RSA key is often stored in ASN.1 DER format. The SubjectPublicKeyInfo</span>
 <span class="s0">* ASN.1 structure is composed of an algorithm of type AlgorithmIdentifier</span>
 <span class="s0">* and a subjectPublicKey of type bit string.</span>
 <span class="s0">*</span>
 <span class="s0">* The AlgorithmIdentifier contains an Object Identifier (OID) and parameters</span>
 <span class="s0">* for the algorithm, if any. In the case of RSA, there aren't any.</span>
 <span class="s0">*</span>
 <span class="s0">* SubjectPublicKeyInfo ::= SEQUENCE {</span>
 <span class="s0">*   algorithm AlgorithmIdentifier,</span>
 <span class="s0">*   subjectPublicKey BIT STRING</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* AlgorithmIdentifer ::= SEQUENCE {</span>
 <span class="s0">*   algorithm OBJECT IDENTIFIER,</span>
 <span class="s0">*   parameters ANY DEFINED BY algorithm OPTIONAL</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* For an RSA public key, the subjectPublicKey is:</span>
 <span class="s0">*</span>
 <span class="s0">* RSAPublicKey ::= SEQUENCE {</span>
 <span class="s0">*   modulus            INTEGER,    -- n</span>
 <span class="s0">*   publicExponent     INTEGER     -- e</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* PrivateKeyInfo ::= SEQUENCE {</span>
 <span class="s0">*   version                   Version,</span>
 <span class="s0">*   privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,</span>
 <span class="s0">*   privateKey                PrivateKey,</span>
 <span class="s0">*   attributes           [0]  IMPLICIT Attributes OPTIONAL</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* Version ::= INTEGER</span>
 <span class="s0">* PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier</span>
 <span class="s0">* PrivateKey ::= OCTET STRING</span>
 <span class="s0">* Attributes ::= SET OF Attribute</span>
 <span class="s0">*</span>
 <span class="s0">* An RSA private key as the following structure:</span>
 <span class="s0">*</span>
 <span class="s0">* RSAPrivateKey ::= SEQUENCE {</span>
 <span class="s0">*   version Version,</span>
 <span class="s0">*   modulus INTEGER, -- n</span>
 <span class="s0">*   publicExponent INTEGER, -- e</span>
 <span class="s0">*   privateExponent INTEGER, -- d</span>
 <span class="s0">*   prime1 INTEGER, -- p</span>
 <span class="s0">*   prime2 INTEGER, -- q</span>
 <span class="s0">*   exponent1 INTEGER, -- d mod (p-1)</span>
 <span class="s0">*   exponent2 INTEGER, -- d mod (q-1)</span>
 <span class="s0">*   coefficient INTEGER -- (inverse of q) mod p</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* Version ::= INTEGER</span>
 <span class="s0">*</span>
 <span class="s0">* The OID for the RSA key algorithm is: 1.2.840.113549.1.1.1</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">forge </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s5">'./forge'</span><span class="s4">);</span>
<span class="s2">require</span><span class="s4">(</span><span class="s5">'./asn1'</span><span class="s4">);</span>
<span class="s2">require</span><span class="s4">(</span><span class="s5">'./jsbn'</span><span class="s4">);</span>
<span class="s2">require</span><span class="s4">(</span><span class="s5">'./oids'</span><span class="s4">);</span>
<span class="s2">require</span><span class="s4">(</span><span class="s5">'./pkcs1'</span><span class="s4">);</span>
<span class="s2">require</span><span class="s4">(</span><span class="s5">'./prime'</span><span class="s4">);</span>
<span class="s2">require</span><span class="s4">(</span><span class="s5">'./random'</span><span class="s4">);</span>
<span class="s2">require</span><span class="s4">(</span><span class="s5">'./util'</span><span class="s4">);</span>

<span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">BigInteger </span><span class="s4">=== </span><span class="s5">'undefined'</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">BigInteger </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">jsbn</span><span class="s4">.</span><span class="s2">BigInteger</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s3">var </span><span class="s2">_crypto </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">isNodejs </span><span class="s4">? </span><span class="s2">require</span><span class="s4">(</span><span class="s5">'crypto'</span><span class="s4">) : </span><span class="s3">null</span><span class="s4">;</span>

<span class="s6">// shortcut for asn.1 API</span>
<span class="s3">var </span><span class="s2">asn1 </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">asn1</span><span class="s4">;</span>

<span class="s6">// shortcut for util API</span>
<span class="s3">var </span><span class="s2">util </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">;</span>

<span class="s6">/* 
 * RSA encryption and decryption, see RFC 2313. 
 */</span>
<span class="s2">forge</span><span class="s4">.</span><span class="s2">pki </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">pki </span><span class="s4">|| {};</span>
<span class="s2">module</span><span class="s4">.</span><span class="s2">exports </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">rsa </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">rsa </span><span class="s4">|| {};</span>
<span class="s3">var </span><span class="s2">pki </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">pki</span><span class="s4">;</span>

<span class="s6">// for finding primes, which are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29</span>
<span class="s3">var </span><span class="s2">GCD_30_DELTA </span><span class="s4">= [</span><span class="s7">6</span><span class="s4">, </span><span class="s7">4</span><span class="s4">, </span><span class="s7">2</span><span class="s4">, </span><span class="s7">4</span><span class="s4">, </span><span class="s7">2</span><span class="s4">, </span><span class="s7">4</span><span class="s4">, </span><span class="s7">6</span><span class="s4">, </span><span class="s7">2</span><span class="s4">];</span>

<span class="s6">// validator for a PrivateKeyInfo structure</span>
<span class="s3">var </span><span class="s2">privateKeyValidator </span><span class="s4">= {</span>
  <span class="s6">// PrivateKeyInfo</span>
  <span class="s2">name</span><span class="s4">: </span><span class="s5">'PrivateKeyInfo'</span><span class="s4">,</span>
  <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
  <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">,</span>
  <span class="s2">constructed</span><span class="s4">: </span><span class="s3">true</span><span class="s4">,</span>
  <span class="s2">value</span><span class="s4">: [{</span>
    <span class="s6">// Version (INTEGER)</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'PrivateKeyInfo.version'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">capture</span><span class="s4">: </span><span class="s5">'privateKeyVersion'</span>
  <span class="s4">}, {</span>
    <span class="s6">// privateKeyAlgorithm</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'PrivateKeyInfo.privateKeyAlgorithm'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">true</span><span class="s4">,</span>
    <span class="s2">value</span><span class="s4">: [{</span>
      <span class="s2">name</span><span class="s4">: </span><span class="s5">'AlgorithmIdentifier.algorithm'</span><span class="s4">,</span>
      <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
      <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">OID</span><span class="s4">,</span>
      <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
      <span class="s2">capture</span><span class="s4">: </span><span class="s5">'privateKeyOid'</span>
    <span class="s4">}]</span>
  <span class="s4">}, {</span>
    <span class="s6">// PrivateKey</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'PrivateKeyInfo'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">OCTETSTRING</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">capture</span><span class="s4">: </span><span class="s5">'privateKey'</span>
  <span class="s4">}]</span>
<span class="s4">};</span>

<span class="s6">// validator for an RSA private key</span>
<span class="s3">var </span><span class="s2">rsaPrivateKeyValidator </span><span class="s4">= {</span>
  <span class="s6">// RSAPrivateKey</span>
  <span class="s2">name</span><span class="s4">: </span><span class="s5">'RSAPrivateKey'</span><span class="s4">,</span>
  <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
  <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">,</span>
  <span class="s2">constructed</span><span class="s4">: </span><span class="s3">true</span><span class="s4">,</span>
  <span class="s2">value</span><span class="s4">: [{</span>
    <span class="s6">// Version (INTEGER)</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'RSAPrivateKey.version'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">capture</span><span class="s4">: </span><span class="s5">'privateKeyVersion'</span>
  <span class="s4">}, {</span>
    <span class="s6">// modulus (n)</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'RSAPrivateKey.modulus'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">capture</span><span class="s4">: </span><span class="s5">'privateKeyModulus'</span>
  <span class="s4">}, {</span>
    <span class="s6">// publicExponent (e)</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'RSAPrivateKey.publicExponent'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">capture</span><span class="s4">: </span><span class="s5">'privateKeyPublicExponent'</span>
  <span class="s4">}, {</span>
    <span class="s6">// privateExponent (d)</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'RSAPrivateKey.privateExponent'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">capture</span><span class="s4">: </span><span class="s5">'privateKeyPrivateExponent'</span>
  <span class="s4">}, {</span>
    <span class="s6">// prime1 (p)</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'RSAPrivateKey.prime1'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">capture</span><span class="s4">: </span><span class="s5">'privateKeyPrime1'</span>
  <span class="s4">}, {</span>
    <span class="s6">// prime2 (q)</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'RSAPrivateKey.prime2'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">capture</span><span class="s4">: </span><span class="s5">'privateKeyPrime2'</span>
  <span class="s4">}, {</span>
    <span class="s6">// exponent1 (d mod (p-1))</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'RSAPrivateKey.exponent1'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">capture</span><span class="s4">: </span><span class="s5">'privateKeyExponent1'</span>
  <span class="s4">}, {</span>
    <span class="s6">// exponent2 (d mod (q-1))</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'RSAPrivateKey.exponent2'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">capture</span><span class="s4">: </span><span class="s5">'privateKeyExponent2'</span>
  <span class="s4">}, {</span>
    <span class="s6">// coefficient ((inverse of q) mod p)</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'RSAPrivateKey.coefficient'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">capture</span><span class="s4">: </span><span class="s5">'privateKeyCoefficient'</span>
  <span class="s4">}]</span>
<span class="s4">};</span>

<span class="s6">// validator for an RSA public key</span>
<span class="s3">var </span><span class="s2">rsaPublicKeyValidator </span><span class="s4">= {</span>
  <span class="s6">// RSAPublicKey</span>
  <span class="s2">name</span><span class="s4">: </span><span class="s5">'RSAPublicKey'</span><span class="s4">,</span>
  <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
  <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">,</span>
  <span class="s2">constructed</span><span class="s4">: </span><span class="s3">true</span><span class="s4">,</span>
  <span class="s2">value</span><span class="s4">: [{</span>
    <span class="s6">// modulus (n)</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'RSAPublicKey.modulus'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">capture</span><span class="s4">: </span><span class="s5">'publicKeyModulus'</span>
  <span class="s4">}, {</span>
    <span class="s6">// publicExponent (e)</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'RSAPublicKey.exponent'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">capture</span><span class="s4">: </span><span class="s5">'publicKeyExponent'</span>
  <span class="s4">}]</span>
<span class="s4">};</span>

<span class="s6">// validator for an SubjectPublicKeyInfo structure</span>
<span class="s6">// Note: Currently only works with an RSA public key</span>
<span class="s3">var </span><span class="s2">publicKeyValidator </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">publicKeyValidator </span><span class="s4">= {</span>
  <span class="s2">name</span><span class="s4">: </span><span class="s5">'SubjectPublicKeyInfo'</span><span class="s4">,</span>
  <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
  <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">,</span>
  <span class="s2">constructed</span><span class="s4">: </span><span class="s3">true</span><span class="s4">,</span>
  <span class="s2">captureAsn1</span><span class="s4">: </span><span class="s5">'subjectPublicKeyInfo'</span><span class="s4">,</span>
  <span class="s2">value</span><span class="s4">: [{</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'SubjectPublicKeyInfo.AlgorithmIdentifier'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">true</span><span class="s4">,</span>
    <span class="s2">value</span><span class="s4">: [{</span>
      <span class="s2">name</span><span class="s4">: </span><span class="s5">'AlgorithmIdentifier.algorithm'</span><span class="s4">,</span>
      <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
      <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">OID</span><span class="s4">,</span>
      <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
      <span class="s2">capture</span><span class="s4">: </span><span class="s5">'publicKeyOid'</span>
    <span class="s4">}]</span>
  <span class="s4">}, {</span>
    <span class="s6">// subjectPublicKey</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'SubjectPublicKeyInfo.subjectPublicKey'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">BITSTRING</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">value</span><span class="s4">: [{</span>
      <span class="s6">// RSAPublicKey</span>
      <span class="s2">name</span><span class="s4">: </span><span class="s5">'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey'</span><span class="s4">,</span>
      <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
      <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">,</span>
      <span class="s2">constructed</span><span class="s4">: </span><span class="s3">true</span><span class="s4">,</span>
      <span class="s2">optional</span><span class="s4">: </span><span class="s3">true</span><span class="s4">,</span>
      <span class="s2">captureAsn1</span><span class="s4">: </span><span class="s5">'rsaPublicKey'</span>
    <span class="s4">}]</span>
  <span class="s4">}]</span>
<span class="s4">};</span>

<span class="s6">// validator for a DigestInfo structure</span>
<span class="s3">var </span><span class="s2">digestInfoValidator </span><span class="s4">= {</span>
  <span class="s2">name</span><span class="s4">: </span><span class="s5">'DigestInfo'</span><span class="s4">,</span>
  <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
  <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">,</span>
  <span class="s2">constructed</span><span class="s4">: </span><span class="s3">true</span><span class="s4">,</span>
  <span class="s2">value</span><span class="s4">: [{</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'DigestInfo.DigestAlgorithm'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">true</span><span class="s4">,</span>
    <span class="s2">value</span><span class="s4">: [{</span>
      <span class="s2">name</span><span class="s4">: </span><span class="s5">'DigestInfo.DigestAlgorithm.algorithmIdentifier'</span><span class="s4">,</span>
      <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
      <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">OID</span><span class="s4">,</span>
      <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
      <span class="s2">capture</span><span class="s4">: </span><span class="s5">'algorithmIdentifier'</span>
    <span class="s4">}, {</span>
      <span class="s6">// NULL paramters</span>
      <span class="s2">name</span><span class="s4">: </span><span class="s5">'DigestInfo.DigestAlgorithm.parameters'</span><span class="s4">,</span>
      <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
      <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">NULL</span><span class="s4">,</span>
      <span class="s6">// captured only to check existence for md2 and md5</span>
      <span class="s2">capture</span><span class="s4">: </span><span class="s5">'parameters'</span><span class="s4">,</span>
      <span class="s2">optional</span><span class="s4">: </span><span class="s3">true</span><span class="s4">,</span>
      <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span>
    <span class="s4">}]</span>
  <span class="s4">}, {</span>
    <span class="s6">// digest</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s5">'DigestInfo.digest'</span><span class="s4">,</span>
    <span class="s2">tagClass</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">,</span>
    <span class="s2">type</span><span class="s4">: </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">OCTETSTRING</span><span class="s4">,</span>
    <span class="s2">constructed</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">capture</span><span class="s4">: </span><span class="s5">'digest'</span>
  <span class="s4">}]</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Wrap digest in DigestInfo object.</span>
 <span class="s0">*</span>
 <span class="s0">* This function implements EMSA-PKCS1-v1_5-ENCODE as per RFC 3447.</span>
 <span class="s0">*</span>
 <span class="s0">* DigestInfo ::= SEQUENCE {</span>
 <span class="s0">*   digestAlgorithm DigestAlgorithmIdentifier,</span>
 <span class="s0">*   digest Digest</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* DigestAlgorithmIdentifier ::= AlgorithmIdentifier</span>
 <span class="s0">* Digest ::= OCTET STRING</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">md the message digest object with the hash to sign.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the encoded message (ready for RSA encrytion)</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">emsaPkcs1v15encode </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">md</span><span class="s4">) {</span>
  <span class="s6">// get the oid for the algorithm</span>
  <span class="s3">var </span><span class="s2">oid</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">md</span><span class="s4">.</span><span class="s2">algorithm </span><span class="s3">in </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">) {</span>
    <span class="s2">oid </span><span class="s4">= </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">[</span><span class="s2">md</span><span class="s4">.</span><span class="s2">algorithm</span><span class="s4">];</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s3">var </span><span class="s2">error </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Unknown message digest algorithm.'</span><span class="s4">);</span>
    <span class="s2">error</span><span class="s4">.</span><span class="s2">algorithm </span><span class="s4">= </span><span class="s2">md</span><span class="s4">.</span><span class="s2">algorithm</span><span class="s4">;</span>
    <span class="s3">throw </span><span class="s2">error</span><span class="s4">;</span>
  <span class="s4">}</span>
  <span class="s3">var </span><span class="s2">oidBytes </span><span class="s4">= </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">oidToDer</span><span class="s4">(</span><span class="s2">oid</span><span class="s4">).</span><span class="s2">getBytes</span><span class="s4">();</span>

  <span class="s6">// create the digest info</span>
  <span class="s3">var </span><span class="s2">digestInfo </span><span class="s4">= </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">, </span><span class="s3">true</span><span class="s4">, []);</span>
  <span class="s3">var </span><span class="s2">digestAlgorithm </span><span class="s4">= </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">, </span><span class="s3">true</span><span class="s4">, []);</span>
  <span class="s2">digestAlgorithm</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">OID</span><span class="s4">, </span><span class="s3">false</span><span class="s4">, </span><span class="s2">oidBytes</span><span class="s4">));</span>
  <span class="s2">digestAlgorithm</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">NULL</span><span class="s4">, </span><span class="s3">false</span><span class="s4">, </span><span class="s5">''</span><span class="s4">));</span>
  <span class="s3">var </span><span class="s2">digest </span><span class="s4">= </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">OCTETSTRING</span><span class="s4">,</span>
    <span class="s3">false</span><span class="s4">, </span><span class="s2">md</span><span class="s4">.</span><span class="s2">digest</span><span class="s4">().</span><span class="s2">getBytes</span><span class="s4">());</span>
  <span class="s2">digestInfo</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">digestAlgorithm</span><span class="s4">);</span>
  <span class="s2">digestInfo</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">digest</span><span class="s4">);</span>

  <span class="s6">// encode digest info</span>
  <span class="s3">return </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">toDer</span><span class="s4">(</span><span class="s2">digestInfo</span><span class="s4">).</span><span class="s2">getBytes</span><span class="s4">();</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Performs x^c mod n (RSA encryption or decryption operation).</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">x the number to raise and mod.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">key the key to use.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">pub true if the key is public, false if private.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the result of x^c mod n.</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">_modPow </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">x</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s2">pub</span><span class="s4">) {</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">pub</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">x</span><span class="s4">.</span><span class="s2">modPow</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">e</span><span class="s4">, </span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s3">if</span><span class="s4">(!</span><span class="s2">key</span><span class="s4">.</span><span class="s2">p </span><span class="s4">|| !</span><span class="s2">key</span><span class="s4">.</span><span class="s2">q</span><span class="s4">) {</span>
    <span class="s6">// allow calculation without CRT params (slow)</span>
    <span class="s3">return </span><span class="s2">x</span><span class="s4">.</span><span class="s2">modPow</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">d</span><span class="s4">, </span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s6">// pre-compute dP, dQ, and qInv if necessary</span>
  <span class="s3">if</span><span class="s4">(!</span><span class="s2">key</span><span class="s4">.</span><span class="s2">dP</span><span class="s4">) {</span>
    <span class="s2">key</span><span class="s4">.</span><span class="s2">dP </span><span class="s4">= </span><span class="s2">key</span><span class="s4">.</span><span class="s2">d</span><span class="s4">.</span><span class="s2">mod</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">p</span><span class="s4">.</span><span class="s2">subtract</span><span class="s4">(</span><span class="s2">BigInteger</span><span class="s4">.</span><span class="s2">ONE</span><span class="s4">));</span>
  <span class="s4">}</span>
  <span class="s3">if</span><span class="s4">(!</span><span class="s2">key</span><span class="s4">.</span><span class="s2">dQ</span><span class="s4">) {</span>
    <span class="s2">key</span><span class="s4">.</span><span class="s2">dQ </span><span class="s4">= </span><span class="s2">key</span><span class="s4">.</span><span class="s2">d</span><span class="s4">.</span><span class="s2">mod</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">q</span><span class="s4">.</span><span class="s2">subtract</span><span class="s4">(</span><span class="s2">BigInteger</span><span class="s4">.</span><span class="s2">ONE</span><span class="s4">));</span>
  <span class="s4">}</span>
  <span class="s3">if</span><span class="s4">(!</span><span class="s2">key</span><span class="s4">.</span><span class="s2">qInv</span><span class="s4">) {</span>
    <span class="s2">key</span><span class="s4">.</span><span class="s2">qInv </span><span class="s4">= </span><span class="s2">key</span><span class="s4">.</span><span class="s2">q</span><span class="s4">.</span><span class="s2">modInverse</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">p</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s6">/* Chinese remainder theorem (CRT) states: 
 
    Suppose n1, n2, ..., nk are positive integers which are pairwise 
    coprime (n1 and n2 have no common factors other than 1). For any 
    integers x1, x2, ..., xk there exists an integer x solving the 
    system of simultaneous congruences (where ~= means modularly 
    congruent so a ~= b mod n means a mod n = b mod n): 
 
    x ~= x1 mod n1 
    x ~= x2 mod n2 
    ... 
    x ~= xk mod nk 
 
    This system of congruences has a single simultaneous solution x 
    between 0 and n - 1. Furthermore, each xk solution and x itself 
    is congruent modulo the product n = n1*n2*...*nk. 
    So x1 mod n = x2 mod n = xk mod n = x mod n. 
 
    The single simultaneous solution x can be solved with the following 
    equation: 
 
    x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni. 
 
    Where x is less than n, xi = x mod ni. 
 
    For RSA we are only concerned with k = 2. The modulus n = pq, where 
    p and q are coprime. The RSA decryption algorithm is: 
 
    y = x^d mod n 
 
    Given the above: 
 
    x1 = x^d mod p 
    r1 = n/p = q 
    s1 = q^-1 mod p 
    x2 = x^d mod q 
    r2 = n/q = p 
    s2 = p^-1 mod q 
 
    So y = (x1r1s1 + x2r2s2) mod n 
         = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n 
 
    According to Fermat's Little Theorem, if the modulus P is prime, 
    for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P. 
    Since A is not divisible by P it follows that if: 
    N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore: 
 
    A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort 
    to calculate). In order to calculate x^d mod p more quickly the 
    exponent d mod (p - 1) is stored in the RSA private key (the same 
    is done for x^d mod q). These values are referred to as dP and dQ 
    respectively. Therefore we now have: 
 
    y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n 
 
    Since we'll be reducing x^dP by modulo p (same for q) we can also 
    reduce x by p (and q respectively) before hand. Therefore, let 
 
    xp = ((x mod p)^dP mod p), and 
    xq = ((x mod q)^dQ mod q), yielding: 
 
    y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n 
 
    This can be further reduced to a simple algorithm that only 
    requires 1 inverse (the q inverse is used) to be used and stored. 
    The algorithm is called Garner's algorithm. If qInv is the 
    inverse of q, we simply calculate: 
 
    y = (qInv*(xp - xq) mod p) * q + xq 
 
    However, there are two further complications. First, we need to 
    ensure that xp &gt; xq to prevent signed BigIntegers from being used 
    so we add p until this is true (since we will be mod'ing with 
    p anyway). Then, there is a known timing attack on algorithms 
    using the CRT. To mitigate this risk, &quot;cryptographic blinding&quot; 
    should be used. This requires simply generating a random number r 
    between 0 and n-1 and its inverse and multiplying x by r^e before 
    calculating y and then multiplying y by r^-1 afterwards. Note that 
    r must be coprime with n (gcd(r, n) === 1) in order to have an 
    inverse. 
  */</span>

  <span class="s6">// cryptographic blinding</span>
  <span class="s3">var </span><span class="s2">r</span><span class="s4">;</span>
  <span class="s3">do </span><span class="s4">{</span>
    <span class="s2">r </span><span class="s4">= </span><span class="s3">new </span><span class="s2">BigInteger</span><span class="s4">(</span>
      <span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">bytesToHex</span><span class="s4">(</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">random</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">.</span><span class="s2">bitLength</span><span class="s4">() / </span><span class="s7">8</span><span class="s4">)),</span>
      <span class="s7">16</span><span class="s4">);</span>
  <span class="s4">} </span><span class="s3">while</span><span class="s4">(</span><span class="s2">r</span><span class="s4">.</span><span class="s2">compareTo</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">) &gt;= </span><span class="s7">0 </span><span class="s4">|| !</span><span class="s2">r</span><span class="s4">.</span><span class="s2">gcd</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">).</span><span class="s2">equals</span><span class="s4">(</span><span class="s2">BigInteger</span><span class="s4">.</span><span class="s2">ONE</span><span class="s4">));</span>
  <span class="s2">x </span><span class="s4">= </span><span class="s2">x</span><span class="s4">.</span><span class="s2">multiply</span><span class="s4">(</span><span class="s2">r</span><span class="s4">.</span><span class="s2">modPow</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">e</span><span class="s4">, </span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">)).</span><span class="s2">mod</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">);</span>

  <span class="s6">// calculate xp and xq</span>
  <span class="s3">var </span><span class="s2">xp </span><span class="s4">= </span><span class="s2">x</span><span class="s4">.</span><span class="s2">mod</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">p</span><span class="s4">).</span><span class="s2">modPow</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">dP</span><span class="s4">, </span><span class="s2">key</span><span class="s4">.</span><span class="s2">p</span><span class="s4">);</span>
  <span class="s3">var </span><span class="s2">xq </span><span class="s4">= </span><span class="s2">x</span><span class="s4">.</span><span class="s2">mod</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">q</span><span class="s4">).</span><span class="s2">modPow</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">dQ</span><span class="s4">, </span><span class="s2">key</span><span class="s4">.</span><span class="s2">q</span><span class="s4">);</span>

  <span class="s6">// xp must be larger than xq to avoid signed bit usage</span>
  <span class="s3">while</span><span class="s4">(</span><span class="s2">xp</span><span class="s4">.</span><span class="s2">compareTo</span><span class="s4">(</span><span class="s2">xq</span><span class="s4">) &lt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s2">xp </span><span class="s4">= </span><span class="s2">xp</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">p</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s6">// do last step</span>
  <span class="s3">var </span><span class="s2">y </span><span class="s4">= </span><span class="s2">xp</span><span class="s4">.</span><span class="s2">subtract</span><span class="s4">(</span><span class="s2">xq</span><span class="s4">)</span>
    <span class="s4">.</span><span class="s2">multiply</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">qInv</span><span class="s4">).</span><span class="s2">mod</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">p</span><span class="s4">)</span>
    <span class="s4">.</span><span class="s2">multiply</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">q</span><span class="s4">).</span><span class="s2">add</span><span class="s4">(</span><span class="s2">xq</span><span class="s4">);</span>

  <span class="s6">// remove effect of random for cryptographic blinding</span>
  <span class="s2">y </span><span class="s4">= </span><span class="s2">y</span><span class="s4">.</span><span class="s2">multiply</span><span class="s4">(</span><span class="s2">r</span><span class="s4">.</span><span class="s2">modInverse</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">)).</span><span class="s2">mod</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">);</span>

  <span class="s3">return </span><span class="s2">y</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* NOTE: THIS METHOD IS DEPRECATED, use 'sign' on a private key object or</span>
 <span class="s0">* 'encrypt' on a public key object instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Performs RSA encryption.</span>
 <span class="s0">*</span>
 <span class="s0">* The parameter bt controls whether to put padding bytes before the</span>
 <span class="s0">* message passed in. Set bt to either true or false to disable padding</span>
 <span class="s0">* completely (in order to handle e.g. EMSA-PSS encoding seperately before),</span>
 <span class="s0">* signaling whether the encryption operation is a public key operation</span>
 <span class="s0">* (i.e. encrypting data) or not, i.e. private key operation (data signing).</span>
 <span class="s0">*</span>
 <span class="s0">* For PKCS#1 v1.5 padding pass in the block type to use, i.e. either 0x01</span>
 <span class="s0">* (for signing) or 0x02 (for encryption). The key operation mode (private</span>
 <span class="s0">* or public) is derived from this flag in that case).</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">m the message to encrypt as a byte string.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">key the RSA key to use.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">bt for PKCS#1 v1.5 padding, the block type to use</span>
 <span class="s0">*   (0x01 for private key, 0x02 for public),</span>
 <span class="s0">*   to disable padding: true = public key, false = private key.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the encrypted bytes as a string.</span>
 <span class="s0">*/</span>
<span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">encrypt </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">m</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s2">bt</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">pub </span><span class="s4">= </span><span class="s2">bt</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">eb</span><span class="s4">;</span>

  <span class="s6">// get the length of the modulus in bytes</span>
  <span class="s3">var </span><span class="s2">k </span><span class="s4">= </span><span class="s2">Math</span><span class="s4">.</span><span class="s2">ceil</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">.</span><span class="s2">bitLength</span><span class="s4">() / </span><span class="s7">8</span><span class="s4">);</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">bt </span><span class="s4">!== </span><span class="s3">false </span><span class="s4">&amp;&amp; </span><span class="s2">bt </span><span class="s4">!== </span><span class="s3">true</span><span class="s4">) {</span>
    <span class="s6">// legacy, default to PKCS#1 v1.5 padding</span>
    <span class="s2">pub </span><span class="s4">= (</span><span class="s2">bt </span><span class="s4">=== </span><span class="s7">0x02</span><span class="s4">);</span>
    <span class="s2">eb </span><span class="s4">= </span><span class="s2">_encodePkcs1_v1_5</span><span class="s4">(</span><span class="s2">m</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s2">bt</span><span class="s4">);</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s2">eb </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">();</span>
    <span class="s2">eb</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s2">m</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s6">// load encryption block as big integer 'x'</span>
  <span class="s6">// FIXME: hex conversion inefficient, get BigInteger w/byte strings</span>
  <span class="s3">var </span><span class="s2">x </span><span class="s4">= </span><span class="s3">new </span><span class="s2">BigInteger</span><span class="s4">(</span><span class="s2">eb</span><span class="s4">.</span><span class="s2">toHex</span><span class="s4">(), </span><span class="s7">16</span><span class="s4">);</span>

  <span class="s6">// do RSA encryption</span>
  <span class="s3">var </span><span class="s2">y </span><span class="s4">= </span><span class="s2">_modPow</span><span class="s4">(</span><span class="s2">x</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s2">pub</span><span class="s4">);</span>

  <span class="s6">// convert y into the encrypted data byte string, if y is shorter in</span>
  <span class="s6">// bytes than k, then prepend zero bytes to fill up ed</span>
  <span class="s6">// FIXME: hex conversion inefficient, get BigInteger w/byte strings</span>
  <span class="s3">var </span><span class="s2">yhex </span><span class="s4">= </span><span class="s2">y</span><span class="s4">.</span><span class="s2">toString</span><span class="s4">(</span><span class="s7">16</span><span class="s4">);</span>
  <span class="s3">var </span><span class="s2">ed </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">();</span>
  <span class="s3">var </span><span class="s2">zeros </span><span class="s4">= </span><span class="s2">k </span><span class="s4">- </span><span class="s2">Math</span><span class="s4">.</span><span class="s2">ceil</span><span class="s4">(</span><span class="s2">yhex</span><span class="s4">.</span><span class="s2">length </span><span class="s4">/ </span><span class="s7">2</span><span class="s4">);</span>
  <span class="s3">while</span><span class="s4">(</span><span class="s2">zeros </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s2">ed</span><span class="s4">.</span><span class="s2">putByte</span><span class="s4">(</span><span class="s7">0x00</span><span class="s4">);</span>
    <span class="s4">--</span><span class="s2">zeros</span><span class="s4">;</span>
  <span class="s4">}</span>
  <span class="s2">ed</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">hexToBytes</span><span class="s4">(</span><span class="s2">yhex</span><span class="s4">));</span>
  <span class="s3">return </span><span class="s2">ed</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">();</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* NOTE: THIS METHOD IS DEPRECATED, use 'decrypt' on a private key object or</span>
 <span class="s0">* 'verify' on a public key object instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Performs RSA decryption.</span>
 <span class="s0">*</span>
 <span class="s0">* The parameter ml controls whether to apply PKCS#1 v1.5 padding</span>
 <span class="s0">* or not.  Set ml = false to disable padding removal completely</span>
 <span class="s0">* (in order to handle e.g. EMSA-PSS later on) and simply pass back</span>
 <span class="s0">* the RSA encryption block.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">ed the encrypted data to decrypt in as a byte string.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">key the RSA key to use.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">pub true for a public key operation, false for private.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">ml the message length, if known, false to disable padding.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the decrypted message as a byte string.</span>
 <span class="s0">*/</span>
<span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">decrypt </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">ed</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s2">pub</span><span class="s4">, </span><span class="s2">ml</span><span class="s4">) {</span>
  <span class="s6">// get the length of the modulus in bytes</span>
  <span class="s3">var </span><span class="s2">k </span><span class="s4">= </span><span class="s2">Math</span><span class="s4">.</span><span class="s2">ceil</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">.</span><span class="s2">bitLength</span><span class="s4">() / </span><span class="s7">8</span><span class="s4">);</span>

  <span class="s6">// error if the length of the encrypted data ED is not k</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">ed</span><span class="s4">.</span><span class="s2">length </span><span class="s4">!== </span><span class="s2">k</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">error </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Encrypted message length is invalid.'</span><span class="s4">);</span>
    <span class="s2">error</span><span class="s4">.</span><span class="s2">length </span><span class="s4">= </span><span class="s2">ed</span><span class="s4">.</span><span class="s2">length</span><span class="s4">;</span>
    <span class="s2">error</span><span class="s4">.</span><span class="s2">expected </span><span class="s4">= </span><span class="s2">k</span><span class="s4">;</span>
    <span class="s3">throw </span><span class="s2">error</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// convert encrypted data into a big integer</span>
  <span class="s6">// FIXME: hex conversion inefficient, get BigInteger w/byte strings</span>
  <span class="s3">var </span><span class="s2">y </span><span class="s4">= </span><span class="s3">new </span><span class="s2">BigInteger</span><span class="s4">(</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">ed</span><span class="s4">).</span><span class="s2">toHex</span><span class="s4">(), </span><span class="s7">16</span><span class="s4">);</span>

  <span class="s6">// y must be less than the modulus or it wasn't the result of</span>
  <span class="s6">// a previous mod operation (encryption) using that modulus</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">y</span><span class="s4">.</span><span class="s2">compareTo</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">) &gt;= </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Encrypted message is invalid.'</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s6">// do RSA decryption</span>
  <span class="s3">var </span><span class="s2">x </span><span class="s4">= </span><span class="s2">_modPow</span><span class="s4">(</span><span class="s2">y</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s2">pub</span><span class="s4">);</span>

  <span class="s6">// create the encryption block, if x is shorter in bytes than k, then</span>
  <span class="s6">// prepend zero bytes to fill up eb</span>
  <span class="s6">// FIXME: hex conversion inefficient, get BigInteger w/byte strings</span>
  <span class="s3">var </span><span class="s2">xhex </span><span class="s4">= </span><span class="s2">x</span><span class="s4">.</span><span class="s2">toString</span><span class="s4">(</span><span class="s7">16</span><span class="s4">);</span>
  <span class="s3">var </span><span class="s2">eb </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">();</span>
  <span class="s3">var </span><span class="s2">zeros </span><span class="s4">= </span><span class="s2">k </span><span class="s4">- </span><span class="s2">Math</span><span class="s4">.</span><span class="s2">ceil</span><span class="s4">(</span><span class="s2">xhex</span><span class="s4">.</span><span class="s2">length </span><span class="s4">/ </span><span class="s7">2</span><span class="s4">);</span>
  <span class="s3">while</span><span class="s4">(</span><span class="s2">zeros </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s2">eb</span><span class="s4">.</span><span class="s2">putByte</span><span class="s4">(</span><span class="s7">0x00</span><span class="s4">);</span>
    <span class="s4">--</span><span class="s2">zeros</span><span class="s4">;</span>
  <span class="s4">}</span>
  <span class="s2">eb</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">hexToBytes</span><span class="s4">(</span><span class="s2">xhex</span><span class="s4">));</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">ml </span><span class="s4">!== </span><span class="s3">false</span><span class="s4">) {</span>
    <span class="s6">// legacy, default to PKCS#1 v1.5 padding</span>
    <span class="s3">return </span><span class="s2">_decodePkcs1_v1_5</span><span class="s4">(</span><span class="s2">eb</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(), </span><span class="s2">key</span><span class="s4">, </span><span class="s2">pub</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s6">// return message</span>
  <span class="s3">return </span><span class="s2">eb</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">();</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Creates an RSA key-pair generation state object. It is used to allow</span>
 <span class="s0">* key-generation to be performed in steps. It also allows for a UI to</span>
 <span class="s0">* display progress updates.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">bits the size for the private key in bits, defaults to 2048.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">e the public exponent to use, defaults to 65537 (0x10001).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">[options] the options to use.</span>
 <span class="s0">*          prng a custom crypto-secure pseudo-random number generator to use,</span>
 <span class="s0">*            that must define &quot;getBytesSync&quot;.</span>
 <span class="s0">*          algorithm the algorithm to use (default: 'PRIMEINC').</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the state object to use to generate the key-pair.</span>
 <span class="s0">*/</span>
<span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">createKeyPairGenerationState </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">bits</span><span class="s4">, </span><span class="s2">e</span><span class="s4">, </span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s6">// TODO: migrate step-based prime generation code to forge.prime</span>

  <span class="s6">// set default bits</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof</span><span class="s4">(</span><span class="s2">bits</span><span class="s4">) === </span><span class="s5">'string'</span><span class="s4">) {</span>
    <span class="s2">bits </span><span class="s4">= </span><span class="s2">parseInt</span><span class="s4">(</span><span class="s2">bits</span><span class="s4">, </span><span class="s7">10</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s2">bits </span><span class="s4">= </span><span class="s2">bits </span><span class="s4">|| </span><span class="s7">2048</span><span class="s4">;</span>

  <span class="s6">// create prng with api that matches BigInteger secure random</span>
  <span class="s2">options </span><span class="s4">= </span><span class="s2">options </span><span class="s4">|| {};</span>
  <span class="s3">var </span><span class="s2">prng </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">prng </span><span class="s4">|| </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">random</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">rng </span><span class="s4">= {</span>
    <span class="s6">// x is an array to fill with bytes</span>
    <span class="s2">nextBytes</span><span class="s4">: </span><span class="s3">function</span><span class="s4">(</span><span class="s2">x</span><span class="s4">) {</span>
      <span class="s3">var </span><span class="s2">b </span><span class="s4">= </span><span class="s2">prng</span><span class="s4">.</span><span class="s2">getBytesSync</span><span class="s4">(</span><span class="s2">x</span><span class="s4">.</span><span class="s2">length</span><span class="s4">);</span>
      <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">x</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
        <span class="s2">x</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s2">b</span><span class="s4">.</span><span class="s2">charCodeAt</span><span class="s4">(</span><span class="s2">i</span><span class="s4">);</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
  <span class="s4">};</span>

  <span class="s3">var </span><span class="s2">algorithm </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">algorithm </span><span class="s4">|| </span><span class="s5">'PRIMEINC'</span><span class="s4">;</span>

  <span class="s6">// create PRIMEINC algorithm state</span>
  <span class="s3">var </span><span class="s2">rval</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">algorithm </span><span class="s4">=== </span><span class="s5">'PRIMEINC'</span><span class="s4">) {</span>
    <span class="s2">rval </span><span class="s4">= {</span>
      <span class="s2">algorithm</span><span class="s4">: </span><span class="s2">algorithm</span><span class="s4">,</span>
      <span class="s2">state</span><span class="s4">: </span><span class="s7">0</span><span class="s4">,</span>
      <span class="s2">bits</span><span class="s4">: </span><span class="s2">bits</span><span class="s4">,</span>
      <span class="s2">rng</span><span class="s4">: </span><span class="s2">rng</span><span class="s4">,</span>
      <span class="s2">eInt</span><span class="s4">: </span><span class="s2">e </span><span class="s4">|| </span><span class="s7">65537</span><span class="s4">,</span>
      <span class="s2">e</span><span class="s4">: </span><span class="s3">new </span><span class="s2">BigInteger</span><span class="s4">(</span><span class="s3">null</span><span class="s4">),</span>
      <span class="s2">p</span><span class="s4">: </span><span class="s3">null</span><span class="s4">,</span>
      <span class="s2">q</span><span class="s4">: </span><span class="s3">null</span><span class="s4">,</span>
      <span class="s2">qBits</span><span class="s4">: </span><span class="s2">bits </span><span class="s4">&gt;&gt; </span><span class="s7">1</span><span class="s4">,</span>
      <span class="s2">pBits</span><span class="s4">: </span><span class="s2">bits </span><span class="s4">- (</span><span class="s2">bits </span><span class="s4">&gt;&gt; </span><span class="s7">1</span><span class="s4">),</span>
      <span class="s2">pqState</span><span class="s4">: </span><span class="s7">0</span><span class="s4">,</span>
      <span class="s2">num</span><span class="s4">: </span><span class="s3">null</span><span class="s4">,</span>
      <span class="s2">keys</span><span class="s4">: </span><span class="s3">null</span>
    <span class="s4">};</span>
    <span class="s2">rval</span><span class="s4">.</span><span class="s2">e</span><span class="s4">.</span><span class="s2">fromInt</span><span class="s4">(</span><span class="s2">rval</span><span class="s4">.</span><span class="s2">eInt</span><span class="s4">);</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Invalid key generation algorithm: ' </span><span class="s4">+ </span><span class="s2">algorithm</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s3">return </span><span class="s2">rval</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Attempts to runs the key-generation algorithm for at most n seconds</span>
 <span class="s0">* (approximately) using the given state. When key-generation has completed,</span>
 <span class="s0">* the keys will be stored in state.keys.</span>
 <span class="s0">*</span>
 <span class="s0">* To use this function to update a UI while generating a key or to prevent</span>
 <span class="s0">* causing browser lockups/warnings, set &quot;n&quot; to a value other than 0. A</span>
 <span class="s0">* simple pattern for generating a key and showing a progress indicator is:</span>
 <span class="s0">*</span>
 <span class="s0">* var state = pki.rsa.createKeyPairGenerationState(2048);</span>
 <span class="s0">* var step = function() {</span>
 <span class="s0">*   // step key-generation, run algorithm for 100 ms, repeat</span>
 <span class="s0">*   if(!forge.pki.rsa.stepKeyPairGenerationState(state, 100)) {</span>
 <span class="s0">*     setTimeout(step, 1);</span>
 <span class="s0">*   } else {</span>
 <span class="s0">*     // key-generation complete</span>
 <span class="s0">*     // TODO: turn off progress indicator here</span>
 <span class="s0">*     // TODO: use the generated key-pair in &quot;state.keys&quot;</span>
 <span class="s0">*   }</span>
 <span class="s0">* };</span>
 <span class="s0">* // TODO: turn on progress indicator here</span>
 <span class="s0">* setTimeout(step, 0);</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">state the state to use.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">n the maximum number of milliseconds to run the algorithm for, 0</span>
 <span class="s0">*          to run the algorithm to completion.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">true if the key-generation completed, false if not.</span>
 <span class="s0">*/</span>
<span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">stepKeyPairGenerationState </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">state</span><span class="s4">, </span><span class="s2">n</span><span class="s4">) {</span>
  <span class="s6">// set default algorithm if not set</span>
  <span class="s3">if</span><span class="s4">(!(</span><span class="s5">'algorithm' </span><span class="s3">in </span><span class="s2">state</span><span class="s4">)) {</span>
    <span class="s2">state</span><span class="s4">.</span><span class="s2">algorithm </span><span class="s4">= </span><span class="s5">'PRIMEINC'</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// TODO: migrate step-based prime generation code to forge.prime</span>
  <span class="s6">// TODO: abstract as PRIMEINC algorithm</span>

  <span class="s6">// do key generation (based on Tom Wu's rsa.js, see jsbn.js license)</span>
  <span class="s6">// with some minor optimizations and designed to run in steps</span>

  <span class="s6">// local state vars</span>
  <span class="s3">var </span><span class="s2">THIRTY </span><span class="s4">= </span><span class="s3">new </span><span class="s2">BigInteger</span><span class="s4">(</span><span class="s3">null</span><span class="s4">);</span>
  <span class="s2">THIRTY</span><span class="s4">.</span><span class="s2">fromInt</span><span class="s4">(</span><span class="s7">30</span><span class="s4">);</span>
  <span class="s3">var </span><span class="s2">deltaIdx </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">op_or </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">x</span><span class="s4">, </span><span class="s2">y</span><span class="s4">) {</span><span class="s3">return </span><span class="s2">x </span><span class="s4">| </span><span class="s2">y</span><span class="s4">;};</span>

  <span class="s6">// keep stepping until time limit is reached or done</span>
  <span class="s3">var </span><span class="s2">t1 </span><span class="s4">= +</span><span class="s3">new </span><span class="s2">Date</span><span class="s4">();</span>
  <span class="s3">var </span><span class="s2">t2</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">total </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
  <span class="s3">while</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">keys </span><span class="s4">=== </span><span class="s3">null </span><span class="s4">&amp;&amp; (</span><span class="s2">n </span><span class="s4">&lt;= </span><span class="s7">0 </span><span class="s4">|| </span><span class="s2">total </span><span class="s4">&lt; </span><span class="s2">n</span><span class="s4">)) {</span>
    <span class="s6">// generate p or q</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">state </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
      <span class="s6">/* Note: All primes are of the form: 
 
        30k+i, for i &lt; 30 and gcd(30, i)=1, where there are 8 values for i 
 
        When we generate a random number, we always align it at 30k + 1. Each 
        time the number is determined not to be prime we add to get to the 
        next 'i', eg: if the number was at 30k + 1 we add 6. */</span>
      <span class="s3">var </span><span class="s2">bits </span><span class="s4">= (</span><span class="s2">state</span><span class="s4">.</span><span class="s2">p </span><span class="s4">=== </span><span class="s3">null</span><span class="s4">) ? </span><span class="s2">state</span><span class="s4">.</span><span class="s2">pBits </span><span class="s4">: </span><span class="s2">state</span><span class="s4">.</span><span class="s2">qBits</span><span class="s4">;</span>
      <span class="s3">var </span><span class="s2">bits1 </span><span class="s4">= </span><span class="s2">bits </span><span class="s4">- </span><span class="s7">1</span><span class="s4">;</span>

      <span class="s6">// get a random number</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">pqState </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
        <span class="s2">state</span><span class="s4">.</span><span class="s2">num </span><span class="s4">= </span><span class="s3">new </span><span class="s2">BigInteger</span><span class="s4">(</span><span class="s2">bits</span><span class="s4">, </span><span class="s2">state</span><span class="s4">.</span><span class="s2">rng</span><span class="s4">);</span>
        <span class="s6">// force MSB set</span>
        <span class="s3">if</span><span class="s4">(!</span><span class="s2">state</span><span class="s4">.</span><span class="s2">num</span><span class="s4">.</span><span class="s2">testBit</span><span class="s4">(</span><span class="s2">bits1</span><span class="s4">)) {</span>
          <span class="s2">state</span><span class="s4">.</span><span class="s2">num</span><span class="s4">.</span><span class="s2">bitwiseTo</span><span class="s4">(</span>
            <span class="s2">BigInteger</span><span class="s4">.</span><span class="s2">ONE</span><span class="s4">.</span><span class="s2">shiftLeft</span><span class="s4">(</span><span class="s2">bits1</span><span class="s4">), </span><span class="s2">op_or</span><span class="s4">, </span><span class="s2">state</span><span class="s4">.</span><span class="s2">num</span><span class="s4">);</span>
        <span class="s4">}</span>
        <span class="s6">// align number on 30k+1 boundary</span>
        <span class="s2">state</span><span class="s4">.</span><span class="s2">num</span><span class="s4">.</span><span class="s2">dAddOffset</span><span class="s4">(</span><span class="s7">31 </span><span class="s4">- </span><span class="s2">state</span><span class="s4">.</span><span class="s2">num</span><span class="s4">.</span><span class="s2">mod</span><span class="s4">(</span><span class="s2">THIRTY</span><span class="s4">).</span><span class="s2">byteValue</span><span class="s4">(), </span><span class="s7">0</span><span class="s4">);</span>
        <span class="s2">deltaIdx </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>

        <span class="s4">++</span><span class="s2">state</span><span class="s4">.</span><span class="s2">pqState</span><span class="s4">;</span>
      <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">pqState </span><span class="s4">=== </span><span class="s7">1</span><span class="s4">) {</span>
        <span class="s6">// try to make the number a prime</span>
        <span class="s3">if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">num</span><span class="s4">.</span><span class="s2">bitLength</span><span class="s4">() &gt; </span><span class="s2">bits</span><span class="s4">) {</span>
          <span class="s6">// overflow, try again</span>
          <span class="s2">state</span><span class="s4">.</span><span class="s2">pqState </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
          <span class="s6">// do primality test</span>
        <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">num</span><span class="s4">.</span><span class="s2">isProbablePrime</span><span class="s4">(</span>
          <span class="s2">_getMillerRabinTests</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">num</span><span class="s4">.</span><span class="s2">bitLength</span><span class="s4">()))) {</span>
          <span class="s4">++</span><span class="s2">state</span><span class="s4">.</span><span class="s2">pqState</span><span class="s4">;</span>
        <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
          <span class="s6">// get next potential prime</span>
          <span class="s2">state</span><span class="s4">.</span><span class="s2">num</span><span class="s4">.</span><span class="s2">dAddOffset</span><span class="s4">(</span><span class="s2">GCD_30_DELTA</span><span class="s4">[</span><span class="s2">deltaIdx</span><span class="s4">++ % </span><span class="s7">8</span><span class="s4">], </span><span class="s7">0</span><span class="s4">);</span>
        <span class="s4">}</span>
      <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">pqState </span><span class="s4">=== </span><span class="s7">2</span><span class="s4">) {</span>
        <span class="s6">// ensure number is coprime with e</span>
        <span class="s2">state</span><span class="s4">.</span><span class="s2">pqState </span><span class="s4">=</span>
          <span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">num</span><span class="s4">.</span><span class="s2">subtract</span><span class="s4">(</span><span class="s2">BigInteger</span><span class="s4">.</span><span class="s2">ONE</span><span class="s4">).</span><span class="s2">gcd</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">e</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s2">compareTo</span><span class="s4">(</span><span class="s2">BigInteger</span><span class="s4">.</span><span class="s2">ONE</span><span class="s4">) === </span><span class="s7">0</span><span class="s4">) ? </span><span class="s7">3 </span><span class="s4">: </span><span class="s7">0</span><span class="s4">;</span>
      <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">pqState </span><span class="s4">=== </span><span class="s7">3</span><span class="s4">) {</span>
        <span class="s6">// store p or q</span>
        <span class="s2">state</span><span class="s4">.</span><span class="s2">pqState </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
        <span class="s3">if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">p </span><span class="s4">=== </span><span class="s3">null</span><span class="s4">) {</span>
          <span class="s2">state</span><span class="s4">.</span><span class="s2">p </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">num</span><span class="s4">;</span>
        <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
          <span class="s2">state</span><span class="s4">.</span><span class="s2">q </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">num</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s6">// advance state if both p and q are ready</span>
        <span class="s3">if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">p </span><span class="s4">!== </span><span class="s3">null </span><span class="s4">&amp;&amp; </span><span class="s2">state</span><span class="s4">.</span><span class="s2">q </span><span class="s4">!== </span><span class="s3">null</span><span class="s4">) {</span>
          <span class="s4">++</span><span class="s2">state</span><span class="s4">.</span><span class="s2">state</span><span class="s4">;</span>
        <span class="s4">}</span>
        <span class="s2">state</span><span class="s4">.</span><span class="s2">num </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
      <span class="s4">}</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">state </span><span class="s4">=== </span><span class="s7">1</span><span class="s4">) {</span>
      <span class="s6">// ensure p is larger than q (swap them if not)</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">p</span><span class="s4">.</span><span class="s2">compareTo</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">q</span><span class="s4">) &lt; </span><span class="s7">0</span><span class="s4">) {</span>
        <span class="s2">state</span><span class="s4">.</span><span class="s2">num </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">p</span><span class="s4">;</span>
        <span class="s2">state</span><span class="s4">.</span><span class="s2">p </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">q</span><span class="s4">;</span>
        <span class="s2">state</span><span class="s4">.</span><span class="s2">q </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">num</span><span class="s4">;</span>
      <span class="s4">}</span>
      <span class="s4">++</span><span class="s2">state</span><span class="s4">.</span><span class="s2">state</span><span class="s4">;</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">state </span><span class="s4">=== </span><span class="s7">2</span><span class="s4">) {</span>
      <span class="s6">// compute phi: (p - 1)(q - 1) (Euler's totient function)</span>
      <span class="s2">state</span><span class="s4">.</span><span class="s2">p1 </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">p</span><span class="s4">.</span><span class="s2">subtract</span><span class="s4">(</span><span class="s2">BigInteger</span><span class="s4">.</span><span class="s2">ONE</span><span class="s4">);</span>
      <span class="s2">state</span><span class="s4">.</span><span class="s2">q1 </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">q</span><span class="s4">.</span><span class="s2">subtract</span><span class="s4">(</span><span class="s2">BigInteger</span><span class="s4">.</span><span class="s2">ONE</span><span class="s4">);</span>
      <span class="s2">state</span><span class="s4">.</span><span class="s2">phi </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">p1</span><span class="s4">.</span><span class="s2">multiply</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">q1</span><span class="s4">);</span>
      <span class="s4">++</span><span class="s2">state</span><span class="s4">.</span><span class="s2">state</span><span class="s4">;</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">state </span><span class="s4">=== </span><span class="s7">3</span><span class="s4">) {</span>
      <span class="s6">// ensure e and phi are coprime</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">phi</span><span class="s4">.</span><span class="s2">gcd</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">e</span><span class="s4">).</span><span class="s2">compareTo</span><span class="s4">(</span><span class="s2">BigInteger</span><span class="s4">.</span><span class="s2">ONE</span><span class="s4">) === </span><span class="s7">0</span><span class="s4">) {</span>
        <span class="s6">// phi and e are coprime, advance</span>
        <span class="s4">++</span><span class="s2">state</span><span class="s4">.</span><span class="s2">state</span><span class="s4">;</span>
      <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
        <span class="s6">// phi and e aren't coprime, so generate a new p and q</span>
        <span class="s2">state</span><span class="s4">.</span><span class="s2">p </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
        <span class="s2">state</span><span class="s4">.</span><span class="s2">q </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
        <span class="s2">state</span><span class="s4">.</span><span class="s2">state </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
      <span class="s4">}</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">state </span><span class="s4">=== </span><span class="s7">4</span><span class="s4">) {</span>
      <span class="s6">// create n, ensure n is has the right number of bits</span>
      <span class="s2">state</span><span class="s4">.</span><span class="s2">n </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">p</span><span class="s4">.</span><span class="s2">multiply</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">q</span><span class="s4">);</span>

      <span class="s6">// ensure n is right number of bits</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">n</span><span class="s4">.</span><span class="s2">bitLength</span><span class="s4">() === </span><span class="s2">state</span><span class="s4">.</span><span class="s2">bits</span><span class="s4">) {</span>
        <span class="s6">// success, advance</span>
        <span class="s4">++</span><span class="s2">state</span><span class="s4">.</span><span class="s2">state</span><span class="s4">;</span>
      <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
        <span class="s6">// failed, get new q</span>
        <span class="s2">state</span><span class="s4">.</span><span class="s2">q </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
        <span class="s2">state</span><span class="s4">.</span><span class="s2">state </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
      <span class="s4">}</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">state </span><span class="s4">=== </span><span class="s7">5</span><span class="s4">) {</span>
      <span class="s6">// set keys</span>
      <span class="s3">var </span><span class="s2">d </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">e</span><span class="s4">.</span><span class="s2">modInverse</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">phi</span><span class="s4">);</span>
      <span class="s2">state</span><span class="s4">.</span><span class="s2">keys </span><span class="s4">= {</span>
        <span class="s2">privateKey</span><span class="s4">: </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">setPrivateKey</span><span class="s4">(</span>
          <span class="s2">state</span><span class="s4">.</span><span class="s2">n</span><span class="s4">, </span><span class="s2">state</span><span class="s4">.</span><span class="s2">e</span><span class="s4">, </span><span class="s2">d</span><span class="s4">, </span><span class="s2">state</span><span class="s4">.</span><span class="s2">p</span><span class="s4">, </span><span class="s2">state</span><span class="s4">.</span><span class="s2">q</span><span class="s4">,</span>
          <span class="s2">d</span><span class="s4">.</span><span class="s2">mod</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">p1</span><span class="s4">), </span><span class="s2">d</span><span class="s4">.</span><span class="s2">mod</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">q1</span><span class="s4">),</span>
          <span class="s2">state</span><span class="s4">.</span><span class="s2">q</span><span class="s4">.</span><span class="s2">modInverse</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">p</span><span class="s4">)),</span>
        <span class="s2">publicKey</span><span class="s4">: </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">setPublicKey</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">n</span><span class="s4">, </span><span class="s2">state</span><span class="s4">.</span><span class="s2">e</span><span class="s4">)</span>
      <span class="s4">};</span>
    <span class="s4">}</span>

    <span class="s6">// update timing</span>
    <span class="s2">t2 </span><span class="s4">= +</span><span class="s3">new </span><span class="s2">Date</span><span class="s4">();</span>
    <span class="s2">total </span><span class="s4">+= </span><span class="s2">t2 </span><span class="s4">- </span><span class="s2">t1</span><span class="s4">;</span>
    <span class="s2">t1 </span><span class="s4">= </span><span class="s2">t2</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s3">return </span><span class="s2">state</span><span class="s4">.</span><span class="s2">keys </span><span class="s4">!== </span><span class="s3">null</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Generates an RSA public-private key pair in a single call.</span>
 <span class="s0">*</span>
 <span class="s0">* To generate a key-pair in steps (to allow for progress updates and to</span>
 <span class="s0">* prevent blocking or warnings in slow browsers) then use the key-pair</span>
 <span class="s0">* generation state functions.</span>
 <span class="s0">*</span>
 <span class="s0">* To generate a key-pair asynchronously (either through web-workers, if</span>
 <span class="s0">* available, or by breaking up the work on the main thread), pass a</span>
 <span class="s0">* callback function.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">[bits] the size for the private key in bits, defaults to 2048.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">[e] the public exponent to use, defaults to 65537.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">[options] options for key-pair generation, if given then 'bits'</span>
 <span class="s0">*            and 'e' must *not* be given:</span>
 <span class="s0">*          bits the size for the private key in bits, (default: 2048).</span>
 <span class="s0">*          e the public exponent to use, (default: 65537 (0x10001)).</span>
 <span class="s0">*          workerScript the worker script URL.</span>
 <span class="s0">*          workers the number of web workers (if supported) to use,</span>
 <span class="s0">*            (default: 2).</span>
 <span class="s0">*          workLoad the size of the work load, ie: number of possible prime</span>
 <span class="s0">*            numbers for each web worker to check per work assignment,</span>
 <span class="s0">*            (default: 100).</span>
 <span class="s0">*          prng a custom crypto-secure pseudo-random number generator to use,</span>
 <span class="s0">*            that must define &quot;getBytesSync&quot;. Disables use of native APIs.</span>
 <span class="s0">*          algorithm the algorithm to use (default: 'PRIMEINC').</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">[callback(err, keypair)] called once the operation completes.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">an object with privateKey and publicKey properties.</span>
 <span class="s0">*/</span>
<span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">generateKeyPair </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">bits</span><span class="s4">, </span><span class="s2">e</span><span class="s4">, </span><span class="s2">options</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
  <span class="s6">// (bits), (options), (callback)</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">arguments</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">1</span><span class="s4">) {</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">bits </span><span class="s4">=== </span><span class="s5">'object'</span><span class="s4">) {</span>
      <span class="s2">options </span><span class="s4">= </span><span class="s2">bits</span><span class="s4">;</span>
      <span class="s2">bits </span><span class="s4">= </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">bits </span><span class="s4">=== </span><span class="s5">'function'</span><span class="s4">) {</span>
      <span class="s2">callback </span><span class="s4">= </span><span class="s2">bits</span><span class="s4">;</span>
      <span class="s2">bits </span><span class="s4">= </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s4">}</span>
  <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">arguments</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">2</span><span class="s4">) {</span>
    <span class="s6">// (bits, e), (bits, options), (bits, callback), (options, callback)</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">bits </span><span class="s4">=== </span><span class="s5">'number'</span><span class="s4">) {</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">e </span><span class="s4">=== </span><span class="s5">'function'</span><span class="s4">) {</span>
        <span class="s2">callback </span><span class="s4">= </span><span class="s2">e</span><span class="s4">;</span>
        <span class="s2">e </span><span class="s4">= </span><span class="s2">undefined</span><span class="s4">;</span>
      <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">e </span><span class="s4">!== </span><span class="s5">'number'</span><span class="s4">) {</span>
        <span class="s2">options </span><span class="s4">= </span><span class="s2">e</span><span class="s4">;</span>
        <span class="s2">e </span><span class="s4">= </span><span class="s2">undefined</span><span class="s4">;</span>
      <span class="s4">}</span>
    <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
      <span class="s2">options </span><span class="s4">= </span><span class="s2">bits</span><span class="s4">;</span>
      <span class="s2">callback </span><span class="s4">= </span><span class="s2">e</span><span class="s4">;</span>
      <span class="s2">bits </span><span class="s4">= </span><span class="s2">undefined</span><span class="s4">;</span>
      <span class="s2">e </span><span class="s4">= </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s4">}</span>
  <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">arguments</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">3</span><span class="s4">) {</span>
    <span class="s6">// (bits, e, options), (bits, e, callback), (bits, options, callback)</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">e </span><span class="s4">=== </span><span class="s5">'number'</span><span class="s4">) {</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">options </span><span class="s4">=== </span><span class="s5">'function'</span><span class="s4">) {</span>
        <span class="s2">callback </span><span class="s4">= </span><span class="s2">options</span><span class="s4">;</span>
        <span class="s2">options </span><span class="s4">= </span><span class="s2">undefined</span><span class="s4">;</span>
      <span class="s4">}</span>
    <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
      <span class="s2">callback </span><span class="s4">= </span><span class="s2">options</span><span class="s4">;</span>
      <span class="s2">options </span><span class="s4">= </span><span class="s2">e</span><span class="s4">;</span>
      <span class="s2">e </span><span class="s4">= </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s4">}</span>
  <span class="s4">}</span>
  <span class="s2">options </span><span class="s4">= </span><span class="s2">options </span><span class="s4">|| {};</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">bits </span><span class="s4">=== </span><span class="s2">undefined</span><span class="s4">) {</span>
    <span class="s2">bits </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">bits </span><span class="s4">|| </span><span class="s7">2048</span><span class="s4">;</span>
  <span class="s4">}</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">e </span><span class="s4">=== </span><span class="s2">undefined</span><span class="s4">) {</span>
    <span class="s2">e </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">e </span><span class="s4">|| </span><span class="s7">0x10001</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// use native code if permitted, available, and parameters are acceptable</span>
  <span class="s3">if</span><span class="s4">(!</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">options</span><span class="s4">.</span><span class="s2">usePureJavaScript </span><span class="s4">&amp;&amp; !</span><span class="s2">options</span><span class="s4">.</span><span class="s2">prng </span><span class="s4">&amp;&amp;</span>
    <span class="s2">bits </span><span class="s4">&gt;= </span><span class="s7">256 </span><span class="s4">&amp;&amp; </span><span class="s2">bits </span><span class="s4">&lt;= </span><span class="s7">16384 </span><span class="s4">&amp;&amp; (</span><span class="s2">e </span><span class="s4">=== </span><span class="s7">0x10001 </span><span class="s4">|| </span><span class="s2">e </span><span class="s4">=== </span><span class="s7">3</span><span class="s4">)) {</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">callback</span><span class="s4">) {</span>
      <span class="s6">// try native async</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">_detectNodeCrypto</span><span class="s4">(</span><span class="s5">'generateKeyPair'</span><span class="s4">)) {</span>
        <span class="s3">return </span><span class="s2">_crypto</span><span class="s4">.</span><span class="s2">generateKeyPair</span><span class="s4">(</span><span class="s5">'rsa'</span><span class="s4">, {</span>
          <span class="s2">modulusLength</span><span class="s4">: </span><span class="s2">bits</span><span class="s4">,</span>
          <span class="s2">publicExponent</span><span class="s4">: </span><span class="s2">e</span><span class="s4">,</span>
          <span class="s2">publicKeyEncoding</span><span class="s4">: {</span>
            <span class="s2">type</span><span class="s4">: </span><span class="s5">'spki'</span><span class="s4">,</span>
            <span class="s2">format</span><span class="s4">: </span><span class="s5">'pem'</span>
          <span class="s4">},</span>
          <span class="s2">privateKeyEncoding</span><span class="s4">: {</span>
            <span class="s2">type</span><span class="s4">: </span><span class="s5">'pkcs8'</span><span class="s4">,</span>
            <span class="s2">format</span><span class="s4">: </span><span class="s5">'pem'</span>
          <span class="s4">}</span>
        <span class="s4">}, </span><span class="s3">function</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">pub</span><span class="s4">, </span><span class="s2">priv</span><span class="s4">) {</span>
          <span class="s3">if</span><span class="s4">(</span><span class="s2">err</span><span class="s4">) {</span>
            <span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
          <span class="s4">}</span>
          <span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, {</span>
            <span class="s2">privateKey</span><span class="s4">: </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">privateKeyFromPem</span><span class="s4">(</span><span class="s2">priv</span><span class="s4">),</span>
            <span class="s2">publicKey</span><span class="s4">: </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">publicKeyFromPem</span><span class="s4">(</span><span class="s2">pub</span><span class="s4">)</span>
          <span class="s4">});</span>
        <span class="s4">});</span>
      <span class="s4">}</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">_detectSubtleCrypto</span><span class="s4">(</span><span class="s5">'generateKey'</span><span class="s4">) &amp;&amp;</span>
        <span class="s2">_detectSubtleCrypto</span><span class="s4">(</span><span class="s5">'exportKey'</span><span class="s4">)) {</span>
        <span class="s6">// use standard native generateKey</span>
        <span class="s3">return </span><span class="s2">util</span><span class="s4">.</span><span class="s2">globalScope</span><span class="s4">.</span><span class="s2">crypto</span><span class="s4">.</span><span class="s2">subtle</span><span class="s4">.</span><span class="s2">generateKey</span><span class="s4">({</span>
          <span class="s2">name</span><span class="s4">: </span><span class="s5">'RSASSA-PKCS1-v1_5'</span><span class="s4">,</span>
          <span class="s2">modulusLength</span><span class="s4">: </span><span class="s2">bits</span><span class="s4">,</span>
          <span class="s2">publicExponent</span><span class="s4">: </span><span class="s2">_intToUint8Array</span><span class="s4">(</span><span class="s2">e</span><span class="s4">),</span>
          <span class="s2">hash</span><span class="s4">: {</span><span class="s2">name</span><span class="s4">: </span><span class="s5">'SHA-256'</span><span class="s4">}</span>
        <span class="s4">}, </span><span class="s3">true </span><span class="s6">/* key can be exported*/</span><span class="s4">, [</span><span class="s5">'sign'</span><span class="s4">, </span><span class="s5">'verify'</span><span class="s4">])</span>
        <span class="s4">.</span><span class="s2">then</span><span class="s4">(</span><span class="s3">function</span><span class="s4">(</span><span class="s2">pair</span><span class="s4">) {</span>
          <span class="s3">return </span><span class="s2">util</span><span class="s4">.</span><span class="s2">globalScope</span><span class="s4">.</span><span class="s2">crypto</span><span class="s4">.</span><span class="s2">subtle</span><span class="s4">.</span><span class="s2">exportKey</span><span class="s4">(</span>
            <span class="s5">'pkcs8'</span><span class="s4">, </span><span class="s2">pair</span><span class="s4">.</span><span class="s2">privateKey</span><span class="s4">);</span>
        <span class="s6">// avoiding catch(function(err) {...}) to support IE &lt;= 8</span>
        <span class="s4">}).</span><span class="s2">then</span><span class="s4">(</span><span class="s2">undefined</span><span class="s4">, </span><span class="s3">function</span><span class="s4">(</span><span class="s2">err</span><span class="s4">) {</span>
          <span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
        <span class="s4">}).</span><span class="s2">then</span><span class="s4">(</span><span class="s3">function</span><span class="s4">(</span><span class="s2">pkcs8</span><span class="s4">) {</span>
          <span class="s3">if</span><span class="s4">(</span><span class="s2">pkcs8</span><span class="s4">) {</span>
            <span class="s3">var </span><span class="s2">privateKey </span><span class="s4">= </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">privateKeyFromAsn1</span><span class="s4">(</span>
              <span class="s2">asn1</span><span class="s4">.</span><span class="s2">fromDer</span><span class="s4">(</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">pkcs8</span><span class="s4">)));</span>
            <span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, {</span>
              <span class="s2">privateKey</span><span class="s4">: </span><span class="s2">privateKey</span><span class="s4">,</span>
              <span class="s2">publicKey</span><span class="s4">: </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">setRsaPublicKey</span><span class="s4">(</span><span class="s2">privateKey</span><span class="s4">.</span><span class="s2">n</span><span class="s4">, </span><span class="s2">privateKey</span><span class="s4">.</span><span class="s2">e</span><span class="s4">)</span>
            <span class="s4">});</span>
          <span class="s4">}</span>
        <span class="s4">});</span>
      <span class="s4">}</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">_detectSubtleMsCrypto</span><span class="s4">(</span><span class="s5">'generateKey'</span><span class="s4">) &amp;&amp;</span>
        <span class="s2">_detectSubtleMsCrypto</span><span class="s4">(</span><span class="s5">'exportKey'</span><span class="s4">)) {</span>
        <span class="s3">var </span><span class="s2">genOp </span><span class="s4">= </span><span class="s2">util</span><span class="s4">.</span><span class="s2">globalScope</span><span class="s4">.</span><span class="s2">msCrypto</span><span class="s4">.</span><span class="s2">subtle</span><span class="s4">.</span><span class="s2">generateKey</span><span class="s4">({</span>
          <span class="s2">name</span><span class="s4">: </span><span class="s5">'RSASSA-PKCS1-v1_5'</span><span class="s4">,</span>
          <span class="s2">modulusLength</span><span class="s4">: </span><span class="s2">bits</span><span class="s4">,</span>
          <span class="s2">publicExponent</span><span class="s4">: </span><span class="s2">_intToUint8Array</span><span class="s4">(</span><span class="s2">e</span><span class="s4">),</span>
          <span class="s2">hash</span><span class="s4">: {</span><span class="s2">name</span><span class="s4">: </span><span class="s5">'SHA-256'</span><span class="s4">}</span>
        <span class="s4">}, </span><span class="s3">true </span><span class="s6">/* key can be exported*/</span><span class="s4">, [</span><span class="s5">'sign'</span><span class="s4">, </span><span class="s5">'verify'</span><span class="s4">]);</span>
        <span class="s2">genOp</span><span class="s4">.</span><span class="s2">oncomplete </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">e</span><span class="s4">) {</span>
          <span class="s3">var </span><span class="s2">pair </span><span class="s4">= </span><span class="s2">e</span><span class="s4">.</span><span class="s2">target</span><span class="s4">.</span><span class="s2">result</span><span class="s4">;</span>
          <span class="s3">var </span><span class="s2">exportOp </span><span class="s4">= </span><span class="s2">util</span><span class="s4">.</span><span class="s2">globalScope</span><span class="s4">.</span><span class="s2">msCrypto</span><span class="s4">.</span><span class="s2">subtle</span><span class="s4">.</span><span class="s2">exportKey</span><span class="s4">(</span>
            <span class="s5">'pkcs8'</span><span class="s4">, </span><span class="s2">pair</span><span class="s4">.</span><span class="s2">privateKey</span><span class="s4">);</span>
          <span class="s2">exportOp</span><span class="s4">.</span><span class="s2">oncomplete </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">e</span><span class="s4">) {</span>
            <span class="s3">var </span><span class="s2">pkcs8 </span><span class="s4">= </span><span class="s2">e</span><span class="s4">.</span><span class="s2">target</span><span class="s4">.</span><span class="s2">result</span><span class="s4">;</span>
            <span class="s3">var </span><span class="s2">privateKey </span><span class="s4">= </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">privateKeyFromAsn1</span><span class="s4">(</span>
              <span class="s2">asn1</span><span class="s4">.</span><span class="s2">fromDer</span><span class="s4">(</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">pkcs8</span><span class="s4">)));</span>
            <span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, {</span>
              <span class="s2">privateKey</span><span class="s4">: </span><span class="s2">privateKey</span><span class="s4">,</span>
              <span class="s2">publicKey</span><span class="s4">: </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">setRsaPublicKey</span><span class="s4">(</span><span class="s2">privateKey</span><span class="s4">.</span><span class="s2">n</span><span class="s4">, </span><span class="s2">privateKey</span><span class="s4">.</span><span class="s2">e</span><span class="s4">)</span>
            <span class="s4">});</span>
          <span class="s4">};</span>
          <span class="s2">exportOp</span><span class="s4">.</span><span class="s2">onerror </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">err</span><span class="s4">) {</span>
            <span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
          <span class="s4">};</span>
        <span class="s4">};</span>
        <span class="s2">genOp</span><span class="s4">.</span><span class="s2">onerror </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">err</span><span class="s4">) {</span>
          <span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
        <span class="s4">};</span>
        <span class="s3">return</span><span class="s4">;</span>
      <span class="s4">}</span>
    <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
      <span class="s6">// try native sync</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">_detectNodeCrypto</span><span class="s4">(</span><span class="s5">'generateKeyPairSync'</span><span class="s4">)) {</span>
        <span class="s3">var </span><span class="s2">keypair </span><span class="s4">= </span><span class="s2">_crypto</span><span class="s4">.</span><span class="s2">generateKeyPairSync</span><span class="s4">(</span><span class="s5">'rsa'</span><span class="s4">, {</span>
          <span class="s2">modulusLength</span><span class="s4">: </span><span class="s2">bits</span><span class="s4">,</span>
          <span class="s2">publicExponent</span><span class="s4">: </span><span class="s2">e</span><span class="s4">,</span>
          <span class="s2">publicKeyEncoding</span><span class="s4">: {</span>
            <span class="s2">type</span><span class="s4">: </span><span class="s5">'spki'</span><span class="s4">,</span>
            <span class="s2">format</span><span class="s4">: </span><span class="s5">'pem'</span>
          <span class="s4">},</span>
          <span class="s2">privateKeyEncoding</span><span class="s4">: {</span>
            <span class="s2">type</span><span class="s4">: </span><span class="s5">'pkcs8'</span><span class="s4">,</span>
            <span class="s2">format</span><span class="s4">: </span><span class="s5">'pem'</span>
          <span class="s4">}</span>
        <span class="s4">});</span>
        <span class="s3">return </span><span class="s4">{</span>
          <span class="s2">privateKey</span><span class="s4">: </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">privateKeyFromPem</span><span class="s4">(</span><span class="s2">keypair</span><span class="s4">.</span><span class="s2">privateKey</span><span class="s4">),</span>
          <span class="s2">publicKey</span><span class="s4">: </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">publicKeyFromPem</span><span class="s4">(</span><span class="s2">keypair</span><span class="s4">.</span><span class="s2">publicKey</span><span class="s4">)</span>
        <span class="s4">};</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s6">// use JavaScript implementation</span>
  <span class="s3">var </span><span class="s2">state </span><span class="s4">= </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">createKeyPairGenerationState</span><span class="s4">(</span><span class="s2">bits</span><span class="s4">, </span><span class="s2">e</span><span class="s4">, </span><span class="s2">options</span><span class="s4">);</span>
  <span class="s3">if</span><span class="s4">(!</span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">stepKeyPairGenerationState</span><span class="s4">(</span><span class="s2">state</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>
    <span class="s3">return </span><span class="s2">state</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">;</span>
  <span class="s4">}</span>
  <span class="s2">_generateKeyPair</span><span class="s4">(</span><span class="s2">state</span><span class="s4">, </span><span class="s2">options</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Sets an RSA public key from BigIntegers modulus and exponent.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">n the modulus.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">e the exponent.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the public key.</span>
 <span class="s0">*/</span>
<span class="s2">pki</span><span class="s4">.</span><span class="s2">setRsaPublicKey </span><span class="s4">= </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">setPublicKey </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">n</span><span class="s4">, </span><span class="s2">e</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">key </span><span class="s4">= {</span>
    <span class="s2">n</span><span class="s4">: </span><span class="s2">n</span><span class="s4">,</span>
    <span class="s2">e</span><span class="s4">: </span><span class="s2">e</span>
  <span class="s4">};</span>

  <span class="s0">/**</span>
   <span class="s0">* Encrypts the given data with this public key. Newer applications</span>
   <span class="s0">* should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for</span>
   <span class="s0">* legacy applications.</span>
   <span class="s0">*</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">data the byte string to encrypt.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">scheme the encryption scheme to use:</span>
   <span class="s0">*          'RSAES-PKCS1-V1_5' (default),</span>
   <span class="s0">*          'RSA-OAEP',</span>
   <span class="s0">*          'RAW', 'NONE', or null to perform raw RSA encryption,</span>
   <span class="s0">*          an object with an 'encode' property set to a function</span>
   <span class="s0">*          with the signature 'function(data, key)' that returns</span>
   <span class="s0">*          a binary-encoded string representing the encoded data.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">schemeOptions any scheme-specific options.</span>
   <span class="s0">*</span>
   <span class="s0">* </span><span class="s1">@return </span><span class="s0">the encrypted byte string.</span>
   <span class="s0">*/</span>
  <span class="s2">key</span><span class="s4">.</span><span class="s2">encrypt </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s2">scheme</span><span class="s4">, </span><span class="s2">schemeOptions</span><span class="s4">) {</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">scheme </span><span class="s4">=== </span><span class="s5">'string'</span><span class="s4">) {</span>
      <span class="s2">scheme </span><span class="s4">= </span><span class="s2">scheme</span><span class="s4">.</span><span class="s2">toUpperCase</span><span class="s4">();</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">scheme </span><span class="s4">=== </span><span class="s2">undefined</span><span class="s4">) {</span>
      <span class="s2">scheme </span><span class="s4">= </span><span class="s5">'RSAES-PKCS1-V1_5'</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s3">if</span><span class="s4">(</span><span class="s2">scheme </span><span class="s4">=== </span><span class="s5">'RSAES-PKCS1-V1_5'</span><span class="s4">) {</span>
      <span class="s2">scheme </span><span class="s4">= {</span>
        <span class="s2">encode</span><span class="s4">: </span><span class="s3">function</span><span class="s4">(</span><span class="s2">m</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s2">pub</span><span class="s4">) {</span>
          <span class="s3">return </span><span class="s2">_encodePkcs1_v1_5</span><span class="s4">(</span><span class="s2">m</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s7">0x02</span><span class="s4">).</span><span class="s2">getBytes</span><span class="s4">();</span>
        <span class="s4">}</span>
      <span class="s4">};</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">scheme </span><span class="s4">=== </span><span class="s5">'RSA-OAEP' </span><span class="s4">|| </span><span class="s2">scheme </span><span class="s4">=== </span><span class="s5">'RSAES-OAEP'</span><span class="s4">) {</span>
      <span class="s2">scheme </span><span class="s4">= {</span>
        <span class="s2">encode</span><span class="s4">: </span><span class="s3">function</span><span class="s4">(</span><span class="s2">m</span><span class="s4">, </span><span class="s2">key</span><span class="s4">) {</span>
          <span class="s3">return </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">pkcs1</span><span class="s4">.</span><span class="s2">encode_rsa_oaep</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, </span><span class="s2">m</span><span class="s4">, </span><span class="s2">schemeOptions</span><span class="s4">);</span>
        <span class="s4">}</span>
      <span class="s4">};</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">([</span><span class="s5">'RAW'</span><span class="s4">, </span><span class="s5">'NONE'</span><span class="s4">, </span><span class="s5">'NULL'</span><span class="s4">, </span><span class="s3">null</span><span class="s4">].</span><span class="s2">indexOf</span><span class="s4">(</span><span class="s2">scheme</span><span class="s4">) !== -</span><span class="s7">1</span><span class="s4">) {</span>
      <span class="s2">scheme </span><span class="s4">= {</span><span class="s2">encode</span><span class="s4">: </span><span class="s3">function</span><span class="s4">(</span><span class="s2">e</span><span class="s4">) {</span><span class="s3">return </span><span class="s2">e</span><span class="s4">;}};</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">scheme </span><span class="s4">=== </span><span class="s5">'string'</span><span class="s4">) {</span>
      <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Unsupported encryption scheme: &quot;' </span><span class="s4">+ </span><span class="s2">scheme </span><span class="s4">+ </span><span class="s5">'&quot;.'</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s6">// do scheme-based encoding then rsa encryption</span>
    <span class="s3">var </span><span class="s2">e </span><span class="s4">= </span><span class="s2">scheme</span><span class="s4">.</span><span class="s2">encode</span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s3">true</span><span class="s4">);</span>
    <span class="s3">return </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">encrypt</span><span class="s4">(</span><span class="s2">e</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s3">true</span><span class="s4">);</span>
  <span class="s4">};</span>

  <span class="s0">/**</span>
   <span class="s0">* Verifies the given signature against the given digest.</span>
   <span class="s0">*</span>
   <span class="s0">* PKCS#1 supports multiple (currently two) signature schemes:</span>
   <span class="s0">* RSASSA-PKCS1-V1_5 and RSASSA-PSS.</span>
   <span class="s0">*</span>
   <span class="s0">* By default this implementation uses the &quot;old scheme&quot;, i.e.</span>
   <span class="s0">* RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the</span>
   <span class="s0">* signature is an OCTET STRING that holds a DigestInfo.</span>
   <span class="s0">*</span>
   <span class="s0">* DigestInfo ::= SEQUENCE {</span>
   <span class="s0">*   digestAlgorithm DigestAlgorithmIdentifier,</span>
   <span class="s0">*   digest Digest</span>
   <span class="s0">* }</span>
   <span class="s0">* DigestAlgorithmIdentifier ::= AlgorithmIdentifier</span>
   <span class="s0">* Digest ::= OCTET STRING</span>
   <span class="s0">*</span>
   <span class="s0">* To perform PSS signature verification, provide an instance</span>
   <span class="s0">* of Forge PSS object as the scheme parameter.</span>
   <span class="s0">*</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">digest the message digest hash to compare against the signature,</span>
   <span class="s0">*          as a binary-encoded string.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">signature the signature to verify, as a binary-encoded string.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">scheme signature verification scheme to use:</span>
   <span class="s0">*          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,</span>
   <span class="s0">*          a Forge PSS object for RSASSA-PSS,</span>
   <span class="s0">*          'NONE' or null for none, DigestInfo will not be expected, but</span>
   <span class="s0">*            PKCS#1 v1.5 padding will still be used.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">options optional verify options</span>
   <span class="s0">*          _parseAllDigestBytes testing flag to control parsing of all</span>
   <span class="s0">*            digest bytes. Unsupported and not for general usage.</span>
   <span class="s0">*            (default: true)</span>
   <span class="s0">*</span>
   <span class="s0">* </span><span class="s1">@return </span><span class="s0">true if the signature was verified, false if not.</span>
   <span class="s0">*/</span>
  <span class="s2">key</span><span class="s4">.</span><span class="s2">verify </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">digest</span><span class="s4">, </span><span class="s2">signature</span><span class="s4">, </span><span class="s2">scheme</span><span class="s4">, </span><span class="s2">options</span><span class="s4">) {</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">scheme </span><span class="s4">=== </span><span class="s5">'string'</span><span class="s4">) {</span>
      <span class="s2">scheme </span><span class="s4">= </span><span class="s2">scheme</span><span class="s4">.</span><span class="s2">toUpperCase</span><span class="s4">();</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">scheme </span><span class="s4">=== </span><span class="s2">undefined</span><span class="s4">) {</span>
      <span class="s2">scheme </span><span class="s4">= </span><span class="s5">'RSASSA-PKCS1-V1_5'</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">options </span><span class="s4">=== </span><span class="s2">undefined</span><span class="s4">) {</span>
      <span class="s2">options </span><span class="s4">= {</span>
        <span class="s2">_parseAllDigestBytes</span><span class="s4">: </span><span class="s3">true</span>
      <span class="s4">};</span>
    <span class="s4">}</span>
    <span class="s3">if</span><span class="s4">(!(</span><span class="s5">'_parseAllDigestBytes' </span><span class="s3">in </span><span class="s2">options</span><span class="s4">)) {</span>
      <span class="s2">options</span><span class="s4">.</span><span class="s2">_parseAllDigestBytes </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s3">if</span><span class="s4">(</span><span class="s2">scheme </span><span class="s4">=== </span><span class="s5">'RSASSA-PKCS1-V1_5'</span><span class="s4">) {</span>
      <span class="s2">scheme </span><span class="s4">= {</span>
        <span class="s2">verify</span><span class="s4">: </span><span class="s3">function</span><span class="s4">(</span><span class="s2">digest</span><span class="s4">, </span><span class="s2">d</span><span class="s4">) {</span>
          <span class="s6">// remove padding</span>
          <span class="s2">d </span><span class="s4">= </span><span class="s2">_decodePkcs1_v1_5</span><span class="s4">(</span><span class="s2">d</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s3">true</span><span class="s4">);</span>
          <span class="s6">// d is ASN.1 BER-encoded DigestInfo</span>
          <span class="s3">var </span><span class="s2">obj </span><span class="s4">= </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">fromDer</span><span class="s4">(</span><span class="s2">d</span><span class="s4">, {</span>
            <span class="s2">parseAllBytes</span><span class="s4">: </span><span class="s2">options</span><span class="s4">.</span><span class="s2">_parseAllDigestBytes</span>
          <span class="s4">});</span>

          <span class="s6">// validate DigestInfo</span>
          <span class="s3">var </span><span class="s2">capture </span><span class="s4">= {};</span>
          <span class="s3">var </span><span class="s2">errors </span><span class="s4">= [];</span>
          <span class="s3">if</span><span class="s4">(!</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">validate</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">, </span><span class="s2">digestInfoValidator</span><span class="s4">, </span><span class="s2">capture</span><span class="s4">, </span><span class="s2">errors</span><span class="s4">)) {</span>
            <span class="s3">var </span><span class="s2">error </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Error</span><span class="s4">(</span>
              <span class="s5">'ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 ' </span><span class="s4">+</span>
              <span class="s5">'DigestInfo value.'</span><span class="s4">);</span>
            <span class="s2">error</span><span class="s4">.</span><span class="s2">errors </span><span class="s4">= </span><span class="s2">errors</span><span class="s4">;</span>
            <span class="s3">throw </span><span class="s2">error</span><span class="s4">;</span>
          <span class="s4">}</span>
          <span class="s6">// check hash algorithm identifier</span>
          <span class="s6">// see PKCS1-v1-5DigestAlgorithms in RFC 8017</span>
          <span class="s6">// FIXME: add support to vaidator for strict value choices</span>
          <span class="s3">var </span><span class="s2">oid </span><span class="s4">= </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">derToOid</span><span class="s4">(</span><span class="s2">capture</span><span class="s4">.</span><span class="s2">algorithmIdentifier</span><span class="s4">);</span>
          <span class="s3">if</span><span class="s4">(!(</span><span class="s2">oid </span><span class="s4">=== </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">.</span><span class="s2">md2 </span><span class="s4">||</span>
            <span class="s2">oid </span><span class="s4">=== </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">.</span><span class="s2">md5 </span><span class="s4">||</span>
            <span class="s2">oid </span><span class="s4">=== </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">.</span><span class="s2">sha1 </span><span class="s4">||</span>
            <span class="s2">oid </span><span class="s4">=== </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">.</span><span class="s2">sha224 </span><span class="s4">||</span>
            <span class="s2">oid </span><span class="s4">=== </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">.</span><span class="s2">sha256 </span><span class="s4">||</span>
            <span class="s2">oid </span><span class="s4">=== </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">.</span><span class="s2">sha384 </span><span class="s4">||</span>
            <span class="s2">oid </span><span class="s4">=== </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">.</span><span class="s2">sha512 </span><span class="s4">||</span>
            <span class="s2">oid </span><span class="s4">=== </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">[</span><span class="s5">'sha512-224'</span><span class="s4">] ||</span>
            <span class="s2">oid </span><span class="s4">=== </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">[</span><span class="s5">'sha512-256'</span><span class="s4">])) {</span>
            <span class="s3">var </span><span class="s2">error </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Error</span><span class="s4">(</span>
              <span class="s5">'Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.'</span><span class="s4">);</span>
            <span class="s2">error</span><span class="s4">.</span><span class="s2">oid </span><span class="s4">= </span><span class="s2">oid</span><span class="s4">;</span>
            <span class="s3">throw </span><span class="s2">error</span><span class="s4">;</span>
          <span class="s4">}</span>

          <span class="s6">// special check for md2 and md5 that NULL parameters exist</span>
          <span class="s3">if</span><span class="s4">(</span><span class="s2">oid </span><span class="s4">=== </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">.</span><span class="s2">md2 </span><span class="s4">|| </span><span class="s2">oid </span><span class="s4">=== </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">.</span><span class="s2">md5</span><span class="s4">) {</span>
            <span class="s3">if</span><span class="s4">(!(</span><span class="s5">'parameters' </span><span class="s3">in </span><span class="s2">capture</span><span class="s4">)) {</span>
              <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span>
                <span class="s5">'ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 ' </span><span class="s4">+</span>
                <span class="s5">'DigestInfo value. ' </span><span class="s4">+</span>
                <span class="s5">'Missing algorithm identifer NULL parameters.'</span><span class="s4">);</span>
            <span class="s4">}</span>
          <span class="s4">}</span>

          <span class="s6">// compare the given digest to the decrypted one</span>
          <span class="s3">return </span><span class="s2">digest </span><span class="s4">=== </span><span class="s2">capture</span><span class="s4">.</span><span class="s2">digest</span><span class="s4">;</span>
        <span class="s4">}</span>
      <span class="s4">};</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">scheme </span><span class="s4">=== </span><span class="s5">'NONE' </span><span class="s4">|| </span><span class="s2">scheme </span><span class="s4">=== </span><span class="s5">'NULL' </span><span class="s4">|| </span><span class="s2">scheme </span><span class="s4">=== </span><span class="s3">null</span><span class="s4">) {</span>
      <span class="s2">scheme </span><span class="s4">= {</span>
        <span class="s2">verify</span><span class="s4">: </span><span class="s3">function</span><span class="s4">(</span><span class="s2">digest</span><span class="s4">, </span><span class="s2">d</span><span class="s4">) {</span>
          <span class="s6">// remove padding</span>
          <span class="s2">d </span><span class="s4">= </span><span class="s2">_decodePkcs1_v1_5</span><span class="s4">(</span><span class="s2">d</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s3">true</span><span class="s4">);</span>
          <span class="s3">return </span><span class="s2">digest </span><span class="s4">=== </span><span class="s2">d</span><span class="s4">;</span>
        <span class="s4">}</span>
      <span class="s4">};</span>
    <span class="s4">}</span>

    <span class="s6">// do rsa decryption w/o any decoding, then verify -- which does decoding</span>
    <span class="s3">var </span><span class="s2">d </span><span class="s4">= </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">decrypt</span><span class="s4">(</span><span class="s2">signature</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s3">true</span><span class="s4">, </span><span class="s3">false</span><span class="s4">);</span>
    <span class="s3">return </span><span class="s2">scheme</span><span class="s4">.</span><span class="s2">verify</span><span class="s4">(</span><span class="s2">digest</span><span class="s4">, </span><span class="s2">d</span><span class="s4">, </span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">.</span><span class="s2">bitLength</span><span class="s4">());</span>
  <span class="s4">};</span>

  <span class="s3">return </span><span class="s2">key</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Sets an RSA private key from BigIntegers modulus, exponent, primes,</span>
 <span class="s0">* prime exponents, and modular multiplicative inverse.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">n the modulus.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">e the public exponent.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">d the private exponent ((inverse of e) mod n).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">p the first prime.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">q the second prime.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">dP exponent1 (d mod (p-1)).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">dQ exponent2 (d mod (q-1)).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">qInv ((inverse of q) mod p)</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the private key.</span>
 <span class="s0">*/</span>
<span class="s2">pki</span><span class="s4">.</span><span class="s2">setRsaPrivateKey </span><span class="s4">= </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">setPrivateKey </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span>
  <span class="s2">n</span><span class="s4">, </span><span class="s2">e</span><span class="s4">, </span><span class="s2">d</span><span class="s4">, </span><span class="s2">p</span><span class="s4">, </span><span class="s2">q</span><span class="s4">, </span><span class="s2">dP</span><span class="s4">, </span><span class="s2">dQ</span><span class="s4">, </span><span class="s2">qInv</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">key </span><span class="s4">= {</span>
    <span class="s2">n</span><span class="s4">: </span><span class="s2">n</span><span class="s4">,</span>
    <span class="s2">e</span><span class="s4">: </span><span class="s2">e</span><span class="s4">,</span>
    <span class="s2">d</span><span class="s4">: </span><span class="s2">d</span><span class="s4">,</span>
    <span class="s2">p</span><span class="s4">: </span><span class="s2">p</span><span class="s4">,</span>
    <span class="s2">q</span><span class="s4">: </span><span class="s2">q</span><span class="s4">,</span>
    <span class="s2">dP</span><span class="s4">: </span><span class="s2">dP</span><span class="s4">,</span>
    <span class="s2">dQ</span><span class="s4">: </span><span class="s2">dQ</span><span class="s4">,</span>
    <span class="s2">qInv</span><span class="s4">: </span><span class="s2">qInv</span>
  <span class="s4">};</span>

  <span class="s0">/**</span>
   <span class="s0">* Decrypts the given data with this private key. The decryption scheme</span>
   <span class="s0">* must match the one used to encrypt the data.</span>
   <span class="s0">*</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">data the byte string to decrypt.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">scheme the decryption scheme to use:</span>
   <span class="s0">*          'RSAES-PKCS1-V1_5' (default),</span>
   <span class="s0">*          'RSA-OAEP',</span>
   <span class="s0">*          'RAW', 'NONE', or null to perform raw RSA decryption.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">schemeOptions any scheme-specific options.</span>
   <span class="s0">*</span>
   <span class="s0">* </span><span class="s1">@return </span><span class="s0">the decrypted byte string.</span>
   <span class="s0">*/</span>
  <span class="s2">key</span><span class="s4">.</span><span class="s2">decrypt </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s2">scheme</span><span class="s4">, </span><span class="s2">schemeOptions</span><span class="s4">) {</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">scheme </span><span class="s4">=== </span><span class="s5">'string'</span><span class="s4">) {</span>
      <span class="s2">scheme </span><span class="s4">= </span><span class="s2">scheme</span><span class="s4">.</span><span class="s2">toUpperCase</span><span class="s4">();</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">scheme </span><span class="s4">=== </span><span class="s2">undefined</span><span class="s4">) {</span>
      <span class="s2">scheme </span><span class="s4">= </span><span class="s5">'RSAES-PKCS1-V1_5'</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s6">// do rsa decryption w/o any decoding</span>
    <span class="s3">var </span><span class="s2">d </span><span class="s4">= </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">decrypt</span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s3">false</span><span class="s4">, </span><span class="s3">false</span><span class="s4">);</span>

    <span class="s3">if</span><span class="s4">(</span><span class="s2">scheme </span><span class="s4">=== </span><span class="s5">'RSAES-PKCS1-V1_5'</span><span class="s4">) {</span>
      <span class="s2">scheme </span><span class="s4">= {</span><span class="s2">decode</span><span class="s4">: </span><span class="s2">_decodePkcs1_v1_5</span><span class="s4">};</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">scheme </span><span class="s4">=== </span><span class="s5">'RSA-OAEP' </span><span class="s4">|| </span><span class="s2">scheme </span><span class="s4">=== </span><span class="s5">'RSAES-OAEP'</span><span class="s4">) {</span>
      <span class="s2">scheme </span><span class="s4">= {</span>
        <span class="s2">decode</span><span class="s4">: </span><span class="s3">function</span><span class="s4">(</span><span class="s2">d</span><span class="s4">, </span><span class="s2">key</span><span class="s4">) {</span>
          <span class="s3">return </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">pkcs1</span><span class="s4">.</span><span class="s2">decode_rsa_oaep</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, </span><span class="s2">d</span><span class="s4">, </span><span class="s2">schemeOptions</span><span class="s4">);</span>
        <span class="s4">}</span>
      <span class="s4">};</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">([</span><span class="s5">'RAW'</span><span class="s4">, </span><span class="s5">'NONE'</span><span class="s4">, </span><span class="s5">'NULL'</span><span class="s4">, </span><span class="s3">null</span><span class="s4">].</span><span class="s2">indexOf</span><span class="s4">(</span><span class="s2">scheme</span><span class="s4">) !== -</span><span class="s7">1</span><span class="s4">) {</span>
      <span class="s2">scheme </span><span class="s4">= {</span><span class="s2">decode</span><span class="s4">: </span><span class="s3">function</span><span class="s4">(</span><span class="s2">d</span><span class="s4">) {</span><span class="s3">return </span><span class="s2">d</span><span class="s4">;}};</span>
    <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
      <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Unsupported encryption scheme: &quot;' </span><span class="s4">+ </span><span class="s2">scheme </span><span class="s4">+ </span><span class="s5">'&quot;.'</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s6">// decode according to scheme</span>
    <span class="s3">return </span><span class="s2">scheme</span><span class="s4">.</span><span class="s2">decode</span><span class="s4">(</span><span class="s2">d</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s3">false</span><span class="s4">);</span>
  <span class="s4">};</span>

  <span class="s0">/**</span>
   <span class="s0">* Signs the given digest, producing a signature.</span>
   <span class="s0">*</span>
   <span class="s0">* PKCS#1 supports multiple (currently two) signature schemes:</span>
   <span class="s0">* RSASSA-PKCS1-V1_5 and RSASSA-PSS.</span>
   <span class="s0">*</span>
   <span class="s0">* By default this implementation uses the &quot;old scheme&quot;, i.e.</span>
   <span class="s0">* RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide</span>
   <span class="s0">* an instance of Forge PSS object as the scheme parameter.</span>
   <span class="s0">*</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">md the message digest object with the hash to sign.</span>
   <span class="s0">* </span><span class="s1">@param </span><span class="s0">scheme the signature scheme to use:</span>
   <span class="s0">*          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,</span>
   <span class="s0">*          a Forge PSS object for RSASSA-PSS,</span>
   <span class="s0">*          'NONE' or null for none, DigestInfo will not be used but</span>
   <span class="s0">*            PKCS#1 v1.5 padding will still be used.</span>
   <span class="s0">*</span>
   <span class="s0">* </span><span class="s1">@return </span><span class="s0">the signature as a byte string.</span>
   <span class="s0">*/</span>
  <span class="s2">key</span><span class="s4">.</span><span class="s2">sign </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">md</span><span class="s4">, </span><span class="s2">scheme</span><span class="s4">) {</span>
    <span class="s6">/* Note: The internal implementation of RSA operations is being 
      transitioned away from a PKCS#1 v1.5 hard-coded scheme. Some legacy 
      code like the use of an encoding block identifier 'bt' will eventually 
      be removed. */</span>

    <span class="s6">// private key operation</span>
    <span class="s3">var </span><span class="s2">bt </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>

    <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">scheme </span><span class="s4">=== </span><span class="s5">'string'</span><span class="s4">) {</span>
      <span class="s2">scheme </span><span class="s4">= </span><span class="s2">scheme</span><span class="s4">.</span><span class="s2">toUpperCase</span><span class="s4">();</span>
    <span class="s4">}</span>

    <span class="s3">if</span><span class="s4">(</span><span class="s2">scheme </span><span class="s4">=== </span><span class="s2">undefined </span><span class="s4">|| </span><span class="s2">scheme </span><span class="s4">=== </span><span class="s5">'RSASSA-PKCS1-V1_5'</span><span class="s4">) {</span>
      <span class="s2">scheme </span><span class="s4">= {</span><span class="s2">encode</span><span class="s4">: </span><span class="s2">emsaPkcs1v15encode</span><span class="s4">};</span>
      <span class="s2">bt </span><span class="s4">= </span><span class="s7">0x01</span><span class="s4">;</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">scheme </span><span class="s4">=== </span><span class="s5">'NONE' </span><span class="s4">|| </span><span class="s2">scheme </span><span class="s4">=== </span><span class="s5">'NULL' </span><span class="s4">|| </span><span class="s2">scheme </span><span class="s4">=== </span><span class="s3">null</span><span class="s4">) {</span>
      <span class="s2">scheme </span><span class="s4">= {</span><span class="s2">encode</span><span class="s4">: </span><span class="s3">function</span><span class="s4">() {</span><span class="s3">return </span><span class="s2">md</span><span class="s4">;}};</span>
      <span class="s2">bt </span><span class="s4">= </span><span class="s7">0x01</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s6">// encode and then encrypt</span>
    <span class="s3">var </span><span class="s2">d </span><span class="s4">= </span><span class="s2">scheme</span><span class="s4">.</span><span class="s2">encode</span><span class="s4">(</span><span class="s2">md</span><span class="s4">, </span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">.</span><span class="s2">bitLength</span><span class="s4">());</span>
    <span class="s3">return </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">encrypt</span><span class="s4">(</span><span class="s2">d</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s2">bt</span><span class="s4">);</span>
  <span class="s4">};</span>

  <span class="s3">return </span><span class="s2">key</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Wraps an RSAPrivateKey ASN.1 object in an ASN.1 PrivateKeyInfo object.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">rsaKey the ASN.1 RSAPrivateKey.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the ASN.1 PrivateKeyInfo.</span>
 <span class="s0">*/</span>
<span class="s2">pki</span><span class="s4">.</span><span class="s2">wrapRsaPrivateKey </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">rsaKey</span><span class="s4">) {</span>
  <span class="s6">// PrivateKeyInfo</span>
  <span class="s3">return </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">, </span><span class="s3">true</span><span class="s4">, [</span>
    <span class="s6">// version (0)</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">, </span><span class="s3">false</span><span class="s4">,</span>
      <span class="s2">asn1</span><span class="s4">.</span><span class="s2">integerToDer</span><span class="s4">(</span><span class="s7">0</span><span class="s4">).</span><span class="s2">getBytes</span><span class="s4">()),</span>
    <span class="s6">// privateKeyAlgorithm</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">, </span><span class="s3">true</span><span class="s4">, [</span>
      <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span>
        <span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">OID</span><span class="s4">, </span><span class="s3">false</span><span class="s4">,</span>
        <span class="s2">asn1</span><span class="s4">.</span><span class="s2">oidToDer</span><span class="s4">(</span><span class="s2">pki</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">.</span><span class="s2">rsaEncryption</span><span class="s4">).</span><span class="s2">getBytes</span><span class="s4">()),</span>
      <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">NULL</span><span class="s4">, </span><span class="s3">false</span><span class="s4">, </span><span class="s5">''</span><span class="s4">)</span>
    <span class="s4">]),</span>
    <span class="s6">// PrivateKey</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">OCTETSTRING</span><span class="s4">, </span><span class="s3">false</span><span class="s4">,</span>
      <span class="s2">asn1</span><span class="s4">.</span><span class="s2">toDer</span><span class="s4">(</span><span class="s2">rsaKey</span><span class="s4">).</span><span class="s2">getBytes</span><span class="s4">())</span>
  <span class="s4">]);</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a private key from an ASN.1 object.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">obj the ASN.1 representation of a PrivateKeyInfo containing an</span>
 <span class="s0">*          RSAPrivateKey or an RSAPrivateKey.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the private key.</span>
 <span class="s0">*/</span>
<span class="s2">pki</span><span class="s4">.</span><span class="s2">privateKeyFromAsn1 </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">) {</span>
  <span class="s6">// get PrivateKeyInfo</span>
  <span class="s3">var </span><span class="s2">capture </span><span class="s4">= {};</span>
  <span class="s3">var </span><span class="s2">errors </span><span class="s4">= [];</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">validate</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">, </span><span class="s2">privateKeyValidator</span><span class="s4">, </span><span class="s2">capture</span><span class="s4">, </span><span class="s2">errors</span><span class="s4">)) {</span>
    <span class="s2">obj </span><span class="s4">= </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">fromDer</span><span class="s4">(</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">capture</span><span class="s4">.</span><span class="s2">privateKey</span><span class="s4">));</span>
  <span class="s4">}</span>

  <span class="s6">// get RSAPrivateKey</span>
  <span class="s2">capture </span><span class="s4">= {};</span>
  <span class="s2">errors </span><span class="s4">= [];</span>
  <span class="s3">if</span><span class="s4">(!</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">validate</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">, </span><span class="s2">rsaPrivateKeyValidator</span><span class="s4">, </span><span class="s2">capture</span><span class="s4">, </span><span class="s2">errors</span><span class="s4">)) {</span>
    <span class="s3">var </span><span class="s2">error </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Cannot read private key. ' </span><span class="s4">+</span>
      <span class="s5">'ASN.1 object does not contain an RSAPrivateKey.'</span><span class="s4">);</span>
    <span class="s2">error</span><span class="s4">.</span><span class="s2">errors </span><span class="s4">= </span><span class="s2">errors</span><span class="s4">;</span>
    <span class="s3">throw </span><span class="s2">error</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// Note: Version is currently ignored.</span>
  <span class="s6">// capture.privateKeyVersion</span>
  <span class="s6">// FIXME: inefficient, get a BigInteger that uses byte strings</span>
  <span class="s3">var </span><span class="s2">n</span><span class="s4">, </span><span class="s2">e</span><span class="s4">, </span><span class="s2">d</span><span class="s4">, </span><span class="s2">p</span><span class="s4">, </span><span class="s2">q</span><span class="s4">, </span><span class="s2">dP</span><span class="s4">, </span><span class="s2">dQ</span><span class="s4">, </span><span class="s2">qInv</span><span class="s4">;</span>
  <span class="s2">n </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">capture</span><span class="s4">.</span><span class="s2">privateKeyModulus</span><span class="s4">).</span><span class="s2">toHex</span><span class="s4">();</span>
  <span class="s2">e </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">capture</span><span class="s4">.</span><span class="s2">privateKeyPublicExponent</span><span class="s4">).</span><span class="s2">toHex</span><span class="s4">();</span>
  <span class="s2">d </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">capture</span><span class="s4">.</span><span class="s2">privateKeyPrivateExponent</span><span class="s4">).</span><span class="s2">toHex</span><span class="s4">();</span>
  <span class="s2">p </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">capture</span><span class="s4">.</span><span class="s2">privateKeyPrime1</span><span class="s4">).</span><span class="s2">toHex</span><span class="s4">();</span>
  <span class="s2">q </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">capture</span><span class="s4">.</span><span class="s2">privateKeyPrime2</span><span class="s4">).</span><span class="s2">toHex</span><span class="s4">();</span>
  <span class="s2">dP </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">capture</span><span class="s4">.</span><span class="s2">privateKeyExponent1</span><span class="s4">).</span><span class="s2">toHex</span><span class="s4">();</span>
  <span class="s2">dQ </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">capture</span><span class="s4">.</span><span class="s2">privateKeyExponent2</span><span class="s4">).</span><span class="s2">toHex</span><span class="s4">();</span>
  <span class="s2">qInv </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">capture</span><span class="s4">.</span><span class="s2">privateKeyCoefficient</span><span class="s4">).</span><span class="s2">toHex</span><span class="s4">();</span>

  <span class="s6">// set private key</span>
  <span class="s3">return </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">setRsaPrivateKey</span><span class="s4">(</span>
    <span class="s3">new </span><span class="s2">BigInteger</span><span class="s4">(</span><span class="s2">n</span><span class="s4">, </span><span class="s7">16</span><span class="s4">),</span>
    <span class="s3">new </span><span class="s2">BigInteger</span><span class="s4">(</span><span class="s2">e</span><span class="s4">, </span><span class="s7">16</span><span class="s4">),</span>
    <span class="s3">new </span><span class="s2">BigInteger</span><span class="s4">(</span><span class="s2">d</span><span class="s4">, </span><span class="s7">16</span><span class="s4">),</span>
    <span class="s3">new </span><span class="s2">BigInteger</span><span class="s4">(</span><span class="s2">p</span><span class="s4">, </span><span class="s7">16</span><span class="s4">),</span>
    <span class="s3">new </span><span class="s2">BigInteger</span><span class="s4">(</span><span class="s2">q</span><span class="s4">, </span><span class="s7">16</span><span class="s4">),</span>
    <span class="s3">new </span><span class="s2">BigInteger</span><span class="s4">(</span><span class="s2">dP</span><span class="s4">, </span><span class="s7">16</span><span class="s4">),</span>
    <span class="s3">new </span><span class="s2">BigInteger</span><span class="s4">(</span><span class="s2">dQ</span><span class="s4">, </span><span class="s7">16</span><span class="s4">),</span>
    <span class="s3">new </span><span class="s2">BigInteger</span><span class="s4">(</span><span class="s2">qInv</span><span class="s4">, </span><span class="s7">16</span><span class="s4">));</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a private key to an ASN.1 RSAPrivateKey.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">key the private key.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the ASN.1 representation of an RSAPrivateKey.</span>
 <span class="s0">*/</span>
<span class="s2">pki</span><span class="s4">.</span><span class="s2">privateKeyToAsn1 </span><span class="s4">= </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">privateKeyToRSAPrivateKey </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">key</span><span class="s4">) {</span>
  <span class="s6">// RSAPrivateKey</span>
  <span class="s3">return </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">, </span><span class="s3">true</span><span class="s4">, [</span>
    <span class="s6">// version (0 = only 2 primes, 1 multiple primes)</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">, </span><span class="s3">false</span><span class="s4">,</span>
      <span class="s2">asn1</span><span class="s4">.</span><span class="s2">integerToDer</span><span class="s4">(</span><span class="s7">0</span><span class="s4">).</span><span class="s2">getBytes</span><span class="s4">()),</span>
    <span class="s6">// modulus (n)</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">, </span><span class="s3">false</span><span class="s4">,</span>
      <span class="s2">_bnToBytes</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">)),</span>
    <span class="s6">// publicExponent (e)</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">, </span><span class="s3">false</span><span class="s4">,</span>
      <span class="s2">_bnToBytes</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">e</span><span class="s4">)),</span>
    <span class="s6">// privateExponent (d)</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">, </span><span class="s3">false</span><span class="s4">,</span>
      <span class="s2">_bnToBytes</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">d</span><span class="s4">)),</span>
    <span class="s6">// privateKeyPrime1 (p)</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">, </span><span class="s3">false</span><span class="s4">,</span>
      <span class="s2">_bnToBytes</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">p</span><span class="s4">)),</span>
    <span class="s6">// privateKeyPrime2 (q)</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">, </span><span class="s3">false</span><span class="s4">,</span>
      <span class="s2">_bnToBytes</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">q</span><span class="s4">)),</span>
    <span class="s6">// privateKeyExponent1 (dP)</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">, </span><span class="s3">false</span><span class="s4">,</span>
      <span class="s2">_bnToBytes</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">dP</span><span class="s4">)),</span>
    <span class="s6">// privateKeyExponent2 (dQ)</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">, </span><span class="s3">false</span><span class="s4">,</span>
      <span class="s2">_bnToBytes</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">dQ</span><span class="s4">)),</span>
    <span class="s6">// coefficient (qInv)</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">, </span><span class="s3">false</span><span class="s4">,</span>
      <span class="s2">_bnToBytes</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">qInv</span><span class="s4">))</span>
  <span class="s4">]);</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a public key from an ASN.1 SubjectPublicKeyInfo or RSAPublicKey.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">obj the asn1 representation of a SubjectPublicKeyInfo or RSAPublicKey.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the public key.</span>
 <span class="s0">*/</span>
<span class="s2">pki</span><span class="s4">.</span><span class="s2">publicKeyFromAsn1 </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">) {</span>
  <span class="s6">// get SubjectPublicKeyInfo</span>
  <span class="s3">var </span><span class="s2">capture </span><span class="s4">= {};</span>
  <span class="s3">var </span><span class="s2">errors </span><span class="s4">= [];</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">validate</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">, </span><span class="s2">publicKeyValidator</span><span class="s4">, </span><span class="s2">capture</span><span class="s4">, </span><span class="s2">errors</span><span class="s4">)) {</span>
    <span class="s6">// get oid</span>
    <span class="s3">var </span><span class="s2">oid </span><span class="s4">= </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">derToOid</span><span class="s4">(</span><span class="s2">capture</span><span class="s4">.</span><span class="s2">publicKeyOid</span><span class="s4">);</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">oid </span><span class="s4">!== </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">.</span><span class="s2">rsaEncryption</span><span class="s4">) {</span>
      <span class="s3">var </span><span class="s2">error </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Cannot read public key. Unknown OID.'</span><span class="s4">);</span>
      <span class="s2">error</span><span class="s4">.</span><span class="s2">oid </span><span class="s4">= </span><span class="s2">oid</span><span class="s4">;</span>
      <span class="s3">throw </span><span class="s2">error</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s2">obj </span><span class="s4">= </span><span class="s2">capture</span><span class="s4">.</span><span class="s2">rsaPublicKey</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// get RSA params</span>
  <span class="s2">errors </span><span class="s4">= [];</span>
  <span class="s3">if</span><span class="s4">(!</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">validate</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">, </span><span class="s2">rsaPublicKeyValidator</span><span class="s4">, </span><span class="s2">capture</span><span class="s4">, </span><span class="s2">errors</span><span class="s4">)) {</span>
    <span class="s3">var </span><span class="s2">error </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Cannot read public key. ' </span><span class="s4">+</span>
      <span class="s5">'ASN.1 object does not contain an RSAPublicKey.'</span><span class="s4">);</span>
    <span class="s2">error</span><span class="s4">.</span><span class="s2">errors </span><span class="s4">= </span><span class="s2">errors</span><span class="s4">;</span>
    <span class="s3">throw </span><span class="s2">error</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// FIXME: inefficient, get a BigInteger that uses byte strings</span>
  <span class="s3">var </span><span class="s2">n </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">capture</span><span class="s4">.</span><span class="s2">publicKeyModulus</span><span class="s4">).</span><span class="s2">toHex</span><span class="s4">();</span>
  <span class="s3">var </span><span class="s2">e </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">capture</span><span class="s4">.</span><span class="s2">publicKeyExponent</span><span class="s4">).</span><span class="s2">toHex</span><span class="s4">();</span>

  <span class="s6">// set public key</span>
  <span class="s3">return </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">setRsaPublicKey</span><span class="s4">(</span>
    <span class="s3">new </span><span class="s2">BigInteger</span><span class="s4">(</span><span class="s2">n</span><span class="s4">, </span><span class="s7">16</span><span class="s4">),</span>
    <span class="s3">new </span><span class="s2">BigInteger</span><span class="s4">(</span><span class="s2">e</span><span class="s4">, </span><span class="s7">16</span><span class="s4">));</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a public key to an ASN.1 SubjectPublicKeyInfo.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">key the public key.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the asn1 representation of a SubjectPublicKeyInfo.</span>
 <span class="s0">*/</span>
<span class="s2">pki</span><span class="s4">.</span><span class="s2">publicKeyToAsn1 </span><span class="s4">= </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">publicKeyToSubjectPublicKeyInfo </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">key</span><span class="s4">) {</span>
  <span class="s6">// SubjectPublicKeyInfo</span>
  <span class="s3">return </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">, </span><span class="s3">true</span><span class="s4">, [</span>
    <span class="s6">// AlgorithmIdentifier</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">, </span><span class="s3">true</span><span class="s4">, [</span>
      <span class="s6">// algorithm</span>
      <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">OID</span><span class="s4">, </span><span class="s3">false</span><span class="s4">,</span>
        <span class="s2">asn1</span><span class="s4">.</span><span class="s2">oidToDer</span><span class="s4">(</span><span class="s2">pki</span><span class="s4">.</span><span class="s2">oids</span><span class="s4">.</span><span class="s2">rsaEncryption</span><span class="s4">).</span><span class="s2">getBytes</span><span class="s4">()),</span>
      <span class="s6">// parameters (null)</span>
      <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">NULL</span><span class="s4">, </span><span class="s3">false</span><span class="s4">, </span><span class="s5">''</span><span class="s4">)</span>
    <span class="s4">]),</span>
    <span class="s6">// subjectPublicKey</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">BITSTRING</span><span class="s4">, </span><span class="s3">false</span><span class="s4">, [</span>
      <span class="s2">pki</span><span class="s4">.</span><span class="s2">publicKeyToRSAPublicKey</span><span class="s4">(</span><span class="s2">key</span><span class="s4">)</span>
    <span class="s4">])</span>
  <span class="s4">]);</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a public key to an ASN.1 RSAPublicKey.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">key the public key.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the asn1 representation of a RSAPublicKey.</span>
 <span class="s0">*/</span>
<span class="s2">pki</span><span class="s4">.</span><span class="s2">publicKeyToRSAPublicKey </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">key</span><span class="s4">) {</span>
  <span class="s6">// RSAPublicKey</span>
  <span class="s3">return </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">SEQUENCE</span><span class="s4">, </span><span class="s3">true</span><span class="s4">, [</span>
    <span class="s6">// modulus (n)</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">, </span><span class="s3">false</span><span class="s4">,</span>
      <span class="s2">_bnToBytes</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">)),</span>
    <span class="s6">// publicExponent (e)</span>
    <span class="s2">asn1</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Class</span><span class="s4">.</span><span class="s2">UNIVERSAL</span><span class="s4">, </span><span class="s2">asn1</span><span class="s4">.</span><span class="s2">Type</span><span class="s4">.</span><span class="s2">INTEGER</span><span class="s4">, </span><span class="s3">false</span><span class="s4">,</span>
      <span class="s2">_bnToBytes</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">e</span><span class="s4">))</span>
  <span class="s4">]);</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Encodes a message using PKCS#1 v1.5 padding.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">m the message to encode.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">key the RSA key to use.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">bt the block type to use, i.e. either 0x01 (for signing) or 0x02</span>
 <span class="s0">*          (for encryption).</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the padded byte buffer.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">_encodePkcs1_v1_5</span><span class="s4">(</span><span class="s2">m</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s2">bt</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">eb </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">();</span>

  <span class="s6">// get the length of the modulus in bytes</span>
  <span class="s3">var </span><span class="s2">k </span><span class="s4">= </span><span class="s2">Math</span><span class="s4">.</span><span class="s2">ceil</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">.</span><span class="s2">bitLength</span><span class="s4">() / </span><span class="s7">8</span><span class="s4">);</span>

  <span class="s6">/* use PKCS#1 v1.5 padding */</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">m</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; (</span><span class="s2">k </span><span class="s4">- </span><span class="s7">11</span><span class="s4">)) {</span>
    <span class="s3">var </span><span class="s2">error </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Message is too long for PKCS#1 v1.5 padding.'</span><span class="s4">);</span>
    <span class="s2">error</span><span class="s4">.</span><span class="s2">length </span><span class="s4">= </span><span class="s2">m</span><span class="s4">.</span><span class="s2">length</span><span class="s4">;</span>
    <span class="s2">error</span><span class="s4">.</span><span class="s2">max </span><span class="s4">= </span><span class="s2">k </span><span class="s4">- </span><span class="s7">11</span><span class="s4">;</span>
    <span class="s3">throw </span><span class="s2">error</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">/* A block type BT, a padding string PS, and the data D shall be 
    formatted into an octet string EB, the encryption block: 
 
    EB = 00 || BT || PS || 00 || D 
 
    The block type BT shall be a single octet indicating the structure of 
    the encryption block. For this version of the document it shall have 
    value 00, 01, or 02. For a private-key operation, the block type 
    shall be 00 or 01. For a public-key operation, it shall be 02. 
 
    The padding string PS shall consist of k-3-||D|| octets. For block 
    type 00, the octets shall have value 00; for block type 01, they 
    shall have value FF; and for block type 02, they shall be 
    pseudorandomly generated and nonzero. This makes the length of the 
    encryption block EB equal to k. */</span>

  <span class="s6">// build the encryption block</span>
  <span class="s2">eb</span><span class="s4">.</span><span class="s2">putByte</span><span class="s4">(</span><span class="s7">0x00</span><span class="s4">);</span>
  <span class="s2">eb</span><span class="s4">.</span><span class="s2">putByte</span><span class="s4">(</span><span class="s2">bt</span><span class="s4">);</span>

  <span class="s6">// create the padding</span>
  <span class="s3">var </span><span class="s2">padNum </span><span class="s4">= </span><span class="s2">k </span><span class="s4">- </span><span class="s7">3 </span><span class="s4">- </span><span class="s2">m</span><span class="s4">.</span><span class="s2">length</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">padByte</span><span class="s4">;</span>
  <span class="s6">// private key op</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">bt </span><span class="s4">=== </span><span class="s7">0x00 </span><span class="s4">|| </span><span class="s2">bt </span><span class="s4">=== </span><span class="s7">0x01</span><span class="s4">) {</span>
    <span class="s2">padByte </span><span class="s4">= (</span><span class="s2">bt </span><span class="s4">=== </span><span class="s7">0x00</span><span class="s4">) ? </span><span class="s7">0x00 </span><span class="s4">: </span><span class="s7">0xFF</span><span class="s4">;</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">padNum</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s2">eb</span><span class="s4">.</span><span class="s2">putByte</span><span class="s4">(</span><span class="s2">padByte</span><span class="s4">);</span>
    <span class="s4">}</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s6">// public key op</span>
    <span class="s6">// pad with random non-zero values</span>
    <span class="s3">while</span><span class="s4">(</span><span class="s2">padNum </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
      <span class="s3">var </span><span class="s2">numZeros </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
      <span class="s3">var </span><span class="s2">padBytes </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">random</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span><span class="s2">padNum</span><span class="s4">);</span>
      <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">padNum</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
        <span class="s2">padByte </span><span class="s4">= </span><span class="s2">padBytes</span><span class="s4">.</span><span class="s2">charCodeAt</span><span class="s4">(</span><span class="s2">i</span><span class="s4">);</span>
        <span class="s3">if</span><span class="s4">(</span><span class="s2">padByte </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
          <span class="s4">++</span><span class="s2">numZeros</span><span class="s4">;</span>
        <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
          <span class="s2">eb</span><span class="s4">.</span><span class="s2">putByte</span><span class="s4">(</span><span class="s2">padByte</span><span class="s4">);</span>
        <span class="s4">}</span>
      <span class="s4">}</span>
      <span class="s2">padNum </span><span class="s4">= </span><span class="s2">numZeros</span><span class="s4">;</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s6">// zero followed by message</span>
  <span class="s2">eb</span><span class="s4">.</span><span class="s2">putByte</span><span class="s4">(</span><span class="s7">0x00</span><span class="s4">);</span>
  <span class="s2">eb</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s2">m</span><span class="s4">);</span>

  <span class="s3">return </span><span class="s2">eb</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Decodes a message using PKCS#1 v1.5 padding.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">em the message to decode.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">key the RSA key to use.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">pub true if the key is a public key, false if it is private.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">ml the message length, if specified.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the decoded bytes.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">_decodePkcs1_v1_5</span><span class="s4">(</span><span class="s2">em</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s2">pub</span><span class="s4">, </span><span class="s2">ml</span><span class="s4">) {</span>
  <span class="s6">// get the length of the modulus in bytes</span>
  <span class="s3">var </span><span class="s2">k </span><span class="s4">= </span><span class="s2">Math</span><span class="s4">.</span><span class="s2">ceil</span><span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">n</span><span class="s4">.</span><span class="s2">bitLength</span><span class="s4">() / </span><span class="s7">8</span><span class="s4">);</span>

  <span class="s6">/* It is an error if any of the following conditions occurs: 
 
    1. The encryption block EB cannot be parsed unambiguously. 
    2. The padding string PS consists of fewer than eight octets 
      or is inconsisent with the block type BT. 
    3. The decryption process is a public-key operation and the block 
      type BT is not 00 or 01, or the decryption process is a 
      private-key operation and the block type is not 02. 
   */</span>

  <span class="s6">// parse the encryption block</span>
  <span class="s3">var </span><span class="s2">eb </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">em</span><span class="s4">);</span>
  <span class="s3">var </span><span class="s2">first </span><span class="s4">= </span><span class="s2">eb</span><span class="s4">.</span><span class="s2">getByte</span><span class="s4">();</span>
  <span class="s3">var </span><span class="s2">bt </span><span class="s4">= </span><span class="s2">eb</span><span class="s4">.</span><span class="s2">getByte</span><span class="s4">();</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">first </span><span class="s4">!== </span><span class="s7">0x00 </span><span class="s4">||</span>
    <span class="s4">(</span><span class="s2">pub </span><span class="s4">&amp;&amp; </span><span class="s2">bt </span><span class="s4">!== </span><span class="s7">0x00 </span><span class="s4">&amp;&amp; </span><span class="s2">bt </span><span class="s4">!== </span><span class="s7">0x01</span><span class="s4">) ||</span>
    <span class="s4">(!</span><span class="s2">pub </span><span class="s4">&amp;&amp; </span><span class="s2">bt </span><span class="s4">!= </span><span class="s7">0x02</span><span class="s4">) ||</span>
    <span class="s4">(</span><span class="s2">pub </span><span class="s4">&amp;&amp; </span><span class="s2">bt </span><span class="s4">=== </span><span class="s7">0x00 </span><span class="s4">&amp;&amp; </span><span class="s3">typeof</span><span class="s4">(</span><span class="s2">ml</span><span class="s4">) === </span><span class="s5">'undefined'</span><span class="s4">)) {</span>
    <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Encryption block is invalid.'</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s3">var </span><span class="s2">padNum </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">bt </span><span class="s4">=== </span><span class="s7">0x00</span><span class="s4">) {</span>
    <span class="s6">// check all padding bytes for 0x00</span>
    <span class="s2">padNum </span><span class="s4">= </span><span class="s2">k </span><span class="s4">- </span><span class="s7">3 </span><span class="s4">- </span><span class="s2">ml</span><span class="s4">;</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">padNum</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">eb</span><span class="s4">.</span><span class="s2">getByte</span><span class="s4">() !== </span><span class="s7">0x00</span><span class="s4">) {</span>
        <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Encryption block is invalid.'</span><span class="s4">);</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
  <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">bt </span><span class="s4">=== </span><span class="s7">0x01</span><span class="s4">) {</span>
    <span class="s6">// find the first byte that isn't 0xFF, should be after all padding</span>
    <span class="s2">padNum </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
    <span class="s3">while</span><span class="s4">(</span><span class="s2">eb</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() &gt; </span><span class="s7">1</span><span class="s4">) {</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">eb</span><span class="s4">.</span><span class="s2">getByte</span><span class="s4">() !== </span><span class="s7">0xFF</span><span class="s4">) {</span>
        <span class="s4">--</span><span class="s2">eb</span><span class="s4">.</span><span class="s2">read</span><span class="s4">;</span>
        <span class="s3">break</span><span class="s4">;</span>
      <span class="s4">}</span>
      <span class="s4">++</span><span class="s2">padNum</span><span class="s4">;</span>
    <span class="s4">}</span>
  <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">bt </span><span class="s4">=== </span><span class="s7">0x02</span><span class="s4">) {</span>
    <span class="s6">// look for 0x00 byte</span>
    <span class="s2">padNum </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
    <span class="s3">while</span><span class="s4">(</span><span class="s2">eb</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() &gt; </span><span class="s7">1</span><span class="s4">) {</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">eb</span><span class="s4">.</span><span class="s2">getByte</span><span class="s4">() === </span><span class="s7">0x00</span><span class="s4">) {</span>
        <span class="s4">--</span><span class="s2">eb</span><span class="s4">.</span><span class="s2">read</span><span class="s4">;</span>
        <span class="s3">break</span><span class="s4">;</span>
      <span class="s4">}</span>
      <span class="s4">++</span><span class="s2">padNum</span><span class="s4">;</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s6">// zero must be 0x00 and padNum must be (k - 3 - message length)</span>
  <span class="s3">var </span><span class="s2">zero </span><span class="s4">= </span><span class="s2">eb</span><span class="s4">.</span><span class="s2">getByte</span><span class="s4">();</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">zero </span><span class="s4">!== </span><span class="s7">0x00 </span><span class="s4">|| </span><span class="s2">padNum </span><span class="s4">!== (</span><span class="s2">k </span><span class="s4">- </span><span class="s7">3 </span><span class="s4">- </span><span class="s2">eb</span><span class="s4">.</span><span class="s2">length</span><span class="s4">())) {</span>
    <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Encryption block is invalid.'</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s3">return </span><span class="s2">eb</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">();</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Runs the key-generation algorithm asynchronously, either in the background</span>
 <span class="s0">* via Web Workers, or using the main thread and setImmediate.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">state the key-pair generation state.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">[options] options for key-pair generation:</span>
 <span class="s0">*          workerScript the worker script URL.</span>
 <span class="s0">*          workers the number of web workers (if supported) to use,</span>
 <span class="s0">*            (default: 2, -1 to use estimated cores minus one).</span>
 <span class="s0">*          workLoad the size of the work load, ie: number of possible prime</span>
 <span class="s0">*            numbers for each web worker to check per work assignment,</span>
 <span class="s0">*            (default: 100).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">callback(err, keypair) called once the operation completes.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">_generateKeyPair</span><span class="s4">(</span><span class="s2">state</span><span class="s4">, </span><span class="s2">options</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">options </span><span class="s4">=== </span><span class="s5">'function'</span><span class="s4">) {</span>
    <span class="s2">callback </span><span class="s4">= </span><span class="s2">options</span><span class="s4">;</span>
    <span class="s2">options </span><span class="s4">= {};</span>
  <span class="s4">}</span>
  <span class="s2">options </span><span class="s4">= </span><span class="s2">options </span><span class="s4">|| {};</span>

  <span class="s3">var </span><span class="s2">opts </span><span class="s4">= {</span>
    <span class="s2">algorithm</span><span class="s4">: {</span>
      <span class="s2">name</span><span class="s4">: </span><span class="s2">options</span><span class="s4">.</span><span class="s2">algorithm </span><span class="s4">|| </span><span class="s5">'PRIMEINC'</span><span class="s4">,</span>
      <span class="s2">options</span><span class="s4">: {</span>
        <span class="s2">workers</span><span class="s4">: </span><span class="s2">options</span><span class="s4">.</span><span class="s2">workers </span><span class="s4">|| </span><span class="s7">2</span><span class="s4">,</span>
        <span class="s2">workLoad</span><span class="s4">: </span><span class="s2">options</span><span class="s4">.</span><span class="s2">workLoad </span><span class="s4">|| </span><span class="s7">100</span><span class="s4">,</span>
        <span class="s2">workerScript</span><span class="s4">: </span><span class="s2">options</span><span class="s4">.</span><span class="s2">workerScript</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
  <span class="s4">};</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s5">'prng' </span><span class="s3">in </span><span class="s2">options</span><span class="s4">) {</span>
    <span class="s2">opts</span><span class="s4">.</span><span class="s2">prng </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">prng</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s2">generate</span><span class="s4">();</span>

  <span class="s3">function </span><span class="s2">generate</span><span class="s4">() {</span>
    <span class="s6">// find p and then q (done in series to simplify)</span>
    <span class="s2">getPrime</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">pBits</span><span class="s4">, </span><span class="s3">function</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">num</span><span class="s4">) {</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">err</span><span class="s4">) {</span>
        <span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
      <span class="s4">}</span>
      <span class="s2">state</span><span class="s4">.</span><span class="s2">p </span><span class="s4">= </span><span class="s2">num</span><span class="s4">;</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">q </span><span class="s4">!== </span><span class="s3">null</span><span class="s4">) {</span>
        <span class="s3">return </span><span class="s2">finish</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">state</span><span class="s4">.</span><span class="s2">q</span><span class="s4">);</span>
      <span class="s4">}</span>
      <span class="s2">getPrime</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">qBits</span><span class="s4">, </span><span class="s2">finish</span><span class="s4">);</span>
    <span class="s4">});</span>
  <span class="s4">}</span>

  <span class="s3">function </span><span class="s2">getPrime</span><span class="s4">(</span><span class="s2">bits</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s2">forge</span><span class="s4">.</span><span class="s2">prime</span><span class="s4">.</span><span class="s2">generateProbablePrime</span><span class="s4">(</span><span class="s2">bits</span><span class="s4">, </span><span class="s2">opts</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s3">function </span><span class="s2">finish</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">num</span><span class="s4">) {</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">err</span><span class="s4">) {</span>
      <span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s6">// set q</span>
    <span class="s2">state</span><span class="s4">.</span><span class="s2">q </span><span class="s4">= </span><span class="s2">num</span><span class="s4">;</span>

    <span class="s6">// ensure p is larger than q (swap them if not)</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">p</span><span class="s4">.</span><span class="s2">compareTo</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">q</span><span class="s4">) &lt; </span><span class="s7">0</span><span class="s4">) {</span>
      <span class="s3">var </span><span class="s2">tmp </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">p</span><span class="s4">;</span>
      <span class="s2">state</span><span class="s4">.</span><span class="s2">p </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">q</span><span class="s4">;</span>
      <span class="s2">state</span><span class="s4">.</span><span class="s2">q </span><span class="s4">= </span><span class="s2">tmp</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s6">// ensure p is coprime with e</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">p</span><span class="s4">.</span><span class="s2">subtract</span><span class="s4">(</span><span class="s2">BigInteger</span><span class="s4">.</span><span class="s2">ONE</span><span class="s4">).</span><span class="s2">gcd</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">e</span><span class="s4">)</span>
      <span class="s4">.</span><span class="s2">compareTo</span><span class="s4">(</span><span class="s2">BigInteger</span><span class="s4">.</span><span class="s2">ONE</span><span class="s4">) !== </span><span class="s7">0</span><span class="s4">) {</span>
      <span class="s2">state</span><span class="s4">.</span><span class="s2">p </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
      <span class="s2">generate</span><span class="s4">();</span>
      <span class="s3">return</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s6">// ensure q is coprime with e</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">q</span><span class="s4">.</span><span class="s2">subtract</span><span class="s4">(</span><span class="s2">BigInteger</span><span class="s4">.</span><span class="s2">ONE</span><span class="s4">).</span><span class="s2">gcd</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">e</span><span class="s4">)</span>
      <span class="s4">.</span><span class="s2">compareTo</span><span class="s4">(</span><span class="s2">BigInteger</span><span class="s4">.</span><span class="s2">ONE</span><span class="s4">) !== </span><span class="s7">0</span><span class="s4">) {</span>
      <span class="s2">state</span><span class="s4">.</span><span class="s2">q </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
      <span class="s2">getPrime</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">qBits</span><span class="s4">, </span><span class="s2">finish</span><span class="s4">);</span>
      <span class="s3">return</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s6">// compute phi: (p - 1)(q - 1) (Euler's totient function)</span>
    <span class="s2">state</span><span class="s4">.</span><span class="s2">p1 </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">p</span><span class="s4">.</span><span class="s2">subtract</span><span class="s4">(</span><span class="s2">BigInteger</span><span class="s4">.</span><span class="s2">ONE</span><span class="s4">);</span>
    <span class="s2">state</span><span class="s4">.</span><span class="s2">q1 </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">q</span><span class="s4">.</span><span class="s2">subtract</span><span class="s4">(</span><span class="s2">BigInteger</span><span class="s4">.</span><span class="s2">ONE</span><span class="s4">);</span>
    <span class="s2">state</span><span class="s4">.</span><span class="s2">phi </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">p1</span><span class="s4">.</span><span class="s2">multiply</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">q1</span><span class="s4">);</span>

    <span class="s6">// ensure e and phi are coprime</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">phi</span><span class="s4">.</span><span class="s2">gcd</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">e</span><span class="s4">).</span><span class="s2">compareTo</span><span class="s4">(</span><span class="s2">BigInteger</span><span class="s4">.</span><span class="s2">ONE</span><span class="s4">) !== </span><span class="s7">0</span><span class="s4">) {</span>
      <span class="s6">// phi and e aren't coprime, so generate a new p and q</span>
      <span class="s2">state</span><span class="s4">.</span><span class="s2">p </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">q </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
      <span class="s2">generate</span><span class="s4">();</span>
      <span class="s3">return</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s6">// create n, ensure n is has the right number of bits</span>
    <span class="s2">state</span><span class="s4">.</span><span class="s2">n </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">p</span><span class="s4">.</span><span class="s2">multiply</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">q</span><span class="s4">);</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">n</span><span class="s4">.</span><span class="s2">bitLength</span><span class="s4">() !== </span><span class="s2">state</span><span class="s4">.</span><span class="s2">bits</span><span class="s4">) {</span>
      <span class="s6">// failed, get new q</span>
      <span class="s2">state</span><span class="s4">.</span><span class="s2">q </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
      <span class="s2">getPrime</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">qBits</span><span class="s4">, </span><span class="s2">finish</span><span class="s4">);</span>
      <span class="s3">return</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s6">// set keys</span>
    <span class="s3">var </span><span class="s2">d </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">e</span><span class="s4">.</span><span class="s2">modInverse</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">phi</span><span class="s4">);</span>
    <span class="s2">state</span><span class="s4">.</span><span class="s2">keys </span><span class="s4">= {</span>
      <span class="s2">privateKey</span><span class="s4">: </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">setPrivateKey</span><span class="s4">(</span>
        <span class="s2">state</span><span class="s4">.</span><span class="s2">n</span><span class="s4">, </span><span class="s2">state</span><span class="s4">.</span><span class="s2">e</span><span class="s4">, </span><span class="s2">d</span><span class="s4">, </span><span class="s2">state</span><span class="s4">.</span><span class="s2">p</span><span class="s4">, </span><span class="s2">state</span><span class="s4">.</span><span class="s2">q</span><span class="s4">,</span>
        <span class="s2">d</span><span class="s4">.</span><span class="s2">mod</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">p1</span><span class="s4">), </span><span class="s2">d</span><span class="s4">.</span><span class="s2">mod</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">q1</span><span class="s4">),</span>
        <span class="s2">state</span><span class="s4">.</span><span class="s2">q</span><span class="s4">.</span><span class="s2">modInverse</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">p</span><span class="s4">)),</span>
      <span class="s2">publicKey</span><span class="s4">: </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">rsa</span><span class="s4">.</span><span class="s2">setPublicKey</span><span class="s4">(</span><span class="s2">state</span><span class="s4">.</span><span class="s2">n</span><span class="s4">, </span><span class="s2">state</span><span class="s4">.</span><span class="s2">e</span><span class="s4">)</span>
    <span class="s4">};</span>

    <span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, </span><span class="s2">state</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">);</span>
  <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a positive BigInteger into 2's-complement big-endian bytes.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">b the big integer to convert.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the bytes.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">_bnToBytes</span><span class="s4">(</span><span class="s2">b</span><span class="s4">) {</span>
  <span class="s6">// prepend 0x00 if first byte &gt;= 0x80</span>
  <span class="s3">var </span><span class="s2">hex </span><span class="s4">= </span><span class="s2">b</span><span class="s4">.</span><span class="s2">toString</span><span class="s4">(</span><span class="s7">16</span><span class="s4">);</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">hex</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] &gt;= </span><span class="s5">'8'</span><span class="s4">) {</span>
    <span class="s2">hex </span><span class="s4">= </span><span class="s5">'00' </span><span class="s4">+ </span><span class="s2">hex</span><span class="s4">;</span>
  <span class="s4">}</span>
  <span class="s3">var </span><span class="s2">bytes </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">hexToBytes</span><span class="s4">(</span><span class="s2">hex</span><span class="s4">);</span>

  <span class="s6">// ensure integer is minimally-encoded</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s7">1 </span><span class="s4">&amp;&amp;</span>
    <span class="s6">// leading 0x00 for positive integer</span>
    <span class="s4">((</span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">charCodeAt</span><span class="s4">(</span><span class="s7">0</span><span class="s4">) === </span><span class="s7">0 </span><span class="s4">&amp;&amp;</span>
    <span class="s4">(</span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">charCodeAt</span><span class="s4">(</span><span class="s7">1</span><span class="s4">) &amp; </span><span class="s7">0x80</span><span class="s4">) === </span><span class="s7">0</span><span class="s4">) ||</span>
    <span class="s6">// leading 0xFF for negative integer</span>
    <span class="s4">(</span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">charCodeAt</span><span class="s4">(</span><span class="s7">0</span><span class="s4">) === </span><span class="s7">0xFF </span><span class="s4">&amp;&amp;</span>
    <span class="s4">(</span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">charCodeAt</span><span class="s4">(</span><span class="s7">1</span><span class="s4">) &amp; </span><span class="s7">0x80</span><span class="s4">) === </span><span class="s7">0x80</span><span class="s4">))) {</span>
    <span class="s3">return </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">substr</span><span class="s4">(</span><span class="s7">1</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s3">return </span><span class="s2">bytes</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the required number of Miller-Rabin tests to generate a</span>
 <span class="s0">* prime with an error probability of (1/2)^80.</span>
 <span class="s0">*</span>
 <span class="s0">* See Handbook of Applied Cryptography Chapter 4, Table 4.4.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">bits the bit size.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the required number of iterations.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">_getMillerRabinTests</span><span class="s4">(</span><span class="s2">bits</span><span class="s4">) {</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">bits </span><span class="s4">&lt;= </span><span class="s7">100</span><span class="s4">) </span><span class="s3">return </span><span class="s7">27</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">bits </span><span class="s4">&lt;= </span><span class="s7">150</span><span class="s4">) </span><span class="s3">return </span><span class="s7">18</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">bits </span><span class="s4">&lt;= </span><span class="s7">200</span><span class="s4">) </span><span class="s3">return </span><span class="s7">15</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">bits </span><span class="s4">&lt;= </span><span class="s7">250</span><span class="s4">) </span><span class="s3">return </span><span class="s7">12</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">bits </span><span class="s4">&lt;= </span><span class="s7">300</span><span class="s4">) </span><span class="s3">return </span><span class="s7">9</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">bits </span><span class="s4">&lt;= </span><span class="s7">350</span><span class="s4">) </span><span class="s3">return </span><span class="s7">8</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">bits </span><span class="s4">&lt;= </span><span class="s7">400</span><span class="s4">) </span><span class="s3">return </span><span class="s7">7</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">bits </span><span class="s4">&lt;= </span><span class="s7">500</span><span class="s4">) </span><span class="s3">return </span><span class="s7">6</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">bits </span><span class="s4">&lt;= </span><span class="s7">600</span><span class="s4">) </span><span class="s3">return </span><span class="s7">5</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">bits </span><span class="s4">&lt;= </span><span class="s7">800</span><span class="s4">) </span><span class="s3">return </span><span class="s7">4</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">bits </span><span class="s4">&lt;= </span><span class="s7">1250</span><span class="s4">) </span><span class="s3">return </span><span class="s7">3</span><span class="s4">;</span>
  <span class="s3">return </span><span class="s7">2</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Performs feature detection on the Node crypto interface.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn the feature (function) to detect.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">true if detected, false if not.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">_detectNodeCrypto</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">) {</span>
  <span class="s3">return </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">isNodejs </span><span class="s4">&amp;&amp; </span><span class="s3">typeof </span><span class="s2">_crypto</span><span class="s4">[</span><span class="s2">fn</span><span class="s4">] === </span><span class="s5">'function'</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Performs feature detection on the SubtleCrypto interface.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn the feature (function) to detect.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">true if detected, false if not.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">_detectSubtleCrypto</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">) {</span>
  <span class="s3">return </span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">util</span><span class="s4">.</span><span class="s2">globalScope </span><span class="s4">!== </span><span class="s5">'undefined' </span><span class="s4">&amp;&amp;</span>
    <span class="s3">typeof </span><span class="s2">util</span><span class="s4">.</span><span class="s2">globalScope</span><span class="s4">.</span><span class="s2">crypto </span><span class="s4">=== </span><span class="s5">'object' </span><span class="s4">&amp;&amp;</span>
    <span class="s3">typeof </span><span class="s2">util</span><span class="s4">.</span><span class="s2">globalScope</span><span class="s4">.</span><span class="s2">crypto</span><span class="s4">.</span><span class="s2">subtle </span><span class="s4">=== </span><span class="s5">'object' </span><span class="s4">&amp;&amp;</span>
    <span class="s3">typeof </span><span class="s2">util</span><span class="s4">.</span><span class="s2">globalScope</span><span class="s4">.</span><span class="s2">crypto</span><span class="s4">.</span><span class="s2">subtle</span><span class="s4">[</span><span class="s2">fn</span><span class="s4">] === </span><span class="s5">'function'</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Performs feature detection on the deprecated Microsoft Internet Explorer</span>
 <span class="s0">* outdated SubtleCrypto interface. This function should only be used after</span>
 <span class="s0">* checking for the modern, standard SubtleCrypto interface.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn the feature (function) to detect.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">true if detected, false if not.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">_detectSubtleMsCrypto</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">) {</span>
  <span class="s3">return </span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">util</span><span class="s4">.</span><span class="s2">globalScope </span><span class="s4">!== </span><span class="s5">'undefined' </span><span class="s4">&amp;&amp;</span>
    <span class="s3">typeof </span><span class="s2">util</span><span class="s4">.</span><span class="s2">globalScope</span><span class="s4">.</span><span class="s2">msCrypto </span><span class="s4">=== </span><span class="s5">'object' </span><span class="s4">&amp;&amp;</span>
    <span class="s3">typeof </span><span class="s2">util</span><span class="s4">.</span><span class="s2">globalScope</span><span class="s4">.</span><span class="s2">msCrypto</span><span class="s4">.</span><span class="s2">subtle </span><span class="s4">=== </span><span class="s5">'object' </span><span class="s4">&amp;&amp;</span>
    <span class="s3">typeof </span><span class="s2">util</span><span class="s4">.</span><span class="s2">globalScope</span><span class="s4">.</span><span class="s2">msCrypto</span><span class="s4">.</span><span class="s2">subtle</span><span class="s4">[</span><span class="s2">fn</span><span class="s4">] === </span><span class="s5">'function'</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">_intToUint8Array</span><span class="s4">(</span><span class="s2">x</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">bytes </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">hexToBytes</span><span class="s4">(</span><span class="s2">x</span><span class="s4">.</span><span class="s2">toString</span><span class="s4">(</span><span class="s7">16</span><span class="s4">));</span>
  <span class="s3">var </span><span class="s2">buffer </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Uint8Array</span><span class="s4">(</span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">);</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s2">buffer</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s2">bytes</span><span class="s4">.</span><span class="s2">charCodeAt</span><span class="s4">(</span><span class="s2">i</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s3">return </span><span class="s2">buffer</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">_privateKeyFromJwk</span><span class="s4">(</span><span class="s2">jwk</span><span class="s4">) {</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">jwk</span><span class="s4">.</span><span class="s2">kty </span><span class="s4">!== </span><span class="s5">'RSA'</span><span class="s4">) {</span>
    <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span>
      <span class="s5">'Unsupported key algorithm &quot;' </span><span class="s4">+ </span><span class="s2">jwk</span><span class="s4">.</span><span class="s2">kty </span><span class="s4">+ </span><span class="s5">'&quot;; algorithm must be &quot;RSA&quot;.'</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s3">return </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">setRsaPrivateKey</span><span class="s4">(</span>
    <span class="s2">_base64ToBigInt</span><span class="s4">(</span><span class="s2">jwk</span><span class="s4">.</span><span class="s2">n</span><span class="s4">),</span>
    <span class="s2">_base64ToBigInt</span><span class="s4">(</span><span class="s2">jwk</span><span class="s4">.</span><span class="s2">e</span><span class="s4">),</span>
    <span class="s2">_base64ToBigInt</span><span class="s4">(</span><span class="s2">jwk</span><span class="s4">.</span><span class="s2">d</span><span class="s4">),</span>
    <span class="s2">_base64ToBigInt</span><span class="s4">(</span><span class="s2">jwk</span><span class="s4">.</span><span class="s2">p</span><span class="s4">),</span>
    <span class="s2">_base64ToBigInt</span><span class="s4">(</span><span class="s2">jwk</span><span class="s4">.</span><span class="s2">q</span><span class="s4">),</span>
    <span class="s2">_base64ToBigInt</span><span class="s4">(</span><span class="s2">jwk</span><span class="s4">.</span><span class="s2">dp</span><span class="s4">),</span>
    <span class="s2">_base64ToBigInt</span><span class="s4">(</span><span class="s2">jwk</span><span class="s4">.</span><span class="s2">dq</span><span class="s4">),</span>
    <span class="s2">_base64ToBigInt</span><span class="s4">(</span><span class="s2">jwk</span><span class="s4">.</span><span class="s2">qi</span><span class="s4">));</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">_publicKeyFromJwk</span><span class="s4">(</span><span class="s2">jwk</span><span class="s4">) {</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">jwk</span><span class="s4">.</span><span class="s2">kty </span><span class="s4">!== </span><span class="s5">'RSA'</span><span class="s4">) {</span>
    <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Key algorithm must be &quot;RSA&quot;.'</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s3">return </span><span class="s2">pki</span><span class="s4">.</span><span class="s2">setRsaPublicKey</span><span class="s4">(</span>
    <span class="s2">_base64ToBigInt</span><span class="s4">(</span><span class="s2">jwk</span><span class="s4">.</span><span class="s2">n</span><span class="s4">),</span>
    <span class="s2">_base64ToBigInt</span><span class="s4">(</span><span class="s2">jwk</span><span class="s4">.</span><span class="s2">e</span><span class="s4">));</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">_base64ToBigInt</span><span class="s4">(</span><span class="s2">b64</span><span class="s4">) {</span>
  <span class="s3">return new </span><span class="s2">BigInteger</span><span class="s4">(</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">bytesToHex</span><span class="s4">(</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">decode64</span><span class="s4">(</span><span class="s2">b64</span><span class="s4">)), </span><span class="s7">16</span><span class="s4">);</span>
<span class="s4">}</span>
</pre>
</body>
</html>