<html>
<head>
<title>API.md</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #c77dbb; font-style: italic;}
.s4 { color: #6aab73;}
.s5 { color: #56a8f5;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
API.md</font>
</center></td></tr></table>
<pre><span class="s0"># </span><span class="s2">API Documentation</span>

<span class="s1">*</span><span class="s2">Please use only this documented API when working with the parser. Methods</span>
<span class="s2">not documented here are subject to change at any point.</span><span class="s1">*</span>

<span class="s0">## </span><span class="s2">`parser` function</span>

<span class="s2">This is the module's main entry point.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">const parser = require('postcss-selector-parser');</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">`parser</span><span class="s1">([</span><span class="s2">transform</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s2">options</span><span class="s1">])</span><span class="s2">`</span>

<span class="s2">Creates a new `processor` instance</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">const processor = parser();</span>
<span class="s0">```</span>

<span class="s2">Or, with optional transform function</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">const transform = selectors =&gt; {</span>
    <span class="s4">selectors.walkUniversals(selector =&gt; {</span>
        <span class="s4">selector.remove();</span>
    <span class="s4">});</span>
<span class="s4">};</span>

<span class="s4">const processor = parser(transform)</span>

<span class="s4">// Example</span>
<span class="s4">const result = processor.processSync('*.class');</span>
<span class="s4">// =&gt; .class</span>
<span class="s0">```</span>

<span class="s1">[</span><span class="s2">See processor documentation</span><span class="s1">](</span><span class="s2">#processor</span><span class="s1">)</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`transform </span><span class="s1">(</span><span class="s2">function</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">Provide a function to work with the parsed AST.</span>
<span class="s0">* </span><span class="s2">`options </span><span class="s1">(</span><span class="s2">object</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">Provide default options for all calls on the returned `Processor`.</span>

<span class="s0">### </span><span class="s2">`parser.attribute</span><span class="s1">([</span><span class="s2">props</span><span class="s1">])</span><span class="s2">`</span>

<span class="s2">Creates a new attribute selector.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">parser.attribute({attribute: 'href'});</span>
<span class="s4">// =&gt; [href]</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`props </span><span class="s1">(</span><span class="s2">object</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">The new node's properties.</span>

<span class="s0">### </span><span class="s2">`parser.className</span><span class="s1">([</span><span class="s2">props</span><span class="s1">])</span><span class="s2">`</span>

<span class="s2">Creates a new class selector.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">parser.className({value: 'button'});</span>
<span class="s4">// =&gt; .button</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`props </span><span class="s1">(</span><span class="s2">object</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">The new node's properties.</span>

<span class="s0">### </span><span class="s2">`parser.combinator</span><span class="s1">([</span><span class="s2">props</span><span class="s1">])</span><span class="s2">`</span>

<span class="s2">Creates a new selector combinator.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">parser.combinator({value: '+'});</span>
<span class="s4">// =&gt; +</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`props </span><span class="s1">(</span><span class="s2">object</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">The new node's properties.</span>

<span class="s2">Notes</span><span class="s1">:</span>
<span class="s0">* </span><span class="s1">**</span><span class="s2">Descendant Combinators</span><span class="s1">** </span><span class="s2">The value of descendant combinators created by the</span>
  <span class="s2">parser always just a single space </span><span class="s1">(</span><span class="s2">`</span><span class="s1">&quot; &quot;</span><span class="s2">`</span><span class="s1">)</span><span class="s2">. For descendant selectors with no</span>
  <span class="s2">comments, additional space is now stored in `node.spaces.before`. Depending</span>
  <span class="s2">on the location of comments, additional spaces may be stored in</span>
  <span class="s2">`node.raws.spaces.before`, `node.raws.spaces.after`, or `node.raws.value`.</span>
<span class="s0">* </span><span class="s1">**</span><span class="s2">Named Combinators</span><span class="s1">** </span><span class="s2">Although, nonstandard and unlikely to ever become a standard,</span>
  <span class="s2">named combinators like `/deep/` and `/for/` are parsed as combinators. The</span>
  <span class="s2">`node.value` is name after being unescaped and normalized as lowercase. The</span>
  <span class="s2">original value for the combinator name is stored in `node.raws.value`.</span>


<span class="s0">### </span><span class="s2">`parser.comment</span><span class="s1">([</span><span class="s2">props</span><span class="s1">])</span><span class="s2">`</span>

<span class="s2">Creates a new comment.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">parser.comment({value: '/* Affirmative, Dave. I read you. */'});</span>
<span class="s4">// =&gt; /* Affirmative, Dave. I read you. */</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`props </span><span class="s1">(</span><span class="s2">object</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">The new node's properties.</span>

<span class="s0">### </span><span class="s2">`parser.id</span><span class="s1">([</span><span class="s2">props</span><span class="s1">])</span><span class="s2">`</span>

<span class="s2">Creates a new id selector.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">parser.id({value: 'search'});</span>
<span class="s4">// =&gt; #search</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`props </span><span class="s1">(</span><span class="s2">object</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">The new node's properties.</span>

<span class="s0">### </span><span class="s2">`parser.nesting</span><span class="s1">([</span><span class="s2">props</span><span class="s1">])</span><span class="s2">`</span>

<span class="s2">Creates a new nesting selector.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">parser.nesting();</span>
<span class="s4">// =&gt; &amp;</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`props </span><span class="s1">(</span><span class="s2">object</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">The new node's properties.</span>

<span class="s0">### </span><span class="s2">`parser.pseudo</span><span class="s1">([</span><span class="s2">props</span><span class="s1">])</span><span class="s2">`</span>

<span class="s2">Creates a new pseudo selector.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">parser.pseudo({value: '::before'});</span>
<span class="s4">// =&gt; ::before</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`props </span><span class="s1">(</span><span class="s2">object</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">The new node's properties.</span>

<span class="s0">### </span><span class="s2">`parser.root</span><span class="s1">([</span><span class="s2">props</span><span class="s1">])</span><span class="s2">`</span>

<span class="s2">Creates a new root node.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">parser.root();</span>
<span class="s4">// =&gt; (empty)</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`props </span><span class="s1">(</span><span class="s2">object</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">The new node's properties.</span>

<span class="s0">### </span><span class="s2">`parser.selector</span><span class="s1">([</span><span class="s2">props</span><span class="s1">])</span><span class="s2">`</span>

<span class="s2">Creates a new selector node.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">parser.selector();</span>
<span class="s4">// =&gt; (empty)</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`props </span><span class="s1">(</span><span class="s2">object</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">The new node's properties.</span>

<span class="s0">### </span><span class="s2">`parser.string</span><span class="s1">([</span><span class="s2">props</span><span class="s1">])</span><span class="s2">`</span>

<span class="s2">Creates a new string node.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">parser.string();</span>
<span class="s4">// =&gt; (empty)</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`props </span><span class="s1">(</span><span class="s2">object</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">The new node's properties.</span>

<span class="s0">### </span><span class="s2">`parser.tag</span><span class="s1">([</span><span class="s2">props</span><span class="s1">])</span><span class="s2">`</span>

<span class="s2">Creates a new tag selector.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">parser.tag({value: 'button'});</span>
<span class="s4">// =&gt; button</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`props </span><span class="s1">(</span><span class="s2">object</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">The new node's properties.</span>

<span class="s0">### </span><span class="s2">`parser.universal</span><span class="s1">([</span><span class="s2">props</span><span class="s1">])</span><span class="s2">`</span>

<span class="s2">Creates a new universal selector.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">parser.universal();</span>
<span class="s4">// =&gt; *</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`props </span><span class="s1">(</span><span class="s2">object</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">The new node's properties.</span>

<span class="s0">## </span><span class="s2">Node types</span>

<span class="s0">### </span><span class="s2">`node.type`</span>

<span class="s2">A string representation of the selector type. It can be one of the following;</span>
<span class="s2">`attribute`, `class`, `combinator`, `comment`, `id`, `nesting`, `pseudo`,</span>
<span class="s2">`root`, `selector`, `string`, `tag`, or `universal`. Note that for convenience,</span>
<span class="s2">these constants are exposed on the main `parser` as uppercased keys. So for</span>
<span class="s2">example you can get `id` by querying `parser.ID`.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">parser.attribute({attribute: 'href'}).type;</span>
<span class="s4">// =&gt; 'attribute'</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">`node.parent`</span>

<span class="s2">Returns the parent node.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">root.nodes[0].parent === root;</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">`node.toString</span><span class="s1">()</span><span class="s2">`, `String</span><span class="s1">(</span><span class="s2">node</span><span class="s1">)</span><span class="s2">`, or `</span><span class="s1">'' </span><span class="s2">+ node`</span>

<span class="s2">Returns a string representation of the node.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">const id = parser.id({value: 'search'});</span>
<span class="s4">console.log(String(id));</span>
<span class="s4">// =&gt; #search</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">`node.next</span><span class="s1">()</span><span class="s2">` &amp; `node.prev</span><span class="s1">()</span><span class="s2">`</span>

<span class="s2">Returns the next/previous child of the parent node.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">const next = id.next();</span>
<span class="s4">if (next &amp;&amp; next.type !== 'combinator') {</span>
    <span class="s4">throw new Error('Qualified IDs are not allowed!');</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">`node.replaceWith</span><span class="s1">(</span><span class="s2">node</span><span class="s1">)</span><span class="s2">`</span>

<span class="s2">Replace a node with another.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">const attr = selectors.first.first;</span>
<span class="s4">const className = parser.className({value: 'test'});</span>
<span class="s4">attr.replaceWith(className);</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`node`</span><span class="s1">: </span><span class="s2">The node to substitute the original with.</span>

<span class="s0">### </span><span class="s2">`node.remove</span><span class="s1">()</span><span class="s2">`</span>

<span class="s2">Removes the node from its parent node.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">if (node.type === 'id') {</span>
    <span class="s4">node.remove();</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">`node.clone</span><span class="s1">([</span><span class="s2">opts</span><span class="s1">])</span><span class="s2">`</span>

<span class="s2">Returns a copy of a node, detached from any parent containers that the</span>
<span class="s2">original might have had.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">const cloned = node.clone();</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">`node.isAtPosition</span><span class="s1">(</span><span class="s2">line, column</span><span class="s1">)</span><span class="s2">`</span>

<span class="s2">Return a `boolean` indicating whether this node includes the character at the</span>
<span class="s2">position of the given line and column. Returns `undefined` if the nodes lack</span>
<span class="s2">sufficient source metadata to determine the position.</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`line`</span><span class="s1">: </span><span class="s2">1-index based line number relative to the start of the selector.</span>
<span class="s0">* </span><span class="s2">`column`</span><span class="s1">: </span><span class="s2">1-index based column number relative to the start of the selector.</span>

<span class="s0">### </span><span class="s2">`node.spaces`</span>

<span class="s2">Extra whitespaces around the node will be moved into `node.spaces.before` and</span>
<span class="s2">`node.spaces.after`. So for example, these spaces will be moved as they have</span>
<span class="s2">no semantic meaning</span><span class="s1">:</span>

<span class="s0">```</span><span class="s3">css</span>
      <span class="s4">h1     ,     h2   {}</span>
<span class="s0">```</span>

<span class="s2">For descendent selectors, the value is always a single space.</span>

<span class="s0">```</span><span class="s3">css</span>
<span class="s4">h1        h2 {}</span>
<span class="s0">```</span>

<span class="s2">Additional whitespace is found in either the `node.spaces.before` and `node.spaces.after` depending on the presence of comments or other whitespace characters. If the actual whitespace does not start or end with a single space, the node's raw value is set to the actual space</span><span class="s1">(</span><span class="s2">s</span><span class="s1">) </span><span class="s2">found in the source.</span>

<span class="s0">### </span><span class="s2">`node.source`</span>

<span class="s2">An object describing the node's start/end, line/column source position.</span>

<span class="s2">Within the following CSS, the `.bar` class node ...</span>

<span class="s0">```</span><span class="s3">css</span>
<span class="s4">.foo,</span>
  <span class="s4">.bar {}</span>
<span class="s0">```</span>

<span class="s2">... will contain the following `source` object.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">source: {</span>
    <span class="s4">start: {</span>
        <span class="s4">line: 2,</span>
        <span class="s4">column: 3</span>
    <span class="s4">},</span>
    <span class="s4">end: {</span>
        <span class="s4">line: 2,</span>
        <span class="s4">column: 6</span>
    <span class="s4">}</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">`node.sourceIndex`</span>

<span class="s2">The zero-based index of the node within the original source string.</span>

<span class="s2">Within the following CSS, the `.baz` class node will have a `sourceIndex` of `12`.</span>

<span class="s0">```</span><span class="s3">css</span>
<span class="s4">.foo, .bar, .baz {}</span>
<span class="s0">```</span>

<span class="s0">## </span><span class="s2">Container types</span>

<span class="s2">The `root`, `selector`, and `pseudo` nodes have some helper methods for working</span>
<span class="s2">with their children.</span>

<span class="s0">### </span><span class="s2">`container.nodes`</span>

<span class="s2">An array of the container's children.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">// Input: h1 h2</span>
<span class="s4">selectors.at(0).nodes.length   // =&gt; 3</span>
<span class="s4">selectors.at(0).nodes[0].value // =&gt; 'h1'</span>
<span class="s4">selectors.at(0).nodes[1].value // =&gt; ' '</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">`container.first` &amp; `container.last`</span>

<span class="s2">The first/last child of the container.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">selector.first === selector.nodes[0];</span>
<span class="s4">selector.last === selector.nodes[selector.nodes.length - 1];</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">`container.at</span><span class="s1">(</span><span class="s2">index</span><span class="s1">)</span><span class="s2">`</span>

<span class="s2">Returns the node at position `index`.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">selector.at(0) === selector.first;</span>
<span class="s4">selector.at(0) === selector.nodes[0];</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`index`</span><span class="s1">: </span><span class="s2">The index of the node to return.</span>

<span class="s0">### </span><span class="s2">`container.atPosition</span><span class="s1">(</span><span class="s2">line, column</span><span class="s1">)</span><span class="s2">`</span>

<span class="s2">Returns the node at the source position `line` and `column`.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">// Input: :not(.foo),\n#foo &gt; :matches(ol, ul)</span>
<span class="s4">selector.atPosition(1, 1); // =&gt; :not(.foo)</span>
<span class="s4">selector.atPosition(2, 1); // =&gt; \n#foo</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`line`</span><span class="s1">: </span><span class="s2">The line number of the node to return.</span>
<span class="s0">* </span><span class="s2">`column`</span><span class="s1">: </span><span class="s2">The column number of the node to return.</span>

<span class="s0">### </span><span class="s2">`container.index</span><span class="s1">(</span><span class="s2">node</span><span class="s1">)</span><span class="s2">`</span>

<span class="s2">Return the index of the node within its container.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">selector.index(selector.nodes[2]) // =&gt; 2</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`node`</span><span class="s1">: </span><span class="s2">A node within the current container.</span>

<span class="s0">### </span><span class="s2">`container.length`</span>

<span class="s2">Proxy to the length of the container's nodes.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">container.length === container.nodes.length</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">`container` Array iterators</span>

<span class="s2">The container class provides proxies to certain Array methods; these are</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`container.map === container.nodes.map`</span>
<span class="s0">* </span><span class="s2">`container.reduce === container.nodes.reduce`</span>
<span class="s0">* </span><span class="s2">`container.every === container.nodes.every`</span>
<span class="s0">* </span><span class="s2">`container.some === container.nodes.some`</span>
<span class="s0">* </span><span class="s2">`container.filter === container.nodes.filter`</span>
<span class="s0">* </span><span class="s2">`container.sort === container.nodes.sort`</span>

<span class="s2">Note that these methods only work on a container's immediate children; recursive</span>
<span class="s2">iteration is provided by `container.walk`.</span>

<span class="s0">### </span><span class="s2">`container.each</span><span class="s1">(</span><span class="s2">callback</span><span class="s1">)</span><span class="s2">`</span>

<span class="s2">Iterate the container's immediate children, calling `callback` for each child.</span>
<span class="s2">You may return `false` within the callback to break the iteration.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">let className;</span>
<span class="s4">selectors.each((selector, index) =&gt; {</span>
    <span class="s4">if (selector.type === 'class') {</span>
        <span class="s4">className = selector.value;</span>
        <span class="s4">return false;</span>
    <span class="s4">}</span>
<span class="s4">});</span>
<span class="s0">```</span>

<span class="s2">Note that unlike `Array#forEach</span><span class="s1">()</span><span class="s2">`, this iterator is safe to use whilst adding</span>
<span class="s2">or removing nodes from the container.</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`callback </span><span class="s1">(</span><span class="s2">function</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">A function to call for each node, which receives `node`</span>
  <span class="s2">and `index` arguments.</span>

<span class="s0">### </span><span class="s2">`container.walk</span><span class="s1">(</span><span class="s2">callback</span><span class="s1">)</span><span class="s2">`</span>

<span class="s2">Like `container#each`, but will also iterate child nodes as long as they are</span>
<span class="s2">`container` types.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">selectors.walk((selector, index) =&gt; {</span>
    <span class="s4">// all nodes</span>
<span class="s4">});</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`callback </span><span class="s1">(</span><span class="s2">function</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">A function to call for each node, which receives `node`</span>
  <span class="s2">and `index` arguments.</span>

<span class="s2">This iterator is safe to use whilst mutating `container.nodes`,</span>
<span class="s2">like `container#each`.</span>

<span class="s0">### </span><span class="s2">`container.walk` proxies</span>

<span class="s2">The container class provides proxy methods for iterating over types of nodes,</span>
<span class="s2">so that it is easier to write modules that target specific selectors. Those</span>
<span class="s2">methods are</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`container.walkAttributes`</span>
<span class="s0">* </span><span class="s2">`container.walkClasses`</span>
<span class="s0">* </span><span class="s2">`container.walkCombinators`</span>
<span class="s0">* </span><span class="s2">`container.walkComments`</span>
<span class="s0">* </span><span class="s2">`container.walkIds`</span>
<span class="s0">* </span><span class="s2">`container.walkNesting`</span>
<span class="s0">* </span><span class="s2">`container.walkPseudos`</span>
<span class="s0">* </span><span class="s2">`container.walkTags`</span>
<span class="s0">* </span><span class="s2">`container.walkUniversals`</span>

<span class="s0">### </span><span class="s2">`container.split</span><span class="s1">(</span><span class="s2">callback</span><span class="s1">)</span><span class="s2">`</span>

<span class="s2">This method allows you to split a group of nodes by returning `true` from</span>
<span class="s2">a callback. It returns an array of arrays, where each inner array corresponds</span>
<span class="s2">to the groups that you created via the callback.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">// (input) =&gt; h1 h2&gt;&gt;h3</span>
<span class="s4">const list = selectors.first.split(selector =&gt; {</span>
    <span class="s4">return selector.type === 'combinator';</span>
<span class="s4">});</span>

<span class="s4">// (node values) =&gt; [['h1', ' '], ['h2', '&gt;&gt;'], ['h3']]</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`callback </span><span class="s1">(</span><span class="s2">function</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">A function to call for each node, which receives `node`</span>
  <span class="s2">as an argument.</span>

<span class="s0">### </span><span class="s2">`container.prepend</span><span class="s1">(</span><span class="s2">node</span><span class="s1">)</span><span class="s2">` &amp; `container.append</span><span class="s1">(</span><span class="s2">node</span><span class="s1">)</span><span class="s2">`</span>

<span class="s2">Add a node to the start/end of the container. Note that doing so will set</span>
<span class="s2">the parent property of the node to this container.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">const id = parser.id({value: 'search'});</span>
<span class="s4">selector.append(id);</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`node`</span><span class="s1">: </span><span class="s2">The node to add.</span>

<span class="s0">### </span><span class="s2">`container.insertBefore</span><span class="s1">(</span><span class="s2">old, new</span><span class="s1">)</span><span class="s2">` &amp; `container.insertAfter</span><span class="s1">(</span><span class="s2">old, new</span><span class="s1">)</span><span class="s2">`</span>

<span class="s2">Add a node before or after an existing node in a container</span><span class="s1">:</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">selectors.walk(selector =&gt; {</span>
    <span class="s4">if (selector.type !== 'class') {</span>
        <span class="s4">const className = parser.className({value: 'theme-name'});</span>
        <span class="s4">selector.parent.insertAfter(selector, className);</span>
    <span class="s4">}</span>
<span class="s4">});</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`old`</span><span class="s1">: </span><span class="s2">The existing node in the container.</span>
<span class="s0">* </span><span class="s2">`new`</span><span class="s1">: </span><span class="s2">The new node to add before/after the existing node.</span>

<span class="s0">### </span><span class="s2">`container.removeChild</span><span class="s1">(</span><span class="s2">node</span><span class="s1">)</span><span class="s2">`</span>

<span class="s2">Remove the node from the container. Note that you can also use</span>
<span class="s2">`node.remove</span><span class="s1">()</span><span class="s2">` if you would like to remove just a single node.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">selector.length // =&gt; 2</span>
<span class="s4">selector.remove(id)</span>
<span class="s4">selector.length // =&gt; 1;</span>
<span class="s4">id.parent       // undefined</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`node`</span><span class="s1">: </span><span class="s2">The node to remove.</span>

<span class="s0">### </span><span class="s2">`container.removeAll</span><span class="s1">()</span><span class="s2">` or `container.empty</span><span class="s1">()</span><span class="s2">`</span>

<span class="s2">Remove all children from the container.</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">selector.removeAll();</span>
<span class="s4">selector.length // =&gt; 0</span>
<span class="s0">```</span>

<span class="s0">## </span><span class="s2">Root nodes</span>

<span class="s2">A root node represents a comma separated list of selectors. Indeed, all</span>
<span class="s2">a root's `toString</span><span class="s1">()</span><span class="s2">` method does is join its selector children with a </span><span class="s1">'</span><span class="s2">,'.</span>
<span class="s2">Other than this, it has no special functionality and acts like a container.</span>

<span class="s0">### </span><span class="s2">`root.trailingComma`</span>

<span class="s2">This will be set to `true` if the input has a trailing comma, in order to</span>
<span class="s2">support parsing of legacy CSS hacks.</span>

<span class="s0">## </span><span class="s2">Selector nodes</span>

<span class="s2">A selector node represents a single complex selector. For example, this</span>
<span class="s2">selector string `h1 h2 h3, </span><span class="s1">[</span><span class="s2">href</span><span class="s1">] &gt; </span><span class="s2">p`, is represented as two selector nodes.</span>
<span class="s2">It has no special functionality of its own.</span>

<span class="s0">## </span><span class="s2">Pseudo nodes</span>

<span class="s2">A pseudo selector extends a container node; if it has any parameters of its</span>
<span class="s2">own </span><span class="s1">(</span><span class="s2">such as `h1</span><span class="s1">:</span><span class="s2">not</span><span class="s1">(</span><span class="s2">h2, h3</span><span class="s1">)</span><span class="s2">`</span><span class="s1">)</span><span class="s2">, they will be its children. Note that the pseudo</span>
<span class="s2">`value` will always contain the colons preceding the pseudo identifier. This</span>
<span class="s2">is so that both `</span><span class="s1">:</span><span class="s2">before` and `</span><span class="s1">::</span><span class="s2">before` are properly represented in the AST.</span>

<span class="s0">## </span><span class="s2">Attribute nodes</span>

<span class="s0">### </span><span class="s2">`attribute.quoted`</span>

<span class="s2">Returns `true` if the attribute's value is wrapped in quotation marks, false if it is not.</span>
<span class="s2">Remains `undefined` if there is no attribute value.</span>

<span class="s0">```</span><span class="s3">css</span>
<span class="s4">[href=foo] /* false */</span>
<span class="s4">[href='foo'] /* true */</span>
<span class="s4">[href=&quot;foo&quot;] /* true */</span>
<span class="s4">[href] /* undefined */</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">`attribute.qualifiedAttribute`</span>

<span class="s2">Returns the attribute name qualified with the namespace if one is given.</span>

<span class="s0">### </span><span class="s2">`attribute.offsetOf</span><span class="s1">(</span><span class="s2">part</span><span class="s1">)</span><span class="s2">`</span>

 <span class="s2">Returns the offset of the attribute part specified relative to the</span>
 <span class="s2">start of the node of the output string. This is useful in raising</span>
 <span class="s2">error messages about a specific part of the attribute, especially</span>
 <span class="s2">in combination with `attribute.sourceIndex`.</span>

 <span class="s2">Returns `-1` if the name is invalid or the value doesn't exist in this</span>
 <span class="s2">attribute.</span>

 <span class="s2">The legal values for `part` are</span><span class="s1">:</span>

 <span class="s0">* </span><span class="s2">`</span><span class="s1">&quot;</span><span class="s2">ns</span><span class="s1">&quot;</span><span class="s2">` - alias for </span><span class="s1">&quot;</span><span class="s2">namespace</span><span class="s1">&quot;</span>
 <span class="s0">* </span><span class="s2">`</span><span class="s1">&quot;</span><span class="s2">namespace</span><span class="s1">&quot;</span><span class="s2">` - the namespace if it exists.</span>
 <span class="s0">* </span><span class="s2">`</span><span class="s1">&quot;</span><span class="s2">attribute</span><span class="s1">&quot;</span><span class="s2">` - the attribute name</span>
 <span class="s0">* </span><span class="s2">`</span><span class="s1">&quot;</span><span class="s2">attributeNS</span><span class="s1">&quot;</span><span class="s2">` - the start of the attribute or its namespace</span>
 <span class="s0">* </span><span class="s2">`</span><span class="s1">&quot;</span><span class="s2">operator</span><span class="s1">&quot;</span><span class="s2">` - the match operator of the attribute</span>
 <span class="s0">* </span><span class="s2">`</span><span class="s1">&quot;</span><span class="s2">value</span><span class="s1">&quot;</span><span class="s2">` - The value </span><span class="s1">(</span><span class="s2">string or identifier</span><span class="s1">)</span>
 <span class="s0">* </span><span class="s2">`</span><span class="s1">&quot;</span><span class="s2">insensitive</span><span class="s1">&quot;</span><span class="s2">` - the case insensitivity flag</span>

<span class="s0">### </span><span class="s2">`attribute.raws.unquoted`</span>

<span class="s2">Returns the unquoted content of the attribute's value.</span>
<span class="s2">Remains `undefined` if there is no attribute value.</span>

<span class="s0">```</span><span class="s3">css</span>
<span class="s4">[href=foo] /* foo */</span>
<span class="s4">[href='foo'] /* foo */</span>
<span class="s4">[href=&quot;foo&quot;] /* foo */</span>
<span class="s4">[href] /* undefined */</span>
<span class="s0">```</span>

<span class="s0">### </span><span class="s2">`attribute.spaces`</span>

<span class="s2">Like `node.spaces` with the `before` and `after` values containing the spaces</span>
<span class="s2">around the element, the parts of the attribute can also have spaces before</span>
<span class="s2">and after them. The for each of `attribute`, `operator`, `value` and</span>
<span class="s2">`insensitive` there is corresponding property of the same nam in</span>
<span class="s2">`node.spaces` that has an optional `before` or `after` string containing only</span>
<span class="s2">whitespace.</span>

<span class="s2">Note that corresponding values in `attributes.raws.spaces` contain values</span>
<span class="s2">including any comments. If set, these values will override the</span>
<span class="s2">`attribute.spaces` value. Take care to remove them if changing</span>
<span class="s2">`attribute.spaces`.</span>

<span class="s0">### </span><span class="s2">`attribute.raws`</span>

<span class="s2">The raws object stores comments and other information necessary to re-render</span>
<span class="s2">the node exactly as it was in the source.</span>

<span class="s2">If a comment is embedded within the identifiers for the `namespace`, `attribute`</span>
<span class="s2">or `value` then a property is placed in the raws for that value containing the full source of the propery including comments.</span>

<span class="s2">If a comment is embedded within the space between parts of the attribute</span>
<span class="s2">then the raw for that space is set accordingly.</span>

<span class="s2">Setting an attribute's property `raws` value to be deleted.</span>

<span class="s2">For now, changing the spaces required also updating or removing any of the</span>
<span class="s2">raws values that override them.</span>

<span class="s2">Example</span><span class="s1">: </span><span class="s2">`</span><span class="s1">[ </span><span class="s2">/</span><span class="s1">*</span><span class="s2">before</span><span class="s1">*</span><span class="s2">/ href /</span><span class="s1">* </span><span class="s2">after-attr </span><span class="s1">*</span><span class="s2">/ = /</span><span class="s1">* </span><span class="s2">after-operator </span><span class="s1">*</span><span class="s2">/ te/</span><span class="s1">*</span><span class="s2">inside-value</span><span class="s1">*</span><span class="s2">/st/</span><span class="s1">* </span><span class="s2">wow </span><span class="s1">*</span><span class="s2">/ /</span><span class="s1">*</span><span class="s2">omg</span><span class="s1">*</span><span class="s2">/i/</span><span class="s1">*</span><span class="s2">bbq</span><span class="s1">*</span><span class="s2">/ /</span><span class="s1">*</span><span class="s2">whodoesthis</span><span class="s1">*</span><span class="s2">/</span><span class="s1">]</span><span class="s2">` would parse as</span><span class="s1">:</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">{</span>
  <span class="s4">attribute: &quot;href&quot;,</span>
  <span class="s4">operator: &quot;=&quot;,</span>
  <span class="s4">value: &quot;test&quot;,</span>
  <span class="s4">spaces: {</span>
    <span class="s4">before: '',</span>
    <span class="s4">after: '',</span>
    <span class="s4">attribute: { before: '  ', after: '  ' },</span>
    <span class="s4">operator: { after: '  ' },</span>
    <span class="s4">value: { after: ' ' },</span>
    <span class="s4">insensitive: { after: ' ' }</span>
  <span class="s4">},</span>
  <span class="s4">raws: {</span>
    <span class="s4">spaces: {</span>
      <span class="s4">attribute: { before: ' /*before*/ ', after: ' /* after-attr */ ' },</span>
      <span class="s4">operator: { after: ' /* after-operator */ ' },</span>
      <span class="s4">value: { after: '/* wow */ /*omg*/' },</span>
      <span class="s4">insensitive: { after: '/*bbq*/ /*whodoesthis*/' }</span>
    <span class="s4">},</span>
    <span class="s4">unquoted: 'test',</span>
    <span class="s4">value: 'te/*inside-value*/st'</span>
  <span class="s4">}</span>
<span class="s4">}</span>
<span class="s0">```</span>

<span class="s0">## </span><span class="s2">`Processor`</span>

<span class="s0">### </span><span class="s2">`ProcessorOptions`</span>

<span class="s0">* </span><span class="s2">`lossless` - When `true`, whitespace is preserved. Defaults to `true`.</span>
<span class="s0">* </span><span class="s2">`updateSelector` - When `true`, if any processor methods are passed a postcss</span>
  <span class="s2">`Rule` node instead of a string, then that Rule's selector is updated</span>
  <span class="s2">with the results of the processing. Defaults to `true`.</span>

<span class="s0">### </span><span class="s2">`process|processSync</span><span class="s1">(</span><span class="s2">selectors, </span><span class="s1">[</span><span class="s2">options</span><span class="s1">])</span><span class="s2">`</span>

<span class="s2">Processes the `selectors`, returning a string from the result of processing.</span>

<span class="s2">Note</span><span class="s1">: </span><span class="s2">when the `updateSelector` option is set, the rule's selector</span>
<span class="s2">will be updated with the resulting string.</span>

<span class="s1">**</span><span class="s2">Example</span><span class="s1">:**</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">const parser = require(&quot;postcss-selector-parser&quot;);</span>
<span class="s4">const processor = parser();</span>

<span class="s4">let result = processor.processSync(' .class');</span>
<span class="s4">console.log(result);</span>
<span class="s4">// =&gt;  .class</span>

<span class="s4">// Asynchronous operation</span>
<span class="s4">let promise = processor.process(' .class').then(result =&gt; {</span>
    <span class="s4">console.log(result)</span>
    <span class="s4">// =&gt; .class</span>
<span class="s4">});</span>

<span class="s4">// To have the parser normalize whitespace values, utilize the options</span>
<span class="s4">result = processor.processSync('  .class  ', {lossless: false});</span>
<span class="s4">console.log(result);</span>
<span class="s4">// =&gt; .class</span>

<span class="s4">// For better syntax errors, pass a PostCSS Rule node.</span>
<span class="s4">const postcss = require('postcss');</span>
<span class="s4">rule = postcss.rule({selector: ' #foo    &gt; a,  .class  '});</span>
<span class="s4">processor.process(rule, {lossless: false, updateSelector: true}).then(result =&gt; {</span>
    <span class="s4">console.log(result);</span>
    <span class="s4">// =&gt; #foo&gt;a,.class</span>
    <span class="s4">console.log(&quot;rule:&quot;, rule.selector);</span>
    <span class="s4">// =&gt; rule: #foo&gt;a,.class</span>
<span class="s4">})</span>
<span class="s0">```</span>

<span class="s2">Arguments</span><span class="s1">:</span>

<span class="s0">* </span><span class="s2">`selectors </span><span class="s1">(</span><span class="s2">string|postcss.Rule</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">Either a selector string or a PostCSS Rule</span>
  <span class="s2">node.</span>
<span class="s0">* </span><span class="s2">`</span><span class="s1">[</span><span class="s2">options</span><span class="s1">] (</span><span class="s2">object</span><span class="s1">)</span><span class="s2">`</span><span class="s1">: </span><span class="s2">Process options</span>


<span class="s0">### </span><span class="s2">`ast|astSync</span><span class="s1">(</span><span class="s2">selectors, </span><span class="s1">[</span><span class="s2">options</span><span class="s1">])</span><span class="s2">`</span>

<span class="s2">Like `process</span><span class="s1">()</span><span class="s2">` and `processSync</span><span class="s1">()</span><span class="s2">` but after</span>
<span class="s2">processing the `selectors` these methods return the `Root` node of the result</span>
<span class="s2">instead of a string.</span>

<span class="s2">Note</span><span class="s1">: </span><span class="s2">when the `updateSelector` option is set, the rule's selector</span>
<span class="s2">will be updated with the resulting string.</span>

<span class="s0">### </span><span class="s2">`transform|transformSync</span><span class="s1">(</span><span class="s2">selectors, </span><span class="s1">[</span><span class="s2">options</span><span class="s1">])</span><span class="s2">`</span>

<span class="s2">Like `process</span><span class="s1">()</span><span class="s2">` and `processSync</span><span class="s1">()</span><span class="s2">` but after</span>
<span class="s2">processing the `selectors` these methods return the value returned by the</span>
<span class="s2">processor callback.</span>

<span class="s2">Note</span><span class="s1">: </span><span class="s2">when the `updateSelector` option is set, the rule's selector</span>
<span class="s2">will be updated with the resulting string.</span>

<span class="s0">### </span><span class="s2">Error Handling Within Selector Processors</span>

<span class="s2">The root node passed to the selector processor callback</span>
<span class="s2">has a method `error</span><span class="s1">(</span><span class="s2">message, options</span><span class="s1">)</span><span class="s2">` that returns an</span>
<span class="s2">error object. This method should always be used to raise</span>
<span class="s2">errors relating to the syntax of selectors. The options</span>
<span class="s2">to this method are passed to postcss's error constructor</span>
<span class="s1">([</span><span class="s2">documentation</span><span class="s1">](</span><span class="s5">http://api.postcss.org/Container.html#error</span><span class="s1">))</span><span class="s2">.</span>

<span class="s0">#### </span><span class="s2">Async Error Example</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">let processor = (root) =&gt; {</span>
    <span class="s4">return new Promise((resolve, reject) =&gt; {</span>
        <span class="s4">root.walkClasses((classNode) =&gt; {</span>
            <span class="s4">if (/^(.*)[-_]/.test(classNode.value)) {</span>
                <span class="s4">let msg = &quot;classes may not have underscores or dashes in them&quot;;</span>
                <span class="s4">reject(root.error(msg, {</span>
                    <span class="s4">index: classNode.sourceIndex + RegExp.$1.length + 1,</span>
                    <span class="s4">word: classNode.value</span>
                <span class="s4">}));</span>
            <span class="s4">}</span>
        <span class="s4">});</span>
        <span class="s4">resolve();</span>
    <span class="s4">});</span>
<span class="s4">};</span>

<span class="s4">const postcss = require(&quot;postcss&quot;);</span>
<span class="s4">const parser = require(&quot;postcss-selector-parser&quot;);</span>
<span class="s4">const selectorProcessor = parser(processor);</span>
<span class="s4">const plugin = postcss.plugin('classValidator', (options) =&gt; {</span>
    <span class="s4">return (root) =&gt; {</span>
        <span class="s4">let promises = [];</span>
        <span class="s4">root.walkRules(rule =&gt; {</span>
            <span class="s4">promises.push(selectorProcessor.process(rule));</span>
        <span class="s4">});</span>
        <span class="s4">return Promise.all(promises);</span>
    <span class="s4">};</span>
<span class="s4">});</span>
<span class="s4">postcss(plugin()).process(`</span>
<span class="s4">.foo-bar {</span>
  <span class="s4">color: red;</span>
<span class="s4">}</span>
<span class="s4">`.trim(), {from: 'test.css'}).catch((e) =&gt; console.error(e.toString()));</span>

<span class="s4">// CssSyntaxError: classValidator: ./test.css:1:5: classes may not have underscores or dashes in them</span>
<span class="s4">//</span>
<span class="s4">// &gt; 1 | .foo-bar {</span>
<span class="s4">//     |     ^</span>
<span class="s4">//   2 |   color: red;</span>
<span class="s4">//   3 | }</span>
<span class="s0">```</span>

<span class="s0">#### </span><span class="s2">Synchronous Error Example</span>

<span class="s0">```</span><span class="s3">js</span>
<span class="s4">let processor = (root) =&gt; {</span>
    <span class="s4">root.walkClasses((classNode) =&gt; {</span>
        <span class="s4">if (/.*[-_]/.test(classNode.value)) {</span>
            <span class="s4">let msg = &quot;classes may not have underscores or dashes in them&quot;;</span>
            <span class="s4">throw root.error(msg, {</span>
                <span class="s4">index: classNode.sourceIndex,</span>
                <span class="s4">word: classNode.value</span>
            <span class="s4">});</span>
        <span class="s4">}</span>
    <span class="s4">});</span>
<span class="s4">};</span>

<span class="s4">const postcss = require(&quot;postcss&quot;);</span>
<span class="s4">const parser = require(&quot;postcss-selector-parser&quot;);</span>
<span class="s4">const selectorProcessor = parser(processor);</span>
<span class="s4">const plugin = postcss.plugin('classValidator', (options) =&gt; {</span>
    <span class="s4">return (root) =&gt; {</span>
        <span class="s4">root.walkRules(rule =&gt; {</span>
            <span class="s4">selectorProcessor.processSync(rule);</span>
        <span class="s4">});</span>
    <span class="s4">};</span>
<span class="s4">});</span>
<span class="s4">postcss(plugin()).process(`</span>
<span class="s4">.foo-bar {</span>
  <span class="s4">color: red;</span>
<span class="s4">}</span>
<span class="s4">`.trim(), {from: 'test.css'}).catch((e) =&gt; console.error(e.toString()));</span>

<span class="s4">// CssSyntaxError: classValidator: ./test.css:1:5: classes may not have underscores or dashes in them</span>
<span class="s4">//</span>
<span class="s4">// &gt; 1 | .foo-bar {</span>
<span class="s4">//     |     ^</span>
<span class="s4">//   2 |   color: red;</span>
<span class="s4">//   3 | }</span>
<span class="s0">```</span>
</pre>
</body>
</html>