<html>
<head>
<title>ChunkGraph.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #bcbec4;}
.s4 { color: #cf8e6d;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #67a37c; font-style: italic;}
.s7 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ChunkGraph.js</font>
</center></td></tr></table>
<pre><span class="s0">/* 
    MIT License http://www.opensource.org/licenses/mit-license.php 
    Author Tobias Koppers @sokra 
*/</span>

<span class="s2">&quot;use strict&quot;</span><span class="s3">;</span>

<span class="s4">const </span><span class="s1">util </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;util&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">Entrypoint </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./Entrypoint&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">ModuleGraphConnection </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./ModuleGraphConnection&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">first </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/SetHelpers&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">SortableSet </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/SortableSet&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{</span>
	<span class="s1">compareModulesById</span><span class="s3">,</span>
	<span class="s1">compareIterables</span><span class="s3">,</span>
	<span class="s1">compareModulesByIdentifier</span><span class="s3">,</span>
	<span class="s1">concatComparators</span><span class="s3">,</span>
	<span class="s1">compareSelect</span><span class="s3">,</span>
	<span class="s1">compareIds</span>
<span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/comparators&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">createHash </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/createHash&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">findGraphRoots </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/findGraphRoots&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{</span>
	<span class="s1">RuntimeSpecMap</span><span class="s3">,</span>
	<span class="s1">RuntimeSpecSet</span><span class="s3">,</span>
	<span class="s1">runtimeToString</span><span class="s3">,</span>
	<span class="s1">mergeRuntime</span><span class="s3">,</span>
	<span class="s1">forEachRuntime</span>
<span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;./util/runtime&quot;</span><span class="s3">);</span>

<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./AsyncDependenciesBlock&quot;)} AsyncDependenciesBlock */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./Chunk&quot;)} Chunk */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./ChunkGroup&quot;)} ChunkGroup */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./Module&quot;)} Module */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./ModuleGraph&quot;)} ModuleGraph */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./RuntimeModule&quot;)} RuntimeModule */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{typeof import(&quot;./util/Hash&quot;)} Hash */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;./util/runtime&quot;).RuntimeSpec} RuntimeSpec */</span>

<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ReadonlySet&lt;string&gt;} */</span>
<span class="s4">const </span><span class="s1">EMPTY_SET </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>

<span class="s4">const </span><span class="s1">ZERO_BIG_INT </span><span class="s3">= </span><span class="s1">BigInt</span><span class="s3">(</span><span class="s7">0</span><span class="s3">);</span>

<span class="s4">const </span><span class="s1">compareModuleIterables </span><span class="s3">= </span><span class="s1">compareIterables</span><span class="s3">(</span><span class="s1">compareModulesByIdentifier</span><span class="s3">);</span>

<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{(c: Chunk, chunkGraph: ChunkGraph) =&gt; boolean} ChunkFilterPredicate */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{(m: Module) =&gt; boolean} ModuleFilterPredicate */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{[Module, Entrypoint | undefined]} EntryModuleWithChunkGroup */</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} ChunkSizeOptions</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number=} chunkOverhead constant overhead for a chunk</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number=} entryChunkMultiplicator multiplicator for initial chunks</span>
 <span class="s5">*/</span>

<span class="s4">class </span><span class="s1">ModuleHashInfo </span><span class="s3">{</span>
	<span class="s1">constructor</span><span class="s3">(</span><span class="s1">hash</span><span class="s3">, </span><span class="s1">renderedHash</span><span class="s3">) {</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">hash </span><span class="s3">= </span><span class="s1">hash</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">renderedHash </span><span class="s3">= </span><span class="s1">renderedHash</span><span class="s3">;</span>
	<span class="s3">}</span>
<span class="s3">}</span>

<span class="s5">/** </span><span class="s6">@template </span><span class="s5">T @typedef {(set: SortableSet&lt;T&gt;) =&gt; T[]} SetToArrayFunction&lt;T&gt; */</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@template </span><span class="s5">T</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{SortableSet&lt;T&gt;} set the set</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{T[]} set as array</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">getArray </span><span class="s3">= </span><span class="s1">set </span><span class="s3">=&gt; {</span>
	<span class="s4">return </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s1">set</span><span class="s3">);</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{SortableSet&lt;Chunk&gt;} chunks the chunks</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{RuntimeSpecSet} runtimes</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">getModuleRuntimes </span><span class="s3">= </span><span class="s1">chunks </span><span class="s3">=&gt; {</span>
	<span class="s4">const </span><span class="s1">runtimes </span><span class="s3">= </span><span class="s4">new </span><span class="s1">RuntimeSpecSet</span><span class="s3">();</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of chunks</span><span class="s3">) {</span>
		<span class="s1">runtimes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">runtime</span><span class="s3">);</span>
	<span class="s3">}</span>
	<span class="s4">return </span><span class="s1">runtimes</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{WeakMap&lt;Module, Set&lt;string&gt;&gt; | undefined} sourceTypesByModule sourceTypesByModule</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{function (SortableSet&lt;Module&gt;): Map&lt;string, SortableSet&lt;Module&gt;&gt;} modules by source type</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">modulesBySourceType </span><span class="s3">= </span><span class="s1">sourceTypesByModule </span><span class="s3">=&gt; </span><span class="s1">set </span><span class="s3">=&gt; {</span>
	<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, SortableSet&lt;Module&gt;&gt;} */</span>
	<span class="s4">const </span><span class="s1">map </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of set</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">sourceTypes </span><span class="s3">=</span>
			<span class="s3">(</span><span class="s1">sourceTypesByModule </span><span class="s3">&amp;&amp; </span><span class="s1">sourceTypesByModule</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) ||</span>
			<span class="s1">module</span><span class="s3">.</span><span class="s1">getSourceTypes</span><span class="s3">();</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">sourceType of sourceTypes</span><span class="s3">) {</span>
			<span class="s4">let </span><span class="s1">innerSet </span><span class="s3">= </span><span class="s1">map</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">sourceType</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">innerSet </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s1">innerSet </span><span class="s3">= </span><span class="s4">new </span><span class="s1">SortableSet</span><span class="s3">();</span>
				<span class="s1">map</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">sourceType</span><span class="s3">, </span><span class="s1">innerSet</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s1">innerSet</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">}</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span><span class="s1">key</span><span class="s3">, </span><span class="s1">innerSet</span><span class="s3">] </span><span class="s1">of map</span><span class="s3">) {</span>
		<span class="s0">// When all modules have the source type, we reuse the original SortableSet</span>
		<span class="s0">// to benefit from the shared cache (especially for sorting)</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">innerSet</span><span class="s3">.</span><span class="s1">size </span><span class="s3">=== </span><span class="s1">set</span><span class="s3">.</span><span class="s1">size</span><span class="s3">) {</span>
			<span class="s1">map</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">set</span><span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">}</span>
	<span class="s4">return </span><span class="s1">map</span><span class="s3">;</span>
<span class="s3">};</span>
<span class="s4">const </span><span class="s1">defaultModulesBySourceType </span><span class="s3">= </span><span class="s1">modulesBySourceType</span><span class="s3">(</span><span class="s1">undefined</span><span class="s3">);</span>

<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WeakMap&lt;Function, any&gt;} */</span>
<span class="s4">const </span><span class="s1">createOrderedArrayFunctionMap </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@template </span><span class="s5">T</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{function(T, T): -1|0|1} comparator comparator function</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{SetToArrayFunction&lt;T&gt;} set as ordered array</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">createOrderedArrayFunction </span><span class="s3">= </span><span class="s1">comparator </span><span class="s3">=&gt; {</span>
	<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SetToArrayFunction&lt;T&gt;} */</span>
	<span class="s4">let </span><span class="s1">fn </span><span class="s3">= </span><span class="s1">createOrderedArrayFunctionMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">comparator</span><span class="s3">);</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">fn </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">return </span><span class="s1">fn</span><span class="s3">;</span>
	<span class="s1">fn </span><span class="s3">= </span><span class="s1">set </span><span class="s3">=&gt; {</span>
		<span class="s1">set</span><span class="s3">.</span><span class="s1">sortWith</span><span class="s3">(</span><span class="s1">comparator</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s1">set</span><span class="s3">);</span>
	<span class="s3">};</span>
	<span class="s1">createOrderedArrayFunctionMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">comparator</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">);</span>
	<span class="s4">return </span><span class="s1">fn</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Iterable&lt;Module&gt;} modules the modules to get the count/size of</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number} the size of the modules</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">getModulesSize </span><span class="s3">= </span><span class="s1">modules </span><span class="s3">=&gt; {</span>
	<span class="s4">let </span><span class="s1">size </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of modules</span><span class="s3">) {</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">type of module</span><span class="s3">.</span><span class="s1">getSourceTypes</span><span class="s3">()) {</span>
			<span class="s1">size </span><span class="s3">+= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">size</span><span class="s3">(</span><span class="s1">type</span><span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">}</span>
	<span class="s4">return </span><span class="s1">size</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Iterable&lt;Module&gt;} modules the sortable Set to get the size of</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Record&lt;string, number&gt;} the sizes of the modules</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">getModulesSizes </span><span class="s3">= </span><span class="s1">modules </span><span class="s3">=&gt; {</span>
	<span class="s4">let </span><span class="s1">sizes </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s4">null</span><span class="s3">);</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of modules</span><span class="s3">) {</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">type of module</span><span class="s3">.</span><span class="s1">getSourceTypes</span><span class="s3">()) {</span>
			<span class="s1">sizes</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] = (</span><span class="s1">sizes</span><span class="s3">[</span><span class="s1">type</span><span class="s3">] || </span><span class="s7">0</span><span class="s3">) + </span><span class="s1">module</span><span class="s3">.</span><span class="s1">size</span><span class="s3">(</span><span class="s1">type</span><span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">}</span>
	<span class="s4">return </span><span class="s1">sizes</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} a chunk</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} b chunk</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true, if a is always a parent of b</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">isAvailableChunk </span><span class="s3">= (</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">) =&gt; {</span>
	<span class="s4">const </span><span class="s1">queue </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">groupsIterable</span><span class="s3">);</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunkGroup of queue</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">isInGroup</span><span class="s3">(</span><span class="s1">chunkGroup</span><span class="s3">)) </span><span class="s4">continue</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">chunkGroup</span><span class="s3">.</span><span class="s1">isInitial</span><span class="s3">()) </span><span class="s4">return false</span><span class="s3">;</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">parent of chunkGroup</span><span class="s3">.</span><span class="s1">parentsIterable</span><span class="s3">) {</span>
			<span class="s1">queue</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">}</span>
	<span class="s4">return true</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s4">class </span><span class="s1">ChunkGraphModule </span><span class="s3">{</span>
	<span class="s1">constructor</span><span class="s3">() {</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SortableSet&lt;Chunk&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">chunks </span><span class="s3">= </span><span class="s4">new </span><span class="s1">SortableSet</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;Chunk&gt; | undefined} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">entryInChunks </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;Chunk&gt; | undefined} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">runtimeInChunks </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{RuntimeSpecMap&lt;ModuleHashInfo&gt; | undefined} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">hashes </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string | number} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">id </span><span class="s3">= </span><span class="s4">null</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{RuntimeSpecMap&lt;Set&lt;string&gt;&gt; | undefined} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">runtimeRequirements </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{RuntimeSpecMap&lt;string&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">graphHashes </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{RuntimeSpecMap&lt;string&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">graphHashesWithConnections </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
	<span class="s3">}</span>
<span class="s3">}</span>

<span class="s4">class </span><span class="s1">ChunkGraphChunk </span><span class="s3">{</span>
	<span class="s1">constructor</span><span class="s3">() {</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SortableSet&lt;Module&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">modules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">SortableSet</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WeakMap&lt;Module, Set&lt;string&gt;&gt; | undefined} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">sourceTypesByModule </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;Module, Entrypoint&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">entryModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{SortableSet&lt;RuntimeModule&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">runtimeModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">SortableSet</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;RuntimeModule&gt; | undefined} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">fullHashModules </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;RuntimeModule&gt; | undefined} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">dependentHashModules </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;string&gt; | undefined} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">runtimeRequirements </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;string&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">runtimeRequirementsInTree </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">_modulesBySourceType </span><span class="s3">= </span><span class="s1">defaultModulesBySourceType</span><span class="s3">;</span>
	<span class="s3">}</span>
<span class="s3">}</span>

<span class="s4">class </span><span class="s1">ChunkGraph </span><span class="s3">{</span>
	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleGraph} moduleGraph the module graph</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string | Hash} hashFunction the hash function to use</span>
	 <span class="s5">*/</span>
	<span class="s1">constructor</span><span class="s3">(</span><span class="s1">moduleGraph</span><span class="s3">, </span><span class="s1">hashFunction </span><span class="s3">= </span><span class="s2">&quot;md4&quot;</span><span class="s3">) {</span>
		<span class="s5">/** </span><span class="s6">@private </span><span class="s5">@type {WeakMap&lt;Module, ChunkGraphModule&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_modules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@private </span><span class="s5">@type {WeakMap&lt;Chunk, ChunkGraphChunk&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_chunks </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@private </span><span class="s5">@type {WeakMap&lt;AsyncDependenciesBlock, ChunkGroup&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_blockChunkGroups </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@private </span><span class="s5">@type {Map&lt;string, string | number&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_runtimeIds </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ModuleGraph} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph </span><span class="s3">= </span><span class="s1">moduleGraph</span><span class="s3">;</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">_hashFunction </span><span class="s3">= </span><span class="s1">hashFunction</span><span class="s3">;</span>

		<span class="s4">this</span><span class="s3">.</span><span class="s1">_getGraphRoots </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getGraphRoots</span><span class="s3">.</span><span class="s1">bind</span><span class="s3">(</span><span class="s4">this</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@private</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ChunkGraphModule} internal module</span>
	 <span class="s5">*/</span>
	<span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">let </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_modules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgm </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s1">cgm </span><span class="s3">= </span><span class="s4">new </span><span class="s1">ChunkGraphModule</span><span class="s3">();</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">_modules</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">cgm</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">return </span><span class="s1">cgm</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@private</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ChunkGraphChunk} internal chunk</span>
	 <span class="s5">*/</span>
	<span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">let </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_chunks</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgc </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s1">cgc </span><span class="s3">= </span><span class="s4">new </span><span class="s1">ChunkGraphChunk</span><span class="s3">();</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">_chunks</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">cgc</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{SortableSet&lt;Module&gt;} set the sortable Set to get the roots of</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Module[]} the graph roots</span>
	 <span class="s5">*/</span>
	<span class="s1">_getGraphRoots</span><span class="s3">(</span><span class="s1">set</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s3">{ </span><span class="s1">moduleGraph </span><span class="s3">} = </span><span class="s4">this</span><span class="s3">;</span>
		<span class="s4">return </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span>
			<span class="s1">findGraphRoots</span><span class="s3">(</span><span class="s1">set</span><span class="s3">, </span><span class="s1">module </span><span class="s3">=&gt; {</span>
				<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;Module&gt;} */</span>
				<span class="s4">const </span><span class="s1">set </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
				<span class="s4">const </span><span class="s1">addDependencies </span><span class="s3">= </span><span class="s1">module </span><span class="s3">=&gt; {</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">connection of moduleGraph</span><span class="s3">.</span><span class="s1">getOutgoingConnections</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
						<span class="s4">if </span><span class="s3">(!</span><span class="s1">connection</span><span class="s3">.</span><span class="s1">module</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
						<span class="s4">const </span><span class="s1">activeState </span><span class="s3">= </span><span class="s1">connection</span><span class="s3">.</span><span class="s1">getActiveState</span><span class="s3">(</span><span class="s1">undefined</span><span class="s3">);</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">activeState </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">activeState </span><span class="s3">=== </span><span class="s1">ModuleGraphConnection</span><span class="s3">.</span><span class="s1">TRANSITIVE_ONLY</span><span class="s3">) {</span>
							<span class="s1">addDependencies</span><span class="s3">(</span><span class="s1">connection</span><span class="s3">.</span><span class="s1">module</span><span class="s3">);</span>
							<span class="s4">continue</span><span class="s3">;</span>
						<span class="s3">}</span>
						<span class="s1">set</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">connection</span><span class="s3">.</span><span class="s1">module</span><span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">};</span>
				<span class="s1">addDependencies</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
				<span class="s4">return </span><span class="s1">set</span><span class="s3">;</span>
			<span class="s3">})</span>
		<span class="s3">).</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">compareModulesByIdentifier</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the new chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">connectChunkAndModule</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s1">cgm</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">disconnectChunkAndModule</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s0">// No need to invalidate cgc._modulesBySourceType because we modified cgc.modules anyway</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">sourceTypesByModule</span><span class="s3">) </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">sourceTypesByModule</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s1">cgm</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk which will be disconnected</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">disconnectChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s1">cgm</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
		<span class="s1">chunk</span><span class="s3">.</span><span class="s1">disconnectFromGroups</span><span class="s3">();</span>
		<span class="s1">ChunkGraph</span><span class="s3">.</span><span class="s1">clearChunkGraphForChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Iterable&lt;Module&gt;} modules the modules</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">attachModules</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">modules</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of modules</span><span class="s3">) {</span>
			<span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Iterable&lt;RuntimeModule&gt;} modules the runtime modules</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">attachRuntimeModules</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">modules</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of modules</span><span class="s3">) {</span>
			<span class="s1">cgc</span><span class="s3">.</span><span class="s1">runtimeModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Iterable&lt;RuntimeModule&gt;} modules the modules that require a full hash</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">attachFullHashModules</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">modules</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">fullHashModules </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">fullHashModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of modules</span><span class="s3">) {</span>
			<span class="s1">cgc</span><span class="s3">.</span><span class="s1">fullHashModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Iterable&lt;RuntimeModule&gt;} modules the modules that require a full hash</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">attachDependentHashModules</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">modules</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">dependentHashModules </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">)</span>
			<span class="s1">cgc</span><span class="s3">.</span><span class="s1">dependentHashModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of modules</span><span class="s3">) {</span>
			<span class="s1">cgc</span><span class="s3">.</span><span class="s1">dependentHashModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} oldModule the replaced module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} newModule the replacing module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">replaceModule</span><span class="s3">(</span><span class="s1">oldModule</span><span class="s3">, </span><span class="s1">newModule</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">oldCgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">oldModule</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">newCgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">newModule</span><span class="s3">);</span>

		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of oldCgm</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
			<span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">oldModule</span><span class="s3">);</span>
			<span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">newModule</span><span class="s3">);</span>
			<span class="s1">newCgm</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s1">oldCgm</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>

		<span class="s4">if </span><span class="s3">(</span><span class="s1">oldCgm</span><span class="s3">.</span><span class="s1">entryInChunks </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">newCgm</span><span class="s3">.</span><span class="s1">entryInChunks </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s1">newCgm</span><span class="s3">.</span><span class="s1">entryInChunks </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
			<span class="s3">}</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of oldCgm</span><span class="s3">.</span><span class="s1">entryInChunks</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
				<span class="s4">const </span><span class="s1">old </span><span class="s3">= </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">entryModules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">oldModule</span><span class="s3">);</span>
				<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;Module, Entrypoint&gt;} */</span>
				<span class="s4">const </span><span class="s1">newEntryModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span><span class="s1">m</span><span class="s3">, </span><span class="s1">cg</span><span class="s3">] </span><span class="s1">of cgc</span><span class="s3">.</span><span class="s1">entryModules</span><span class="s3">) {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">m </span><span class="s3">=== </span><span class="s1">oldModule</span><span class="s3">) {</span>
						<span class="s1">newEntryModules</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">newModule</span><span class="s3">, </span><span class="s1">old</span><span class="s3">);</span>
					<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
						<span class="s1">newEntryModules</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">cg</span><span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
				<span class="s1">cgc</span><span class="s3">.</span><span class="s1">entryModules </span><span class="s3">= </span><span class="s1">newEntryModules</span><span class="s3">;</span>
				<span class="s1">newCgm</span><span class="s3">.</span><span class="s1">entryInChunks</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s1">oldCgm</span><span class="s3">.</span><span class="s1">entryInChunks </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s3">}</span>

		<span class="s4">if </span><span class="s3">(</span><span class="s1">oldCgm</span><span class="s3">.</span><span class="s1">runtimeInChunks </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">newCgm</span><span class="s3">.</span><span class="s1">runtimeInChunks </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s1">newCgm</span><span class="s3">.</span><span class="s1">runtimeInChunks </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
			<span class="s3">}</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of oldCgm</span><span class="s3">.</span><span class="s1">runtimeInChunks</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
				<span class="s1">cgc</span><span class="s3">.</span><span class="s1">runtimeModules</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{RuntimeModule} */ </span><span class="s3">(</span><span class="s1">oldModule</span><span class="s3">));</span>
				<span class="s1">cgc</span><span class="s3">.</span><span class="s1">runtimeModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{RuntimeModule} */ </span><span class="s3">(</span><span class="s1">newModule</span><span class="s3">));</span>
				<span class="s1">newCgm</span><span class="s3">.</span><span class="s1">runtimeInChunks</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span>
					<span class="s1">cgc</span><span class="s3">.</span><span class="s1">fullHashModules </span><span class="s3">!== </span><span class="s1">undefined </span><span class="s3">&amp;&amp;</span>
					<span class="s1">cgc</span><span class="s3">.</span><span class="s1">fullHashModules</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{RuntimeModule} */ </span><span class="s3">(</span><span class="s1">oldModule</span><span class="s3">))</span>
				<span class="s3">) {</span>
					<span class="s1">cgc</span><span class="s3">.</span><span class="s1">fullHashModules</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{RuntimeModule} */ </span><span class="s3">(</span><span class="s1">oldModule</span><span class="s3">));</span>
					<span class="s1">cgc</span><span class="s3">.</span><span class="s1">fullHashModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{RuntimeModule} */ </span><span class="s3">(</span><span class="s1">newModule</span><span class="s3">));</span>
				<span class="s3">}</span>
				<span class="s4">if </span><span class="s3">(</span>
					<span class="s1">cgc</span><span class="s3">.</span><span class="s1">dependentHashModules </span><span class="s3">!== </span><span class="s1">undefined </span><span class="s3">&amp;&amp;</span>
					<span class="s1">cgc</span><span class="s3">.</span><span class="s1">dependentHashModules</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{RuntimeModule} */ </span><span class="s3">(</span><span class="s1">oldModule</span><span class="s3">))</span>
				<span class="s3">) {</span>
					<span class="s1">cgc</span><span class="s3">.</span><span class="s1">dependentHashModules</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{RuntimeModule} */ </span><span class="s3">(</span><span class="s1">oldModule</span><span class="s3">)</span>
					<span class="s3">);</span>
					<span class="s1">cgc</span><span class="s3">.</span><span class="s1">dependentHashModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{RuntimeModule} */ </span><span class="s3">(</span><span class="s1">newModule</span><span class="s3">)</span>
					<span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
			<span class="s1">oldCgm</span><span class="s3">.</span><span class="s1">runtimeInChunks </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the checked module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the checked chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true, if the chunk contains the module</span>
	 <span class="s5">*/</span>
	<span class="s1">isModuleInChunk</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the checked module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunkGroup} chunkGroup the checked chunk group</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true, if the chunk contains the module</span>
	 <span class="s5">*/</span>
	<span class="s1">isModuleInChunkGroup</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">chunkGroup</span><span class="s3">) {</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of chunkGroup</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">isModuleInChunk</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">)) </span><span class="s4">return true</span><span class="s3">;</span>
		<span class="s3">}</span>
		<span class="s4">return false</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the checked module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true, if the module is entry of any chunk</span>
	 <span class="s5">*/</span>
	<span class="s1">isEntryModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">entryInChunks </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Iterable&lt;Chunk&gt;} iterable of chunks (do not modify)</span>
	 <span class="s5">*/</span>
	<span class="s1">getModuleChunksIterable</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{function(Chunk, Chunk): -1|0|1} sortFn sort function</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Iterable&lt;Chunk&gt;} iterable of chunks (do not modify)</span>
	 <span class="s5">*/</span>
	<span class="s1">getOrderedModuleChunksIterable</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">sortFn</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s1">cgm</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">sortWith</span><span class="s3">(</span><span class="s1">sortFn</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Chunk[]} array of chunks (cached, do not modify)</span>
	 <span class="s5">*/</span>
	<span class="s1">getModuleChunks</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">getFromCache</span><span class="s3">(</span><span class="s1">getArray</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number} the number of chunk which contain the module</span>
	 <span class="s5">*/</span>
	<span class="s1">getNumberOfModuleChunks</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">size</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{RuntimeSpecSet} runtimes</span>
	 <span class="s5">*/</span>
	<span class="s1">getModuleRuntimes</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">.</span><span class="s1">getFromUnorderedCache</span><span class="s3">(</span><span class="s1">getModuleRuntimes</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number} the number of modules which are contained in this chunk</span>
	 <span class="s5">*/</span>
	<span class="s1">getNumberOfChunkModules</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number} the number of full hash modules which are contained in this chunk</span>
	 <span class="s5">*/</span>
	<span class="s1">getNumberOfChunkFullHashModules</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">fullHashModules </span><span class="s3">=== </span><span class="s1">undefined </span><span class="s3">? </span><span class="s7">0 </span><span class="s3">: </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">fullHashModules</span><span class="s3">.</span><span class="s1">size</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Iterable&lt;Module&gt;} return the modules for this chunk</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkModulesIterable</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} sourceType source type</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Iterable&lt;Module&gt; | undefined} return the modules for this chunk</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkModulesIterableBySourceType</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">sourceType</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">modulesWithSourceType </span><span class="s3">= </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span>
			<span class="s3">.</span><span class="s1">getFromUnorderedCache</span><span class="s3">(</span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">_modulesBySourceType</span><span class="s3">)</span>
			<span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">sourceType</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">modulesWithSourceType</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module chunk module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Set&lt;string&gt;} sourceTypes source types</span>
	 <span class="s5">*/</span>
	<span class="s1">setChunkModuleSourceTypes</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">sourceTypes</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">sourceTypesByModule </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s1">cgc</span><span class="s3">.</span><span class="s1">sourceTypesByModule </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>
		<span class="s3">}</span>
		<span class="s1">cgc</span><span class="s3">.</span><span class="s1">sourceTypesByModule</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">sourceTypes</span><span class="s3">);</span>
		<span class="s0">// Update cgc._modulesBySourceType to invalidate the cache</span>
		<span class="s1">cgc</span><span class="s3">.</span><span class="s1">_modulesBySourceType </span><span class="s3">= </span><span class="s1">modulesBySourceType</span><span class="s3">(</span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">sourceTypesByModule</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module chunk module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Set&lt;string&gt;} source types</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkModuleSourceTypes</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">sourceTypesByModule </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s4">return </span><span class="s1">module</span><span class="s3">.</span><span class="s1">getSourceTypes</span><span class="s3">();</span>
		<span class="s3">}</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">sourceTypesByModule</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) || </span><span class="s1">module</span><span class="s3">.</span><span class="s1">getSourceTypes</span><span class="s3">();</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Set&lt;string&gt;} source types</span>
	 <span class="s5">*/</span>
	<span class="s1">getModuleSourceTypes</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">return </span><span class="s3">(</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">_getOverwrittenModuleSourceTypes</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) || </span><span class="s1">module</span><span class="s3">.</span><span class="s1">getSourceTypes</span><span class="s3">()</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Set&lt;string&gt; | undefined} source types</span>
	 <span class="s5">*/</span>
	<span class="s1">_getOverwrittenModuleSourceTypes</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">let </span><span class="s1">newSet </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
		<span class="s4">let </span><span class="s1">sourceTypes</span><span class="s3">;</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">getModuleChunksIterable</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
			<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">sourceTypesByModule </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
			<span class="s4">const </span><span class="s1">st </span><span class="s3">= </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">sourceTypesByModule</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">st </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
			<span class="s4">if </span><span class="s3">(!</span><span class="s1">sourceTypes</span><span class="s3">) {</span>
				<span class="s1">sourceTypes </span><span class="s3">= </span><span class="s1">st</span><span class="s3">;</span>
				<span class="s4">continue</span><span class="s3">;</span>
			<span class="s3">} </span><span class="s4">else if </span><span class="s3">(!</span><span class="s1">newSet</span><span class="s3">) {</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">type of st</span><span class="s3">) {</span>
					<span class="s4">if </span><span class="s3">(!</span><span class="s1">newSet</span><span class="s3">) {</span>
						<span class="s4">if </span><span class="s3">(!</span><span class="s1">sourceTypes</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">type</span><span class="s3">)) {</span>
							<span class="s1">newSet </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
							<span class="s1">sourceTypes </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">sourceTypes</span><span class="s3">);</span>
							<span class="s1">sourceTypes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">type</span><span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
						<span class="s1">sourceTypes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">type</span><span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
			<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">type of st</span><span class="s3">) </span><span class="s1">sourceTypes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">type</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">return </span><span class="s1">sourceTypes</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{function(Module, Module): -1|0|1} comparator comparator function</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Iterable&lt;Module&gt;} return the modules for this chunk</span>
	 <span class="s5">*/</span>
	<span class="s1">getOrderedChunkModulesIterable</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">comparator</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">sortWith</span><span class="s3">(</span><span class="s1">comparator</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} sourceType source type</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{function(Module, Module): -1|0|1} comparator comparator function</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Iterable&lt;Module&gt; | undefined} return the modules for this chunk</span>
	 <span class="s5">*/</span>
	<span class="s1">getOrderedChunkModulesIterableBySourceType</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">sourceType</span><span class="s3">, </span><span class="s1">comparator</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">modulesWithSourceType </span><span class="s3">= </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span>
			<span class="s3">.</span><span class="s1">getFromUnorderedCache</span><span class="s3">(</span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">_modulesBySourceType</span><span class="s3">)</span>
			<span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">sourceType</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">modulesWithSourceType </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">return </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s1">modulesWithSourceType</span><span class="s3">.</span><span class="s1">sortWith</span><span class="s3">(</span><span class="s1">comparator</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">modulesWithSourceType</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Module[]} return the modules for this chunk (cached, do not modify)</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkModules</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">getFromUnorderedCache</span><span class="s3">(</span><span class="s1">getArray</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{function(Module, Module): -1|0|1} comparator comparator function</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Module[]} return the modules for this chunk (cached, do not modify)</span>
	 <span class="s5">*/</span>
	<span class="s1">getOrderedChunkModules</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">comparator</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">arrayFunction </span><span class="s3">= </span><span class="s1">createOrderedArrayFunction</span><span class="s3">(</span><span class="s1">comparator</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">getFromUnorderedCache</span><span class="s3">(</span><span class="s1">arrayFunction</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleFilterPredicate} filterFn function used to filter modules</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{boolean} includeAllChunks all chunks or only async chunks</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Record&lt;string|number, (string|number)[]&gt;} chunk to module ids object</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkModuleIdMap</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">filterFn</span><span class="s3">, </span><span class="s1">includeAllChunks </span><span class="s3">= </span><span class="s4">false</span><span class="s3">) {</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Record&lt;string|number, (string|number)[]&gt;} */</span>
		<span class="s4">const </span><span class="s1">chunkModuleIdMap </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s4">null</span><span class="s3">);</span>

		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">asyncChunk of includeAllChunks</span>
			<span class="s3">? </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">getAllReferencedChunks</span><span class="s3">()</span>
			<span class="s3">: </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">getAllAsyncChunks</span><span class="s3">()) {</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{(string|number)[]} */</span>
			<span class="s4">let </span><span class="s1">array</span><span class="s3">;</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">getOrderedChunkModulesIterable</span><span class="s3">(</span>
				<span class="s1">asyncChunk</span><span class="s3">,</span>
				<span class="s1">compareModulesById</span><span class="s3">(</span><span class="s4">this</span><span class="s3">)</span>
			<span class="s3">)) {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">filterFn</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">array </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
						<span class="s1">array </span><span class="s3">= [];</span>
						<span class="s1">chunkModuleIdMap</span><span class="s3">[</span><span class="s1">asyncChunk</span><span class="s3">.</span><span class="s1">id</span><span class="s3">] = </span><span class="s1">array</span><span class="s3">;</span>
					<span class="s3">}</span>
					<span class="s4">const </span><span class="s1">moduleId </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">getModuleId</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
					<span class="s1">array</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">moduleId</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">return </span><span class="s1">chunkModuleIdMap</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleFilterPredicate} filterFn function used to filter modules</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} hashLength length of the hash</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{boolean} includeAllChunks all chunks or only async chunks</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Record&lt;string|number, Record&lt;string|number, string&gt;&gt;} chunk to module id to module hash object</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkModuleRenderedHashMap</span><span class="s3">(</span>
		<span class="s1">chunk</span><span class="s3">,</span>
		<span class="s1">filterFn</span><span class="s3">,</span>
		<span class="s1">hashLength </span><span class="s3">= </span><span class="s7">0</span><span class="s3">,</span>
		<span class="s1">includeAllChunks </span><span class="s3">= </span><span class="s4">false</span>
	<span class="s3">) {</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Record&lt;string|number, Record&lt;string|number, string&gt;&gt;} */</span>
		<span class="s4">const </span><span class="s1">chunkModuleHashMap </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s4">null</span><span class="s3">);</span>

		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">asyncChunk of includeAllChunks</span>
			<span class="s3">? </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">getAllReferencedChunks</span><span class="s3">()</span>
			<span class="s3">: </span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">getAllAsyncChunks</span><span class="s3">()) {</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Record&lt;string|number, string&gt;} */</span>
			<span class="s4">let </span><span class="s1">idToHashMap</span><span class="s3">;</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">getOrderedChunkModulesIterable</span><span class="s3">(</span>
				<span class="s1">asyncChunk</span><span class="s3">,</span>
				<span class="s1">compareModulesById</span><span class="s3">(</span><span class="s4">this</span><span class="s3">)</span>
			<span class="s3">)) {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">filterFn</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">idToHashMap </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
						<span class="s1">idToHashMap </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s4">null</span><span class="s3">);</span>
						<span class="s1">chunkModuleHashMap</span><span class="s3">[</span><span class="s1">asyncChunk</span><span class="s3">.</span><span class="s1">id</span><span class="s3">] = </span><span class="s1">idToHashMap</span><span class="s3">;</span>
					<span class="s3">}</span>
					<span class="s4">const </span><span class="s1">moduleId </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">getModuleId</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
					<span class="s4">const </span><span class="s1">hash </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">getRenderedModuleHash</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">asyncChunk</span><span class="s3">.</span><span class="s1">runtime</span><span class="s3">);</span>
					<span class="s1">idToHashMap</span><span class="s3">[</span><span class="s1">moduleId</span><span class="s3">] = </span><span class="s1">hashLength </span><span class="s3">? </span><span class="s1">hash</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">0</span><span class="s3">, </span><span class="s1">hashLength</span><span class="s3">) : </span><span class="s1">hash</span><span class="s3">;</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">return </span><span class="s1">chunkModuleHashMap</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunkFilterPredicate} filterFn function used to filter chunks</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Record&lt;string|number, boolean&gt;} chunk map</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkConditionMap</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">filterFn</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">map </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s4">null</span><span class="s3">);</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">c of chunk</span><span class="s3">.</span><span class="s1">getAllReferencedChunks</span><span class="s3">()) {</span>
			<span class="s1">map</span><span class="s3">[</span><span class="s1">c</span><span class="s3">.</span><span class="s1">id</span><span class="s3">] = </span><span class="s1">filterFn</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s4">this</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">return </span><span class="s1">map</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleFilterPredicate} filterFn predicate function used to filter modules</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} return true if module exists in graph</span>
	 <span class="s5">*/</span>
	<span class="s1">hasModuleInGraph</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">filterFn</span><span class="s3">, </span><span class="s1">filterChunkFn</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">queue </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">groupsIterable</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">chunksProcessed </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>

		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunkGroup of queue</span><span class="s3">) {</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">innerChunk of chunkGroup</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">) {</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s1">chunksProcessed</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">innerChunk</span><span class="s3">)) {</span>
					<span class="s1">chunksProcessed</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">innerChunk</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(!</span><span class="s1">filterChunkFn </span><span class="s3">|| </span><span class="s1">filterChunkFn</span><span class="s3">(</span><span class="s1">innerChunk</span><span class="s3">, </span><span class="s4">this</span><span class="s3">)) {</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">getChunkModulesIterable</span><span class="s3">(</span><span class="s1">innerChunk</span><span class="s3">)) {</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">filterFn</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
								<span class="s4">return true</span><span class="s3">;</span>
							<span class="s3">}</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">child of chunkGroup</span><span class="s3">.</span><span class="s1">childrenIterable</span><span class="s3">) {</span>
				<span class="s1">queue</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">child</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s4">return false</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunkA first chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunkB second chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{-1|0|1} this is a comparator function like sort and returns -1, 0, or 1 based on sort order</span>
	 <span class="s5">*/</span>
	<span class="s1">compareChunks</span><span class="s3">(</span><span class="s1">chunkA</span><span class="s3">, </span><span class="s1">chunkB</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgcA </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunkA</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">cgcB </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunkB</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgcA</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s1">cgcB</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size</span><span class="s3">) </span><span class="s4">return </span><span class="s3">-</span><span class="s7">1</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgcA</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&lt; </span><span class="s1">cgcB</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">size</span><span class="s3">) </span><span class="s4">return </span><span class="s7">1</span><span class="s3">;</span>
		<span class="s1">cgcA</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">sortWith</span><span class="s3">(</span><span class="s1">compareModulesByIdentifier</span><span class="s3">);</span>
		<span class="s1">cgcB</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">sortWith</span><span class="s3">(</span><span class="s1">compareModulesByIdentifier</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">compareModuleIterables</span><span class="s3">(</span><span class="s1">cgcA</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">, </span><span class="s1">cgcB</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number} total size of all modules in the chunk</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkModulesSize</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">getFromUnorderedCache</span><span class="s3">(</span><span class="s1">getModulesSize</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Record&lt;string, number&gt;} total sizes of all modules in the chunk by source type</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkModulesSizes</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">getFromUnorderedCache</span><span class="s3">(</span><span class="s1">getModulesSizes</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Module[]} root modules of the chunks (ordered by identifier)</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkRootModules</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">getFromUnorderedCache</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getGraphRoots</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunkSizeOptions} options options object</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number} total size of the chunk</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkSize</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">options </span><span class="s3">= {}) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">modulesSize </span><span class="s3">= </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">getFromUnorderedCache</span><span class="s3">(</span><span class="s1">getModulesSize</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">chunkOverhead </span><span class="s3">=</span>
			<span class="s4">typeof </span><span class="s1">options</span><span class="s3">.</span><span class="s1">chunkOverhead </span><span class="s3">=== </span><span class="s2">&quot;number&quot; </span><span class="s3">? </span><span class="s1">options</span><span class="s3">.</span><span class="s1">chunkOverhead </span><span class="s3">: </span><span class="s7">10000</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">entryChunkMultiplicator </span><span class="s3">=</span>
			<span class="s4">typeof </span><span class="s1">options</span><span class="s3">.</span><span class="s1">entryChunkMultiplicator </span><span class="s3">=== </span><span class="s2">&quot;number&quot;</span>
				<span class="s3">? </span><span class="s1">options</span><span class="s3">.</span><span class="s1">entryChunkMultiplicator</span>
				<span class="s3">: </span><span class="s7">10</span><span class="s3">;</span>
		<span class="s4">return </span><span class="s3">(</span>
			<span class="s1">chunkOverhead </span><span class="s3">+</span>
			<span class="s1">modulesSize </span><span class="s3">* (</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">canBeInitial</span><span class="s3">() ? </span><span class="s1">entryChunkMultiplicator </span><span class="s3">: </span><span class="s7">1</span><span class="s3">)</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunkA chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunkB chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunkSizeOptions} options options object</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number} total size of the chunk or false if chunks can't be integrated</span>
	 <span class="s5">*/</span>
	<span class="s1">getIntegratedChunksSize</span><span class="s3">(</span><span class="s1">chunkA</span><span class="s3">, </span><span class="s1">chunkB</span><span class="s3">, </span><span class="s1">options </span><span class="s3">= {}) {</span>
		<span class="s4">const </span><span class="s1">cgcA </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunkA</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">cgcB </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunkB</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">allModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">cgcA</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">);</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">m of cgcB</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">) </span><span class="s1">allModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">m</span><span class="s3">);</span>
		<span class="s4">let </span><span class="s1">modulesSize </span><span class="s3">= </span><span class="s1">getModulesSize</span><span class="s3">(</span><span class="s1">allModules</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">chunkOverhead </span><span class="s3">=</span>
			<span class="s4">typeof </span><span class="s1">options</span><span class="s3">.</span><span class="s1">chunkOverhead </span><span class="s3">=== </span><span class="s2">&quot;number&quot; </span><span class="s3">? </span><span class="s1">options</span><span class="s3">.</span><span class="s1">chunkOverhead </span><span class="s3">: </span><span class="s7">10000</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">entryChunkMultiplicator </span><span class="s3">=</span>
			<span class="s4">typeof </span><span class="s1">options</span><span class="s3">.</span><span class="s1">entryChunkMultiplicator </span><span class="s3">=== </span><span class="s2">&quot;number&quot;</span>
				<span class="s3">? </span><span class="s1">options</span><span class="s3">.</span><span class="s1">entryChunkMultiplicator</span>
				<span class="s3">: </span><span class="s7">10</span><span class="s3">;</span>
		<span class="s4">return </span><span class="s3">(</span>
			<span class="s1">chunkOverhead </span><span class="s3">+</span>
			<span class="s1">modulesSize </span><span class="s3">*</span>
				<span class="s3">(</span><span class="s1">chunkA</span><span class="s3">.</span><span class="s1">canBeInitial</span><span class="s3">() || </span><span class="s1">chunkB</span><span class="s3">.</span><span class="s1">canBeInitial</span><span class="s3">()</span>
					<span class="s3">? </span><span class="s1">entryChunkMultiplicator</span>
					<span class="s3">: </span><span class="s7">1</span><span class="s3">)</span>
		<span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunkA chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunkB chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true, if chunks could be integrated</span>
	 <span class="s5">*/</span>
	<span class="s1">canChunksBeIntegrated</span><span class="s3">(</span><span class="s1">chunkA</span><span class="s3">, </span><span class="s1">chunkB</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">chunkA</span><span class="s3">.</span><span class="s1">preventIntegration </span><span class="s3">|| </span><span class="s1">chunkB</span><span class="s3">.</span><span class="s1">preventIntegration</span><span class="s3">) {</span>
			<span class="s4">return false</span><span class="s3">;</span>
		<span class="s3">}</span>

		<span class="s4">const </span><span class="s1">hasRuntimeA </span><span class="s3">= </span><span class="s1">chunkA</span><span class="s3">.</span><span class="s1">hasRuntime</span><span class="s3">();</span>
		<span class="s4">const </span><span class="s1">hasRuntimeB </span><span class="s3">= </span><span class="s1">chunkB</span><span class="s3">.</span><span class="s1">hasRuntime</span><span class="s3">();</span>

		<span class="s4">if </span><span class="s3">(</span><span class="s1">hasRuntimeA </span><span class="s3">!== </span><span class="s1">hasRuntimeB</span><span class="s3">) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">hasRuntimeA</span><span class="s3">) {</span>
				<span class="s4">return </span><span class="s1">isAvailableChunk</span><span class="s3">(</span><span class="s1">chunkA</span><span class="s3">, </span><span class="s1">chunkB</span><span class="s3">);</span>
			<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">hasRuntimeB</span><span class="s3">) {</span>
				<span class="s4">return </span><span class="s1">isAvailableChunk</span><span class="s3">(</span><span class="s1">chunkB</span><span class="s3">, </span><span class="s1">chunkA</span><span class="s3">);</span>
			<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
				<span class="s4">return false</span><span class="s3">;</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">if </span><span class="s3">(</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">getNumberOfEntryModules</span><span class="s3">(</span><span class="s1">chunkA</span><span class="s3">) &gt; </span><span class="s7">0 </span><span class="s3">||</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">getNumberOfEntryModules</span><span class="s3">(</span><span class="s1">chunkB</span><span class="s3">) &gt; </span><span class="s7">0</span>
		<span class="s3">) {</span>
			<span class="s4">return false</span><span class="s3">;</span>
		<span class="s3">}</span>

		<span class="s4">return true</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunkA the target chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunkB the chunk to integrate</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">integrateChunks</span><span class="s3">(</span><span class="s1">chunkA</span><span class="s3">, </span><span class="s1">chunkB</span><span class="s3">) {</span>
		<span class="s0">// Decide for one name (deterministic)</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">chunkA</span><span class="s3">.</span><span class="s1">name </span><span class="s3">&amp;&amp; </span><span class="s1">chunkB</span><span class="s3">.</span><span class="s1">name</span><span class="s3">) {</span>
			<span class="s4">if </span><span class="s3">(</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">getNumberOfEntryModules</span><span class="s3">(</span><span class="s1">chunkA</span><span class="s3">) &gt; </span><span class="s7">0 </span><span class="s3">===</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">getNumberOfEntryModules</span><span class="s3">(</span><span class="s1">chunkB</span><span class="s3">) &gt; </span><span class="s7">0</span>
			<span class="s3">) {</span>
				<span class="s0">// When both chunks have entry modules or none have one, use</span>
				<span class="s0">// shortest name</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">chunkA</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">length </span><span class="s3">!== </span><span class="s1">chunkB</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) {</span>
					<span class="s1">chunkA</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=</span>
						<span class="s1">chunkA</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&lt; </span><span class="s1">chunkB</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">length </span><span class="s3">? </span><span class="s1">chunkA</span><span class="s3">.</span><span class="s1">name </span><span class="s3">: </span><span class="s1">chunkB</span><span class="s3">.</span><span class="s1">name</span><span class="s3">;</span>
				<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
					<span class="s1">chunkA</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">chunkA</span><span class="s3">.</span><span class="s1">name </span><span class="s3">&lt; </span><span class="s1">chunkB</span><span class="s3">.</span><span class="s1">name </span><span class="s3">? </span><span class="s1">chunkA</span><span class="s3">.</span><span class="s1">name </span><span class="s3">: </span><span class="s1">chunkB</span><span class="s3">.</span><span class="s1">name</span><span class="s3">;</span>
				<span class="s3">}</span>
			<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">getNumberOfEntryModules</span><span class="s3">(</span><span class="s1">chunkB</span><span class="s3">) &gt; </span><span class="s7">0</span><span class="s3">) {</span>
				<span class="s0">// Pick the name of the chunk with the entry module</span>
				<span class="s1">chunkA</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">chunkB</span><span class="s3">.</span><span class="s1">name</span><span class="s3">;</span>
			<span class="s3">}</span>
		<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">chunkB</span><span class="s3">.</span><span class="s1">name</span><span class="s3">) {</span>
			<span class="s1">chunkA</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">chunkB</span><span class="s3">.</span><span class="s1">name</span><span class="s3">;</span>
		<span class="s3">}</span>

		<span class="s0">// Merge id name hints</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">hint of chunkB</span><span class="s3">.</span><span class="s1">idNameHints</span><span class="s3">) {</span>
			<span class="s1">chunkA</span><span class="s3">.</span><span class="s1">idNameHints</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">hint</span><span class="s3">);</span>
		<span class="s3">}</span>

		<span class="s0">// Merge runtime</span>
		<span class="s1">chunkA</span><span class="s3">.</span><span class="s1">runtime </span><span class="s3">= </span><span class="s1">mergeRuntime</span><span class="s3">(</span><span class="s1">chunkA</span><span class="s3">.</span><span class="s1">runtime</span><span class="s3">, </span><span class="s1">chunkB</span><span class="s3">.</span><span class="s1">runtime</span><span class="s3">);</span>

		<span class="s0">// getChunkModules is used here to create a clone, because disconnectChunkAndModule modifies</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">getChunkModules</span><span class="s3">(</span><span class="s1">chunkB</span><span class="s3">)) {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">disconnectChunkAndModule</span><span class="s3">(</span><span class="s1">chunkB</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">connectChunkAndModule</span><span class="s3">(</span><span class="s1">chunkA</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
		<span class="s3">}</span>

		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span><span class="s1">module</span><span class="s3">, </span><span class="s1">chunkGroup</span><span class="s3">] </span><span class="s1">of Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">getChunkEntryModulesWithChunkGroupIterable</span><span class="s3">(</span><span class="s1">chunkB</span><span class="s3">)</span>
		<span class="s3">)) {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">disconnectChunkAndEntryModule</span><span class="s3">(</span><span class="s1">chunkB</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">connectChunkAndEntryModule</span><span class="s3">(</span><span class="s1">chunkA</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">chunkGroup</span><span class="s3">);</span>
		<span class="s3">}</span>

		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunkGroup of chunkB</span><span class="s3">.</span><span class="s1">groupsIterable</span><span class="s3">) {</span>
			<span class="s1">chunkGroup</span><span class="s3">.</span><span class="s1">replaceChunk</span><span class="s3">(</span><span class="s1">chunkB</span><span class="s3">, </span><span class="s1">chunkA</span><span class="s3">);</span>
			<span class="s1">chunkA</span><span class="s3">.</span><span class="s1">addGroup</span><span class="s3">(</span><span class="s1">chunkGroup</span><span class="s3">);</span>
			<span class="s1">chunkB</span><span class="s3">.</span><span class="s1">removeGroup</span><span class="s3">(</span><span class="s1">chunkGroup</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s1">ChunkGraph</span><span class="s3">.</span><span class="s1">clearChunkGraphForChunk</span><span class="s3">(</span><span class="s1">chunkB</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk to upgrade</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">upgradeDependentToFullHashModules</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">dependentHashModules </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">fullHashModules </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s1">cgc</span><span class="s3">.</span><span class="s1">fullHashModules </span><span class="s3">= </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">dependentHashModules</span><span class="s3">;</span>
		<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">m of cgc</span><span class="s3">.</span><span class="s1">dependentHashModules</span><span class="s3">) {</span>
				<span class="s1">cgc</span><span class="s3">.</span><span class="s1">fullHashModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">m</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s1">cgc</span><span class="s3">.</span><span class="s1">dependentHashModules </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the checked module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the checked chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true, if the chunk contains the module as entry</span>
	 <span class="s5">*/</span>
	<span class="s1">isEntryModuleInChunk</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">entryModules</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the new chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the entry module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Entrypoint=} entrypoint the chunk group which must be loaded before the module is executed</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">connectChunkAndEntryModule</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">entrypoint</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">entryInChunks </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s1">cgm</span><span class="s3">.</span><span class="s1">entryInChunks </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s3">}</span>
		<span class="s1">cgm</span><span class="s3">.</span><span class="s1">entryInChunks</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s1">cgc</span><span class="s3">.</span><span class="s1">entryModules</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">entrypoint</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the new chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeModule} module the runtime module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">connectChunkAndRuntimeModule</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">runtimeInChunks </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s1">cgm</span><span class="s3">.</span><span class="s1">runtimeInChunks </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s3">}</span>
		<span class="s1">cgm</span><span class="s3">.</span><span class="s1">runtimeInChunks</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s1">cgc</span><span class="s3">.</span><span class="s1">runtimeModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the new chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeModule} module the module that require a full hash</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">addFullHashModuleToChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">fullHashModules </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">fullHashModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s1">cgc</span><span class="s3">.</span><span class="s1">fullHashModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the new chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeModule} module the module that require a full hash</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">addDependentHashModuleToChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">dependentHashModules </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">)</span>
			<span class="s1">cgc</span><span class="s3">.</span><span class="s1">dependentHashModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s1">cgc</span><span class="s3">.</span><span class="s1">dependentHashModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the new chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the entry module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">disconnectChunkAndEntryModule</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s1">cgm</span><span class="s3">.</span><span class="s1">entryInChunks</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">entryInChunks</span><span class="s3">.</span><span class="s1">size </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) {</span>
			<span class="s1">cgm</span><span class="s3">.</span><span class="s1">entryInChunks </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s3">}</span>
		<span class="s1">cgc</span><span class="s3">.</span><span class="s1">entryModules</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the new chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeModule} module the runtime module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">disconnectChunkAndRuntimeModule</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s1">cgm</span><span class="s3">.</span><span class="s1">runtimeInChunks</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">runtimeInChunks</span><span class="s3">.</span><span class="s1">size </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) {</span>
			<span class="s1">cgm</span><span class="s3">.</span><span class="s1">runtimeInChunks </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
		<span class="s3">}</span>
		<span class="s1">cgc</span><span class="s3">.</span><span class="s1">runtimeModules</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the entry module, it will no longer be entry</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">disconnectEntryModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunk of cgm</span><span class="s3">.</span><span class="s1">entryInChunks</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
			<span class="s1">cgc</span><span class="s3">.</span><span class="s1">entryModules</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s1">cgm</span><span class="s3">.</span><span class="s1">entryInChunks </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk, for which all entries will be removed</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">disconnectEntries</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of cgc</span><span class="s3">.</span><span class="s1">entryModules</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()) {</span>
			<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s1">cgm</span><span class="s3">.</span><span class="s1">entryInChunks</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">entryInChunks</span><span class="s3">.</span><span class="s1">size </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) {</span>
				<span class="s1">cgm</span><span class="s3">.</span><span class="s1">entryInChunks </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s1">cgc</span><span class="s3">.</span><span class="s1">entryModules</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number} the amount of entry modules in chunk</span>
	 <span class="s5">*/</span>
	<span class="s1">getNumberOfEntryModules</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">entryModules</span><span class="s3">.</span><span class="s1">size</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number} the amount of entry modules in chunk</span>
	 <span class="s5">*/</span>
	<span class="s1">getNumberOfRuntimeModules</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">runtimeModules</span><span class="s3">.</span><span class="s1">size</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Iterable&lt;Module&gt;} iterable of modules (do not modify)</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkEntryModulesIterable</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">entryModules</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">();</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Iterable&lt;Chunk&gt;} iterable of chunks</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkEntryDependentChunksIterable</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;Chunk&gt;} */</span>
		<span class="s4">const </span><span class="s1">set </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunkGroup of chunk</span><span class="s3">.</span><span class="s1">groupsIterable</span><span class="s3">) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">chunkGroup </span><span class="s4">instanceof </span><span class="s1">Entrypoint</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">entrypointChunk </span><span class="s3">= </span><span class="s1">chunkGroup</span><span class="s3">.</span><span class="s1">getEntrypointChunk</span><span class="s3">();</span>
				<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">entrypointChunk</span><span class="s3">);</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunkGroup of cgc</span><span class="s3">.</span><span class="s1">entryModules</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()) {</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">c of chunkGroup</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">) {</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">c </span><span class="s3">!== </span><span class="s1">chunk </span><span class="s3">&amp;&amp; </span><span class="s1">c </span><span class="s3">!== </span><span class="s1">entrypointChunk </span><span class="s3">&amp;&amp; !</span><span class="s1">c</span><span class="s3">.</span><span class="s1">hasRuntime</span><span class="s3">()) {</span>
							<span class="s1">set</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">c</span><span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">return </span><span class="s1">set</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true, when it has dependent chunks</span>
	 <span class="s5">*/</span>
	<span class="s1">hasChunkEntryDependentChunks</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">chunkGroup of cgc</span><span class="s3">.</span><span class="s1">entryModules</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()) {</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">c of chunkGroup</span><span class="s3">.</span><span class="s1">chunks</span><span class="s3">) {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">c </span><span class="s3">!== </span><span class="s1">chunk</span><span class="s3">) {</span>
					<span class="s4">return true</span><span class="s3">;</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s4">return false</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Iterable&lt;RuntimeModule&gt;} iterable of modules (do not modify)</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkRuntimeModulesIterable</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">runtimeModules</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{RuntimeModule[]} array of modules in order of execution</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkRuntimeModulesInOrder</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">array </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">runtimeModules</span><span class="s3">);</span>
		<span class="s1">array</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span>
			<span class="s1">concatComparators</span><span class="s3">(</span>
				<span class="s1">compareSelect</span><span class="s3">(</span>
					<span class="s5">/**</span>
					 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeModule} r runtime module</span>
					 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number=} stage</span>
					 <span class="s5">*/</span>
					<span class="s1">r </span><span class="s3">=&gt; </span><span class="s1">r</span><span class="s3">.</span><span class="s1">stage</span><span class="s3">,</span>
					<span class="s1">compareIds</span>
				<span class="s3">),</span>
				<span class="s1">compareModulesByIdentifier</span>
			<span class="s3">)</span>
		<span class="s3">);</span>
		<span class="s4">return </span><span class="s1">array</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Iterable&lt;RuntimeModule&gt; | undefined} iterable of modules (do not modify)</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkFullHashModulesIterable</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">fullHashModules</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ReadonlySet&lt;RuntimeModule&gt; | undefined} set of modules (do not modify)</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkFullHashModulesSet</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">fullHashModules</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Iterable&lt;RuntimeModule&gt; | undefined} iterable of modules (do not modify)</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkDependentHashModulesIterable</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">dependentHashModules</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Iterable&lt;EntryModuleWithChunkGroup&gt;} iterable of modules (do not modify)</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkEntryModulesWithChunkGroupIterable</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">entryModules</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{AsyncDependenciesBlock} depBlock the async block</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ChunkGroup} the chunk group</span>
	 <span class="s5">*/</span>
	<span class="s1">getBlockChunkGroup</span><span class="s3">(</span><span class="s1">depBlock</span><span class="s3">) {</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">_blockChunkGroups</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">depBlock</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{AsyncDependenciesBlock} depBlock the async block</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunkGroup} chunkGroup the chunk group</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">connectBlockAndChunkGroup</span><span class="s3">(</span><span class="s1">depBlock</span><span class="s3">, </span><span class="s1">chunkGroup</span><span class="s3">) {</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_blockChunkGroups</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">depBlock</span><span class="s3">, </span><span class="s1">chunkGroup</span><span class="s3">);</span>
		<span class="s1">chunkGroup</span><span class="s3">.</span><span class="s1">addBlock</span><span class="s3">(</span><span class="s1">depBlock</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunkGroup} chunkGroup the chunk group</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">disconnectChunkGroup</span><span class="s3">(</span><span class="s1">chunkGroup</span><span class="s3">) {</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">block of chunkGroup</span><span class="s3">.</span><span class="s1">blocksIterable</span><span class="s3">) {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">_blockChunkGroups</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">block</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s0">// TODO refactor by moving blocks list into ChunkGraph</span>
		<span class="s1">chunkGroup</span><span class="s3">.</span><span class="s1">_blocks</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">();</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string | number} the id of the module</span>
	 <span class="s5">*/</span>
	<span class="s1">getModuleId</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">id</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string | number} id the id of the module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">setModuleId</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">id</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s1">cgm</span><span class="s3">.</span><span class="s1">id </span><span class="s3">= </span><span class="s1">id</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} runtime runtime</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string | number} the id of the runtime</span>
	 <span class="s5">*/</span>
	<span class="s1">getRuntimeId</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">) {</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">_runtimeIds</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} runtime runtime</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string | number} id the id of the runtime</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">setRuntimeId</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">, </span><span class="s1">id</span><span class="s3">) {</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_runtimeIds</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">, </span><span class="s1">id</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@template </span><span class="s5">T</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpecMap&lt;T&gt;} hashes hashes data</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime the runtime</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{T} hash</span>
	 <span class="s5">*/</span>
	<span class="s1">_getModuleHashInfo</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">hashes</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(!</span><span class="s1">hashes</span><span class="s3">) {</span>
			<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
				<span class="s2">`Module </span><span class="s1">$</span><span class="s3">{</span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">()} </span><span class="s2">has no hash info for runtime </span><span class="s1">$</span><span class="s3">{</span><span class="s1">runtimeToString</span><span class="s3">(</span>
					<span class="s1">runtime</span>
				<span class="s3">)} </span><span class="s2">(hashes not set at all)`</span>
			<span class="s3">);</span>
		<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">runtime </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">hashInfoItems </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">hashes</span><span class="s3">.</span><span class="s1">values</span><span class="s3">());</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">hashInfoItems</span><span class="s3">.</span><span class="s1">size </span><span class="s3">!== </span><span class="s7">1</span><span class="s3">) {</span>
				<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
					<span class="s2">`No unique hash info entry for unspecified runtime for </span><span class="s1">$</span><span class="s3">{</span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">()} </span><span class="s2">(existing runtimes: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span>
						<span class="s1">hashes</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(),</span>
						<span class="s1">r </span><span class="s3">=&gt; </span><span class="s1">runtimeToString</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>
					<span class="s3">).</span><span class="s1">join</span><span class="s3">(</span><span class="s2">&quot;, &quot;</span><span class="s3">)}</span><span class="s2">). 
Caller might not support runtime-dependent code generation (opt-out via optimization.usedExports: &quot;global&quot;).`</span>
				<span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">return </span><span class="s1">first</span><span class="s3">(</span><span class="s1">hashInfoItems</span><span class="s3">);</span>
		<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
			<span class="s4">const </span><span class="s1">hashInfo </span><span class="s3">= </span><span class="s1">hashes</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(!</span><span class="s1">hashInfo</span><span class="s3">) {</span>
				<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
					<span class="s2">`Module </span><span class="s1">$</span><span class="s3">{</span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">()} </span><span class="s2">has no hash info for runtime </span><span class="s1">$</span><span class="s3">{</span><span class="s1">runtimeToString</span><span class="s3">(</span>
						<span class="s1">runtime</span>
					<span class="s3">)} </span><span class="s2">(available runtimes </span><span class="s1">$</span><span class="s3">{</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span>
						<span class="s1">hashes</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(),</span>
						<span class="s1">runtimeToString</span>
					<span class="s3">).</span><span class="s1">join</span><span class="s3">(</span><span class="s2">&quot;, &quot;</span><span class="s3">)}</span><span class="s2">)`</span>
				<span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">return </span><span class="s1">hashInfo</span><span class="s3">;</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime the runtime</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} true, if the module has hashes for this runtime</span>
	 <span class="s5">*/</span>
	<span class="s1">hasModuleHashes</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">hashes </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{RuntimeSpecMap&lt;ModuleHashInfo&gt;} */ </span><span class="s3">(</span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">hashes</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">hashes </span><span class="s3">&amp;&amp; </span><span class="s1">hashes</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime the runtime</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} hash</span>
	 <span class="s5">*/</span>
	<span class="s1">getModuleHash</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">hashes </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{RuntimeSpecMap&lt;ModuleHashInfo&gt;} */ </span><span class="s3">(</span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">hashes</span><span class="s3">);</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">_getModuleHashInfo</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">hashes</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">).</span><span class="s1">hash</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime the runtime</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} hash</span>
	 <span class="s5">*/</span>
	<span class="s1">getRenderedModuleHash</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">hashes </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{RuntimeSpecMap&lt;ModuleHashInfo&gt;} */ </span><span class="s3">(</span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">hashes</span><span class="s3">);</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">_getModuleHashInfo</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">hashes</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">).</span><span class="s1">renderedHash</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime the runtime</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} hash the full hash</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} renderedHash the shortened hash for rendering</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">setModuleHashes</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">, </span><span class="s1">hash</span><span class="s3">, </span><span class="s1">renderedHash</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">hashes </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s1">cgm</span><span class="s3">.</span><span class="s1">hashes </span><span class="s3">= </span><span class="s4">new </span><span class="s1">RuntimeSpecMap</span><span class="s3">();</span>
		<span class="s3">}</span>
		<span class="s1">cgm</span><span class="s3">.</span><span class="s1">hashes</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">, </span><span class="s4">new </span><span class="s1">ModuleHashInfo</span><span class="s3">(</span><span class="s1">hash</span><span class="s3">, </span><span class="s1">renderedHash</span><span class="s3">));</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime the runtime</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Set&lt;string&gt;} items runtime requirements to be added (ownership of this Set is given to ChunkGraph when transferOwnership not false)</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{boolean} transferOwnership true: transfer ownership of the items object, false: items is immutable and shared and won't be modified</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">addModuleRuntimeRequirements</span><span class="s3">(</span>
		<span class="s1">module</span><span class="s3">,</span>
		<span class="s1">runtime</span><span class="s3">,</span>
		<span class="s1">items</span><span class="s3">,</span>
		<span class="s1">transferOwnership </span><span class="s3">= </span><span class="s4">true</span>
	<span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">runtimeRequirementsMap </span><span class="s3">= </span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">runtimeRequirements</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">runtimeRequirementsMap </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">map </span><span class="s3">= </span><span class="s4">new </span><span class="s1">RuntimeSpecMap</span><span class="s3">();</span>
			<span class="s0">// TODO avoid cloning item and track ownership instead</span>
			<span class="s1">map</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">, </span><span class="s1">transferOwnership </span><span class="s3">? </span><span class="s1">items </span><span class="s3">: </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">items</span><span class="s3">));</span>
			<span class="s1">cgm</span><span class="s3">.</span><span class="s1">runtimeRequirements </span><span class="s3">= </span><span class="s1">map</span><span class="s3">;</span>
			<span class="s4">return</span><span class="s3">;</span>
		<span class="s3">}</span>
		<span class="s1">runtimeRequirementsMap</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">, </span><span class="s1">runtimeRequirements </span><span class="s3">=&gt; {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">runtimeRequirements </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s4">return </span><span class="s1">transferOwnership </span><span class="s3">? </span><span class="s1">items </span><span class="s3">: </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">items</span><span class="s3">);</span>
			<span class="s3">} </span><span class="s4">else if </span><span class="s3">(!</span><span class="s1">transferOwnership </span><span class="s3">|| </span><span class="s1">runtimeRequirements</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt;= </span><span class="s1">items</span><span class="s3">.</span><span class="s1">size</span><span class="s3">) {</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">item of items</span><span class="s3">) </span><span class="s1">runtimeRequirements</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">item</span><span class="s3">);</span>
				<span class="s4">return </span><span class="s1">runtimeRequirements</span><span class="s3">;</span>
			<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">item of runtimeRequirements</span><span class="s3">) </span><span class="s1">items</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">item</span><span class="s3">);</span>
				<span class="s4">return </span><span class="s1">items</span><span class="s3">;</span>
			<span class="s3">}</span>
		<span class="s3">});</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Set&lt;string&gt;} items runtime requirements to be added (ownership of this Set is given to ChunkGraph)</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">addChunkRuntimeRequirements</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">items</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">runtimeRequirements </span><span class="s3">= </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">runtimeRequirements</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">runtimeRequirements </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s1">cgc</span><span class="s3">.</span><span class="s1">runtimeRequirements </span><span class="s3">= </span><span class="s1">items</span><span class="s3">;</span>
		<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">runtimeRequirements</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt;= </span><span class="s1">items</span><span class="s3">.</span><span class="s1">size</span><span class="s3">) {</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">item of items</span><span class="s3">) </span><span class="s1">runtimeRequirements</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">item</span><span class="s3">);</span>
		<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">item of runtimeRequirements</span><span class="s3">) </span><span class="s1">items</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">item</span><span class="s3">);</span>
			<span class="s1">cgc</span><span class="s3">.</span><span class="s1">runtimeRequirements </span><span class="s3">= </span><span class="s1">items</span><span class="s3">;</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Iterable&lt;string&gt;} items runtime requirements to be added</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">addTreeRuntimeRequirements</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">items</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">runtimeRequirements </span><span class="s3">= </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">runtimeRequirementsInTree</span><span class="s3">;</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">item of items</span><span class="s3">) </span><span class="s1">runtimeRequirements</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">item</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime the runtime</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ReadonlySet&lt;string&gt;} runtime requirements</span>
	 <span class="s5">*/</span>
	<span class="s1">getModuleRuntimeRequirements</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">runtimeRequirements </span><span class="s3">=</span>
			<span class="s1">cgm</span><span class="s3">.</span><span class="s1">runtimeRequirements </span><span class="s3">&amp;&amp; </span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">runtimeRequirements</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">runtimeRequirements </span><span class="s3">=== </span><span class="s1">undefined </span><span class="s3">? </span><span class="s1">EMPTY_SET </span><span class="s3">: </span><span class="s1">runtimeRequirements</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ReadonlySet&lt;string&gt;} runtime requirements</span>
	 <span class="s5">*/</span>
	<span class="s1">getChunkRuntimeRequirements</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">runtimeRequirements </span><span class="s3">= </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">runtimeRequirements</span><span class="s3">;</span>
		<span class="s4">return </span><span class="s1">runtimeRequirements </span><span class="s3">=== </span><span class="s1">undefined </span><span class="s3">? </span><span class="s1">EMPTY_SET </span><span class="s3">: </span><span class="s1">runtimeRequirements</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime the runtime</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{boolean} withConnections include connections</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} hash</span>
	 <span class="s5">*/</span>
	<span class="s1">getModuleGraphHash</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">, </span><span class="s1">withConnections </span><span class="s3">= </span><span class="s4">true</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">withConnections</span>
			<span class="s3">? </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getModuleGraphHashWithConnections</span><span class="s3">(</span><span class="s1">cgm</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">)</span>
			<span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getModuleGraphHashBigInt</span><span class="s3">(</span><span class="s1">cgm</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">).</span><span class="s1">toString</span><span class="s3">(</span><span class="s7">16</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime the runtime</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{boolean} withConnections include connections</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{bigint} hash</span>
	 <span class="s5">*/</span>
	<span class="s1">getModuleGraphHashBigInt</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">, </span><span class="s1">withConnections </span><span class="s3">= </span><span class="s4">true</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgm </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">withConnections</span>
			<span class="s3">? </span><span class="s1">BigInt</span><span class="s3">(</span>
					<span class="s2">`0x</span><span class="s1">$</span><span class="s3">{</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getModuleGraphHashWithConnections</span><span class="s3">(</span><span class="s1">cgm</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">)}</span><span class="s2">`</span>
			  <span class="s3">)</span>
			<span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getModuleGraphHashBigInt</span><span class="s3">(</span><span class="s1">cgm</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunkGraphModule} cgm the ChunkGraphModule</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime the runtime</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{bigint} hash as big int</span>
	 <span class="s5">*/</span>
	<span class="s1">_getModuleGraphHashBigInt</span><span class="s3">(</span><span class="s1">cgm</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">graphHashes </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s1">cgm</span><span class="s3">.</span><span class="s1">graphHashes </span><span class="s3">= </span><span class="s4">new </span><span class="s1">RuntimeSpecMap</span><span class="s3">();</span>
		<span class="s3">}</span>
		<span class="s4">const </span><span class="s1">graphHash </span><span class="s3">= </span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">graphHashes</span><span class="s3">.</span><span class="s1">provide</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">, () =&gt; {</span>
			<span class="s4">const </span><span class="s1">hash </span><span class="s3">= </span><span class="s1">createHash</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_hashFunction</span><span class="s3">);</span>
			<span class="s1">hash</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">id</span><span class="s3">}</span><span class="s1">$</span><span class="s3">{</span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">isAsync</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)}</span><span class="s2">`</span><span class="s3">);</span>
			<span class="s4">const </span><span class="s1">sourceTypes </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getOverwrittenModuleSourceTypes</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">sourceTypes </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">type of sourceTypes</span><span class="s3">) </span><span class="s1">hash</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">type</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getExportsInfo</span><span class="s3">(</span><span class="s1">module</span><span class="s3">).</span><span class="s1">updateHash</span><span class="s3">(</span><span class="s1">hash</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">);</span>
			<span class="s4">return </span><span class="s1">BigInt</span><span class="s3">(</span><span class="s2">`0x</span><span class="s1">$</span><span class="s3">{</span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */ </span><span class="s3">(</span><span class="s1">hash</span><span class="s3">.</span><span class="s1">digest</span><span class="s3">(</span><span class="s2">&quot;hex&quot;</span><span class="s3">))}</span><span class="s2">`</span><span class="s3">);</span>
		<span class="s3">});</span>
		<span class="s4">return </span><span class="s1">graphHash</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunkGraphModule} cgm the ChunkGraphModule</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime the runtime</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} hash</span>
	 <span class="s5">*/</span>
	<span class="s1">_getModuleGraphHashWithConnections</span><span class="s3">(</span><span class="s1">cgm</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">graphHashesWithConnections </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s1">cgm</span><span class="s3">.</span><span class="s1">graphHashesWithConnections </span><span class="s3">= </span><span class="s4">new </span><span class="s1">RuntimeSpecMap</span><span class="s3">();</span>
		<span class="s3">}</span>
		<span class="s4">const </span><span class="s1">activeStateToString </span><span class="s3">= </span><span class="s1">state </span><span class="s3">=&gt; {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">state </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">) </span><span class="s4">return </span><span class="s2">&quot;F&quot;</span><span class="s3">;</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">state </span><span class="s3">=== </span><span class="s4">true</span><span class="s3">) </span><span class="s4">return </span><span class="s2">&quot;T&quot;</span><span class="s3">;</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">state </span><span class="s3">=== </span><span class="s1">ModuleGraphConnection</span><span class="s3">.</span><span class="s1">TRANSITIVE_ONLY</span><span class="s3">) </span><span class="s4">return </span><span class="s2">&quot;O&quot;</span><span class="s3">;</span>
			<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span><span class="s2">&quot;Not implemented active state&quot;</span><span class="s3">);</span>
		<span class="s3">};</span>
		<span class="s4">const </span><span class="s1">strict </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">buildMeta </span><span class="s3">&amp;&amp; </span><span class="s1">module</span><span class="s3">.</span><span class="s1">buildMeta</span><span class="s3">.</span><span class="s1">strictHarmonyModule</span><span class="s3">;</span>
		<span class="s4">return </span><span class="s1">cgm</span><span class="s3">.</span><span class="s1">graphHashesWithConnections</span><span class="s3">.</span><span class="s1">provide</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">, () =&gt; {</span>
			<span class="s4">const </span><span class="s1">graphHash </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getModuleGraphHashBigInt</span><span class="s3">(</span>
				<span class="s1">cgm</span><span class="s3">,</span>
				<span class="s1">module</span><span class="s3">,</span>
				<span class="s1">runtime</span>
			<span class="s3">).</span><span class="s1">toString</span><span class="s3">(</span><span class="s7">16</span><span class="s3">);</span>
			<span class="s4">const </span><span class="s1">connections </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getOutgoingConnections</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;Module&gt;} */</span>
			<span class="s4">const </span><span class="s1">activeNamespaceModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, Module | Set&lt;Module&gt;&gt;} */</span>
			<span class="s4">const </span><span class="s1">connectedModules </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
			<span class="s4">const </span><span class="s1">processConnection </span><span class="s3">= (</span><span class="s1">connection</span><span class="s3">, </span><span class="s1">stateInfo</span><span class="s3">) =&gt; {</span>
				<span class="s4">const </span><span class="s1">module </span><span class="s3">= </span><span class="s1">connection</span><span class="s3">.</span><span class="s1">module</span><span class="s3">;</span>
				<span class="s1">stateInfo </span><span class="s3">+= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">getExportsType</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">);</span>
				<span class="s0">// cspell:word Tnamespace</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">stateInfo </span><span class="s3">=== </span><span class="s2">&quot;Tnamespace&quot;</span><span class="s3">) </span><span class="s1">activeNamespaceModules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
				<span class="s4">else </span><span class="s3">{</span>
					<span class="s4">const </span><span class="s1">oldModule </span><span class="s3">= </span><span class="s1">connectedModules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">stateInfo</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">oldModule </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
						<span class="s1">connectedModules</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">stateInfo</span><span class="s3">, </span><span class="s1">module</span><span class="s3">);</span>
					<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">oldModule </span><span class="s4">instanceof </span><span class="s1">Set</span><span class="s3">) {</span>
						<span class="s1">oldModule</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
					<span class="s3">} </span><span class="s4">else if </span><span class="s3">(</span><span class="s1">oldModule </span><span class="s3">!== </span><span class="s1">module</span><span class="s3">) {</span>
						<span class="s1">connectedModules</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">stateInfo</span><span class="s3">, </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">([</span><span class="s1">oldModule</span><span class="s3">, </span><span class="s1">module</span><span class="s3">]));</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
			<span class="s3">};</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">runtime </span><span class="s3">=== </span><span class="s1">undefined </span><span class="s3">|| </span><span class="s4">typeof </span><span class="s1">runtime </span><span class="s3">=== </span><span class="s2">&quot;string&quot;</span><span class="s3">) {</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">connection of connections</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">state </span><span class="s3">= </span><span class="s1">connection</span><span class="s3">.</span><span class="s1">getActiveState</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">state </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
					<span class="s1">processConnection</span><span class="s3">(</span><span class="s1">connection</span><span class="s3">, </span><span class="s1">state </span><span class="s3">=== </span><span class="s4">true </span><span class="s3">? </span><span class="s2">&quot;T&quot; </span><span class="s3">: </span><span class="s2">&quot;O&quot;</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
				<span class="s0">// cspell:word Tnamespace</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">connection of connections</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">states </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
					<span class="s4">let </span><span class="s1">stateInfo </span><span class="s3">= </span><span class="s2">&quot;&quot;</span><span class="s3">;</span>
					<span class="s1">forEachRuntime</span><span class="s3">(</span>
						<span class="s1">runtime</span><span class="s3">,</span>
						<span class="s1">runtime </span><span class="s3">=&gt; {</span>
							<span class="s4">const </span><span class="s1">state </span><span class="s3">= </span><span class="s1">connection</span><span class="s3">.</span><span class="s1">getActiveState</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">);</span>
							<span class="s1">states</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">state</span><span class="s3">);</span>
							<span class="s1">stateInfo </span><span class="s3">+= </span><span class="s1">activeStateToString</span><span class="s3">(</span><span class="s1">state</span><span class="s3">) + </span><span class="s1">runtime</span><span class="s3">;</span>
						<span class="s3">},</span>
						<span class="s4">true</span>
					<span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">states</span><span class="s3">.</span><span class="s1">size </span><span class="s3">=== </span><span class="s7">1</span><span class="s3">) {</span>
						<span class="s4">const </span><span class="s1">state </span><span class="s3">= </span><span class="s1">first</span><span class="s3">(</span><span class="s1">states</span><span class="s3">);</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">state </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
						<span class="s1">stateInfo </span><span class="s3">= </span><span class="s1">activeStateToString</span><span class="s3">(</span><span class="s1">state</span><span class="s3">);</span>
					<span class="s3">}</span>
					<span class="s1">processConnection</span><span class="s3">(</span><span class="s1">connection</span><span class="s3">, </span><span class="s1">stateInfo</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
			<span class="s0">// cspell:word Tnamespace</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">activeNamespaceModules</span><span class="s3">.</span><span class="s1">size </span><span class="s3">=== </span><span class="s7">0 </span><span class="s3">&amp;&amp; </span><span class="s1">connectedModules</span><span class="s3">.</span><span class="s1">size </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">)</span>
				<span class="s4">return </span><span class="s1">graphHash</span><span class="s3">;</span>
			<span class="s4">const </span><span class="s1">connectedModulesInOrder </span><span class="s3">=</span>
				<span class="s1">connectedModules</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s7">1</span>
					<span class="s3">? </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s1">connectedModules</span><span class="s3">).</span><span class="s1">sort</span><span class="s3">(([</span><span class="s1">a</span><span class="s3">], [</span><span class="s1">b</span><span class="s3">]) =&gt; (</span><span class="s1">a </span><span class="s3">&lt; </span><span class="s1">b </span><span class="s3">? -</span><span class="s7">1 </span><span class="s3">: </span><span class="s7">1</span><span class="s3">))</span>
					<span class="s3">: </span><span class="s1">connectedModules</span><span class="s3">;</span>
			<span class="s4">const </span><span class="s1">hash </span><span class="s3">= </span><span class="s1">createHash</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_hashFunction</span><span class="s3">);</span>
			<span class="s4">const </span><span class="s1">addModuleToHash </span><span class="s3">= </span><span class="s1">module </span><span class="s3">=&gt; {</span>
				<span class="s1">hash</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">_getModuleGraphHashBigInt</span><span class="s3">(</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">),</span>
						<span class="s1">module</span><span class="s3">,</span>
						<span class="s1">runtime</span>
					<span class="s3">).</span><span class="s1">toString</span><span class="s3">(</span><span class="s7">16</span><span class="s3">)</span>
				<span class="s3">);</span>
			<span class="s3">};</span>
			<span class="s4">const </span><span class="s1">addModulesToHash </span><span class="s3">= </span><span class="s1">modules </span><span class="s3">=&gt; {</span>
				<span class="s4">let </span><span class="s1">xor </span><span class="s3">= </span><span class="s1">ZERO_BIG_INT</span><span class="s3">;</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">m of modules</span><span class="s3">) {</span>
					<span class="s1">xor </span><span class="s3">=</span>
						<span class="s1">xor </span><span class="s3">^</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">_getModuleGraphHashBigInt</span><span class="s3">(</span>
							<span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphModule</span><span class="s3">(</span><span class="s1">m</span><span class="s3">),</span>
							<span class="s1">m</span><span class="s3">,</span>
							<span class="s1">runtime</span>
						<span class="s3">);</span>
				<span class="s3">}</span>
				<span class="s1">hash</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">xor</span><span class="s3">.</span><span class="s1">toString</span><span class="s3">(</span><span class="s7">16</span><span class="s3">));</span>
			<span class="s3">};</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">activeNamespaceModules</span><span class="s3">.</span><span class="s1">size </span><span class="s3">=== </span><span class="s7">1</span><span class="s3">)</span>
				<span class="s1">addModuleToHash</span><span class="s3">(</span><span class="s1">activeNamespaceModules</span><span class="s3">.</span><span class="s1">values</span><span class="s3">().</span><span class="s1">next</span><span class="s3">().</span><span class="s1">value</span><span class="s3">);</span>
			<span class="s4">else if </span><span class="s3">(</span><span class="s1">activeNamespaceModules</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s7">1</span><span class="s3">)</span>
				<span class="s1">addModulesToHash</span><span class="s3">(</span><span class="s1">activeNamespaceModules</span><span class="s3">);</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span><span class="s1">stateInfo</span><span class="s3">, </span><span class="s1">modules</span><span class="s3">] </span><span class="s1">of connectedModulesInOrder</span><span class="s3">) {</span>
				<span class="s1">hash</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">stateInfo</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">modules </span><span class="s4">instanceof </span><span class="s1">Set</span><span class="s3">) {</span>
					<span class="s1">addModulesToHash</span><span class="s3">(</span><span class="s1">modules</span><span class="s3">);</span>
				<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
					<span class="s1">addModuleToHash</span><span class="s3">(</span><span class="s1">modules</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
			<span class="s1">hash</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">graphHash</span><span class="s3">);</span>
			<span class="s4">return </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */ </span><span class="s3">(</span><span class="s1">hash</span><span class="s3">.</span><span class="s1">digest</span><span class="s3">(</span><span class="s2">&quot;hex&quot;</span><span class="s3">));</span>
		<span class="s3">});</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ReadonlySet&lt;string&gt;} runtime requirements</span>
	 <span class="s5">*/</span>
	<span class="s1">getTreeRuntimeRequirements</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cgc </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getChunkGraphChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">cgc</span><span class="s3">.</span><span class="s1">runtimeRequirementsInTree</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s0">// TODO remove in webpack 6</span>
	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} deprecateMessage message for the deprecation message</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} deprecationCode code for the deprecation</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ChunkGraph} the chunk graph</span>
	 <span class="s5">*/</span>
	<span class="s4">static </span><span class="s1">getChunkGraphForModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">deprecateMessage</span><span class="s3">, </span><span class="s1">deprecationCode</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">fn </span><span class="s3">= </span><span class="s1">deprecateGetChunkGraphForModuleMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">deprecateMessage</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">fn</span><span class="s3">) </span><span class="s4">return </span><span class="s1">fn</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">newFn </span><span class="s3">= </span><span class="s1">util</span><span class="s3">.</span><span class="s1">deprecate</span><span class="s3">(</span>
			<span class="s5">/**</span>
			 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
			 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ChunkGraph} the chunk graph</span>
			 <span class="s5">*/</span>
			<span class="s1">module </span><span class="s3">=&gt; {</span>
				<span class="s4">const </span><span class="s1">chunkGraph </span><span class="s3">= </span><span class="s1">chunkGraphForModuleMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s1">chunkGraph</span><span class="s3">)</span>
					<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
						<span class="s1">deprecateMessage </span><span class="s3">+</span>
							<span class="s2">&quot;: There was no ChunkGraph assigned to the Module for backward-compat (Use the new API)&quot;</span>
					<span class="s3">);</span>
				<span class="s4">return </span><span class="s1">chunkGraph</span><span class="s3">;</span>
			<span class="s3">},</span>
			<span class="s1">deprecateMessage </span><span class="s3">+ </span><span class="s2">&quot;: Use new ChunkGraph API&quot;</span><span class="s3">,</span>
			<span class="s1">deprecationCode</span>
		<span class="s3">);</span>
		<span class="s1">deprecateGetChunkGraphForModuleMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">deprecateMessage</span><span class="s3">, </span><span class="s1">newFn</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">newFn</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s0">// TODO remove in webpack 6</span>
	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunkGraph} chunkGraph the chunk graph</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s4">static </span><span class="s1">setChunkGraphForModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">chunkGraph</span><span class="s3">) {</span>
		<span class="s1">chunkGraphForModuleMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">chunkGraph</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s0">// TODO remove in webpack 6</span>
	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module the module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s4">static </span><span class="s1">clearChunkGraphForModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s1">chunkGraphForModuleMap</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s0">// TODO remove in webpack 6</span>
	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} deprecateMessage message for the deprecation message</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} deprecationCode code for the deprecation</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ChunkGraph} the chunk graph</span>
	 <span class="s5">*/</span>
	<span class="s4">static </span><span class="s1">getChunkGraphForChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">deprecateMessage</span><span class="s3">, </span><span class="s1">deprecationCode</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">fn </span><span class="s3">= </span><span class="s1">deprecateGetChunkGraphForChunkMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">deprecateMessage</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">fn</span><span class="s3">) </span><span class="s4">return </span><span class="s1">fn</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">newFn </span><span class="s3">= </span><span class="s1">util</span><span class="s3">.</span><span class="s1">deprecate</span><span class="s3">(</span>
			<span class="s5">/**</span>
			 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
			 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ChunkGraph} the chunk graph</span>
			 <span class="s5">*/</span>
			<span class="s1">chunk </span><span class="s3">=&gt; {</span>
				<span class="s4">const </span><span class="s1">chunkGraph </span><span class="s3">= </span><span class="s1">chunkGraphForChunkMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s1">chunkGraph</span><span class="s3">)</span>
					<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
						<span class="s1">deprecateMessage </span><span class="s3">+</span>
							<span class="s2">&quot;There was no ChunkGraph assigned to the Chunk for backward-compat (Use the new API)&quot;</span>
					<span class="s3">);</span>
				<span class="s4">return </span><span class="s1">chunkGraph</span><span class="s3">;</span>
			<span class="s3">},</span>
			<span class="s1">deprecateMessage </span><span class="s3">+ </span><span class="s2">&quot;: Use new ChunkGraph API&quot;</span><span class="s3">,</span>
			<span class="s1">deprecationCode</span>
		<span class="s3">);</span>
		<span class="s1">deprecateGetChunkGraphForChunkMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">deprecateMessage</span><span class="s3">, </span><span class="s1">newFn</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">newFn</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s0">// TODO remove in webpack 6</span>
	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunkGraph} chunkGraph the chunk graph</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s4">static </span><span class="s1">setChunkGraphForChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">chunkGraph</span><span class="s3">) {</span>
		<span class="s1">chunkGraphForChunkMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">chunkGraph</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s0">// TODO remove in webpack 6</span>
	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Chunk} chunk the chunk</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s4">static </span><span class="s1">clearChunkGraphForChunk</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">) {</span>
		<span class="s1">chunkGraphForChunkMap</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">);</span>
	<span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">// TODO remove in webpack 6</span>
<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WeakMap&lt;Module, ChunkGraph&gt;} */</span>
<span class="s4">const </span><span class="s1">chunkGraphForModuleMap </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>

<span class="s0">// TODO remove in webpack 6</span>
<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WeakMap&lt;Chunk, ChunkGraph&gt;} */</span>
<span class="s4">const </span><span class="s1">chunkGraphForChunkMap </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>

<span class="s0">// TODO remove in webpack 6</span>
<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, (module: Module) =&gt; ChunkGraph&gt;} */</span>
<span class="s4">const </span><span class="s1">deprecateGetChunkGraphForModuleMap </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>

<span class="s0">// TODO remove in webpack 6</span>
<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, (chunk: Chunk) =&gt; ChunkGraph&gt;} */</span>
<span class="s4">const </span><span class="s1">deprecateGetChunkGraphForChunkMap </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>

<span class="s1">module</span><span class="s3">.</span><span class="s1">exports </span><span class="s3">= </span><span class="s1">ChunkGraph</span><span class="s3">;</span>
</pre>
</body>
</html>