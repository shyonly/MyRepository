<html>
<head>
<title>visitors.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
visitors.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;virtualTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;DEPRECATED_KEYS&quot;</span><span class="s0">,</span><span class="s1">&quot;DEPRECATED_ALIASES&quot;</span><span class="s0">,</span><span class="s1">&quot;FLIPPED_ALIAS_KEYS&quot;</span><span class="s0">,</span><span class="s1">&quot;TYPES&quot;</span><span class="s0">,</span><span class="s1">&quot;__internal__deprecationWarning&quot;</span><span class="s0">,</span><span class="s1">&quot;deprecationWarning&quot;</span><span class="s0">,</span><span class="s1">&quot;isVirtualType&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;isExplodedVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;visitor&quot;</span><span class="s0">,</span><span class="s1">&quot;_exploded&quot;</span><span class="s0">,</span><span class="s1">&quot;explode&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeType&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldIgnoreKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parts&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;fns&quot;</span><span class="s0">,</span><span class="s1">&quot;part&quot;</span><span class="s0">,</span><span class="s1">&quot;verify&quot;</span><span class="s0">,</span><span class="s1">&quot;__esModule&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureEntranceObjects&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureCallbackArrays&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapCheck&quot;</span><span class="s0">,</span><span class="s1">&quot;types&quot;</span><span class="s0">,</span><span class="s1">&quot;mergePair&quot;</span><span class="s0">,</span><span class="s1">&quot;aliases&quot;</span><span class="s0">,</span><span class="s1">&quot;deprecatedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;deprecatedAlias&quot;</span><span class="s0">,</span><span class="s1">&quot;alias&quot;</span><span class="s0">,</span><span class="s1">&quot;existing&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;_verified&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;validateVisitorMethods&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;visitors&quot;</span><span class="s0">,</span><span class="s1">&quot;visitorKey&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;merge&quot;</span><span class="s0">,</span><span class="s1">&quot;states&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapper&quot;</span><span class="s0">,</span><span class="s1">&quot;mergedVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;topVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapWithStateOrWrapper&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;typeVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;oldVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;newVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;phase&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;newFn&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;enter&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;dest&quot;</span><span class="s0">,</span><span class="s1">&quot;src&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/visitors.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import * as virtualTypes from </span><span class="s3">\&quot;</span><span class="s1">./path/lib/virtual-types.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Node } from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">DEPRECATED_KEYS,</span><span class="s3">\n  </span><span class="s1">DEPRECATED_ALIASES,</span><span class="s3">\n  </span><span class="s1">FLIPPED_ALIAS_KEYS,</span><span class="s3">\n  </span><span class="s1">TYPES,</span><span class="s3">\n  </span><span class="s1">__internal__deprecationWarning as deprecationWarning,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { ExplodedVisitor, NodePath, Visitor } from </span><span class="s3">\&quot;</span><span class="s1">./index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { ExplVisitNode, VisitNodeFunction, VisitPhase } from </span><span class="s3">\&quot;</span><span class="s1">./types.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">type VIRTUAL_TYPES = keyof typeof virtualTypes;</span><span class="s3">\n</span><span class="s1">function isVirtualType(type: string): type is VIRTUAL_TYPES {</span><span class="s3">\n  </span><span class="s1">return type in virtualTypes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export type VisitWrapper&lt;S = any&gt; = (</span><span class="s3">\n  </span><span class="s1">stateName: string | undefined,</span><span class="s3">\n  </span><span class="s1">visitorType: VisitPhase,</span><span class="s3">\n  </span><span class="s1">callback: VisitNodeFunction&lt;S, Node&gt;,</span><span class="s3">\n</span><span class="s1">) =&gt; VisitNodeFunction&lt;S, Node&gt;;</span><span class="s3">\n\n</span><span class="s1">export function isExplodedVisitor(</span><span class="s3">\n  </span><span class="s1">visitor: Visitor,</span><span class="s3">\n</span><span class="s1">): visitor is ExplodedVisitor {</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error _exploded is not defined on non-exploded Visitor</span><span class="s3">\n  </span><span class="s1">return visitor?._exploded;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* explode() will take a visitor object with all of the various shorthands</span><span class="s3">\n </span><span class="s1">* that we support, and validates &amp; normalizes it into a common format, ready</span><span class="s3">\n </span><span class="s1">* to be used in traversal</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The various shorthands are:</span><span class="s3">\n </span><span class="s1">* * `Identifier() { ... }` -&gt; `Identifier: { enter() { ... } }`</span><span class="s3">\n </span><span class="s1">* * `</span><span class="s3">\&quot;</span><span class="s1">Identifier|NumericLiteral</span><span class="s3">\&quot;</span><span class="s1">: { ... }` -&gt; `Identifier: { ... }, NumericLiteral: { ... }`</span><span class="s3">\n </span><span class="s1">* * Aliases in `@babel/types`: e.g. `Property: { ... }` -&gt; `ObjectProperty: { ... }, ClassProperty: { ... }`</span><span class="s3">\n </span><span class="s1">* Other normalizations are:</span><span class="s3">\n </span><span class="s1">* * Visitors of virtual types are wrapped, so that they are only visited when</span><span class="s3">\n </span><span class="s1">*   their dynamic check passes</span><span class="s3">\n </span><span class="s1">* * `enter` and `exit` functions are wrapped in arrays, to ease merging of</span><span class="s3">\n </span><span class="s1">*   visitors</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function explode&lt;S&gt;(visitor: Visitor&lt;S&gt;): ExplodedVisitor&lt;S&gt; {</span><span class="s3">\n  </span><span class="s1">if (isExplodedVisitor(visitor)) return visitor;</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error `visitor` will be cast to ExplodedVisitor by this function</span><span class="s3">\n  </span><span class="s1">visitor._exploded = true;</span><span class="s3">\n\n  </span><span class="s1">// normalise pipes</span><span class="s3">\n  </span><span class="s1">for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {</span><span class="s3">\n    </span><span class="s1">if (shouldIgnoreKey(nodeType)) continue;</span><span class="s3">\n\n    </span><span class="s1">const parts: Array&lt;string&gt; = nodeType.split(</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (parts.length === 1) continue;</span><span class="s3">\n\n    </span><span class="s1">const fns = visitor[nodeType];</span><span class="s3">\n    </span><span class="s1">delete visitor[nodeType];</span><span class="s3">\n\n    </span><span class="s1">for (const part of parts) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error part will be verified by `verify` later</span><span class="s3">\n      </span><span class="s1">visitor[part] = fns;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// verify data structure</span><span class="s3">\n  </span><span class="s1">verify(visitor);</span><span class="s3">\n\n  </span><span class="s1">// make sure there's no __esModule type since this is because we're using loose mode</span><span class="s3">\n  </span><span class="s1">// and it sets __esModule to be enumerable on all modules :(</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error ESModule interop</span><span class="s3">\n  </span><span class="s1">delete visitor.__esModule;</span><span class="s3">\n\n  </span><span class="s1">// ensure visitors are objects</span><span class="s3">\n  </span><span class="s1">ensureEntranceObjects(visitor);</span><span class="s3">\n\n  </span><span class="s1">// ensure enter/exit callbacks are arrays</span><span class="s3">\n  </span><span class="s1">ensureCallbackArrays(visitor);</span><span class="s3">\n\n  </span><span class="s1">// add type wrappers</span><span class="s3">\n  </span><span class="s1">for (const nodeType of Object.keys(visitor)) {</span><span class="s3">\n    </span><span class="s1">if (shouldIgnoreKey(nodeType)) continue;</span><span class="s3">\n\n    </span><span class="s1">if (!isVirtualType(nodeType)) continue;</span><span class="s3">\n\n    </span><span class="s1">// wrap all the functions</span><span class="s3">\n    </span><span class="s1">const fns = visitor[nodeType];</span><span class="s3">\n    </span><span class="s1">for (const type of Object.keys(fns)) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error normalised as VisitNodeObject</span><span class="s3">\n      </span><span class="s1">fns[type] = wrapCheck(nodeType, fns[type]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// clear it from the visitor</span><span class="s3">\n    </span><span class="s1">delete visitor[nodeType];</span><span class="s3">\n\n    </span><span class="s1">const types = virtualTypes[nodeType];</span><span class="s3">\n    </span><span class="s1">if (types !== null) {</span><span class="s3">\n      </span><span class="s1">for (const type of types) {</span><span class="s3">\n        </span><span class="s1">// merge the visitor if necessary or just put it back in</span><span class="s3">\n        </span><span class="s1">if (visitor[type]) {</span><span class="s3">\n          </span><span class="s1">mergePair(visitor[type], fns);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error Expression produces too complex union</span><span class="s3">\n          </span><span class="s1">visitor[type] = fns;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">mergePair(visitor, fns);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// add aliases</span><span class="s3">\n  </span><span class="s1">for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {</span><span class="s3">\n    </span><span class="s1">if (shouldIgnoreKey(nodeType)) continue;</span><span class="s3">\n\n    </span><span class="s1">let aliases = FLIPPED_ALIAS_KEYS[nodeType];</span><span class="s3">\n\n    </span><span class="s1">if (nodeType in DEPRECATED_KEYS) {</span><span class="s3">\n      </span><span class="s1">const deprecatedKey = DEPRECATED_KEYS[nodeType];</span><span class="s3">\n      </span><span class="s1">deprecationWarning(nodeType, deprecatedKey, </span><span class="s3">\&quot;</span><span class="s1">Visitor </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">aliases = [deprecatedKey];</span><span class="s3">\n    </span><span class="s1">} else if (nodeType in DEPRECATED_ALIASES) {</span><span class="s3">\n      </span><span class="s1">const deprecatedAlias =</span><span class="s3">\n        </span><span class="s1">DEPRECATED_ALIASES[nodeType as keyof typeof DEPRECATED_ALIASES];</span><span class="s3">\n      </span><span class="s1">deprecationWarning(nodeType, deprecatedAlias, </span><span class="s3">\&quot;</span><span class="s1">Visitor </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!aliases) continue;</span><span class="s3">\n\n    </span><span class="s1">const fns = visitor[nodeType];</span><span class="s3">\n    </span><span class="s1">// clear it from the visitor</span><span class="s3">\n    </span><span class="s1">delete visitor[nodeType];</span><span class="s3">\n\n    </span><span class="s1">for (const alias of aliases) {</span><span class="s3">\n      </span><span class="s1">const existing = visitor[alias];</span><span class="s3">\n      </span><span class="s1">if (existing) {</span><span class="s3">\n        </span><span class="s1">mergePair(existing, fns);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error Expression produces a union type that is too complex to represent.</span><span class="s3">\n        </span><span class="s1">visitor[alias] = { ...fns };</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const nodeType of Object.keys(visitor)) {</span><span class="s3">\n    </span><span class="s1">if (shouldIgnoreKey(nodeType)) continue;</span><span class="s3">\n\n    </span><span class="s1">ensureCallbackArrays(</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error nodeType must present in visitor after previous validations</span><span class="s3">\n      </span><span class="s1">visitor[nodeType],</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error explosion has been performed</span><span class="s3">\n  </span><span class="s1">return visitor as ExplodedVisitor;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function verify(visitor: Visitor) {</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error _verified is not defined on non-verified Visitor.</span><span class="s3">\n  </span><span class="s1">// TODO: unify _verified and _exploded.</span><span class="s3">\n  </span><span class="s1">if (visitor._verified) return;</span><span class="s3">\n\n  </span><span class="s1">if (typeof visitor === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">You passed `traverse()` a function when it expected a visitor object, </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        \&quot;</span><span class="s1">are you sure you didn't mean `{ enter: Function }`?</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {</span><span class="s3">\n    </span><span class="s1">if (nodeType === </span><span class="s3">\&quot;</span><span class="s1">enter</span><span class="s3">\&quot; </span><span class="s1">|| nodeType === </span><span class="s3">\&quot;</span><span class="s1">exit</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">validateVisitorMethods(nodeType, visitor[nodeType]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (shouldIgnoreKey(nodeType)) continue;</span><span class="s3">\n\n    </span><span class="s1">if (TYPES.indexOf(nodeType) &lt; 0) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`You gave us a visitor for the node type ${nodeType} but it's not a valid type`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const visitors = visitor[nodeType];</span><span class="s3">\n    </span><span class="s1">if (typeof visitors === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">for (const visitorKey of Object.keys(visitors)) {</span><span class="s3">\n        </span><span class="s1">if (visitorKey === </span><span class="s3">\&quot;</span><span class="s1">enter</span><span class="s3">\&quot; </span><span class="s1">|| visitorKey === </span><span class="s3">\&quot;</span><span class="s1">exit</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// verify that it just contains functions</span><span class="s3">\n          </span><span class="s1">validateVisitorMethods(</span><span class="s3">\n            </span><span class="s1">`${nodeType}.${visitorKey}`,</span><span class="s3">\n            </span><span class="s1">visitors[visitorKey],</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            \&quot;</span><span class="s1">You passed `traverse()` a visitor object with the property </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n              </span><span class="s1">`${nodeType} that has the invalid property ${visitorKey}`,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error _verified is not defined on non-verified Visitor.</span><span class="s3">\n  </span><span class="s1">// TODO: unify _verified and _exploded.</span><span class="s3">\n  </span><span class="s1">visitor._verified = true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function validateVisitorMethods(</span><span class="s3">\n  </span><span class="s1">path: string,</span><span class="s3">\n  </span><span class="s1">val: any,</span><span class="s3">\n</span><span class="s1">): asserts val is Function | Function[] {</span><span class="s3">\n  </span><span class="s1">const fns = [].concat(val);</span><span class="s3">\n  </span><span class="s1">for (const fn of fns) {</span><span class="s3">\n    </span><span class="s1">if (typeof fn !== </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError(</span><span class="s3">\n        </span><span class="s1">`Non-function found defined in ${path} with type ${typeof fn}`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function merge&lt;State&gt;(</span><span class="s3">\n  </span><span class="s1">visitors: Visitor&lt;State&gt;[],</span><span class="s3">\n</span><span class="s1">): ExplodedVisitor&lt;State&gt;;</span><span class="s3">\n</span><span class="s1">export function merge(</span><span class="s3">\n  </span><span class="s1">visitors: Visitor&lt;unknown&gt;[],</span><span class="s3">\n  </span><span class="s1">states?: any[],</span><span class="s3">\n  </span><span class="s1">wrapper?: Function | null,</span><span class="s3">\n</span><span class="s1">): ExplodedVisitor&lt;unknown&gt;;</span><span class="s3">\n</span><span class="s1">export function merge(</span><span class="s3">\n  </span><span class="s1">visitors: any[],</span><span class="s3">\n  </span><span class="s1">states: any[] = [],</span><span class="s3">\n  </span><span class="s1">wrapper?: VisitWrapper | null,</span><span class="s3">\n</span><span class="s1">): ExplodedVisitor {</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error don't bother with internal flags so it can work with earlier @babel/core validations</span><span class="s3">\n  </span><span class="s1">const mergedVisitor: ExplodedVisitor = {};</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; visitors.length; i++) {</span><span class="s3">\n    </span><span class="s1">const visitor = explode(visitors[i]);</span><span class="s3">\n    </span><span class="s1">const state = states[i];</span><span class="s3">\n\n    </span><span class="s1">let topVisitor: ExplVisitNode&lt;unknown, Node&gt; = visitor;</span><span class="s3">\n    </span><span class="s1">if (state || wrapper) {</span><span class="s3">\n      </span><span class="s1">topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mergePair(mergedVisitor, topVisitor);</span><span class="s3">\n\n    </span><span class="s1">for (const key of Object.keys(visitor) as (keyof ExplodedVisitor)[]) {</span><span class="s3">\n      </span><span class="s1">if (shouldIgnoreKey(key)) continue;</span><span class="s3">\n\n      </span><span class="s1">let typeVisitor = visitor[key];</span><span class="s3">\n\n      </span><span class="s1">// if we have state or wrapper then overload the callbacks to take it</span><span class="s3">\n      </span><span class="s1">if (state || wrapper) {</span><span class="s3">\n        </span><span class="s1">typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const nodeVisitor = (mergedVisitor[key] ||= {});</span><span class="s3">\n      </span><span class="s1">mergePair(nodeVisitor, typeVisitor);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">...mergedVisitor,</span><span class="s3">\n      </span><span class="s1">_exploded: true,</span><span class="s3">\n      </span><span class="s1">_verified: true,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return mergedVisitor;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function wrapWithStateOrWrapper&lt;State&gt;(</span><span class="s3">\n  </span><span class="s1">oldVisitor: ExplVisitNode&lt;State, Node&gt;,</span><span class="s3">\n  </span><span class="s1">state: State | null,</span><span class="s3">\n  </span><span class="s1">wrapper?: VisitWrapper&lt;State&gt; | null,</span><span class="s3">\n</span><span class="s1">): ExplVisitNode&lt;State, Node&gt; {</span><span class="s3">\n  </span><span class="s1">const newVisitor: ExplVisitNode&lt;State, Node&gt; = {};</span><span class="s3">\n\n  </span><span class="s1">for (const phase of [</span><span class="s3">\&quot;</span><span class="s1">enter</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">exit</span><span class="s3">\&quot;</span><span class="s1">] as VisitPhase[]) {</span><span class="s3">\n    </span><span class="s1">let fns = oldVisitor[phase];</span><span class="s3">\n\n    </span><span class="s1">// not an enter/exit array of callbacks</span><span class="s3">\n    </span><span class="s1">if (!Array.isArray(fns)) continue;</span><span class="s3">\n\n    </span><span class="s1">fns = fns.map(function (fn) {</span><span class="s3">\n      </span><span class="s1">let newFn = fn;</span><span class="s3">\n\n      </span><span class="s1">if (state) {</span><span class="s3">\n        </span><span class="s1">newFn = function (path: NodePath) {</span><span class="s3">\n          </span><span class="s1">fn.call(state, path, state);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (wrapper) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error Fixme: actually PluginPass.key (aka pluginAlias)?</span><span class="s3">\n        </span><span class="s1">newFn = wrapper(state?.key, phase, newFn);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Override toString in case this function is printed, we want to print the wrapped function, same as we do in `wrapCheck`</span><span class="s3">\n      </span><span class="s1">if (newFn !== fn) {</span><span class="s3">\n        </span><span class="s1">newFn.toString = () =&gt; fn.toString();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return newFn;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">newVisitor[phase] = fns;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return newVisitor;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function ensureEntranceObjects(obj: Visitor) {</span><span class="s3">\n  </span><span class="s1">for (const key of Object.keys(obj) as (keyof Visitor)[]) {</span><span class="s3">\n    </span><span class="s1">if (shouldIgnoreKey(key)) continue;</span><span class="s3">\n\n    </span><span class="s1">const fns = obj[key];</span><span class="s3">\n    </span><span class="s1">if (typeof fns === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error: Expression produces a union type that is too complex to represent.</span><span class="s3">\n      </span><span class="s1">obj[key] = { enter: fns };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function ensureCallbackArrays(obj: Visitor) {</span><span class="s3">\n  </span><span class="s1">if (obj.enter &amp;&amp; !Array.isArray(obj.enter)) obj.enter = [obj.enter];</span><span class="s3">\n  </span><span class="s1">if (obj.exit &amp;&amp; !Array.isArray(obj.exit)) obj.exit = [obj.exit];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function wrapCheck(nodeType: VIRTUAL_TYPES, fn: Function) {</span><span class="s3">\n  </span><span class="s1">const newFn = function (this: unknown, path: NodePath) {</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error: Expression produces a union type that is too complex to represent.</span><span class="s3">\n    </span><span class="s1">if (path[`is${nodeType}`]()) {</span><span class="s3">\n      </span><span class="s1">return fn.apply(this, arguments);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">newFn.toString = () =&gt; fn.toString();</span><span class="s3">\n  </span><span class="s1">return newFn;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function shouldIgnoreKey(</span><span class="s3">\n  </span><span class="s1">key: string,</span><span class="s3">\n</span><span class="s1">): key is</span><span class="s3">\n  </span><span class="s1">| `_${string}`</span><span class="s3">\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">enter</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">exit</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">shouldSkip</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">denylist</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">noScope</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">skipKeys</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">blacklist</span><span class="s3">\&quot; </span><span class="s1">{</span><span class="s3">\n  </span><span class="s1">// internal/hidden key</span><span class="s3">\n  </span><span class="s1">if (key[0] === </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">) return true;</span><span class="s3">\n\n  </span><span class="s1">// ignore function keys</span><span class="s3">\n  </span><span class="s1">if (key === </span><span class="s3">\&quot;</span><span class="s1">enter</span><span class="s3">\&quot; </span><span class="s1">|| key === </span><span class="s3">\&quot;</span><span class="s1">exit</span><span class="s3">\&quot; </span><span class="s1">|| key === </span><span class="s3">\&quot;</span><span class="s1">shouldSkip</span><span class="s3">\&quot;</span><span class="s1">) return true;</span><span class="s3">\n\n  </span><span class="s1">// ignore other options</span><span class="s3">\n  </span><span class="s1">if (key === </span><span class="s3">\&quot;</span><span class="s1">denylist</span><span class="s3">\&quot; </span><span class="s1">|| key === </span><span class="s3">\&quot;</span><span class="s1">noScope</span><span class="s3">\&quot; </span><span class="s1">|| key === </span><span class="s3">\&quot;</span><span class="s1">skipKeys</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">if (key === </span><span class="s3">\&quot;</span><span class="s1">blacklist</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n</span><span class="s1">function mergePair(</span><span class="s3">\n  </span><span class="s1">dest: ExplVisitNode&lt;unknown, Node&gt;,</span><span class="s3">\n  </span><span class="s1">src: ExplVisitNode&lt;unknown, Node&gt;,</span><span class="s3">\n</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function mergePair(dest: any, src: any) {</span><span class="s3">\n  </span><span class="s1">for (const phase of [</span><span class="s3">\&quot;</span><span class="s1">enter</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">exit</span><span class="s3">\&quot;</span><span class="s1">] as VisitPhase[]) {</span><span class="s3">\n    </span><span class="s1">if (!src[phase]) continue;</span><span class="s3">\n    </span><span class="s1">dest[phase] = [].concat(dest[phase] || [], src[phase]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>