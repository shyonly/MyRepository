<html>
<head>
<title>aesCipherSuites.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #67a37c; font-style: italic;}
.s2 { color: #bcbec4;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
.s7 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
aesCipherSuites.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* A Javascript implementation of AES Cipher Suites for TLS.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Dave Longley</span>
 <span class="s0">*</span>
 <span class="s0">* Copyright (c) 2009-2015 Digital Bazaar, Inc.</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">forge </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s5">'./forge'</span><span class="s4">);</span>
<span class="s2">require</span><span class="s4">(</span><span class="s5">'./aes'</span><span class="s4">);</span>
<span class="s2">require</span><span class="s4">(</span><span class="s5">'./tls'</span><span class="s4">);</span>

<span class="s3">var </span><span class="s2">tls </span><span class="s4">= </span><span class="s2">module</span><span class="s4">.</span><span class="s2">exports </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">tls</span><span class="s4">;</span>

<span class="s0">/**</span>
 <span class="s0">* Supported cipher suites.</span>
 <span class="s0">*/</span>
<span class="s2">tls</span><span class="s4">.</span><span class="s2">CipherSuites</span><span class="s4">[</span><span class="s5">'TLS_RSA_WITH_AES_128_CBC_SHA'</span><span class="s4">] = {</span>
  <span class="s2">id</span><span class="s4">: [</span><span class="s6">0x00</span><span class="s4">, </span><span class="s6">0x2f</span><span class="s4">],</span>
  <span class="s2">name</span><span class="s4">: </span><span class="s5">'TLS_RSA_WITH_AES_128_CBC_SHA'</span><span class="s4">,</span>
  <span class="s2">initSecurityParameters</span><span class="s4">: </span><span class="s3">function</span><span class="s4">(</span><span class="s2">sp</span><span class="s4">) {</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">bulk_cipher_algorithm </span><span class="s4">= </span><span class="s2">tls</span><span class="s4">.</span><span class="s2">BulkCipherAlgorithm</span><span class="s4">.</span><span class="s2">aes</span><span class="s4">;</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">cipher_type </span><span class="s4">= </span><span class="s2">tls</span><span class="s4">.</span><span class="s2">CipherType</span><span class="s4">.</span><span class="s2">block</span><span class="s4">;</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">enc_key_length </span><span class="s4">= </span><span class="s6">16</span><span class="s4">;</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">block_length </span><span class="s4">= </span><span class="s6">16</span><span class="s4">;</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">fixed_iv_length </span><span class="s4">= </span><span class="s6">16</span><span class="s4">;</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">record_iv_length </span><span class="s4">= </span><span class="s6">16</span><span class="s4">;</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">mac_algorithm </span><span class="s4">= </span><span class="s2">tls</span><span class="s4">.</span><span class="s2">MACAlgorithm</span><span class="s4">.</span><span class="s2">hmac_sha1</span><span class="s4">;</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">mac_length </span><span class="s4">= </span><span class="s6">20</span><span class="s4">;</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">mac_key_length </span><span class="s4">= </span><span class="s6">20</span><span class="s4">;</span>
  <span class="s4">},</span>
  <span class="s2">initConnectionState</span><span class="s4">: </span><span class="s2">initConnectionState</span>
<span class="s4">};</span>
<span class="s2">tls</span><span class="s4">.</span><span class="s2">CipherSuites</span><span class="s4">[</span><span class="s5">'TLS_RSA_WITH_AES_256_CBC_SHA'</span><span class="s4">] = {</span>
  <span class="s2">id</span><span class="s4">: [</span><span class="s6">0x00</span><span class="s4">, </span><span class="s6">0x35</span><span class="s4">],</span>
  <span class="s2">name</span><span class="s4">: </span><span class="s5">'TLS_RSA_WITH_AES_256_CBC_SHA'</span><span class="s4">,</span>
  <span class="s2">initSecurityParameters</span><span class="s4">: </span><span class="s3">function</span><span class="s4">(</span><span class="s2">sp</span><span class="s4">) {</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">bulk_cipher_algorithm </span><span class="s4">= </span><span class="s2">tls</span><span class="s4">.</span><span class="s2">BulkCipherAlgorithm</span><span class="s4">.</span><span class="s2">aes</span><span class="s4">;</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">cipher_type </span><span class="s4">= </span><span class="s2">tls</span><span class="s4">.</span><span class="s2">CipherType</span><span class="s4">.</span><span class="s2">block</span><span class="s4">;</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">enc_key_length </span><span class="s4">= </span><span class="s6">32</span><span class="s4">;</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">block_length </span><span class="s4">= </span><span class="s6">16</span><span class="s4">;</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">fixed_iv_length </span><span class="s4">= </span><span class="s6">16</span><span class="s4">;</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">record_iv_length </span><span class="s4">= </span><span class="s6">16</span><span class="s4">;</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">mac_algorithm </span><span class="s4">= </span><span class="s2">tls</span><span class="s4">.</span><span class="s2">MACAlgorithm</span><span class="s4">.</span><span class="s2">hmac_sha1</span><span class="s4">;</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">mac_length </span><span class="s4">= </span><span class="s6">20</span><span class="s4">;</span>
    <span class="s2">sp</span><span class="s4">.</span><span class="s2">mac_key_length </span><span class="s4">= </span><span class="s6">20</span><span class="s4">;</span>
  <span class="s4">},</span>
  <span class="s2">initConnectionState</span><span class="s4">: </span><span class="s2">initConnectionState</span>
<span class="s4">};</span>

<span class="s3">function </span><span class="s2">initConnectionState</span><span class="s4">(</span><span class="s2">state</span><span class="s4">, </span><span class="s2">c</span><span class="s4">, </span><span class="s2">sp</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">client </span><span class="s4">= (</span><span class="s2">c</span><span class="s4">.</span><span class="s2">entity </span><span class="s4">=== </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">tls</span><span class="s4">.</span><span class="s2">ConnectionEnd</span><span class="s4">.</span><span class="s2">client</span><span class="s4">);</span>

  <span class="s7">// cipher setup</span>
  <span class="s2">state</span><span class="s4">.</span><span class="s2">read</span><span class="s4">.</span><span class="s2">cipherState </span><span class="s4">= {</span>
    <span class="s2">init</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">cipher</span><span class="s4">: </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">createDecipher</span><span class="s4">(</span><span class="s5">'AES-CBC'</span><span class="s4">, </span><span class="s2">client </span><span class="s4">?</span>
      <span class="s2">sp</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">.</span><span class="s2">server_write_key </span><span class="s4">: </span><span class="s2">sp</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">.</span><span class="s2">client_write_key</span><span class="s4">),</span>
    <span class="s2">iv</span><span class="s4">: </span><span class="s2">client </span><span class="s4">? </span><span class="s2">sp</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">.</span><span class="s2">server_write_IV </span><span class="s4">: </span><span class="s2">sp</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">.</span><span class="s2">client_write_IV</span>
  <span class="s4">};</span>
  <span class="s2">state</span><span class="s4">.</span><span class="s2">write</span><span class="s4">.</span><span class="s2">cipherState </span><span class="s4">= {</span>
    <span class="s2">init</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">cipher</span><span class="s4">: </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">createCipher</span><span class="s4">(</span><span class="s5">'AES-CBC'</span><span class="s4">, </span><span class="s2">client </span><span class="s4">?</span>
      <span class="s2">sp</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">.</span><span class="s2">client_write_key </span><span class="s4">: </span><span class="s2">sp</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">.</span><span class="s2">server_write_key</span><span class="s4">),</span>
    <span class="s2">iv</span><span class="s4">: </span><span class="s2">client </span><span class="s4">? </span><span class="s2">sp</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">.</span><span class="s2">client_write_IV </span><span class="s4">: </span><span class="s2">sp</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">.</span><span class="s2">server_write_IV</span>
  <span class="s4">};</span>
  <span class="s2">state</span><span class="s4">.</span><span class="s2">read</span><span class="s4">.</span><span class="s2">cipherFunction </span><span class="s4">= </span><span class="s2">decrypt_aes_cbc_sha1</span><span class="s4">;</span>
  <span class="s2">state</span><span class="s4">.</span><span class="s2">write</span><span class="s4">.</span><span class="s2">cipherFunction </span><span class="s4">= </span><span class="s2">encrypt_aes_cbc_sha1</span><span class="s4">;</span>

  <span class="s7">// MAC setup</span>
  <span class="s2">state</span><span class="s4">.</span><span class="s2">read</span><span class="s4">.</span><span class="s2">macLength </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">write</span><span class="s4">.</span><span class="s2">macLength </span><span class="s4">= </span><span class="s2">sp</span><span class="s4">.</span><span class="s2">mac_length</span><span class="s4">;</span>
  <span class="s2">state</span><span class="s4">.</span><span class="s2">read</span><span class="s4">.</span><span class="s2">macFunction </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">write</span><span class="s4">.</span><span class="s2">macFunction </span><span class="s4">= </span><span class="s2">tls</span><span class="s4">.</span><span class="s2">hmac_sha1</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Encrypts the TLSCompressed record into a TLSCipherText record using AES</span>
 <span class="s0">* in CBC mode.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">record the TLSCompressed record to encrypt.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">s the ConnectionState to use.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">true on success, false on failure.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">encrypt_aes_cbc_sha1</span><span class="s4">(</span><span class="s2">record</span><span class="s4">, </span><span class="s2">s</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">rval </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>

  <span class="s7">// append MAC to fragment, update sequence number</span>
  <span class="s3">var </span><span class="s2">mac </span><span class="s4">= </span><span class="s2">s</span><span class="s4">.</span><span class="s2">macFunction</span><span class="s4">(</span><span class="s2">s</span><span class="s4">.</span><span class="s2">macKey</span><span class="s4">, </span><span class="s2">s</span><span class="s4">.</span><span class="s2">sequenceNumber</span><span class="s4">, </span><span class="s2">record</span><span class="s4">);</span>
  <span class="s2">record</span><span class="s4">.</span><span class="s2">fragment</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s2">mac</span><span class="s4">);</span>
  <span class="s2">s</span><span class="s4">.</span><span class="s2">updateSequenceNumber</span><span class="s4">();</span>

  <span class="s7">// TLS 1.1+ use an explicit IV every time to protect against CBC attacks</span>
  <span class="s3">var </span><span class="s2">iv</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">record</span><span class="s4">.</span><span class="s2">version</span><span class="s4">.</span><span class="s2">minor </span><span class="s4">=== </span><span class="s2">tls</span><span class="s4">.</span><span class="s2">Versions</span><span class="s4">.</span><span class="s2">TLS_1_0</span><span class="s4">.</span><span class="s2">minor</span><span class="s4">) {</span>
    <span class="s7">// use the pre-generated IV when initializing for TLS 1.0, otherwise use</span>
    <span class="s7">// the residue from the previous encryption</span>
    <span class="s2">iv </span><span class="s4">= </span><span class="s2">s</span><span class="s4">.</span><span class="s2">cipherState</span><span class="s4">.</span><span class="s2">init </span><span class="s4">? </span><span class="s3">null </span><span class="s4">: </span><span class="s2">s</span><span class="s4">.</span><span class="s2">cipherState</span><span class="s4">.</span><span class="s2">iv</span><span class="s4">;</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s2">iv </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">random</span><span class="s4">.</span><span class="s2">getBytesSync</span><span class="s4">(</span><span class="s6">16</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s2">s</span><span class="s4">.</span><span class="s2">cipherState</span><span class="s4">.</span><span class="s2">init </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>

  <span class="s7">// start cipher</span>
  <span class="s3">var </span><span class="s2">cipher </span><span class="s4">= </span><span class="s2">s</span><span class="s4">.</span><span class="s2">cipherState</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">;</span>
  <span class="s2">cipher</span><span class="s4">.</span><span class="s2">start</span><span class="s4">({</span><span class="s2">iv</span><span class="s4">: </span><span class="s2">iv</span><span class="s4">});</span>

  <span class="s7">// TLS 1.1+ write IV into output</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">record</span><span class="s4">.</span><span class="s2">version</span><span class="s4">.</span><span class="s2">minor </span><span class="s4">&gt;= </span><span class="s2">tls</span><span class="s4">.</span><span class="s2">Versions</span><span class="s4">.</span><span class="s2">TLS_1_1</span><span class="s4">.</span><span class="s2">minor</span><span class="s4">) {</span>
    <span class="s2">cipher</span><span class="s4">.</span><span class="s2">output</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s2">iv</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s7">// do encryption (default padding is appropriate)</span>
  <span class="s2">cipher</span><span class="s4">.</span><span class="s2">update</span><span class="s4">(</span><span class="s2">record</span><span class="s4">.</span><span class="s2">fragment</span><span class="s4">);</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">finish</span><span class="s4">(</span><span class="s2">encrypt_aes_cbc_sha1_padding</span><span class="s4">)) {</span>
    <span class="s7">// set record fragment to encrypted output</span>
    <span class="s2">record</span><span class="s4">.</span><span class="s2">fragment </span><span class="s4">= </span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">output</span><span class="s4">;</span>
    <span class="s2">record</span><span class="s4">.</span><span class="s2">length </span><span class="s4">= </span><span class="s2">record</span><span class="s4">.</span><span class="s2">fragment</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
    <span class="s2">rval </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s3">return </span><span class="s2">rval</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Handles padding for aes_cbc_sha1 in encrypt mode.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">blockSize the block size.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">input the input buffer.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">decrypt true in decrypt mode, false in encrypt mode.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">true on success, false on failure.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">encrypt_aes_cbc_sha1_padding</span><span class="s4">(</span><span class="s2">blockSize</span><span class="s4">, </span><span class="s2">input</span><span class="s4">, </span><span class="s2">decrypt</span><span class="s4">) {</span>
  <span class="s7">/* The encrypted data length (TLSCiphertext.length) is one more than the sum 
   of SecurityParameters.block_length, TLSCompressed.length, 
   SecurityParameters.mac_length, and padding_length. 
 
   The padding may be any length up to 255 bytes long, as long as it results in 
   the TLSCiphertext.length being an integral multiple of the block length. 
   Lengths longer than necessary might be desirable to frustrate attacks on a 
   protocol based on analysis of the lengths of exchanged messages. Each uint8 
   in the padding data vector must be filled with the padding length value. 
 
   The padding length should be such that the total size of the 
   GenericBlockCipher structure is a multiple of the cipher's block length. 
   Legal values range from zero to 255, inclusive. This length specifies the 
   length of the padding field exclusive of the padding_length field itself. 
 
   This is slightly different from PKCS#7 because the padding value is 1 
   less than the actual number of padding bytes if you include the 
   padding_length uint8 itself as a padding byte. */</span>
  <span class="s3">if</span><span class="s4">(!</span><span class="s2">decrypt</span><span class="s4">) {</span>
    <span class="s7">// get the number of padding bytes required to reach the blockSize and</span>
    <span class="s7">// subtract 1 for the padding value (to make room for the padding_length</span>
    <span class="s7">// uint8)</span>
    <span class="s3">var </span><span class="s2">padding </span><span class="s4">= </span><span class="s2">blockSize </span><span class="s4">- (</span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() % </span><span class="s2">blockSize</span><span class="s4">);</span>
    <span class="s2">input</span><span class="s4">.</span><span class="s2">fillWithByte</span><span class="s4">(</span><span class="s2">padding </span><span class="s4">- </span><span class="s6">1</span><span class="s4">, </span><span class="s2">padding</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s3">return true</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Handles padding for aes_cbc_sha1 in decrypt mode.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">blockSize the block size.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">output the output buffer.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">decrypt true in decrypt mode, false in encrypt mode.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">true on success, false on failure.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">decrypt_aes_cbc_sha1_padding</span><span class="s4">(</span><span class="s2">blockSize</span><span class="s4">, </span><span class="s2">output</span><span class="s4">, </span><span class="s2">decrypt</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">rval </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">decrypt</span><span class="s4">) {</span>
    <span class="s7">/* The last byte in the output specifies the number of padding bytes not 
      including itself. Each of the padding bytes has the same value as that 
      last byte (known as the padding_length). Here we check all padding 
      bytes to ensure they have the value of padding_length even if one of 
      them is bad in order to ward-off timing attacks. */</span>
    <span class="s3">var </span><span class="s2">len </span><span class="s4">= </span><span class="s2">output</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
    <span class="s3">var </span><span class="s2">paddingLength </span><span class="s4">= </span><span class="s2">output</span><span class="s4">.</span><span class="s2">last</span><span class="s4">();</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s2">len </span><span class="s4">- </span><span class="s6">1 </span><span class="s4">- </span><span class="s2">paddingLength</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">len </span><span class="s4">- </span><span class="s6">1</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s2">rval </span><span class="s4">= </span><span class="s2">rval </span><span class="s4">&amp;&amp; (</span><span class="s2">output</span><span class="s4">.</span><span class="s2">at</span><span class="s4">(</span><span class="s2">i</span><span class="s4">) == </span><span class="s2">paddingLength</span><span class="s4">);</span>
    <span class="s4">}</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">rval</span><span class="s4">) {</span>
      <span class="s7">// trim off padding bytes and last padding length byte</span>
      <span class="s2">output</span><span class="s4">.</span><span class="s2">truncate</span><span class="s4">(</span><span class="s2">paddingLength </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">);</span>
    <span class="s4">}</span>
  <span class="s4">}</span>
  <span class="s3">return </span><span class="s2">rval</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Decrypts a TLSCipherText record into a TLSCompressed record using</span>
 <span class="s0">* AES in CBC mode.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">record the TLSCipherText record to decrypt.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">s the ConnectionState to use.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">true on success, false on failure.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">decrypt_aes_cbc_sha1</span><span class="s4">(</span><span class="s2">record</span><span class="s4">, </span><span class="s2">s</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">rval </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>

  <span class="s3">var </span><span class="s2">iv</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">record</span><span class="s4">.</span><span class="s2">version</span><span class="s4">.</span><span class="s2">minor </span><span class="s4">=== </span><span class="s2">tls</span><span class="s4">.</span><span class="s2">Versions</span><span class="s4">.</span><span class="s2">TLS_1_0</span><span class="s4">.</span><span class="s2">minor</span><span class="s4">) {</span>
    <span class="s7">// use pre-generated IV when initializing for TLS 1.0, otherwise use the</span>
    <span class="s7">// residue from the previous decryption</span>
    <span class="s2">iv </span><span class="s4">= </span><span class="s2">s</span><span class="s4">.</span><span class="s2">cipherState</span><span class="s4">.</span><span class="s2">init </span><span class="s4">? </span><span class="s3">null </span><span class="s4">: </span><span class="s2">s</span><span class="s4">.</span><span class="s2">cipherState</span><span class="s4">.</span><span class="s2">iv</span><span class="s4">;</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s7">// TLS 1.1+ use an explicit IV every time to protect against CBC attacks</span>
    <span class="s7">// that is appended to the record fragment</span>
    <span class="s2">iv </span><span class="s4">= </span><span class="s2">record</span><span class="s4">.</span><span class="s2">fragment</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span><span class="s6">16</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s2">s</span><span class="s4">.</span><span class="s2">cipherState</span><span class="s4">.</span><span class="s2">init </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>

  <span class="s7">// start cipher</span>
  <span class="s3">var </span><span class="s2">cipher </span><span class="s4">= </span><span class="s2">s</span><span class="s4">.</span><span class="s2">cipherState</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">;</span>
  <span class="s2">cipher</span><span class="s4">.</span><span class="s2">start</span><span class="s4">({</span><span class="s2">iv</span><span class="s4">: </span><span class="s2">iv</span><span class="s4">});</span>

  <span class="s7">// do decryption</span>
  <span class="s2">cipher</span><span class="s4">.</span><span class="s2">update</span><span class="s4">(</span><span class="s2">record</span><span class="s4">.</span><span class="s2">fragment</span><span class="s4">);</span>
  <span class="s2">rval </span><span class="s4">= </span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">finish</span><span class="s4">(</span><span class="s2">decrypt_aes_cbc_sha1_padding</span><span class="s4">);</span>

  <span class="s7">// even if decryption fails, keep going to minimize timing attacks</span>

  <span class="s7">// decrypted data:</span>
  <span class="s7">// first (len - 20) bytes = application data</span>
  <span class="s7">// last 20 bytes          = MAC</span>
  <span class="s3">var </span><span class="s2">macLen </span><span class="s4">= </span><span class="s2">s</span><span class="s4">.</span><span class="s2">macLength</span><span class="s4">;</span>

  <span class="s7">// create a random MAC to check against should the mac length check fail</span>
  <span class="s7">// Note: do this regardless of the failure to keep timing consistent</span>
  <span class="s3">var </span><span class="s2">mac </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">random</span><span class="s4">.</span><span class="s2">getBytesSync</span><span class="s4">(</span><span class="s2">macLen</span><span class="s4">);</span>

  <span class="s7">// get fragment and mac</span>
  <span class="s3">var </span><span class="s2">len </span><span class="s4">= </span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">output</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">len </span><span class="s4">&gt;= </span><span class="s2">macLen</span><span class="s4">) {</span>
    <span class="s2">record</span><span class="s4">.</span><span class="s2">fragment </span><span class="s4">= </span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">output</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span><span class="s2">len </span><span class="s4">- </span><span class="s2">macLen</span><span class="s4">);</span>
    <span class="s2">mac </span><span class="s4">= </span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">output</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span><span class="s2">macLen</span><span class="s4">);</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s7">// bad data, but get bytes anyway to try to keep timing consistent</span>
    <span class="s2">record</span><span class="s4">.</span><span class="s2">fragment </span><span class="s4">= </span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">output</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">();</span>
  <span class="s4">}</span>
  <span class="s2">record</span><span class="s4">.</span><span class="s2">fragment </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">record</span><span class="s4">.</span><span class="s2">fragment</span><span class="s4">);</span>
  <span class="s2">record</span><span class="s4">.</span><span class="s2">length </span><span class="s4">= </span><span class="s2">record</span><span class="s4">.</span><span class="s2">fragment</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>

  <span class="s7">// see if data integrity checks out, update sequence number</span>
  <span class="s3">var </span><span class="s2">mac2 </span><span class="s4">= </span><span class="s2">s</span><span class="s4">.</span><span class="s2">macFunction</span><span class="s4">(</span><span class="s2">s</span><span class="s4">.</span><span class="s2">macKey</span><span class="s4">, </span><span class="s2">s</span><span class="s4">.</span><span class="s2">sequenceNumber</span><span class="s4">, </span><span class="s2">record</span><span class="s4">);</span>
  <span class="s2">s</span><span class="s4">.</span><span class="s2">updateSequenceNumber</span><span class="s4">();</span>
  <span class="s2">rval </span><span class="s4">= </span><span class="s2">compareMacs</span><span class="s4">(</span><span class="s2">s</span><span class="s4">.</span><span class="s2">macKey</span><span class="s4">, </span><span class="s2">mac</span><span class="s4">, </span><span class="s2">mac2</span><span class="s4">) &amp;&amp; </span><span class="s2">rval</span><span class="s4">;</span>
  <span class="s3">return </span><span class="s2">rval</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Safely compare two MACs. This function will compare two MACs in a way</span>
 <span class="s0">* that protects against timing attacks.</span>
 <span class="s0">*</span>
 <span class="s0">* TODO: Expose elsewhere as a utility API.</span>
 <span class="s0">*</span>
 <span class="s0">* See: https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/february/double-hmac-verification/</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">key the MAC key to use.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">mac1 as a binary-encoded string of bytes.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">mac2 as a binary-encoded string of bytes.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">true if the MACs are the same, false if not.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">compareMacs</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, </span><span class="s2">mac1</span><span class="s4">, </span><span class="s2">mac2</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">hmac </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">hmac</span><span class="s4">.</span><span class="s2">create</span><span class="s4">();</span>

  <span class="s2">hmac</span><span class="s4">.</span><span class="s2">start</span><span class="s4">(</span><span class="s5">'SHA1'</span><span class="s4">, </span><span class="s2">key</span><span class="s4">);</span>
  <span class="s2">hmac</span><span class="s4">.</span><span class="s2">update</span><span class="s4">(</span><span class="s2">mac1</span><span class="s4">);</span>
  <span class="s2">mac1 </span><span class="s4">= </span><span class="s2">hmac</span><span class="s4">.</span><span class="s2">digest</span><span class="s4">().</span><span class="s2">getBytes</span><span class="s4">();</span>

  <span class="s2">hmac</span><span class="s4">.</span><span class="s2">start</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, </span><span class="s3">null</span><span class="s4">);</span>
  <span class="s2">hmac</span><span class="s4">.</span><span class="s2">update</span><span class="s4">(</span><span class="s2">mac2</span><span class="s4">);</span>
  <span class="s2">mac2 </span><span class="s4">= </span><span class="s2">hmac</span><span class="s4">.</span><span class="s2">digest</span><span class="s4">().</span><span class="s2">getBytes</span><span class="s4">();</span>

  <span class="s3">return </span><span class="s2">mac1 </span><span class="s4">=== </span><span class="s2">mac2</span><span class="s4">;</span>
<span class="s4">}</span>
</pre>
</body>
</html>