<html>
<head>
<title>misc.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
misc.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperEnvironmentVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;findBareSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;visitors&quot;</span><span class="s0">,</span><span class="s1">&quot;merge&quot;</span><span class="s0">,</span><span class="s1">&quot;Super&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;environmentVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;referenceVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;TSTypeAnnotation|TypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;skip&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;rename&quot;</span><span class="s0">,</span><span class="s1">&quot;handleClassTDZ&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;classBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;getBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;classNameTDZError&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;addHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;throwNode&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;classFieldDefinitionEvaluationTDZVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;injectInitialization&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;nodes&quot;</span><span class="s0">,</span><span class="s1">&quot;renamer&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;isDerived&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;newConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;classMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;restElement&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;unshiftContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;bareSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;isFirst&quot;</span><span class="s0">,</span><span class="s1">&quot;bareSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;insertAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;extractComputedKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;computedPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;declarations&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;computedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;computedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;computedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;isConstantExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;ident&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifierBasedOnNode&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/misc.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { template, traverse, types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { File } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath, Scope, Visitor, Binding } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import environmentVisitor from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-environment-visitor</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const findBareSupers = traverse.visitors.merge&lt;NodePath&lt;t.CallExpression&gt;[]&gt;([</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">Super(path) {</span><span class="s3">\n      </span><span class="s1">const { node, parentPath } = path;</span><span class="s3">\n      </span><span class="s1">if (parentPath.isCallExpression({ callee: node })) {</span><span class="s3">\n        </span><span class="s1">this.push(parentPath);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">environmentVisitor,</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n\n</span><span class="s1">const referenceVisitor: Visitor&lt;{ scope: Scope }&gt; = {</span><span class="s3">\n  \&quot;</span><span class="s1">TSTypeAnnotation|TypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;t.TSTypeAnnotation | t.TypeAnnotation&gt;,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">path.skip();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">ReferencedIdentifier(path: NodePath&lt;t.Identifier&gt;, { scope }) {</span><span class="s3">\n    </span><span class="s1">if (scope.hasOwnBinding(path.node.name)) {</span><span class="s3">\n      </span><span class="s1">scope.rename(path.node.name);</span><span class="s3">\n      </span><span class="s1">path.skip();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">type HandleClassTDZState = {</span><span class="s3">\n  </span><span class="s1">classBinding: Binding;</span><span class="s3">\n  </span><span class="s1">file: File;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function handleClassTDZ(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Identifier&gt;,</span><span class="s3">\n  </span><span class="s1">state: HandleClassTDZState,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">state.classBinding &amp;&amp;</span><span class="s3">\n    </span><span class="s1">state.classBinding === path.scope.getBinding(path.node.name)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const classNameTDZError = state.file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classNameTDZError</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const throwNode = t.callExpression(classNameTDZError, [</span><span class="s3">\n      </span><span class="s1">t.stringLiteral(path.node.name),</span><span class="s3">\n    </span><span class="s1">]);</span><span class="s3">\n\n    </span><span class="s1">path.replaceWith(t.sequenceExpression([throwNode, path.node]));</span><span class="s3">\n    </span><span class="s1">path.skip();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const classFieldDefinitionEvaluationTDZVisitor: Visitor&lt;HandleClassTDZState&gt; = {</span><span class="s3">\n  </span><span class="s1">ReferencedIdentifier: handleClassTDZ,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">interface RenamerState {</span><span class="s3">\n  </span><span class="s1">scope: Scope;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function injectInitialization(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Class&gt;,</span><span class="s3">\n  </span><span class="s1">constructor: NodePath&lt;t.ClassMethod&gt; | undefined,</span><span class="s3">\n  </span><span class="s1">nodes: t.Statement[],</span><span class="s3">\n  </span><span class="s1">renamer?: (visitor: Visitor&lt;RenamerState&gt;, state: RenamerState) =&gt; void,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!nodes.length) return;</span><span class="s3">\n\n  </span><span class="s1">const isDerived = !!path.node.superClass;</span><span class="s3">\n\n  </span><span class="s1">if (!constructor) {</span><span class="s3">\n    </span><span class="s1">const newConstructor = t.classMethod(</span><span class="s3">\n      \&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">[],</span><span class="s3">\n      </span><span class="s1">t.blockStatement([]),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (isDerived) {</span><span class="s3">\n      </span><span class="s1">newConstructor.params = [t.restElement(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">args</span><span class="s3">\&quot;</span><span class="s1">))];</span><span class="s3">\n      </span><span class="s1">newConstructor.body.body.push(template.statement.ast`super(...args)`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">[constructor] = path</span><span class="s3">\n      </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">.unshiftContainer(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, newConstructor) as NodePath&lt;t.ClassMethod&gt;[];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (renamer) {</span><span class="s3">\n    </span><span class="s1">renamer(referenceVisitor, { scope: constructor.scope });</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isDerived) {</span><span class="s3">\n    </span><span class="s1">const bareSupers: NodePath&lt;t.CallExpression&gt;[] = [];</span><span class="s3">\n    </span><span class="s1">constructor.traverse(findBareSupers, bareSupers);</span><span class="s3">\n    </span><span class="s1">let isFirst = true;</span><span class="s3">\n    </span><span class="s1">for (const bareSuper of bareSupers) {</span><span class="s3">\n      </span><span class="s1">if (isFirst) {</span><span class="s3">\n        </span><span class="s1">bareSuper.insertAfter(nodes);</span><span class="s3">\n        </span><span class="s1">isFirst = false;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">bareSuper.insertAfter(nodes.map(n =&gt; t.cloneNode(n)));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">constructor.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).unshiftContainer(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, nodes);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function extractComputedKeys(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Class&gt;,</span><span class="s3">\n  </span><span class="s1">computedPaths: NodePath&lt;t.ClassProperty | t.ClassMethod&gt;[],</span><span class="s3">\n  </span><span class="s1">file: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const declarations: t.ExpressionStatement[] = [];</span><span class="s3">\n  </span><span class="s1">const state = {</span><span class="s3">\n    </span><span class="s1">classBinding: path.node.id &amp;&amp; path.scope.getBinding(path.node.id.name),</span><span class="s3">\n    </span><span class="s1">file,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">for (const computedPath of computedPaths) {</span><span class="s3">\n    </span><span class="s1">const computedKey = computedPath.get(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (computedKey.isReferencedIdentifier()) {</span><span class="s3">\n      </span><span class="s1">handleClassTDZ(computedKey, state);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const computedNode = computedPath.node;</span><span class="s3">\n    </span><span class="s1">// Make sure computed property names are only evaluated once (upon class definition)</span><span class="s3">\n    </span><span class="s1">// and in the right order in combination with static properties</span><span class="s3">\n    </span><span class="s1">if (!computedKey.isConstantExpression()) {</span><span class="s3">\n      </span><span class="s1">const ident = path.scope.generateUidIdentifierBasedOnNode(</span><span class="s3">\n        </span><span class="s1">computedNode.key,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">// Declaring in the same block scope</span><span class="s3">\n      </span><span class="s1">// Ref: https://github.com/babel/babel/pull/10029/files#diff-fbbdd83e7a9c998721c1484529c2ce92</span><span class="s3">\n      </span><span class="s1">path.scope.push({</span><span class="s3">\n        </span><span class="s1">id: ident,</span><span class="s3">\n        </span><span class="s1">kind: </span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">declarations.push(</span><span class="s3">\n        </span><span class="s1">t.expressionStatement(</span><span class="s3">\n          </span><span class="s1">t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, t.cloneNode(ident), computedNode.key),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">computedNode.key = t.cloneNode(ident);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return declarations;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AAGA,IAAAC,yBAAA,GAAAD,OAAA;AAEA,MAAME,cAAc,GAAGC,cAAQ,CAACC,QAAQ,CAACC,KAAK,CAA+B,CAC3E;EACEC,KAAKA,CAACC,IAAI,EAAE;IACV,MAAM;MAAEC,IAAI;MAAEC;IAAW,CAAC,GAAGF,IAAI;IACjC,IAAIE,UAAU,CAACC,gBAAgB,CAAC;MAAEC,MAAM,EAAEH;IAAK,CAAC,CAAC,EAAE;MACjD,IAAI,CAACI,IAAI,CAACH,UAAU,CAAC;IACvB;EACF;AACF,CAAC,EACDI,iCAAkB,CACnB,CAAC;AAEF,MAAMC,gBAA2C,GAAG;EAClD,iCAAiCC,CAC/BR,IAAqD,EACrD;IACAA,IAAI,CAACS,IAAI,CAAC,CAAC;EACb,CAAC;EAEDC,oBAAoBA,CAACV,IAA4B,EAAE;IAAEW;EAAM,CAAC,EAAE;IAC5D,IAAIA,KAAK,CAACC,aAAa,CAACZ,IAAI,CAACC,IAAI,CAACY,IAAI,CAAC,EAAE;MACvCF,KAAK,CAACG,MAAM,CAACd,IAAI,CAACC,IAAI,CAACY,IAAI,CAAC;MAC5Bb,IAAI,CAACS,IAAI,CAAC,CAAC;IACb;EACF;AACF,CAAC;AAOD,SAASM,cAAcA,CACrBf,IAA4B,EAC5BgB,KAA0B,EAC1B;EACA,IACEA,KAAK,CAACC,YAAY,IAClBD,KAAK,CAACC,YAAY,KAAKjB,IAAI,CAACW,KAAK,CAACO,UAAU,CAAClB,IAAI,CAACC,IAAI,CAACY,IAAI,CAAC,EAC5D;IACA,MAAMM,iBAAiB,GAAGH,KAAK,CAACI,IAAI,CAACC,SAAS,CAAC,mBAAmB,CAAC;IACnE,MAAMC,SAAS,GAAGC,WAAC,CAACC,cAAc,CAACL,iBAAiB,EAAE,CACpDI,WAAC,CAACE,aAAa,CAACzB,IAAI,CAACC,IAAI,CAACY,IAAI,CAAC,CAChC,CAAC;IAEFb,IAAI,CAAC0B,WAAW,CAACH,WAAC,CAACI,kBAAkB,CAAC,CAACL,SAAS,EAAEtB,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC;IAC9DD,IAAI,CAACS,IAAI,CAAC,CAAC;EACb;AACF;AAEA,MAAMmB,wCAAsE,GAAG;EAC7ElB,oBAAoB,EAAEK;AACxB,CAAC;AAMM,SAASc,oBAAoBA,CAClC7B,IAAuB,EACvB8B,WAAgD,EAChDC,KAAoB,EACpBC,OAAuE,EACvE;EACA,IAAI,CAACD,KAAK,CAACE,MAAM,EAAE;EAEnB,MAAMC,SAAS,GAAG,CAAC,CAAClC,IAAI,CAACC,IAAI,CAACkC,UAAU;EAExC,IAAI,CAACL,WAAW,EAAE;IAChB,MAAMM,cAAc,GAAGb,WAAC,CAACc,WAAW,CAClC,aAAa,EACbd,WAAC,CAACe,UAAU,CAAC,aAAa,CAAC,EAC3B,EAAE,EACFf,WAAC,CAACgB,cAAc,CAAC,EAAE,CACrB,CAAC;IAED,IAAIL,SAAS,EAAE;MACbE,cAAc,CAACI,MAAM,GAAG,CAACjB,WAAC,CAACkB,WAAW,CAAClB,WAAC,CAACe,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC;MAC7DF,cAAc,CAACM,IAAI,CAACA,IAAI,CAACrC,IAAI,CAACsC,cAAQ,CAACC,SAAS,CAACC,GAAI,gBAAe,CAAC;IACvE;IAEA,CAACf,WAAW,CAAC,GAAG9B,IAAI,CACjB8C,GAAG,CAAC,MAAM,CAAC,CACXC,gBAAgB,CAAC,MAAM,EAAEX,cAAc,CAA8B;EAC1E;EAEA,IAAIJ,OAAO,EAAE;IACXA,OAAO,CAACzB,gBAAgB,EAAE;MAAEI,KAAK,EAAEmB,WAAW,CAACnB;IAAM,CAAC,CAAC;EACzD;EAEA,IAAIuB,SAAS,EAAE;IACb,MAAMc,UAAwC,GAAG,EAAE;IACnDlB,WAAW,CAAClC,QAAQ,CAACD,cAAc,EAAEqD,UAAU,CAAC;IAChD,IAAIC,OAAO,GAAG,IAAI;IAClB,KAAK,MAAMC,SAAS,IAAIF,UAAU,EAAE;MAClC,IAAIC,OAAO,EAAE;QACXC,SAAS,CAACC,WAAW,CAACpB,KAAK,CAAC;QAC5BkB,OAAO,GAAG,KAAK;MACjB,CAAC,MAAM;QACLC,SAAS,CAACC,WAAW,CAACpB,KAAK,CAACqB,GAAG,CAACC,CAAC,IAAI9B,WAAC,CAAC+B,SAAS,CAACD,CAAC,CAAC,CAAC,CAAC;MACvD;IACF;EACF,CAAC,MAAM;IACLvB,WAAW,CAACgB,GAAG,CAAC,MAAM,CAAC,CAACC,gBAAgB,CAAC,MAAM,EAAEhB,KAAK,CAAC;EACzD;AACF;AAEO,SAASwB,mBAAmBA,CACjCvD,IAAuB,EACvBwD,aAA0D,EAC1DpC,IAAU,EACV;EACA,MAAMqC,YAAqC,GAAG,EAAE;EAChD,MAAMzC,KAAK,GAAG;IACZC,YAAY,EAAEjB,IAAI,CAACC,IAAI,CAACyD,EAAE,IAAI1D,IAAI,CAACW,KAAK,CAACO,UAAU,CAAClB,IAAI,CAACC,IAAI,CAACyD,EAAE,CAAC7C,IAAI,CAAC;IACtEO;EACF,CAAC;EACD,KAAK,MAAMuC,YAAY,IAAIH,aAAa,EAAE;IACxC,MAAMI,WAAW,GAAGD,YAAY,CAACb,GAAG,CAAC,KAAK,CAAC;IAC3C,IAAIc,WAAW,CAACC,sBAAsB,CAAC,CAAC,EAAE;MACxC9C,cAAc,CAAC6C,WAAW,EAAE5C,KAAK,CAAC;IACpC,CAAC,MAAM;MACL4C,WAAW,CAAChE,QAAQ,CAACgC,wCAAwC,EAAEZ,KAAK,CAAC;IACvE;IAEA,MAAM8C,YAAY,GAAGH,YAAY,CAAC1D,IAAI;IAGtC,IAAI,CAAC2D,WAAW,CAACG,oBAAoB,CAAC,CAAC,EAAE;MACvC,MAAMC,KAAK,GAAGhE,IAAI,CAACW,KAAK,CAACsD,gCAAgC,CACvDH,YAAY,CAACI,GACf,CAAC;MAGDlE,IAAI,CAACW,KAAK,CAACN,IAAI,CAAC;QACdqD,EAAE,EAAEM,KAAK;QACTG,IAAI,EAAE;MACR,CAAC,CAAC;MACFV,YAAY,CAACpD,IAAI,CACfkB,WAAC,CAAC6C,mBAAmB,CACnB7C,WAAC,CAAC8C,oBAAoB,CAAC,GAAG,EAAE9C,WAAC,CAAC+B,SAAS,CAACU,KAAK,CAAC,EAAEF,YAAY,CAACI,GAAG,CAClE,CACF,CAAC;MACDJ,YAAY,CAACI,GAAG,GAAG3C,WAAC,CAAC+B,SAAS,CAACU,KAAK,CAAC;IACvC;EACF;EAEA,OAAOP,YAAY;AACrB&quot;</span><span class="s0">}</span></pre>
</body>
</html>