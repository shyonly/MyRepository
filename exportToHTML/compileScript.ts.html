<html>
<head>
<title>compileScript.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #42c3d4;}
.s7 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
compileScript.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">MagicString from </span><span class="s2">'magic-string'</span>
<span class="s0">import </span><span class="s1">LRU from </span><span class="s2">'lru-cache'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">walkIdentifiers</span><span class="s3">, </span><span class="s1">isFunctionType </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'./babelUtils'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">BindingMetadata</span><span class="s3">, </span><span class="s1">BindingTypes </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'./types'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">SFCDescriptor</span><span class="s3">, </span><span class="s1">SFCScriptBlock </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'./parseComponent'</span>
<span class="s0">import </span><span class="s3">{</span>
  <span class="s1">parse </span><span class="s3">as </span><span class="s1">_parse</span><span class="s3">,</span>
  <span class="s1">parseExpression</span><span class="s3">,</span>
  <span class="s1">ParserOptions</span><span class="s3">,</span>
  <span class="s1">ParserPlugin</span>
<span class="s3">} </span><span class="s1">from </span><span class="s2">'@babel/parser'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">generateCodeFrame </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'compiler/codeframe'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">camelize</span><span class="s3">, </span><span class="s1">capitalize</span><span class="s3">, </span><span class="s1">isBuiltInTag</span><span class="s3">, </span><span class="s1">makeMap </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'shared/util'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">parseHTML </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'compiler/parser/html-parser'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">baseOptions </span><span class="s3">as </span><span class="s1">webCompilerOptions </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'web/compiler/options'</span>
<span class="s0">import </span><span class="s3">{</span>
  <span class="s1">Node</span><span class="s3">,</span>
  <span class="s1">Declaration</span><span class="s3">,</span>
  <span class="s1">ObjectPattern</span><span class="s3">,</span>
  <span class="s1">ObjectExpression</span><span class="s3">,</span>
  <span class="s1">ArrayPattern</span><span class="s3">,</span>
  <span class="s1">Identifier</span><span class="s3">,</span>
  <span class="s1">ExportSpecifier</span><span class="s3">,</span>
  <span class="s1">TSType</span><span class="s3">,</span>
  <span class="s1">TSTypeLiteral</span><span class="s3">,</span>
  <span class="s1">TSFunctionType</span><span class="s3">,</span>
  <span class="s1">ObjectProperty</span><span class="s3">,</span>
  <span class="s1">ArrayExpression</span><span class="s3">,</span>
  <span class="s1">Statement</span><span class="s3">,</span>
  <span class="s1">CallExpression</span><span class="s3">,</span>
  <span class="s1">RestElement</span><span class="s3">,</span>
  <span class="s1">TSInterfaceBody</span><span class="s3">,</span>
  <span class="s1">Program</span><span class="s3">,</span>
  <span class="s1">ObjectMethod</span><span class="s3">,</span>
  <span class="s1">LVal</span><span class="s3">,</span>
  <span class="s1">Expression</span>
<span class="s3">} </span><span class="s1">from </span><span class="s2">'@babel/types'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">walk </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'estree-walker'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">RawSourceMap </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'source-map'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">warnOnce </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'./warn'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">isReservedTag </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'web/util'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">bindRE</span><span class="s3">, </span><span class="s1">dirRE</span><span class="s3">, </span><span class="s1">onRE</span><span class="s3">, </span><span class="s1">slotRE </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'compiler/parser'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">parseText </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'compiler/parser/text-parser'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">DEFAULT_FILENAME </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'./parseComponent'</span>
<span class="s0">import </span><span class="s3">{</span>
  <span class="s1">CSS_VARS_HELPER</span><span class="s3">,</span>
  <span class="s1">genCssVarsCode</span><span class="s3">,</span>
  <span class="s1">genNormalScriptCssVarsCode</span>
<span class="s3">} </span><span class="s1">from </span><span class="s2">'./cssVars'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">rewriteDefault </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'./rewriteDefault'</span>

<span class="s4">// Special compiler macros</span>
<span class="s0">const </span><span class="s1">DEFINE_PROPS </span><span class="s3">= </span><span class="s2">'defineProps'</span>
<span class="s0">const </span><span class="s1">DEFINE_EMITS </span><span class="s3">= </span><span class="s2">'defineEmits'</span>
<span class="s0">const </span><span class="s1">DEFINE_EXPOSE </span><span class="s3">= </span><span class="s2">'defineExpose'</span>
<span class="s0">const </span><span class="s1">WITH_DEFAULTS </span><span class="s3">= </span><span class="s2">'withDefaults'</span>

<span class="s4">// constants</span>
<span class="s0">const </span><span class="s1">DEFAULT_VAR </span><span class="s3">= </span><span class="s2">`__default__`</span>

<span class="s0">const </span><span class="s1">isBuiltInDir </span><span class="s3">= </span><span class="s1">makeMap</span><span class="s3">(</span>
  <span class="s2">`once,memo,if,for,else,else-if,slot,text,html,on,bind,model,show,cloak,is`</span>
<span class="s3">)</span>

<span class="s0">export interface </span><span class="s1">SFCScriptCompileOptions </span><span class="s3">{</span>
  <span class="s5">/**</span>
   <span class="s5">* Scope ID for prefixing injected CSS variables.</span>
   <span class="s5">* This must be consistent with the `id` passed to `compileStyle`.</span>
   <span class="s5">*/</span>
  <span class="s1">id</span><span class="s3">: </span><span class="s1">string</span>
  <span class="s5">/**</span>
   <span class="s5">* Production mode. Used to determine whether to generate hashed CSS variables</span>
   <span class="s5">*/</span>
  <span class="s1">isProd</span><span class="s3">?: </span><span class="s1">boolean</span>
  <span class="s5">/**</span>
   <span class="s5">* Enable/disable source map. Defaults to true.</span>
   <span class="s5">*/</span>
  <span class="s1">sourceMap</span><span class="s3">?: </span><span class="s1">boolean</span>
  <span class="s5">/**</span>
   <span class="s5">* https://babeljs.io/docs/en/babel-parser#plugins</span>
   <span class="s5">*/</span>
  <span class="s1">babelParserPlugins</span><span class="s3">?: </span><span class="s1">ParserPlugin</span><span class="s3">[]</span>
<span class="s3">}</span>

<span class="s0">export interface </span><span class="s1">ImportBinding </span><span class="s3">{</span>
  <span class="s1">isType</span><span class="s3">: </span><span class="s1">boolean</span>
  <span class="s1">imported</span><span class="s3">: </span><span class="s1">string</span>
  <span class="s1">source</span><span class="s3">: </span><span class="s1">string</span>
  <span class="s1">isFromSetup</span><span class="s3">: </span><span class="s1">boolean</span>
  <span class="s1">isUsedInTemplate</span><span class="s3">: </span><span class="s1">boolean</span>
<span class="s3">}</span>

<span class="s5">/**</span>
 <span class="s5">* Compile `&lt;script setup&gt;`</span>
 <span class="s5">* It requires the whole SFC descriptor because we need to handle and merge</span>
 <span class="s5">* normal `&lt;script&gt;` + `&lt;script setup&gt;` if both are present.</span>
 <span class="s5">*/</span>
<span class="s0">export function </span><span class="s1">compileScript</span><span class="s3">(</span>
  <span class="s1">sfc</span><span class="s3">: </span><span class="s1">SFCDescriptor</span><span class="s3">,</span>
  <span class="s1">options</span><span class="s3">: </span><span class="s1">SFCScriptCompileOptions </span><span class="s3">= { </span><span class="s1">id</span><span class="s3">: </span><span class="s2">'' </span><span class="s3">}</span>
<span class="s3">): </span><span class="s1">SFCScriptBlock </span><span class="s3">{</span>
  <span class="s0">let </span><span class="s3">{ </span><span class="s1">filename</span><span class="s3">, </span><span class="s1">script</span><span class="s3">, </span><span class="s1">scriptSetup</span><span class="s3">, </span><span class="s1">source </span><span class="s3">} = </span><span class="s1">sfc</span>
  <span class="s0">const </span><span class="s1">isProd </span><span class="s3">= !!</span><span class="s1">options</span><span class="s3">.</span><span class="s1">isProd</span>
  <span class="s0">const </span><span class="s1">genSourceMap </span><span class="s3">= </span><span class="s1">options</span><span class="s3">.</span><span class="s1">sourceMap </span><span class="s3">!== </span><span class="s0">false</span>
  <span class="s0">let </span><span class="s1">refBindings</span><span class="s3">: </span><span class="s1">string</span><span class="s3">[] | </span><span class="s1">undefined</span>

  <span class="s0">const </span><span class="s1">cssVars </span><span class="s3">= </span><span class="s1">sfc</span><span class="s3">.</span><span class="s1">cssVars</span>
  <span class="s0">const </span><span class="s1">scopeId </span><span class="s3">= </span><span class="s1">options</span><span class="s3">.</span><span class="s1">id </span><span class="s3">? </span><span class="s1">options</span><span class="s3">.</span><span class="s1">id</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s6">/^data-v-/</span><span class="s3">, </span><span class="s2">''</span><span class="s3">) : </span><span class="s2">''</span>
  <span class="s0">const </span><span class="s1">scriptLang </span><span class="s3">= </span><span class="s1">script </span><span class="s3">&amp;&amp; </span><span class="s1">script</span><span class="s3">.</span><span class="s1">lang</span>
  <span class="s0">const </span><span class="s1">scriptSetupLang </span><span class="s3">= </span><span class="s1">scriptSetup </span><span class="s3">&amp;&amp; </span><span class="s1">scriptSetup</span><span class="s3">.</span><span class="s1">lang</span>
  <span class="s0">const </span><span class="s1">isTS </span><span class="s3">=</span>
    <span class="s1">scriptLang </span><span class="s3">=== </span><span class="s2">'ts' </span><span class="s3">||</span>
    <span class="s1">scriptLang </span><span class="s3">=== </span><span class="s2">'tsx' </span><span class="s3">||</span>
    <span class="s1">scriptSetupLang </span><span class="s3">=== </span><span class="s2">'ts' </span><span class="s3">||</span>
    <span class="s1">scriptSetupLang </span><span class="s3">=== </span><span class="s2">'tsx'</span>

  <span class="s4">// resolve parser plugins</span>
  <span class="s0">const </span><span class="s1">plugins</span><span class="s3">: </span><span class="s1">ParserPlugin</span><span class="s3">[] = []</span>
  <span class="s0">if </span><span class="s3">(!</span><span class="s1">isTS </span><span class="s3">|| </span><span class="s1">scriptLang </span><span class="s3">=== </span><span class="s2">'tsx' </span><span class="s3">|| </span><span class="s1">scriptSetupLang </span><span class="s3">=== </span><span class="s2">'tsx'</span><span class="s3">) {</span>
    <span class="s1">plugins</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s2">'jsx'</span><span class="s3">)</span>
  <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
    <span class="s4">// If don't match the case of adding jsx, should remove the jsx from the babelParserPlugins</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">babelParserPlugins</span><span class="s3">)</span>
      <span class="s1">options</span><span class="s3">.</span><span class="s1">babelParserPlugins </span><span class="s3">= </span><span class="s1">options</span><span class="s3">.</span><span class="s1">babelParserPlugins</span><span class="s3">.</span><span class="s1">filter</span><span class="s3">(</span>
        <span class="s1">n </span><span class="s3">=&gt; </span><span class="s1">n </span><span class="s3">!== </span><span class="s2">'jsx'</span>
      <span class="s3">)</span>
  <span class="s3">}</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">babelParserPlugins</span><span class="s3">) </span><span class="s1">plugins</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">...options</span><span class="s3">.</span><span class="s1">babelParserPlugins</span><span class="s3">)</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">isTS</span><span class="s3">) {</span>
    <span class="s1">plugins</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s2">'typescript'</span><span class="s3">)</span>
    <span class="s0">if </span><span class="s3">(!</span><span class="s1">plugins</span><span class="s3">.</span><span class="s1">includes</span><span class="s3">(</span><span class="s2">'decorators'</span><span class="s3">)) {</span>
      <span class="s1">plugins</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s2">'decorators-legacy'</span><span class="s3">)</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s0">if </span><span class="s3">(!</span><span class="s1">scriptSetup</span><span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(!</span><span class="s1">script</span><span class="s3">) {</span>
      <span class="s0">throw new </span><span class="s1">Error</span><span class="s3">(</span><span class="s2">`[@vue/compiler-sfc] SFC contains no &lt;script&gt; tags.`</span><span class="s3">)</span>
    <span class="s3">}</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">scriptLang </span><span class="s3">&amp;&amp; !</span><span class="s1">isTS </span><span class="s3">&amp;&amp; </span><span class="s1">scriptLang </span><span class="s3">!== </span><span class="s2">'jsx'</span><span class="s3">) {</span>
      <span class="s4">// do not process non js/ts script blocks</span>
      <span class="s0">return </span><span class="s1">script</span>
    <span class="s3">}</span>
    <span class="s0">try </span><span class="s3">{</span>
      <span class="s0">let </span><span class="s1">content </span><span class="s3">= </span><span class="s1">script</span><span class="s3">.</span><span class="s1">content</span>
      <span class="s0">let </span><span class="s1">map </span><span class="s3">= </span><span class="s1">script</span><span class="s3">.</span><span class="s1">map</span>
      <span class="s0">const </span><span class="s1">scriptAst </span><span class="s3">= </span><span class="s1">_parse</span><span class="s3">(</span><span class="s1">content</span><span class="s3">, {</span>
        <span class="s1">plugins</span><span class="s3">,</span>
        <span class="s1">sourceType</span><span class="s3">: </span><span class="s2">'module'</span>
      <span class="s3">}).</span><span class="s1">program</span>
      <span class="s0">const </span><span class="s1">bindings </span><span class="s3">= </span><span class="s1">analyzeScriptBindings</span><span class="s3">(</span><span class="s1">scriptAst</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">cssVars</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) {</span>
        <span class="s1">content </span><span class="s3">= </span><span class="s1">rewriteDefault</span><span class="s3">(</span><span class="s1">content</span><span class="s3">, </span><span class="s1">DEFAULT_VAR</span><span class="s3">, </span><span class="s1">plugins</span><span class="s3">)</span>
        <span class="s1">content </span><span class="s3">+= </span><span class="s1">genNormalScriptCssVarsCode</span><span class="s3">(</span>
          <span class="s1">cssVars</span><span class="s3">,</span>
          <span class="s1">bindings</span><span class="s3">,</span>
          <span class="s1">scopeId</span><span class="s3">,</span>
          <span class="s1">isProd</span>
        <span class="s3">)</span>
        <span class="s1">content </span><span class="s3">+= </span><span class="s2">`</span><span class="s0">\n</span><span class="s2">export default </span><span class="s1">$</span><span class="s3">{</span><span class="s1">DEFAULT_VAR</span><span class="s3">}</span><span class="s2">`</span>
      <span class="s3">}</span>
      <span class="s0">return </span><span class="s3">{</span>
        <span class="s1">...script</span><span class="s3">,</span>
        <span class="s1">content</span><span class="s3">,</span>
        <span class="s1">map</span><span class="s3">,</span>
        <span class="s1">bindings</span><span class="s3">,</span>
        <span class="s1">scriptAst</span><span class="s3">: </span><span class="s1">scriptAst</span><span class="s3">.</span><span class="s1">body</span>
      <span class="s3">}</span>
    <span class="s3">} </span><span class="s0">catch </span><span class="s3">(</span><span class="s1">e</span><span class="s3">: </span><span class="s1">any</span><span class="s3">) {</span>
      <span class="s4">// silently fallback if parse fails since user may be using custom</span>
      <span class="s4">// babel syntax</span>
      <span class="s0">return </span><span class="s1">script</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s0">if </span><span class="s3">(</span><span class="s1">script </span><span class="s3">&amp;&amp; </span><span class="s1">scriptLang </span><span class="s3">!== </span><span class="s1">scriptSetupLang</span><span class="s3">) {</span>
    <span class="s0">throw new </span><span class="s1">Error</span><span class="s3">(</span>
      <span class="s2">`[@vue/compiler-sfc] &lt;script&gt; and &lt;script setup&gt; must have the same ` </span><span class="s3">+</span>
        <span class="s2">`language type.`</span>
    <span class="s3">)</span>
  <span class="s3">}</span>

  <span class="s0">if </span><span class="s3">(</span><span class="s1">scriptSetupLang </span><span class="s3">&amp;&amp; !</span><span class="s1">isTS </span><span class="s3">&amp;&amp; </span><span class="s1">scriptSetupLang </span><span class="s3">!== </span><span class="s2">'jsx'</span><span class="s3">) {</span>
    <span class="s4">// do not process non js/ts script blocks</span>
    <span class="s0">return </span><span class="s1">scriptSetup</span>
  <span class="s3">}</span>

  <span class="s4">// metadata that needs to be returned</span>
  <span class="s0">const </span><span class="s1">bindingMetadata</span><span class="s3">: </span><span class="s1">BindingMetadata </span><span class="s3">= {}</span>
  <span class="s0">const </span><span class="s1">helperImports</span><span class="s3">: </span><span class="s1">Set</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">&gt; = </span><span class="s0">new </span><span class="s1">Set</span><span class="s3">()</span>
  <span class="s0">const </span><span class="s1">userImports</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">ImportBinding</span><span class="s3">&gt; = </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s0">null</span><span class="s3">)</span>
  <span class="s0">const </span><span class="s1">userImportAlias</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">string</span><span class="s3">&gt; = </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s0">null</span><span class="s3">)</span>
  <span class="s0">const </span><span class="s1">scriptBindings</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">BindingTypes</span><span class="s3">&gt; = </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s0">null</span><span class="s3">)</span>
  <span class="s0">const </span><span class="s1">setupBindings</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">BindingTypes</span><span class="s3">&gt; = </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s0">null</span><span class="s3">)</span>

  <span class="s0">let </span><span class="s1">defaultExport</span><span class="s3">: </span><span class="s1">Node </span><span class="s3">| </span><span class="s1">undefined</span>
  <span class="s0">let </span><span class="s1">hasDefinePropsCall </span><span class="s3">= </span><span class="s0">false</span>
  <span class="s0">let </span><span class="s1">hasDefineEmitCall </span><span class="s3">= </span><span class="s0">false</span>
  <span class="s0">let </span><span class="s1">hasDefineExposeCall </span><span class="s3">= </span><span class="s0">false</span>
  <span class="s0">let </span><span class="s1">hasDefaultExportName </span><span class="s3">= </span><span class="s0">false</span>
  <span class="s0">let </span><span class="s1">propsRuntimeDecl</span><span class="s3">: </span><span class="s1">Node </span><span class="s3">| </span><span class="s1">undefined</span>
  <span class="s0">let </span><span class="s1">propsRuntimeDefaults</span><span class="s3">: </span><span class="s1">ObjectExpression </span><span class="s3">| </span><span class="s1">undefined</span>
  <span class="s0">let </span><span class="s1">propsDestructureDecl</span><span class="s3">: </span><span class="s1">Node </span><span class="s3">| </span><span class="s1">undefined</span>
  <span class="s0">let </span><span class="s1">propsDestructureRestId</span><span class="s3">: </span><span class="s1">string </span><span class="s3">| </span><span class="s1">undefined</span>
  <span class="s0">let </span><span class="s1">propsTypeDecl</span><span class="s3">: </span><span class="s1">TSTypeLiteral </span><span class="s3">| </span><span class="s1">TSInterfaceBody </span><span class="s3">| </span><span class="s1">undefined</span>
  <span class="s0">let </span><span class="s1">propsTypeDeclRaw</span><span class="s3">: </span><span class="s1">Node </span><span class="s3">| </span><span class="s1">undefined</span>
  <span class="s0">let </span><span class="s1">propsIdentifier</span><span class="s3">: </span><span class="s1">string </span><span class="s3">| </span><span class="s1">undefined</span>
  <span class="s0">let </span><span class="s1">emitsRuntimeDecl</span><span class="s3">: </span><span class="s1">Node </span><span class="s3">| </span><span class="s1">undefined</span>
  <span class="s0">let </span><span class="s1">emitsTypeDecl</span><span class="s3">:</span>
    <span class="s3">| </span><span class="s1">TSFunctionType</span>
    <span class="s3">| </span><span class="s1">TSTypeLiteral</span>
    <span class="s3">| </span><span class="s1">TSInterfaceBody</span>
    <span class="s3">| </span><span class="s1">undefined</span>
  <span class="s0">let </span><span class="s1">emitsTypeDeclRaw</span><span class="s3">: </span><span class="s1">Node </span><span class="s3">| </span><span class="s1">undefined</span>
  <span class="s0">let </span><span class="s1">emitIdentifier</span><span class="s3">: </span><span class="s1">string </span><span class="s3">| </span><span class="s1">undefined</span>
  <span class="s0">let </span><span class="s1">hasInlinedSsrRenderFn </span><span class="s3">= </span><span class="s0">false</span>
  <span class="s4">// props/emits declared via types</span>
  <span class="s0">const </span><span class="s1">typeDeclaredProps</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">PropTypeData</span><span class="s3">&gt; = {}</span>
  <span class="s0">const </span><span class="s1">typeDeclaredEmits</span><span class="s3">: </span><span class="s1">Set</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">&gt; = </span><span class="s0">new </span><span class="s1">Set</span><span class="s3">()</span>
  <span class="s4">// record declared types for runtime props type generation</span>
  <span class="s0">const </span><span class="s1">declaredTypes</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">string</span><span class="s3">[]&gt; = {}</span>
  <span class="s4">// props destructure data</span>
  <span class="s0">const </span><span class="s1">propsDestructuredBindings</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span>
    <span class="s1">string</span><span class="s3">, </span><span class="s4">// public prop key</span>
    <span class="s3">{</span>
      <span class="s1">local</span><span class="s3">: </span><span class="s1">string </span><span class="s4">// local identifier, may be different</span>
      <span class="s0">default</span><span class="s3">?: </span><span class="s1">Expression</span>
    <span class="s3">}</span>
  <span class="s3">&gt; = </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s0">null</span><span class="s3">)</span>

  <span class="s4">// magic-string state</span>
  <span class="s0">const </span><span class="s1">s </span><span class="s3">= </span><span class="s0">new </span><span class="s1">MagicString</span><span class="s3">(</span><span class="s1">source</span><span class="s3">)</span>
  <span class="s0">const </span><span class="s1">startOffset </span><span class="s3">= </span><span class="s1">scriptSetup</span><span class="s3">.</span><span class="s1">start</span>
  <span class="s0">const </span><span class="s1">endOffset </span><span class="s3">= </span><span class="s1">scriptSetup</span><span class="s3">.</span><span class="s1">end</span>
  <span class="s0">const </span><span class="s1">scriptStartOffset </span><span class="s3">= </span><span class="s1">script </span><span class="s3">&amp;&amp; </span><span class="s1">script</span><span class="s3">.</span><span class="s1">start</span>
  <span class="s0">const </span><span class="s1">scriptEndOffset </span><span class="s3">= </span><span class="s1">script </span><span class="s3">&amp;&amp; </span><span class="s1">script</span><span class="s3">.</span><span class="s1">end</span>

  <span class="s0">function </span><span class="s1">helper</span><span class="s3">(</span><span class="s1">key</span><span class="s3">: </span><span class="s1">string</span><span class="s3">): </span><span class="s1">string </span><span class="s3">{</span>
    <span class="s1">helperImports</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>
    <span class="s0">return </span><span class="s2">`_</span><span class="s1">$</span><span class="s3">{</span><span class="s1">key</span><span class="s3">}</span><span class="s2">`</span>
  <span class="s3">}</span>

  <span class="s0">function </span><span class="s1">parse</span><span class="s3">(</span>
    <span class="s1">input</span><span class="s3">: </span><span class="s1">string</span><span class="s3">,</span>
    <span class="s1">options</span><span class="s3">: </span><span class="s1">ParserOptions</span><span class="s3">,</span>
    <span class="s1">offset</span><span class="s3">: </span><span class="s1">number</span>
  <span class="s3">): </span><span class="s1">Program </span><span class="s3">{</span>
    <span class="s0">try </span><span class="s3">{</span>
      <span class="s0">return </span><span class="s1">_parse</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">options</span><span class="s3">).</span><span class="s1">program</span>
    <span class="s3">} </span><span class="s0">catch </span><span class="s3">(</span><span class="s1">e</span><span class="s3">: </span><span class="s1">any</span><span class="s3">) {</span>
      <span class="s1">e</span><span class="s3">.</span><span class="s1">message </span><span class="s3">= </span><span class="s2">`[@vue/compiler-sfc] </span><span class="s1">$</span><span class="s3">{</span>
        <span class="s1">e</span><span class="s3">.</span><span class="s1">message</span>
      <span class="s3">}</span><span class="s0">\n\n</span><span class="s1">$</span><span class="s3">{</span><span class="s1">filename</span><span class="s3">}</span><span class="s0">\n</span><span class="s1">$</span><span class="s3">{</span><span class="s1">generateCodeFrame</span><span class="s3">(</span>
        <span class="s1">source</span><span class="s3">,</span>
        <span class="s1">e</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">+ </span><span class="s1">offset</span><span class="s3">,</span>
        <span class="s1">e</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">+ </span><span class="s1">offset </span><span class="s3">+ </span><span class="s7">1</span>
      <span class="s3">)}</span><span class="s2">`</span>
      <span class="s0">throw </span><span class="s1">e</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s0">function </span><span class="s1">error</span><span class="s3">(</span>
    <span class="s1">msg</span><span class="s3">: </span><span class="s1">string</span><span class="s3">,</span>
    <span class="s1">node</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">,</span>
    <span class="s1">end</span><span class="s3">: </span><span class="s1">number </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">end</span><span class="s3">! + </span><span class="s1">startOffset</span>
  <span class="s3">): </span><span class="s1">never </span><span class="s3">{</span>
    <span class="s0">throw new </span><span class="s1">Error</span><span class="s3">(</span>
      <span class="s2">`[@vue/compiler-sfc] </span><span class="s1">$</span><span class="s3">{</span><span class="s1">msg</span><span class="s3">}</span><span class="s0">\n\n</span><span class="s1">$</span><span class="s3">{</span><span class="s1">filename</span><span class="s3">}</span><span class="s0">\n</span><span class="s1">$</span><span class="s3">{</span><span class="s1">generateCodeFrame</span><span class="s3">(</span>
        <span class="s1">source</span><span class="s3">,</span>
        <span class="s1">node</span><span class="s3">.</span><span class="s1">start</span><span class="s3">! + </span><span class="s1">startOffset</span><span class="s3">,</span>
        <span class="s1">end</span>
      <span class="s3">)}</span><span class="s2">`</span>
    <span class="s3">)</span>
  <span class="s3">}</span>

  <span class="s0">function </span><span class="s1">registerUserImport</span><span class="s3">(</span>
    <span class="s1">source</span><span class="s3">: </span><span class="s1">string</span><span class="s3">,</span>
    <span class="s1">local</span><span class="s3">: </span><span class="s1">string</span><span class="s3">,</span>
    <span class="s1">imported</span><span class="s3">: </span><span class="s1">string </span><span class="s3">| </span><span class="s0">false</span><span class="s3">,</span>
    <span class="s1">isType</span><span class="s3">: </span><span class="s1">boolean</span><span class="s3">,</span>
    <span class="s1">isFromSetup</span><span class="s3">: </span><span class="s1">boolean</span>
  <span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">source </span><span class="s3">=== </span><span class="s2">'vue' </span><span class="s3">&amp;&amp; </span><span class="s1">imported</span><span class="s3">) {</span>
      <span class="s1">userImportAlias</span><span class="s3">[</span><span class="s1">imported</span><span class="s3">] = </span><span class="s1">local</span>
    <span class="s3">}</span>

    <span class="s0">let </span><span class="s1">isUsedInTemplate </span><span class="s3">= </span><span class="s0">true</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">sfc</span><span class="s3">.</span><span class="s1">template </span><span class="s3">&amp;&amp; !</span><span class="s1">sfc</span><span class="s3">.</span><span class="s1">template</span><span class="s3">.</span><span class="s1">src </span><span class="s3">&amp;&amp; !</span><span class="s1">sfc</span><span class="s3">.</span><span class="s1">template</span><span class="s3">.</span><span class="s1">lang</span><span class="s3">) {</span>
      <span class="s1">isUsedInTemplate </span><span class="s3">= </span><span class="s1">isImportUsed</span><span class="s3">(</span><span class="s1">local</span><span class="s3">, </span><span class="s1">sfc</span><span class="s3">, </span><span class="s1">isTS</span><span class="s3">)</span>
    <span class="s3">}</span>

    <span class="s1">userImports</span><span class="s3">[</span><span class="s1">local</span><span class="s3">] = {</span>
      <span class="s1">isType</span><span class="s3">,</span>
      <span class="s1">imported</span><span class="s3">: </span><span class="s1">imported </span><span class="s3">|| </span><span class="s2">'default'</span><span class="s3">,</span>
      <span class="s1">source</span><span class="s3">,</span>
      <span class="s1">isFromSetup</span><span class="s3">,</span>
      <span class="s1">isUsedInTemplate</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s0">function </span><span class="s1">processDefineProps</span><span class="s3">(</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">, </span><span class="s1">declId</span><span class="s3">?: </span><span class="s1">LVal</span><span class="s3">): </span><span class="s1">boolean </span><span class="s3">{</span>
    <span class="s0">if </span><span class="s3">(!</span><span class="s1">isCallOf</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">DEFINE_PROPS</span><span class="s3">)) {</span>
      <span class="s0">return false</span>
    <span class="s3">}</span>

    <span class="s0">if </span><span class="s3">(</span><span class="s1">hasDefinePropsCall</span><span class="s3">) {</span>
      <span class="s1">error</span><span class="s3">(</span><span class="s2">`duplicate </span><span class="s1">$</span><span class="s3">{</span><span class="s1">DEFINE_PROPS</span><span class="s3">}</span><span class="s2">() call`</span><span class="s3">, </span><span class="s1">node</span><span class="s3">)</span>
    <span class="s3">}</span>
    <span class="s1">hasDefinePropsCall </span><span class="s3">= </span><span class="s0">true</span>

    <span class="s1">propsRuntimeDecl </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">arguments</span><span class="s3">[</span><span class="s7">0</span><span class="s3">]</span>

    <span class="s4">// call has type parameters - infer runtime types from it</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">typeParameters</span><span class="s3">) {</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">propsRuntimeDecl</span><span class="s3">) {</span>
        <span class="s1">error</span><span class="s3">(</span>
          <span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">DEFINE_PROPS</span><span class="s3">}</span><span class="s2">() cannot accept both type and non-type arguments ` </span><span class="s3">+</span>
            <span class="s2">`at the same time. Use one or the other.`</span><span class="s3">,</span>
          <span class="s1">node</span>
        <span class="s3">)</span>
      <span class="s3">}</span>

      <span class="s1">propsTypeDeclRaw </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">typeParameters</span><span class="s3">.</span><span class="s1">params</span><span class="s3">[</span><span class="s7">0</span><span class="s3">]</span>
      <span class="s1">propsTypeDecl </span><span class="s3">= </span><span class="s1">resolveQualifiedType</span><span class="s3">(</span>
        <span class="s1">propsTypeDeclRaw</span><span class="s3">,</span>
        <span class="s1">node </span><span class="s3">=&gt; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSTypeLiteral'</span>
      <span class="s3">) as </span><span class="s1">TSTypeLiteral </span><span class="s3">| </span><span class="s1">TSInterfaceBody </span><span class="s3">| </span><span class="s1">undefined</span>

      <span class="s0">if </span><span class="s3">(!</span><span class="s1">propsTypeDecl</span><span class="s3">) {</span>
        <span class="s1">error</span><span class="s3">(</span>
          <span class="s2">`type argument passed to </span><span class="s1">$</span><span class="s3">{</span><span class="s1">DEFINE_PROPS</span><span class="s3">}</span><span class="s2">() must be a literal type, ` </span><span class="s3">+</span>
            <span class="s2">`or a reference to an interface or literal type.`</span><span class="s3">,</span>
          <span class="s1">propsTypeDeclRaw</span>
        <span class="s3">)</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s0">if </span><span class="s3">(</span><span class="s1">declId</span><span class="s3">) {</span>
      <span class="s1">propsIdentifier </span><span class="s3">= </span><span class="s1">scriptSetup</span><span class="s3">!.</span><span class="s1">content</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">declId</span><span class="s3">.</span><span class="s1">start</span><span class="s3">!, </span><span class="s1">declId</span><span class="s3">.</span><span class="s1">end</span><span class="s3">!)</span>
    <span class="s3">}</span>

    <span class="s0">return true</span>
  <span class="s3">}</span>

  <span class="s0">function </span><span class="s1">processWithDefaults</span><span class="s3">(</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">, </span><span class="s1">declId</span><span class="s3">?: </span><span class="s1">LVal</span><span class="s3">): </span><span class="s1">boolean </span><span class="s3">{</span>
    <span class="s0">if </span><span class="s3">(!</span><span class="s1">isCallOf</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">WITH_DEFAULTS</span><span class="s3">)) {</span>
      <span class="s0">return false</span>
    <span class="s3">}</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">processDefineProps</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">arguments</span><span class="s3">[</span><span class="s7">0</span><span class="s3">], </span><span class="s1">declId</span><span class="s3">)) {</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">propsRuntimeDecl</span><span class="s3">) {</span>
        <span class="s1">error</span><span class="s3">(</span>
          <span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">WITH_DEFAULTS</span><span class="s3">} </span><span class="s2">can only be used with type-based ` </span><span class="s3">+</span>
            <span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">DEFINE_PROPS</span><span class="s3">} </span><span class="s2">declaration.`</span><span class="s3">,</span>
          <span class="s1">node</span>
        <span class="s3">)</span>
      <span class="s3">}</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">propsDestructureDecl</span><span class="s3">) {</span>
        <span class="s1">error</span><span class="s3">(</span>
          <span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">WITH_DEFAULTS</span><span class="s3">}</span><span class="s2">() is unnecessary when using destructure with </span><span class="s1">$</span><span class="s3">{</span><span class="s1">DEFINE_PROPS</span><span class="s3">}</span><span class="s2">().</span><span class="s0">\n</span><span class="s2">` </span><span class="s3">+</span>
            <span class="s2">`Prefer using destructure default values, e.g. const { foo = 1 } = defineProps(...).`</span><span class="s3">,</span>
          <span class="s1">node</span><span class="s3">.</span><span class="s1">callee</span>
        <span class="s3">)</span>
      <span class="s3">}</span>
      <span class="s1">propsRuntimeDefaults </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">arguments</span><span class="s3">[</span><span class="s7">1</span><span class="s3">] as </span><span class="s1">ObjectExpression</span>
      <span class="s0">if </span><span class="s3">(</span>
        <span class="s3">!</span><span class="s1">propsRuntimeDefaults </span><span class="s3">||</span>
        <span class="s1">propsRuntimeDefaults</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!== </span><span class="s2">'ObjectExpression'</span>
      <span class="s3">) {</span>
        <span class="s1">error</span><span class="s3">(</span>
          <span class="s2">`The 2nd argument of </span><span class="s1">$</span><span class="s3">{</span><span class="s1">WITH_DEFAULTS</span><span class="s3">} </span><span class="s2">must be an object literal.`</span><span class="s3">,</span>
          <span class="s1">propsRuntimeDefaults </span><span class="s3">|| </span><span class="s1">node</span>
        <span class="s3">)</span>
      <span class="s3">}</span>
    <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
      <span class="s1">error</span><span class="s3">(</span>
        <span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">WITH_DEFAULTS</span><span class="s3">}</span><span class="s2">' first argument must be a </span><span class="s1">$</span><span class="s3">{</span><span class="s1">DEFINE_PROPS</span><span class="s3">} </span><span class="s2">call.`</span><span class="s3">,</span>
        <span class="s1">node</span><span class="s3">.</span><span class="s1">arguments</span><span class="s3">[</span><span class="s7">0</span><span class="s3">] || </span><span class="s1">node</span>
      <span class="s3">)</span>
    <span class="s3">}</span>
    <span class="s0">return true</span>
  <span class="s3">}</span>

  <span class="s0">function </span><span class="s1">processDefineEmits</span><span class="s3">(</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">, </span><span class="s1">declId</span><span class="s3">?: </span><span class="s1">LVal</span><span class="s3">): </span><span class="s1">boolean </span><span class="s3">{</span>
    <span class="s0">if </span><span class="s3">(!</span><span class="s1">isCallOf</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">DEFINE_EMITS</span><span class="s3">)) {</span>
      <span class="s0">return false</span>
    <span class="s3">}</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">hasDefineEmitCall</span><span class="s3">) {</span>
      <span class="s1">error</span><span class="s3">(</span><span class="s2">`duplicate </span><span class="s1">$</span><span class="s3">{</span><span class="s1">DEFINE_EMITS</span><span class="s3">}</span><span class="s2">() call`</span><span class="s3">, </span><span class="s1">node</span><span class="s3">)</span>
    <span class="s3">}</span>
    <span class="s1">hasDefineEmitCall </span><span class="s3">= </span><span class="s0">true</span>
    <span class="s1">emitsRuntimeDecl </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">arguments</span><span class="s3">[</span><span class="s7">0</span><span class="s3">]</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">typeParameters</span><span class="s3">) {</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">emitsRuntimeDecl</span><span class="s3">) {</span>
        <span class="s1">error</span><span class="s3">(</span>
          <span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">DEFINE_EMITS</span><span class="s3">}</span><span class="s2">() cannot accept both type and non-type arguments ` </span><span class="s3">+</span>
            <span class="s2">`at the same time. Use one or the other.`</span><span class="s3">,</span>
          <span class="s1">node</span>
        <span class="s3">)</span>
      <span class="s3">}</span>

      <span class="s1">emitsTypeDeclRaw </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">typeParameters</span><span class="s3">.</span><span class="s1">params</span><span class="s3">[</span><span class="s7">0</span><span class="s3">]</span>
      <span class="s1">emitsTypeDecl </span><span class="s3">= </span><span class="s1">resolveQualifiedType</span><span class="s3">(</span>
        <span class="s1">emitsTypeDeclRaw</span><span class="s3">,</span>
        <span class="s1">node </span><span class="s3">=&gt; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSFunctionType' </span><span class="s3">|| </span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSTypeLiteral'</span>
      <span class="s3">) as </span><span class="s1">TSFunctionType </span><span class="s3">| </span><span class="s1">TSTypeLiteral </span><span class="s3">| </span><span class="s1">TSInterfaceBody </span><span class="s3">| </span><span class="s1">undefined</span>

      <span class="s0">if </span><span class="s3">(!</span><span class="s1">emitsTypeDecl</span><span class="s3">) {</span>
        <span class="s1">error</span><span class="s3">(</span>
          <span class="s2">`type argument passed to </span><span class="s1">$</span><span class="s3">{</span><span class="s1">DEFINE_EMITS</span><span class="s3">}</span><span class="s2">() must be a function type, ` </span><span class="s3">+</span>
            <span class="s2">`a literal type with call signatures, or a reference to the above types.`</span><span class="s3">,</span>
          <span class="s1">emitsTypeDeclRaw</span>
        <span class="s3">)</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s0">if </span><span class="s3">(</span><span class="s1">declId</span><span class="s3">) {</span>
      <span class="s1">emitIdentifier </span><span class="s3">= </span><span class="s1">scriptSetup</span><span class="s3">!.</span><span class="s1">content</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">declId</span><span class="s3">.</span><span class="s1">start</span><span class="s3">!, </span><span class="s1">declId</span><span class="s3">.</span><span class="s1">end</span><span class="s3">!)</span>
    <span class="s3">}</span>

    <span class="s0">return true</span>
  <span class="s3">}</span>

  <span class="s0">function </span><span class="s1">resolveQualifiedType</span><span class="s3">(</span>
    <span class="s1">node</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">,</span>
    <span class="s1">qualifier</span><span class="s3">: (</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">) =&gt; </span><span class="s1">boolean</span>
  <span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">qualifier</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)) {</span>
      <span class="s0">return </span><span class="s1">node</span>
    <span class="s3">}</span>
    <span class="s0">if </span><span class="s3">(</span>
      <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSTypeReference' </span><span class="s3">&amp;&amp;</span>
      <span class="s1">node</span><span class="s3">.</span><span class="s1">typeName</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'Identifier'</span>
    <span class="s3">) {</span>
      <span class="s0">const </span><span class="s1">refName </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">typeName</span><span class="s3">.</span><span class="s1">name</span>
      <span class="s0">const </span><span class="s1">isQualifiedType </span><span class="s3">= (</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">): </span><span class="s1">Node </span><span class="s3">| </span><span class="s1">undefined </span><span class="s3">=&gt; {</span>
        <span class="s0">if </span><span class="s3">(</span>
          <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSInterfaceDeclaration' </span><span class="s3">&amp;&amp;</span>
          <span class="s1">node</span><span class="s3">.</span><span class="s1">id</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=== </span><span class="s1">refName</span>
        <span class="s3">) {</span>
          <span class="s0">return </span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span>
        <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span>
          <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSTypeAliasDeclaration' </span><span class="s3">&amp;&amp;</span>
          <span class="s1">node</span><span class="s3">.</span><span class="s1">id</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=== </span><span class="s1">refName </span><span class="s3">&amp;&amp;</span>
          <span class="s1">qualifier</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">typeAnnotation</span><span class="s3">)</span>
        <span class="s3">) {</span>
          <span class="s0">return </span><span class="s1">node</span><span class="s3">.</span><span class="s1">typeAnnotation</span>
        <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ExportNamedDeclaration' </span><span class="s3">&amp;&amp; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">declaration</span><span class="s3">) {</span>
          <span class="s0">return </span><span class="s1">isQualifiedType</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">declaration</span><span class="s3">)</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
      <span class="s0">const </span><span class="s1">body </span><span class="s3">= </span><span class="s1">scriptAst</span>
        <span class="s3">? [</span><span class="s1">...scriptSetupAst</span><span class="s3">.</span><span class="s1">body</span><span class="s3">, </span><span class="s1">...scriptAst</span><span class="s3">.</span><span class="s1">body</span><span class="s3">]</span>
        <span class="s3">: </span><span class="s1">scriptSetupAst</span><span class="s3">.</span><span class="s1">body</span>
      <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">node of body</span><span class="s3">) {</span>
        <span class="s0">const </span><span class="s1">qualified </span><span class="s3">= </span><span class="s1">isQualifiedType</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">qualified</span><span class="s3">) {</span>
          <span class="s0">return </span><span class="s1">qualified</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s0">function </span><span class="s1">processDefineExpose</span><span class="s3">(</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">): </span><span class="s1">boolean </span><span class="s3">{</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">isCallOf</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">DEFINE_EXPOSE</span><span class="s3">)) {</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">hasDefineExposeCall</span><span class="s3">) {</span>
        <span class="s1">error</span><span class="s3">(</span><span class="s2">`duplicate </span><span class="s1">$</span><span class="s3">{</span><span class="s1">DEFINE_EXPOSE</span><span class="s3">}</span><span class="s2">() call`</span><span class="s3">, </span><span class="s1">node</span><span class="s3">)</span>
      <span class="s3">}</span>
      <span class="s1">hasDefineExposeCall </span><span class="s3">= </span><span class="s0">true</span>
      <span class="s0">return true</span>
    <span class="s3">}</span>
    <span class="s0">return false</span>
  <span class="s3">}</span>

  <span class="s0">function </span><span class="s1">checkInvalidScopeReference</span><span class="s3">(</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Node </span><span class="s3">| </span><span class="s1">undefined</span><span class="s3">, </span><span class="s1">method</span><span class="s3">: </span><span class="s1">string</span><span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(!</span><span class="s1">node</span><span class="s3">) </span><span class="s0">return</span>
    <span class="s1">walkIdentifiers</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">id </span><span class="s3">=&gt; {</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">setupBindings</span><span class="s3">[</span><span class="s1">id</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]) {</span>
        <span class="s1">error</span><span class="s3">(</span>
          <span class="s2">`</span><span class="s0">\`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">method</span><span class="s3">}</span><span class="s2">()</span><span class="s0">\` </span><span class="s2">in &lt;script setup&gt; cannot reference locally ` </span><span class="s3">+</span>
            <span class="s2">`declared variables because it will be hoisted outside of the ` </span><span class="s3">+</span>
            <span class="s2">`setup() function. If your component options require initialization ` </span><span class="s3">+</span>
            <span class="s2">`in the module scope, use a separate normal &lt;script&gt; to export ` </span><span class="s3">+</span>
            <span class="s2">`the options instead.`</span><span class="s3">,</span>
          <span class="s1">id</span>
        <span class="s3">)</span>
      <span class="s3">}</span>
    <span class="s3">})</span>
  <span class="s3">}</span>

  <span class="s5">/**</span>
   <span class="s5">* check defaults. If the default object is an object literal with only</span>
   <span class="s5">* static properties, we can directly generate more optimized default</span>
   <span class="s5">* declarations. Otherwise we will have to fallback to runtime merging.</span>
   <span class="s5">*/</span>
  <span class="s0">function </span><span class="s1">hasStaticWithDefaults</span><span class="s3">() {</span>
    <span class="s0">return </span><span class="s3">(</span>
      <span class="s1">propsRuntimeDefaults </span><span class="s3">&amp;&amp;</span>
      <span class="s1">propsRuntimeDefaults</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectExpression' </span><span class="s3">&amp;&amp;</span>
      <span class="s1">propsRuntimeDefaults</span><span class="s3">.</span><span class="s1">properties</span><span class="s3">.</span><span class="s1">every</span><span class="s3">(</span>
        <span class="s1">node </span><span class="s3">=&gt;</span>
          <span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectProperty' </span><span class="s3">&amp;&amp; !</span><span class="s1">node</span><span class="s3">.</span><span class="s1">computed</span><span class="s3">) ||</span>
          <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectMethod'</span>
      <span class="s3">)</span>
    <span class="s3">)</span>
  <span class="s3">}</span>

  <span class="s0">function </span><span class="s1">genRuntimeProps</span><span class="s3">(</span><span class="s1">props</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">PropTypeData</span><span class="s3">&gt;) {</span>
    <span class="s0">const </span><span class="s1">keys </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">props</span><span class="s3">)</span>
    <span class="s0">if </span><span class="s3">(!</span><span class="s1">keys</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) {</span>
      <span class="s0">return </span><span class="s2">``</span>
    <span class="s3">}</span>
    <span class="s0">const </span><span class="s1">hasStaticDefaults </span><span class="s3">= </span><span class="s1">hasStaticWithDefaults</span><span class="s3">()</span>
    <span class="s0">const </span><span class="s1">scriptSetupSource </span><span class="s3">= </span><span class="s1">scriptSetup</span><span class="s3">!.</span><span class="s1">content</span>
    <span class="s0">let </span><span class="s1">propsDecls </span><span class="s3">= </span><span class="s2">`{ 
    </span><span class="s1">$</span><span class="s3">{</span><span class="s1">keys</span>
      <span class="s3">.</span><span class="s1">map</span><span class="s3">(</span><span class="s1">key </span><span class="s3">=&gt; {</span>
        <span class="s0">let </span><span class="s1">defaultString</span><span class="s3">: </span><span class="s1">string </span><span class="s3">| </span><span class="s1">undefined</span>
        <span class="s0">const </span><span class="s1">destructured </span><span class="s3">= </span><span class="s1">genDestructuredDefaultValue</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">destructured</span><span class="s3">) {</span>
          <span class="s1">defaultString </span><span class="s3">= </span><span class="s2">`default: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">destructured</span><span class="s3">}</span><span class="s2">`</span>
        <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">hasStaticDefaults</span><span class="s3">) {</span>
          <span class="s0">const </span><span class="s1">prop </span><span class="s3">= </span><span class="s1">propsRuntimeDefaults</span><span class="s3">!.</span><span class="s1">properties</span><span class="s3">.</span><span class="s1">find</span><span class="s3">(</span>
            <span class="s3">(</span><span class="s1">node</span><span class="s3">: </span><span class="s1">any</span><span class="s3">) =&gt; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=== </span><span class="s1">key</span>
          <span class="s3">) as </span><span class="s1">ObjectProperty </span><span class="s3">| </span><span class="s1">ObjectMethod</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">prop</span><span class="s3">) {</span>
            <span class="s0">if </span><span class="s3">(</span><span class="s1">prop</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectProperty'</span><span class="s3">) {</span>
              <span class="s4">// prop has corresponding static default value</span>
              <span class="s1">defaultString </span><span class="s3">= </span><span class="s2">`default: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">scriptSetupSource</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span>
                <span class="s1">prop</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">start</span><span class="s3">!,</span>
                <span class="s1">prop</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">end</span><span class="s3">!</span>
              <span class="s3">)}</span><span class="s2">`</span>
            <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
              <span class="s1">defaultString </span><span class="s3">= </span><span class="s2">`default() </span><span class="s1">$</span><span class="s3">{</span><span class="s1">scriptSetupSource</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span>
                <span class="s1">prop</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">start</span><span class="s3">!,</span>
                <span class="s1">prop</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">end</span><span class="s3">!</span>
              <span class="s3">)}</span><span class="s2">`</span>
            <span class="s3">}</span>
          <span class="s3">}</span>
        <span class="s3">}</span>

        <span class="s0">const </span><span class="s3">{ </span><span class="s1">type</span><span class="s3">, </span><span class="s1">required </span><span class="s3">} = </span><span class="s1">props</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]</span>
        <span class="s0">if </span><span class="s3">(!</span><span class="s1">isProd</span><span class="s3">) {</span>
          <span class="s0">return </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">key</span><span class="s3">}</span><span class="s2">: { type: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">toRuntimeTypeString</span><span class="s3">(</span>
            <span class="s1">type</span>
          <span class="s3">)}</span><span class="s2">, required: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">required</span><span class="s3">}</span><span class="s1">$</span><span class="s3">{</span>
            <span class="s1">defaultString </span><span class="s3">? </span><span class="s2">`, </span><span class="s1">$</span><span class="s3">{</span><span class="s1">defaultString</span><span class="s3">}</span><span class="s2">` </span><span class="s3">: </span><span class="s2">``</span>
          <span class="s3">} </span><span class="s2">}`</span>
        <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span>
          <span class="s1">type</span><span class="s3">.</span><span class="s1">some</span><span class="s3">(</span>
            <span class="s1">el </span><span class="s3">=&gt; </span><span class="s1">el </span><span class="s3">=== </span><span class="s2">'Boolean' </span><span class="s3">|| (</span><span class="s1">defaultString </span><span class="s3">&amp;&amp; </span><span class="s1">el </span><span class="s3">=== </span><span class="s2">'Function'</span><span class="s3">)</span>
          <span class="s3">)</span>
        <span class="s3">) {</span>
          <span class="s4">// #4783 production: if boolean or defaultString and function exists, should keep the type.</span>
          <span class="s0">return </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">key</span><span class="s3">}</span><span class="s2">: { type: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">toRuntimeTypeString</span><span class="s3">(</span><span class="s1">type</span><span class="s3">)}</span><span class="s1">$</span><span class="s3">{</span>
            <span class="s1">defaultString </span><span class="s3">? </span><span class="s2">`, </span><span class="s1">$</span><span class="s3">{</span><span class="s1">defaultString</span><span class="s3">}</span><span class="s2">` </span><span class="s3">: </span><span class="s2">``</span>
          <span class="s3">} </span><span class="s2">}`</span>
        <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
          <span class="s4">// production: checks are useless</span>
          <span class="s0">return </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">key</span><span class="s3">}</span><span class="s2">: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">defaultString </span><span class="s3">? </span><span class="s2">`{ </span><span class="s1">$</span><span class="s3">{</span><span class="s1">defaultString</span><span class="s3">} </span><span class="s2">}` </span><span class="s3">: </span><span class="s2">'null'</span><span class="s3">}</span><span class="s2">`</span>
        <span class="s3">}</span>
      <span class="s3">})</span>
      <span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s2">',</span><span class="s0">\n    </span><span class="s2">'</span><span class="s3">)}</span><span class="s0">\n  </span><span class="s2">}`</span>

    <span class="s0">if </span><span class="s3">(</span><span class="s1">propsRuntimeDefaults </span><span class="s3">&amp;&amp; !</span><span class="s1">hasStaticDefaults</span><span class="s3">) {</span>
      <span class="s1">propsDecls </span><span class="s3">= </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">helper</span><span class="s3">(</span><span class="s2">'mergeDefaults'</span><span class="s3">)}</span><span class="s2">(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">propsDecls</span><span class="s3">}</span><span class="s2">, </span><span class="s1">$</span><span class="s3">{</span><span class="s1">source</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span>
        <span class="s1">propsRuntimeDefaults</span><span class="s3">.</span><span class="s1">start</span><span class="s3">! + </span><span class="s1">startOffset</span><span class="s3">,</span>
        <span class="s1">propsRuntimeDefaults</span><span class="s3">.</span><span class="s1">end</span><span class="s3">! + </span><span class="s1">startOffset</span>
      <span class="s3">)}</span><span class="s2">)`</span>
    <span class="s3">}</span>

    <span class="s0">return </span><span class="s2">`</span><span class="s0">\n  </span><span class="s2">props: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">propsDecls</span><span class="s3">}</span><span class="s2">,`</span>
  <span class="s3">}</span>

  <span class="s0">function </span><span class="s1">genDestructuredDefaultValue</span><span class="s3">(</span><span class="s1">key</span><span class="s3">: </span><span class="s1">string</span><span class="s3">): </span><span class="s1">string </span><span class="s3">| </span><span class="s1">undefined </span><span class="s3">{</span>
    <span class="s0">const </span><span class="s1">destructured </span><span class="s3">= </span><span class="s1">propsDestructuredBindings</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">destructured </span><span class="s3">&amp;&amp; </span><span class="s1">destructured</span><span class="s3">.</span><span class="s1">default</span><span class="s3">) {</span>
      <span class="s0">const </span><span class="s1">value </span><span class="s3">= </span><span class="s1">scriptSetup</span><span class="s3">!.</span><span class="s1">content</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span>
        <span class="s1">destructured</span><span class="s3">.</span><span class="s1">default</span><span class="s3">.</span><span class="s1">start</span><span class="s3">!,</span>
        <span class="s1">destructured</span><span class="s3">.</span><span class="s1">default</span><span class="s3">.</span><span class="s1">end</span><span class="s3">!</span>
      <span class="s3">)</span>
      <span class="s0">const </span><span class="s1">isLiteral </span><span class="s3">= </span><span class="s1">destructured</span><span class="s3">.</span><span class="s1">default</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">endsWith</span><span class="s3">(</span><span class="s2">'Literal'</span><span class="s3">)</span>
      <span class="s0">return </span><span class="s1">isLiteral </span><span class="s3">? </span><span class="s1">value </span><span class="s3">: </span><span class="s2">`() =&gt; (</span><span class="s1">$</span><span class="s3">{</span><span class="s1">value</span><span class="s3">}</span><span class="s2">)`</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s0">function </span><span class="s1">genSetupPropsType</span><span class="s3">(</span><span class="s1">node</span><span class="s3">: </span><span class="s1">TSTypeLiteral </span><span class="s3">| </span><span class="s1">TSInterfaceBody</span><span class="s3">) {</span>
    <span class="s0">const </span><span class="s1">scriptSetupSource </span><span class="s3">= </span><span class="s1">scriptSetup</span><span class="s3">!.</span><span class="s1">content</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">hasStaticWithDefaults</span><span class="s3">()) {</span>
      <span class="s4">// if withDefaults() is used, we need to remove the optional flags</span>
      <span class="s4">// on props that have default values</span>
      <span class="s0">let </span><span class="s1">res </span><span class="s3">= </span><span class="s2">`{ `</span>
      <span class="s0">const </span><span class="s1">members </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSTypeLiteral' </span><span class="s3">? </span><span class="s1">node</span><span class="s3">.</span><span class="s1">members </span><span class="s3">: </span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span>
      <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">m of members</span><span class="s3">) {</span>
        <span class="s0">if </span><span class="s3">(</span>
          <span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSPropertySignature' </span><span class="s3">||</span>
            <span class="s1">m</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSMethodSignature'</span><span class="s3">) &amp;&amp;</span>
          <span class="s1">m</span><span class="s3">.</span><span class="s1">typeAnnotation </span><span class="s3">&amp;&amp;</span>
          <span class="s1">m</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'Identifier'</span>
        <span class="s3">) {</span>
          <span class="s0">if </span><span class="s3">(</span>
            <span class="s1">propsRuntimeDefaults</span><span class="s3">!.</span><span class="s1">properties</span><span class="s3">.</span><span class="s1">some</span><span class="s3">(</span>
              <span class="s3">(</span><span class="s1">p</span><span class="s3">: </span><span class="s1">any</span><span class="s3">) =&gt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=== (</span><span class="s1">m</span><span class="s3">.</span><span class="s1">key </span><span class="s3">as </span><span class="s1">Identifier</span><span class="s3">).</span><span class="s1">name</span>
            <span class="s3">)</span>
          <span class="s3">) {</span>
            <span class="s1">res </span><span class="s3">+=</span>
              <span class="s1">m</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">name </span><span class="s3">+</span>
              <span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSMethodSignature' </span><span class="s3">? </span><span class="s2">'()' </span><span class="s3">: </span><span class="s2">''</span><span class="s3">) +</span>
              <span class="s1">scriptSetupSource</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span>
                <span class="s1">m</span><span class="s3">.</span><span class="s1">typeAnnotation</span><span class="s3">.</span><span class="s1">start</span><span class="s3">!,</span>
                <span class="s1">m</span><span class="s3">.</span><span class="s1">typeAnnotation</span><span class="s3">.</span><span class="s1">end</span><span class="s3">!</span>
              <span class="s3">) +</span>
              <span class="s2">', '</span>
          <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
            <span class="s1">res </span><span class="s3">+=</span>
              <span class="s1">scriptSetupSource</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">start</span><span class="s3">!, </span><span class="s1">m</span><span class="s3">.</span><span class="s1">typeAnnotation</span><span class="s3">.</span><span class="s1">end</span><span class="s3">!) + </span><span class="s2">`, `</span>
          <span class="s3">}</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
      <span class="s0">return </span><span class="s3">(</span><span class="s1">res</span><span class="s3">.</span><span class="s1">length </span><span class="s3">? </span><span class="s1">res</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">0</span><span class="s3">, -</span><span class="s7">2</span><span class="s3">) : </span><span class="s1">res</span><span class="s3">) + </span><span class="s2">` }`</span>
    <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
      <span class="s0">return </span><span class="s1">scriptSetupSource</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">start</span><span class="s3">!, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">end</span><span class="s3">!)</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s4">// 1. process normal &lt;script&gt; first if it exists</span>
  <span class="s0">let </span><span class="s1">scriptAst</span><span class="s3">: </span><span class="s1">Program </span><span class="s3">| </span><span class="s1">undefined</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">script</span><span class="s3">) {</span>
    <span class="s1">scriptAst </span><span class="s3">= </span><span class="s1">parse</span><span class="s3">(</span>
      <span class="s1">script</span><span class="s3">.</span><span class="s1">content</span><span class="s3">,</span>
      <span class="s3">{</span>
        <span class="s1">plugins</span><span class="s3">,</span>
        <span class="s1">sourceType</span><span class="s3">: </span><span class="s2">'module'</span>
      <span class="s3">},</span>
      <span class="s1">scriptStartOffset</span><span class="s3">!</span>
    <span class="s3">)</span>

    <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">node of scriptAst</span><span class="s3">.</span><span class="s1">body</span><span class="s3">) {</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ImportDeclaration'</span><span class="s3">) {</span>
        <span class="s4">// record imports for dedupe</span>
        <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">specifier of node</span><span class="s3">.</span><span class="s1">specifiers</span><span class="s3">) {</span>
          <span class="s0">const </span><span class="s1">imported </span><span class="s3">=</span>
            <span class="s1">specifier</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ImportSpecifier' </span><span class="s3">&amp;&amp;</span>
            <span class="s1">specifier</span><span class="s3">.</span><span class="s1">imported</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'Identifier' </span><span class="s3">&amp;&amp;</span>
            <span class="s1">specifier</span><span class="s3">.</span><span class="s1">imported</span><span class="s3">.</span><span class="s1">name</span>
          <span class="s1">registerUserImport</span><span class="s3">(</span>
            <span class="s1">node</span><span class="s3">.</span><span class="s1">source</span><span class="s3">.</span><span class="s1">value</span><span class="s3">,</span>
            <span class="s1">specifier</span><span class="s3">.</span><span class="s1">local</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,</span>
            <span class="s1">imported</span><span class="s3">,</span>
            <span class="s1">node</span><span class="s3">.</span><span class="s1">importKind </span><span class="s3">=== </span><span class="s2">'type' </span><span class="s3">||</span>
              <span class="s3">(</span><span class="s1">specifier</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ImportSpecifier' </span><span class="s3">&amp;&amp;</span>
                <span class="s1">specifier</span><span class="s3">.</span><span class="s1">importKind </span><span class="s3">=== </span><span class="s2">'type'</span><span class="s3">),</span>
            <span class="s0">false</span>
          <span class="s3">)</span>
        <span class="s3">}</span>
      <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ExportDefaultDeclaration'</span><span class="s3">) {</span>
        <span class="s4">// export default</span>
        <span class="s1">defaultExport </span><span class="s3">= </span><span class="s1">node</span>

        <span class="s4">// check if user has manually specified `name` or 'render` option in</span>
        <span class="s4">// export default</span>
        <span class="s4">// if has name, skip name inference</span>
        <span class="s4">// if has render and no template, generate return object instead of</span>
        <span class="s4">// empty render function (#4980)</span>
        <span class="s0">let </span><span class="s1">optionProperties</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">defaultExport</span><span class="s3">.</span><span class="s1">declaration</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectExpression'</span><span class="s3">) {</span>
          <span class="s1">optionProperties </span><span class="s3">= </span><span class="s1">defaultExport</span><span class="s3">.</span><span class="s1">declaration</span><span class="s3">.</span><span class="s1">properties</span>
        <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span>
          <span class="s1">defaultExport</span><span class="s3">.</span><span class="s1">declaration</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'CallExpression' </span><span class="s3">&amp;&amp;</span>
          <span class="s1">defaultExport</span><span class="s3">.</span><span class="s1">declaration</span><span class="s3">.</span><span class="s1">arguments</span><span class="s3">[</span><span class="s7">0</span><span class="s3">].</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectExpression'</span>
        <span class="s3">) {</span>
          <span class="s1">optionProperties </span><span class="s3">= </span><span class="s1">defaultExport</span><span class="s3">.</span><span class="s1">declaration</span><span class="s3">.</span><span class="s1">arguments</span><span class="s3">[</span><span class="s7">0</span><span class="s3">].</span><span class="s1">properties</span>
        <span class="s3">}</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">optionProperties</span><span class="s3">) {</span>
          <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">s of optionProperties</span><span class="s3">) {</span>
            <span class="s0">if </span><span class="s3">(</span>
              <span class="s1">s</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectProperty' </span><span class="s3">&amp;&amp;</span>
              <span class="s1">s</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'Identifier' </span><span class="s3">&amp;&amp;</span>
              <span class="s1">s</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=== </span><span class="s2">'name'</span>
            <span class="s3">) {</span>
              <span class="s1">hasDefaultExportName </span><span class="s3">= </span><span class="s0">true</span>
            <span class="s3">}</span>
          <span class="s3">}</span>
        <span class="s3">}</span>

        <span class="s4">// export default { ... } --&gt; const __default__ = { ... }</span>
        <span class="s0">const </span><span class="s1">start </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">start</span><span class="s3">! + </span><span class="s1">scriptStartOffset</span><span class="s3">!</span>
        <span class="s0">const </span><span class="s1">end </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">declaration</span><span class="s3">.</span><span class="s1">start</span><span class="s3">! + </span><span class="s1">scriptStartOffset</span><span class="s3">!</span>
        <span class="s1">s</span><span class="s3">.</span><span class="s1">overwrite</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s2">`const </span><span class="s1">$</span><span class="s3">{</span><span class="s1">DEFAULT_VAR</span><span class="s3">} </span><span class="s2">= `</span><span class="s3">)</span>
      <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ExportNamedDeclaration'</span><span class="s3">) {</span>
        <span class="s0">const </span><span class="s1">defaultSpecifier </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">specifiers</span><span class="s3">.</span><span class="s1">find</span><span class="s3">(</span>
          <span class="s1">s </span><span class="s3">=&gt; </span><span class="s1">s</span><span class="s3">.</span><span class="s1">exported</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'Identifier' </span><span class="s3">&amp;&amp; </span><span class="s1">s</span><span class="s3">.</span><span class="s1">exported</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=== </span><span class="s2">'default'</span>
        <span class="s3">) as </span><span class="s1">ExportSpecifier</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">defaultSpecifier</span><span class="s3">) {</span>
          <span class="s1">defaultExport </span><span class="s3">= </span><span class="s1">node</span>
          <span class="s4">// 1. remove specifier</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">specifiers</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">1</span><span class="s3">) {</span>
            <span class="s1">s</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span>
              <span class="s1">defaultSpecifier</span><span class="s3">.</span><span class="s1">start</span><span class="s3">! + </span><span class="s1">scriptStartOffset</span><span class="s3">!,</span>
              <span class="s1">defaultSpecifier</span><span class="s3">.</span><span class="s1">end</span><span class="s3">! + </span><span class="s1">scriptStartOffset</span><span class="s3">!</span>
            <span class="s3">)</span>
          <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
            <span class="s1">s</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span>
              <span class="s1">node</span><span class="s3">.</span><span class="s1">start</span><span class="s3">! + </span><span class="s1">scriptStartOffset</span><span class="s3">!,</span>
              <span class="s1">node</span><span class="s3">.</span><span class="s1">end</span><span class="s3">! + </span><span class="s1">scriptStartOffset</span><span class="s3">!</span>
            <span class="s3">)</span>
          <span class="s3">}</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">source</span><span class="s3">) {</span>
            <span class="s4">// export { x as default } from './x'</span>
            <span class="s4">// rewrite to `import { x as __default__ } from './x'` and</span>
            <span class="s4">// add to top</span>
            <span class="s1">s</span><span class="s3">.</span><span class="s1">prepend</span><span class="s3">(</span>
              <span class="s2">`import { </span><span class="s1">$</span><span class="s3">{</span><span class="s1">defaultSpecifier</span><span class="s3">.</span><span class="s1">local</span><span class="s3">.</span><span class="s1">name</span><span class="s3">} </span><span class="s2">as </span><span class="s1">$</span><span class="s3">{</span><span class="s1">DEFAULT_VAR</span><span class="s3">} </span><span class="s2">} from '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">node</span><span class="s3">.</span><span class="s1">source</span><span class="s3">.</span><span class="s1">value</span><span class="s3">}</span><span class="s2">'</span><span class="s0">\n</span><span class="s2">`</span>
            <span class="s3">)</span>
          <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
            <span class="s4">// export { x as default }</span>
            <span class="s4">// rewrite to `const __default__ = x` and move to end</span>
            <span class="s1">s</span><span class="s3">.</span><span class="s1">appendLeft</span><span class="s3">(</span>
              <span class="s1">scriptEndOffset</span><span class="s3">!,</span>
              <span class="s2">`</span><span class="s0">\n</span><span class="s2">const </span><span class="s1">$</span><span class="s3">{</span><span class="s1">DEFAULT_VAR</span><span class="s3">} </span><span class="s2">= </span><span class="s1">$</span><span class="s3">{</span><span class="s1">defaultSpecifier</span><span class="s3">.</span><span class="s1">local</span><span class="s3">.</span><span class="s1">name</span><span class="s3">}</span><span class="s0">\n</span><span class="s2">`</span>
            <span class="s3">)</span>
          <span class="s3">}</span>
        <span class="s3">}</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">declaration</span><span class="s3">) {</span>
          <span class="s1">walkDeclaration</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">declaration</span><span class="s3">, </span><span class="s1">scriptBindings</span><span class="s3">, </span><span class="s1">userImportAlias</span><span class="s3">)</span>
        <span class="s3">}</span>
      <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span>
        <span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'VariableDeclaration' </span><span class="s3">||</span>
          <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'FunctionDeclaration' </span><span class="s3">||</span>
          <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ClassDeclaration' </span><span class="s3">||</span>
          <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSEnumDeclaration'</span><span class="s3">) &amp;&amp;</span>
        <span class="s3">!</span><span class="s1">node</span><span class="s3">.</span><span class="s1">declare</span>
      <span class="s3">) {</span>
        <span class="s1">walkDeclaration</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">scriptBindings</span><span class="s3">, </span><span class="s1">userImportAlias</span><span class="s3">)</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s4">// apply reactivity transform</span>
    <span class="s4">// if (enableReactivityTransform &amp;&amp; shouldTransform(script.content)) {</span>
    <span class="s4">//   const { rootRefs, importedHelpers } = transformAST(</span>
    <span class="s4">//     scriptAst,</span>
    <span class="s4">//     s,</span>
    <span class="s4">//     scriptStartOffset!</span>
    <span class="s4">//   )</span>
    <span class="s4">//   refBindings = rootRefs</span>
    <span class="s4">//   for (const h of importedHelpers) {</span>
    <span class="s4">//     helperImports.add(h)</span>
    <span class="s4">//   }</span>
    <span class="s4">// }</span>

    <span class="s4">// &lt;script&gt; after &lt;script setup&gt;</span>
    <span class="s4">// we need to move the block up so that `const __default__` is</span>
    <span class="s4">// declared before being used in the actual component definition</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">scriptStartOffset</span><span class="s3">! &gt; </span><span class="s1">startOffset</span><span class="s3">) {</span>
      <span class="s4">// if content doesn't end with newline, add one</span>
      <span class="s0">if </span><span class="s3">(!</span><span class="s6">/\n$/</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">script</span><span class="s3">.</span><span class="s1">content</span><span class="s3">.</span><span class="s1">trim</span><span class="s3">())) {</span>
        <span class="s1">s</span><span class="s3">.</span><span class="s1">appendLeft</span><span class="s3">(</span><span class="s1">scriptEndOffset</span><span class="s3">!, </span><span class="s2">`</span><span class="s0">\n</span><span class="s2">`</span><span class="s3">)</span>
      <span class="s3">}</span>
      <span class="s1">s</span><span class="s3">.</span><span class="s1">move</span><span class="s3">(</span><span class="s1">scriptStartOffset</span><span class="s3">!, </span><span class="s1">scriptEndOffset</span><span class="s3">!, </span><span class="s7">0</span><span class="s3">)</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s4">// 2. parse &lt;script setup&gt; and  walk over top level statements</span>
  <span class="s0">const </span><span class="s1">scriptSetupAst </span><span class="s3">= </span><span class="s1">parse</span><span class="s3">(</span>
    <span class="s1">scriptSetup</span><span class="s3">.</span><span class="s1">content</span><span class="s3">,</span>
    <span class="s3">{</span>
      <span class="s1">plugins</span><span class="s3">: [</span>
        <span class="s1">...plugins</span><span class="s3">,</span>
        <span class="s4">// allow top level await but only inside &lt;script setup&gt;</span>
        <span class="s2">'topLevelAwait'</span>
      <span class="s3">],</span>
      <span class="s1">sourceType</span><span class="s3">: </span><span class="s2">'module'</span>
    <span class="s3">},</span>
    <span class="s1">startOffset</span>
  <span class="s3">)</span>

  <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">node of scriptSetupAst</span><span class="s3">.</span><span class="s1">body</span><span class="s3">) {</span>
    <span class="s0">const </span><span class="s1">start </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">start</span><span class="s3">! + </span><span class="s1">startOffset</span>
    <span class="s0">let </span><span class="s1">end </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">end</span><span class="s3">! + </span><span class="s1">startOffset</span>
    <span class="s4">// locate comment</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">trailingComments </span><span class="s3">&amp;&amp; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">trailingComments</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
      <span class="s0">const </span><span class="s1">lastCommentNode </span><span class="s3">=</span>
        <span class="s1">node</span><span class="s3">.</span><span class="s1">trailingComments</span><span class="s3">[</span><span class="s1">node</span><span class="s3">.</span><span class="s1">trailingComments</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s7">1</span><span class="s3">]</span>
      <span class="s1">end </span><span class="s3">= </span><span class="s1">lastCommentNode</span><span class="s3">.</span><span class="s1">end</span><span class="s3">! + </span><span class="s1">startOffset</span>
    <span class="s3">}</span>
    <span class="s4">// locate the end of whitespace between this statement and the next</span>
    <span class="s0">while </span><span class="s3">(</span><span class="s1">end </span><span class="s3">&lt;= </span><span class="s1">source</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) {</span>
      <span class="s0">if </span><span class="s3">(!</span><span class="s6">/\s/</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">source</span><span class="s3">.</span><span class="s1">charAt</span><span class="s3">(</span><span class="s1">end</span><span class="s3">))) {</span>
        <span class="s0">break</span>
      <span class="s3">}</span>
      <span class="s1">end</span><span class="s3">++</span>
    <span class="s3">}</span>

    <span class="s4">// (Dropped) `ref: x` bindings</span>
    <span class="s0">if </span><span class="s3">(</span>
      <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'LabeledStatement' </span><span class="s3">&amp;&amp;</span>
      <span class="s1">node</span><span class="s3">.</span><span class="s1">label</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=== </span><span class="s2">'ref' </span><span class="s3">&amp;&amp;</span>
      <span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ExpressionStatement'</span>
    <span class="s3">) {</span>
      <span class="s1">error</span><span class="s3">(</span>
        <span class="s2">`ref sugar using the label syntax was an experimental proposal and ` </span><span class="s3">+</span>
          <span class="s2">`has been dropped based on community feedback. Please check out ` </span><span class="s3">+</span>
          <span class="s2">`the new proposal at https://github.com/vuejs/rfcs/discussions/369`</span><span class="s3">,</span>
        <span class="s1">node</span>
      <span class="s3">)</span>
    <span class="s3">}</span>

    <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ImportDeclaration'</span><span class="s3">) {</span>
      <span class="s4">// import declarations are moved to top</span>
      <span class="s1">s</span><span class="s3">.</span><span class="s1">move</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s7">0</span><span class="s3">)</span>

      <span class="s4">// dedupe imports</span>
      <span class="s0">let </span><span class="s1">removed </span><span class="s3">= </span><span class="s7">0</span>
      <span class="s0">const </span><span class="s1">removeSpecifier </span><span class="s3">= (</span><span class="s1">i</span><span class="s3">: </span><span class="s1">number</span><span class="s3">) =&gt; {</span>
        <span class="s0">const </span><span class="s1">removeLeft </span><span class="s3">= </span><span class="s1">i </span><span class="s3">&gt; </span><span class="s1">removed</span>
        <span class="s1">removed</span><span class="s3">++</span>
        <span class="s0">const </span><span class="s1">current </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">specifiers</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s0">const </span><span class="s1">next </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">specifiers</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s7">1</span><span class="s3">]</span>
        <span class="s1">s</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span>
          <span class="s1">removeLeft</span>
            <span class="s3">? </span><span class="s1">node</span><span class="s3">.</span><span class="s1">specifiers</span><span class="s3">[</span><span class="s1">i </span><span class="s3">- </span><span class="s7">1</span><span class="s3">].</span><span class="s1">end</span><span class="s3">! + </span><span class="s1">startOffset</span>
            <span class="s3">: </span><span class="s1">current</span><span class="s3">.</span><span class="s1">start</span><span class="s3">! + </span><span class="s1">startOffset</span><span class="s3">,</span>
          <span class="s1">next </span><span class="s3">&amp;&amp; !</span><span class="s1">removeLeft</span>
            <span class="s3">? </span><span class="s1">next</span><span class="s3">.</span><span class="s1">start</span><span class="s3">! + </span><span class="s1">startOffset</span>
            <span class="s3">: </span><span class="s1">current</span><span class="s3">.</span><span class="s1">end</span><span class="s3">! + </span><span class="s1">startOffset</span>
        <span class="s3">)</span>
      <span class="s3">}</span>

      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">i </span><span class="s3">= </span><span class="s7">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">specifiers</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
        <span class="s0">const </span><span class="s1">specifier </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">specifiers</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s0">const </span><span class="s1">local </span><span class="s3">= </span><span class="s1">specifier</span><span class="s3">.</span><span class="s1">local</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s0">let </span><span class="s1">imported </span><span class="s3">=</span>
          <span class="s1">specifier</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ImportSpecifier' </span><span class="s3">&amp;&amp;</span>
          <span class="s1">specifier</span><span class="s3">.</span><span class="s1">imported</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'Identifier' </span><span class="s3">&amp;&amp;</span>
          <span class="s1">specifier</span><span class="s3">.</span><span class="s1">imported</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">specifier</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ImportNamespaceSpecifier'</span><span class="s3">) {</span>
          <span class="s1">imported </span><span class="s3">= </span><span class="s2">'*'</span>
        <span class="s3">}</span>
        <span class="s0">const </span><span class="s1">source </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">source</span><span class="s3">.</span><span class="s1">value</span>
        <span class="s0">const </span><span class="s1">existing </span><span class="s3">= </span><span class="s1">userImports</span><span class="s3">[</span><span class="s1">local</span><span class="s3">]</span>
        <span class="s0">if </span><span class="s3">(</span>
          <span class="s1">source </span><span class="s3">=== </span><span class="s2">'vue' </span><span class="s3">&amp;&amp;</span>
          <span class="s3">(</span><span class="s1">imported </span><span class="s3">=== </span><span class="s1">DEFINE_PROPS </span><span class="s3">||</span>
            <span class="s1">imported </span><span class="s3">=== </span><span class="s1">DEFINE_EMITS </span><span class="s3">||</span>
            <span class="s1">imported </span><span class="s3">=== </span><span class="s1">DEFINE_EXPOSE</span><span class="s3">)</span>
        <span class="s3">) {</span>
          <span class="s1">warnOnce</span><span class="s3">(</span>
            <span class="s2">`</span><span class="s0">\`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">imported</span><span class="s3">}</span><span class="s0">\` </span><span class="s2">is a compiler macro and no longer needs to be imported.`</span>
          <span class="s3">)</span>
          <span class="s1">removeSpecifier</span><span class="s3">(</span><span class="s1">i</span><span class="s3">)</span>
        <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">existing</span><span class="s3">) {</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">existing</span><span class="s3">.</span><span class="s1">source </span><span class="s3">=== </span><span class="s1">source </span><span class="s3">&amp;&amp; </span><span class="s1">existing</span><span class="s3">.</span><span class="s1">imported </span><span class="s3">=== </span><span class="s1">imported</span><span class="s3">) {</span>
            <span class="s4">// already imported in &lt;script setup&gt;, dedupe</span>
            <span class="s1">removeSpecifier</span><span class="s3">(</span><span class="s1">i</span><span class="s3">)</span>
          <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
            <span class="s1">error</span><span class="s3">(</span><span class="s2">`different imports aliased to same local name.`</span><span class="s3">, </span><span class="s1">specifier</span><span class="s3">)</span>
          <span class="s3">}</span>
        <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
          <span class="s1">registerUserImport</span><span class="s3">(</span>
            <span class="s1">source</span><span class="s3">,</span>
            <span class="s1">local</span><span class="s3">,</span>
            <span class="s1">imported</span><span class="s3">,</span>
            <span class="s1">node</span><span class="s3">.</span><span class="s1">importKind </span><span class="s3">=== </span><span class="s2">'type' </span><span class="s3">||</span>
              <span class="s3">(</span><span class="s1">specifier</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ImportSpecifier' </span><span class="s3">&amp;&amp;</span>
                <span class="s1">specifier</span><span class="s3">.</span><span class="s1">importKind </span><span class="s3">=== </span><span class="s2">'type'</span><span class="s3">),</span>
            <span class="s0">true</span>
          <span class="s3">)</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">specifiers</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&amp;&amp; </span><span class="s1">removed </span><span class="s3">=== </span><span class="s1">node</span><span class="s3">.</span><span class="s1">specifiers</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) {</span>
        <span class="s1">s</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">start</span><span class="s3">! + </span><span class="s1">startOffset</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">end</span><span class="s3">! + </span><span class="s1">startOffset</span><span class="s3">)</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ExpressionStatement'</span><span class="s3">) {</span>
      <span class="s4">// process `defineProps` and `defineEmit(s)` calls</span>
      <span class="s0">if </span><span class="s3">(</span>
        <span class="s1">processDefineProps</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">expression</span><span class="s3">) ||</span>
        <span class="s1">processDefineEmits</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">expression</span><span class="s3">) ||</span>
        <span class="s1">processWithDefaults</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">expression</span><span class="s3">)</span>
      <span class="s3">) {</span>
        <span class="s1">s</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">start</span><span class="s3">! + </span><span class="s1">startOffset</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">end</span><span class="s3">! + </span><span class="s1">startOffset</span><span class="s3">)</span>
      <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">processDefineExpose</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">expression</span><span class="s3">)) {</span>
        <span class="s4">// defineExpose({}) -&gt; expose({})</span>
        <span class="s0">const </span><span class="s1">callee </span><span class="s3">= (</span><span class="s1">node</span><span class="s3">.</span><span class="s1">expression </span><span class="s3">as </span><span class="s1">CallExpression</span><span class="s3">).</span><span class="s1">callee</span>
        <span class="s1">s</span><span class="s3">.</span><span class="s1">overwrite</span><span class="s3">(</span>
          <span class="s1">callee</span><span class="s3">.</span><span class="s1">start</span><span class="s3">! + </span><span class="s1">startOffset</span><span class="s3">,</span>
          <span class="s1">callee</span><span class="s3">.</span><span class="s1">end</span><span class="s3">! + </span><span class="s1">startOffset</span><span class="s3">,</span>
          <span class="s2">'expose'</span>
        <span class="s3">)</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'VariableDeclaration' </span><span class="s3">&amp;&amp; !</span><span class="s1">node</span><span class="s3">.</span><span class="s1">declare</span><span class="s3">) {</span>
      <span class="s0">const </span><span class="s1">total </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">declarations</span><span class="s3">.</span><span class="s1">length</span>
      <span class="s0">let </span><span class="s1">left </span><span class="s3">= </span><span class="s1">total</span>
      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">i </span><span class="s3">= </span><span class="s7">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">total</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
        <span class="s0">const </span><span class="s1">decl </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">declarations</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">decl</span><span class="s3">.</span><span class="s1">init</span><span class="s3">) {</span>
          <span class="s4">// defineProps / defineEmits</span>
          <span class="s0">const </span><span class="s1">isDefineProps </span><span class="s3">=</span>
            <span class="s1">processDefineProps</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">.</span><span class="s1">init</span><span class="s3">, </span><span class="s1">decl</span><span class="s3">.</span><span class="s1">id</span><span class="s3">) ||</span>
            <span class="s1">processWithDefaults</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">.</span><span class="s1">init</span><span class="s3">, </span><span class="s1">decl</span><span class="s3">.</span><span class="s1">id</span><span class="s3">)</span>
          <span class="s0">const </span><span class="s1">isDefineEmits </span><span class="s3">= </span><span class="s1">processDefineEmits</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">.</span><span class="s1">init</span><span class="s3">, </span><span class="s1">decl</span><span class="s3">.</span><span class="s1">id</span><span class="s3">)</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">isDefineProps </span><span class="s3">|| </span><span class="s1">isDefineEmits</span><span class="s3">) {</span>
            <span class="s0">if </span><span class="s3">(</span><span class="s1">left </span><span class="s3">=== </span><span class="s7">1</span><span class="s3">) {</span>
              <span class="s1">s</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">start</span><span class="s3">! + </span><span class="s1">startOffset</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">end</span><span class="s3">! + </span><span class="s1">startOffset</span><span class="s3">)</span>
            <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
              <span class="s0">let </span><span class="s1">start </span><span class="s3">= </span><span class="s1">decl</span><span class="s3">.</span><span class="s1">start</span><span class="s3">! + </span><span class="s1">startOffset</span>
              <span class="s0">let </span><span class="s1">end </span><span class="s3">= </span><span class="s1">decl</span><span class="s3">.</span><span class="s1">end</span><span class="s3">! + </span><span class="s1">startOffset</span>
              <span class="s0">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">total </span><span class="s3">- </span><span class="s7">1</span><span class="s3">) {</span>
                <span class="s4">// not the last one, locate the start of the next</span>
                <span class="s1">end </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">declarations</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s7">1</span><span class="s3">].</span><span class="s1">start</span><span class="s3">! + </span><span class="s1">startOffset</span>
              <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
                <span class="s4">// last one, locate the end of the prev</span>
                <span class="s1">start </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">declarations</span><span class="s3">[</span><span class="s1">i </span><span class="s3">- </span><span class="s7">1</span><span class="s3">].</span><span class="s1">end</span><span class="s3">! + </span><span class="s1">startOffset</span>
              <span class="s3">}</span>
              <span class="s1">s</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>
              <span class="s1">left</span><span class="s3">--</span>
            <span class="s3">}</span>
          <span class="s3">}</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s4">// walk declarations to record declared bindings</span>
    <span class="s0">if </span><span class="s3">(</span>
      <span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'VariableDeclaration' </span><span class="s3">||</span>
        <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'FunctionDeclaration' </span><span class="s3">||</span>
        <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ClassDeclaration'</span><span class="s3">) &amp;&amp;</span>
      <span class="s3">!</span><span class="s1">node</span><span class="s3">.</span><span class="s1">declare</span>
    <span class="s3">) {</span>
      <span class="s1">walkDeclaration</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">setupBindings</span><span class="s3">, </span><span class="s1">userImportAlias</span><span class="s3">)</span>
    <span class="s3">}</span>

    <span class="s4">// walk statements &amp; named exports / variable declarations for top level</span>
    <span class="s4">// await</span>
    <span class="s0">if </span><span class="s3">(</span>
      <span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'VariableDeclaration' </span><span class="s3">&amp;&amp; !</span><span class="s1">node</span><span class="s3">.</span><span class="s1">declare</span><span class="s3">) ||</span>
      <span class="s1">node</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">endsWith</span><span class="s3">(</span><span class="s2">'Statement'</span><span class="s3">)</span>
    <span class="s3">) {</span>
      <span class="s0">const </span><span class="s1">scope</span><span class="s3">: </span><span class="s1">Statement</span><span class="s3">[][] = [</span><span class="s1">scriptSetupAst</span><span class="s3">.</span><span class="s1">body</span><span class="s3">]</span>
      <span class="s3">;(</span><span class="s1">walk </span><span class="s3">as </span><span class="s1">any</span><span class="s3">)(</span><span class="s1">node</span><span class="s3">, {</span>
        <span class="s1">enter</span><span class="s3">(</span><span class="s1">child</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">) {</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">isFunctionType</span><span class="s3">(</span><span class="s1">child</span><span class="s3">)) {</span>
            <span class="s0">this</span><span class="s3">.</span><span class="s1">skip</span><span class="s3">()</span>
          <span class="s3">}</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">child</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'BlockStatement'</span><span class="s3">) {</span>
            <span class="s1">scope</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">child</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)</span>
          <span class="s3">}</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">child</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'AwaitExpression'</span><span class="s3">) {</span>
            <span class="s1">error</span><span class="s3">(</span>
              <span class="s2">`Vue 2 does not support top level await in &lt;script setup&gt;.`</span><span class="s3">,</span>
              <span class="s1">child</span>
            <span class="s3">)</span>
          <span class="s3">}</span>
        <span class="s3">},</span>
        <span class="s1">exit</span><span class="s3">(</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">) {</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'BlockStatement'</span><span class="s3">) </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
        <span class="s3">}</span>
      <span class="s3">})</span>
    <span class="s3">}</span>

    <span class="s0">if </span><span class="s3">(</span>
      <span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ExportNamedDeclaration' </span><span class="s3">&amp;&amp; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">exportKind </span><span class="s3">!== </span><span class="s2">'type'</span><span class="s3">) ||</span>
      <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ExportAllDeclaration' </span><span class="s3">||</span>
      <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ExportDefaultDeclaration'</span>
    <span class="s3">) {</span>
      <span class="s1">error</span><span class="s3">(</span>
        <span class="s2">`&lt;script setup&gt; cannot contain ES module exports. ` </span><span class="s3">+</span>
          <span class="s2">`If you are using a previous version of &lt;script setup&gt;, please ` </span><span class="s3">+</span>
          <span class="s2">`consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.`</span><span class="s3">,</span>
        <span class="s1">node</span>
      <span class="s3">)</span>
    <span class="s3">}</span>

    <span class="s0">if </span><span class="s3">(</span><span class="s1">isTS</span><span class="s3">) {</span>
      <span class="s4">// runtime enum</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSEnumDeclaration'</span><span class="s3">) {</span>
        <span class="s1">registerBinding</span><span class="s3">(</span><span class="s1">setupBindings</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">id</span><span class="s3">, </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_CONST</span><span class="s3">)</span>
      <span class="s3">}</span>

      <span class="s4">// move all Type declarations to outer scope</span>
      <span class="s0">if </span><span class="s3">(</span>
        <span class="s1">node</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">startsWith</span><span class="s3">(</span><span class="s2">'TS'</span><span class="s3">) ||</span>
        <span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ExportNamedDeclaration' </span><span class="s3">&amp;&amp;</span>
          <span class="s1">node</span><span class="s3">.</span><span class="s1">exportKind </span><span class="s3">=== </span><span class="s2">'type'</span><span class="s3">) ||</span>
        <span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'VariableDeclaration' </span><span class="s3">&amp;&amp; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">declare</span><span class="s3">)</span>
      <span class="s3">) {</span>
        <span class="s1">recordType</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">declaredTypes</span><span class="s3">)</span>
        <span class="s1">s</span><span class="s3">.</span><span class="s1">move</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s7">0</span><span class="s3">)</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s4">// 3. Apply reactivity transform</span>
  <span class="s4">// if (</span>
  <span class="s4">//   (enableReactivityTransform &amp;&amp;</span>
  <span class="s4">//     // normal &lt;script&gt; had ref bindings that maybe used in &lt;script setup&gt;</span>
  <span class="s4">//     (refBindings || shouldTransform(scriptSetup.content))) ||</span>
  <span class="s4">//   propsDestructureDecl</span>
  <span class="s4">// ) {</span>
  <span class="s4">//   const { rootRefs, importedHelpers } = transformAST(</span>
  <span class="s4">//     scriptSetupAst,</span>
  <span class="s4">//     s,</span>
  <span class="s4">//     startOffset,</span>
  <span class="s4">//     refBindings,</span>
  <span class="s4">//     propsDestructuredBindings</span>
  <span class="s4">//   )</span>
  <span class="s4">//   refBindings = refBindings ? [...refBindings, ...rootRefs] : rootRefs</span>
  <span class="s4">//   for (const h of importedHelpers) {</span>
  <span class="s4">//     helperImports.add(h)</span>
  <span class="s4">//   }</span>
  <span class="s4">// }</span>

  <span class="s4">// 4. extract runtime props/emits code from setup context type</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">propsTypeDecl</span><span class="s3">) {</span>
    <span class="s1">extractRuntimeProps</span><span class="s3">(</span><span class="s1">propsTypeDecl</span><span class="s3">, </span><span class="s1">typeDeclaredProps</span><span class="s3">, </span><span class="s1">declaredTypes</span><span class="s3">, </span><span class="s1">isProd</span><span class="s3">)</span>
  <span class="s3">}</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">emitsTypeDecl</span><span class="s3">) {</span>
    <span class="s1">extractRuntimeEmits</span><span class="s3">(</span><span class="s1">emitsTypeDecl</span><span class="s3">, </span><span class="s1">typeDeclaredEmits</span><span class="s3">)</span>
  <span class="s3">}</span>

  <span class="s4">// 5. check useOptions args to make sure it doesn't reference setup scope</span>
  <span class="s4">// variables</span>
  <span class="s1">checkInvalidScopeReference</span><span class="s3">(</span><span class="s1">propsRuntimeDecl</span><span class="s3">, </span><span class="s1">DEFINE_PROPS</span><span class="s3">)</span>
  <span class="s1">checkInvalidScopeReference</span><span class="s3">(</span><span class="s1">propsRuntimeDefaults</span><span class="s3">, </span><span class="s1">DEFINE_PROPS</span><span class="s3">)</span>
  <span class="s1">checkInvalidScopeReference</span><span class="s3">(</span><span class="s1">propsDestructureDecl</span><span class="s3">, </span><span class="s1">DEFINE_PROPS</span><span class="s3">)</span>
  <span class="s1">checkInvalidScopeReference</span><span class="s3">(</span><span class="s1">emitsRuntimeDecl</span><span class="s3">, </span><span class="s1">DEFINE_EMITS</span><span class="s3">)</span>

  <span class="s4">// 6. remove non-script content</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">script</span><span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">startOffset </span><span class="s3">&lt; </span><span class="s1">scriptStartOffset</span><span class="s3">!) {</span>
      <span class="s4">// &lt;script setup&gt; before &lt;script&gt;</span>
      <span class="s1">s</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s7">0</span><span class="s3">, </span><span class="s1">startOffset</span><span class="s3">)</span>
      <span class="s1">s</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">endOffset</span><span class="s3">, </span><span class="s1">scriptStartOffset</span><span class="s3">!)</span>
      <span class="s1">s</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">scriptEndOffset</span><span class="s3">!, </span><span class="s1">source</span><span class="s3">.</span><span class="s1">length</span><span class="s3">)</span>
    <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
      <span class="s4">// &lt;script&gt; before &lt;script setup&gt;</span>
      <span class="s1">s</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s7">0</span><span class="s3">, </span><span class="s1">scriptStartOffset</span><span class="s3">!)</span>
      <span class="s1">s</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">scriptEndOffset</span><span class="s3">!, </span><span class="s1">startOffset</span><span class="s3">)</span>
      <span class="s1">s</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">endOffset</span><span class="s3">, </span><span class="s1">source</span><span class="s3">.</span><span class="s1">length</span><span class="s3">)</span>
    <span class="s3">}</span>
  <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
    <span class="s4">// only &lt;script setup&gt;</span>
    <span class="s1">s</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s7">0</span><span class="s3">, </span><span class="s1">startOffset</span><span class="s3">)</span>
    <span class="s1">s</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">endOffset</span><span class="s3">, </span><span class="s1">source</span><span class="s3">.</span><span class="s1">length</span><span class="s3">)</span>
  <span class="s3">}</span>

  <span class="s4">// 7. analyze binding metadata</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">scriptAst</span><span class="s3">) {</span>
    <span class="s1">Object</span><span class="s3">.</span><span class="s1">assign</span><span class="s3">(</span><span class="s1">bindingMetadata</span><span class="s3">, </span><span class="s1">analyzeScriptBindings</span><span class="s3">(</span><span class="s1">scriptAst</span><span class="s3">.</span><span class="s1">body</span><span class="s3">))</span>
  <span class="s3">}</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">propsRuntimeDecl</span><span class="s3">) {</span>
    <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">key of getObjectOrArrayExpressionKeys</span><span class="s3">(</span><span class="s1">propsRuntimeDecl</span><span class="s3">)) {</span>
      <span class="s1">bindingMetadata</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">PROPS</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">key </span><span class="s0">in </span><span class="s1">typeDeclaredProps</span><span class="s3">) {</span>
    <span class="s1">bindingMetadata</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">PROPS</span>
  <span class="s3">}</span>
  <span class="s4">// props aliases</span>
  <span class="s4">// if (propsDestructureDecl) {</span>
  <span class="s4">//   if (propsDestructureRestId) {</span>
  <span class="s4">//     bindingMetadata[propsDestructureRestId] =</span>
  <span class="s4">//       BindingTypes.SETUP_REACTIVE_CONST</span>
  <span class="s4">//   }</span>
  <span class="s4">//   for (const key in propsDestructuredBindings) {</span>
  <span class="s4">//     const { local } = propsDestructuredBindings[key]</span>
  <span class="s4">//     if (local !== key) {</span>
  <span class="s4">//       bindingMetadata[local] = BindingTypes.PROPS_ALIASED</span>
  <span class="s4">//       ;(bindingMetadata.__propsAliases ||</span>
  <span class="s4">//         (bindingMetadata.__propsAliases = {}))[local] = key</span>
  <span class="s4">//     }</span>
  <span class="s4">//   }</span>
  <span class="s4">// }</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s3">[</span><span class="s1">key</span><span class="s3">, { </span><span class="s1">isType</span><span class="s3">, </span><span class="s1">imported</span><span class="s3">, </span><span class="s1">source </span><span class="s3">}] </span><span class="s1">of Object</span><span class="s3">.</span><span class="s1">entries</span><span class="s3">(</span>
    <span class="s1">userImports</span>
  <span class="s3">)) {</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">isType</span><span class="s3">) </span><span class="s0">continue</span>
    <span class="s1">bindingMetadata</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] =</span>
      <span class="s1">imported </span><span class="s3">=== </span><span class="s2">'*' </span><span class="s3">||</span>
      <span class="s3">(</span><span class="s1">imported </span><span class="s3">=== </span><span class="s2">'default' </span><span class="s3">&amp;&amp; </span><span class="s1">source</span><span class="s3">.</span><span class="s1">endsWith</span><span class="s3">(</span><span class="s2">'.vue'</span><span class="s3">)) ||</span>
      <span class="s1">source </span><span class="s3">=== </span><span class="s2">'vue'</span>
        <span class="s3">? </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_CONST</span>
        <span class="s3">: </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_MAYBE_REF</span>
  <span class="s3">}</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">key </span><span class="s0">in </span><span class="s1">scriptBindings</span><span class="s3">) {</span>
    <span class="s1">bindingMetadata</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">scriptBindings</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]</span>
  <span class="s3">}</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">key </span><span class="s0">in </span><span class="s1">setupBindings</span><span class="s3">) {</span>
    <span class="s1">bindingMetadata</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">setupBindings</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]</span>
  <span class="s3">}</span>
  <span class="s4">// known ref bindings</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">refBindings</span><span class="s3">) {</span>
    <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">key of refBindings</span><span class="s3">) {</span>
      <span class="s1">bindingMetadata</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_REF</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s4">// 8. inject `useCssVars` calls</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">cssVars</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) {</span>
    <span class="s1">helperImports</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">CSS_VARS_HELPER</span><span class="s3">)</span>
    <span class="s1">s</span><span class="s3">.</span><span class="s1">prependRight</span><span class="s3">(</span>
      <span class="s1">startOffset</span><span class="s3">,</span>
      <span class="s2">`</span><span class="s0">\n</span><span class="s1">$</span><span class="s3">{</span><span class="s1">genCssVarsCode</span><span class="s3">(</span><span class="s1">cssVars</span><span class="s3">, </span><span class="s1">bindingMetadata</span><span class="s3">, </span><span class="s1">scopeId</span><span class="s3">, </span><span class="s1">isProd</span><span class="s3">)}</span><span class="s0">\n</span><span class="s2">`</span>
    <span class="s3">)</span>
  <span class="s3">}</span>

  <span class="s4">// 9. finalize setup() argument signature</span>
  <span class="s0">let </span><span class="s1">args </span><span class="s3">= </span><span class="s2">`__props`</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">propsTypeDecl</span><span class="s3">) {</span>
    <span class="s4">// mark as any and only cast on assignment</span>
    <span class="s4">// since the user defined complex types may be incompatible with the</span>
    <span class="s4">// inferred type from generated runtime declarations</span>
    <span class="s1">args </span><span class="s3">+= </span><span class="s2">`: any`</span>
  <span class="s3">}</span>
  <span class="s4">// inject user assignment of props</span>
  <span class="s4">// we use a default __props so that template expressions referencing props</span>
  <span class="s4">// can use it directly</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">propsIdentifier</span><span class="s3">) {</span>
    <span class="s1">s</span><span class="s3">.</span><span class="s1">prependLeft</span><span class="s3">(</span>
      <span class="s1">startOffset</span><span class="s3">,</span>
      <span class="s2">`</span><span class="s0">\n</span><span class="s2">const </span><span class="s1">$</span><span class="s3">{</span><span class="s1">propsIdentifier</span><span class="s3">} </span><span class="s2">= __props</span><span class="s1">$</span><span class="s3">{</span>
        <span class="s1">propsTypeDecl </span><span class="s3">? </span><span class="s2">` as </span><span class="s1">$</span><span class="s3">{</span><span class="s1">genSetupPropsType</span><span class="s3">(</span><span class="s1">propsTypeDecl</span><span class="s3">)}</span><span class="s2">` </span><span class="s3">: </span><span class="s2">``</span>
      <span class="s3">}</span><span class="s0">\n</span><span class="s2">`</span>
    <span class="s3">)</span>
  <span class="s3">}</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">propsDestructureRestId</span><span class="s3">) {</span>
    <span class="s1">s</span><span class="s3">.</span><span class="s1">prependLeft</span><span class="s3">(</span>
      <span class="s1">startOffset</span><span class="s3">,</span>
      <span class="s2">`</span><span class="s0">\n</span><span class="s2">const </span><span class="s1">$</span><span class="s3">{</span><span class="s1">propsDestructureRestId</span><span class="s3">} </span><span class="s2">= </span><span class="s1">$</span><span class="s3">{</span><span class="s1">helper</span><span class="s3">(</span>
        <span class="s2">`createPropsRestProxy`</span>
      <span class="s3">)}</span><span class="s2">(__props, </span><span class="s1">$</span><span class="s3">{</span><span class="s1">JSON</span><span class="s3">.</span><span class="s1">stringify</span><span class="s3">(</span><span class="s1">Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">propsDestructuredBindings</span><span class="s3">))}</span><span class="s2">)</span><span class="s0">\n</span><span class="s2">`</span>
    <span class="s3">)</span>
  <span class="s3">}</span>

  <span class="s0">const </span><span class="s1">destructureElements </span><span class="s3">= </span><span class="s1">hasDefineExposeCall </span><span class="s3">? [</span><span class="s2">`expose`</span><span class="s3">] : []</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">emitIdentifier</span><span class="s3">) {</span>
    <span class="s1">destructureElements</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span>
      <span class="s1">emitIdentifier </span><span class="s3">=== </span><span class="s2">`emit` </span><span class="s3">? </span><span class="s2">`emit` </span><span class="s3">: </span><span class="s2">`emit: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">emitIdentifier</span><span class="s3">}</span><span class="s2">`</span>
    <span class="s3">)</span>
  <span class="s3">}</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">destructureElements</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) {</span>
    <span class="s1">args </span><span class="s3">+= </span><span class="s2">`, { </span><span class="s1">$</span><span class="s3">{</span><span class="s1">destructureElements</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s2">', '</span><span class="s3">)} </span><span class="s2">}`</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">emitsTypeDecl</span><span class="s3">) {</span>
      <span class="s1">args </span><span class="s3">+= </span><span class="s2">`: { emit: (</span><span class="s1">$</span><span class="s3">{</span><span class="s1">scriptSetup</span><span class="s3">.</span><span class="s1">content</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span>
        <span class="s1">emitsTypeDecl</span><span class="s3">.</span><span class="s1">start</span><span class="s3">!,</span>
        <span class="s1">emitsTypeDecl</span><span class="s3">.</span><span class="s1">end</span><span class="s3">!</span>
      <span class="s3">)}</span><span class="s2">), expose: any, slots: any, attrs: any }`</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s4">// 10. generate return statement</span>
  <span class="s0">const </span><span class="s1">allBindings</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">any</span><span class="s3">&gt; = {</span>
    <span class="s1">...scriptBindings</span><span class="s3">,</span>
    <span class="s1">...setupBindings</span>
  <span class="s3">}</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">key </span><span class="s0">in </span><span class="s1">userImports</span><span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(!</span><span class="s1">userImports</span><span class="s3">[</span><span class="s1">key</span><span class="s3">].</span><span class="s1">isType </span><span class="s3">&amp;&amp; </span><span class="s1">userImports</span><span class="s3">[</span><span class="s1">key</span><span class="s3">].</span><span class="s1">isUsedInTemplate</span><span class="s3">) {</span>
      <span class="s1">allBindings</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s0">true</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
  <span class="s4">// __sfc marker indicates these bindings are compiled from &lt;script setup&gt;</span>
  <span class="s4">// and should not be proxied on `this`</span>
  <span class="s0">const </span><span class="s1">returned </span><span class="s3">= </span><span class="s2">`{ </span><span class="s1">$</span><span class="s3">{</span><span class="s1">__TEST__ </span><span class="s3">? </span><span class="s2">`` </span><span class="s3">: </span><span class="s2">`__sfc: true,`</span><span class="s3">}</span><span class="s1">$</span><span class="s3">{</span><span class="s1">Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span>
    <span class="s1">allBindings</span>
  <span class="s3">).</span><span class="s1">join</span><span class="s3">(</span><span class="s2">', '</span><span class="s3">)} </span><span class="s2">}`</span>

  <span class="s1">s</span><span class="s3">.</span><span class="s1">appendRight</span><span class="s3">(</span><span class="s1">endOffset</span><span class="s3">, </span><span class="s2">`</span><span class="s0">\n</span><span class="s2">return </span><span class="s1">$</span><span class="s3">{</span><span class="s1">returned</span><span class="s3">}</span><span class="s0">\n</span><span class="s2">}</span><span class="s0">\n\n</span><span class="s2">`</span><span class="s3">)</span>

  <span class="s4">// 11. finalize default export</span>
  <span class="s0">let </span><span class="s1">runtimeOptions </span><span class="s3">= </span><span class="s2">``</span>
  <span class="s0">if </span><span class="s3">(!</span><span class="s1">hasDefaultExportName </span><span class="s3">&amp;&amp; </span><span class="s1">filename </span><span class="s3">&amp;&amp; </span><span class="s1">filename </span><span class="s3">!== </span><span class="s1">DEFAULT_FILENAME</span><span class="s3">) {</span>
    <span class="s0">const </span><span class="s1">match </span><span class="s3">= </span><span class="s1">filename</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s6">/([^/\\]+)\.\w+$/</span><span class="s3">)</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">match</span><span class="s3">) {</span>
      <span class="s1">runtimeOptions </span><span class="s3">+= </span><span class="s2">`</span><span class="s0">\n  </span><span class="s2">__name: '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">match</span><span class="s3">[</span><span class="s7">1</span><span class="s3">]}</span><span class="s2">',`</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">hasInlinedSsrRenderFn</span><span class="s3">) {</span>
    <span class="s1">runtimeOptions </span><span class="s3">+= </span><span class="s2">`</span><span class="s0">\n  </span><span class="s2">__ssrInlineRender: true,`</span>
  <span class="s3">}</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">propsRuntimeDecl</span><span class="s3">) {</span>
    <span class="s0">let </span><span class="s1">declCode </span><span class="s3">= </span><span class="s1">scriptSetup</span><span class="s3">.</span><span class="s1">content</span>
      <span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">propsRuntimeDecl</span><span class="s3">.</span><span class="s1">start</span><span class="s3">!, </span><span class="s1">propsRuntimeDecl</span><span class="s3">.</span><span class="s1">end</span><span class="s3">!)</span>
      <span class="s3">.</span><span class="s1">trim</span><span class="s3">()</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">propsDestructureDecl</span><span class="s3">) {</span>
      <span class="s0">const </span><span class="s1">defaults</span><span class="s3">: </span><span class="s1">string</span><span class="s3">[] = []</span>
      <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">key </span><span class="s0">in </span><span class="s1">propsDestructuredBindings</span><span class="s3">) {</span>
        <span class="s0">const </span><span class="s1">d </span><span class="s3">= </span><span class="s1">genDestructuredDefaultValue</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">d</span><span class="s3">) </span><span class="s1">defaults</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">key</span><span class="s3">}</span><span class="s2">: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">d</span><span class="s3">}</span><span class="s2">`</span><span class="s3">)</span>
      <span class="s3">}</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">defaults</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) {</span>
        <span class="s1">declCode </span><span class="s3">= </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">helper</span><span class="s3">(</span>
          <span class="s2">`mergeDefaults`</span>
        <span class="s3">)}</span><span class="s2">(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">declCode</span><span class="s3">}</span><span class="s2">, {</span><span class="s0">\n  </span><span class="s1">$</span><span class="s3">{</span><span class="s1">defaults</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s2">',</span><span class="s0">\n  </span><span class="s2">'</span><span class="s3">)}</span><span class="s0">\n</span><span class="s2">})`</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
    <span class="s1">runtimeOptions </span><span class="s3">+= </span><span class="s2">`</span><span class="s0">\n  </span><span class="s2">props: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">declCode</span><span class="s3">}</span><span class="s2">,`</span>
  <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">propsTypeDecl</span><span class="s3">) {</span>
    <span class="s1">runtimeOptions </span><span class="s3">+= </span><span class="s1">genRuntimeProps</span><span class="s3">(</span><span class="s1">typeDeclaredProps</span><span class="s3">)</span>
  <span class="s3">}</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">emitsRuntimeDecl</span><span class="s3">) {</span>
    <span class="s1">runtimeOptions </span><span class="s3">+= </span><span class="s2">`</span><span class="s0">\n  </span><span class="s2">emits: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">scriptSetup</span><span class="s3">.</span><span class="s1">content</span>
      <span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">emitsRuntimeDecl</span><span class="s3">.</span><span class="s1">start</span><span class="s3">!, </span><span class="s1">emitsRuntimeDecl</span><span class="s3">.</span><span class="s1">end</span><span class="s3">!)</span>
      <span class="s3">.</span><span class="s1">trim</span><span class="s3">()}</span><span class="s2">,`</span>
  <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">emitsTypeDecl</span><span class="s3">) {</span>
    <span class="s1">runtimeOptions </span><span class="s3">+= </span><span class="s1">genRuntimeEmits</span><span class="s3">(</span><span class="s1">typeDeclaredEmits</span><span class="s3">)</span>
  <span class="s3">}</span>

  <span class="s4">// wrap setup code with function.</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">isTS</span><span class="s3">) {</span>
    <span class="s4">// for TS, make sure the exported type is still valid type with</span>
    <span class="s4">// correct props information</span>
    <span class="s4">// we have to use object spread for types to be merged properly</span>
    <span class="s4">// user's TS setting should compile it down to proper targets</span>
    <span class="s4">// export default defineComponent({ ...__default__, ... })</span>
    <span class="s0">const </span><span class="s1">def </span><span class="s3">= </span><span class="s1">defaultExport </span><span class="s3">? </span><span class="s2">`</span><span class="s0">\n  </span><span class="s2">...</span><span class="s1">$</span><span class="s3">{</span><span class="s1">DEFAULT_VAR</span><span class="s3">}</span><span class="s2">,` </span><span class="s3">: </span><span class="s2">``</span>
    <span class="s1">s</span><span class="s3">.</span><span class="s1">prependLeft</span><span class="s3">(</span>
      <span class="s1">startOffset</span><span class="s3">,</span>
      <span class="s2">`</span><span class="s0">\n</span><span class="s2">export default /*#__PURE__*/</span><span class="s1">$</span><span class="s3">{</span><span class="s1">helper</span><span class="s3">(</span>
        <span class="s2">`defineComponent`</span>
      <span class="s3">)}</span><span class="s2">({</span><span class="s1">$</span><span class="s3">{</span><span class="s1">def</span><span class="s3">}</span><span class="s1">$</span><span class="s3">{</span><span class="s1">runtimeOptions</span><span class="s3">}</span><span class="s0">\n  </span><span class="s2">setup(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">args</span><span class="s3">}</span><span class="s2">) {</span><span class="s0">\n</span><span class="s2">`</span>
    <span class="s3">)</span>
    <span class="s1">s</span><span class="s3">.</span><span class="s1">appendRight</span><span class="s3">(</span><span class="s1">endOffset</span><span class="s3">, </span><span class="s2">`})`</span><span class="s3">)</span>
  <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">defaultExport</span><span class="s3">) {</span>
      <span class="s4">// without TS, can't rely on rest spread, so we use Object.assign</span>
      <span class="s4">// export default Object.assign(__default__, { ... })</span>
      <span class="s1">s</span><span class="s3">.</span><span class="s1">prependLeft</span><span class="s3">(</span>
        <span class="s1">startOffset</span><span class="s3">,</span>
        <span class="s2">`</span><span class="s0">\n</span><span class="s2">export default /*#__PURE__*/Object.assign(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">DEFAULT_VAR</span><span class="s3">}</span><span class="s2">, {</span><span class="s1">$</span><span class="s3">{</span><span class="s1">runtimeOptions</span><span class="s3">}</span><span class="s0">\n  </span><span class="s2">` </span><span class="s3">+</span>
          <span class="s2">`setup(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">args</span><span class="s3">}</span><span class="s2">) {</span><span class="s0">\n</span><span class="s2">`</span>
      <span class="s3">)</span>
      <span class="s1">s</span><span class="s3">.</span><span class="s1">appendRight</span><span class="s3">(</span><span class="s1">endOffset</span><span class="s3">, </span><span class="s2">`})`</span><span class="s3">)</span>
    <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
      <span class="s1">s</span><span class="s3">.</span><span class="s1">prependLeft</span><span class="s3">(</span>
        <span class="s1">startOffset</span><span class="s3">,</span>
        <span class="s2">`</span><span class="s0">\n</span><span class="s2">export default {</span><span class="s1">$</span><span class="s3">{</span><span class="s1">runtimeOptions</span><span class="s3">}</span><span class="s0">\n  </span><span class="s2">setup(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">args</span><span class="s3">}</span><span class="s2">) {</span><span class="s0">\n</span><span class="s2">`</span>
      <span class="s3">)</span>
      <span class="s1">s</span><span class="s3">.</span><span class="s1">appendRight</span><span class="s3">(</span><span class="s1">endOffset</span><span class="s3">, </span><span class="s2">`}`</span><span class="s3">)</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s4">// 12. finalize Vue helper imports</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">helperImports</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
    <span class="s1">s</span><span class="s3">.</span><span class="s1">prepend</span><span class="s3">(</span>
      <span class="s2">`import { </span><span class="s1">$</span><span class="s3">{[</span><span class="s1">...helperImports</span><span class="s3">]</span>
        <span class="s3">.</span><span class="s1">map</span><span class="s3">(</span><span class="s1">h </span><span class="s3">=&gt; </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">h</span><span class="s3">} </span><span class="s2">as _</span><span class="s1">$</span><span class="s3">{</span><span class="s1">h</span><span class="s3">}</span><span class="s2">`</span><span class="s3">)</span>
        <span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s2">', '</span><span class="s3">)} </span><span class="s2">} from 'vue'</span><span class="s0">\n</span><span class="s2">`</span>
    <span class="s3">)</span>
  <span class="s3">}</span>

  <span class="s1">s</span><span class="s3">.</span><span class="s1">trim</span><span class="s3">()</span>

  <span class="s0">return </span><span class="s3">{</span>
    <span class="s1">...scriptSetup</span><span class="s3">,</span>
    <span class="s1">bindings</span><span class="s3">: </span><span class="s1">bindingMetadata</span><span class="s3">,</span>
    <span class="s1">imports</span><span class="s3">: </span><span class="s1">userImports</span><span class="s3">,</span>
    <span class="s1">content</span><span class="s3">: </span><span class="s1">s</span><span class="s3">.</span><span class="s1">toString</span><span class="s3">(),</span>
    <span class="s1">map</span><span class="s3">: </span><span class="s1">genSourceMap</span>
      <span class="s3">? (</span><span class="s1">s</span><span class="s3">.</span><span class="s1">generateMap</span><span class="s3">({</span>
          <span class="s1">source</span><span class="s3">: </span><span class="s1">filename</span><span class="s3">,</span>
          <span class="s1">hires</span><span class="s3">: </span><span class="s0">true</span><span class="s3">,</span>
          <span class="s1">includeContent</span><span class="s3">: </span><span class="s0">true</span>
        <span class="s3">}) as </span><span class="s1">unknown </span><span class="s3">as </span><span class="s1">RawSourceMap</span><span class="s3">)</span>
      <span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
    <span class="s1">scriptAst</span><span class="s3">: </span><span class="s1">scriptAst</span><span class="s3">?.</span><span class="s1">body</span><span class="s3">,</span>
    <span class="s1">scriptSetupAst</span><span class="s3">: </span><span class="s1">scriptSetupAst</span><span class="s3">?.</span><span class="s1">body</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">registerBinding</span><span class="s3">(</span>
  <span class="s1">bindings</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">BindingTypes</span><span class="s3">&gt;,</span>
  <span class="s1">node</span><span class="s3">: </span><span class="s1">Identifier</span><span class="s3">,</span>
  <span class="s1">type</span><span class="s3">: </span><span class="s1">BindingTypes</span>
<span class="s3">) {</span>
  <span class="s1">bindings</span><span class="s3">[</span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">type</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">walkDeclaration</span><span class="s3">(</span>
  <span class="s1">node</span><span class="s3">: </span><span class="s1">Declaration</span><span class="s3">,</span>
  <span class="s1">bindings</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">BindingTypes</span><span class="s3">&gt;,</span>
  <span class="s1">userImportAlias</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">string</span><span class="s3">&gt;</span>
<span class="s3">) {</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'VariableDeclaration'</span><span class="s3">) {</span>
    <span class="s0">const </span><span class="s1">isConst </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">=== </span><span class="s2">'const'</span>
    <span class="s4">// export const foo = ...</span>
    <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s3">{ </span><span class="s1">id</span><span class="s3">, </span><span class="s1">init </span><span class="s3">} </span><span class="s1">of node</span><span class="s3">.</span><span class="s1">declarations</span><span class="s3">) {</span>
      <span class="s0">const </span><span class="s1">isDefineCall </span><span class="s3">= !!(</span>
        <span class="s1">isConst </span><span class="s3">&amp;&amp;</span>
        <span class="s1">isCallOf</span><span class="s3">(</span>
          <span class="s1">init</span><span class="s3">,</span>
          <span class="s1">c </span><span class="s3">=&gt; </span><span class="s1">c </span><span class="s3">=== </span><span class="s1">DEFINE_PROPS </span><span class="s3">|| </span><span class="s1">c </span><span class="s3">=== </span><span class="s1">DEFINE_EMITS </span><span class="s3">|| </span><span class="s1">c </span><span class="s3">=== </span><span class="s1">WITH_DEFAULTS</span>
        <span class="s3">)</span>
      <span class="s3">)</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">id</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'Identifier'</span><span class="s3">) {</span>
        <span class="s0">let </span><span class="s1">bindingType</span>
        <span class="s0">const </span><span class="s1">userReactiveBinding </span><span class="s3">= </span><span class="s1">userImportAlias</span><span class="s3">[</span><span class="s2">'reactive'</span><span class="s3">] || </span><span class="s2">'reactive'</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">isCallOf</span><span class="s3">(</span><span class="s1">init</span><span class="s3">, </span><span class="s1">userReactiveBinding</span><span class="s3">)) {</span>
          <span class="s4">// treat reactive() calls as let since it's meant to be mutable</span>
          <span class="s1">bindingType </span><span class="s3">= </span><span class="s1">isConst</span>
            <span class="s3">? </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_REACTIVE_CONST</span>
            <span class="s3">: </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_LET</span>
        <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span>
          <span class="s4">// if a declaration is a const literal, we can mark it so that</span>
          <span class="s4">// the generated render fn code doesn't need to unref() it</span>
          <span class="s1">isDefineCall </span><span class="s3">||</span>
          <span class="s3">(</span><span class="s1">isConst </span><span class="s3">&amp;&amp; </span><span class="s1">canNeverBeRef</span><span class="s3">(</span><span class="s1">init</span><span class="s3">!, </span><span class="s1">userReactiveBinding</span><span class="s3">))</span>
        <span class="s3">) {</span>
          <span class="s1">bindingType </span><span class="s3">= </span><span class="s1">isCallOf</span><span class="s3">(</span><span class="s1">init</span><span class="s3">, </span><span class="s1">DEFINE_PROPS</span><span class="s3">)</span>
            <span class="s3">? </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_REACTIVE_CONST</span>
            <span class="s3">: </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_CONST</span>
        <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">isConst</span><span class="s3">) {</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">isCallOf</span><span class="s3">(</span><span class="s1">init</span><span class="s3">, </span><span class="s1">userImportAlias</span><span class="s3">[</span><span class="s2">'ref'</span><span class="s3">] || </span><span class="s2">'ref'</span><span class="s3">)) {</span>
            <span class="s1">bindingType </span><span class="s3">= </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_REF</span>
          <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
            <span class="s1">bindingType </span><span class="s3">= </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_MAYBE_REF</span>
          <span class="s3">}</span>
        <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
          <span class="s1">bindingType </span><span class="s3">= </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_LET</span>
        <span class="s3">}</span>
        <span class="s1">registerBinding</span><span class="s3">(</span><span class="s1">bindings</span><span class="s3">, </span><span class="s1">id</span><span class="s3">, </span><span class="s1">bindingType</span><span class="s3">)</span>
      <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">isCallOf</span><span class="s3">(</span><span class="s1">init</span><span class="s3">, </span><span class="s1">DEFINE_PROPS</span><span class="s3">)) {</span>
          <span class="s4">// skip walking props destructure</span>
          <span class="s0">return</span>
        <span class="s3">}</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">id</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectPattern'</span><span class="s3">) {</span>
          <span class="s1">walkObjectPattern</span><span class="s3">(</span><span class="s1">id</span><span class="s3">, </span><span class="s1">bindings</span><span class="s3">, </span><span class="s1">isConst</span><span class="s3">, </span><span class="s1">isDefineCall</span><span class="s3">)</span>
        <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">id</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ArrayPattern'</span><span class="s3">) {</span>
          <span class="s1">walkArrayPattern</span><span class="s3">(</span><span class="s1">id</span><span class="s3">, </span><span class="s1">bindings</span><span class="s3">, </span><span class="s1">isConst</span><span class="s3">, </span><span class="s1">isDefineCall</span><span class="s3">)</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span>
    <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSEnumDeclaration' </span><span class="s3">||</span>
    <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'FunctionDeclaration' </span><span class="s3">||</span>
    <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ClassDeclaration'</span>
  <span class="s3">) {</span>
    <span class="s4">// export function foo() {} / export class Foo {}</span>
    <span class="s4">// export declarations must be named.</span>
    <span class="s1">bindings</span><span class="s3">[</span><span class="s1">node</span><span class="s3">.</span><span class="s1">id</span><span class="s3">!.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_CONST</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">walkObjectPattern</span><span class="s3">(</span>
  <span class="s1">node</span><span class="s3">: </span><span class="s1">ObjectPattern</span><span class="s3">,</span>
  <span class="s1">bindings</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">BindingTypes</span><span class="s3">&gt;,</span>
  <span class="s1">isConst</span><span class="s3">: </span><span class="s1">boolean</span><span class="s3">,</span>
  <span class="s1">isDefineCall </span><span class="s3">= </span><span class="s0">false</span>
<span class="s3">) {</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">p of node</span><span class="s3">.</span><span class="s1">properties</span><span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectProperty'</span><span class="s3">) {</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'Identifier' </span><span class="s3">&amp;&amp; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">key </span><span class="s3">=== </span><span class="s1">p</span><span class="s3">.</span><span class="s1">value</span><span class="s3">) {</span>
        <span class="s4">// shorthand: const { x } = ...</span>
        <span class="s0">const </span><span class="s1">type </span><span class="s3">= </span><span class="s1">isDefineCall</span>
          <span class="s3">? </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_CONST</span>
          <span class="s3">: </span><span class="s1">isConst</span>
          <span class="s3">? </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_MAYBE_REF</span>
          <span class="s3">: </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_LET</span>
        <span class="s1">registerBinding</span><span class="s3">(</span><span class="s1">bindings</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">key</span><span class="s3">, </span><span class="s1">type</span><span class="s3">)</span>
      <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
        <span class="s1">walkPattern</span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">bindings</span><span class="s3">, </span><span class="s1">isConst</span><span class="s3">, </span><span class="s1">isDefineCall</span><span class="s3">)</span>
      <span class="s3">}</span>
    <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
      <span class="s4">// ...rest</span>
      <span class="s4">// argument can only be identifier when destructuring</span>
      <span class="s0">const </span><span class="s1">type </span><span class="s3">= </span><span class="s1">isConst </span><span class="s3">? </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_CONST </span><span class="s3">: </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_LET</span>
      <span class="s1">registerBinding</span><span class="s3">(</span><span class="s1">bindings</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">argument </span><span class="s3">as </span><span class="s1">Identifier</span><span class="s3">, </span><span class="s1">type</span><span class="s3">)</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">walkArrayPattern</span><span class="s3">(</span>
  <span class="s1">node</span><span class="s3">: </span><span class="s1">ArrayPattern</span><span class="s3">,</span>
  <span class="s1">bindings</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">BindingTypes</span><span class="s3">&gt;,</span>
  <span class="s1">isConst</span><span class="s3">: </span><span class="s1">boolean</span><span class="s3">,</span>
  <span class="s1">isDefineCall </span><span class="s3">= </span><span class="s0">false</span>
<span class="s3">) {</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">e of node</span><span class="s3">.</span><span class="s1">elements</span><span class="s3">) {</span>
    <span class="s1">e </span><span class="s3">&amp;&amp; </span><span class="s1">walkPattern</span><span class="s3">(</span><span class="s1">e</span><span class="s3">, </span><span class="s1">bindings</span><span class="s3">, </span><span class="s1">isConst</span><span class="s3">, </span><span class="s1">isDefineCall</span><span class="s3">)</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">walkPattern</span><span class="s3">(</span>
  <span class="s1">node</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">,</span>
  <span class="s1">bindings</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">BindingTypes</span><span class="s3">&gt;,</span>
  <span class="s1">isConst</span><span class="s3">: </span><span class="s1">boolean</span><span class="s3">,</span>
  <span class="s1">isDefineCall </span><span class="s3">= </span><span class="s0">false</span>
<span class="s3">) {</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'Identifier'</span><span class="s3">) {</span>
    <span class="s0">const </span><span class="s1">type </span><span class="s3">= </span><span class="s1">isDefineCall</span>
      <span class="s3">? </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_CONST</span>
      <span class="s3">: </span><span class="s1">isConst</span>
      <span class="s3">? </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_MAYBE_REF</span>
      <span class="s3">: </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_LET</span>
    <span class="s1">registerBinding</span><span class="s3">(</span><span class="s1">bindings</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">type</span><span class="s3">)</span>
  <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'RestElement'</span><span class="s3">) {</span>
    <span class="s4">// argument can only be identifier when destructuring</span>
    <span class="s0">const </span><span class="s1">type </span><span class="s3">= </span><span class="s1">isConst </span><span class="s3">? </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_CONST </span><span class="s3">: </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_LET</span>
    <span class="s1">registerBinding</span><span class="s3">(</span><span class="s1">bindings</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">argument </span><span class="s3">as </span><span class="s1">Identifier</span><span class="s3">, </span><span class="s1">type</span><span class="s3">)</span>
  <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectPattern'</span><span class="s3">) {</span>
    <span class="s1">walkObjectPattern</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">bindings</span><span class="s3">, </span><span class="s1">isConst</span><span class="s3">)</span>
  <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ArrayPattern'</span><span class="s3">) {</span>
    <span class="s1">walkArrayPattern</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">bindings</span><span class="s3">, </span><span class="s1">isConst</span><span class="s3">)</span>
  <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'AssignmentPattern'</span><span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">left</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'Identifier'</span><span class="s3">) {</span>
      <span class="s0">const </span><span class="s1">type </span><span class="s3">= </span><span class="s1">isDefineCall</span>
        <span class="s3">? </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_CONST</span>
        <span class="s3">: </span><span class="s1">isConst</span>
        <span class="s3">? </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_MAYBE_REF</span>
        <span class="s3">: </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_LET</span>
      <span class="s1">registerBinding</span><span class="s3">(</span><span class="s1">bindings</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">left</span><span class="s3">, </span><span class="s1">type</span><span class="s3">)</span>
    <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
      <span class="s1">walkPattern</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">left</span><span class="s3">, </span><span class="s1">bindings</span><span class="s3">, </span><span class="s1">isConst</span><span class="s3">)</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">interface </span><span class="s1">PropTypeData </span><span class="s3">{</span>
  <span class="s1">key</span><span class="s3">: </span><span class="s1">string</span>
  <span class="s1">type</span><span class="s3">: </span><span class="s1">string</span><span class="s3">[]</span>
  <span class="s1">required</span><span class="s3">: </span><span class="s1">boolean</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">recordType</span><span class="s3">(</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">, </span><span class="s1">declaredTypes</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">string</span><span class="s3">[]&gt;) {</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSInterfaceDeclaration'</span><span class="s3">) {</span>
    <span class="s1">declaredTypes</span><span class="s3">[</span><span class="s1">node</span><span class="s3">.</span><span class="s1">id</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = [</span><span class="s2">`Object`</span><span class="s3">]</span>
  <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSTypeAliasDeclaration'</span><span class="s3">) {</span>
    <span class="s1">declaredTypes</span><span class="s3">[</span><span class="s1">node</span><span class="s3">.</span><span class="s1">id</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">inferRuntimeType</span><span class="s3">(</span>
      <span class="s1">node</span><span class="s3">.</span><span class="s1">typeAnnotation</span><span class="s3">,</span>
      <span class="s1">declaredTypes</span>
    <span class="s3">)</span>
  <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ExportNamedDeclaration' </span><span class="s3">&amp;&amp; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">declaration</span><span class="s3">) {</span>
    <span class="s1">recordType</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">declaration</span><span class="s3">, </span><span class="s1">declaredTypes</span><span class="s3">)</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">extractRuntimeProps</span><span class="s3">(</span>
  <span class="s1">node</span><span class="s3">: </span><span class="s1">TSTypeLiteral </span><span class="s3">| </span><span class="s1">TSInterfaceBody</span><span class="s3">,</span>
  <span class="s1">props</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">PropTypeData</span><span class="s3">&gt;,</span>
  <span class="s1">declaredTypes</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">string</span><span class="s3">[]&gt;,</span>
  <span class="s1">isProd</span><span class="s3">: </span><span class="s1">boolean</span>
<span class="s3">) {</span>
  <span class="s0">const </span><span class="s1">members </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSTypeLiteral' </span><span class="s3">? </span><span class="s1">node</span><span class="s3">.</span><span class="s1">members </span><span class="s3">: </span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">m of members</span><span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(</span>
      <span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSPropertySignature' </span><span class="s3">|| </span><span class="s1">m</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSMethodSignature'</span><span class="s3">) &amp;&amp;</span>
      <span class="s1">m</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'Identifier'</span>
    <span class="s3">) {</span>
      <span class="s0">let </span><span class="s1">type</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSMethodSignature'</span><span class="s3">) {</span>
        <span class="s1">type </span><span class="s3">= [</span><span class="s2">'Function'</span><span class="s3">]</span>
      <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">typeAnnotation</span><span class="s3">) {</span>
        <span class="s1">type </span><span class="s3">= </span><span class="s1">inferRuntimeType</span><span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">typeAnnotation</span><span class="s3">.</span><span class="s1">typeAnnotation</span><span class="s3">, </span><span class="s1">declaredTypes</span><span class="s3">)</span>
      <span class="s3">}</span>
      <span class="s1">props</span><span class="s3">[</span><span class="s1">m</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = {</span>
        <span class="s1">key</span><span class="s3">: </span><span class="s1">m</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,</span>
        <span class="s1">required</span><span class="s3">: !</span><span class="s1">m</span><span class="s3">.</span><span class="s1">optional</span><span class="s3">,</span>
        <span class="s1">type</span><span class="s3">: </span><span class="s1">type </span><span class="s3">|| [</span><span class="s2">`null`</span><span class="s3">]</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">inferRuntimeType</span><span class="s3">(</span>
  <span class="s1">node</span><span class="s3">: </span><span class="s1">TSType</span><span class="s3">,</span>
  <span class="s1">declaredTypes</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">string</span><span class="s3">[]&gt;</span>
<span class="s3">): </span><span class="s1">string</span><span class="s3">[] {</span>
  <span class="s0">switch </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type</span><span class="s3">) {</span>
    <span class="s0">case </span><span class="s2">'TSStringKeyword'</span><span class="s3">:</span>
      <span class="s0">return </span><span class="s3">[</span><span class="s2">'String'</span><span class="s3">]</span>
    <span class="s0">case </span><span class="s2">'TSNumberKeyword'</span><span class="s3">:</span>
      <span class="s0">return </span><span class="s3">[</span><span class="s2">'Number'</span><span class="s3">]</span>
    <span class="s0">case </span><span class="s2">'TSBooleanKeyword'</span><span class="s3">:</span>
      <span class="s0">return </span><span class="s3">[</span><span class="s2">'Boolean'</span><span class="s3">]</span>
    <span class="s0">case </span><span class="s2">'TSObjectKeyword'</span><span class="s3">:</span>
      <span class="s0">return </span><span class="s3">[</span><span class="s2">'Object'</span><span class="s3">]</span>
    <span class="s0">case </span><span class="s2">'TSTypeLiteral'</span><span class="s3">:</span>
      <span class="s4">// TODO (nice to have) generate runtime property validation</span>
      <span class="s0">return </span><span class="s3">[</span><span class="s2">'Object'</span><span class="s3">]</span>
    <span class="s0">case </span><span class="s2">'TSFunctionType'</span><span class="s3">:</span>
      <span class="s0">return </span><span class="s3">[</span><span class="s2">'Function'</span><span class="s3">]</span>
    <span class="s0">case </span><span class="s2">'TSArrayType'</span><span class="s3">:</span>
    <span class="s0">case </span><span class="s2">'TSTupleType'</span><span class="s3">:</span>
      <span class="s4">// TODO (nice to have) generate runtime element type/length checks</span>
      <span class="s0">return </span><span class="s3">[</span><span class="s2">'Array'</span><span class="s3">]</span>

    <span class="s0">case </span><span class="s2">'TSLiteralType'</span><span class="s3">:</span>
      <span class="s0">switch </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">literal</span><span class="s3">.</span><span class="s1">type</span><span class="s3">) {</span>
        <span class="s0">case </span><span class="s2">'StringLiteral'</span><span class="s3">:</span>
          <span class="s0">return </span><span class="s3">[</span><span class="s2">'String'</span><span class="s3">]</span>
        <span class="s0">case </span><span class="s2">'BooleanLiteral'</span><span class="s3">:</span>
          <span class="s0">return </span><span class="s3">[</span><span class="s2">'Boolean'</span><span class="s3">]</span>
        <span class="s0">case </span><span class="s2">'NumericLiteral'</span><span class="s3">:</span>
        <span class="s0">case </span><span class="s2">'BigIntLiteral'</span><span class="s3">:</span>
          <span class="s0">return </span><span class="s3">[</span><span class="s2">'Number'</span><span class="s3">]</span>
        <span class="s0">default</span><span class="s3">:</span>
          <span class="s0">return </span><span class="s3">[</span><span class="s2">`null`</span><span class="s3">]</span>
      <span class="s3">}</span>

    <span class="s0">case </span><span class="s2">'TSTypeReference'</span><span class="s3">:</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">typeName</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'Identifier'</span><span class="s3">) {</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">declaredTypes</span><span class="s3">[</span><span class="s1">node</span><span class="s3">.</span><span class="s1">typeName</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]) {</span>
          <span class="s0">return </span><span class="s1">declaredTypes</span><span class="s3">[</span><span class="s1">node</span><span class="s3">.</span><span class="s1">typeName</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
        <span class="s3">}</span>
        <span class="s0">switch </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">typeName</span><span class="s3">.</span><span class="s1">name</span><span class="s3">) {</span>
          <span class="s0">case </span><span class="s2">'Array'</span><span class="s3">:</span>
          <span class="s0">case </span><span class="s2">'Function'</span><span class="s3">:</span>
          <span class="s0">case </span><span class="s2">'Object'</span><span class="s3">:</span>
          <span class="s0">case </span><span class="s2">'Set'</span><span class="s3">:</span>
          <span class="s0">case </span><span class="s2">'Map'</span><span class="s3">:</span>
          <span class="s0">case </span><span class="s2">'WeakSet'</span><span class="s3">:</span>
          <span class="s0">case </span><span class="s2">'WeakMap'</span><span class="s3">:</span>
          <span class="s0">case </span><span class="s2">'Date'</span><span class="s3">:</span>
          <span class="s0">case </span><span class="s2">'Promise'</span><span class="s3">:</span>
            <span class="s0">return </span><span class="s3">[</span><span class="s1">node</span><span class="s3">.</span><span class="s1">typeName</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
          <span class="s0">case </span><span class="s2">'Record'</span><span class="s3">:</span>
          <span class="s0">case </span><span class="s2">'Partial'</span><span class="s3">:</span>
          <span class="s0">case </span><span class="s2">'Readonly'</span><span class="s3">:</span>
          <span class="s0">case </span><span class="s2">'Pick'</span><span class="s3">:</span>
          <span class="s0">case </span><span class="s2">'Omit'</span><span class="s3">:</span>
          <span class="s0">case </span><span class="s2">'Exclude'</span><span class="s3">:</span>
          <span class="s0">case </span><span class="s2">'Extract'</span><span class="s3">:</span>
          <span class="s0">case </span><span class="s2">'Required'</span><span class="s3">:</span>
          <span class="s0">case </span><span class="s2">'InstanceType'</span><span class="s3">:</span>
            <span class="s0">return </span><span class="s3">[</span><span class="s2">'Object'</span><span class="s3">]</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
      <span class="s0">return </span><span class="s3">[</span><span class="s2">`null`</span><span class="s3">]</span>

    <span class="s0">case </span><span class="s2">'TSParenthesizedType'</span><span class="s3">:</span>
      <span class="s0">return </span><span class="s1">inferRuntimeType</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">typeAnnotation</span><span class="s3">, </span><span class="s1">declaredTypes</span><span class="s3">)</span>
    <span class="s0">case </span><span class="s2">'TSUnionType'</span><span class="s3">:</span>
      <span class="s0">return </span><span class="s3">[</span>
        <span class="s1">...</span><span class="s0">new </span><span class="s1">Set</span><span class="s3">(</span>
          <span class="s3">[].</span><span class="s1">concat</span><span class="s3">(</span>
            <span class="s1">...</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">types</span><span class="s3">.</span><span class="s1">map</span><span class="s3">(</span><span class="s1">t </span><span class="s3">=&gt; </span><span class="s1">inferRuntimeType</span><span class="s3">(</span><span class="s1">t</span><span class="s3">, </span><span class="s1">declaredTypes</span><span class="s3">)) as </span><span class="s1">any</span><span class="s3">)</span>
          <span class="s3">)</span>
        <span class="s3">)</span>
      <span class="s3">]</span>
    <span class="s0">case </span><span class="s2">'TSIntersectionType'</span><span class="s3">:</span>
      <span class="s0">return </span><span class="s3">[</span><span class="s2">'Object'</span><span class="s3">]</span>

    <span class="s0">case </span><span class="s2">'TSSymbolKeyword'</span><span class="s3">:</span>
      <span class="s0">return </span><span class="s3">[</span><span class="s2">'Symbol'</span><span class="s3">]</span>

    <span class="s0">default</span><span class="s3">:</span>
      <span class="s0">return </span><span class="s3">[</span><span class="s2">`null`</span><span class="s3">] </span><span class="s4">// no runtime check</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">toRuntimeTypeString</span><span class="s3">(</span><span class="s1">types</span><span class="s3">: </span><span class="s1">string</span><span class="s3">[]) {</span>
  <span class="s0">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">1 </span><span class="s3">? </span><span class="s2">`[</span><span class="s1">$</span><span class="s3">{</span><span class="s1">types</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s2">', '</span><span class="s3">)}</span><span class="s2">]` </span><span class="s3">: </span><span class="s1">types</span><span class="s3">[</span><span class="s7">0</span><span class="s3">]</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">extractRuntimeEmits</span><span class="s3">(</span>
  <span class="s1">node</span><span class="s3">: </span><span class="s1">TSFunctionType </span><span class="s3">| </span><span class="s1">TSTypeLiteral </span><span class="s3">| </span><span class="s1">TSInterfaceBody</span><span class="s3">,</span>
  <span class="s1">emits</span><span class="s3">: </span><span class="s1">Set</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">&gt;</span>
<span class="s3">) {</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSTypeLiteral' </span><span class="s3">|| </span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSInterfaceBody'</span><span class="s3">) {</span>
    <span class="s0">const </span><span class="s1">members </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSTypeLiteral' </span><span class="s3">? </span><span class="s1">node</span><span class="s3">.</span><span class="s1">members </span><span class="s3">: </span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span>
    <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">t of members</span><span class="s3">) {</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSCallSignatureDeclaration'</span><span class="s3">) {</span>
        <span class="s1">extractEventNames</span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">parameters</span><span class="s3">[</span><span class="s7">0</span><span class="s3">], </span><span class="s1">emits</span><span class="s3">)</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
    <span class="s0">return</span>
  <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
    <span class="s1">extractEventNames</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">parameters</span><span class="s3">[</span><span class="s7">0</span><span class="s3">], </span><span class="s1">emits</span><span class="s3">)</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">extractEventNames</span><span class="s3">(</span>
  <span class="s1">eventName</span><span class="s3">: </span><span class="s1">Identifier </span><span class="s3">| </span><span class="s1">RestElement</span><span class="s3">,</span>
  <span class="s1">emits</span><span class="s3">: </span><span class="s1">Set</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">&gt;</span>
<span class="s3">) {</span>
  <span class="s0">if </span><span class="s3">(</span>
    <span class="s1">eventName</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'Identifier' </span><span class="s3">&amp;&amp;</span>
    <span class="s1">eventName</span><span class="s3">.</span><span class="s1">typeAnnotation </span><span class="s3">&amp;&amp;</span>
    <span class="s1">eventName</span><span class="s3">.</span><span class="s1">typeAnnotation</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSTypeAnnotation'</span>
  <span class="s3">) {</span>
    <span class="s0">const </span><span class="s1">typeNode </span><span class="s3">= </span><span class="s1">eventName</span><span class="s3">.</span><span class="s1">typeAnnotation</span><span class="s3">.</span><span class="s1">typeAnnotation</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">typeNode</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSLiteralType'</span><span class="s3">) {</span>
      <span class="s0">if </span><span class="s3">(</span>
        <span class="s1">typeNode</span><span class="s3">.</span><span class="s1">literal</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!== </span><span class="s2">'UnaryExpression' </span><span class="s3">&amp;&amp;</span>
        <span class="s1">typeNode</span><span class="s3">.</span><span class="s1">literal</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!== </span><span class="s2">'TemplateLiteral'</span>
      <span class="s3">) {</span>
        <span class="s1">emits</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">String</span><span class="s3">(</span><span class="s1">typeNode</span><span class="s3">.</span><span class="s1">literal</span><span class="s3">.</span><span class="s1">value</span><span class="s3">))</span>
      <span class="s3">}</span>
    <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">typeNode</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSUnionType'</span><span class="s3">) {</span>
      <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">t of typeNode</span><span class="s3">.</span><span class="s1">types</span><span class="s3">) {</span>
        <span class="s0">if </span><span class="s3">(</span>
          <span class="s1">t</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'TSLiteralType' </span><span class="s3">&amp;&amp;</span>
          <span class="s1">t</span><span class="s3">.</span><span class="s1">literal</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!== </span><span class="s2">'UnaryExpression' </span><span class="s3">&amp;&amp;</span>
          <span class="s1">t</span><span class="s3">.</span><span class="s1">literal</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!== </span><span class="s2">'TemplateLiteral'</span>
        <span class="s3">) {</span>
          <span class="s1">emits</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">String</span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">literal</span><span class="s3">.</span><span class="s1">value</span><span class="s3">))</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">genRuntimeEmits</span><span class="s3">(</span><span class="s1">emits</span><span class="s3">: </span><span class="s1">Set</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">&gt;) {</span>
  <span class="s0">return </span><span class="s1">emits</span><span class="s3">.</span><span class="s1">size</span>
    <span class="s3">? </span><span class="s2">`</span><span class="s0">\n  </span><span class="s2">emits: [</span><span class="s1">$</span><span class="s3">{</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s1">emits</span><span class="s3">)</span>
        <span class="s3">.</span><span class="s1">map</span><span class="s3">(</span><span class="s1">p </span><span class="s3">=&gt; </span><span class="s1">JSON</span><span class="s3">.</span><span class="s1">stringify</span><span class="s3">(</span><span class="s1">p</span><span class="s3">))</span>
        <span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s2">', '</span><span class="s3">)}</span><span class="s2">],`</span>
    <span class="s3">: </span><span class="s2">``</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">isCallOf</span><span class="s3">(</span>
  <span class="s1">node</span><span class="s3">: </span><span class="s1">Node </span><span class="s3">| </span><span class="s0">null </span><span class="s3">| </span><span class="s1">undefined</span><span class="s3">,</span>
  <span class="s1">test</span><span class="s3">: </span><span class="s1">string </span><span class="s3">| ((</span><span class="s1">id</span><span class="s3">: </span><span class="s1">string</span><span class="s3">) =&gt; </span><span class="s1">boolean</span><span class="s3">)</span>
<span class="s3">): </span><span class="s1">node </span><span class="s3">is </span><span class="s1">CallExpression </span><span class="s3">{</span>
  <span class="s0">return </span><span class="s3">!!(</span>
    <span class="s1">node </span><span class="s3">&amp;&amp;</span>
    <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'CallExpression' </span><span class="s3">&amp;&amp;</span>
    <span class="s1">node</span><span class="s3">.</span><span class="s1">callee</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'Identifier' </span><span class="s3">&amp;&amp;</span>
    <span class="s3">(</span><span class="s0">typeof </span><span class="s1">test </span><span class="s3">=== </span><span class="s2">'string'</span>
      <span class="s3">? </span><span class="s1">node</span><span class="s3">.</span><span class="s1">callee</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=== </span><span class="s1">test</span>
      <span class="s3">: </span><span class="s1">test</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">callee</span><span class="s3">.</span><span class="s1">name</span><span class="s3">))</span>
  <span class="s3">)</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">canNeverBeRef</span><span class="s3">(</span><span class="s1">node</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">, </span><span class="s1">userReactiveImport</span><span class="s3">: </span><span class="s1">string</span><span class="s3">): </span><span class="s1">boolean </span><span class="s3">{</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">isCallOf</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">userReactiveImport</span><span class="s3">)) {</span>
    <span class="s0">return true</span>
  <span class="s3">}</span>
  <span class="s0">switch </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type</span><span class="s3">) {</span>
    <span class="s0">case </span><span class="s2">'UnaryExpression'</span><span class="s3">:</span>
    <span class="s0">case </span><span class="s2">'BinaryExpression'</span><span class="s3">:</span>
    <span class="s0">case </span><span class="s2">'ArrayExpression'</span><span class="s3">:</span>
    <span class="s0">case </span><span class="s2">'ObjectExpression'</span><span class="s3">:</span>
    <span class="s0">case </span><span class="s2">'FunctionExpression'</span><span class="s3">:</span>
    <span class="s0">case </span><span class="s2">'ArrowFunctionExpression'</span><span class="s3">:</span>
    <span class="s0">case </span><span class="s2">'UpdateExpression'</span><span class="s3">:</span>
    <span class="s0">case </span><span class="s2">'ClassExpression'</span><span class="s3">:</span>
    <span class="s0">case </span><span class="s2">'TaggedTemplateExpression'</span><span class="s3">:</span>
      <span class="s0">return true</span>
    <span class="s0">case </span><span class="s2">'SequenceExpression'</span><span class="s3">:</span>
      <span class="s0">return </span><span class="s1">canNeverBeRef</span><span class="s3">(</span>
        <span class="s1">node</span><span class="s3">.</span><span class="s1">expressions</span><span class="s3">[</span><span class="s1">node</span><span class="s3">.</span><span class="s1">expressions</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s7">1</span><span class="s3">],</span>
        <span class="s1">userReactiveImport</span>
      <span class="s3">)</span>
    <span class="s0">default</span><span class="s3">:</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">endsWith</span><span class="s3">(</span><span class="s2">'Literal'</span><span class="s3">)) {</span>
        <span class="s0">return true</span>
      <span class="s3">}</span>
      <span class="s0">return false</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s5">/**</span>
 <span class="s5">* Analyze bindings in normal `&lt;script&gt;`</span>
 <span class="s5">* Note that `compileScriptSetup` already analyzes bindings as part of its</span>
 <span class="s5">* compilation process so this should only be used on single `&lt;script&gt;` SFCs.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">analyzeScriptBindings</span><span class="s3">(</span><span class="s1">ast</span><span class="s3">: </span><span class="s1">Statement</span><span class="s3">[]): </span><span class="s1">BindingMetadata </span><span class="s3">{</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">node of ast</span><span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(</span>
      <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ExportDefaultDeclaration' </span><span class="s3">&amp;&amp;</span>
      <span class="s1">node</span><span class="s3">.</span><span class="s1">declaration</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectExpression'</span>
    <span class="s3">) {</span>
      <span class="s0">return </span><span class="s1">analyzeBindingsFromOptions</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">declaration</span><span class="s3">)</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
  <span class="s0">return </span><span class="s3">{}</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">analyzeBindingsFromOptions</span><span class="s3">(</span><span class="s1">node</span><span class="s3">: </span><span class="s1">ObjectExpression</span><span class="s3">): </span><span class="s1">BindingMetadata </span><span class="s3">{</span>
  <span class="s0">const </span><span class="s1">bindings</span><span class="s3">: </span><span class="s1">BindingMetadata </span><span class="s3">= {}</span>
  <span class="s4">// #3270, #3275</span>
  <span class="s4">// mark non-script-setup so we don't resolve components/directives from these</span>
  <span class="s1">Object</span><span class="s3">.</span><span class="s1">defineProperty</span><span class="s3">(</span><span class="s1">bindings</span><span class="s3">, </span><span class="s2">'__isScriptSetup'</span><span class="s3">, {</span>
    <span class="s1">enumerable</span><span class="s3">: </span><span class="s0">false</span><span class="s3">,</span>
    <span class="s1">value</span><span class="s3">: </span><span class="s0">false</span>
  <span class="s3">})</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">property of node</span><span class="s3">.</span><span class="s1">properties</span><span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(</span>
      <span class="s1">property</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectProperty' </span><span class="s3">&amp;&amp;</span>
      <span class="s3">!</span><span class="s1">property</span><span class="s3">.</span><span class="s1">computed </span><span class="s3">&amp;&amp;</span>
      <span class="s1">property</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'Identifier'</span>
    <span class="s3">) {</span>
      <span class="s4">// props</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">property</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=== </span><span class="s2">'props'</span><span class="s3">) {</span>
        <span class="s4">// props: ['foo']</span>
        <span class="s4">// props: { foo: ... }</span>
        <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">key of getObjectOrArrayExpressionKeys</span><span class="s3">(</span><span class="s1">property</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)) {</span>
          <span class="s1">bindings</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">PROPS</span>
        <span class="s3">}</span>
      <span class="s3">}</span>

      <span class="s4">// inject</span>
      <span class="s0">else if </span><span class="s3">(</span><span class="s1">property</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=== </span><span class="s2">'inject'</span><span class="s3">) {</span>
        <span class="s4">// inject: ['foo']</span>
        <span class="s4">// inject: { foo: {} }</span>
        <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">key of getObjectOrArrayExpressionKeys</span><span class="s3">(</span><span class="s1">property</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)) {</span>
          <span class="s1">bindings</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">OPTIONS</span>
        <span class="s3">}</span>
      <span class="s3">}</span>

      <span class="s4">// computed &amp; methods</span>
      <span class="s0">else if </span><span class="s3">(</span>
        <span class="s1">property</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectExpression' </span><span class="s3">&amp;&amp;</span>
        <span class="s3">(</span><span class="s1">property</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=== </span><span class="s2">'computed' </span><span class="s3">|| </span><span class="s1">property</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=== </span><span class="s2">'methods'</span><span class="s3">)</span>
      <span class="s3">) {</span>
        <span class="s4">// methods: { foo() {} }</span>
        <span class="s4">// computed: { foo() {} }</span>
        <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">key of getObjectExpressionKeys</span><span class="s3">(</span><span class="s1">property</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)) {</span>
          <span class="s1">bindings</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">OPTIONS</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s4">// setup &amp; data</span>
    <span class="s0">else if </span><span class="s3">(</span>
      <span class="s1">property</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectMethod' </span><span class="s3">&amp;&amp;</span>
      <span class="s1">property</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'Identifier' </span><span class="s3">&amp;&amp;</span>
      <span class="s3">(</span><span class="s1">property</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=== </span><span class="s2">'setup' </span><span class="s3">|| </span><span class="s1">property</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=== </span><span class="s2">'data'</span><span class="s3">)</span>
    <span class="s3">) {</span>
      <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">bodyItem of property</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">body</span><span class="s3">) {</span>
        <span class="s4">// setup() {</span>
        <span class="s4">//   return {</span>
        <span class="s4">//     foo: null</span>
        <span class="s4">//   }</span>
        <span class="s4">// }</span>
        <span class="s0">if </span><span class="s3">(</span>
          <span class="s1">bodyItem</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ReturnStatement' </span><span class="s3">&amp;&amp;</span>
          <span class="s1">bodyItem</span><span class="s3">.</span><span class="s1">argument </span><span class="s3">&amp;&amp;</span>
          <span class="s1">bodyItem</span><span class="s3">.</span><span class="s1">argument</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectExpression'</span>
        <span class="s3">) {</span>
          <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">key of getObjectExpressionKeys</span><span class="s3">(</span><span class="s1">bodyItem</span><span class="s3">.</span><span class="s1">argument</span><span class="s3">)) {</span>
            <span class="s1">bindings</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] =</span>
              <span class="s1">property</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=== </span><span class="s2">'setup'</span>
                <span class="s3">? </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">SETUP_MAYBE_REF</span>
                <span class="s3">: </span><span class="s1">BindingTypes</span><span class="s3">.</span><span class="s1">DATA</span>
          <span class="s3">}</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s0">return </span><span class="s1">bindings</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">getObjectExpressionKeys</span><span class="s3">(</span><span class="s1">node</span><span class="s3">: </span><span class="s1">ObjectExpression</span><span class="s3">): </span><span class="s1">string</span><span class="s3">[] {</span>
  <span class="s0">const </span><span class="s1">keys</span><span class="s3">: </span><span class="s1">string</span><span class="s3">[] = []</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">prop of node</span><span class="s3">.</span><span class="s1">properties</span><span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(</span>
      <span class="s3">(</span><span class="s1">prop</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectProperty' </span><span class="s3">|| </span><span class="s1">prop</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectMethod'</span><span class="s3">) &amp;&amp;</span>
      <span class="s3">!</span><span class="s1">prop</span><span class="s3">.</span><span class="s1">computed</span>
    <span class="s3">) {</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">prop</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'Identifier'</span><span class="s3">) {</span>
        <span class="s1">keys</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">prop</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
      <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">prop</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'StringLiteral'</span><span class="s3">) {</span>
        <span class="s1">keys</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">prop</span><span class="s3">.</span><span class="s1">key</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
  <span class="s0">return </span><span class="s1">keys</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">getArrayExpressionKeys</span><span class="s3">(</span><span class="s1">node</span><span class="s3">: </span><span class="s1">ArrayExpression</span><span class="s3">): </span><span class="s1">string</span><span class="s3">[] {</span>
  <span class="s0">const </span><span class="s1">keys</span><span class="s3">: </span><span class="s1">string</span><span class="s3">[] = []</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">element of node</span><span class="s3">.</span><span class="s1">elements</span><span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">element </span><span class="s3">&amp;&amp; </span><span class="s1">element</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'StringLiteral'</span><span class="s3">) {</span>
      <span class="s1">keys</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">element</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
  <span class="s0">return </span><span class="s1">keys</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">getObjectOrArrayExpressionKeys</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">Node</span><span class="s3">): </span><span class="s1">string</span><span class="s3">[] {</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">value</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ArrayExpression'</span><span class="s3">) {</span>
    <span class="s0">return </span><span class="s1">getArrayExpressionKeys</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
  <span class="s3">}</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">value</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'ObjectExpression'</span><span class="s3">) {</span>
    <span class="s0">return </span><span class="s1">getObjectExpressionKeys</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
  <span class="s3">}</span>
  <span class="s0">return </span><span class="s3">[]</span>
<span class="s3">}</span>

<span class="s0">const </span><span class="s1">templateUsageCheckCache </span><span class="s3">= </span><span class="s0">new </span><span class="s1">LRU</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">string</span><span class="s3">&gt;(</span><span class="s7">512</span><span class="s3">)</span>

<span class="s0">function </span><span class="s1">resolveTemplateUsageCheckString</span><span class="s3">(</span><span class="s1">sfc</span><span class="s3">: </span><span class="s1">SFCDescriptor</span><span class="s3">, </span><span class="s1">isTS</span><span class="s3">: </span><span class="s1">boolean</span><span class="s3">) {</span>
  <span class="s0">const </span><span class="s3">{ </span><span class="s1">content </span><span class="s3">} = </span><span class="s1">sfc</span><span class="s3">.</span><span class="s1">template</span><span class="s3">!</span>
  <span class="s0">const </span><span class="s1">cached </span><span class="s3">= </span><span class="s1">templateUsageCheckCache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">content</span><span class="s3">)</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">cached</span><span class="s3">) {</span>
    <span class="s0">return </span><span class="s1">cached</span>
  <span class="s3">}</span>

  <span class="s0">let </span><span class="s1">code </span><span class="s3">= </span><span class="s2">''</span>

  <span class="s1">parseHTML</span><span class="s3">(</span><span class="s1">content</span><span class="s3">, {</span>
    <span class="s1">...webCompilerOptions</span><span class="s3">,</span>
    <span class="s1">start</span><span class="s3">(</span><span class="s1">tag</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">) {</span>
      <span class="s0">if </span><span class="s3">(!</span><span class="s1">isBuiltInTag</span><span class="s3">(</span><span class="s1">tag</span><span class="s3">) &amp;&amp; !</span><span class="s1">isReservedTag</span><span class="s3">(</span><span class="s1">tag</span><span class="s3">)) {</span>
        <span class="s1">code </span><span class="s3">+= </span><span class="s2">`,</span><span class="s1">$</span><span class="s3">{</span><span class="s1">camelize</span><span class="s3">(</span><span class="s1">tag</span><span class="s3">)}</span><span class="s2">,</span><span class="s1">$</span><span class="s3">{</span><span class="s1">capitalize</span><span class="s3">(</span><span class="s1">camelize</span><span class="s3">(</span><span class="s1">tag</span><span class="s3">))}</span><span class="s2">`</span>
      <span class="s3">}</span>
      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">i </span><span class="s3">= </span><span class="s7">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">attrs</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
        <span class="s0">const </span><span class="s3">{ </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s3">} = </span><span class="s1">attrs</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">dirRE</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)) {</span>
          <span class="s0">const </span><span class="s1">baseName </span><span class="s3">= </span><span class="s1">onRE</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s3">? </span><span class="s2">'on'</span>
            <span class="s3">: </span><span class="s1">slotRE</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s3">? </span><span class="s2">'slot'</span>
            <span class="s3">: </span><span class="s1">bindRE</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s3">? </span><span class="s2">'bind'</span>
            <span class="s3">: </span><span class="s1">name</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">dirRE</span><span class="s3">, </span><span class="s2">''</span><span class="s3">)</span>
          <span class="s0">if </span><span class="s3">(!</span><span class="s1">isBuiltInDir</span><span class="s3">(</span><span class="s1">baseName</span><span class="s3">)) {</span>
            <span class="s1">code </span><span class="s3">+= </span><span class="s2">`,v</span><span class="s1">$</span><span class="s3">{</span><span class="s1">capitalize</span><span class="s3">(</span><span class="s1">camelize</span><span class="s3">(</span><span class="s1">baseName</span><span class="s3">))}</span><span class="s2">`</span>
          <span class="s3">}</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">value</span><span class="s3">) {</span>
            <span class="s1">code </span><span class="s3">+= </span><span class="s2">`,</span><span class="s1">$</span><span class="s3">{</span><span class="s1">processExp</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">isTS</span><span class="s3">, </span><span class="s1">baseName</span><span class="s3">)}</span><span class="s2">`</span>
          <span class="s3">}</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
    <span class="s3">},</span>
    <span class="s1">chars</span><span class="s3">(</span><span class="s1">text</span><span class="s3">) {</span>
      <span class="s0">const </span><span class="s1">res </span><span class="s3">= </span><span class="s1">parseText</span><span class="s3">(</span><span class="s1">text</span><span class="s3">)</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">res</span><span class="s3">) {</span>
        <span class="s1">code </span><span class="s3">+= </span><span class="s2">`,</span><span class="s1">$</span><span class="s3">{</span><span class="s1">processExp</span><span class="s3">(</span><span class="s1">res</span><span class="s3">.</span><span class="s1">expression</span><span class="s3">, </span><span class="s1">isTS</span><span class="s3">)}</span><span class="s2">`</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">})</span>

  <span class="s1">code </span><span class="s3">+= </span><span class="s2">';'</span>
  <span class="s1">templateUsageCheckCache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">content</span><span class="s3">, </span><span class="s1">code</span><span class="s3">)</span>
  <span class="s0">return </span><span class="s1">code</span>
<span class="s3">}</span>

<span class="s0">const </span><span class="s1">forAliasRE </span><span class="s3">= </span><span class="s6">/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/</span>

<span class="s0">function </span><span class="s1">processExp</span><span class="s3">(</span><span class="s1">exp</span><span class="s3">: </span><span class="s1">string</span><span class="s3">, </span><span class="s1">isTS</span><span class="s3">: </span><span class="s1">boolean</span><span class="s3">, </span><span class="s1">dir</span><span class="s3">?: </span><span class="s1">string</span><span class="s3">): </span><span class="s1">string </span><span class="s3">{</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">isTS </span><span class="s3">&amp;&amp; </span><span class="s6">/ as\s+\w|&lt;.*&gt;|:/</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">exp</span><span class="s3">)) {</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">dir </span><span class="s3">=== </span><span class="s2">'slot'</span><span class="s3">) {</span>
      <span class="s1">exp </span><span class="s3">= </span><span class="s2">`(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">exp</span><span class="s3">}</span><span class="s2">)=&gt;{}`</span>
    <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">dir </span><span class="s3">=== </span><span class="s2">'on'</span><span class="s3">) {</span>
      <span class="s1">exp </span><span class="s3">= </span><span class="s2">`()=&gt;{</span><span class="s1">$</span><span class="s3">{</span><span class="s1">exp</span><span class="s3">}</span><span class="s2">}`</span>
    <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">dir </span><span class="s3">=== </span><span class="s2">'for'</span><span class="s3">) {</span>
      <span class="s0">const </span><span class="s1">inMatch </span><span class="s3">= </span><span class="s1">exp</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">forAliasRE</span><span class="s3">)</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">inMatch</span><span class="s3">) {</span>
        <span class="s0">const </span><span class="s3">[, </span><span class="s1">LHS</span><span class="s3">, </span><span class="s1">RHS</span><span class="s3">] = </span><span class="s1">inMatch</span>
        <span class="s0">return </span><span class="s1">processExp</span><span class="s3">(</span><span class="s2">`(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">LHS</span><span class="s3">}</span><span class="s2">)=&gt;{}`</span><span class="s3">, </span><span class="s0">true</span><span class="s3">) + </span><span class="s1">processExp</span><span class="s3">(</span><span class="s1">RHS</span><span class="s3">, </span><span class="s0">true</span><span class="s3">)</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
    <span class="s0">let </span><span class="s1">ret </span><span class="s3">= </span><span class="s2">''</span>
    <span class="s4">// has potential type cast or generic arguments that uses types</span>
    <span class="s0">const </span><span class="s1">ast </span><span class="s3">= </span><span class="s1">parseExpression</span><span class="s3">(</span><span class="s1">exp</span><span class="s3">, { </span><span class="s1">plugins</span><span class="s3">: [</span><span class="s2">'typescript'</span><span class="s3">] })</span>
    <span class="s1">walkIdentifiers</span><span class="s3">(</span><span class="s1">ast</span><span class="s3">, </span><span class="s1">node </span><span class="s3">=&gt; {</span>
      <span class="s1">ret </span><span class="s3">+= </span><span class="s2">`,` </span><span class="s3">+ </span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span>
    <span class="s3">})</span>
    <span class="s0">return </span><span class="s1">ret</span>
  <span class="s3">}</span>
  <span class="s0">return </span><span class="s1">stripStrings</span><span class="s3">(</span><span class="s1">exp</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">stripStrings</span><span class="s3">(</span><span class="s1">exp</span><span class="s3">: </span><span class="s1">string</span><span class="s3">) {</span>
  <span class="s0">return </span><span class="s1">exp</span>
    <span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s6">/'[^']*'|&quot;[^&quot;]*&quot;/g</span><span class="s3">, </span><span class="s2">''</span><span class="s3">)</span>
    <span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s6">/`[^`]+`/g</span><span class="s3">, </span><span class="s1">stripTemplateString</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">stripTemplateString</span><span class="s3">(</span><span class="s1">str</span><span class="s3">: </span><span class="s1">string</span><span class="s3">): </span><span class="s1">string </span><span class="s3">{</span>
  <span class="s0">const </span><span class="s1">interpMatch </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s6">/\${[^}]+}/g</span><span class="s3">)</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">interpMatch</span><span class="s3">) {</span>
    <span class="s0">return </span><span class="s1">interpMatch</span><span class="s3">.</span><span class="s1">map</span><span class="s3">(</span><span class="s1">m </span><span class="s3">=&gt; </span><span class="s1">m</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">2</span><span class="s3">, -</span><span class="s7">1</span><span class="s3">)).</span><span class="s1">join</span><span class="s3">(</span><span class="s2">','</span><span class="s3">)</span>
  <span class="s3">}</span>
  <span class="s0">return </span><span class="s2">''</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">isImportUsed</span><span class="s3">(</span>
  <span class="s1">local</span><span class="s3">: </span><span class="s1">string</span><span class="s3">,</span>
  <span class="s1">sfc</span><span class="s3">: </span><span class="s1">SFCDescriptor</span><span class="s3">,</span>
  <span class="s1">isTS</span><span class="s3">: </span><span class="s1">boolean</span>
<span class="s3">): </span><span class="s1">boolean </span><span class="s3">{</span>
  <span class="s0">return new </span><span class="s1">RegExp</span><span class="s3">(</span>
    <span class="s4">// #4274 escape $ since it's a special char in regex</span>
    <span class="s4">// (and is the only regex special char that is valid in identifiers)</span>
    <span class="s2">`[^</span><span class="s0">\\</span><span class="s2">w$_]</span><span class="s1">$</span><span class="s3">{</span><span class="s1">local</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s6">/\$/g</span><span class="s3">, </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">$'</span><span class="s3">)}</span><span class="s2">[^</span><span class="s0">\\</span><span class="s2">w$_]`</span>
  <span class="s3">).</span><span class="s1">test</span><span class="s3">(</span><span class="s1">resolveTemplateUsageCheckString</span><span class="s3">(</span><span class="s1">sfc</span><span class="s3">, </span><span class="s1">isTS</span><span class="s3">))</span>
<span class="s3">}</span>

<span class="s5">/**</span>
 <span class="s5">* Note: this comparison assumes the prev/next script are already identical,</span>
 <span class="s5">* and only checks the special case where &lt;script setup&gt; unused import</span>
 <span class="s5">* pruning result changes due to template changes.</span>
 <span class="s5">*/</span>
<span class="s0">export function </span><span class="s1">hmrShouldReload</span><span class="s3">(</span>
  <span class="s1">prevImports</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">ImportBinding</span><span class="s3">&gt;,</span>
  <span class="s1">next</span><span class="s3">: </span><span class="s1">SFCDescriptor</span>
<span class="s3">): </span><span class="s1">boolean </span><span class="s3">{</span>
  <span class="s0">if </span><span class="s3">(!</span><span class="s1">next</span><span class="s3">.</span><span class="s1">scriptSetup</span><span class="s3">) {</span>
    <span class="s0">return false</span>
  <span class="s3">}</span>

  <span class="s0">const </span><span class="s1">isTS </span><span class="s3">= </span><span class="s1">next</span><span class="s3">.</span><span class="s1">scriptSetup</span><span class="s3">.</span><span class="s1">lang </span><span class="s3">=== </span><span class="s2">'ts' </span><span class="s3">|| </span><span class="s1">next</span><span class="s3">.</span><span class="s1">scriptSetup</span><span class="s3">.</span><span class="s1">lang </span><span class="s3">=== </span><span class="s2">'tsx'</span>
  <span class="s4">// for each previous import, check if its used status remain the same based on</span>
  <span class="s4">// the next descriptor's template</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">key </span><span class="s0">in </span><span class="s1">prevImports</span><span class="s3">) {</span>
    <span class="s4">// if an import was previous unused, but now is used, we need to force</span>
    <span class="s4">// reload so that the script now includes that import.</span>
    <span class="s0">if </span><span class="s3">(!</span><span class="s1">prevImports</span><span class="s3">[</span><span class="s1">key</span><span class="s3">].</span><span class="s1">isUsedInTemplate </span><span class="s3">&amp;&amp; </span><span class="s1">isImportUsed</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">next</span><span class="s3">, </span><span class="s1">isTS</span><span class="s3">)) {</span>
      <span class="s0">return true</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s0">return false</span>
<span class="s3">}</span>
</pre>
</body>
</html>