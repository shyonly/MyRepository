<html>
<head>
<title>virtual-types-validator.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
virtual-types-validator.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;isBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;isBlockScoped&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeIsBlockScoped&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeIsExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isFlow&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeIsFlow&quot;</span><span class="s0">,</span><span class="s1">&quot;isForStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isForXStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isImportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isImportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isRestElement&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeIsRestElement&quot;</span><span class="s0">,</span><span class="s1">&quot;isReferenced&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeIsReferenced&quot;</span><span class="s0">,</span><span class="s1">&quot;isScope&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeIsScope&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeIsStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isVar&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeIsVar&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;react&quot;</span><span class="s0">,</span><span class="s1">&quot;isForOfStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isCompatTag&quot;</span><span class="s0">,</span><span class="s1">&quot;isReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isReferencedMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isBindingIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;grandparent&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;isUser&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;isGenerated&quot;</span><span class="s0">,</span><span class="s1">&quot;isPure&quot;</span><span class="s0">,</span><span class="s1">&quot;constantsOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;importKind&quot;</span><span class="s0">,</span><span class="s1">&quot;exportKind&quot;</span><span class="s0">,</span><span class="s1">&quot;isRestProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;isSpreadProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isForAwaitStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;await&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;isExistentialTypeParam&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;isNumericLiteralTypeAnnotation&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/path/lib/virtual-types-validator.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type NodePath from </span><span class="s3">\&quot;</span><span class="s1">../index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isBinding,</span><span class="s3">\n  </span><span class="s1">isBlockScoped as nodeIsBlockScoped,</span><span class="s3">\n  </span><span class="s1">isExportDeclaration,</span><span class="s3">\n  </span><span class="s1">isExpression as nodeIsExpression,</span><span class="s3">\n  </span><span class="s1">isFlow as nodeIsFlow,</span><span class="s3">\n  </span><span class="s1">isForStatement,</span><span class="s3">\n  </span><span class="s1">isForXStatement,</span><span class="s3">\n  </span><span class="s1">isIdentifier,</span><span class="s3">\n  </span><span class="s1">isImportDeclaration,</span><span class="s3">\n  </span><span class="s1">isImportSpecifier,</span><span class="s3">\n  </span><span class="s1">isJSXIdentifier,</span><span class="s3">\n  </span><span class="s1">isJSXMemberExpression,</span><span class="s3">\n  </span><span class="s1">isMemberExpression,</span><span class="s3">\n  </span><span class="s1">isRestElement as nodeIsRestElement,</span><span class="s3">\n  </span><span class="s1">isReferenced as nodeIsReferenced,</span><span class="s3">\n  </span><span class="s1">isScope as nodeIsScope,</span><span class="s3">\n  </span><span class="s1">isStatement as nodeIsStatement,</span><span class="s3">\n  </span><span class="s1">isVar as nodeIsVar,</span><span class="s3">\n  </span><span class="s1">isVariableDeclaration,</span><span class="s3">\n  </span><span class="s1">react,</span><span class="s3">\n  </span><span class="s1">isForOfStatement,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const { isCompatTag } = react;</span><span class="s3">\n</span><span class="s1">import type { VirtualTypeAliases } from </span><span class="s3">\&quot;</span><span class="s1">./virtual-types.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">type Opts&lt;Obj&gt; = Partial&lt;{</span><span class="s3">\n  </span><span class="s1">[Prop in keyof Obj]: Obj[Prop] extends t.Node</span><span class="s3">\n    </span><span class="s1">? t.Node</span><span class="s3">\n    </span><span class="s1">: Obj[Prop] extends t.Node[]</span><span class="s3">\n    </span><span class="s1">? t.Node[]</span><span class="s3">\n    </span><span class="s1">: Obj[Prop];</span><span class="s3">\n</span><span class="s1">}&gt;;</span><span class="s3">\n\n</span><span class="s1">export interface VirtualTypeNodePathValidators {</span><span class="s3">\n  </span><span class="s1">isBindingIdentifier&lt;T extends t.Node&gt;(</span><span class="s3">\n    </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n    </span><span class="s1">opts?: Opts&lt;VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">BindingIdentifier</span><span class="s3">\&quot;</span><span class="s1">]&gt;,</span><span class="s3">\n  </span><span class="s1">): this is NodePath&lt;T &amp; VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">BindingIdentifier</span><span class="s3">\&quot;</span><span class="s1">]&gt;;</span><span class="s3">\n  </span><span class="s1">isBlockScoped(opts?: Opts&lt;VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">BlockScoped</span><span class="s3">\&quot;</span><span class="s1">]&gt;): boolean;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isExistentialTypeParam&lt;T extends t.Node&gt;(</span><span class="s3">\n    </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n    </span><span class="s1">opts?: Opts&lt;VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">ExistentialTypeParam</span><span class="s3">\&quot;</span><span class="s1">]&gt;,</span><span class="s3">\n  </span><span class="s1">): this is NodePath&lt;T &amp; VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">ExistentialTypeParam</span><span class="s3">\&quot;</span><span class="s1">]&gt;;</span><span class="s3">\n  </span><span class="s1">isExpression&lt;T extends t.Node&gt;(</span><span class="s3">\n    </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n    </span><span class="s1">opts?: Opts&lt;VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">]&gt;,</span><span class="s3">\n  </span><span class="s1">): this is NodePath&lt;T &amp; t.Expression&gt;;</span><span class="s3">\n  </span><span class="s1">isFlow&lt;T extends t.Node&gt;(</span><span class="s3">\n    </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n    </span><span class="s1">opts?: Opts&lt;VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">Flow</span><span class="s3">\&quot;</span><span class="s1">]&gt;,</span><span class="s3">\n  </span><span class="s1">): this is NodePath&lt;T &amp; t.Flow&gt;;</span><span class="s3">\n  </span><span class="s1">isForAwaitStatement&lt;T extends t.Node&gt;(</span><span class="s3">\n    </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n    </span><span class="s1">opts?: Opts&lt;VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">ForAwaitStatement</span><span class="s3">\&quot;</span><span class="s1">]&gt;,</span><span class="s3">\n  </span><span class="s1">): this is NodePath&lt;T &amp; VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">ForAwaitStatement</span><span class="s3">\&quot;</span><span class="s1">]&gt;;</span><span class="s3">\n  </span><span class="s1">isGenerated(opts?: VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">Generated</span><span class="s3">\&quot;</span><span class="s1">]): boolean;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isNumericLiteralTypeAnnotation(</span><span class="s3">\n    </span><span class="s1">opts?: VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">NumericLiteralTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n  </span><span class="s1">): void;</span><span class="s3">\n  </span><span class="s1">isPure(opts?: VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">Pure</span><span class="s3">\&quot;</span><span class="s1">]): boolean;</span><span class="s3">\n  </span><span class="s1">isReferenced(opts?: VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">Referenced</span><span class="s3">\&quot;</span><span class="s1">]): boolean;</span><span class="s3">\n  </span><span class="s1">isReferencedIdentifier&lt;T extends t.Node&gt;(</span><span class="s3">\n    </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n    </span><span class="s1">opts?: Opts&lt;VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">ReferencedIdentifier</span><span class="s3">\&quot;</span><span class="s1">]&gt;,</span><span class="s3">\n  </span><span class="s1">): this is NodePath&lt;T &amp; VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">ReferencedIdentifier</span><span class="s3">\&quot;</span><span class="s1">]&gt;;</span><span class="s3">\n  </span><span class="s1">isReferencedMemberExpression&lt;T extends t.Node&gt;(</span><span class="s3">\n    </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n    </span><span class="s1">opts?: Opts&lt;VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">ReferencedMemberExpression</span><span class="s3">\&quot;</span><span class="s1">]&gt;,</span><span class="s3">\n  </span><span class="s1">): this is NodePath&lt;T &amp; VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">ReferencedMemberExpression</span><span class="s3">\&quot;</span><span class="s1">]&gt;;</span><span class="s3">\n  </span><span class="s1">isRestProperty&lt;T extends t.Node&gt;(</span><span class="s3">\n    </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n    </span><span class="s1">opts?: Opts&lt;VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">RestProperty</span><span class="s3">\&quot;</span><span class="s1">]&gt;,</span><span class="s3">\n  </span><span class="s1">): this is NodePath&lt;T &amp; t.RestProperty&gt;;</span><span class="s3">\n  </span><span class="s1">isScope&lt;T extends t.Node&gt;(</span><span class="s3">\n    </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n    </span><span class="s1">opts?: Opts&lt;VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">Scope</span><span class="s3">\&quot;</span><span class="s1">]&gt;,</span><span class="s3">\n  </span><span class="s1">): this is NodePath&lt;T &amp; VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">Scope</span><span class="s3">\&quot;</span><span class="s1">]&gt;;</span><span class="s3">\n  </span><span class="s1">isSpreadProperty&lt;T extends t.Node&gt;(</span><span class="s3">\n    </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n    </span><span class="s1">opts?: Opts&lt;VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">SpreadProperty</span><span class="s3">\&quot;</span><span class="s1">]&gt;,</span><span class="s3">\n  </span><span class="s1">): this is NodePath&lt;T &amp; t.SpreadProperty&gt;;</span><span class="s3">\n  </span><span class="s1">isStatement&lt;T extends t.Node&gt;(</span><span class="s3">\n    </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n    </span><span class="s1">opts?: Opts&lt;VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">]&gt;,</span><span class="s3">\n  </span><span class="s1">): this is NodePath&lt;T &amp; t.Statement&gt;;</span><span class="s3">\n  </span><span class="s1">isUser(opts?: VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">User</span><span class="s3">\&quot;</span><span class="s1">]): boolean;</span><span class="s3">\n  </span><span class="s1">isVar&lt;T extends t.Node&gt;(</span><span class="s3">\n    </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n    </span><span class="s1">opts?: Opts&lt;VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">Var</span><span class="s3">\&quot;</span><span class="s1">]&gt;,</span><span class="s3">\n  </span><span class="s1">): this is NodePath&lt;T &amp; VirtualTypeAliases[</span><span class="s3">\&quot;</span><span class="s1">Var</span><span class="s3">\&quot;</span><span class="s1">]&gt;;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isReferencedIdentifier(this: NodePath, opts?: any): boolean {</span><span class="s3">\n  </span><span class="s1">const { node, parent } = this;</span><span class="s3">\n  </span><span class="s1">if (!isIdentifier(node, opts) &amp;&amp; !isJSXMemberExpression(parent, opts)) {</span><span class="s3">\n    </span><span class="s1">if (isJSXIdentifier(node, opts)) {</span><span class="s3">\n      </span><span class="s1">if (isCompatTag(node.name)) return false;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// not a JSXIdentifier or an Identifier</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// check if node is referenced</span><span class="s3">\n  </span><span class="s1">return nodeIsReferenced(node, parent, this.parentPath.parent);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isReferencedMemberExpression(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">const { node, parent } = this;</span><span class="s3">\n  </span><span class="s1">return isMemberExpression(node) &amp;&amp; nodeIsReferenced(node, parent);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isBindingIdentifier(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">const { node, parent } = this;</span><span class="s3">\n  </span><span class="s1">const grandparent = this.parentPath.parent;</span><span class="s3">\n  </span><span class="s1">return isIdentifier(node) &amp;&amp; isBinding(node, parent, grandparent);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isStatement(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">const { node, parent } = this;</span><span class="s3">\n  </span><span class="s1">if (nodeIsStatement(node)) {</span><span class="s3">\n    </span><span class="s1">if (isVariableDeclaration(node)) {</span><span class="s3">\n      </span><span class="s1">if (isForXStatement(parent, { left: node })) return false;</span><span class="s3">\n      </span><span class="s1">if (isForStatement(parent, { init: node })) return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isExpression(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">if (this.isIdentifier()) {</span><span class="s3">\n    </span><span class="s1">return this.isReferencedIdentifier();</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return nodeIsExpression(this.node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isScope(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">return nodeIsScope(this.node, this.parent);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isReferenced(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">return nodeIsReferenced(this.node, this.parent);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isBlockScoped(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">return nodeIsBlockScoped(this.node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isVar(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">return nodeIsVar(this.node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isUser(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">return this.node &amp;&amp; !!this.node.loc;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isGenerated(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">return !this.isUser();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isPure(this: NodePath, constantsOnly?: boolean): boolean {</span><span class="s3">\n  </span><span class="s1">return this.scope.isPure(this.node, constantsOnly);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isFlow(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">const { node } = this;</span><span class="s3">\n  </span><span class="s1">if (nodeIsFlow(node)) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">} else if (isImportDeclaration(node)) {</span><span class="s3">\n    </span><span class="s1">return node.importKind === </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot; </span><span class="s1">|| node.importKind === </span><span class="s3">\&quot;</span><span class="s1">typeof</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">} else if (isExportDeclaration(node)) {</span><span class="s3">\n    </span><span class="s1">return node.exportKind === </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">} else if (isImportSpecifier(node)) {</span><span class="s3">\n    </span><span class="s1">return node.importKind === </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot; </span><span class="s1">|| node.importKind === </span><span class="s3">\&quot;</span><span class="s1">typeof</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// TODO: 7.0 Backwards Compat</span><span class="s3">\n</span><span class="s1">export function isRestProperty(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">nodeIsRestElement(this.node) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">this.parentPath &amp;&amp;</span><span class="s3">\n    </span><span class="s1">this.parentPath.isObjectPattern()</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isSpreadProperty(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">nodeIsRestElement(this.node) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">this.parentPath &amp;&amp;</span><span class="s3">\n    </span><span class="s1">this.parentPath.isObjectExpression()</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isForAwaitStatement(this: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">return isForOfStatement(this.node, { await: true });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">if (!process.env.BABEL_8_BREAKING &amp;&amp; !USE_ESM) {</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-restricted-globals</span><span class="s3">\n  </span><span class="s1">exports.isExistentialTypeParam = function isExistentialTypeParam(</span><span class="s3">\n    </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// eslint-disable-next-line no-restricted-globals</span><span class="s3">\n  </span><span class="s1">exports.isNumericLiteralTypeAnnotation =</span><span class="s3">\n    </span><span class="s1">function isNumericLiteralTypeAnnotation(this: NodePath): void {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        \&quot;</span><span class="s1">`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>