<html>
<head>
<title>rewrite-pattern.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6aab73;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #cf8e6d;}
.s4 { color: #42c3d4;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
rewrite-pattern.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s3">const </span><span class="s2">generate </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'@babel/regjsgen'</span><span class="s1">).</span><span class="s2">generate</span><span class="s1">;</span>
<span class="s3">const </span><span class="s2">parse </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'regjsparser'</span><span class="s1">).</span><span class="s2">parse</span><span class="s1">;</span>
<span class="s3">const </span><span class="s2">regenerate </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'regenerate'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s2">unicodeMatchProperty </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'unicode-match-property-ecmascript'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s2">unicodeMatchPropertyValue </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'unicode-match-property-value-ecmascript'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s2">iuMappings </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'./data/iu-mappings.js'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s2">ESCAPE_SETS </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'./data/character-class-escape-sets.js'</span><span class="s1">);</span>

<span class="s3">function </span><span class="s2">flatMap</span><span class="s1">(</span><span class="s2">array</span><span class="s1">, </span><span class="s2">callback</span><span class="s1">) {</span>
	<span class="s3">const </span><span class="s2">result </span><span class="s1">= [];</span>
	<span class="s2">array</span><span class="s1">.</span><span class="s2">forEach</span><span class="s1">(</span><span class="s2">item </span><span class="s1">=&gt; {</span>
		<span class="s3">const </span><span class="s2">res </span><span class="s1">= </span><span class="s2">callback</span><span class="s1">(</span><span class="s2">item</span><span class="s1">);</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s2">Array</span><span class="s1">.</span><span class="s2">isArray</span><span class="s1">(</span><span class="s2">res</span><span class="s1">)) {</span>
			<span class="s2">result</span><span class="s1">.</span><span class="s2">push</span><span class="s1">.</span><span class="s2">apply</span><span class="s1">(</span><span class="s2">result</span><span class="s1">, </span><span class="s2">res</span><span class="s1">);</span>
		<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
			<span class="s2">result</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">res</span><span class="s1">);</span>
		<span class="s1">}</span>
	<span class="s1">});</span>
	<span class="s3">return </span><span class="s2">result</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">const </span><span class="s2">SPECIAL_CHARS </span><span class="s1">= </span><span class="s4">/([\\^$.*+?()[\]{}|])/g</span><span class="s1">;</span>

<span class="s5">// Prepare a Regenerate set containing all code points, used for negative</span>
<span class="s5">// character classes (if any).</span>
<span class="s3">const </span><span class="s2">UNICODE_SET </span><span class="s1">= </span><span class="s2">regenerate</span><span class="s1">().</span><span class="s2">addRange</span><span class="s1">(</span><span class="s6">0x0</span><span class="s1">, </span><span class="s6">0x10FFFF</span><span class="s1">);</span>

<span class="s3">const </span><span class="s2">ASTRAL_SET </span><span class="s1">= </span><span class="s2">regenerate</span><span class="s1">().</span><span class="s2">addRange</span><span class="s1">(</span><span class="s6">0x10000</span><span class="s1">, </span><span class="s6">0x10FFFF</span><span class="s1">);</span>

<span class="s3">const </span><span class="s2">NEWLINE_SET </span><span class="s1">= </span><span class="s2">regenerate</span><span class="s1">().</span><span class="s2">add</span><span class="s1">(</span>
	<span class="s5">// `LineTerminator`s (https://mths.be/es6#sec-line-terminators):</span>
	<span class="s6">0x000A</span><span class="s1">, </span><span class="s5">// Line Feed &lt;LF&gt;</span>
	<span class="s6">0x000D</span><span class="s1">, </span><span class="s5">// Carriage Return &lt;CR&gt;</span>
	<span class="s6">0x2028</span><span class="s1">, </span><span class="s5">// Line Separator &lt;LS&gt;</span>
	<span class="s6">0x2029  </span><span class="s5">// Paragraph Separator &lt;PS&gt;</span>
<span class="s1">);</span>

<span class="s5">// Prepare a Regenerate set containing all code points that are supposed to be</span>
<span class="s5">// matched by `/./u`. https://mths.be/es6#sec-atom</span>
<span class="s3">const </span><span class="s2">DOT_SET_UNICODE </span><span class="s1">= </span><span class="s2">UNICODE_SET</span><span class="s1">.</span><span class="s2">clone</span><span class="s1">() </span><span class="s5">// all Unicode code points</span>
	<span class="s1">.</span><span class="s2">remove</span><span class="s1">(</span><span class="s2">NEWLINE_SET</span><span class="s1">);</span>

<span class="s3">const </span><span class="s2">getCharacterClassEscapeSet </span><span class="s1">= (</span><span class="s2">character</span><span class="s1">, </span><span class="s2">unicode</span><span class="s1">, </span><span class="s2">ignoreCase</span><span class="s1">) =&gt; {</span>
	<span class="s3">if </span><span class="s1">(</span><span class="s2">unicode</span><span class="s1">) {</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s2">ignoreCase</span><span class="s1">) {</span>
			<span class="s3">return </span><span class="s2">ESCAPE_SETS</span><span class="s1">.</span><span class="s2">UNICODE_IGNORE_CASE</span><span class="s1">.</span><span class="s2">get</span><span class="s1">(</span><span class="s2">character</span><span class="s1">);</span>
		<span class="s1">}</span>
		<span class="s3">return </span><span class="s2">ESCAPE_SETS</span><span class="s1">.</span><span class="s2">UNICODE</span><span class="s1">.</span><span class="s2">get</span><span class="s1">(</span><span class="s2">character</span><span class="s1">);</span>
	<span class="s1">}</span>
	<span class="s3">return </span><span class="s2">ESCAPE_SETS</span><span class="s1">.</span><span class="s2">REGULAR</span><span class="s1">.</span><span class="s2">get</span><span class="s1">(</span><span class="s2">character</span><span class="s1">);</span>
<span class="s1">};</span>

<span class="s3">const </span><span class="s2">getUnicodeDotSet </span><span class="s1">= (</span><span class="s2">dotAll</span><span class="s1">) =&gt; {</span>
	<span class="s3">return </span><span class="s2">dotAll </span><span class="s1">? </span><span class="s2">UNICODE_SET </span><span class="s1">: </span><span class="s2">DOT_SET_UNICODE</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s3">const </span><span class="s2">getUnicodePropertyValueSet </span><span class="s1">= (</span><span class="s2">property</span><span class="s1">, </span><span class="s2">value</span><span class="s1">) =&gt; {</span>
	<span class="s3">const </span><span class="s2">path </span><span class="s1">= </span><span class="s2">value </span><span class="s1">?</span>
		<span class="s0">`</span><span class="s2">$</span><span class="s1">{ </span><span class="s2">property </span><span class="s1">}</span><span class="s0">/</span><span class="s2">$</span><span class="s1">{ </span><span class="s2">value </span><span class="s1">}</span><span class="s0">` </span><span class="s1">:</span>
		<span class="s0">`Binary_Property/</span><span class="s2">$</span><span class="s1">{ </span><span class="s2">property </span><span class="s1">}</span><span class="s0">`</span><span class="s1">;</span>
	<span class="s3">try </span><span class="s1">{</span>
		<span class="s3">return </span><span class="s2">require</span><span class="s1">(</span><span class="s0">`regenerate-unicode-properties/</span><span class="s2">$</span><span class="s1">{ </span><span class="s2">path </span><span class="s1">}</span><span class="s0">.js`</span><span class="s1">);</span>
	<span class="s1">} </span><span class="s3">catch </span><span class="s1">(</span><span class="s2">exception</span><span class="s1">) {</span>
		<span class="s3">throw new </span><span class="s2">Error</span><span class="s1">(</span>
			<span class="s0">`Failed to recognize value </span><span class="s3">\`</span><span class="s2">$</span><span class="s1">{ </span><span class="s2">value </span><span class="s1">}</span><span class="s3">\` </span><span class="s0">for property ` </span><span class="s1">+</span>
			<span class="s0">`</span><span class="s3">\`</span><span class="s2">$</span><span class="s1">{ </span><span class="s2">property </span><span class="s1">}</span><span class="s3">\`</span><span class="s0">.`</span>
		<span class="s1">);</span>
	<span class="s1">}</span>
<span class="s1">};</span>

<span class="s3">const </span><span class="s2">handleLoneUnicodePropertyNameOrValue </span><span class="s1">= (</span><span class="s2">value</span><span class="s1">) =&gt; {</span>
	<span class="s5">// It could be a `General_Category` value or a binary property.</span>
	<span class="s5">// Note: `unicodeMatchPropertyValue` throws on invalid values.</span>
	<span class="s3">try </span><span class="s1">{</span>
		<span class="s3">const </span><span class="s2">property </span><span class="s1">= </span><span class="s0">'General_Category'</span><span class="s1">;</span>
		<span class="s3">const </span><span class="s2">category </span><span class="s1">= </span><span class="s2">unicodeMatchPropertyValue</span><span class="s1">(</span><span class="s2">property</span><span class="s1">, </span><span class="s2">value</span><span class="s1">);</span>
		<span class="s3">return </span><span class="s2">getUnicodePropertyValueSet</span><span class="s1">(</span><span class="s2">property</span><span class="s1">, </span><span class="s2">category</span><span class="s1">);</span>
	<span class="s1">} </span><span class="s3">catch </span><span class="s1">(</span><span class="s2">exception</span><span class="s1">) {}</span>
	<span class="s5">// It’s not a `General_Category` value, so check if it’s a property</span>
	<span class="s5">// of strings.</span>
	<span class="s3">try </span><span class="s1">{</span>
		<span class="s3">return </span><span class="s2">getUnicodePropertyValueSet</span><span class="s1">(</span><span class="s0">'Property_of_Strings'</span><span class="s1">, </span><span class="s2">value</span><span class="s1">);</span>
	<span class="s1">} </span><span class="s3">catch </span><span class="s1">(</span><span class="s2">exception</span><span class="s1">) {}</span>
	<span class="s5">// Lastly, check if it’s a binary property of single code points.</span>
	<span class="s5">// Note: `unicodeMatchProperty` throws on invalid properties.</span>
	<span class="s3">const </span><span class="s2">property </span><span class="s1">= </span><span class="s2">unicodeMatchProperty</span><span class="s1">(</span><span class="s2">value</span><span class="s1">);</span>
	<span class="s3">return </span><span class="s2">getUnicodePropertyValueSet</span><span class="s1">(</span><span class="s2">property</span><span class="s1">);</span>
<span class="s1">};</span>

<span class="s3">const </span><span class="s2">getUnicodePropertyEscapeSet </span><span class="s1">= (</span><span class="s2">value</span><span class="s1">, </span><span class="s2">isNegative</span><span class="s1">) =&gt; {</span>
	<span class="s3">const </span><span class="s2">parts </span><span class="s1">= </span><span class="s2">value</span><span class="s1">.</span><span class="s2">split</span><span class="s1">(</span><span class="s0">'='</span><span class="s1">);</span>
	<span class="s3">const </span><span class="s2">firstPart </span><span class="s1">= </span><span class="s2">parts</span><span class="s1">[</span><span class="s6">0</span><span class="s1">];</span>
	<span class="s3">let </span><span class="s2">set</span><span class="s1">;</span>
	<span class="s3">if </span><span class="s1">(</span><span class="s2">parts</span><span class="s1">.</span><span class="s2">length </span><span class="s1">== </span><span class="s6">1</span><span class="s1">) {</span>
		<span class="s2">set </span><span class="s1">= </span><span class="s2">handleLoneUnicodePropertyNameOrValue</span><span class="s1">(</span><span class="s2">firstPart</span><span class="s1">);</span>
	<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
		<span class="s5">// The pattern consists of two parts, i.e. `Property=Value`.</span>
		<span class="s3">const </span><span class="s2">property </span><span class="s1">= </span><span class="s2">unicodeMatchProperty</span><span class="s1">(</span><span class="s2">firstPart</span><span class="s1">);</span>
		<span class="s3">const </span><span class="s2">value </span><span class="s1">= </span><span class="s2">unicodeMatchPropertyValue</span><span class="s1">(</span><span class="s2">property</span><span class="s1">, </span><span class="s2">parts</span><span class="s1">[</span><span class="s6">1</span><span class="s1">]);</span>
		<span class="s2">set </span><span class="s1">= </span><span class="s2">getUnicodePropertyValueSet</span><span class="s1">(</span><span class="s2">property</span><span class="s1">, </span><span class="s2">value</span><span class="s1">);</span>
	<span class="s1">}</span>
	<span class="s3">if </span><span class="s1">(</span><span class="s2">isNegative</span><span class="s1">) {</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s2">set</span><span class="s1">.</span><span class="s2">strings</span><span class="s1">) {</span>
			<span class="s3">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">'Cannot negate Unicode property of strings'</span><span class="s1">);</span>
		<span class="s1">}</span>
		<span class="s3">return </span><span class="s1">{</span>
			<span class="s2">characters</span><span class="s1">: </span><span class="s2">UNICODE_SET</span><span class="s1">.</span><span class="s2">clone</span><span class="s1">().</span><span class="s2">remove</span><span class="s1">(</span><span class="s2">set</span><span class="s1">.</span><span class="s2">characters</span><span class="s1">),</span>
			<span class="s2">strings</span><span class="s1">: </span><span class="s3">new </span><span class="s2">Set</span><span class="s1">()</span>
		<span class="s1">};</span>
	<span class="s1">}</span>
	<span class="s3">return </span><span class="s1">{</span>
		<span class="s2">characters</span><span class="s1">: </span><span class="s2">set</span><span class="s1">.</span><span class="s2">characters</span><span class="s1">.</span><span class="s2">clone</span><span class="s1">(),</span>
		<span class="s2">strings</span><span class="s1">: </span><span class="s2">set</span><span class="s1">.</span><span class="s2">strings</span>
			<span class="s5">// We need to escape strings like *️⃣ to make sure that they can be safely used in unions.</span>
			<span class="s1">? </span><span class="s3">new </span><span class="s2">Set</span><span class="s1">(</span><span class="s2">set</span><span class="s1">.</span><span class="s2">strings</span><span class="s1">.</span><span class="s2">map</span><span class="s1">(</span><span class="s2">str </span><span class="s1">=&gt; </span><span class="s2">str</span><span class="s1">.</span><span class="s2">replace</span><span class="s1">(</span><span class="s2">SPECIAL_CHARS</span><span class="s1">, </span><span class="s0">'</span><span class="s3">\\</span><span class="s0">$1'</span><span class="s1">)))</span>
			<span class="s1">: </span><span class="s3">new </span><span class="s2">Set</span><span class="s1">()</span>
	<span class="s1">};</span>
<span class="s1">};</span>

<span class="s3">const </span><span class="s2">getUnicodePropertyEscapeCharacterClassData </span><span class="s1">= (</span><span class="s2">property</span><span class="s1">, </span><span class="s2">isNegative</span><span class="s1">) =&gt; {</span>
	<span class="s3">const </span><span class="s2">set </span><span class="s1">= </span><span class="s2">getUnicodePropertyEscapeSet</span><span class="s1">(</span><span class="s2">property</span><span class="s1">, </span><span class="s2">isNegative</span><span class="s1">);</span>
	<span class="s3">const </span><span class="s2">data </span><span class="s1">= </span><span class="s2">getCharacterClassEmptyData</span><span class="s1">();</span>
	<span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars </span><span class="s1">= </span><span class="s2">set</span><span class="s1">.</span><span class="s2">characters</span><span class="s1">;</span>
	<span class="s3">if </span><span class="s1">(</span><span class="s2">set</span><span class="s1">.</span><span class="s2">strings</span><span class="s1">.</span><span class="s2">size </span><span class="s1">&gt; </span><span class="s6">0</span><span class="s1">) {</span>
		<span class="s2">data</span><span class="s1">.</span><span class="s2">longStrings </span><span class="s1">= </span><span class="s2">set</span><span class="s1">.</span><span class="s2">strings</span><span class="s1">;</span>
		<span class="s2">data</span><span class="s1">.</span><span class="s2">maybeIncludesStrings </span><span class="s1">= </span><span class="s3">true</span><span class="s1">;</span>
	<span class="s1">}</span>
	<span class="s3">return </span><span class="s2">data</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s3">function </span><span class="s2">configNeedCaseFoldAscii</span><span class="s1">() {</span>
	<span class="s3">return </span><span class="s1">!!</span><span class="s2">config</span><span class="s1">.</span><span class="s2">modifiersData</span><span class="s1">.</span><span class="s2">i</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">configNeedCaseFoldUnicode</span><span class="s1">() {</span>
	<span class="s5">// config.modifiersData.i : undefined | false</span>
	<span class="s3">if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">modifiersData</span><span class="s1">.</span><span class="s2">i </span><span class="s1">=== </span><span class="s3">false</span><span class="s1">) </span><span class="s3">return false</span><span class="s1">;</span>
	<span class="s3">if </span><span class="s1">(!</span><span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">unicodeFlag</span><span class="s1">) </span><span class="s3">return false</span><span class="s1">;</span>
	<span class="s3">return </span><span class="s2">Boolean</span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">modifiersData</span><span class="s1">.</span><span class="s2">i </span><span class="s1">|| </span><span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">ignoreCase</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s5">// Given a range of code points, add any case-folded code points in that range</span>
<span class="s5">// to a set.</span>
<span class="s2">regenerate</span><span class="s1">.</span><span class="s2">prototype</span><span class="s1">.</span><span class="s2">iuAddRange </span><span class="s1">= </span><span class="s3">function</span><span class="s1">(</span><span class="s2">min</span><span class="s1">, </span><span class="s2">max</span><span class="s1">) {</span>
	<span class="s3">const </span><span class="s2">$this </span><span class="s1">= </span><span class="s3">this</span><span class="s1">;</span>
	<span class="s3">do </span><span class="s1">{</span>
		<span class="s3">const </span><span class="s2">folded </span><span class="s1">= </span><span class="s2">caseFold</span><span class="s1">(</span><span class="s2">min</span><span class="s1">, </span><span class="s2">configNeedCaseFoldAscii</span><span class="s1">(), </span><span class="s2">configNeedCaseFoldUnicode</span><span class="s1">());</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s2">folded</span><span class="s1">) {</span>
			<span class="s2">$this</span><span class="s1">.</span><span class="s2">add</span><span class="s1">(</span><span class="s2">folded</span><span class="s1">);</span>
		<span class="s1">}</span>
	<span class="s1">} </span><span class="s3">while </span><span class="s1">(++</span><span class="s2">min </span><span class="s1">&lt;= </span><span class="s2">max</span><span class="s1">);</span>
	<span class="s3">return </span><span class="s2">$this</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s2">regenerate</span><span class="s1">.</span><span class="s2">prototype</span><span class="s1">.</span><span class="s2">iuRemoveRange </span><span class="s1">= </span><span class="s3">function</span><span class="s1">(</span><span class="s2">min</span><span class="s1">, </span><span class="s2">max</span><span class="s1">) {</span>
	<span class="s3">const </span><span class="s2">$this </span><span class="s1">= </span><span class="s3">this</span><span class="s1">;</span>
	<span class="s3">do </span><span class="s1">{</span>
		<span class="s3">const </span><span class="s2">folded </span><span class="s1">= </span><span class="s2">caseFold</span><span class="s1">(</span><span class="s2">min</span><span class="s1">, </span><span class="s2">configNeedCaseFoldAscii</span><span class="s1">(), </span><span class="s2">configNeedCaseFoldUnicode</span><span class="s1">());</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s2">folded</span><span class="s1">) {</span>
			<span class="s2">$this</span><span class="s1">.</span><span class="s2">remove</span><span class="s1">(</span><span class="s2">folded</span><span class="s1">);</span>
		<span class="s1">}</span>
	<span class="s1">} </span><span class="s3">while </span><span class="s1">(++</span><span class="s2">min </span><span class="s1">&lt;= </span><span class="s2">max</span><span class="s1">);</span>
	<span class="s3">return </span><span class="s2">$this</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s3">const </span><span class="s2">update </span><span class="s1">= (</span><span class="s2">item</span><span class="s1">, </span><span class="s2">pattern</span><span class="s1">) =&gt; {</span>
	<span class="s3">let </span><span class="s2">tree </span><span class="s1">= </span><span class="s2">parse</span><span class="s1">(</span><span class="s2">pattern</span><span class="s1">, </span><span class="s2">config</span><span class="s1">.</span><span class="s2">useUnicodeFlag </span><span class="s1">? </span><span class="s0">'u' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">, {</span>
		<span class="s2">lookbehind</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
		<span class="s2">namedGroups</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
		<span class="s2">unicodePropertyEscape</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
		<span class="s2">unicodeSet</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
		<span class="s2">modifiers</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
	<span class="s1">});</span>
	<span class="s3">switch </span><span class="s1">(</span><span class="s2">tree</span><span class="s1">.</span><span class="s2">type</span><span class="s1">) {</span>
		<span class="s3">case </span><span class="s0">'characterClass'</span><span class="s1">:</span>
		<span class="s3">case </span><span class="s0">'group'</span><span class="s1">:</span>
		<span class="s3">case </span><span class="s0">'value'</span><span class="s1">:</span>
			<span class="s5">// No wrapping needed.</span>
			<span class="s3">break</span><span class="s1">;</span>
		<span class="s3">default</span><span class="s1">:</span>
			<span class="s5">// Wrap the pattern in a non-capturing group.</span>
			<span class="s2">tree </span><span class="s1">= </span><span class="s2">wrap</span><span class="s1">(</span><span class="s2">tree</span><span class="s1">, </span><span class="s2">pattern</span><span class="s1">);</span>
	<span class="s1">}</span>
	<span class="s2">Object</span><span class="s1">.</span><span class="s2">assign</span><span class="s1">(</span><span class="s2">item</span><span class="s1">, </span><span class="s2">tree</span><span class="s1">);</span>
<span class="s1">};</span>

<span class="s3">const </span><span class="s2">wrap </span><span class="s1">= (</span><span class="s2">tree</span><span class="s1">, </span><span class="s2">pattern</span><span class="s1">) =&gt; {</span>
	<span class="s5">// Wrap the pattern in a non-capturing group.</span>
	<span class="s3">return </span><span class="s1">{</span>
		<span class="s0">'type'</span><span class="s1">: </span><span class="s0">'group'</span><span class="s1">,</span>
		<span class="s0">'behavior'</span><span class="s1">: </span><span class="s0">'ignore'</span><span class="s1">,</span>
		<span class="s0">'body'</span><span class="s1">: [</span><span class="s2">tree</span><span class="s1">],</span>
		<span class="s0">'raw'</span><span class="s1">: </span><span class="s0">`(?:</span><span class="s2">$</span><span class="s1">{ </span><span class="s2">pattern </span><span class="s1">}</span><span class="s0">)`</span>
	<span class="s1">};</span>
<span class="s1">};</span>

<span class="s3">const </span><span class="s2">caseFold </span><span class="s1">= (</span><span class="s2">codePoint</span><span class="s1">, </span><span class="s2">includeAscii</span><span class="s1">, </span><span class="s2">includeUnicode</span><span class="s1">) =&gt; {</span>
	<span class="s3">let </span><span class="s2">folded </span><span class="s1">= (</span><span class="s2">includeUnicode </span><span class="s1">? </span><span class="s2">iuMappings</span><span class="s1">.</span><span class="s2">get</span><span class="s1">(</span><span class="s2">codePoint</span><span class="s1">) : </span><span class="s2">undefined</span><span class="s1">) || [];</span>
	<span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s2">folded </span><span class="s1">=== </span><span class="s0">'number'</span><span class="s1">) </span><span class="s2">folded </span><span class="s1">= [</span><span class="s2">folded</span><span class="s1">];</span>
	<span class="s3">if </span><span class="s1">(</span><span class="s2">includeAscii</span><span class="s1">) {</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s2">codePoint </span><span class="s1">&gt;= </span><span class="s6">0x41 </span><span class="s1">&amp;&amp; </span><span class="s2">codePoint </span><span class="s1">&lt;= </span><span class="s6">0x5A</span><span class="s1">) {</span>
			<span class="s2">folded</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">codePoint </span><span class="s1">+ </span><span class="s6">0x20</span><span class="s1">);</span>
		<span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">codePoint </span><span class="s1">&gt;= </span><span class="s6">0x61 </span><span class="s1">&amp;&amp; </span><span class="s2">codePoint </span><span class="s1">&lt;= </span><span class="s6">0x7A</span><span class="s1">) {</span>
			<span class="s2">folded</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">codePoint </span><span class="s1">- </span><span class="s6">0x20</span><span class="s1">);</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s3">return </span><span class="s2">folded</span><span class="s1">.</span><span class="s2">length </span><span class="s1">== </span><span class="s6">0 </span><span class="s1">? </span><span class="s3">false </span><span class="s1">: </span><span class="s2">folded</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s3">const </span><span class="s2">buildHandler </span><span class="s1">= (</span><span class="s2">action</span><span class="s1">) =&gt; {</span>
	<span class="s3">switch </span><span class="s1">(</span><span class="s2">action</span><span class="s1">) {</span>
		<span class="s3">case </span><span class="s0">'union'</span><span class="s1">:</span>
			<span class="s3">return </span><span class="s1">{</span>
				<span class="s2">single</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">cp</span><span class="s1">) =&gt; {</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">add</span><span class="s1">(</span><span class="s2">cp</span><span class="s1">);</span>
				<span class="s1">},</span>
				<span class="s2">regSet</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">set2</span><span class="s1">) =&gt; {</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">add</span><span class="s1">(</span><span class="s2">set2</span><span class="s1">);</span>
				<span class="s1">},</span>
				<span class="s2">range</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">) =&gt; {</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">addRange</span><span class="s1">(</span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">);</span>
				<span class="s1">},</span>
				<span class="s2">iuRange</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">) =&gt; {</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">iuAddRange</span><span class="s1">(</span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">);</span>
				<span class="s1">},</span>
				<span class="s2">nested</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">nestedData</span><span class="s1">) =&gt; {</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">add</span><span class="s1">(</span><span class="s2">nestedData</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">);</span>
					<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s2">str of nestedData</span><span class="s1">.</span><span class="s2">longStrings</span><span class="s1">) </span><span class="s2">data</span><span class="s1">.</span><span class="s2">longStrings</span><span class="s1">.</span><span class="s2">add</span><span class="s1">(</span><span class="s2">str</span><span class="s1">);</span>
					<span class="s3">if </span><span class="s1">(</span><span class="s2">nestedData</span><span class="s1">.</span><span class="s2">maybeIncludesStrings</span><span class="s1">) </span><span class="s2">data</span><span class="s1">.</span><span class="s2">maybeIncludesStrings </span><span class="s1">= </span><span class="s3">true</span><span class="s1">;</span>
				<span class="s1">}</span>
			<span class="s1">};</span>
		<span class="s3">case </span><span class="s0">'union-negative'</span><span class="s1">: {</span>
			<span class="s3">const </span><span class="s2">regSet </span><span class="s1">= (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">set2</span><span class="s1">) =&gt; {</span>
				<span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars </span><span class="s1">= </span><span class="s2">UNICODE_SET</span><span class="s1">.</span><span class="s2">clone</span><span class="s1">().</span><span class="s2">remove</span><span class="s1">(</span><span class="s2">set2</span><span class="s1">).</span><span class="s2">add</span><span class="s1">(</span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">);</span>
			<span class="s1">};</span>
			<span class="s3">return </span><span class="s1">{</span>
				<span class="s2">single</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">cp</span><span class="s1">) =&gt; {</span>
					<span class="s3">const </span><span class="s2">unicode </span><span class="s1">= </span><span class="s2">UNICODE_SET</span><span class="s1">.</span><span class="s2">clone</span><span class="s1">();</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars </span><span class="s1">= </span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">contains</span><span class="s1">(</span><span class="s2">cp</span><span class="s1">) ? </span><span class="s2">unicode </span><span class="s1">: </span><span class="s2">unicode</span><span class="s1">.</span><span class="s2">remove</span><span class="s1">(</span><span class="s2">cp</span><span class="s1">);</span>
				<span class="s1">},</span>
				<span class="s2">regSet</span><span class="s1">: </span><span class="s2">regSet</span><span class="s1">,</span>
				<span class="s2">range</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">) =&gt; {</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars </span><span class="s1">= </span><span class="s2">UNICODE_SET</span><span class="s1">.</span><span class="s2">clone</span><span class="s1">().</span><span class="s2">removeRange</span><span class="s1">(</span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">).</span><span class="s2">add</span><span class="s1">(</span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">);</span>
				<span class="s1">},</span>
				<span class="s2">iuRange</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">) =&gt; {</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars </span><span class="s1">= </span><span class="s2">UNICODE_SET</span><span class="s1">.</span><span class="s2">clone</span><span class="s1">().</span><span class="s2">iuRemoveRange</span><span class="s1">(</span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">).</span><span class="s2">add</span><span class="s1">(</span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">);</span>
				<span class="s1">},</span>
				<span class="s2">nested</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">nestedData</span><span class="s1">) =&gt; {</span>
					<span class="s2">regSet</span><span class="s1">(</span><span class="s2">data</span><span class="s1">, </span><span class="s2">nestedData</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">);</span>
					<span class="s3">if </span><span class="s1">(</span><span class="s2">nestedData</span><span class="s1">.</span><span class="s2">maybeIncludesStrings</span><span class="s1">) </span><span class="s3">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">'ASSERTION ERROR'</span><span class="s1">);</span>
				<span class="s1">}</span>
			<span class="s1">};</span>
		<span class="s1">}</span>
		<span class="s3">case </span><span class="s0">'intersection'</span><span class="s1">: {</span>
			<span class="s3">const </span><span class="s2">regSet </span><span class="s1">= (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">set2</span><span class="s1">) =&gt; {</span>
				<span class="s3">if </span><span class="s1">(</span><span class="s2">data</span><span class="s1">.</span><span class="s2">first</span><span class="s1">) </span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars </span><span class="s1">= </span><span class="s2">set2</span><span class="s1">;</span>
				<span class="s3">else </span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">intersection</span><span class="s1">(</span><span class="s2">set2</span><span class="s1">);</span>
			<span class="s1">};</span>
			<span class="s3">return </span><span class="s1">{</span>
				<span class="s2">single</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">cp</span><span class="s1">) =&gt; {</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars </span><span class="s1">= </span><span class="s2">data</span><span class="s1">.</span><span class="s2">first </span><span class="s1">|| </span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">contains</span><span class="s1">(</span><span class="s2">cp</span><span class="s1">) ? </span><span class="s2">regenerate</span><span class="s1">(</span><span class="s2">cp</span><span class="s1">) : </span><span class="s2">regenerate</span><span class="s1">();</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">longStrings</span><span class="s1">.</span><span class="s2">clear</span><span class="s1">();</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">maybeIncludesStrings </span><span class="s1">= </span><span class="s3">false</span><span class="s1">;</span>
				<span class="s1">},</span>
				<span class="s2">regSet</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">set</span><span class="s1">) =&gt; {</span>
					<span class="s2">regSet</span><span class="s1">(</span><span class="s2">data</span><span class="s1">, </span><span class="s2">set</span><span class="s1">);</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">longStrings</span><span class="s1">.</span><span class="s2">clear</span><span class="s1">();</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">maybeIncludesStrings </span><span class="s1">= </span><span class="s3">false</span><span class="s1">;</span>
				<span class="s1">},</span>
				<span class="s2">range</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">) =&gt; {</span>
					<span class="s3">if </span><span class="s1">(</span><span class="s2">data</span><span class="s1">.</span><span class="s2">first</span><span class="s1">) </span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">addRange</span><span class="s1">(</span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">);</span>
					<span class="s3">else </span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">intersection</span><span class="s1">(</span><span class="s2">regenerate</span><span class="s1">().</span><span class="s2">addRange</span><span class="s1">(</span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">));</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">longStrings</span><span class="s1">.</span><span class="s2">clear</span><span class="s1">();</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">maybeIncludesStrings </span><span class="s1">= </span><span class="s3">false</span><span class="s1">;</span>
				<span class="s1">},</span>
				<span class="s2">iuRange</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">) =&gt; {</span>
					<span class="s3">if </span><span class="s1">(</span><span class="s2">data</span><span class="s1">.</span><span class="s2">first</span><span class="s1">) </span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">iuAddRange</span><span class="s1">(</span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">);</span>
					<span class="s3">else </span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">intersection</span><span class="s1">(</span><span class="s2">regenerate</span><span class="s1">().</span><span class="s2">iuAddRange</span><span class="s1">(</span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">));</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">longStrings</span><span class="s1">.</span><span class="s2">clear</span><span class="s1">();</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">maybeIncludesStrings </span><span class="s1">= </span><span class="s3">false</span><span class="s1">;</span>
				<span class="s1">},</span>
				<span class="s2">nested</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">nestedData</span><span class="s1">) =&gt; {</span>
					<span class="s2">regSet</span><span class="s1">(</span><span class="s2">data</span><span class="s1">, </span><span class="s2">nestedData</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">);</span>

					<span class="s3">if </span><span class="s1">(</span><span class="s2">data</span><span class="s1">.</span><span class="s2">first</span><span class="s1">) {</span>
						<span class="s2">data</span><span class="s1">.</span><span class="s2">longStrings </span><span class="s1">= </span><span class="s2">nestedData</span><span class="s1">.</span><span class="s2">longStrings</span><span class="s1">;</span>
						<span class="s2">data</span><span class="s1">.</span><span class="s2">maybeIncludesStrings </span><span class="s1">= </span><span class="s2">nestedData</span><span class="s1">.</span><span class="s2">maybeIncludesStrings</span><span class="s1">;</span>
					<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
						<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s2">str of data</span><span class="s1">.</span><span class="s2">longStrings</span><span class="s1">) {</span>
							<span class="s3">if </span><span class="s1">(!</span><span class="s2">nestedData</span><span class="s1">.</span><span class="s2">longStrings</span><span class="s1">.</span><span class="s2">has</span><span class="s1">(</span><span class="s2">str</span><span class="s1">)) </span><span class="s2">data</span><span class="s1">.</span><span class="s2">longStrings</span><span class="s1">.</span><span class="s2">delete</span><span class="s1">(</span><span class="s2">str</span><span class="s1">);</span>
						<span class="s1">}</span>
						<span class="s3">if </span><span class="s1">(!</span><span class="s2">nestedData</span><span class="s1">.</span><span class="s2">maybeIncludesStrings</span><span class="s1">) </span><span class="s2">data</span><span class="s1">.</span><span class="s2">maybeIncludesStrings </span><span class="s1">= </span><span class="s3">false</span><span class="s1">;</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">};</span>
		<span class="s1">}</span>
		<span class="s3">case </span><span class="s0">'subtraction'</span><span class="s1">: {</span>
			<span class="s3">const </span><span class="s2">regSet </span><span class="s1">= (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">set2</span><span class="s1">) =&gt; {</span>
				<span class="s3">if </span><span class="s1">(</span><span class="s2">data</span><span class="s1">.</span><span class="s2">first</span><span class="s1">) </span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">add</span><span class="s1">(</span><span class="s2">set2</span><span class="s1">);</span>
				<span class="s3">else </span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">remove</span><span class="s1">(</span><span class="s2">set2</span><span class="s1">);</span>
			<span class="s1">};</span>
			<span class="s3">return </span><span class="s1">{</span>
				<span class="s2">single</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">cp</span><span class="s1">) =&gt; {</span>
					<span class="s3">if </span><span class="s1">(</span><span class="s2">data</span><span class="s1">.</span><span class="s2">first</span><span class="s1">) </span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">add</span><span class="s1">(</span><span class="s2">cp</span><span class="s1">);</span>
					<span class="s3">else </span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">remove</span><span class="s1">(</span><span class="s2">cp</span><span class="s1">);</span>
				<span class="s1">},</span>
				<span class="s2">regSet</span><span class="s1">: </span><span class="s2">regSet</span><span class="s1">,</span>
				<span class="s2">range</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">) =&gt; {</span>
					<span class="s3">if </span><span class="s1">(</span><span class="s2">data</span><span class="s1">.</span><span class="s2">first</span><span class="s1">) </span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">addRange</span><span class="s1">(</span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">);</span>
					<span class="s3">else </span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">removeRange</span><span class="s1">(</span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">);</span>
				<span class="s1">},</span>
				<span class="s2">iuRange</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">) =&gt; {</span>
					<span class="s3">if </span><span class="s1">(</span><span class="s2">data</span><span class="s1">.</span><span class="s2">first</span><span class="s1">) </span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">iuAddRange</span><span class="s1">(</span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">);</span>
					<span class="s3">else </span><span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">iuRemoveRange</span><span class="s1">(</span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">);</span>
				<span class="s1">},</span>
				<span class="s2">nested</span><span class="s1">: (</span><span class="s2">data</span><span class="s1">, </span><span class="s2">nestedData</span><span class="s1">) =&gt; {</span>
					<span class="s2">regSet</span><span class="s1">(</span><span class="s2">data</span><span class="s1">, </span><span class="s2">nestedData</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">);</span>

					<span class="s3">if </span><span class="s1">(</span><span class="s2">data</span><span class="s1">.</span><span class="s2">first</span><span class="s1">) {</span>
						<span class="s2">data</span><span class="s1">.</span><span class="s2">longStrings </span><span class="s1">= </span><span class="s2">nestedData</span><span class="s1">.</span><span class="s2">longStrings</span><span class="s1">;</span>
						<span class="s2">data</span><span class="s1">.</span><span class="s2">maybeIncludesStrings </span><span class="s1">= </span><span class="s2">nestedData</span><span class="s1">.</span><span class="s2">maybeIncludesStrings</span><span class="s1">;</span>
					<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
						<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s2">str of data</span><span class="s1">.</span><span class="s2">longStrings</span><span class="s1">) {</span>
							<span class="s3">if </span><span class="s1">(</span><span class="s2">nestedData</span><span class="s1">.</span><span class="s2">longStrings</span><span class="s1">.</span><span class="s2">has</span><span class="s1">(</span><span class="s2">str</span><span class="s1">)) </span><span class="s2">data</span><span class="s1">.</span><span class="s2">longStrings</span><span class="s1">.</span><span class="s2">delete</span><span class="s1">(</span><span class="s2">str</span><span class="s1">);</span>
						<span class="s1">}</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">};</span>
		<span class="s1">}</span>
		<span class="s5">// The `default` clause is only here as a safeguard; it should never be</span>
		<span class="s5">// reached. Code coverage tools should ignore it.</span>
		<span class="s5">/* istanbul ignore next */</span>
		<span class="s3">default</span><span class="s1">:</span>
			<span class="s3">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">`Unknown set action: </span><span class="s2">$</span><span class="s1">{ </span><span class="s2">characterClassItem</span><span class="s1">.</span><span class="s2">kind </span><span class="s1">}</span><span class="s0">`</span><span class="s1">);</span>
	<span class="s1">}</span>
<span class="s1">};</span>

<span class="s3">const </span><span class="s2">getCharacterClassEmptyData </span><span class="s1">= () =&gt; ({</span>
	<span class="s2">transformed</span><span class="s1">: </span><span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">unicodeFlag</span><span class="s1">,</span>
	<span class="s2">singleChars</span><span class="s1">: </span><span class="s2">regenerate</span><span class="s1">(),</span>
	<span class="s2">longStrings</span><span class="s1">: </span><span class="s3">new </span><span class="s2">Set</span><span class="s1">(),</span>
	<span class="s2">hasEmptyString</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
	<span class="s2">first</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
	<span class="s2">maybeIncludesStrings</span><span class="s1">: </span><span class="s3">false</span>
<span class="s1">});</span>

<span class="s3">const </span><span class="s2">maybeFold </span><span class="s1">= (</span><span class="s2">codePoint</span><span class="s1">) =&gt; {</span>
	<span class="s3">const </span><span class="s2">caseFoldAscii </span><span class="s1">= </span><span class="s2">configNeedCaseFoldAscii</span><span class="s1">();</span>
	<span class="s3">const </span><span class="s2">caseFoldUnicode </span><span class="s1">= </span><span class="s2">configNeedCaseFoldUnicode</span><span class="s1">();</span>

	<span class="s3">if </span><span class="s1">(</span><span class="s2">caseFoldAscii </span><span class="s1">|| </span><span class="s2">caseFoldUnicode</span><span class="s1">) {</span>
		<span class="s3">const </span><span class="s2">folded </span><span class="s1">= </span><span class="s2">caseFold</span><span class="s1">(</span><span class="s2">codePoint</span><span class="s1">, </span><span class="s2">caseFoldAscii</span><span class="s1">, </span><span class="s2">caseFoldUnicode</span><span class="s1">);</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s2">folded</span><span class="s1">) {</span>
			<span class="s3">return </span><span class="s1">[</span><span class="s2">codePoint</span><span class="s1">, </span><span class="s2">folded</span><span class="s1">];</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s3">return </span><span class="s1">[</span><span class="s2">codePoint</span><span class="s1">];</span>
<span class="s1">};</span>

<span class="s3">const </span><span class="s2">computeClassStrings </span><span class="s1">= (</span><span class="s2">classStrings</span><span class="s1">, </span><span class="s2">regenerateOptions</span><span class="s1">) =&gt; {</span>
	<span class="s3">let </span><span class="s2">data </span><span class="s1">= </span><span class="s2">getCharacterClassEmptyData</span><span class="s1">();</span>

	<span class="s3">const </span><span class="s2">caseFoldAscii </span><span class="s1">= </span><span class="s2">configNeedCaseFoldAscii</span><span class="s1">();</span>
	<span class="s3">const </span><span class="s2">caseFoldUnicode </span><span class="s1">= </span><span class="s2">configNeedCaseFoldUnicode</span><span class="s1">();</span>

	<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s2">string of classStrings</span><span class="s1">.</span><span class="s2">strings</span><span class="s1">) {</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s2">string</span><span class="s1">.</span><span class="s2">characters</span><span class="s1">.</span><span class="s2">length </span><span class="s1">=== </span><span class="s6">1</span><span class="s1">) {</span>
			<span class="s2">maybeFold</span><span class="s1">(</span><span class="s2">string</span><span class="s1">.</span><span class="s2">characters</span><span class="s1">[</span><span class="s6">0</span><span class="s1">].</span><span class="s2">codePoint</span><span class="s1">).</span><span class="s2">forEach</span><span class="s1">((</span><span class="s2">cp</span><span class="s1">) =&gt; {</span>
				<span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">add</span><span class="s1">(</span><span class="s2">cp</span><span class="s1">);</span>
			<span class="s1">});</span>
		<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
			<span class="s3">let </span><span class="s2">stringifiedString</span><span class="s1">;</span>
			<span class="s3">if </span><span class="s1">(</span><span class="s2">caseFoldUnicode </span><span class="s1">|| </span><span class="s2">caseFoldAscii</span><span class="s1">) {</span>
				<span class="s2">stringifiedString </span><span class="s1">= </span><span class="s0">''</span><span class="s1">;</span>
				<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s2">ch of string</span><span class="s1">.</span><span class="s2">characters</span><span class="s1">) {</span>
					<span class="s3">let </span><span class="s2">set </span><span class="s1">= </span><span class="s2">regenerate</span><span class="s1">(</span><span class="s2">ch</span><span class="s1">.</span><span class="s2">codePoint</span><span class="s1">);</span>
					<span class="s3">const </span><span class="s2">folded </span><span class="s1">= </span><span class="s2">maybeFold</span><span class="s1">(</span><span class="s2">ch</span><span class="s1">.</span><span class="s2">codePoint</span><span class="s1">);</span>
					<span class="s3">if </span><span class="s1">(</span><span class="s2">folded</span><span class="s1">) </span><span class="s2">set</span><span class="s1">.</span><span class="s2">add</span><span class="s1">(</span><span class="s2">folded</span><span class="s1">);</span>
					<span class="s2">stringifiedString </span><span class="s1">+= </span><span class="s2">set</span><span class="s1">.</span><span class="s2">toString</span><span class="s1">(</span><span class="s2">regenerateOptions</span><span class="s1">);</span>
				<span class="s1">}</span>
			<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
				<span class="s2">stringifiedString </span><span class="s1">= </span><span class="s2">string</span><span class="s1">.</span><span class="s2">characters</span><span class="s1">.</span><span class="s2">map</span><span class="s1">(</span><span class="s2">ch </span><span class="s1">=&gt; </span><span class="s2">generate</span><span class="s1">(</span><span class="s2">ch</span><span class="s1">)).</span><span class="s2">join</span><span class="s1">(</span><span class="s0">''</span><span class="s1">)</span>
			<span class="s1">}</span>

			<span class="s2">data</span><span class="s1">.</span><span class="s2">longStrings</span><span class="s1">.</span><span class="s2">add</span><span class="s1">(</span><span class="s2">stringifiedString</span><span class="s1">);</span>
			<span class="s2">data</span><span class="s1">.</span><span class="s2">maybeIncludesStrings </span><span class="s1">= </span><span class="s3">true</span><span class="s1">;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s3">return </span><span class="s2">data</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">const </span><span class="s2">computeCharacterClass </span><span class="s1">= (</span><span class="s2">characterClassItem</span><span class="s1">, </span><span class="s2">regenerateOptions</span><span class="s1">) =&gt; {</span>
	<span class="s3">let </span><span class="s2">data </span><span class="s1">= </span><span class="s2">getCharacterClassEmptyData</span><span class="s1">();</span>

	<span class="s3">let </span><span class="s2">handlePositive</span><span class="s1">;</span>
	<span class="s3">let </span><span class="s2">handleNegative</span><span class="s1">;</span>

	<span class="s3">switch </span><span class="s1">(</span><span class="s2">characterClassItem</span><span class="s1">.</span><span class="s2">kind</span><span class="s1">) {</span>
		<span class="s3">case </span><span class="s0">'union'</span><span class="s1">:</span>
			<span class="s2">handlePositive </span><span class="s1">= </span><span class="s2">buildHandler</span><span class="s1">(</span><span class="s0">'union'</span><span class="s1">);</span>
			<span class="s2">handleNegative </span><span class="s1">= </span><span class="s2">buildHandler</span><span class="s1">(</span><span class="s0">'union-negative'</span><span class="s1">);</span>
			<span class="s3">break</span><span class="s1">;</span>
		<span class="s3">case </span><span class="s0">'intersection'</span><span class="s1">:</span>
			<span class="s2">handlePositive </span><span class="s1">= </span><span class="s2">buildHandler</span><span class="s1">(</span><span class="s0">'intersection'</span><span class="s1">);</span>
			<span class="s2">handleNegative </span><span class="s1">= </span><span class="s2">buildHandler</span><span class="s1">(</span><span class="s0">'subtraction'</span><span class="s1">);</span>
			<span class="s3">if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">unicodeSetsFlag</span><span class="s1">) </span><span class="s2">data</span><span class="s1">.</span><span class="s2">transformed </span><span class="s1">= </span><span class="s3">true</span><span class="s1">;</span>
			<span class="s3">break</span><span class="s1">;</span>
		<span class="s3">case </span><span class="s0">'subtraction'</span><span class="s1">:</span>
			<span class="s2">handlePositive </span><span class="s1">= </span><span class="s2">buildHandler</span><span class="s1">(</span><span class="s0">'subtraction'</span><span class="s1">);</span>
			<span class="s2">handleNegative </span><span class="s1">= </span><span class="s2">buildHandler</span><span class="s1">(</span><span class="s0">'intersection'</span><span class="s1">);</span>
			<span class="s3">if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">unicodeSetsFlag</span><span class="s1">) </span><span class="s2">data</span><span class="s1">.</span><span class="s2">transformed </span><span class="s1">= </span><span class="s3">true</span><span class="s1">;</span>
			<span class="s3">break</span><span class="s1">;</span>
		<span class="s5">// The `default` clause is only here as a safeguard; it should never be</span>
		<span class="s5">// reached. Code coverage tools should ignore it.</span>
		<span class="s5">/* istanbul ignore next */</span>
		<span class="s3">default</span><span class="s1">:</span>
			<span class="s3">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">`Unknown character class kind: </span><span class="s2">$</span><span class="s1">{ </span><span class="s2">characterClassItem</span><span class="s1">.</span><span class="s2">kind </span><span class="s1">}</span><span class="s0">`</span><span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s3">const </span><span class="s2">caseFoldAscii </span><span class="s1">= </span><span class="s2">configNeedCaseFoldAscii</span><span class="s1">();</span>
	<span class="s3">const </span><span class="s2">caseFoldUnicode </span><span class="s1">= </span><span class="s2">configNeedCaseFoldUnicode</span><span class="s1">();</span>

	<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s2">item of characterClassItem</span><span class="s1">.</span><span class="s2">body</span><span class="s1">) {</span>
		<span class="s3">switch </span><span class="s1">(</span><span class="s2">item</span><span class="s1">.</span><span class="s2">type</span><span class="s1">) {</span>
			<span class="s3">case </span><span class="s0">'value'</span><span class="s1">:</span>
				<span class="s2">maybeFold</span><span class="s1">(</span><span class="s2">item</span><span class="s1">.</span><span class="s2">codePoint</span><span class="s1">).</span><span class="s2">forEach</span><span class="s1">((</span><span class="s2">cp</span><span class="s1">) =&gt; {</span>
					<span class="s2">handlePositive</span><span class="s1">.</span><span class="s2">single</span><span class="s1">(</span><span class="s2">data</span><span class="s1">, </span><span class="s2">cp</span><span class="s1">);</span>
				<span class="s1">});</span>
				<span class="s3">break</span><span class="s1">;</span>
			<span class="s3">case </span><span class="s0">'characterClassRange'</span><span class="s1">:</span>
				<span class="s3">const </span><span class="s2">min </span><span class="s1">= </span><span class="s2">item</span><span class="s1">.</span><span class="s2">min</span><span class="s1">.</span><span class="s2">codePoint</span><span class="s1">;</span>
				<span class="s3">const </span><span class="s2">max </span><span class="s1">= </span><span class="s2">item</span><span class="s1">.</span><span class="s2">max</span><span class="s1">.</span><span class="s2">codePoint</span><span class="s1">;</span>
				<span class="s2">handlePositive</span><span class="s1">.</span><span class="s2">range</span><span class="s1">(</span><span class="s2">data</span><span class="s1">, </span><span class="s2">min</span><span class="s1">, </span><span class="s2">max</span><span class="s1">);</span>
				<span class="s3">if </span><span class="s1">(</span><span class="s2">caseFoldAscii </span><span class="s1">|| </span><span class="s2">caseFoldUnicode</span><span class="s1">) {</span>
					<span class="s2">handlePositive</span><span class="s1">.</span><span class="s2">iuRange</span><span class="s1">(</span><span class="s2">data</span><span class="s1">, </span><span class="s2">min</span><span class="s1">, </span><span class="s2">max</span><span class="s1">);</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">transformed </span><span class="s1">= </span><span class="s3">true</span><span class="s1">;</span>
				<span class="s1">}</span>
				<span class="s3">break</span><span class="s1">;</span>
			<span class="s3">case </span><span class="s0">'characterClassEscape'</span><span class="s1">:</span>
				<span class="s2">handlePositive</span><span class="s1">.</span><span class="s2">regSet</span><span class="s1">(</span><span class="s2">data</span><span class="s1">, </span><span class="s2">getCharacterClassEscapeSet</span><span class="s1">(</span>
					<span class="s2">item</span><span class="s1">.</span><span class="s2">value</span><span class="s1">,</span>
					<span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">unicode</span><span class="s1">,</span>
					<span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">ignoreCase</span>
				<span class="s1">));</span>
				<span class="s3">break</span><span class="s1">;</span>
			<span class="s3">case </span><span class="s0">'unicodePropertyEscape'</span><span class="s1">:</span>
				<span class="s3">const </span><span class="s2">nestedData </span><span class="s1">= </span><span class="s2">getUnicodePropertyEscapeCharacterClassData</span><span class="s1">(</span><span class="s2">item</span><span class="s1">.</span><span class="s2">value</span><span class="s1">, </span><span class="s2">item</span><span class="s1">.</span><span class="s2">negative</span><span class="s1">);</span>
				<span class="s2">handlePositive</span><span class="s1">.</span><span class="s2">nested</span><span class="s1">(</span><span class="s2">data</span><span class="s1">, </span><span class="s2">nestedData</span><span class="s1">);</span>
				<span class="s2">data</span><span class="s1">.</span><span class="s2">transformed </span><span class="s1">=</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">transformed </span><span class="s1">||</span>
					<span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">unicodePropertyEscapes </span><span class="s1">||</span>
					<span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">unicodeSetsFlag </span><span class="s1">&amp;&amp; </span><span class="s2">nestedData</span><span class="s1">.</span><span class="s2">maybeIncludesStrings</span><span class="s1">);</span>
				<span class="s3">break</span><span class="s1">;</span>
			<span class="s3">case </span><span class="s0">'characterClass'</span><span class="s1">:</span>
				<span class="s3">const </span><span class="s2">handler </span><span class="s1">= </span><span class="s2">item</span><span class="s1">.</span><span class="s2">negative </span><span class="s1">? </span><span class="s2">handleNegative </span><span class="s1">: </span><span class="s2">handlePositive</span><span class="s1">;</span>
				<span class="s3">const </span><span class="s2">res </span><span class="s1">= </span><span class="s2">computeCharacterClass</span><span class="s1">(</span><span class="s2">item</span><span class="s1">, </span><span class="s2">regenerateOptions</span><span class="s1">);</span>
				<span class="s2">handler</span><span class="s1">.</span><span class="s2">nested</span><span class="s1">(</span><span class="s2">data</span><span class="s1">, </span><span class="s2">res</span><span class="s1">);</span>
				<span class="s2">data</span><span class="s1">.</span><span class="s2">transformed </span><span class="s1">= </span><span class="s3">true</span><span class="s1">;</span>
				<span class="s3">break</span><span class="s1">;</span>
			<span class="s3">case </span><span class="s0">'classStrings'</span><span class="s1">:</span>
				<span class="s2">handlePositive</span><span class="s1">.</span><span class="s2">nested</span><span class="s1">(</span><span class="s2">data</span><span class="s1">, </span><span class="s2">computeClassStrings</span><span class="s1">(</span><span class="s2">item</span><span class="s1">, </span><span class="s2">regenerateOptions</span><span class="s1">));</span>
				<span class="s2">data</span><span class="s1">.</span><span class="s2">transformed </span><span class="s1">= </span><span class="s3">true</span><span class="s1">;</span>
				<span class="s3">break</span><span class="s1">;</span>
			<span class="s5">// The `default` clause is only here as a safeguard; it should never be</span>
			<span class="s5">// reached. Code coverage tools should ignore it.</span>
			<span class="s5">/* istanbul ignore next */</span>
			<span class="s3">default</span><span class="s1">:</span>
				<span class="s3">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">`Unknown term type: </span><span class="s2">$</span><span class="s1">{ </span><span class="s2">item</span><span class="s1">.</span><span class="s2">type </span><span class="s1">}</span><span class="s0">`</span><span class="s1">);</span>
		<span class="s1">}</span>

		<span class="s2">data</span><span class="s1">.</span><span class="s2">first </span><span class="s1">= </span><span class="s3">false</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s3">if </span><span class="s1">(</span><span class="s2">characterClassItem</span><span class="s1">.</span><span class="s2">negative </span><span class="s1">&amp;&amp; </span><span class="s2">data</span><span class="s1">.</span><span class="s2">maybeIncludesStrings</span><span class="s1">) {</span>
		<span class="s3">throw new </span><span class="s2">SyntaxError</span><span class="s1">(</span><span class="s0">'Cannot negate set containing strings'</span><span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s3">return </span><span class="s2">data</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">const </span><span class="s2">processCharacterClass </span><span class="s1">= (</span>
	<span class="s2">characterClassItem</span><span class="s1">,</span>
	<span class="s2">regenerateOptions</span><span class="s1">,</span>
	<span class="s2">computed </span><span class="s1">= </span><span class="s2">computeCharacterClass</span><span class="s1">(</span><span class="s2">characterClassItem</span><span class="s1">, </span><span class="s2">regenerateOptions</span><span class="s1">)</span>
<span class="s1">) =&gt; {</span>
	<span class="s3">const </span><span class="s2">negative </span><span class="s1">= </span><span class="s2">characterClassItem</span><span class="s1">.</span><span class="s2">negative</span><span class="s1">;</span>
	<span class="s3">const </span><span class="s1">{ </span><span class="s2">singleChars</span><span class="s1">, </span><span class="s2">transformed</span><span class="s1">, </span><span class="s2">longStrings </span><span class="s1">} = </span><span class="s2">computed</span><span class="s1">;</span>
	<span class="s3">if </span><span class="s1">(</span><span class="s2">transformed</span><span class="s1">) {</span>
		<span class="s3">const </span><span class="s2">setStr </span><span class="s1">= </span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">toString</span><span class="s1">(</span><span class="s2">regenerateOptions</span><span class="s1">);</span>

		<span class="s3">if </span><span class="s1">(</span><span class="s2">negative</span><span class="s1">) {</span>
			<span class="s3">if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">useUnicodeFlag</span><span class="s1">) {</span>
				<span class="s2">update</span><span class="s1">(</span><span class="s2">characterClassItem</span><span class="s1">, </span><span class="s0">`[^</span><span class="s2">$</span><span class="s1">{</span><span class="s2">setStr</span><span class="s1">[</span><span class="s6">0</span><span class="s1">] === </span><span class="s0">'[' </span><span class="s1">? </span><span class="s2">setStr</span><span class="s1">.</span><span class="s2">slice</span><span class="s1">(</span><span class="s6">1</span><span class="s1">, -</span><span class="s6">1</span><span class="s1">) : </span><span class="s2">setStr</span><span class="s1">}</span><span class="s0">]`</span><span class="s1">)</span>
			<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
				<span class="s3">if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">unicode</span><span class="s1">) {</span>
					<span class="s3">if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">ignoreCase</span><span class="s1">) {</span>
						<span class="s3">const </span><span class="s2">astralCharsSet </span><span class="s1">= </span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">clone</span><span class="s1">().</span><span class="s2">intersection</span><span class="s1">(</span><span class="s2">ASTRAL_SET</span><span class="s1">);</span>
						<span class="s5">// Assumption: singleChars do not contain lone surrogates.</span>
						<span class="s5">// Regex like /[^\ud800]/u is not supported</span>
						<span class="s3">const </span><span class="s2">surrogateOrBMPSetStr </span><span class="s1">= </span><span class="s2">singleChars</span>
							<span class="s1">.</span><span class="s2">clone</span><span class="s1">()</span>
							<span class="s1">.</span><span class="s2">remove</span><span class="s1">(</span><span class="s2">astralCharsSet</span><span class="s1">)</span>
							<span class="s1">.</span><span class="s2">addRange</span><span class="s1">(</span><span class="s6">0xd800</span><span class="s1">, </span><span class="s6">0xdfff</span><span class="s1">)</span>
							<span class="s1">.</span><span class="s2">toString</span><span class="s1">({ </span><span class="s2">bmpOnly</span><span class="s1">: </span><span class="s3">true </span><span class="s1">});</span>
						<span class="s5">// Don't generate negative lookahead for astral characters</span>
						<span class="s5">// because the case folding is not working anyway as we break</span>
						<span class="s5">// code points into surrogate pairs.</span>
						<span class="s3">const </span><span class="s2">astralNegativeSetStr </span><span class="s1">= </span><span class="s2">ASTRAL_SET</span>
							<span class="s1">.</span><span class="s2">clone</span><span class="s1">()</span>
							<span class="s1">.</span><span class="s2">remove</span><span class="s1">(</span><span class="s2">astralCharsSet</span><span class="s1">)</span>
							<span class="s1">.</span><span class="s2">toString</span><span class="s1">(</span><span class="s2">regenerateOptions</span><span class="s1">);</span>
						<span class="s5">// The transform here does not support lone surrogates.</span>
						<span class="s2">update</span><span class="s1">(</span>
							<span class="s2">characterClassItem</span><span class="s1">,</span>
							<span class="s0">`(?!</span><span class="s2">$</span><span class="s1">{</span><span class="s2">surrogateOrBMPSetStr</span><span class="s1">}</span><span class="s0">)[</span><span class="s3">\\</span><span class="s0">s</span><span class="s3">\\</span><span class="s0">S]|</span><span class="s2">$</span><span class="s1">{</span><span class="s2">astralNegativeSetStr</span><span class="s1">}</span><span class="s0">`</span>
						<span class="s1">);</span>
					<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
						<span class="s5">// Generate negative set directly when case folding is not involved.</span>
						<span class="s2">update</span><span class="s1">(</span>
							<span class="s2">characterClassItem</span><span class="s1">,</span>
							<span class="s2">UNICODE_SET</span><span class="s1">.</span><span class="s2">clone</span><span class="s1">().</span><span class="s2">remove</span><span class="s1">(</span><span class="s2">singleChars</span><span class="s1">).</span><span class="s2">toString</span><span class="s1">(</span><span class="s2">regenerateOptions</span><span class="s1">)</span>
						<span class="s1">);</span>
					<span class="s1">}</span>
				<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
					<span class="s2">update</span><span class="s1">(</span><span class="s2">characterClassItem</span><span class="s1">, </span><span class="s0">`(?!</span><span class="s2">$</span><span class="s1">{</span><span class="s2">setStr</span><span class="s1">}</span><span class="s0">)[</span><span class="s3">\\</span><span class="s0">s</span><span class="s3">\\</span><span class="s0">S]`</span><span class="s1">);</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
			<span class="s3">const </span><span class="s2">hasEmptyString </span><span class="s1">= </span><span class="s2">longStrings</span><span class="s1">.</span><span class="s2">has</span><span class="s1">(</span><span class="s0">''</span><span class="s1">);</span>
			<span class="s3">const </span><span class="s2">pieces </span><span class="s1">= </span><span class="s2">Array</span><span class="s1">.</span><span class="s2">from</span><span class="s1">(</span><span class="s2">longStrings</span><span class="s1">).</span><span class="s2">sort</span><span class="s1">((</span><span class="s2">a</span><span class="s1">, </span><span class="s2">b</span><span class="s1">) =&gt; </span><span class="s2">b</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s2">a</span><span class="s1">.</span><span class="s2">length</span><span class="s1">);</span>

			<span class="s3">if </span><span class="s1">(</span><span class="s2">setStr </span><span class="s1">!== </span><span class="s0">'[]' </span><span class="s1">|| </span><span class="s2">longStrings</span><span class="s1">.</span><span class="s2">size </span><span class="s1">=== </span><span class="s6">0</span><span class="s1">) {</span>
				<span class="s2">pieces</span><span class="s1">.</span><span class="s2">splice</span><span class="s1">(</span><span class="s2">pieces</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- (</span><span class="s2">hasEmptyString </span><span class="s1">? </span><span class="s6">1 </span><span class="s1">: </span><span class="s6">0</span><span class="s1">), </span><span class="s6">0</span><span class="s1">, </span><span class="s2">setStr</span><span class="s1">);</span>
			<span class="s1">}</span>

			<span class="s2">update</span><span class="s1">(</span><span class="s2">characterClassItem</span><span class="s1">, </span><span class="s2">pieces</span><span class="s1">.</span><span class="s2">join</span><span class="s1">(</span><span class="s0">'|'</span><span class="s1">));</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s3">return </span><span class="s2">characterClassItem</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s3">const </span><span class="s2">assertNoUnmatchedReferences </span><span class="s1">= (</span><span class="s2">groups</span><span class="s1">) =&gt; {</span>
	<span class="s3">const </span><span class="s2">unmatchedReferencesNames </span><span class="s1">= </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">groups</span><span class="s1">.</span><span class="s2">unmatchedReferences</span><span class="s1">);</span>
	<span class="s3">if </span><span class="s1">(</span><span class="s2">unmatchedReferencesNames</span><span class="s1">.</span><span class="s2">length </span><span class="s1">&gt; </span><span class="s6">0</span><span class="s1">) {</span>
		<span class="s3">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">`Unknown group names: </span><span class="s2">$</span><span class="s1">{</span><span class="s2">unmatchedReferencesNames</span><span class="s1">}</span><span class="s0">`</span><span class="s1">);</span>
	<span class="s1">}</span>
<span class="s1">};</span>

<span class="s3">const </span><span class="s2">processModifiers </span><span class="s1">= (</span><span class="s2">item</span><span class="s1">, </span><span class="s2">regenerateOptions</span><span class="s1">, </span><span class="s2">groups</span><span class="s1">) =&gt; {</span>
	<span class="s3">const </span><span class="s2">enabling </span><span class="s1">= </span><span class="s2">item</span><span class="s1">.</span><span class="s2">modifierFlags</span><span class="s1">.</span><span class="s2">enabling</span><span class="s1">;</span>
	<span class="s3">const </span><span class="s2">disabling </span><span class="s1">= </span><span class="s2">item</span><span class="s1">.</span><span class="s2">modifierFlags</span><span class="s1">.</span><span class="s2">disabling</span><span class="s1">;</span>

	<span class="s3">delete </span><span class="s2">item</span><span class="s1">.</span><span class="s2">modifierFlags</span><span class="s1">;</span>
	<span class="s2">item</span><span class="s1">.</span><span class="s2">behavior </span><span class="s1">= </span><span class="s0">'ignore'</span><span class="s1">;</span>

	<span class="s3">const </span><span class="s2">oldData </span><span class="s1">= </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">assign</span><span class="s1">({}, </span><span class="s2">config</span><span class="s1">.</span><span class="s2">modifiersData</span><span class="s1">);</span>

	<span class="s2">enabling</span><span class="s1">.</span><span class="s2">split</span><span class="s1">(</span><span class="s0">''</span><span class="s1">).</span><span class="s2">forEach</span><span class="s1">(</span><span class="s2">flag </span><span class="s1">=&gt; {</span>
		<span class="s2">config</span><span class="s1">.</span><span class="s2">modifiersData</span><span class="s1">[</span><span class="s2">flag</span><span class="s1">] = </span><span class="s3">true</span><span class="s1">;</span>
	<span class="s1">});</span>
	<span class="s2">disabling</span><span class="s1">.</span><span class="s2">split</span><span class="s1">(</span><span class="s0">''</span><span class="s1">).</span><span class="s2">forEach</span><span class="s1">(</span><span class="s2">flag </span><span class="s1">=&gt; {</span>
		<span class="s2">config</span><span class="s1">.</span><span class="s2">modifiersData</span><span class="s1">[</span><span class="s2">flag</span><span class="s1">] = </span><span class="s3">false</span><span class="s1">;</span>
	<span class="s1">});</span>

	<span class="s2">item</span><span class="s1">.</span><span class="s2">body </span><span class="s1">= </span><span class="s2">item</span><span class="s1">.</span><span class="s2">body</span><span class="s1">.</span><span class="s2">map</span><span class="s1">(</span><span class="s2">term </span><span class="s1">=&gt; {</span>
		<span class="s3">return </span><span class="s2">processTerm</span><span class="s1">(</span><span class="s2">term</span><span class="s1">, </span><span class="s2">regenerateOptions</span><span class="s1">, </span><span class="s2">groups</span><span class="s1">);</span>
	<span class="s1">});</span>

	<span class="s2">config</span><span class="s1">.</span><span class="s2">modifiersData </span><span class="s1">= </span><span class="s2">oldData</span><span class="s1">;</span>

	<span class="s3">return </span><span class="s2">item</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">const </span><span class="s2">processTerm </span><span class="s1">= (</span><span class="s2">item</span><span class="s1">, </span><span class="s2">regenerateOptions</span><span class="s1">, </span><span class="s2">groups</span><span class="s1">) =&gt; {</span>
	<span class="s3">switch </span><span class="s1">(</span><span class="s2">item</span><span class="s1">.</span><span class="s2">type</span><span class="s1">) {</span>
		<span class="s3">case </span><span class="s0">'dot'</span><span class="s1">:</span>
			<span class="s3">if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">unicodeFlag</span><span class="s1">) {</span>
				<span class="s2">update</span><span class="s1">(</span>
					<span class="s2">item</span><span class="s1">,</span>
					<span class="s2">getUnicodeDotSet</span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">dotAll </span><span class="s1">|| </span><span class="s2">config</span><span class="s1">.</span><span class="s2">modifiersData</span><span class="s1">.</span><span class="s2">s</span><span class="s1">).</span><span class="s2">toString</span><span class="s1">(</span><span class="s2">regenerateOptions</span><span class="s1">)</span>
				<span class="s1">);</span>
			<span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">dotAllFlag </span><span class="s1">|| </span><span class="s2">config</span><span class="s1">.</span><span class="s2">modifiersData</span><span class="s1">.</span><span class="s2">s</span><span class="s1">) {</span>
				<span class="s5">// TODO: consider changing this at the regenerate level.</span>
				<span class="s2">update</span><span class="s1">(</span><span class="s2">item</span><span class="s1">, </span><span class="s0">'[</span><span class="s3">\\</span><span class="s0">s</span><span class="s3">\\</span><span class="s0">S]'</span><span class="s1">);</span>
			<span class="s1">}</span>
			<span class="s3">break</span><span class="s1">;</span>
		<span class="s3">case </span><span class="s0">'characterClass'</span><span class="s1">:</span>
			<span class="s2">item </span><span class="s1">= </span><span class="s2">processCharacterClass</span><span class="s1">(</span><span class="s2">item</span><span class="s1">, </span><span class="s2">regenerateOptions</span><span class="s1">);</span>
			<span class="s3">break</span><span class="s1">;</span>
		<span class="s3">case </span><span class="s0">'unicodePropertyEscape'</span><span class="s1">:</span>
			<span class="s3">const </span><span class="s2">data </span><span class="s1">= </span><span class="s2">getUnicodePropertyEscapeCharacterClassData</span><span class="s1">(</span><span class="s2">item</span><span class="s1">.</span><span class="s2">value</span><span class="s1">, </span><span class="s2">item</span><span class="s1">.</span><span class="s2">negative</span><span class="s1">);</span>
			<span class="s3">if </span><span class="s1">(</span><span class="s2">data</span><span class="s1">.</span><span class="s2">maybeIncludesStrings</span><span class="s1">) {</span>
				<span class="s3">if </span><span class="s1">(!</span><span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">unicodeSets</span><span class="s1">) {</span>
					<span class="s3">throw new </span><span class="s2">Error</span><span class="s1">(</span>
						<span class="s0">'Properties of strings are only supported when using the unicodeSets (v) flag.'</span>
					<span class="s1">);</span>
				<span class="s1">}</span>
				<span class="s3">if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">unicodeSetsFlag</span><span class="s1">) {</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">transformed </span><span class="s1">= </span><span class="s3">true</span><span class="s1">;</span>
					<span class="s2">item </span><span class="s1">= </span><span class="s2">processCharacterClass</span><span class="s1">(</span><span class="s2">item</span><span class="s1">, </span><span class="s2">regenerateOptions</span><span class="s1">, </span><span class="s2">data</span><span class="s1">);</span>
				<span class="s1">}</span>
			<span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">unicodePropertyEscapes</span><span class="s1">) {</span>
				<span class="s2">update</span><span class="s1">(</span>
					<span class="s2">item</span><span class="s1">,</span>
					<span class="s2">data</span><span class="s1">.</span><span class="s2">singleChars</span><span class="s1">.</span><span class="s2">toString</span><span class="s1">(</span><span class="s2">regenerateOptions</span><span class="s1">)</span>
				<span class="s1">);</span>
			<span class="s1">}</span>
			<span class="s3">break</span><span class="s1">;</span>
		<span class="s3">case </span><span class="s0">'characterClassEscape'</span><span class="s1">:</span>
			<span class="s3">if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">unicodeFlag</span><span class="s1">) {</span>
				<span class="s2">update</span><span class="s1">(</span>
					<span class="s2">item</span><span class="s1">,</span>
					<span class="s2">getCharacterClassEscapeSet</span><span class="s1">(</span>
						<span class="s2">item</span><span class="s1">.</span><span class="s2">value</span><span class="s1">,</span>
						<span class="s5">/* config.transform.unicodeFlag implies config.flags.unicode */ </span><span class="s3">true</span><span class="s1">,</span>
						<span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">ignoreCase</span>
					<span class="s1">).</span><span class="s2">toString</span><span class="s1">(</span><span class="s2">regenerateOptions</span><span class="s1">)</span>
				<span class="s1">);</span>
			<span class="s1">}</span>
			<span class="s3">break</span><span class="s1">;</span>
		<span class="s3">case </span><span class="s0">'group'</span><span class="s1">:</span>
			<span class="s3">if </span><span class="s1">(</span><span class="s2">item</span><span class="s1">.</span><span class="s2">behavior </span><span class="s1">== </span><span class="s0">'normal'</span><span class="s1">) {</span>
				<span class="s2">groups</span><span class="s1">.</span><span class="s2">lastIndex</span><span class="s1">++;</span>
			<span class="s1">}</span>
			<span class="s3">if </span><span class="s1">(</span><span class="s2">item</span><span class="s1">.</span><span class="s2">name</span><span class="s1">) {</span>
				<span class="s3">const </span><span class="s2">name </span><span class="s1">= </span><span class="s2">item</span><span class="s1">.</span><span class="s2">name</span><span class="s1">.</span><span class="s2">value</span><span class="s1">;</span>

				<span class="s3">if </span><span class="s1">(</span><span class="s2">groups</span><span class="s1">.</span><span class="s2">namesConflicts</span><span class="s1">[</span><span class="s2">name</span><span class="s1">]) {</span>
					<span class="s3">throw new </span><span class="s2">Error</span><span class="s1">(</span>
						<span class="s0">`Group '</span><span class="s2">$</span><span class="s1">{ </span><span class="s2">name </span><span class="s1">}</span><span class="s0">' has already been defined in this context.`</span>
					<span class="s1">);</span>
				<span class="s1">}</span>
				<span class="s2">groups</span><span class="s1">.</span><span class="s2">namesConflicts</span><span class="s1">[</span><span class="s2">name</span><span class="s1">] = </span><span class="s3">true</span><span class="s1">;</span>

				<span class="s3">if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">namedGroups</span><span class="s1">) {</span>
					<span class="s3">delete </span><span class="s2">item</span><span class="s1">.</span><span class="s2">name</span><span class="s1">;</span>
				<span class="s1">}</span>

				<span class="s3">const </span><span class="s2">index </span><span class="s1">= </span><span class="s2">groups</span><span class="s1">.</span><span class="s2">lastIndex</span><span class="s1">;</span>
				<span class="s3">if </span><span class="s1">(!</span><span class="s2">groups</span><span class="s1">.</span><span class="s2">names</span><span class="s1">[</span><span class="s2">name</span><span class="s1">]) {</span>
					<span class="s2">groups</span><span class="s1">.</span><span class="s2">names</span><span class="s1">[</span><span class="s2">name</span><span class="s1">] = [];</span>
				<span class="s1">}</span>
				<span class="s2">groups</span><span class="s1">.</span><span class="s2">names</span><span class="s1">[</span><span class="s2">name</span><span class="s1">].</span><span class="s2">push</span><span class="s1">(</span><span class="s2">index</span><span class="s1">);</span>

				<span class="s3">if </span><span class="s1">(</span><span class="s2">groups</span><span class="s1">.</span><span class="s2">onNamedGroup</span><span class="s1">) {</span>
					<span class="s2">groups</span><span class="s1">.</span><span class="s2">onNamedGroup</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">null</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, </span><span class="s2">index</span><span class="s1">);</span>
				<span class="s1">}</span>

				<span class="s3">if </span><span class="s1">(</span><span class="s2">groups</span><span class="s1">.</span><span class="s2">unmatchedReferences</span><span class="s1">[</span><span class="s2">name</span><span class="s1">]) {</span>
					<span class="s3">delete </span><span class="s2">groups</span><span class="s1">.</span><span class="s2">unmatchedReferences</span><span class="s1">[</span><span class="s2">name</span><span class="s1">];</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s3">if </span><span class="s1">(</span><span class="s2">item</span><span class="s1">.</span><span class="s2">modifierFlags </span><span class="s1">&amp;&amp; </span><span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">modifiers</span><span class="s1">) {</span>
				<span class="s3">return </span><span class="s2">processModifiers</span><span class="s1">(</span><span class="s2">item</span><span class="s1">, </span><span class="s2">regenerateOptions</span><span class="s1">, </span><span class="s2">groups</span><span class="s1">);</span>
			<span class="s1">}</span>
			<span class="s5">/* falls through */</span>
		<span class="s3">case </span><span class="s0">'quantifier'</span><span class="s1">:</span>
			<span class="s2">item</span><span class="s1">.</span><span class="s2">body </span><span class="s1">= </span><span class="s2">item</span><span class="s1">.</span><span class="s2">body</span><span class="s1">.</span><span class="s2">map</span><span class="s1">(</span><span class="s2">term </span><span class="s1">=&gt; {</span>
				<span class="s3">return </span><span class="s2">processTerm</span><span class="s1">(</span><span class="s2">term</span><span class="s1">, </span><span class="s2">regenerateOptions</span><span class="s1">, </span><span class="s2">groups</span><span class="s1">);</span>
			<span class="s1">});</span>
			<span class="s3">break</span><span class="s1">;</span>
		<span class="s3">case </span><span class="s0">'disjunction'</span><span class="s1">:</span>
			<span class="s3">const </span><span class="s2">outerNamesConflicts </span><span class="s1">= </span><span class="s2">groups</span><span class="s1">.</span><span class="s2">namesConflicts</span><span class="s1">;</span>
			<span class="s2">item</span><span class="s1">.</span><span class="s2">body </span><span class="s1">= </span><span class="s2">item</span><span class="s1">.</span><span class="s2">body</span><span class="s1">.</span><span class="s2">map</span><span class="s1">(</span><span class="s2">term </span><span class="s1">=&gt; {</span>
				<span class="s2">groups</span><span class="s1">.</span><span class="s2">namesConflicts </span><span class="s1">= </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">create</span><span class="s1">(</span><span class="s2">outerNamesConflicts</span><span class="s1">);</span>
				<span class="s3">return </span><span class="s2">processTerm</span><span class="s1">(</span><span class="s2">term</span><span class="s1">, </span><span class="s2">regenerateOptions</span><span class="s1">, </span><span class="s2">groups</span><span class="s1">);</span>
			<span class="s1">});</span>
			<span class="s3">break</span><span class="s1">;</span>
		<span class="s3">case </span><span class="s0">'alternative'</span><span class="s1">:</span>
			<span class="s2">item</span><span class="s1">.</span><span class="s2">body </span><span class="s1">= </span><span class="s2">flatMap</span><span class="s1">(</span><span class="s2">item</span><span class="s1">.</span><span class="s2">body</span><span class="s1">, </span><span class="s2">term </span><span class="s1">=&gt; {</span>
				<span class="s3">const </span><span class="s2">res </span><span class="s1">= </span><span class="s2">processTerm</span><span class="s1">(</span><span class="s2">term</span><span class="s1">, </span><span class="s2">regenerateOptions</span><span class="s1">, </span><span class="s2">groups</span><span class="s1">);</span>
				<span class="s5">// Alternatives cannot contain alternatives; flatten them.</span>
				<span class="s3">return </span><span class="s2">res</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'alternative' </span><span class="s1">? </span><span class="s2">res</span><span class="s1">.</span><span class="s2">body </span><span class="s1">: </span><span class="s2">res</span><span class="s1">;</span>
			<span class="s1">});</span>
			<span class="s3">break</span><span class="s1">;</span>
		<span class="s3">case </span><span class="s0">'value'</span><span class="s1">:</span>
			<span class="s3">const </span><span class="s2">codePoint </span><span class="s1">= </span><span class="s2">item</span><span class="s1">.</span><span class="s2">codePoint</span><span class="s1">;</span>
			<span class="s3">const </span><span class="s2">set </span><span class="s1">= </span><span class="s2">regenerate</span><span class="s1">(</span><span class="s2">codePoint</span><span class="s1">);</span>
			<span class="s3">const </span><span class="s2">folded </span><span class="s1">= </span><span class="s2">maybeFold</span><span class="s1">(</span><span class="s2">codePoint</span><span class="s1">);</span>
			<span class="s2">set</span><span class="s1">.</span><span class="s2">add</span><span class="s1">(</span><span class="s2">folded</span><span class="s1">);</span>
			<span class="s2">update</span><span class="s1">(</span><span class="s2">item</span><span class="s1">, </span><span class="s2">set</span><span class="s1">.</span><span class="s2">toString</span><span class="s1">(</span><span class="s2">regenerateOptions</span><span class="s1">));</span>
			<span class="s3">break</span><span class="s1">;</span>
		<span class="s3">case </span><span class="s0">'reference'</span><span class="s1">:</span>
			<span class="s3">if </span><span class="s1">(</span><span class="s2">item</span><span class="s1">.</span><span class="s2">name</span><span class="s1">) {</span>
				<span class="s3">const </span><span class="s2">name </span><span class="s1">= </span><span class="s2">item</span><span class="s1">.</span><span class="s2">name</span><span class="s1">.</span><span class="s2">value</span><span class="s1">;</span>
				<span class="s3">const </span><span class="s2">indexes </span><span class="s1">= </span><span class="s2">groups</span><span class="s1">.</span><span class="s2">names</span><span class="s1">[</span><span class="s2">name</span><span class="s1">];</span>
				<span class="s3">if </span><span class="s1">(!</span><span class="s2">indexes</span><span class="s1">) {</span>
					<span class="s2">groups</span><span class="s1">.</span><span class="s2">unmatchedReferences</span><span class="s1">[</span><span class="s2">name</span><span class="s1">] = </span><span class="s3">true</span><span class="s1">;</span>
				<span class="s1">}</span>

				<span class="s3">if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">namedGroups</span><span class="s1">) {</span>
					<span class="s3">if </span><span class="s1">(</span><span class="s2">indexes</span><span class="s1">) {</span>
						<span class="s3">const </span><span class="s2">body </span><span class="s1">= </span><span class="s2">indexes</span><span class="s1">.</span><span class="s2">map</span><span class="s1">(</span><span class="s2">index </span><span class="s1">=&gt; ({</span>
							<span class="s0">'type'</span><span class="s1">: </span><span class="s0">'reference'</span><span class="s1">,</span>
							<span class="s0">'matchIndex'</span><span class="s1">: </span><span class="s2">index</span><span class="s1">,</span>
							<span class="s0">'raw'</span><span class="s1">: </span><span class="s0">'</span><span class="s3">\\</span><span class="s0">' </span><span class="s1">+ </span><span class="s2">index</span><span class="s1">,</span>
						<span class="s1">}));</span>
						<span class="s3">if </span><span class="s1">(</span><span class="s2">body</span><span class="s1">.</span><span class="s2">length </span><span class="s1">=== </span><span class="s6">1</span><span class="s1">) {</span>
							<span class="s3">return </span><span class="s2">body</span><span class="s1">[</span><span class="s6">0</span><span class="s1">];</span>
						<span class="s1">}</span>
						<span class="s3">return </span><span class="s1">{</span>
							<span class="s0">'type'</span><span class="s1">: </span><span class="s0">'alternative'</span><span class="s1">,</span>
							<span class="s0">'body'</span><span class="s1">: </span><span class="s2">body</span><span class="s1">,</span>
							<span class="s0">'raw'</span><span class="s1">: </span><span class="s2">body</span><span class="s1">.</span><span class="s2">map</span><span class="s1">(</span><span class="s2">term </span><span class="s1">=&gt; </span><span class="s2">term</span><span class="s1">.</span><span class="s2">raw</span><span class="s1">).</span><span class="s2">join</span><span class="s1">(</span><span class="s0">''</span><span class="s1">),</span>
						<span class="s1">};</span>
					<span class="s1">}</span>

					<span class="s5">// This named reference comes before the group where it’s defined,</span>
					<span class="s5">// so it’s always an empty match.</span>
					<span class="s3">return </span><span class="s1">{</span>
						<span class="s0">'type'</span><span class="s1">: </span><span class="s0">'group'</span><span class="s1">,</span>
						<span class="s0">'behavior'</span><span class="s1">: </span><span class="s0">'ignore'</span><span class="s1">,</span>
						<span class="s0">'body'</span><span class="s1">: [],</span>
						<span class="s0">'raw'</span><span class="s1">: </span><span class="s0">'(?:)'</span><span class="s1">,</span>
					<span class="s1">};</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s3">break</span><span class="s1">;</span>
		<span class="s3">case </span><span class="s0">'anchor'</span><span class="s1">:</span>
			<span class="s3">if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">modifiersData</span><span class="s1">.</span><span class="s2">m</span><span class="s1">) {</span>
				<span class="s3">if </span><span class="s1">(</span><span class="s2">item</span><span class="s1">.</span><span class="s2">kind </span><span class="s1">== </span><span class="s0">'start'</span><span class="s1">) {</span>
					<span class="s2">update</span><span class="s1">(</span><span class="s2">item</span><span class="s1">, </span><span class="s0">`(?:^|(?&lt;=</span><span class="s2">$</span><span class="s1">{</span><span class="s2">NEWLINE_SET</span><span class="s1">.</span><span class="s2">toString</span><span class="s1">()}</span><span class="s0">))`</span><span class="s1">);</span>
				<span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">item</span><span class="s1">.</span><span class="s2">kind </span><span class="s1">== </span><span class="s0">'end'</span><span class="s1">) {</span>
					<span class="s2">update</span><span class="s1">(</span><span class="s2">item</span><span class="s1">, </span><span class="s0">`(?:$|(?=</span><span class="s2">$</span><span class="s1">{</span><span class="s2">NEWLINE_SET</span><span class="s1">.</span><span class="s2">toString</span><span class="s1">()}</span><span class="s0">))`</span><span class="s1">);</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s3">case </span><span class="s0">'empty'</span><span class="s1">:</span>
			<span class="s5">// Nothing to do here.</span>
			<span class="s3">break</span><span class="s1">;</span>
		<span class="s5">// The `default` clause is only here as a safeguard; it should never be</span>
		<span class="s5">// reached. Code coverage tools should ignore it.</span>
		<span class="s5">/* istanbul ignore next */</span>
		<span class="s3">default</span><span class="s1">:</span>
			<span class="s3">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">`Unknown term type: </span><span class="s2">$</span><span class="s1">{ </span><span class="s2">item</span><span class="s1">.</span><span class="s2">type </span><span class="s1">}</span><span class="s0">`</span><span class="s1">);</span>
	<span class="s1">}</span>
	<span class="s3">return </span><span class="s2">item</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s3">const </span><span class="s2">config </span><span class="s1">= {</span>
	<span class="s0">'flags'</span><span class="s1">: {</span>
		<span class="s0">'ignoreCase'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
		<span class="s0">'unicode'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
		<span class="s0">'unicodeSets'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
		<span class="s0">'dotAll'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
		<span class="s0">'multiline'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
	<span class="s1">},</span>
	<span class="s0">'transform'</span><span class="s1">: {</span>
		<span class="s0">'dotAllFlag'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
		<span class="s0">'unicodeFlag'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
		<span class="s0">'unicodeSetsFlag'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
		<span class="s0">'unicodePropertyEscapes'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
		<span class="s0">'namedGroups'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
		<span class="s0">'modifiers'</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
	<span class="s1">},</span>
	<span class="s0">'modifiersData'</span><span class="s1">: {</span>
		<span class="s0">'i'</span><span class="s1">: </span><span class="s2">undefined</span><span class="s1">,</span>
		<span class="s0">'s'</span><span class="s1">: </span><span class="s2">undefined</span><span class="s1">,</span>
		<span class="s0">'m'</span><span class="s1">: </span><span class="s2">undefined</span><span class="s1">,</span>
	<span class="s1">},</span>
	<span class="s2">get useUnicodeFlag</span><span class="s1">() {</span>
		<span class="s3">return </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">unicode </span><span class="s1">|| </span><span class="s3">this</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">unicodeSets</span><span class="s1">) &amp;&amp; !</span><span class="s3">this</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">unicodeFlag</span><span class="s1">;</span>
	<span class="s1">}</span>
<span class="s1">};</span>

<span class="s3">const </span><span class="s2">validateOptions </span><span class="s1">= (</span><span class="s2">options</span><span class="s1">) =&gt; {</span>
	<span class="s3">if </span><span class="s1">(!</span><span class="s2">options</span><span class="s1">) </span><span class="s3">return</span><span class="s1">;</span>

	<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s2">key of Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">options</span><span class="s1">)) {</span>
		<span class="s3">const </span><span class="s2">value </span><span class="s1">= </span><span class="s2">options</span><span class="s1">[</span><span class="s2">key</span><span class="s1">];</span>
		<span class="s3">switch </span><span class="s1">(</span><span class="s2">key</span><span class="s1">) {</span>
			<span class="s3">case </span><span class="s0">'dotAllFlag'</span><span class="s1">:</span>
			<span class="s3">case </span><span class="s0">'unicodeFlag'</span><span class="s1">:</span>
			<span class="s3">case </span><span class="s0">'unicodePropertyEscapes'</span><span class="s1">:</span>
			<span class="s3">case </span><span class="s0">'namedGroups'</span><span class="s1">:</span>
				<span class="s3">if </span><span class="s1">(</span><span class="s2">value </span><span class="s1">!= </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s2">value </span><span class="s1">!== </span><span class="s3">false </span><span class="s1">&amp;&amp; </span><span class="s2">value </span><span class="s1">!== </span><span class="s0">'transform'</span><span class="s1">) {</span>
					<span class="s3">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">`.</span><span class="s2">$</span><span class="s1">{</span><span class="s2">key</span><span class="s1">} </span><span class="s0">must be false (default) or 'transform'.`</span><span class="s1">);</span>
				<span class="s1">}</span>
				<span class="s3">break</span><span class="s1">;</span>
			<span class="s3">case </span><span class="s0">'modifiers'</span><span class="s1">:</span>
			<span class="s3">case </span><span class="s0">'unicodeSetsFlag'</span><span class="s1">:</span>
				<span class="s3">if </span><span class="s1">(</span><span class="s2">value </span><span class="s1">!= </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s2">value </span><span class="s1">!== </span><span class="s3">false </span><span class="s1">&amp;&amp; </span><span class="s2">value </span><span class="s1">!== </span><span class="s0">'parse' </span><span class="s1">&amp;&amp; </span><span class="s2">value </span><span class="s1">!== </span><span class="s0">'transform'</span><span class="s1">) {</span>
					<span class="s3">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">`.</span><span class="s2">$</span><span class="s1">{</span><span class="s2">key</span><span class="s1">} </span><span class="s0">must be false (default), 'parse' or 'transform'.`</span><span class="s1">);</span>
				<span class="s1">}</span>
				<span class="s3">break</span><span class="s1">;</span>
			<span class="s3">case </span><span class="s0">'onNamedGroup'</span><span class="s1">:</span>
			<span class="s3">case </span><span class="s0">'onNewFlags'</span><span class="s1">:</span>
				<span class="s3">if </span><span class="s1">(</span><span class="s2">value </span><span class="s1">!= </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s2">value </span><span class="s1">!== </span><span class="s0">'function'</span><span class="s1">) {</span>
					<span class="s3">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">`.</span><span class="s2">$</span><span class="s1">{</span><span class="s2">key</span><span class="s1">} </span><span class="s0">must be a function.`</span><span class="s1">);</span>
				<span class="s1">}</span>
				<span class="s3">break</span><span class="s1">;</span>
			<span class="s3">default</span><span class="s1">:</span>
				<span class="s3">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">`.</span><span class="s2">$</span><span class="s1">{</span><span class="s2">key</span><span class="s1">} </span><span class="s0">is not a valid regexpu-core option.`</span><span class="s1">);</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
<span class="s1">};</span>

<span class="s3">const </span><span class="s2">hasFlag </span><span class="s1">= (</span><span class="s2">flags</span><span class="s1">, </span><span class="s2">flag</span><span class="s1">) =&gt; </span><span class="s2">flags </span><span class="s1">? </span><span class="s2">flags</span><span class="s1">.</span><span class="s2">includes</span><span class="s1">(</span><span class="s2">flag</span><span class="s1">) : </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">const </span><span class="s2">transform </span><span class="s1">= (</span><span class="s2">options</span><span class="s1">, </span><span class="s2">name</span><span class="s1">) =&gt; </span><span class="s2">options </span><span class="s1">? </span><span class="s2">options</span><span class="s1">[</span><span class="s2">name</span><span class="s1">] === </span><span class="s0">'transform' </span><span class="s1">: </span><span class="s3">false</span><span class="s1">;</span>

<span class="s3">const </span><span class="s2">rewritePattern </span><span class="s1">= (</span><span class="s2">pattern</span><span class="s1">, </span><span class="s2">flags</span><span class="s1">, </span><span class="s2">options</span><span class="s1">) =&gt; {</span>
	<span class="s2">validateOptions</span><span class="s1">(</span><span class="s2">options</span><span class="s1">);</span>

	<span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">unicode </span><span class="s1">= </span><span class="s2">hasFlag</span><span class="s1">(</span><span class="s2">flags</span><span class="s1">, </span><span class="s0">'u'</span><span class="s1">);</span>
	<span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">unicodeSets </span><span class="s1">= </span><span class="s2">hasFlag</span><span class="s1">(</span><span class="s2">flags</span><span class="s1">, </span><span class="s0">'v'</span><span class="s1">);</span>
	<span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">ignoreCase </span><span class="s1">= </span><span class="s2">hasFlag</span><span class="s1">(</span><span class="s2">flags</span><span class="s1">, </span><span class="s0">'i'</span><span class="s1">);</span>
	<span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">dotAll </span><span class="s1">= </span><span class="s2">hasFlag</span><span class="s1">(</span><span class="s2">flags</span><span class="s1">, </span><span class="s0">'s'</span><span class="s1">);</span>
	<span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">multiline </span><span class="s1">= </span><span class="s2">hasFlag</span><span class="s1">(</span><span class="s2">flags</span><span class="s1">, </span><span class="s0">'m'</span><span class="s1">);</span>

	<span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">dotAllFlag </span><span class="s1">= </span><span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">dotAll </span><span class="s1">&amp;&amp; </span><span class="s2">transform</span><span class="s1">(</span><span class="s2">options</span><span class="s1">, </span><span class="s0">'dotAllFlag'</span><span class="s1">);</span>
	<span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">unicodeFlag </span><span class="s1">= (</span><span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">unicode </span><span class="s1">|| </span><span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">unicodeSets</span><span class="s1">) &amp;&amp; </span><span class="s2">transform</span><span class="s1">(</span><span class="s2">options</span><span class="s1">, </span><span class="s0">'unicodeFlag'</span><span class="s1">);</span>
	<span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">unicodeSetsFlag </span><span class="s1">= </span><span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">unicodeSets </span><span class="s1">&amp;&amp; </span><span class="s2">transform</span><span class="s1">(</span><span class="s2">options</span><span class="s1">, </span><span class="s0">'unicodeSetsFlag'</span><span class="s1">);</span>

	<span class="s5">// unicodeFlag: 'transform' implies unicodePropertyEscapes: 'transform'</span>
	<span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">unicodePropertyEscapes </span><span class="s1">= </span><span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">unicode </span><span class="s1">&amp;&amp; (</span>
		<span class="s2">transform</span><span class="s1">(</span><span class="s2">options</span><span class="s1">, </span><span class="s0">'unicodeFlag'</span><span class="s1">) || </span><span class="s2">transform</span><span class="s1">(</span><span class="s2">options</span><span class="s1">, </span><span class="s0">'unicodePropertyEscapes'</span><span class="s1">)</span>
	<span class="s1">);</span>
	<span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">namedGroups </span><span class="s1">= </span><span class="s2">transform</span><span class="s1">(</span><span class="s2">options</span><span class="s1">, </span><span class="s0">'namedGroups'</span><span class="s1">);</span>
	<span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">modifiers </span><span class="s1">= </span><span class="s2">transform</span><span class="s1">(</span><span class="s2">options</span><span class="s1">, </span><span class="s0">'modifiers'</span><span class="s1">);</span>

	<span class="s2">config</span><span class="s1">.</span><span class="s2">modifiersData</span><span class="s1">.</span><span class="s2">i </span><span class="s1">= </span><span class="s2">undefined</span><span class="s1">;</span>
	<span class="s2">config</span><span class="s1">.</span><span class="s2">modifiersData</span><span class="s1">.</span><span class="s2">s </span><span class="s1">= </span><span class="s2">undefined</span><span class="s1">;</span>
	<span class="s2">config</span><span class="s1">.</span><span class="s2">modifiersData</span><span class="s1">.</span><span class="s2">m </span><span class="s1">= </span><span class="s2">undefined</span><span class="s1">;</span>

	<span class="s3">const </span><span class="s2">regjsparserFeatures </span><span class="s1">= {</span>
		<span class="s0">'unicodeSet'</span><span class="s1">: </span><span class="s2">Boolean</span><span class="s1">(</span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">unicodeSetsFlag</span><span class="s1">),</span>
		<span class="s0">'modifiers'</span><span class="s1">: </span><span class="s2">Boolean</span><span class="s1">(</span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">modifiers</span><span class="s1">),</span>

		<span class="s5">// Enable every stable RegExp feature by default</span>
		<span class="s0">'unicodePropertyEscape'</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
		<span class="s0">'namedGroups'</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
		<span class="s0">'lookbehind'</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
	<span class="s1">};</span>

	<span class="s3">const </span><span class="s2">regenerateOptions </span><span class="s1">= {</span>
		<span class="s0">'hasUnicodeFlag'</span><span class="s1">: </span><span class="s2">config</span><span class="s1">.</span><span class="s2">useUnicodeFlag</span><span class="s1">,</span>
		<span class="s0">'bmpOnly'</span><span class="s1">: !</span><span class="s2">config</span><span class="s1">.</span><span class="s2">flags</span><span class="s1">.</span><span class="s2">unicode</span>
	<span class="s1">};</span>

	<span class="s3">const </span><span class="s2">groups </span><span class="s1">= {</span>
		<span class="s0">'onNamedGroup'</span><span class="s1">: </span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">onNamedGroup</span><span class="s1">,</span>
		<span class="s0">'lastIndex'</span><span class="s1">: </span><span class="s6">0</span><span class="s1">,</span>
		<span class="s0">'names'</span><span class="s1">: </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">create</span><span class="s1">(</span><span class="s3">null</span><span class="s1">), </span><span class="s5">// { [name]: Array&lt;index&gt; }</span>
		<span class="s0">'namesConflicts'</span><span class="s1">: </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">create</span><span class="s1">(</span><span class="s3">null</span><span class="s1">), </span><span class="s5">// { [name]: true }</span>
		<span class="s0">'unmatchedReferences'</span><span class="s1">: </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">create</span><span class="s1">(</span><span class="s3">null</span><span class="s1">) </span><span class="s5">// { [name]: true }</span>
	<span class="s1">};</span>

	<span class="s3">const </span><span class="s2">tree </span><span class="s1">= </span><span class="s2">parse</span><span class="s1">(</span><span class="s2">pattern</span><span class="s1">, </span><span class="s2">flags</span><span class="s1">, </span><span class="s2">regjsparserFeatures</span><span class="s1">);</span>

	<span class="s3">if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">modifiers</span><span class="s1">) {</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s4">/\(\?[a-z]*-[a-z]+:/</span><span class="s1">.</span><span class="s2">test</span><span class="s1">(</span><span class="s2">pattern</span><span class="s1">)) {</span>
			<span class="s5">// the pattern _likely_ contain inline disabled modifiers</span>
			<span class="s5">// we need to traverse to make sure that they are actually modifiers and to collect them</span>
			<span class="s3">const </span><span class="s2">allDisabledModifiers </span><span class="s1">= </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">create</span><span class="s1">(</span><span class="s3">null</span><span class="s1">)</span>
			<span class="s3">const </span><span class="s2">itemStack </span><span class="s1">= [</span><span class="s2">tree</span><span class="s1">];</span>
			<span class="s3">let </span><span class="s2">node</span><span class="s1">;</span>
			<span class="s3">while </span><span class="s1">(</span><span class="s2">node </span><span class="s1">= </span><span class="s2">itemStack</span><span class="s1">.</span><span class="s2">pop</span><span class="s1">(), </span><span class="s2">node </span><span class="s1">!= </span><span class="s2">undefined</span><span class="s1">) {</span>
				<span class="s3">if </span><span class="s1">(</span><span class="s2">Array</span><span class="s1">.</span><span class="s2">isArray</span><span class="s1">(</span><span class="s2">node</span><span class="s1">)) {</span>
					<span class="s2">Array</span><span class="s1">.</span><span class="s2">prototype</span><span class="s1">.</span><span class="s2">push</span><span class="s1">.</span><span class="s2">apply</span><span class="s1">(</span><span class="s2">itemStack</span><span class="s1">, </span><span class="s2">node</span><span class="s1">);</span>
				<span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s2">node </span><span class="s1">== </span><span class="s0">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">node </span><span class="s1">!= </span><span class="s3">null</span><span class="s1">) {</span>
					<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s2">key of Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">node</span><span class="s1">)) {</span>
						<span class="s3">const </span><span class="s2">value </span><span class="s1">= </span><span class="s2">node</span><span class="s1">[</span><span class="s2">key</span><span class="s1">];</span>
						<span class="s3">if </span><span class="s1">(</span><span class="s2">key </span><span class="s1">== </span><span class="s0">'modifierFlags'</span><span class="s1">) {</span>
							<span class="s3">if </span><span class="s1">(</span><span class="s2">value</span><span class="s1">.</span><span class="s2">disabling</span><span class="s1">.</span><span class="s2">length </span><span class="s1">&gt; </span><span class="s6">0</span><span class="s1">){</span>
								<span class="s2">value</span><span class="s1">.</span><span class="s2">disabling</span><span class="s1">.</span><span class="s2">split</span><span class="s1">(</span><span class="s0">''</span><span class="s1">).</span><span class="s2">forEach</span><span class="s1">((</span><span class="s2">flag</span><span class="s1">)=&gt;{</span>
									<span class="s2">allDisabledModifiers</span><span class="s1">[</span><span class="s2">flag</span><span class="s1">] = </span><span class="s3">true</span>
								<span class="s1">});</span>
							<span class="s1">}</span>
						<span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s2">value </span><span class="s1">== </span><span class="s0">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">value </span><span class="s1">!= </span><span class="s3">null</span><span class="s1">) {</span>
							<span class="s2">itemStack</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">value</span><span class="s1">);</span>
						<span class="s1">}</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s2">flag of Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">allDisabledModifiers</span><span class="s1">)) {</span>
				<span class="s2">config</span><span class="s1">.</span><span class="s2">modifiersData</span><span class="s1">[</span><span class="s2">flag</span><span class="s1">] = </span><span class="s3">true</span><span class="s1">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s5">// Note: `processTerm` mutates `tree` and `groups`.</span>
	<span class="s2">processTerm</span><span class="s1">(</span><span class="s2">tree</span><span class="s1">, </span><span class="s2">regenerateOptions</span><span class="s1">, </span><span class="s2">groups</span><span class="s1">);</span>
	<span class="s2">assertNoUnmatchedReferences</span><span class="s1">(</span><span class="s2">groups</span><span class="s1">);</span>

	<span class="s3">const </span><span class="s2">onNewFlags </span><span class="s1">= </span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">onNewFlags</span><span class="s1">;</span>
	<span class="s3">if </span><span class="s1">(</span><span class="s2">onNewFlags</span><span class="s1">) {</span>
		<span class="s3">let </span><span class="s2">newFlags </span><span class="s1">= </span><span class="s2">flags</span><span class="s1">.</span><span class="s2">split</span><span class="s1">(</span><span class="s0">''</span><span class="s1">).</span><span class="s2">filter</span><span class="s1">((</span><span class="s2">flag</span><span class="s1">) =&gt; !</span><span class="s2">config</span><span class="s1">.</span><span class="s2">modifiersData</span><span class="s1">[</span><span class="s2">flag</span><span class="s1">]).</span><span class="s2">join</span><span class="s1">(</span><span class="s0">''</span><span class="s1">);</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">unicodeSetsFlag</span><span class="s1">) {</span>
			<span class="s2">newFlags </span><span class="s1">= </span><span class="s2">newFlags</span><span class="s1">.</span><span class="s2">replace</span><span class="s1">(</span><span class="s0">'v'</span><span class="s1">, </span><span class="s0">'u'</span><span class="s1">);</span>
		<span class="s1">}</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">unicodeFlag</span><span class="s1">) {</span>
			<span class="s2">newFlags </span><span class="s1">= </span><span class="s2">newFlags</span><span class="s1">.</span><span class="s2">replace</span><span class="s1">(</span><span class="s0">'u'</span><span class="s1">, </span><span class="s0">''</span><span class="s1">);</span>
		<span class="s1">}</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s2">config</span><span class="s1">.</span><span class="s2">transform</span><span class="s1">.</span><span class="s2">dotAllFlag </span><span class="s1">=== </span><span class="s0">'transform'</span><span class="s1">) {</span>
			<span class="s2">newFlags </span><span class="s1">= </span><span class="s2">newFlags</span><span class="s1">.</span><span class="s2">replace</span><span class="s1">(</span><span class="s0">'s'</span><span class="s1">, </span><span class="s0">''</span><span class="s1">);</span>
		<span class="s1">}</span>
		<span class="s2">onNewFlags</span><span class="s1">(</span><span class="s2">newFlags</span><span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s3">return </span><span class="s2">generate</span><span class="s1">(</span><span class="s2">tree</span><span class="s1">);</span>
<span class="s1">};</span>

<span class="s2">module</span><span class="s1">.</span><span class="s2">exports </span><span class="s1">= </span><span class="s2">rewritePattern</span><span class="s1">;</span>
</pre>
</body>
</html>