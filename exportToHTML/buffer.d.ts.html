<html>
<head>
<title>buffer.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #67a37c; font-style: italic;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #bcbec4;}
.s5 { color: #cf8e6d;}
.s6 { color: #7a7e85;}
.s7 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
buffer.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* `Buffer` objects are used to represent a fixed-length sequence of bytes. Many</span>
 <span class="s0">* Node.js APIs support `Buffer`s.</span>
 <span class="s0">*</span>
 <span class="s0">* The `Buffer` class is a subclass of JavaScript's [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) class and</span>
 <span class="s0">* extends it with methods that cover additional use cases. Node.js APIs accept</span>
 <span class="s0">* plain [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) s wherever `Buffer`s are supported as well.</span>
 <span class="s0">*</span>
 <span class="s0">* While the `Buffer` class is available within the global scope, it is still</span>
 <span class="s0">* recommended to explicitly reference it via an import or require statement.</span>
 <span class="s0">*</span>
 <span class="s0">* ```js</span>
 <span class="s0">* import { Buffer } from 'node:buffer';</span>
 <span class="s0">*</span>
 <span class="s0">* // Creates a zero-filled Buffer of length 10.</span>
 <span class="s0">* const buf1 = Buffer.alloc(10);</span>
 <span class="s0">*</span>
 <span class="s0">* // Creates a Buffer of length 10,</span>
 <span class="s0">* // filled with bytes which all have the value `1`.</span>
 <span class="s0">* const buf2 = Buffer.alloc(10, 1);</span>
 <span class="s0">*</span>
 <span class="s0">* // Creates an uninitialized buffer of length 10.</span>
 <span class="s0">* // This is faster than calling Buffer.alloc() but the returned</span>
 <span class="s0">* // Buffer instance might contain old data that needs to be</span>
 <span class="s0">* // overwritten using fill(), write(), or other functions that fill the Buffer's</span>
 <span class="s0">* // contents.</span>
 <span class="s0">* const buf3 = Buffer.allocUnsafe(10);</span>
 <span class="s0">*</span>
 <span class="s0">* // Creates a Buffer containing the bytes [1, 2, 3].</span>
 <span class="s0">* const buf4 = Buffer.from([1, 2, 3]);</span>
 <span class="s0">*</span>
 <span class="s0">* // Creates a Buffer containing the bytes [1, 1, 1, 1] – the entries</span>
 <span class="s0">* // are all truncated using `(value &amp;#x26; 255)` to fit into the range 0–255.</span>
 <span class="s0">* const buf5 = Buffer.from([257, 257.5, -255, '1']);</span>
 <span class="s0">*</span>
 <span class="s0">* // Creates a Buffer containing the UTF-8-encoded bytes for the string 'tést':</span>
 <span class="s0">* // [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)</span>
 <span class="s0">* // [116, 195, 169, 115, 116] (in decimal notation)</span>
 <span class="s0">* const buf6 = Buffer.from('tést');</span>
 <span class="s0">*</span>
 <span class="s0">* // Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].</span>
 <span class="s0">* const buf7 = Buffer.from('tést', 'latin1');</span>
 <span class="s0">* ```</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[source](https://github.com/nodejs/node/blob/v20.2.0/lib/buffer.js)</span>
 <span class="s0">*/</span>
<span class="s2">declare module </span><span class="s3">&quot;buffer&quot; </span><span class="s4">{</span>
    <span class="s5">import </span><span class="s4">{ </span><span class="s2">BinaryLike </span><span class="s4">} </span><span class="s2">from </span><span class="s3">&quot;node:crypto&quot;</span><span class="s4">;</span>
    <span class="s5">import </span><span class="s4">{ </span><span class="s2">ReadableStream </span><span class="s4">as </span><span class="s2">WebReadableStream </span><span class="s4">} </span><span class="s2">from </span><span class="s3">&quot;node:stream/web&quot;</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This function returns `true` if `input` contains only valid UTF-8-encoded data,</span>
     <span class="s0">* including the case in which `input` is empty.</span>
     <span class="s0">*</span>
     <span class="s0">* Throws if the `input` is a detached array buffer.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.4.0, v18.14.0</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">input The input to validate.</span>
     <span class="s0">*/</span>
    <span class="s5">export function </span><span class="s2">isUtf8</span><span class="s4">(</span><span class="s2">input</span><span class="s4">: </span><span class="s2">Buffer </span><span class="s4">| </span><span class="s2">ArrayBuffer </span><span class="s4">| </span><span class="s2">NodeJS</span><span class="s4">.</span><span class="s2">TypedArray</span><span class="s4">): </span><span class="s2">boolean</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This function returns `true` if `input` contains only valid ASCII-encoded data,</span>
     <span class="s0">* including the case in which `input` is empty.</span>
     <span class="s0">*</span>
     <span class="s0">* Throws if the `input` is a detached array buffer.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.6.0, v18.15.0</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">input The input to validate.</span>
     <span class="s0">*/</span>
    <span class="s5">export function </span><span class="s2">isAscii</span><span class="s4">(</span><span class="s2">input</span><span class="s4">: </span><span class="s2">Buffer </span><span class="s4">| </span><span class="s2">ArrayBuffer </span><span class="s4">| </span><span class="s2">NodeJS</span><span class="s4">.</span><span class="s2">TypedArray</span><span class="s4">): </span><span class="s2">boolean</span><span class="s4">;</span>
    <span class="s5">export const </span><span class="s2">INSPECT_MAX_BYTES</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s5">export const </span><span class="s2">kMaxLength</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s5">export const </span><span class="s2">kStringMaxLength</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s5">export const </span><span class="s2">constants</span><span class="s4">: {</span>
        <span class="s2">MAX_LENGTH</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s2">MAX_STRING_LENGTH</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s4">};</span>
    <span class="s5">export </span><span class="s2">type TranscodeEncoding </span><span class="s4">=</span>
        <span class="s4">| </span><span class="s3">&quot;ascii&quot;</span>
        <span class="s4">| </span><span class="s3">&quot;utf8&quot;</span>
        <span class="s4">| </span><span class="s3">&quot;utf-8&quot;</span>
        <span class="s4">| </span><span class="s3">&quot;utf16le&quot;</span>
        <span class="s4">| </span><span class="s3">&quot;utf-16le&quot;</span>
        <span class="s4">| </span><span class="s3">&quot;ucs2&quot;</span>
        <span class="s4">| </span><span class="s3">&quot;ucs-2&quot;</span>
        <span class="s4">| </span><span class="s3">&quot;latin1&quot;</span>
        <span class="s4">| </span><span class="s3">&quot;binary&quot;</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Re-encodes the given `Buffer` or `Uint8Array` instance from one character</span>
     <span class="s0">* encoding to another. Returns a new `Buffer` instance.</span>
     <span class="s0">*</span>
     <span class="s0">* Throws if the `fromEnc` or `toEnc` specify invalid character encodings or if</span>
     <span class="s0">* conversion from `fromEnc` to `toEnc` is not permitted.</span>
     <span class="s0">*</span>
     <span class="s0">* Encodings supported by `buffer.transcode()` are: `'ascii'`, `'utf8'`,`'utf16le'`, `'ucs2'`, `'latin1'`, and `'binary'`.</span>
     <span class="s0">*</span>
     <span class="s0">* The transcoding process will use substitution characters if a given byte</span>
     <span class="s0">* sequence cannot be adequately represented in the target encoding. For instance:</span>
     <span class="s0">*</span>
     <span class="s0">* ```js</span>
     <span class="s0">* import { Buffer, transcode } from 'node:buffer';</span>
     <span class="s0">*</span>
     <span class="s0">* const newBuf = transcode(Buffer.from('€'), 'utf8', 'ascii');</span>
     <span class="s0">* console.log(newBuf.toString('ascii'));</span>
     <span class="s0">* // Prints: '?'</span>
     <span class="s0">* ```</span>
     <span class="s0">*</span>
     <span class="s0">* Because the Euro (`€`) sign is not representable in US-ASCII, it is replaced</span>
     <span class="s0">* with `?` in the transcoded `Buffer`.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v7.1.0</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">source A `Buffer` or `Uint8Array` instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">fromEnc The current encoding.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">toEnc To target encoding.</span>
     <span class="s0">*/</span>
    <span class="s5">export function </span><span class="s2">transcode</span><span class="s4">(</span><span class="s2">source</span><span class="s4">: </span><span class="s2">Uint8Array</span><span class="s4">, </span><span class="s2">fromEnc</span><span class="s4">: </span><span class="s2">TranscodeEncoding</span><span class="s4">, </span><span class="s2">toEnc</span><span class="s4">: </span><span class="s2">TranscodeEncoding</span><span class="s4">): </span><span class="s2">Buffer</span><span class="s4">;</span>
    <span class="s5">export const </span><span class="s2">SlowBuffer</span><span class="s4">: {</span>
        <span class="s0">/** </span><span class="s1">@deprecated </span><span class="s0">since v6.0.0, use `Buffer.allocUnsafeSlow()` */</span>
        <span class="s5">new</span><span class="s4">(</span><span class="s2">size</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">Buffer</span><span class="s4">;</span>
        <span class="s2">prototype</span><span class="s4">: </span><span class="s2">Buffer</span><span class="s4">;</span>
    <span class="s4">};</span>
    <span class="s0">/**</span>
     <span class="s0">* Resolves a `'blob:nodedata:...'` an associated `Blob` object registered using</span>
     <span class="s0">* a prior call to `URL.createObjectURL()`.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v16.7.0</span>
     <span class="s0">* </span><span class="s1">@experimental</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">id A `'blob:nodedata:...` URL string returned by a prior call to `URL.createObjectURL()`.</span>
     <span class="s0">*/</span>
    <span class="s5">export function </span><span class="s2">resolveObjectURL</span><span class="s4">(</span><span class="s2">id</span><span class="s4">: </span><span class="s2">string</span><span class="s4">): </span><span class="s2">Blob </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s5">export </span><span class="s4">{ </span><span class="s2">Buffer </span><span class="s4">};</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@experimental</span>
     <span class="s0">*/</span>
    <span class="s5">export interface </span><span class="s2">BlobOptions </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">'utf8'</span>
         <span class="s0">*/</span>
        <span class="s2">encoding</span><span class="s4">?: </span><span class="s2">BufferEncoding </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The Blob content-type. The intent is for `type` to convey</span>
         <span class="s0">* the MIME media type of the data, however no validation of the type format</span>
         <span class="s0">* is performed.</span>
         <span class="s0">*/</span>
        <span class="s2">type</span><span class="s4">?: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) encapsulates immutable, raw data that can be safely shared across</span>
     <span class="s0">* multiple worker threads.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v15.7.0, v14.18.0</span>
     <span class="s0">*/</span>
    <span class="s5">export class </span><span class="s2">Blob </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The total size of the `Blob` in bytes.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v15.7.0, v14.18.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly size</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The content-type of the `Blob`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v15.7.0, v14.18.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly type</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Creates a new `Blob` object containing a concatenation of the given sources.</span>
         <span class="s0">*</span>
         <span class="s0">* {ArrayBuffer}, {TypedArray}, {DataView}, and {Buffer} sources are copied into</span>
         <span class="s0">* the 'Blob' and can therefore be safely modified after the 'Blob' is created.</span>
         <span class="s0">*</span>
         <span class="s0">* String sources are also copied into the `Blob`.</span>
         <span class="s0">*/</span>
        <span class="s2">constructor</span><span class="s4">(</span><span class="s2">sources</span><span class="s4">: </span><span class="s2">Array</span><span class="s4">&lt;</span><span class="s2">BinaryLike </span><span class="s4">| </span><span class="s2">Blob</span><span class="s4">&gt;, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">BlobOptions</span><span class="s4">);</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a promise that fulfills with an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) containing a copy of</span>
         <span class="s0">* the `Blob` data.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v15.7.0, v14.18.0</span>
         <span class="s0">*/</span>
        <span class="s2">arrayBuffer</span><span class="s4">(): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s2">ArrayBuffer</span><span class="s4">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Creates and returns a new `Blob` containing a subset of this `Blob` objects</span>
         <span class="s0">* data. The original `Blob` is not altered.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v15.7.0, v14.18.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">start The starting index.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">end The ending index.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">type The content-type for the new `Blob`</span>
         <span class="s0">*/</span>
        <span class="s2">slice</span><span class="s4">(</span><span class="s2">start</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">end</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">type</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">): </span><span class="s2">Blob</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a promise that fulfills with the contents of the `Blob` decoded as a</span>
         <span class="s0">* UTF-8 string.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v15.7.0, v14.18.0</span>
         <span class="s0">*/</span>
        <span class="s2">text</span><span class="s4">(): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s2">string</span><span class="s4">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a new `ReadableStream` that allows the content of the `Blob` to be read.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v16.7.0</span>
         <span class="s0">*/</span>
        <span class="s2">stream</span><span class="s4">(): </span><span class="s2">WebReadableStream</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s5">export interface </span><span class="s2">FileOptions </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* One of either `'transparent'` or `'native'`. When set to `'native'`, line endings in string source parts will be</span>
         <span class="s0">* converted to the platform native line-ending as specified by `require('node:os').EOL`.</span>
         <span class="s0">*/</span>
        <span class="s2">endings</span><span class="s4">?: </span><span class="s3">&quot;native&quot; </span><span class="s4">| </span><span class="s3">&quot;transparent&quot;</span><span class="s4">;</span>
        <span class="s0">/** The File content-type. */</span>
        <span class="s2">type</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">;</span>
        <span class="s0">/** The last modified date of the file. `Default`: Date.now(). */</span>
        <span class="s2">lastModified</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) provides information about files.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.2.0, v18.13.0</span>
     <span class="s0">*/</span>
    <span class="s5">export class </span><span class="s2">File </span><span class="s5">extends </span><span class="s2">Blob </span><span class="s4">{</span>
        <span class="s2">constructor</span><span class="s4">(</span><span class="s2">sources</span><span class="s4">: </span><span class="s2">Array</span><span class="s4">&lt;</span><span class="s2">BinaryLike </span><span class="s4">| </span><span class="s2">Blob</span><span class="s4">&gt;, </span><span class="s2">fileName</span><span class="s4">: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">FileOptions</span><span class="s4">);</span>
        <span class="s0">/**</span>
         <span class="s0">* The name of the `File`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.2.0, v18.13.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly name</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The last modified date of the `File`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.2.0, v18.13.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly lastModified</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s5">export import </span><span class="s2">atob </span><span class="s4">= </span><span class="s2">globalThis</span><span class="s4">.</span><span class="s2">atob</span><span class="s4">;</span>
    <span class="s5">export import </span><span class="s2">btoa </span><span class="s4">= </span><span class="s2">globalThis</span><span class="s4">.</span><span class="s2">btoa</span><span class="s4">;</span>
    <span class="s5">import </span><span class="s4">{ </span><span class="s2">Blob </span><span class="s4">as </span><span class="s2">NodeBlob </span><span class="s4">} </span><span class="s2">from </span><span class="s3">&quot;buffer&quot;</span><span class="s4">;</span>
    <span class="s6">// This conditional type will be the existing global Blob in a browser, or</span>
    <span class="s6">// the copy below in a Node environment.</span>
    <span class="s2">type __Blob </span><span class="s4">= </span><span class="s5">typeof </span><span class="s2">globalThis </span><span class="s5">extends </span><span class="s4">{ </span><span class="s2">onmessage</span><span class="s4">: </span><span class="s2">any</span><span class="s4">; </span><span class="s2">Blob</span><span class="s4">: </span><span class="s2">any </span><span class="s4">} ? {} : </span><span class="s2">NodeBlob</span><span class="s4">;</span>
    <span class="s2">global </span><span class="s4">{</span>
        <span class="s2">namespace NodeJS </span><span class="s4">{</span>
            <span class="s5">export </span><span class="s4">{ </span><span class="s2">BufferEncoding </span><span class="s4">};</span>
        <span class="s4">}</span>
        <span class="s6">// Buffer class</span>
        <span class="s2">type BufferEncoding </span><span class="s4">=</span>
            <span class="s4">| </span><span class="s3">&quot;ascii&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;utf8&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;utf-8&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;utf16le&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;utf-16le&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;ucs2&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;ucs-2&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;base64&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;base64url&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;latin1&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;binary&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;hex&quot;</span><span class="s4">;</span>
        <span class="s2">type WithImplicitCoercion</span><span class="s4">&lt;</span><span class="s2">T</span><span class="s4">&gt; =</span>
            <span class="s4">| </span><span class="s2">T</span>
            <span class="s4">| {</span>
                <span class="s2">valueOf</span><span class="s4">(): </span><span class="s2">T</span><span class="s4">;</span>
            <span class="s4">};</span>
        <span class="s0">/**</span>
         <span class="s0">* Raw data is stored in instances of the Buffer class.</span>
         <span class="s0">* A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.</span>
         <span class="s0">* Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'base64url'|'binary'(deprecated)|'hex'</span>
         <span class="s0">*/</span>
        <span class="s5">interface </span><span class="s2">BufferConstructor </span><span class="s4">{</span>
            <span class="s0">/**</span>
             <span class="s0">* Allocates a new buffer containing the given {str}.</span>
             <span class="s0">*</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">str String to store in buffer.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">encoding encoding to use, optional.  Default is 'utf8'</span>
             <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">since v10.0.0 - Use `Buffer.from(string[, encoding])` instead.</span>
             <span class="s0">*/</span>
            <span class="s5">new</span><span class="s4">(</span><span class="s2">str</span><span class="s4">: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">encoding</span><span class="s4">?: </span><span class="s2">BufferEncoding</span><span class="s4">): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Allocates a new buffer of {size} octets.</span>
             <span class="s0">*</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">size count of octets to allocate.</span>
             <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">since v10.0.0 - Use `Buffer.alloc()` instead (also see `Buffer.allocUnsafe()`).</span>
             <span class="s0">*/</span>
            <span class="s5">new</span><span class="s4">(</span><span class="s2">size</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Allocates a new buffer containing the given {array} of octets.</span>
             <span class="s0">*</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">array The octets to store.</span>
             <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">since v10.0.0 - Use `Buffer.from(array)` instead.</span>
             <span class="s0">*/</span>
            <span class="s5">new</span><span class="s4">(</span><span class="s2">array</span><span class="s4">: </span><span class="s2">Uint8Array</span><span class="s4">): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Produces a Buffer backed by the same allocated memory as</span>
             <span class="s0">* the given {ArrayBuffer}/{SharedArrayBuffer}.</span>
             <span class="s0">*</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">arrayBuffer The ArrayBuffer with which to share memory.</span>
             <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">since v10.0.0 - Use `Buffer.from(arrayBuffer[, byteOffset[, length]])` instead.</span>
             <span class="s0">*/</span>
            <span class="s5">new</span><span class="s4">(</span><span class="s2">arrayBuffer</span><span class="s4">: </span><span class="s2">ArrayBuffer </span><span class="s4">| </span><span class="s2">SharedArrayBuffer</span><span class="s4">): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Allocates a new buffer containing the given {array} of octets.</span>
             <span class="s0">*</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">array The octets to store.</span>
             <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">since v10.0.0 - Use `Buffer.from(array)` instead.</span>
             <span class="s0">*/</span>
            <span class="s5">new</span><span class="s4">(</span><span class="s2">array</span><span class="s4">: </span><span class="s2">ReadonlyArray</span><span class="s4">&lt;</span><span class="s2">any</span><span class="s4">&gt;): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Copies the passed {buffer} data onto a new {Buffer} instance.</span>
             <span class="s0">*</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">buffer The buffer to copy.</span>
             <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">since v10.0.0 - Use `Buffer.from(buffer)` instead.</span>
             <span class="s0">*/</span>
            <span class="s5">new</span><span class="s4">(</span><span class="s2">buffer</span><span class="s4">: </span><span class="s2">Buffer</span><span class="s4">): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Allocates a new `Buffer` using an `array` of bytes in the range `0` – `255`.</span>
             <span class="s0">* Array entries outside that range will be truncated to fit into it.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* // Creates a new Buffer containing the UTF-8 bytes of the string 'buffer'.</span>
             <span class="s0">* const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* If `array` is an `Array`\-like object (that is, one with a `length` property of</span>
             <span class="s0">* type `number`), it is treated as if it is an array, unless it is a `Buffer` or</span>
             <span class="s0">* a `Uint8Array`. This means all other `TypedArray` variants get treated as an`Array`. To create a `Buffer` from the bytes backing a `TypedArray`, use `Buffer.copyBytesFrom()`.</span>
             <span class="s0">*</span>
             <span class="s0">* A `TypeError` will be thrown if `array` is not an `Array` or another type</span>
             <span class="s0">* appropriate for `Buffer.from()` variants.</span>
             <span class="s0">*</span>
             <span class="s0">* `Buffer.from(array)` and `Buffer.from(string)` may also use the internal`Buffer` pool like `Buffer.allocUnsafe()` does.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v5.10.0</span>
             <span class="s0">*/</span>
            <span class="s2">from</span><span class="s4">(</span>
                <span class="s2">arrayBuffer</span><span class="s4">: </span><span class="s2">WithImplicitCoercion</span><span class="s4">&lt;</span><span class="s2">ArrayBuffer </span><span class="s4">| </span><span class="s2">SharedArrayBuffer</span><span class="s4">&gt;,</span>
                <span class="s2">byteOffset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">,</span>
                <span class="s2">length</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">,</span>
            <span class="s4">): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Creates a new Buffer using the passed {data}</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">data data to create a new Buffer</span>
             <span class="s0">*/</span>
            <span class="s2">from</span><span class="s4">(</span><span class="s2">data</span><span class="s4">: </span><span class="s2">Uint8Array </span><span class="s4">| </span><span class="s2">ReadonlyArray</span><span class="s4">&lt;</span><span class="s2">number</span><span class="s4">&gt;): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s2">from</span><span class="s4">(</span><span class="s2">data</span><span class="s4">: </span><span class="s2">WithImplicitCoercion</span><span class="s4">&lt;</span><span class="s2">Uint8Array </span><span class="s4">| </span><span class="s2">ReadonlyArray</span><span class="s4">&lt;</span><span class="s2">number</span><span class="s4">&gt; | </span><span class="s2">string</span><span class="s4">&gt;): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Creates a new Buffer containing the given JavaScript string {str}.</span>
             <span class="s0">* If provided, the {encoding} parameter identifies the character encoding.</span>
             <span class="s0">* If not provided, {encoding} defaults to 'utf8'.</span>
             <span class="s0">*/</span>
            <span class="s2">from</span><span class="s4">(</span>
                <span class="s2">str</span><span class="s4">:</span>
                    <span class="s4">| </span><span class="s2">WithImplicitCoercion</span><span class="s4">&lt;</span><span class="s2">string</span><span class="s4">&gt;</span>
                    <span class="s4">| {</span>
                        <span class="s4">[</span><span class="s2">Symbol</span><span class="s4">.</span><span class="s2">toPrimitive</span><span class="s4">](</span><span class="s2">hint</span><span class="s4">: </span><span class="s3">&quot;string&quot;</span><span class="s4">): </span><span class="s2">string</span><span class="s4">;</span>
                    <span class="s4">},</span>
                <span class="s2">encoding</span><span class="s4">?: </span><span class="s2">BufferEncoding</span><span class="s4">,</span>
            <span class="s4">): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Creates a new Buffer using the passed {data}</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">values to create a new Buffer</span>
             <span class="s0">*/</span>
            <span class="s2">of</span><span class="s4">(</span><span class="s2">...items</span><span class="s4">: </span><span class="s2">number</span><span class="s4">[]): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Returns `true` if `obj` is a `Buffer`, `false` otherwise.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* Buffer.isBuffer(Buffer.alloc(10)); // true</span>
             <span class="s0">* Buffer.isBuffer(Buffer.from('foo')); // true</span>
             <span class="s0">* Buffer.isBuffer('a string'); // false</span>
             <span class="s0">* Buffer.isBuffer([]); // false</span>
             <span class="s0">* Buffer.isBuffer(new Uint8Array(1024)); // false</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.1.101</span>
             <span class="s0">*/</span>
            <span class="s2">isBuffer</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">: </span><span class="s2">any</span><span class="s4">): </span><span class="s2">obj </span><span class="s4">is </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Returns `true` if `encoding` is the name of a supported character encoding,</span>
             <span class="s0">* or `false` otherwise.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(Buffer.isEncoding('utf8'));</span>
             <span class="s0">* // Prints: true</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(Buffer.isEncoding('hex'));</span>
             <span class="s0">* // Prints: true</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(Buffer.isEncoding('utf/8'));</span>
             <span class="s0">* // Prints: false</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(Buffer.isEncoding(''));</span>
             <span class="s0">* // Prints: false</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.9.1</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">encoding A character encoding name to check.</span>
             <span class="s0">*/</span>
            <span class="s2">isEncoding</span><span class="s4">(</span><span class="s2">encoding</span><span class="s4">: </span><span class="s2">string</span><span class="s4">): </span><span class="s2">encoding </span><span class="s4">is </span><span class="s2">BufferEncoding</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Returns the byte length of a string when encoded using `encoding`.</span>
             <span class="s0">* This is not the same as [`String.prototype.length`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length), which does not account</span>
             <span class="s0">* for the encoding that is used to convert the string into bytes.</span>
             <span class="s0">*</span>
             <span class="s0">* For `'base64'`, `'base64url'`, and `'hex'`, this function assumes valid input.</span>
             <span class="s0">* For strings that contain non-base64/hex-encoded data (e.g. whitespace), the</span>
             <span class="s0">* return value might be greater than the length of a `Buffer` created from the</span>
             <span class="s0">* string.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const str = '\u00bd + \u00bc = \u00be';</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(`${str}: ${str.length} characters, ` +</span>
             <span class="s0">*             `${Buffer.byteLength(str, 'utf8')} bytes`);</span>
             <span class="s0">* // Prints: ½ + ¼ = ¾: 9 characters, 12 bytes</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* When `string` is a</span>
             <span class="s0">* `Buffer`/[`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)/[`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/-</span>
             <span class="s0">* Reference/Global_Objects/TypedArray)/[`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)/[`SharedArrayBuffer`](https://develop-</span>
             <span class="s0">* er.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer), the byte length as reported by `.byteLength`is returned.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.1.90</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">string A value to calculate the length of.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[encoding='utf8'] If `string` is a string, this is its encoding.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">The number of bytes contained within `string`.</span>
             <span class="s0">*/</span>
            <span class="s2">byteLength</span><span class="s4">(</span>
                <span class="s2">string</span><span class="s4">: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">NodeJS</span><span class="s4">.</span><span class="s2">ArrayBufferView </span><span class="s4">| </span><span class="s2">ArrayBuffer </span><span class="s4">| </span><span class="s2">SharedArrayBuffer</span><span class="s4">,</span>
                <span class="s2">encoding</span><span class="s4">?: </span><span class="s2">BufferEncoding</span><span class="s4">,</span>
            <span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Returns a new `Buffer` which is the result of concatenating all the `Buffer`instances in the `list` together.</span>
             <span class="s0">*</span>
             <span class="s0">* If the list has no items, or if the `totalLength` is 0, then a new zero-length`Buffer` is returned.</span>
             <span class="s0">*</span>
             <span class="s0">* If `totalLength` is not provided, it is calculated from the `Buffer` instances</span>
             <span class="s0">* in `list` by adding their lengths.</span>
             <span class="s0">*</span>
             <span class="s0">* If `totalLength` is provided, it is coerced to an unsigned integer. If the</span>
             <span class="s0">* combined length of the `Buffer`s in `list` exceeds `totalLength`, the result is</span>
             <span class="s0">* truncated to `totalLength`.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* // Create a single `Buffer` from a list of three `Buffer` instances.</span>
             <span class="s0">*</span>
             <span class="s0">* const buf1 = Buffer.alloc(10);</span>
             <span class="s0">* const buf2 = Buffer.alloc(14);</span>
             <span class="s0">* const buf3 = Buffer.alloc(18);</span>
             <span class="s0">* const totalLength = buf1.length + buf2.length + buf3.length;</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(totalLength);</span>
             <span class="s0">* // Prints: 42</span>
             <span class="s0">*</span>
             <span class="s0">* const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(bufA);</span>
             <span class="s0">* // Prints: &lt;Buffer 00 00 00 00 ...&gt;</span>
             <span class="s0">* console.log(bufA.length);</span>
             <span class="s0">* // Prints: 42</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* `Buffer.concat()` may also use the internal `Buffer` pool like `Buffer.allocUnsafe()` does.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.7.11</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">list List of `Buffer` or {</span><span class="s1">@link </span><span class="s0">Uint8Array} instances to concatenate.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">totalLength Total length of the `Buffer` instances in `list` when concatenated.</span>
             <span class="s0">*/</span>
            <span class="s2">concat</span><span class="s4">(</span><span class="s2">list</span><span class="s4">: </span><span class="s2">ReadonlyArray</span><span class="s4">&lt;</span><span class="s2">Uint8Array</span><span class="s4">&gt;, </span><span class="s2">totalLength</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Copies the underlying memory of `view` into a new `Buffer`.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* const u16 = new Uint16Array([0, 0xffff]);</span>
             <span class="s0">* const buf = Buffer.copyBytesFrom(u16, 1, 1);</span>
             <span class="s0">* u16[1] = 0;</span>
             <span class="s0">* console.log(buf.length); // 2</span>
             <span class="s0">* console.log(buf[0]); // 255</span>
             <span class="s0">* console.log(buf[1]); // 255</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.8.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">view The {TypedArray} to copy.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=': 0'] The starting offset within `view`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[length=view.length - offset] The number of elements from `view` to copy.</span>
             <span class="s0">*/</span>
            <span class="s2">copyBytesFrom</span><span class="s4">(</span><span class="s2">view</span><span class="s4">: </span><span class="s2">NodeJS</span><span class="s4">.</span><span class="s2">TypedArray</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">length</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Compares `buf1` to `buf2`, typically for the purpose of sorting arrays of`Buffer` instances. This is equivalent to calling `buf1.compare(buf2)`.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf1 = Buffer.from('1234');</span>
             <span class="s0">* const buf2 = Buffer.from('0123');</span>
             <span class="s0">* const arr = [buf1, buf2];</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(arr.sort(Buffer.compare));</span>
             <span class="s0">* // Prints: [ &lt;Buffer 30 31 32 33&gt;, &lt;Buffer 31 32 33 34&gt; ]</span>
             <span class="s0">* // (This result is equal to: [buf2, buf1].)</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.13</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">Either `-1`, `0`, or `1`, depending on the result of the comparison. See `compare` for details.</span>
             <span class="s0">*/</span>
            <span class="s2">compare</span><span class="s4">(</span><span class="s2">buf1</span><span class="s4">: </span><span class="s2">Uint8Array</span><span class="s4">, </span><span class="s2">buf2</span><span class="s4">: </span><span class="s2">Uint8Array</span><span class="s4">): -</span><span class="s7">1 </span><span class="s4">| </span><span class="s7">0 </span><span class="s4">| </span><span class="s7">1</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Allocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the`Buffer` will be zero-filled.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.alloc(5);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer 00 00 00 00 00&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* If `size` is larger than {</span><span class="s1">@link </span><span class="s0">constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown.</span>
             <span class="s0">*</span>
             <span class="s0">* If `fill` is specified, the allocated `Buffer` will be initialized by calling `buf.fill(fill)`.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.alloc(5, 'a');</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer 61 61 61 61 61&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* If both `fill` and `encoding` are specified, the allocated `Buffer` will be</span>
             <span class="s0">* initialized by calling `buf.fill(fill, encoding)`.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* Calling `Buffer.alloc()` can be measurably slower than the alternative `Buffer.allocUnsafe()` but ensures that the newly created `Buffer` instance</span>
             <span class="s0">* contents will never contain sensitive data from previous allocations, including</span>
             <span class="s0">* data that might not have been allocated for `Buffer`s.</span>
             <span class="s0">*</span>
             <span class="s0">* A `TypeError` will be thrown if `size` is not a number.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v5.10.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">size The desired length of the new `Buffer`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[fill=0] A value to pre-fill the new `Buffer` with.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[encoding='utf8'] If `fill` is a string, this is its encoding.</span>
             <span class="s0">*/</span>
            <span class="s2">alloc</span><span class="s4">(</span><span class="s2">size</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">fill</span><span class="s4">?: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">Uint8Array </span><span class="s4">| </span><span class="s2">number</span><span class="s4">, </span><span class="s2">encoding</span><span class="s4">?: </span><span class="s2">BufferEncoding</span><span class="s4">): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Allocates a new `Buffer` of `size` bytes. If `size` is larger than {</span><span class="s1">@link </span><span class="s0">constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown.</span>
             <span class="s0">*</span>
             <span class="s0">* The underlying memory for `Buffer` instances created in this way is _not_</span>
             <span class="s0">* _initialized_. The contents of the newly created `Buffer` are unknown and _may contain sensitive data_. Use `Buffer.alloc()` instead to initialize`Buffer` instances with zeroes.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(10);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints (contents may vary): &lt;Buffer a0 8b 28 3f 01 00 00 00 50 32&gt;</span>
             <span class="s0">*</span>
             <span class="s0">* buf.fill(0);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* A `TypeError` will be thrown if `size` is not a number.</span>
             <span class="s0">*</span>
             <span class="s0">* The `Buffer` module pre-allocates an internal `Buffer` instance of</span>
             <span class="s0">* size `Buffer.poolSize` that is used as a pool for the fast allocation of new`Buffer` instances created using `Buffer.allocUnsafe()`, `Buffer.from(array)`,</span>
             <span class="s0">* and `Buffer.concat()` only when `size` is less than or equal to`Buffer.poolSize &gt;&gt; 1` (floor of `Buffer.poolSize` divided by two).</span>
             <span class="s0">*</span>
             <span class="s0">* Use of this pre-allocated internal memory pool is a key difference between</span>
             <span class="s0">* calling `Buffer.alloc(size, fill)` vs. `Buffer.allocUnsafe(size).fill(fill)`.</span>
             <span class="s0">* Specifically, `Buffer.alloc(size, fill)` will _never_ use the internal `Buffer`pool, while `Buffer.allocUnsafe(size).fill(fill)`_will_ use the internal`Buffer` pool if `size` is less</span>
             <span class="s0">* than or equal to half `Buffer.poolSize`. The</span>
             <span class="s0">* difference is subtle but can be important when an application requires the</span>
             <span class="s0">* additional performance that `Buffer.allocUnsafe()` provides.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v5.10.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">size The desired length of the new `Buffer`.</span>
             <span class="s0">*/</span>
            <span class="s2">allocUnsafe</span><span class="s4">(</span><span class="s2">size</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Allocates a new `Buffer` of `size` bytes. If `size` is larger than {</span><span class="s1">@link </span><span class="s0">constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown. A zero-length `Buffer` is created if</span>
             <span class="s0">* `size` is 0.</span>
             <span class="s0">*</span>
             <span class="s0">* The underlying memory for `Buffer` instances created in this way is _not_</span>
             <span class="s0">* _initialized_. The contents of the newly created `Buffer` are unknown and _may contain sensitive data_. Use `buf.fill(0)` to initialize</span>
             <span class="s0">* such `Buffer` instances with zeroes.</span>
             <span class="s0">*</span>
             <span class="s0">* When using `Buffer.allocUnsafe()` to allocate new `Buffer` instances,</span>
             <span class="s0">* allocations under 4 KiB are sliced from a single pre-allocated `Buffer`. This</span>
             <span class="s0">* allows applications to avoid the garbage collection overhead of creating many</span>
             <span class="s0">* individually allocated `Buffer` instances. This approach improves both</span>
             <span class="s0">* performance and memory usage by eliminating the need to track and clean up as</span>
             <span class="s0">* many individual `ArrayBuffer` objects.</span>
             <span class="s0">*</span>
             <span class="s0">* However, in the case where a developer may need to retain a small chunk of</span>
             <span class="s0">* memory from a pool for an indeterminate amount of time, it may be appropriate</span>
             <span class="s0">* to create an un-pooled `Buffer` instance using `Buffer.allocUnsafeSlow()` and</span>
             <span class="s0">* then copying out the relevant bits.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* // Need to keep around a few small chunks of memory.</span>
             <span class="s0">* const store = [];</span>
             <span class="s0">*</span>
             <span class="s0">* socket.on('readable', () =&gt; {</span>
             <span class="s0">*   let data;</span>
             <span class="s0">*   while (null !== (data = readable.read())) {</span>
             <span class="s0">*     // Allocate for retained data.</span>
             <span class="s0">*     const sb = Buffer.allocUnsafeSlow(10);</span>
             <span class="s0">*</span>
             <span class="s0">*     // Copy the data into the new allocation.</span>
             <span class="s0">*     data.copy(sb, 0, 0, 10);</span>
             <span class="s0">*</span>
             <span class="s0">*     store.push(sb);</span>
             <span class="s0">*   }</span>
             <span class="s0">* });</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* A `TypeError` will be thrown if `size` is not a number.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v5.12.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">size The desired length of the new `Buffer`.</span>
             <span class="s0">*/</span>
            <span class="s2">allocUnsafeSlow</span><span class="s4">(</span><span class="s2">size</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* This is the size (in bytes) of pre-allocated internal `Buffer` instances used</span>
             <span class="s0">* for pooling. This value may be modified.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.3</span>
             <span class="s0">*/</span>
            <span class="s2">poolSize</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s4">}</span>
        <span class="s5">interface </span><span class="s2">Buffer </span><span class="s5">extends </span><span class="s2">Uint8Array </span><span class="s4">{</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `string` to `buf` at `offset` according to the character encoding in`encoding`. The `length` parameter is the number of bytes to write. If `buf` did</span>
             <span class="s0">* not contain enough space to fit the entire string, only part of `string` will be</span>
             <span class="s0">* written. However, partially encoded characters will not be written.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.alloc(256);</span>
             <span class="s0">*</span>
             <span class="s0">* const len = buf.write('\u00bd + \u00bc = \u00be', 0);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);</span>
             <span class="s0">* // Prints: 12 bytes: ½ + ¼ = ¾</span>
             <span class="s0">*</span>
             <span class="s0">* const buffer = Buffer.alloc(10);</span>
             <span class="s0">*</span>
             <span class="s0">* const length = buffer.write('abcd', 8);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(`${length} bytes: ${buffer.toString('utf8', 8, 10)}`);</span>
             <span class="s0">* // Prints: 2 bytes : ab</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.1.90</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">string String to write to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write `string`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[length=buf.length - offset] Maximum number of bytes to write (written bytes will not exceed `buf.length - offset`).</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[encoding='utf8'] The character encoding of `string`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">Number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">write</span><span class="s4">(</span><span class="s2">string</span><span class="s4">: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">encoding</span><span class="s4">?: </span><span class="s2">BufferEncoding</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s2">write</span><span class="s4">(</span><span class="s2">string</span><span class="s4">: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">encoding</span><span class="s4">?: </span><span class="s2">BufferEncoding</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s2">write</span><span class="s4">(</span><span class="s2">string</span><span class="s4">: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">length</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">encoding</span><span class="s4">?: </span><span class="s2">BufferEncoding</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Decodes `buf` to a string according to the specified character encoding in`encoding`. `start` and `end` may be passed to decode only a subset of `buf`.</span>
             <span class="s0">*</span>
             <span class="s0">* If `encoding` is `'utf8'` and a byte sequence in the input is not valid UTF-8,</span>
             <span class="s0">* then each invalid byte is replaced with the replacement character `U+FFFD`.</span>
             <span class="s0">*</span>
             <span class="s0">* The maximum length of a string instance (in UTF-16 code units) is available</span>
             <span class="s0">* as {</span><span class="s1">@link </span><span class="s0">constants.MAX_STRING_LENGTH}.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf1 = Buffer.allocUnsafe(26);</span>
             <span class="s0">*</span>
             <span class="s0">* for (let i = 0; i &lt; 26; i++) {</span>
             <span class="s0">*   // 97 is the decimal ASCII value for 'a'.</span>
             <span class="s0">*   buf1[i] = i + 97;</span>
             <span class="s0">* }</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf1.toString('utf8'));</span>
             <span class="s0">* // Prints: abcdefghijklmnopqrstuvwxyz</span>
             <span class="s0">* console.log(buf1.toString('utf8', 0, 5));</span>
             <span class="s0">* // Prints: abcde</span>
             <span class="s0">*</span>
             <span class="s0">* const buf2 = Buffer.from('tést');</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf2.toString('hex'));</span>
             <span class="s0">* // Prints: 74c3a97374</span>
             <span class="s0">* console.log(buf2.toString('utf8', 0, 3));</span>
             <span class="s0">* // Prints: té</span>
             <span class="s0">* console.log(buf2.toString(undefined, 0, 3));</span>
             <span class="s0">* // Prints: té</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.1.90</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[encoding='utf8'] The character encoding to use.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[start=0] The byte offset to start decoding at.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[end=buf.length] The byte offset to stop decoding at (not inclusive).</span>
             <span class="s0">*/</span>
            <span class="s2">toString</span><span class="s4">(</span><span class="s2">encoding</span><span class="s4">?: </span><span class="s2">BufferEncoding</span><span class="s4">, </span><span class="s2">start</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">end</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">string</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Returns a JSON representation of `buf`. [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) implicitly calls</span>
             <span class="s0">* this function when stringifying a `Buffer` instance.</span>
             <span class="s0">*</span>
             <span class="s0">* `Buffer.from()` accepts objects in the format returned from this method.</span>
             <span class="s0">* In particular, `Buffer.from(buf.toJSON())` works like `Buffer.from(buf)`.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);</span>
             <span class="s0">* const json = JSON.stringify(buf);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(json);</span>
             <span class="s0">* // Prints: {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}</span>
             <span class="s0">*</span>
             <span class="s0">* const copy = JSON.parse(json, (key, value) =&gt; {</span>
             <span class="s0">*   return value &amp;#x26;&amp;#x26; value.type === 'Buffer' ?</span>
             <span class="s0">*     Buffer.from(value) :</span>
             <span class="s0">*     value;</span>
             <span class="s0">* });</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(copy);</span>
             <span class="s0">* // Prints: &lt;Buffer 01 02 03 04 05&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.9.2</span>
             <span class="s0">*/</span>
            <span class="s2">toJSON</span><span class="s4">(): {</span>
                <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;Buffer&quot;</span><span class="s4">;</span>
                <span class="s2">data</span><span class="s4">: </span><span class="s2">number</span><span class="s4">[];</span>
            <span class="s4">};</span>
            <span class="s0">/**</span>
             <span class="s0">* Returns `true` if both `buf` and `otherBuffer` have exactly the same bytes,`false` otherwise. Equivalent to `buf.compare(otherBuffer) === 0`.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf1 = Buffer.from('ABC');</span>
             <span class="s0">* const buf2 = Buffer.from('414243', 'hex');</span>
             <span class="s0">* const buf3 = Buffer.from('ABCD');</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf1.equals(buf2));</span>
             <span class="s0">* // Prints: true</span>
             <span class="s0">* console.log(buf1.equals(buf3));</span>
             <span class="s0">* // Prints: false</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.13</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">otherBuffer A `Buffer` or {</span><span class="s1">@link </span><span class="s0">Uint8Array} with which to compare `buf`.</span>
             <span class="s0">*/</span>
            <span class="s2">equals</span><span class="s4">(</span><span class="s2">otherBuffer</span><span class="s4">: </span><span class="s2">Uint8Array</span><span class="s4">): </span><span class="s2">boolean</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Compares `buf` with `target` and returns a number indicating whether `buf`comes before, after, or is the same as `target` in sort order.</span>
             <span class="s0">* Comparison is based on the actual sequence of bytes in each `Buffer`.</span>
             <span class="s0">*</span>
             <span class="s0">* * `0` is returned if `target` is the same as `buf`</span>
             <span class="s0">* * `1` is returned if `target` should come _before_`buf` when sorted.</span>
             <span class="s0">* * `-1` is returned if `target` should come _after_`buf` when sorted.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf1 = Buffer.from('ABC');</span>
             <span class="s0">* const buf2 = Buffer.from('BCD');</span>
             <span class="s0">* const buf3 = Buffer.from('ABCD');</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf1.compare(buf1));</span>
             <span class="s0">* // Prints: 0</span>
             <span class="s0">* console.log(buf1.compare(buf2));</span>
             <span class="s0">* // Prints: -1</span>
             <span class="s0">* console.log(buf1.compare(buf3));</span>
             <span class="s0">* // Prints: -1</span>
             <span class="s0">* console.log(buf2.compare(buf1));</span>
             <span class="s0">* // Prints: 1</span>
             <span class="s0">* console.log(buf2.compare(buf3));</span>
             <span class="s0">* // Prints: 1</span>
             <span class="s0">* console.log([buf1, buf2, buf3].sort(Buffer.compare));</span>
             <span class="s0">* // Prints: [ &lt;Buffer 41 42 43&gt;, &lt;Buffer 41 42 43 44&gt;, &lt;Buffer 42 43 44&gt; ]</span>
             <span class="s0">* // (This result is equal to: [buf1, buf3, buf2].)</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* The optional `targetStart`, `targetEnd`, `sourceStart`, and `sourceEnd`arguments can be used to limit the comparison to specific ranges within `target`and `buf` respectively.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);</span>
             <span class="s0">* const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf1.compare(buf2, 5, 9, 0, 4));</span>
             <span class="s0">* // Prints: 0</span>
             <span class="s0">* console.log(buf1.compare(buf2, 0, 6, 4));</span>
             <span class="s0">* // Prints: -1</span>
             <span class="s0">* console.log(buf1.compare(buf2, 5, 6, 5));</span>
             <span class="s0">* // Prints: 1</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* `ERR_OUT_OF_RANGE` is thrown if `targetStart &lt; 0`, `sourceStart &lt; 0`,`targetEnd &gt; target.byteLength`, or `sourceEnd &gt; source.byteLength`.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.13</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">target A `Buffer` or {</span><span class="s1">@link </span><span class="s0">Uint8Array} with which to compare `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[targetStart=0] The offset within `target` at which to begin comparison.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[targetEnd=target.length] The offset within `target` at which to end comparison (not inclusive).</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[sourceStart=0] The offset within `buf` at which to begin comparison.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[sourceEnd=buf.length] The offset within `buf` at which to end comparison (not inclusive).</span>
             <span class="s0">*/</span>
            <span class="s2">compare</span><span class="s4">(</span>
                <span class="s2">target</span><span class="s4">: </span><span class="s2">Uint8Array</span><span class="s4">,</span>
                <span class="s2">targetStart</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">,</span>
                <span class="s2">targetEnd</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">,</span>
                <span class="s2">sourceStart</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">,</span>
                <span class="s2">sourceEnd</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">,</span>
            <span class="s4">): -</span><span class="s7">1 </span><span class="s4">| </span><span class="s7">0 </span><span class="s4">| </span><span class="s7">1</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Copies data from a region of `buf` to a region in `target`, even if the `target`memory region overlaps with `buf`.</span>
             <span class="s0">*</span>
             <span class="s0">* [`TypedArray.prototype.set()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set) performs the same operation, and is available</span>
             <span class="s0">* for all TypedArrays, including Node.js `Buffer`s, although it takes</span>
             <span class="s0">* different function arguments.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* // Create two `Buffer` instances.</span>
             <span class="s0">* const buf1 = Buffer.allocUnsafe(26);</span>
             <span class="s0">* const buf2 = Buffer.allocUnsafe(26).fill('!');</span>
             <span class="s0">*</span>
             <span class="s0">* for (let i = 0; i &lt; 26; i++) {</span>
             <span class="s0">*   // 97 is the decimal ASCII value for 'a'.</span>
             <span class="s0">*   buf1[i] = i + 97;</span>
             <span class="s0">* }</span>
             <span class="s0">*</span>
             <span class="s0">* // Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`.</span>
             <span class="s0">* buf1.copy(buf2, 8, 16, 20);</span>
             <span class="s0">* // This is equivalent to:</span>
             <span class="s0">* // buf2.set(buf1.subarray(16, 20), 8);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf2.toString('ascii', 0, 25));</span>
             <span class="s0">* // Prints: !!!!!!!!qrst!!!!!!!!!!!!!</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* // Create a `Buffer` and copy data from one region to an overlapping region</span>
             <span class="s0">* // within the same `Buffer`.</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(26);</span>
             <span class="s0">*</span>
             <span class="s0">* for (let i = 0; i &lt; 26; i++) {</span>
             <span class="s0">*   // 97 is the decimal ASCII value for 'a'.</span>
             <span class="s0">*   buf[i] = i + 97;</span>
             <span class="s0">* }</span>
             <span class="s0">*</span>
             <span class="s0">* buf.copy(buf, 0, 4, 10);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.toString());</span>
             <span class="s0">* // Prints: efghijghijklmnopqrstuvwxyz</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.1.90</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">target A `Buffer` or {</span><span class="s1">@link </span><span class="s0">Uint8Array} to copy into.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[targetStart=0] The offset within `target` at which to begin writing.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[sourceStart=0] The offset within `buf` from which to begin copying.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[sourceEnd=buf.length] The offset within `buf` at which to stop copying (not inclusive).</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">The number of bytes copied.</span>
             <span class="s0">*/</span>
            <span class="s2">copy</span><span class="s4">(</span><span class="s2">target</span><span class="s4">: </span><span class="s2">Uint8Array</span><span class="s4">, </span><span class="s2">targetStart</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">sourceStart</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">sourceEnd</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Returns a new `Buffer` that references the same memory as the original, but</span>
             <span class="s0">* offset and cropped by the `start` and `end` indices.</span>
             <span class="s0">*</span>
             <span class="s0">* This method is not compatible with the `Uint8Array.prototype.slice()`,</span>
             <span class="s0">* which is a superclass of `Buffer`. To copy the slice, use`Uint8Array.prototype.slice()`.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from('buffer');</span>
             <span class="s0">*</span>
             <span class="s0">* const copiedBuf = Uint8Array.prototype.slice.call(buf);</span>
             <span class="s0">* copiedBuf[0]++;</span>
             <span class="s0">* console.log(copiedBuf.toString());</span>
             <span class="s0">* // Prints: cuffer</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.toString());</span>
             <span class="s0">* // Prints: buffer</span>
             <span class="s0">*</span>
             <span class="s0">* // With buf.slice(), the original buffer is modified.</span>
             <span class="s0">* const notReallyCopiedBuf = buf.slice();</span>
             <span class="s0">* notReallyCopiedBuf[0]++;</span>
             <span class="s0">* console.log(notReallyCopiedBuf.toString());</span>
             <span class="s0">* // Prints: cuffer</span>
             <span class="s0">* console.log(buf.toString());</span>
             <span class="s0">* // Also prints: cuffer (!)</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.3.0</span>
             <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">Use `subarray` instead.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[start=0] Where the new `Buffer` will start.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[end=buf.length] Where the new `Buffer` will end (not inclusive).</span>
             <span class="s0">*/</span>
            <span class="s2">slice</span><span class="s4">(</span><span class="s2">start</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">end</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Returns a new `Buffer` that references the same memory as the original, but</span>
             <span class="s0">* offset and cropped by the `start` and `end` indices.</span>
             <span class="s0">*</span>
             <span class="s0">* Specifying `end` greater than `buf.length` will return the same result as</span>
             <span class="s0">* that of `end` equal to `buf.length`.</span>
             <span class="s0">*</span>
             <span class="s0">* This method is inherited from [`TypedArray.prototype.subarray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray).</span>
             <span class="s0">*</span>
             <span class="s0">* Modifying the new `Buffer` slice will modify the memory in the original `Buffer`because the allocated memory of the two objects overlap.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* // Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte</span>
             <span class="s0">* // from the original `Buffer`.</span>
             <span class="s0">*</span>
             <span class="s0">* const buf1 = Buffer.allocUnsafe(26);</span>
             <span class="s0">*</span>
             <span class="s0">* for (let i = 0; i &lt; 26; i++) {</span>
             <span class="s0">*   // 97 is the decimal ASCII value for 'a'.</span>
             <span class="s0">*   buf1[i] = i + 97;</span>
             <span class="s0">* }</span>
             <span class="s0">*</span>
             <span class="s0">* const buf2 = buf1.subarray(0, 3);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf2.toString('ascii', 0, buf2.length));</span>
             <span class="s0">* // Prints: abc</span>
             <span class="s0">*</span>
             <span class="s0">* buf1[0] = 33;</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf2.toString('ascii', 0, buf2.length));</span>
             <span class="s0">* // Prints: !bc</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* Specifying negative indexes causes the slice to be generated relative to the</span>
             <span class="s0">* end of `buf` rather than the beginning.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from('buffer');</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.subarray(-6, -1).toString());</span>
             <span class="s0">* // Prints: buffe</span>
             <span class="s0">* // (Equivalent to buf.subarray(0, 5).)</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.subarray(-6, -2).toString());</span>
             <span class="s0">* // Prints: buff</span>
             <span class="s0">* // (Equivalent to buf.subarray(0, 4).)</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.subarray(-5, -2).toString());</span>
             <span class="s0">* // Prints: uff</span>
             <span class="s0">* // (Equivalent to buf.subarray(1, 4).)</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v3.0.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[start=0] Where the new `Buffer` will start.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[end=buf.length] Where the new `Buffer` will end (not inclusive).</span>
             <span class="s0">*/</span>
            <span class="s2">subarray</span><span class="s4">(</span><span class="s2">start</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">end</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as big-endian.</span>
             <span class="s0">*</span>
             <span class="s0">* `value` is interpreted and written as a two's complement signed integer.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(8);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeBigInt64BE(0x0102030405060708n, 0);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v12.0.0, v10.20.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeBigInt64BE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">bigint</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as little-endian.</span>
             <span class="s0">*</span>
             <span class="s0">* `value` is interpreted and written as a two's complement signed integer.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(8);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeBigInt64LE(0x0102030405060708n, 0);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer 08 07 06 05 04 03 02 01&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v12.0.0, v10.20.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeBigInt64LE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">bigint</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as big-endian.</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `writeBigUint64BE` alias.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(8);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeBigUInt64BE(0xdecafafecacefaden, 0);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer de ca fa fe ca ce fa de&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v12.0.0, v10.20.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeBigUInt64BE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">bigint</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.writeBigUInt64BE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.10.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">writeBigUint64BE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">bigint</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as little-endian</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(8);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeBigUInt64LE(0xdecafafecacefaden, 0);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer de fa ce ca fe fa ca de&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `writeBigUint64LE` alias.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v12.0.0, v10.20.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeBigUInt64LE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">bigint</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.writeBigUInt64LE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.10.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">writeBigUint64LE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">bigint</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined</span>
             <span class="s0">* when `value` is anything other than an unsigned integer.</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `writeUintLE` alias.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(6);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeUIntLE(0x1234567890ab, 0, 6);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer ab 90 78 56 34 12&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">offset Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">byteLength Number of bytes to write. Must satisfy `0 &lt; byteLength &lt;= 6`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeUIntLE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">byteLength</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.writeUIntLE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">writeUintLE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">byteLength</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined</span>
             <span class="s0">* when `value` is anything other than an unsigned integer.</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `writeUintBE` alias.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(6);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeUIntBE(0x1234567890ab, 0, 6);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer 12 34 56 78 90 ab&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">offset Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">byteLength Number of bytes to write. Must satisfy `0 &lt; byteLength &lt;= 6`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeUIntBE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">byteLength</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.writeUIntBE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">writeUintBE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">byteLength</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined</span>
             <span class="s0">* when `value` is anything other than a signed integer.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(6);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeIntLE(0x1234567890ab, 0, 6);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer ab 90 78 56 34 12&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.15</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">offset Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">byteLength Number of bytes to write. Must satisfy `0 &lt; byteLength &lt;= 6`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeIntLE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">byteLength</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined when`value` is anything other than a</span>
             <span class="s0">* signed integer.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(6);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeIntBE(0x1234567890ab, 0, 6);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer 12 34 56 78 90 ab&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.15</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">offset Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">byteLength Number of bytes to write. Must satisfy `0 &lt; byteLength &lt;= 6`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeIntBE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">byteLength</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads an unsigned, big-endian 64-bit integer from `buf` at the specified`offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `readBigUint64BE` alias.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readBigUInt64BE(0));</span>
             <span class="s0">* // Prints: 4294967295n</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v12.0.0, v10.20.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`.</span>
             <span class="s0">*/</span>
            <span class="s2">readBigUInt64BE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">bigint</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.readBigUInt64BE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.10.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">readBigUint64BE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">bigint</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads an unsigned, little-endian 64-bit integer from `buf` at the specified`offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `readBigUint64LE` alias.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readBigUInt64LE(0));</span>
             <span class="s0">* // Prints: 18446744069414584320n</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v12.0.0, v10.20.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`.</span>
             <span class="s0">*/</span>
            <span class="s2">readBigUInt64LE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">bigint</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.readBigUInt64LE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.10.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">readBigUint64LE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">bigint</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a signed, big-endian 64-bit integer from `buf` at the specified `offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* Integers read from a `Buffer` are interpreted as two's complement signed</span>
             <span class="s0">* values.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v12.0.0, v10.20.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`.</span>
             <span class="s0">*/</span>
            <span class="s2">readBigInt64BE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">bigint</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a signed, little-endian 64-bit integer from `buf` at the specified`offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* Integers read from a `Buffer` are interpreted as two's complement signed</span>
             <span class="s0">* values.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v12.0.0, v10.20.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`.</span>
             <span class="s0">*/</span>
            <span class="s2">readBigInt64LE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">bigint</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as an unsigned, little-endian integer supporting</span>
             <span class="s0">* up to 48 bits of accuracy.</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `readUintLE` alias.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readUIntLE(0, 6).toString(16));</span>
             <span class="s0">* // Prints: ab9078563412</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.15</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">offset Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">byteLength Number of bytes to read. Must satisfy `0 &lt; byteLength &lt;= 6`.</span>
             <span class="s0">*/</span>
            <span class="s2">readUIntLE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">byteLength</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.readUIntLE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">readUintLE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">byteLength</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as an unsigned big-endian integer supporting</span>
             <span class="s0">* up to 48 bits of accuracy.</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `readUintBE` alias.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readUIntBE(0, 6).toString(16));</span>
             <span class="s0">* // Prints: 1234567890ab</span>
             <span class="s0">* console.log(buf.readUIntBE(1, 6).toString(16));</span>
             <span class="s0">* // Throws ERR_OUT_OF_RANGE.</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.15</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">offset Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">byteLength Number of bytes to read. Must satisfy `0 &lt; byteLength &lt;= 6`.</span>
             <span class="s0">*/</span>
            <span class="s2">readUIntBE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">byteLength</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.readUIntBE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">readUintBE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">byteLength</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as a little-endian, two's complement signed value</span>
             <span class="s0">* supporting up to 48 bits of accuracy.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readIntLE(0, 6).toString(16));</span>
             <span class="s0">* // Prints: -546f87a9cbee</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.15</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">offset Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">byteLength Number of bytes to read. Must satisfy `0 &lt; byteLength &lt;= 6`.</span>
             <span class="s0">*/</span>
            <span class="s2">readIntLE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">byteLength</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as a big-endian, two's complement signed value</span>
             <span class="s0">* supporting up to 48 bits of accuracy.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readIntBE(0, 6).toString(16));</span>
             <span class="s0">* // Prints: 1234567890ab</span>
             <span class="s0">* console.log(buf.readIntBE(1, 6).toString(16));</span>
             <span class="s0">* // Throws ERR_OUT_OF_RANGE.</span>
             <span class="s0">* console.log(buf.readIntBE(1, 0).toString(16));</span>
             <span class="s0">* // Throws ERR_OUT_OF_RANGE.</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.15</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">offset Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">byteLength Number of bytes to read. Must satisfy `0 &lt; byteLength &lt;= 6`.</span>
             <span class="s0">*/</span>
            <span class="s2">readIntBE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">byteLength</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads an unsigned 8-bit integer from `buf` at the specified `offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `readUint8` alias.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([1, -2]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readUInt8(0));</span>
             <span class="s0">* // Prints: 1</span>
             <span class="s0">* console.log(buf.readUInt8(1));</span>
             <span class="s0">* // Prints: 254</span>
             <span class="s0">* console.log(buf.readUInt8(2));</span>
             <span class="s0">* // Throws ERR_OUT_OF_RANGE.</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 1`.</span>
             <span class="s0">*/</span>
            <span class="s2">readUInt8</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.readUInt8</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">readUint8</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads an unsigned, little-endian 16-bit integer from `buf` at the specified`offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `readUint16LE` alias.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([0x12, 0x34, 0x56]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readUInt16LE(0).toString(16));</span>
             <span class="s0">* // Prints: 3412</span>
             <span class="s0">* console.log(buf.readUInt16LE(1).toString(16));</span>
             <span class="s0">* // Prints: 5634</span>
             <span class="s0">* console.log(buf.readUInt16LE(2).toString(16));</span>
             <span class="s0">* // Throws ERR_OUT_OF_RANGE.</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`.</span>
             <span class="s0">*/</span>
            <span class="s2">readUInt16LE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.readUInt16LE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">readUint16LE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads an unsigned, big-endian 16-bit integer from `buf` at the specified`offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `readUint16BE` alias.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([0x12, 0x34, 0x56]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readUInt16BE(0).toString(16));</span>
             <span class="s0">* // Prints: 1234</span>
             <span class="s0">* console.log(buf.readUInt16BE(1).toString(16));</span>
             <span class="s0">* // Prints: 3456</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`.</span>
             <span class="s0">*/</span>
            <span class="s2">readUInt16BE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.readUInt16BE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">readUint16BE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads an unsigned, little-endian 32-bit integer from `buf` at the specified`offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `readUint32LE` alias.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readUInt32LE(0).toString(16));</span>
             <span class="s0">* // Prints: 78563412</span>
             <span class="s0">* console.log(buf.readUInt32LE(1).toString(16));</span>
             <span class="s0">* // Throws ERR_OUT_OF_RANGE.</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.</span>
             <span class="s0">*/</span>
            <span class="s2">readUInt32LE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.readUInt32LE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">readUint32LE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads an unsigned, big-endian 32-bit integer from `buf` at the specified`offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `readUint32BE` alias.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readUInt32BE(0).toString(16));</span>
             <span class="s0">* // Prints: 12345678</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.</span>
             <span class="s0">*/</span>
            <span class="s2">readUInt32BE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.readUInt32BE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">readUint32BE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a signed 8-bit integer from `buf` at the specified `offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* Integers read from a `Buffer` are interpreted as two's complement signed values.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([-1, 5]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readInt8(0));</span>
             <span class="s0">* // Prints: -1</span>
             <span class="s0">* console.log(buf.readInt8(1));</span>
             <span class="s0">* // Prints: 5</span>
             <span class="s0">* console.log(buf.readInt8(2));</span>
             <span class="s0">* // Throws ERR_OUT_OF_RANGE.</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 1`.</span>
             <span class="s0">*/</span>
            <span class="s2">readInt8</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a signed, little-endian 16-bit integer from `buf` at the specified`offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* Integers read from a `Buffer` are interpreted as two's complement signed values.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([0, 5]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readInt16LE(0));</span>
             <span class="s0">* // Prints: 1280</span>
             <span class="s0">* console.log(buf.readInt16LE(1));</span>
             <span class="s0">* // Throws ERR_OUT_OF_RANGE.</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`.</span>
             <span class="s0">*/</span>
            <span class="s2">readInt16LE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a signed, big-endian 16-bit integer from `buf` at the specified `offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* Integers read from a `Buffer` are interpreted as two's complement signed values.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([0, 5]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readInt16BE(0));</span>
             <span class="s0">* // Prints: 5</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`.</span>
             <span class="s0">*/</span>
            <span class="s2">readInt16BE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a signed, little-endian 32-bit integer from `buf` at the specified`offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* Integers read from a `Buffer` are interpreted as two's complement signed values.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([0, 0, 0, 5]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readInt32LE(0));</span>
             <span class="s0">* // Prints: 83886080</span>
             <span class="s0">* console.log(buf.readInt32LE(1));</span>
             <span class="s0">* // Throws ERR_OUT_OF_RANGE.</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.</span>
             <span class="s0">*/</span>
            <span class="s2">readInt32LE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a signed, big-endian 32-bit integer from `buf` at the specified `offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* Integers read from a `Buffer` are interpreted as two's complement signed values.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([0, 0, 0, 5]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readInt32BE(0));</span>
             <span class="s0">* // Prints: 5</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.</span>
             <span class="s0">*/</span>
            <span class="s2">readInt32BE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a 32-bit, little-endian float from `buf` at the specified `offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([1, 2, 3, 4]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readFloatLE(0));</span>
             <span class="s0">* // Prints: 1.539989614439558e-36</span>
             <span class="s0">* console.log(buf.readFloatLE(1));</span>
             <span class="s0">* // Throws ERR_OUT_OF_RANGE.</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.15</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.</span>
             <span class="s0">*/</span>
            <span class="s2">readFloatLE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a 32-bit, big-endian float from `buf` at the specified `offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([1, 2, 3, 4]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readFloatBE(0));</span>
             <span class="s0">* // Prints: 2.387939260590663e-38</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.15</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.</span>
             <span class="s0">*/</span>
            <span class="s2">readFloatBE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a 64-bit, little-endian double from `buf` at the specified `offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readDoubleLE(0));</span>
             <span class="s0">* // Prints: 5.447603722011605e-270</span>
             <span class="s0">* console.log(buf.readDoubleLE(1));</span>
             <span class="s0">* // Throws ERR_OUT_OF_RANGE.</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.15</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 8`.</span>
             <span class="s0">*/</span>
            <span class="s2">readDoubleLE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a 64-bit, big-endian double from `buf` at the specified `offset`.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.readDoubleBE(0));</span>
             <span class="s0">* // Prints: 8.20788039913184e-304</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.15</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 8`.</span>
             <span class="s0">*/</span>
            <span class="s2">readDoubleBE</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s2">reverse</span><span class="s4">(): </span><span class="s5">this</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Interprets `buf` as an array of unsigned 16-bit integers and swaps the</span>
             <span class="s0">* byte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 2.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf1);</span>
             <span class="s0">* // Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;</span>
             <span class="s0">*</span>
             <span class="s0">* buf1.swap16();</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf1);</span>
             <span class="s0">* // Prints: &lt;Buffer 02 01 04 03 06 05 08 07&gt;</span>
             <span class="s0">*</span>
             <span class="s0">* const buf2 = Buffer.from([0x1, 0x2, 0x3]);</span>
             <span class="s0">*</span>
             <span class="s0">* buf2.swap16();</span>
             <span class="s0">* // Throws ERR_INVALID_BUFFER_SIZE.</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* One convenient use of `buf.swap16()` is to perform a fast in-place conversion</span>
             <span class="s0">* between UTF-16 little-endian and UTF-16 big-endian:</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from('This is little-endian UTF-16', 'utf16le');</span>
             <span class="s0">* buf.swap16(); // Convert to big-endian UTF-16 text.</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v5.10.0</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">A reference to `buf`.</span>
             <span class="s0">*/</span>
            <span class="s2">swap16</span><span class="s4">(): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Interprets `buf` as an array of unsigned 32-bit integers and swaps the</span>
             <span class="s0">* byte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 4.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf1);</span>
             <span class="s0">* // Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;</span>
             <span class="s0">*</span>
             <span class="s0">* buf1.swap32();</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf1);</span>
             <span class="s0">* // Prints: &lt;Buffer 04 03 02 01 08 07 06 05&gt;</span>
             <span class="s0">*</span>
             <span class="s0">* const buf2 = Buffer.from([0x1, 0x2, 0x3]);</span>
             <span class="s0">*</span>
             <span class="s0">* buf2.swap32();</span>
             <span class="s0">* // Throws ERR_INVALID_BUFFER_SIZE.</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v5.10.0</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">A reference to `buf`.</span>
             <span class="s0">*/</span>
            <span class="s2">swap32</span><span class="s4">(): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Interprets `buf` as an array of 64-bit numbers and swaps byte order _in-place_.</span>
             <span class="s0">* Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 8.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf1);</span>
             <span class="s0">* // Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;</span>
             <span class="s0">*</span>
             <span class="s0">* buf1.swap64();</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf1);</span>
             <span class="s0">* // Prints: &lt;Buffer 08 07 06 05 04 03 02 01&gt;</span>
             <span class="s0">*</span>
             <span class="s0">* const buf2 = Buffer.from([0x1, 0x2, 0x3]);</span>
             <span class="s0">*</span>
             <span class="s0">* buf2.swap64();</span>
             <span class="s0">* // Throws ERR_INVALID_BUFFER_SIZE.</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v6.3.0</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">A reference to `buf`.</span>
             <span class="s0">*/</span>
            <span class="s2">swap64</span><span class="s4">(): </span><span class="s2">Buffer</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset`. `value` must be a</span>
             <span class="s0">* valid unsigned 8-bit integer. Behavior is undefined when `value` is anything</span>
             <span class="s0">* other than an unsigned 8-bit integer.</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `writeUint8` alias.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(4);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeUInt8(0x3, 0);</span>
             <span class="s0">* buf.writeUInt8(0x4, 1);</span>
             <span class="s0">* buf.writeUInt8(0x23, 2);</span>
             <span class="s0">* buf.writeUInt8(0x42, 3);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer 03 04 23 42&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 1`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeUInt8</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.writeUInt8</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">writeUint8</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as little-endian. The `value`must be a valid unsigned 16-bit integer. Behavior is undefined when `value` is</span>
             <span class="s0">* anything other than an unsigned 16-bit integer.</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `writeUint16LE` alias.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(4);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeUInt16LE(0xdead, 0);</span>
             <span class="s0">* buf.writeUInt16LE(0xbeef, 2);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer ad de ef be&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeUInt16LE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.writeUInt16LE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">writeUint16LE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as big-endian. The `value`must be a valid unsigned 16-bit integer. Behavior is undefined when `value`is anything other than an</span>
             <span class="s0">* unsigned 16-bit integer.</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `writeUint16BE` alias.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(4);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeUInt16BE(0xdead, 0);</span>
             <span class="s0">* buf.writeUInt16BE(0xbeef, 2);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer de ad be ef&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeUInt16BE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.writeUInt16BE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">writeUint16BE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as little-endian. The `value`must be a valid unsigned 32-bit integer. Behavior is undefined when `value` is</span>
             <span class="s0">* anything other than an unsigned 32-bit integer.</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `writeUint32LE` alias.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(4);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeUInt32LE(0xfeedface, 0);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer ce fa ed fe&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeUInt32LE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.writeUInt32LE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">writeUint32LE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as big-endian. The `value`must be a valid unsigned 32-bit integer. Behavior is undefined when `value`is anything other than an</span>
             <span class="s0">* unsigned 32-bit integer.</span>
             <span class="s0">*</span>
             <span class="s0">* This function is also available under the `writeUint32BE` alias.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(4);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeUInt32BE(0xfeedface, 0);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer fe ed fa ce&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeUInt32BE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s0">Buffer.writeUInt32BE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0</span>
             <span class="s0">*/</span>
            <span class="s2">writeUint32BE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset`. `value` must be a valid</span>
             <span class="s0">* signed 8-bit integer. Behavior is undefined when `value` is anything other than</span>
             <span class="s0">* a signed 8-bit integer.</span>
             <span class="s0">*</span>
             <span class="s0">* `value` is interpreted and written as a two's complement signed integer.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(2);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeInt8(2, 0);</span>
             <span class="s0">* buf.writeInt8(-2, 1);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer 02 fe&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 1`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeInt8</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as little-endian.  The `value`must be a valid signed 16-bit integer. Behavior is undefined when `value` is</span>
             <span class="s0">* anything other than a signed 16-bit integer.</span>
             <span class="s0">*</span>
             <span class="s0">* The `value` is interpreted and written as a two's complement signed integer.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(2);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeInt16LE(0x0304, 0);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer 04 03&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeInt16LE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as big-endian.  The `value`must be a valid signed 16-bit integer. Behavior is undefined when `value` is</span>
             <span class="s0">* anything other than a signed 16-bit integer.</span>
             <span class="s0">*</span>
             <span class="s0">* The `value` is interpreted and written as a two's complement signed integer.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(2);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeInt16BE(0x0102, 0);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer 01 02&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeInt16BE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as little-endian. The `value`must be a valid signed 32-bit integer. Behavior is undefined when `value` is</span>
             <span class="s0">* anything other than a signed 32-bit integer.</span>
             <span class="s0">*</span>
             <span class="s0">* The `value` is interpreted and written as a two's complement signed integer.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(4);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeInt32LE(0x05060708, 0);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer 08 07 06 05&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeInt32LE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as big-endian. The `value`must be a valid signed 32-bit integer. Behavior is undefined when `value` is</span>
             <span class="s0">* anything other than a signed 32-bit integer.</span>
             <span class="s0">*</span>
             <span class="s0">* The `value` is interpreted and written as a two's complement signed integer.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(4);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeInt32BE(0x01020304, 0);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer 01 02 03 04&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.5</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeInt32BE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as little-endian. Behavior is</span>
             <span class="s0">* undefined when `value` is anything other than a JavaScript number.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(4);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeFloatLE(0xcafebabe, 0);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer bb fe 4a 4f&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.15</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeFloatLE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as big-endian. Behavior is</span>
             <span class="s0">* undefined when `value` is anything other than a JavaScript number.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(4);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeFloatBE(0xcafebabe, 0);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer 4f 4a fe bb&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.15</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeFloatBE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as little-endian. The `value`must be a JavaScript number. Behavior is undefined when `value` is anything</span>
             <span class="s0">* other than a JavaScript number.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(8);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeDoubleLE(123.456, 0);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer 77 be 9f 1a 2f dd 5e 40&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.15</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 8`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeDoubleLE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as big-endian. The `value`must be a JavaScript number. Behavior is undefined when `value` is anything</span>
             <span class="s0">* other than a JavaScript number.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(8);</span>
             <span class="s0">*</span>
             <span class="s0">* buf.writeDoubleBE(123.456, 0);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf);</span>
             <span class="s0">* // Prints: &lt;Buffer 40 5e dd 2f 1a 9f be 77&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.15</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value Number to be written to `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 8`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written.</span>
             <span class="s0">*/</span>
            <span class="s2">writeDoubleBE</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Fills `buf` with the specified `value`. If the `offset` and `end` are not given,</span>
             <span class="s0">* the entire `buf` will be filled:</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* // Fill a `Buffer` with the ASCII character 'h'.</span>
             <span class="s0">*</span>
             <span class="s0">* const b = Buffer.allocUnsafe(50).fill('h');</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(b.toString());</span>
             <span class="s0">* // Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh</span>
             <span class="s0">*</span>
             <span class="s0">* // Fill a buffer with empty string</span>
             <span class="s0">* const c = Buffer.allocUnsafe(5).fill('');</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(c.fill(''));</span>
             <span class="s0">* // Prints: &lt;Buffer 00 00 00 00 00&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* `value` is coerced to a `uint32` value if it is not a string, `Buffer`, or</span>
             <span class="s0">* integer. If the resulting integer is greater than `255` (decimal), `buf` will be</span>
             <span class="s0">* filled with `value &amp;#x26; 255`.</span>
             <span class="s0">*</span>
             <span class="s0">* If the final write of a `fill()` operation falls on a multi-byte character,</span>
             <span class="s0">* then only the bytes of that character that fit into `buf` are written:</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* // Fill a `Buffer` with character that takes up two bytes in UTF-8.</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(Buffer.allocUnsafe(5).fill('\u0222'));</span>
             <span class="s0">* // Prints: &lt;Buffer c8 a2 c8 a2 c8&gt;</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* If `value` contains invalid characters, it is truncated; if no valid</span>
             <span class="s0">* fill data remains, an exception is thrown:</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.allocUnsafe(5);</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.fill('a'));</span>
             <span class="s0">* // Prints: &lt;Buffer 61 61 61 61 61&gt;</span>
             <span class="s0">* console.log(buf.fill('aazz', 'hex'));</span>
             <span class="s0">* // Prints: &lt;Buffer aa aa aa aa aa&gt;</span>
             <span class="s0">* console.log(buf.fill('zz', 'hex'));</span>
             <span class="s0">* // Throws an exception.</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.5.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value The value with which to fill `buf`. Empty value (string, Uint8Array, Buffer) is coerced to `0`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to fill `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[end=buf.length] Where to stop filling `buf` (not inclusive).</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[encoding='utf8'] The encoding for `value` if `value` is a string.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">A reference to `buf`.</span>
             <span class="s0">*/</span>
            <span class="s2">fill</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">Uint8Array </span><span class="s4">| </span><span class="s2">number</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">end</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">encoding</span><span class="s4">?: </span><span class="s2">BufferEncoding</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* If `value` is:</span>
             <span class="s0">*</span>
             <span class="s0">* * a string, `value` is interpreted according to the character encoding in`encoding`.</span>
             <span class="s0">* * a `Buffer` or [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array), `value` will be used in its entirety.</span>
             <span class="s0">* To compare a partial `Buffer`, use `buf.subarray`.</span>
             <span class="s0">* * a number, `value` will be interpreted as an unsigned 8-bit integer</span>
             <span class="s0">* value between `0` and `255`.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from('this is a buffer');</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.indexOf('this'));</span>
             <span class="s0">* // Prints: 0</span>
             <span class="s0">* console.log(buf.indexOf('is'));</span>
             <span class="s0">* // Prints: 2</span>
             <span class="s0">* console.log(buf.indexOf(Buffer.from('a buffer')));</span>
             <span class="s0">* // Prints: 8</span>
             <span class="s0">* console.log(buf.indexOf(97));</span>
             <span class="s0">* // Prints: 8 (97 is the decimal ASCII value for 'a')</span>
             <span class="s0">* console.log(buf.indexOf(Buffer.from('a buffer example')));</span>
             <span class="s0">* // Prints: -1</span>
             <span class="s0">* console.log(buf.indexOf(Buffer.from('a buffer example').slice(0, 8)));</span>
             <span class="s0">* // Prints: 8</span>
             <span class="s0">*</span>
             <span class="s0">* const utf16Buffer = Buffer.from('\u039a\u0391\u03a3\u03a3\u0395', 'utf16le');</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(utf16Buffer.indexOf('\u03a3', 0, 'utf16le'));</span>
             <span class="s0">* // Prints: 4</span>
             <span class="s0">* console.log(utf16Buffer.indexOf('\u03a3', -4, 'utf16le'));</span>
             <span class="s0">* // Prints: 6</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* If `value` is not a string, number, or `Buffer`, this method will throw a`TypeError`. If `value` is a number, it will be coerced to a valid byte value,</span>
             <span class="s0">* an integer between 0 and 255.</span>
             <span class="s0">*</span>
             <span class="s0">* If `byteOffset` is not a number, it will be coerced to a number. If the result</span>
             <span class="s0">* of coercion is `NaN` or `0`, then the entire buffer will be searched. This</span>
             <span class="s0">* behavior matches [`String.prototype.indexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf).</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const b = Buffer.from('abcdef');</span>
             <span class="s0">*</span>
             <span class="s0">* // Passing a value that's a number, but not a valid byte.</span>
             <span class="s0">* // Prints: 2, equivalent to searching for 99 or 'c'.</span>
             <span class="s0">* console.log(b.indexOf(99.9));</span>
             <span class="s0">* console.log(b.indexOf(256 + 99));</span>
             <span class="s0">*</span>
             <span class="s0">* // Passing a byteOffset that coerces to NaN or 0.</span>
             <span class="s0">* // Prints: 1, searching the whole buffer.</span>
             <span class="s0">* console.log(b.indexOf('b', undefined));</span>
             <span class="s0">* console.log(b.indexOf('b', {}));</span>
             <span class="s0">* console.log(b.indexOf('b', null));</span>
             <span class="s0">* console.log(b.indexOf('b', []));</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* If `value` is an empty string or empty `Buffer` and `byteOffset` is less</span>
             <span class="s0">* than `buf.length`, `byteOffset` will be returned. If `value` is empty and`byteOffset` is at least `buf.length`, `buf.length` will be returned.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v1.5.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value What to search for.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[byteOffset=0] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[encoding='utf8'] If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">The index of the first occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`.</span>
             <span class="s0">*/</span>
            <span class="s2">indexOf</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">number </span><span class="s4">| </span><span class="s2">Uint8Array</span><span class="s4">, </span><span class="s2">byteOffset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">encoding</span><span class="s4">?: </span><span class="s2">BufferEncoding</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Identical to `buf.indexOf()`, except the last occurrence of `value` is found</span>
             <span class="s0">* rather than the first occurrence.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from('this buffer is a buffer');</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.lastIndexOf('this'));</span>
             <span class="s0">* // Prints: 0</span>
             <span class="s0">* console.log(buf.lastIndexOf('buffer'));</span>
             <span class="s0">* // Prints: 17</span>
             <span class="s0">* console.log(buf.lastIndexOf(Buffer.from('buffer')));</span>
             <span class="s0">* // Prints: 17</span>
             <span class="s0">* console.log(buf.lastIndexOf(97));</span>
             <span class="s0">* // Prints: 15 (97 is the decimal ASCII value for 'a')</span>
             <span class="s0">* console.log(buf.lastIndexOf(Buffer.from('yolo')));</span>
             <span class="s0">* // Prints: -1</span>
             <span class="s0">* console.log(buf.lastIndexOf('buffer', 5));</span>
             <span class="s0">* // Prints: 5</span>
             <span class="s0">* console.log(buf.lastIndexOf('buffer', 4));</span>
             <span class="s0">* // Prints: -1</span>
             <span class="s0">*</span>
             <span class="s0">* const utf16Buffer = Buffer.from('\u039a\u0391\u03a3\u03a3\u0395', 'utf16le');</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(utf16Buffer.lastIndexOf('\u03a3', undefined, 'utf16le'));</span>
             <span class="s0">* // Prints: 6</span>
             <span class="s0">* console.log(utf16Buffer.lastIndexOf('\u03a3', -5, 'utf16le'));</span>
             <span class="s0">* // Prints: 4</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* If `value` is not a string, number, or `Buffer`, this method will throw a`TypeError`. If `value` is a number, it will be coerced to a valid byte value,</span>
             <span class="s0">* an integer between 0 and 255.</span>
             <span class="s0">*</span>
             <span class="s0">* If `byteOffset` is not a number, it will be coerced to a number. Any arguments</span>
             <span class="s0">* that coerce to `NaN`, like `{}` or `undefined`, will search the whole buffer.</span>
             <span class="s0">* This behavior matches [`String.prototype.lastIndexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf).</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const b = Buffer.from('abcdef');</span>
             <span class="s0">*</span>
             <span class="s0">* // Passing a value that's a number, but not a valid byte.</span>
             <span class="s0">* // Prints: 2, equivalent to searching for 99 or 'c'.</span>
             <span class="s0">* console.log(b.lastIndexOf(99.9));</span>
             <span class="s0">* console.log(b.lastIndexOf(256 + 99));</span>
             <span class="s0">*</span>
             <span class="s0">* // Passing a byteOffset that coerces to NaN.</span>
             <span class="s0">* // Prints: 1, searching the whole buffer.</span>
             <span class="s0">* console.log(b.lastIndexOf('b', undefined));</span>
             <span class="s0">* console.log(b.lastIndexOf('b', {}));</span>
             <span class="s0">*</span>
             <span class="s0">* // Passing a byteOffset that coerces to 0.</span>
             <span class="s0">* // Prints: -1, equivalent to passing 0.</span>
             <span class="s0">* console.log(b.lastIndexOf('b', null));</span>
             <span class="s0">* console.log(b.lastIndexOf('b', []));</span>
             <span class="s0">* ```</span>
             <span class="s0">*</span>
             <span class="s0">* If `value` is an empty string or empty `Buffer`, `byteOffset` will be returned.</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v6.0.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value What to search for.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[byteOffset=buf.length - 1] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[encoding='utf8'] If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`.</span>
             <span class="s0">*/</span>
            <span class="s2">lastIndexOf</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">number </span><span class="s4">| </span><span class="s2">Uint8Array</span><span class="s4">, </span><span class="s2">byteOffset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">encoding</span><span class="s4">?: </span><span class="s2">BufferEncoding</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Creates and returns an [iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) of `[index, byte]` pairs from the contents</span>
             <span class="s0">* of `buf`.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* // Log the entire contents of a `Buffer`.</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from('buffer');</span>
             <span class="s0">*</span>
             <span class="s0">* for (const pair of buf.entries()) {</span>
             <span class="s0">*   console.log(pair);</span>
             <span class="s0">* }</span>
             <span class="s0">* // Prints:</span>
             <span class="s0">* //   [0, 98]</span>
             <span class="s0">* //   [1, 117]</span>
             <span class="s0">* //   [2, 102]</span>
             <span class="s0">* //   [3, 102]</span>
             <span class="s0">* //   [4, 101]</span>
             <span class="s0">* //   [5, 114]</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v1.1.0</span>
             <span class="s0">*/</span>
            <span class="s2">entries</span><span class="s4">(): </span><span class="s2">IterableIterator</span><span class="s4">&lt;[</span><span class="s2">number</span><span class="s4">, </span><span class="s2">number</span><span class="s4">]&gt;;</span>
            <span class="s0">/**</span>
             <span class="s0">* Equivalent to `buf.indexOf() !== -1`.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from('this is a buffer');</span>
             <span class="s0">*</span>
             <span class="s0">* console.log(buf.includes('this'));</span>
             <span class="s0">* // Prints: true</span>
             <span class="s0">* console.log(buf.includes('is'));</span>
             <span class="s0">* // Prints: true</span>
             <span class="s0">* console.log(buf.includes(Buffer.from('a buffer')));</span>
             <span class="s0">* // Prints: true</span>
             <span class="s0">* console.log(buf.includes(97));</span>
             <span class="s0">* // Prints: true (97 is the decimal ASCII value for 'a')</span>
             <span class="s0">* console.log(buf.includes(Buffer.from('a buffer example')));</span>
             <span class="s0">* // Prints: false</span>
             <span class="s0">* console.log(buf.includes(Buffer.from('a buffer example').slice(0, 8)));</span>
             <span class="s0">* // Prints: true</span>
             <span class="s0">* console.log(buf.includes('this', 4));</span>
             <span class="s0">* // Prints: false</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v5.3.0</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">value What to search for.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[byteOffset=0] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">[encoding='utf8'] If `value` is a string, this is its encoding.</span>
             <span class="s0">* </span><span class="s1">@return </span><span class="s0">`true` if `value` was found in `buf`, `false` otherwise.</span>
             <span class="s0">*/</span>
            <span class="s2">includes</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">number </span><span class="s4">| </span><span class="s2">Buffer</span><span class="s4">, </span><span class="s2">byteOffset</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">encoding</span><span class="s4">?: </span><span class="s2">BufferEncoding</span><span class="s4">): </span><span class="s2">boolean</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Creates and returns an [iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) of `buf` keys (indices).</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from('buffer');</span>
             <span class="s0">*</span>
             <span class="s0">* for (const key of buf.keys()) {</span>
             <span class="s0">*   console.log(key);</span>
             <span class="s0">* }</span>
             <span class="s0">* // Prints:</span>
             <span class="s0">* //   0</span>
             <span class="s0">* //   1</span>
             <span class="s0">* //   2</span>
             <span class="s0">* //   3</span>
             <span class="s0">* //   4</span>
             <span class="s0">* //   5</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v1.1.0</span>
             <span class="s0">*/</span>
            <span class="s2">keys</span><span class="s4">(): </span><span class="s2">IterableIterator</span><span class="s4">&lt;</span><span class="s2">number</span><span class="s4">&gt;;</span>
            <span class="s0">/**</span>
             <span class="s0">* Creates and returns an [iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) for `buf` values (bytes). This function is</span>
             <span class="s0">* called automatically when a `Buffer` is used in a `for..of` statement.</span>
             <span class="s0">*</span>
             <span class="s0">* ```js</span>
             <span class="s0">* import { Buffer } from 'node:buffer';</span>
             <span class="s0">*</span>
             <span class="s0">* const buf = Buffer.from('buffer');</span>
             <span class="s0">*</span>
             <span class="s0">* for (const value of buf.values()) {</span>
             <span class="s0">*   console.log(value);</span>
             <span class="s0">* }</span>
             <span class="s0">* // Prints:</span>
             <span class="s0">* //   98</span>
             <span class="s0">* //   117</span>
             <span class="s0">* //   102</span>
             <span class="s0">* //   102</span>
             <span class="s0">* //   101</span>
             <span class="s0">* //   114</span>
             <span class="s0">*</span>
             <span class="s0">* for (const value of buf) {</span>
             <span class="s0">*   console.log(value);</span>
             <span class="s0">* }</span>
             <span class="s0">* // Prints:</span>
             <span class="s0">* //   98</span>
             <span class="s0">* //   117</span>
             <span class="s0">* //   102</span>
             <span class="s0">* //   102</span>
             <span class="s0">* //   101</span>
             <span class="s0">* //   114</span>
             <span class="s0">* ```</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v1.1.0</span>
             <span class="s0">*/</span>
            <span class="s2">values</span><span class="s4">(): </span><span class="s2">IterableIterator</span><span class="s4">&lt;</span><span class="s2">number</span><span class="s4">&gt;;</span>
        <span class="s4">}</span>
        <span class="s5">var </span><span class="s2">Buffer</span><span class="s4">: </span><span class="s2">BufferConstructor</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Decodes a string of Base64-encoded data into bytes, and encodes those bytes</span>
         <span class="s0">* into a string using Latin-1 (ISO-8859-1).</span>
         <span class="s0">*</span>
         <span class="s0">* The `data` may be any JavaScript-value that can be coerced into a string.</span>
         <span class="s0">*</span>
         <span class="s0">* **This function is only provided for compatibility with legacy web platform APIs**</span>
         <span class="s0">* **and should never be used in new code, because they use strings to represent**</span>
         <span class="s0">* **binary data and predate the introduction of typed arrays in JavaScript.**</span>
         <span class="s0">* **For code running using Node.js APIs, converting between base64-encoded strings**</span>
         <span class="s0">* **and binary data should be performed using `Buffer.from(str, 'base64')` and`buf.toString('base64')`.**</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v15.13.0, v14.17.0</span>
         <span class="s0">* </span><span class="s1">@legacy </span><span class="s0">Use `Buffer.from(data, 'base64')` instead.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">data The Base64-encoded input string.</span>
         <span class="s0">*/</span>
        <span class="s5">function </span><span class="s2">atob</span><span class="s4">(</span><span class="s2">data</span><span class="s4">: </span><span class="s2">string</span><span class="s4">): </span><span class="s2">string</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Decodes a string into bytes using Latin-1 (ISO-8859), and encodes those bytes</span>
         <span class="s0">* into a string using Base64.</span>
         <span class="s0">*</span>
         <span class="s0">* The `data` may be any JavaScript-value that can be coerced into a string.</span>
         <span class="s0">*</span>
         <span class="s0">* **This function is only provided for compatibility with legacy web platform APIs**</span>
         <span class="s0">* **and should never be used in new code, because they use strings to represent**</span>
         <span class="s0">* **binary data and predate the introduction of typed arrays in JavaScript.**</span>
         <span class="s0">* **For code running using Node.js APIs, converting between base64-encoded strings**</span>
         <span class="s0">* **and binary data should be performed using `Buffer.from(str, 'base64')` and`buf.toString('base64')`.**</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v15.13.0, v14.17.0</span>
         <span class="s0">* </span><span class="s1">@legacy </span><span class="s0">Use `buf.toString('base64')` instead.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">data An ASCII (Latin1) string.</span>
         <span class="s0">*/</span>
        <span class="s5">function </span><span class="s2">btoa</span><span class="s4">(</span><span class="s2">data</span><span class="s4">: </span><span class="s2">string</span><span class="s4">): </span><span class="s2">string</span><span class="s4">;</span>
        <span class="s5">interface </span><span class="s2">Blob </span><span class="s5">extends </span><span class="s2">__Blob </span><span class="s4">{}</span>
        <span class="s0">/**</span>
         <span class="s0">* `Blob` class is a global reference for `require('node:buffer').Blob`</span>
         <span class="s0">* https://nodejs.org/api/buffer.html#class-blob</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.0.0</span>
         <span class="s0">*/</span>
        <span class="s5">var </span><span class="s2">Blob</span><span class="s4">: </span><span class="s5">typeof </span><span class="s2">globalThis </span><span class="s5">extends </span><span class="s4">{</span>
            <span class="s2">onmessage</span><span class="s4">: </span><span class="s2">any</span><span class="s4">;</span>
            <span class="s2">Blob</span><span class="s4">: </span><span class="s2">infer T</span><span class="s4">;</span>
        <span class="s4">} ? </span><span class="s2">T</span>
            <span class="s4">: </span><span class="s5">typeof </span><span class="s2">NodeBlob</span><span class="s4">;</span>
    <span class="s4">}</span>
<span class="s4">}</span>
<span class="s2">declare module </span><span class="s3">&quot;node:buffer&quot; </span><span class="s4">{</span>
    <span class="s5">export </span><span class="s4">* </span><span class="s2">from </span><span class="s3">&quot;buffer&quot;</span><span class="s4">;</span>
<span class="s4">}</span>
</pre>
</body>
</html>