<html>
<head>
<title>source-map.min.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
source-map.min.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack:///webpack/universalModuleDefinition&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack:///source-map.min.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack:///webpack/bootstrap 0fd5815da764db5fb9fe&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack:///./source-map.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack:///./lib/source-map-generator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack:///./lib/base64-vlq.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack:///./lib/base64.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack:///./lib/util.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack:///./lib/array-set.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack:///./lib/mapping-list.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack:///./lib/source-map-consumer.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack:///./lib/binary-search.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack:///./lib/quick-sort.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack:///./lib/source-node.js&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;root&quot;</span><span class="s0">,</span><span class="s1">&quot;factory&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;define&quot;</span><span class="s0">,</span><span class="s1">&quot;amd&quot;</span><span class="s0">,</span><span class="s1">&quot;this&quot;</span><span class="s0">,</span><span class="s1">&quot;modules&quot;</span><span class="s0">,</span><span class="s1">&quot;__webpack_require__&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleId&quot;</span><span class="s0">,</span><span class="s1">&quot;installedModules&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;loaded&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;c&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;SourceMapGenerator&quot;</span><span class="s0">,</span><span class="s1">&quot;SourceMapConsumer&quot;</span><span class="s0">,</span><span class="s1">&quot;SourceNode&quot;</span><span class="s0">,</span><span class="s1">&quot;aArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;_file&quot;</span><span class="s0">,</span><span class="s1">&quot;util&quot;</span><span class="s0">,</span><span class="s1">&quot;getArg&quot;</span><span class="s0">,</span><span class="s1">&quot;_sourceRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;_skipValidation&quot;</span><span class="s0">,</span><span class="s1">&quot;_sources&quot;</span><span class="s0">,</span><span class="s1">&quot;ArraySet&quot;</span><span class="s0">,</span><span class="s1">&quot;_names&quot;</span><span class="s0">,</span><span class="s1">&quot;_mappings&quot;</span><span class="s0">,</span><span class="s1">&quot;MappingList&quot;</span><span class="s0">,</span><span class="s1">&quot;_sourcesContents&quot;</span><span class="s0">,</span><span class="s1">&quot;base64VLQ&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;_version&quot;</span><span class="s0">,</span><span class="s1">&quot;fromSourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;aSourceMapConsumer&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;generator&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;eachMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;mapping&quot;</span><span class="s0">,</span><span class="s1">&quot;newMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;generated&quot;</span><span class="s0">,</span><span class="s1">&quot;line&quot;</span><span class="s0">,</span><span class="s1">&quot;generatedLine&quot;</span><span class="s0">,</span><span class="s1">&quot;column&quot;</span><span class="s0">,</span><span class="s1">&quot;generatedColumn&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;relative&quot;</span><span class="s0">,</span><span class="s1">&quot;original&quot;</span><span class="s0">,</span><span class="s1">&quot;originalLine&quot;</span><span class="s0">,</span><span class="s1">&quot;originalColumn&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;addMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceFile&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceRelative&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;content&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceContentFor&quot;</span><span class="s0">,</span><span class="s1">&quot;setSourceContent&quot;</span><span class="s0">,</span><span class="s1">&quot;_validateMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;aSourceFile&quot;</span><span class="s0">,</span><span class="s1">&quot;aSourceContent&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;create&quot;</span><span class="s0">,</span><span class="s1">&quot;toSetString&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;applySourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;aSourceMapPath&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;newSources&quot;</span><span class="s0">,</span><span class="s1">&quot;newNames&quot;</span><span class="s0">,</span><span class="s1">&quot;unsortedForEach&quot;</span><span class="s0">,</span><span class="s1">&quot;originalPositionFor&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;aGenerated&quot;</span><span class="s0">,</span><span class="s1">&quot;aOriginal&quot;</span><span class="s0">,</span><span class="s1">&quot;aSource&quot;</span><span class="s0">,</span><span class="s1">&quot;aName&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;_serializeMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;nameIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;previousGeneratedColumn&quot;</span><span class="s0">,</span><span class="s1">&quot;previousGeneratedLine&quot;</span><span class="s0">,</span><span class="s1">&quot;previousOriginalColumn&quot;</span><span class="s0">,</span><span class="s1">&quot;previousOriginalLine&quot;</span><span class="s0">,</span><span class="s1">&quot;previousName&quot;</span><span class="s0">,</span><span class="s1">&quot;previousSource&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">,</span><span class="s1">&quot;toArray&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;len&quot;</span><span class="s0">,</span><span class="s1">&quot;compareByGeneratedPositionsInflated&quot;</span><span class="s0">,</span><span class="s1">&quot;encode&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;_generateSourcesContent&quot;</span><span class="s0">,</span><span class="s1">&quot;aSources&quot;</span><span class="s0">,</span><span class="s1">&quot;aSourceRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;toJSON&quot;</span><span class="s0">,</span><span class="s1">&quot;version&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;toVLQSigned&quot;</span><span class="s0">,</span><span class="s1">&quot;aValue&quot;</span><span class="s0">,</span><span class="s1">&quot;fromVLQSigned&quot;</span><span class="s0">,</span><span class="s1">&quot;isNegative&quot;</span><span class="s0">,</span><span class="s1">&quot;shifted&quot;</span><span class="s0">,</span><span class="s1">&quot;base64&quot;</span><span class="s0">,</span><span class="s1">&quot;VLQ_BASE_SHIFT&quot;</span><span class="s0">,</span><span class="s1">&quot;VLQ_BASE&quot;</span><span class="s0">,</span><span class="s1">&quot;VLQ_BASE_MASK&quot;</span><span class="s0">,</span><span class="s1">&quot;VLQ_CONTINUATION_BIT&quot;</span><span class="s0">,</span><span class="s1">&quot;digit&quot;</span><span class="s0">,</span><span class="s1">&quot;encoded&quot;</span><span class="s0">,</span><span class="s1">&quot;vlq&quot;</span><span class="s0">,</span><span class="s1">&quot;decode&quot;</span><span class="s0">,</span><span class="s1">&quot;aStr&quot;</span><span class="s0">,</span><span class="s1">&quot;aIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;aOutParam&quot;</span><span class="s0">,</span><span class="s1">&quot;continuation&quot;</span><span class="s0">,</span><span class="s1">&quot;strLen&quot;</span><span class="s0">,</span><span class="s1">&quot;shift&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;charAt&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;rest&quot;</span><span class="s0">,</span><span class="s1">&quot;intToCharMap&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;number&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;charCode&quot;</span><span class="s0">,</span><span class="s1">&quot;bigA&quot;</span><span class="s0">,</span><span class="s1">&quot;bigZ&quot;</span><span class="s0">,</span><span class="s1">&quot;littleA&quot;</span><span class="s0">,</span><span class="s1">&quot;littleZ&quot;</span><span class="s0">,</span><span class="s1">&quot;zero&quot;</span><span class="s0">,</span><span class="s1">&quot;nine&quot;</span><span class="s0">,</span><span class="s1">&quot;plus&quot;</span><span class="s0">,</span><span class="s1">&quot;slash&quot;</span><span class="s0">,</span><span class="s1">&quot;littleOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;numberOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;aDefaultValue&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;urlParse&quot;</span><span class="s0">,</span><span class="s1">&quot;aUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;urlRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;scheme&quot;</span><span class="s0">,</span><span class="s1">&quot;auth&quot;</span><span class="s0">,</span><span class="s1">&quot;host&quot;</span><span class="s0">,</span><span class="s1">&quot;port&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;urlGenerate&quot;</span><span class="s0">,</span><span class="s1">&quot;aParsedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;normalize&quot;</span><span class="s0">,</span><span class="s1">&quot;aPath&quot;</span><span class="s0">,</span><span class="s1">&quot;part&quot;</span><span class="s0">,</span><span class="s1">&quot;isAbsolute&quot;</span><span class="s0">,</span><span class="s1">&quot;parts&quot;</span><span class="s0">,</span><span class="s1">&quot;up&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;aRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;aPathUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;aRootUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;dataUrlRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;joined&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;level&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;lastIndexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;substr&quot;</span><span class="s0">,</span><span class="s1">&quot;identity&quot;</span><span class="s0">,</span><span class="s1">&quot;s&quot;</span><span class="s0">,</span><span class="s1">&quot;isProtoString&quot;</span><span class="s0">,</span><span class="s1">&quot;fromSetString&quot;</span><span class="s0">,</span><span class="s1">&quot;compareByOriginalPositions&quot;</span><span class="s0">,</span><span class="s1">&quot;mappingA&quot;</span><span class="s0">,</span><span class="s1">&quot;mappingB&quot;</span><span class="s0">,</span><span class="s1">&quot;onlyCompareOriginal&quot;</span><span class="s0">,</span><span class="s1">&quot;cmp&quot;</span><span class="s0">,</span><span class="s1">&quot;strcmp&quot;</span><span class="s0">,</span><span class="s1">&quot;compareByGeneratedPositionsDeflated&quot;</span><span class="s0">,</span><span class="s1">&quot;onlyCompareGenerated&quot;</span><span class="s0">,</span><span class="s1">&quot;aStr1&quot;</span><span class="s0">,</span><span class="s1">&quot;aStr2&quot;</span><span class="s0">,</span><span class="s1">&quot;parseSourceMapInput&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;computeSourceURL&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceURL&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMapURL&quot;</span><span class="s0">,</span><span class="s1">&quot;parsed&quot;</span><span class="s0">,</span><span class="s1">&quot;substring&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;supportsNullProto&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;_array&quot;</span><span class="s0">,</span><span class="s1">&quot;_set&quot;</span><span class="s0">,</span><span class="s1">&quot;hasNativeMap&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;fromArray&quot;</span><span class="s0">,</span><span class="s1">&quot;aArray&quot;</span><span class="s0">,</span><span class="s1">&quot;aAllowDuplicates&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;getOwnPropertyNames&quot;</span><span class="s0">,</span><span class="s1">&quot;sStr&quot;</span><span class="s0">,</span><span class="s1">&quot;isDuplicate&quot;</span><span class="s0">,</span><span class="s1">&quot;idx&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;at&quot;</span><span class="s0">,</span><span class="s1">&quot;aIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;generatedPositionAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;lineA&quot;</span><span class="s0">,</span><span class="s1">&quot;lineB&quot;</span><span class="s0">,</span><span class="s1">&quot;columnA&quot;</span><span class="s0">,</span><span class="s1">&quot;columnB&quot;</span><span class="s0">,</span><span class="s1">&quot;_sorted&quot;</span><span class="s0">,</span><span class="s1">&quot;_last&quot;</span><span class="s0">,</span><span class="s1">&quot;aCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;aThisArg&quot;</span><span class="s0">,</span><span class="s1">&quot;aMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">,</span><span class="s1">&quot;aSourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;aSourceMapURL&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;sections&quot;</span><span class="s0">,</span><span class="s1">&quot;IndexedSourceMapConsumer&quot;</span><span class="s0">,</span><span class="s1">&quot;BasicSourceMapConsumer&quot;</span><span class="s0">,</span><span class="s1">&quot;_absoluteSources&quot;</span><span class="s0">,</span><span class="s1">&quot;_sourceMapURL&quot;</span><span class="s0">,</span><span class="s1">&quot;Mapping&quot;</span><span class="s0">,</span><span class="s1">&quot;lastOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;_sections&quot;</span><span class="s0">,</span><span class="s1">&quot;offset&quot;</span><span class="s0">,</span><span class="s1">&quot;offsetLine&quot;</span><span class="s0">,</span><span class="s1">&quot;offsetColumn&quot;</span><span class="s0">,</span><span class="s1">&quot;generatedOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;consumer&quot;</span><span class="s0">,</span><span class="s1">&quot;binarySearch&quot;</span><span class="s0">,</span><span class="s1">&quot;quickSort&quot;</span><span class="s0">,</span><span class="s1">&quot;__generatedMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;configurable&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;_parseMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;__originalMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;_charIsMappingSeparator&quot;</span><span class="s0">,</span><span class="s1">&quot;GENERATED_ORDER&quot;</span><span class="s0">,</span><span class="s1">&quot;ORIGINAL_ORDER&quot;</span><span class="s0">,</span><span class="s1">&quot;GREATEST_LOWER_BOUND&quot;</span><span class="s0">,</span><span class="s1">&quot;LEAST_UPPER_BOUND&quot;</span><span class="s0">,</span><span class="s1">&quot;aContext&quot;</span><span class="s0">,</span><span class="s1">&quot;aOrder&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;order&quot;</span><span class="s0">,</span><span class="s1">&quot;_generatedMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;_originalMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;allGeneratedPositionsFor&quot;</span><span class="s0">,</span><span class="s1">&quot;needle&quot;</span><span class="s0">,</span><span class="s1">&quot;_findSourceIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;_findMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;lastColumn&quot;</span><span class="s0">,</span><span class="s1">&quot;relativeSource&quot;</span><span class="s0">,</span><span class="s1">&quot;smc&quot;</span><span class="s0">,</span><span class="s1">&quot;generatedMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;destGeneratedMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;destOriginalMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;srcMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;destMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;temp&quot;</span><span class="s0">,</span><span class="s1">&quot;originalMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;aNeedle&quot;</span><span class="s0">,</span><span class="s1">&quot;aMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;aLineName&quot;</span><span class="s0">,</span><span class="s1">&quot;aColumnName&quot;</span><span class="s0">,</span><span class="s1">&quot;aComparator&quot;</span><span class="s0">,</span><span class="s1">&quot;aBias&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;computeColumnSpans&quot;</span><span class="s0">,</span><span class="s1">&quot;nextMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;lastGeneratedColumn&quot;</span><span class="s0">,</span><span class="s1">&quot;Infinity&quot;</span><span class="s0">,</span><span class="s1">&quot;hasContentsOfAllSources&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;sc&quot;</span><span class="s0">,</span><span class="s1">&quot;nullOnMissing&quot;</span><span class="s0">,</span><span class="s1">&quot;fileUriAbsPath&quot;</span><span class="s0">,</span><span class="s1">&quot;generatedPositionFor&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;j&quot;</span><span class="s0">,</span><span class="s1">&quot;sectionIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;section&quot;</span><span class="s0">,</span><span class="s1">&quot;bias&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;generatedPosition&quot;</span><span class="s0">,</span><span class="s1">&quot;ret&quot;</span><span class="s0">,</span><span class="s1">&quot;sectionMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;adjustedMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;recursiveSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;aLow&quot;</span><span class="s0">,</span><span class="s1">&quot;aHigh&quot;</span><span class="s0">,</span><span class="s1">&quot;aHaystack&quot;</span><span class="s0">,</span><span class="s1">&quot;aCompare&quot;</span><span class="s0">,</span><span class="s1">&quot;mid&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;floor&quot;</span><span class="s0">,</span><span class="s1">&quot;swap&quot;</span><span class="s0">,</span><span class="s1">&quot;ary&quot;</span><span class="s0">,</span><span class="s1">&quot;x&quot;</span><span class="s0">,</span><span class="s1">&quot;y&quot;</span><span class="s0">,</span><span class="s1">&quot;randomIntInRange&quot;</span><span class="s0">,</span><span class="s1">&quot;low&quot;</span><span class="s0">,</span><span class="s1">&quot;high&quot;</span><span class="s0">,</span><span class="s1">&quot;round&quot;</span><span class="s0">,</span><span class="s1">&quot;random&quot;</span><span class="s0">,</span><span class="s1">&quot;doQuickSort&quot;</span><span class="s0">,</span><span class="s1">&quot;comparator&quot;</span><span class="s0">,</span><span class="s1">&quot;r&quot;</span><span class="s0">,</span><span class="s1">&quot;pivotIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;pivot&quot;</span><span class="s0">,</span><span class="s1">&quot;q&quot;</span><span class="s0">,</span><span class="s1">&quot;aLine&quot;</span><span class="s0">,</span><span class="s1">&quot;aColumn&quot;</span><span class="s0">,</span><span class="s1">&quot;aChunks&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceContents&quot;</span><span class="s0">,</span><span class="s1">&quot;isSourceNode&quot;</span><span class="s0">,</span><span class="s1">&quot;REGEX_NEWLINE&quot;</span><span class="s0">,</span><span class="s1">&quot;NEWLINE_CODE&quot;</span><span class="s0">,</span><span class="s1">&quot;fromStringWithSourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;aGeneratedCode&quot;</span><span class="s0">,</span><span class="s1">&quot;aRelativePath&quot;</span><span class="s0">,</span><span class="s1">&quot;addMappingWithCode&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;remainingLines&quot;</span><span class="s0">,</span><span class="s1">&quot;remainingLinesIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;shiftNextLine&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextLine&quot;</span><span class="s0">,</span><span class="s1">&quot;lineContents&quot;</span><span class="s0">,</span><span class="s1">&quot;newLine&quot;</span><span class="s0">,</span><span class="s1">&quot;lastGeneratedLine&quot;</span><span class="s0">,</span><span class="s1">&quot;lastMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;nextLine&quot;</span><span class="s0">,</span><span class="s1">&quot;aChunk&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;chunk&quot;</span><span class="s0">,</span><span class="s1">&quot;prepend&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;walk&quot;</span><span class="s0">,</span><span class="s1">&quot;aFn&quot;</span><span class="s0">,</span><span class="s1">&quot;aSep&quot;</span><span class="s0">,</span><span class="s1">&quot;newChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceRight&quot;</span><span class="s0">,</span><span class="s1">&quot;aPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;aReplacement&quot;</span><span class="s0">,</span><span class="s1">&quot;lastChild&quot;</span><span class="s0">,</span><span class="s1">&quot;walkSourceContents&quot;</span><span class="s0">,</span><span class="s1">&quot;toStringWithSourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMappingActive&quot;</span><span class="s0">,</span><span class="s1">&quot;lastOriginalSource&quot;</span><span class="s0">,</span><span class="s1">&quot;lastOriginalLine&quot;</span><span class="s0">,</span><span class="s1">&quot;lastOriginalColumn&quot;</span><span class="s0">,</span><span class="s1">&quot;lastOriginalName&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceContent&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;source-map.min.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;(function webpackUniversalModuleDefinition(root, factory) {</span><span class="s3">\n\t</span><span class="s1">if(typeof exports === 'object' &amp;&amp; typeof module === 'object')</span><span class="s3">\n\t\t</span><span class="s1">module.exports = factory();</span><span class="s3">\n\t</span><span class="s1">else if(typeof define === 'function' &amp;&amp; define.amd)</span><span class="s3">\n\t\t</span><span class="s1">define([], factory);</span><span class="s3">\n\t</span><span class="s1">else if(typeof exports === 'object')</span><span class="s3">\n\t\t</span><span class="s1">exports[</span><span class="s3">\&quot;</span><span class="s1">sourceMap</span><span class="s3">\&quot;</span><span class="s1">] = factory();</span><span class="s3">\n\t</span><span class="s1">else</span><span class="s3">\n\t\t</span><span class="s1">root[</span><span class="s3">\&quot;</span><span class="s1">sourceMap</span><span class="s3">\&quot;</span><span class="s1">] = factory();</span><span class="s3">\n</span><span class="s1">})(this, function() {</span><span class="s3">\n</span><span class="s1">return </span><span class="s3">\n\n\n</span><span class="s1">// WEBPACK FOOTER //</span><span class="s3">\n</span><span class="s1">// webpack/universalModuleDefinition&quot;</span><span class="s0">,</span><span class="s1">&quot;(function webpackUniversalModuleDefinition(root, factory) {</span><span class="s3">\n\t</span><span class="s1">if(typeof exports === 'object' &amp;&amp; typeof module === 'object')</span><span class="s3">\n\t\t</span><span class="s1">module.exports = factory();</span><span class="s3">\n\t</span><span class="s1">else if(typeof define === 'function' &amp;&amp; define.amd)</span><span class="s3">\n\t\t</span><span class="s1">define([], factory);</span><span class="s3">\n\t</span><span class="s1">else if(typeof exports === 'object')</span><span class="s3">\n\t\t</span><span class="s1">exports[</span><span class="s3">\&quot;</span><span class="s1">sourceMap</span><span class="s3">\&quot;</span><span class="s1">] = factory();</span><span class="s3">\n\t</span><span class="s1">else</span><span class="s3">\n\t\t</span><span class="s1">root[</span><span class="s3">\&quot;</span><span class="s1">sourceMap</span><span class="s3">\&quot;</span><span class="s1">] = factory();</span><span class="s3">\n</span><span class="s1">})(this, function() {</span><span class="s3">\n</span><span class="s1">return /******/ (function(modules) { // webpackBootstrap</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// The module cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">var installedModules = {};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// The require function</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">function __webpack_require__(moduleId) {</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Check if module is in cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">if(installedModules[moduleId])</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">return installedModules[moduleId].exports;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Create a new module (and put it into the cache)</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">var module = installedModules[moduleId] = {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">exports: {},</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">id: moduleId,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">loaded: false</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Execute the module function</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Flag the module as loaded</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">module.loaded = true;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Return the exports of the module</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">return module.exports;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// expose the modules object (__webpack_modules__)</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.m = modules;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// expose the module cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.c = installedModules;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// __webpack_public_path__</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.p = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// Load entry module and return exports</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">return __webpack_require__(0);</span><span class="s3">\n</span><span class="s1">/******/ })</span><span class="s3">\n</span><span class="s1">/************************************************************************/</span><span class="s3">\n</span><span class="s1">/******/ ([</span><span class="s3">\n</span><span class="s1">/* 0 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\t</span><span class="s1">/*</span><span class="s3">\n\t </span><span class="s1">* Copyright 2009-2011 Mozilla Foundation and contributors</span><span class="s3">\n\t </span><span class="s1">* Licensed under the New BSD license. See LICENSE.txt or:</span><span class="s3">\n\t </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">exports.SourceMapGenerator = __webpack_require__(1).SourceMapGenerator;</span><span class="s3">\n\t</span><span class="s1">exports.SourceMapConsumer = __webpack_require__(7).SourceMapConsumer;</span><span class="s3">\n\t</span><span class="s1">exports.SourceNode = __webpack_require__(10).SourceNode;</span><span class="s3">\n\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 1 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\t</span><span class="s1">/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n\t</span><span class="s1">/*</span><span class="s3">\n\t </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n\t </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n\t </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t\n\t</span><span class="s1">var base64VLQ = __webpack_require__(2);</span><span class="s3">\n\t</span><span class="s1">var util = __webpack_require__(4);</span><span class="s3">\n\t</span><span class="s1">var ArraySet = __webpack_require__(5).ArraySet;</span><span class="s3">\n\t</span><span class="s1">var MappingList = __webpack_require__(6).MappingList;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* An instance of the SourceMapGenerator represents a source map which is</span><span class="s3">\n\t </span><span class="s1">* being built incrementally. You may pass an object with the following</span><span class="s3">\n\t </span><span class="s1">* properties:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*   - file: The filename of the generated source.</span><span class="s3">\n\t </span><span class="s1">*   - sourceRoot: A root for all relative URLs in this source map.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function SourceMapGenerator(aArgs) {</span><span class="s3">\n\t  </span><span class="s1">if (!aArgs) {</span><span class="s3">\n\t    </span><span class="s1">aArgs = {};</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">this._file = util.getArg(aArgs, 'file', null);</span><span class="s3">\n\t  </span><span class="s1">this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);</span><span class="s3">\n\t  </span><span class="s1">this._skipValidation = util.getArg(aArgs, 'skipValidation', false);</span><span class="s3">\n\t  </span><span class="s1">this._sources = new ArraySet();</span><span class="s3">\n\t  </span><span class="s1">this._names = new ArraySet();</span><span class="s3">\n\t  </span><span class="s1">this._mappings = new MappingList();</span><span class="s3">\n\t  </span><span class="s1">this._sourcesContents = null;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">SourceMapGenerator.prototype._version = 3;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Creates a new SourceMapGenerator based on a SourceMapConsumer</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param aSourceMapConsumer The SourceMap.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceMapGenerator.fromSourceMap =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {</span><span class="s3">\n\t    </span><span class="s1">var sourceRoot = aSourceMapConsumer.sourceRoot;</span><span class="s3">\n\t    </span><span class="s1">var generator = new SourceMapGenerator({</span><span class="s3">\n\t      </span><span class="s1">file: aSourceMapConsumer.file,</span><span class="s3">\n\t      </span><span class="s1">sourceRoot: sourceRoot</span><span class="s3">\n\t    </span><span class="s1">});</span><span class="s3">\n\t    </span><span class="s1">aSourceMapConsumer.eachMapping(function (mapping) {</span><span class="s3">\n\t      </span><span class="s1">var newMapping = {</span><span class="s3">\n\t        </span><span class="s1">generated: {</span><span class="s3">\n\t          </span><span class="s1">line: mapping.generatedLine,</span><span class="s3">\n\t          </span><span class="s1">column: mapping.generatedColumn</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">};</span><span class="s3">\n\t\n\t      </span><span class="s1">if (mapping.source != null) {</span><span class="s3">\n\t        </span><span class="s1">newMapping.source = mapping.source;</span><span class="s3">\n\t        </span><span class="s1">if (sourceRoot != null) {</span><span class="s3">\n\t          </span><span class="s1">newMapping.source = util.relative(sourceRoot, newMapping.source);</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t\n\t        </span><span class="s1">newMapping.original = {</span><span class="s3">\n\t          </span><span class="s1">line: mapping.originalLine,</span><span class="s3">\n\t          </span><span class="s1">column: mapping.originalColumn</span><span class="s3">\n\t        </span><span class="s1">};</span><span class="s3">\n\t\n\t        </span><span class="s1">if (mapping.name != null) {</span><span class="s3">\n\t          </span><span class="s1">newMapping.name = mapping.name;</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t\n\t      </span><span class="s1">generator.addMapping(newMapping);</span><span class="s3">\n\t    </span><span class="s1">});</span><span class="s3">\n\t    </span><span class="s1">aSourceMapConsumer.sources.forEach(function (sourceFile) {</span><span class="s3">\n\t      </span><span class="s1">var sourceRelative = sourceFile;</span><span class="s3">\n\t      </span><span class="s1">if (sourceRoot !== null) {</span><span class="s3">\n\t        </span><span class="s1">sourceRelative = util.relative(sourceRoot, sourceFile);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t\n\t      </span><span class="s1">if (!generator._sources.has(sourceRelative)) {</span><span class="s3">\n\t        </span><span class="s1">generator._sources.add(sourceRelative);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t\n\t      </span><span class="s1">var content = aSourceMapConsumer.sourceContentFor(sourceFile);</span><span class="s3">\n\t      </span><span class="s1">if (content != null) {</span><span class="s3">\n\t        </span><span class="s1">generator.setSourceContent(sourceFile, content);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">});</span><span class="s3">\n\t    </span><span class="s1">return generator;</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Add a single mapping from original source line and column to the generated</span><span class="s3">\n\t </span><span class="s1">* source's line and column for this source map being created. The mapping</span><span class="s3">\n\t </span><span class="s1">* object should have the following properties:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*   - generated: An object with the generated line and column positions.</span><span class="s3">\n\t </span><span class="s1">*   - original: An object with the original line and column positions.</span><span class="s3">\n\t </span><span class="s1">*   - source: The original source file (relative to the sourceRoot).</span><span class="s3">\n\t </span><span class="s1">*   - name: An optional original token name for this mapping.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceMapGenerator.prototype.addMapping =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapGenerator_addMapping(aArgs) {</span><span class="s3">\n\t    </span><span class="s1">var generated = util.getArg(aArgs, 'generated');</span><span class="s3">\n\t    </span><span class="s1">var original = util.getArg(aArgs, 'original', null);</span><span class="s3">\n\t    </span><span class="s1">var source = util.getArg(aArgs, 'source', null);</span><span class="s3">\n\t    </span><span class="s1">var name = util.getArg(aArgs, 'name', null);</span><span class="s3">\n\t\n\t    </span><span class="s1">if (!this._skipValidation) {</span><span class="s3">\n\t      </span><span class="s1">this._validateMapping(generated, original, source, name);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">if (source != null) {</span><span class="s3">\n\t      </span><span class="s1">source = String(source);</span><span class="s3">\n\t      </span><span class="s1">if (!this._sources.has(source)) {</span><span class="s3">\n\t        </span><span class="s1">this._sources.add(source);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">if (name != null) {</span><span class="s3">\n\t      </span><span class="s1">name = String(name);</span><span class="s3">\n\t      </span><span class="s1">if (!this._names.has(name)) {</span><span class="s3">\n\t        </span><span class="s1">this._names.add(name);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">this._mappings.add({</span><span class="s3">\n\t      </span><span class="s1">generatedLine: generated.line,</span><span class="s3">\n\t      </span><span class="s1">generatedColumn: generated.column,</span><span class="s3">\n\t      </span><span class="s1">originalLine: original != null &amp;&amp; original.line,</span><span class="s3">\n\t      </span><span class="s1">originalColumn: original != null &amp;&amp; original.column,</span><span class="s3">\n\t      </span><span class="s1">source: source,</span><span class="s3">\n\t      </span><span class="s1">name: name</span><span class="s3">\n\t    </span><span class="s1">});</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Set the source content for a source file.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceMapGenerator.prototype.setSourceContent =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {</span><span class="s3">\n\t    </span><span class="s1">var source = aSourceFile;</span><span class="s3">\n\t    </span><span class="s1">if (this._sourceRoot != null) {</span><span class="s3">\n\t      </span><span class="s1">source = util.relative(this._sourceRoot, source);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">if (aSourceContent != null) {</span><span class="s3">\n\t      </span><span class="s1">// Add the source content to the _sourcesContents map.</span><span class="s3">\n\t      </span><span class="s1">// Create a new _sourcesContents map if the property is null.</span><span class="s3">\n\t      </span><span class="s1">if (!this._sourcesContents) {</span><span class="s3">\n\t        </span><span class="s1">this._sourcesContents = Object.create(null);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">this._sourcesContents[util.toSetString(source)] = aSourceContent;</span><span class="s3">\n\t    </span><span class="s1">} else if (this._sourcesContents) {</span><span class="s3">\n\t      </span><span class="s1">// Remove the source file from the _sourcesContents map.</span><span class="s3">\n\t      </span><span class="s1">// If the _sourcesContents map is empty, set the property to null.</span><span class="s3">\n\t      </span><span class="s1">delete this._sourcesContents[util.toSetString(source)];</span><span class="s3">\n\t      </span><span class="s1">if (Object.keys(this._sourcesContents).length === 0) {</span><span class="s3">\n\t        </span><span class="s1">this._sourcesContents = null;</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Applies the mappings of a sub-source-map for a specific source file to the</span><span class="s3">\n\t </span><span class="s1">* source map being generated. Each mapping to the supplied source file is</span><span class="s3">\n\t </span><span class="s1">* rewritten using the supplied source map. Note: The resolution for the</span><span class="s3">\n\t </span><span class="s1">* resulting mappings is the minimium of this map and the supplied map.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param aSourceMapConsumer The source map to be applied.</span><span class="s3">\n\t </span><span class="s1">* @param aSourceFile Optional. The filename of the source file.</span><span class="s3">\n\t </span><span class="s1">*        If omitted, SourceMapConsumer's file property will be used.</span><span class="s3">\n\t </span><span class="s1">* @param aSourceMapPath Optional. The dirname of the path to the source map</span><span class="s3">\n\t </span><span class="s1">*        to be applied. If relative, it is relative to the SourceMapConsumer.</span><span class="s3">\n\t </span><span class="s1">*        This parameter is needed when the two source maps aren't in the same</span><span class="s3">\n\t </span><span class="s1">*        directory, and the source map to be applied contains relative source</span><span class="s3">\n\t </span><span class="s1">*        paths. If so, those relative source paths need to be rewritten</span><span class="s3">\n\t </span><span class="s1">*        relative to the SourceMapGenerator.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceMapGenerator.prototype.applySourceMap =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {</span><span class="s3">\n\t    </span><span class="s1">var sourceFile = aSourceFile;</span><span class="s3">\n\t    </span><span class="s1">// If aSourceFile is omitted, we will use the file property of the SourceMap</span><span class="s3">\n\t    </span><span class="s1">if (aSourceFile == null) {</span><span class="s3">\n\t      </span><span class="s1">if (aSourceMapConsumer.file == null) {</span><span class="s3">\n\t        </span><span class="s1">throw new Error(</span><span class="s3">\n\t          </span><span class="s1">'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +</span><span class="s3">\n\t          </span><span class="s1">'or the source map</span><span class="s3">\\</span><span class="s1">'s </span><span class="s3">\&quot;</span><span class="s1">file</span><span class="s3">\&quot; </span><span class="s1">property. Both were omitted.'</span><span class="s3">\n\t        </span><span class="s1">);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">sourceFile = aSourceMapConsumer.file;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">var sourceRoot = this._sourceRoot;</span><span class="s3">\n\t    </span><span class="s1">// Make </span><span class="s3">\&quot;</span><span class="s1">sourceFile</span><span class="s3">\&quot; </span><span class="s1">relative if an absolute Url is passed.</span><span class="s3">\n\t    </span><span class="s1">if (sourceRoot != null) {</span><span class="s3">\n\t      </span><span class="s1">sourceFile = util.relative(sourceRoot, sourceFile);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">// Applying the SourceMap can add and remove items from the sources and</span><span class="s3">\n\t    </span><span class="s1">// the names array.</span><span class="s3">\n\t    </span><span class="s1">var newSources = new ArraySet();</span><span class="s3">\n\t    </span><span class="s1">var newNames = new ArraySet();</span><span class="s3">\n\t\n\t    </span><span class="s1">// Find mappings for the </span><span class="s3">\&quot;</span><span class="s1">sourceFile</span><span class="s3">\&quot;\n\t    </span><span class="s1">this._mappings.unsortedForEach(function (mapping) {</span><span class="s3">\n\t      </span><span class="s1">if (mapping.source === sourceFile &amp;&amp; mapping.originalLine != null) {</span><span class="s3">\n\t        </span><span class="s1">// Check if it can be mapped by the source map, then update the mapping.</span><span class="s3">\n\t        </span><span class="s1">var original = aSourceMapConsumer.originalPositionFor({</span><span class="s3">\n\t          </span><span class="s1">line: mapping.originalLine,</span><span class="s3">\n\t          </span><span class="s1">column: mapping.originalColumn</span><span class="s3">\n\t        </span><span class="s1">});</span><span class="s3">\n\t        </span><span class="s1">if (original.source != null) {</span><span class="s3">\n\t          </span><span class="s1">// Copy mapping</span><span class="s3">\n\t          </span><span class="s1">mapping.source = original.source;</span><span class="s3">\n\t          </span><span class="s1">if (aSourceMapPath != null) {</span><span class="s3">\n\t            </span><span class="s1">mapping.source = util.join(aSourceMapPath, mapping.source)</span><span class="s3">\n\t          </span><span class="s1">}</span><span class="s3">\n\t          </span><span class="s1">if (sourceRoot != null) {</span><span class="s3">\n\t            </span><span class="s1">mapping.source = util.relative(sourceRoot, mapping.source);</span><span class="s3">\n\t          </span><span class="s1">}</span><span class="s3">\n\t          </span><span class="s1">mapping.originalLine = original.line;</span><span class="s3">\n\t          </span><span class="s1">mapping.originalColumn = original.column;</span><span class="s3">\n\t          </span><span class="s1">if (original.name != null) {</span><span class="s3">\n\t            </span><span class="s1">mapping.name = original.name;</span><span class="s3">\n\t          </span><span class="s1">}</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t\n\t      </span><span class="s1">var source = mapping.source;</span><span class="s3">\n\t      </span><span class="s1">if (source != null &amp;&amp; !newSources.has(source)) {</span><span class="s3">\n\t        </span><span class="s1">newSources.add(source);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t\n\t      </span><span class="s1">var name = mapping.name;</span><span class="s3">\n\t      </span><span class="s1">if (name != null &amp;&amp; !newNames.has(name)) {</span><span class="s3">\n\t        </span><span class="s1">newNames.add(name);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">}, this);</span><span class="s3">\n\t    </span><span class="s1">this._sources = newSources;</span><span class="s3">\n\t    </span><span class="s1">this._names = newNames;</span><span class="s3">\n\t\n\t    </span><span class="s1">// Copy sourcesContents of applied map.</span><span class="s3">\n\t    </span><span class="s1">aSourceMapConsumer.sources.forEach(function (sourceFile) {</span><span class="s3">\n\t      </span><span class="s1">var content = aSourceMapConsumer.sourceContentFor(sourceFile);</span><span class="s3">\n\t      </span><span class="s1">if (content != null) {</span><span class="s3">\n\t        </span><span class="s1">if (aSourceMapPath != null) {</span><span class="s3">\n\t          </span><span class="s1">sourceFile = util.join(aSourceMapPath, sourceFile);</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t        </span><span class="s1">if (sourceRoot != null) {</span><span class="s3">\n\t          </span><span class="s1">sourceFile = util.relative(sourceRoot, sourceFile);</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t        </span><span class="s1">this.setSourceContent(sourceFile, content);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}, this);</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* A mapping can have one of the three levels of data:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*   1. Just the generated position.</span><span class="s3">\n\t </span><span class="s1">*   2. The Generated position, original position, and original source.</span><span class="s3">\n\t </span><span class="s1">*   3. Generated and original position, original source, as well as a name</span><span class="s3">\n\t </span><span class="s1">*      token.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* To maintain consistency, we validate that any new mapping being added falls</span><span class="s3">\n\t </span><span class="s1">* in to one of these categories.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceMapGenerator.prototype._validateMapping =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,</span><span class="s3">\n\t                                              </span><span class="s1">aName) {</span><span class="s3">\n\t    </span><span class="s1">// When aOriginal is truthy but has empty values for .line and .column,</span><span class="s3">\n\t    </span><span class="s1">// it is most likely a programmer error. In this case we throw a very</span><span class="s3">\n\t    </span><span class="s1">// specific error message to try to guide them the right way.</span><span class="s3">\n\t    </span><span class="s1">// For example: https://github.com/Polymer/polymer-bundler/pull/519</span><span class="s3">\n\t    </span><span class="s1">if (aOriginal &amp;&amp; typeof aOriginal.line !== 'number' &amp;&amp; typeof aOriginal.column !== 'number') {</span><span class="s3">\n\t        </span><span class="s1">throw new Error(</span><span class="s3">\n\t            </span><span class="s1">'original.line and original.column are not numbers -- you probably meant to omit ' +</span><span class="s3">\n\t            </span><span class="s1">'the original mapping entirely and only map the generated position. If so, pass ' +</span><span class="s3">\n\t            </span><span class="s1">'null for the original mapping instead of an object with empty or null values.'</span><span class="s3">\n\t        </span><span class="s1">);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">if (aGenerated &amp;&amp; 'line' in aGenerated &amp;&amp; 'column' in aGenerated</span><span class="s3">\n\t        </span><span class="s1">&amp;&amp; aGenerated.line &gt; 0 &amp;&amp; aGenerated.column &gt;= 0</span><span class="s3">\n\t        </span><span class="s1">&amp;&amp; !aOriginal &amp;&amp; !aSource &amp;&amp; !aName) {</span><span class="s3">\n\t      </span><span class="s1">// Case 1.</span><span class="s3">\n\t      </span><span class="s1">return;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">else if (aGenerated &amp;&amp; 'line' in aGenerated &amp;&amp; 'column' in aGenerated</span><span class="s3">\n\t             </span><span class="s1">&amp;&amp; aOriginal &amp;&amp; 'line' in aOriginal &amp;&amp; 'column' in aOriginal</span><span class="s3">\n\t             </span><span class="s1">&amp;&amp; aGenerated.line &gt; 0 &amp;&amp; aGenerated.column &gt;= 0</span><span class="s3">\n\t             </span><span class="s1">&amp;&amp; aOriginal.line &gt; 0 &amp;&amp; aOriginal.column &gt;= 0</span><span class="s3">\n\t             </span><span class="s1">&amp;&amp; aSource) {</span><span class="s3">\n\t      </span><span class="s1">// Cases 2 and 3.</span><span class="s3">\n\t      </span><span class="s1">return;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">else {</span><span class="s3">\n\t      </span><span class="s1">throw new Error('Invalid mapping: ' + JSON.stringify({</span><span class="s3">\n\t        </span><span class="s1">generated: aGenerated,</span><span class="s3">\n\t        </span><span class="s1">source: aSource,</span><span class="s3">\n\t        </span><span class="s1">original: aOriginal,</span><span class="s3">\n\t        </span><span class="s1">name: aName</span><span class="s3">\n\t      </span><span class="s1">}));</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Serialize the accumulated mappings in to the stream of base 64 VLQs</span><span class="s3">\n\t </span><span class="s1">* specified by the source map format.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceMapGenerator.prototype._serializeMappings =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapGenerator_serializeMappings() {</span><span class="s3">\n\t    </span><span class="s1">var previousGeneratedColumn = 0;</span><span class="s3">\n\t    </span><span class="s1">var previousGeneratedLine = 1;</span><span class="s3">\n\t    </span><span class="s1">var previousOriginalColumn = 0;</span><span class="s3">\n\t    </span><span class="s1">var previousOriginalLine = 0;</span><span class="s3">\n\t    </span><span class="s1">var previousName = 0;</span><span class="s3">\n\t    </span><span class="s1">var previousSource = 0;</span><span class="s3">\n\t    </span><span class="s1">var result = '';</span><span class="s3">\n\t    </span><span class="s1">var next;</span><span class="s3">\n\t    </span><span class="s1">var mapping;</span><span class="s3">\n\t    </span><span class="s1">var nameIdx;</span><span class="s3">\n\t    </span><span class="s1">var sourceIdx;</span><span class="s3">\n\t\n\t    </span><span class="s1">var mappings = this._mappings.toArray();</span><span class="s3">\n\t    </span><span class="s1">for (var i = 0, len = mappings.length; i &lt; len; i++) {</span><span class="s3">\n\t      </span><span class="s1">mapping = mappings[i];</span><span class="s3">\n\t      </span><span class="s1">next = ''</span><span class="s3">\n\t\n\t      </span><span class="s1">if (mapping.generatedLine !== previousGeneratedLine) {</span><span class="s3">\n\t        </span><span class="s1">previousGeneratedColumn = 0;</span><span class="s3">\n\t        </span><span class="s1">while (mapping.generatedLine !== previousGeneratedLine) {</span><span class="s3">\n\t          </span><span class="s1">next += ';';</span><span class="s3">\n\t          </span><span class="s1">previousGeneratedLine++;</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">else {</span><span class="s3">\n\t        </span><span class="s1">if (i &gt; 0) {</span><span class="s3">\n\t          </span><span class="s1">if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {</span><span class="s3">\n\t            </span><span class="s1">continue;</span><span class="s3">\n\t          </span><span class="s1">}</span><span class="s3">\n\t          </span><span class="s1">next += ',';</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t\n\t      </span><span class="s1">next += base64VLQ.encode(mapping.generatedColumn</span><span class="s3">\n\t                                 </span><span class="s1">- previousGeneratedColumn);</span><span class="s3">\n\t      </span><span class="s1">previousGeneratedColumn = mapping.generatedColumn;</span><span class="s3">\n\t\n\t      </span><span class="s1">if (mapping.source != null) {</span><span class="s3">\n\t        </span><span class="s1">sourceIdx = this._sources.indexOf(mapping.source);</span><span class="s3">\n\t        </span><span class="s1">next += base64VLQ.encode(sourceIdx - previousSource);</span><span class="s3">\n\t        </span><span class="s1">previousSource = sourceIdx;</span><span class="s3">\n\t\n\t        </span><span class="s1">// lines are stored 0-based in SourceMap spec version 3</span><span class="s3">\n\t        </span><span class="s1">next += base64VLQ.encode(mapping.originalLine - 1</span><span class="s3">\n\t                                   </span><span class="s1">- previousOriginalLine);</span><span class="s3">\n\t        </span><span class="s1">previousOriginalLine = mapping.originalLine - 1;</span><span class="s3">\n\t\n\t        </span><span class="s1">next += base64VLQ.encode(mapping.originalColumn</span><span class="s3">\n\t                                   </span><span class="s1">- previousOriginalColumn);</span><span class="s3">\n\t        </span><span class="s1">previousOriginalColumn = mapping.originalColumn;</span><span class="s3">\n\t\n\t        </span><span class="s1">if (mapping.name != null) {</span><span class="s3">\n\t          </span><span class="s1">nameIdx = this._names.indexOf(mapping.name);</span><span class="s3">\n\t          </span><span class="s1">next += base64VLQ.encode(nameIdx - previousName);</span><span class="s3">\n\t          </span><span class="s1">previousName = nameIdx;</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t\n\t      </span><span class="s1">result += next;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">return result;</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">SourceMapGenerator.prototype._generateSourcesContent =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {</span><span class="s3">\n\t    </span><span class="s1">return aSources.map(function (source) {</span><span class="s3">\n\t      </span><span class="s1">if (!this._sourcesContents) {</span><span class="s3">\n\t        </span><span class="s1">return null;</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">if (aSourceRoot != null) {</span><span class="s3">\n\t        </span><span class="s1">source = util.relative(aSourceRoot, source);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">var key = util.toSetString(source);</span><span class="s3">\n\t      </span><span class="s1">return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)</span><span class="s3">\n\t        </span><span class="s1">? this._sourcesContents[key]</span><span class="s3">\n\t        </span><span class="s1">: null;</span><span class="s3">\n\t    </span><span class="s1">}, this);</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Externalize the source map.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceMapGenerator.prototype.toJSON =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapGenerator_toJSON() {</span><span class="s3">\n\t    </span><span class="s1">var map = {</span><span class="s3">\n\t      </span><span class="s1">version: this._version,</span><span class="s3">\n\t      </span><span class="s1">sources: this._sources.toArray(),</span><span class="s3">\n\t      </span><span class="s1">names: this._names.toArray(),</span><span class="s3">\n\t      </span><span class="s1">mappings: this._serializeMappings()</span><span class="s3">\n\t    </span><span class="s1">};</span><span class="s3">\n\t    </span><span class="s1">if (this._file != null) {</span><span class="s3">\n\t      </span><span class="s1">map.file = this._file;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">if (this._sourceRoot != null) {</span><span class="s3">\n\t      </span><span class="s1">map.sourceRoot = this._sourceRoot;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">if (this._sourcesContents) {</span><span class="s3">\n\t      </span><span class="s1">map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">return map;</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Render the source map being generated to a string.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceMapGenerator.prototype.toString =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapGenerator_toString() {</span><span class="s3">\n\t    </span><span class="s1">return JSON.stringify(this.toJSON());</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">exports.SourceMapGenerator = SourceMapGenerator;</span><span class="s3">\n\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 2 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\t</span><span class="s1">/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n\t</span><span class="s1">/*</span><span class="s3">\n\t </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n\t </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n\t </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* Based on the Base 64 VLQ implementation in Closure Compiler:</span><span class="s3">\n\t </span><span class="s1">* https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* Copyright 2011 The Closure Compiler Authors. All rights reserved.</span><span class="s3">\n\t </span><span class="s1">* Redistribution and use in source and binary forms, with or without</span><span class="s3">\n\t </span><span class="s1">* modification, are permitted provided that the following conditions are</span><span class="s3">\n\t </span><span class="s1">* met:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*  * Redistributions of source code must retain the above copyright</span><span class="s3">\n\t </span><span class="s1">*    notice, this list of conditions and the following disclaimer.</span><span class="s3">\n\t </span><span class="s1">*  * Redistributions in binary form must reproduce the above</span><span class="s3">\n\t </span><span class="s1">*    copyright notice, this list of conditions and the following</span><span class="s3">\n\t </span><span class="s1">*    disclaimer in the documentation and/or other materials provided</span><span class="s3">\n\t </span><span class="s1">*    with the distribution.</span><span class="s3">\n\t </span><span class="s1">*  * Neither the name of Google Inc. nor the names of its</span><span class="s3">\n\t </span><span class="s1">*    contributors may be used to endorse or promote products derived</span><span class="s3">\n\t </span><span class="s1">*    from this software without specific prior written permission.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span><span class="s3">\n\t </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">AS IS</span><span class="s3">\&quot; </span><span class="s1">AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span><span class="s3">\n\t </span><span class="s1">* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span><span class="s3">\n\t </span><span class="s1">* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span><span class="s3">\n\t </span><span class="s1">* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span><span class="s3">\n\t </span><span class="s1">* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span><span class="s3">\n\t </span><span class="s1">* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span><span class="s3">\n\t </span><span class="s1">* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span><span class="s3">\n\t </span><span class="s1">* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span><span class="s3">\n\t </span><span class="s1">* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span><span class="s3">\n\t </span><span class="s1">* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t\n\t</span><span class="s1">var base64 = __webpack_require__(3);</span><span class="s3">\n\t\n\t</span><span class="s1">// A single base 64 digit can contain 6 bits of data. For the base 64 variable</span><span class="s3">\n\t</span><span class="s1">// length quantities we use in the source map spec, the first bit is the sign,</span><span class="s3">\n\t</span><span class="s1">// the next four bits are the actual value, and the 6th bit is the</span><span class="s3">\n\t</span><span class="s1">// continuation bit. The continuation bit tells us whether there are more</span><span class="s3">\n\t</span><span class="s1">// digits in this value following this digit.</span><span class="s3">\n\t</span><span class="s1">//</span><span class="s3">\n\t</span><span class="s1">//   Continuation</span><span class="s3">\n\t</span><span class="s1">//   |    Sign</span><span class="s3">\n\t</span><span class="s1">//   |    |</span><span class="s3">\n\t</span><span class="s1">//   V    V</span><span class="s3">\n\t</span><span class="s1">//   101011</span><span class="s3">\n\t\n\t</span><span class="s1">var VLQ_BASE_SHIFT = 5;</span><span class="s3">\n\t\n\t</span><span class="s1">// binary: 100000</span><span class="s3">\n\t</span><span class="s1">var VLQ_BASE = 1 &lt;&lt; VLQ_BASE_SHIFT;</span><span class="s3">\n\t\n\t</span><span class="s1">// binary: 011111</span><span class="s3">\n\t</span><span class="s1">var VLQ_BASE_MASK = VLQ_BASE - 1;</span><span class="s3">\n\t\n\t</span><span class="s1">// binary: 100000</span><span class="s3">\n\t</span><span class="s1">var VLQ_CONTINUATION_BIT = VLQ_BASE;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Converts from a two-complement value to a value where the sign bit is</span><span class="s3">\n\t </span><span class="s1">* placed in the least significant bit.  For example, as decimals:</span><span class="s3">\n\t </span><span class="s1">*   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)</span><span class="s3">\n\t </span><span class="s1">*   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function toVLQSigned(aValue) {</span><span class="s3">\n\t  </span><span class="s1">return aValue &lt; 0</span><span class="s3">\n\t    </span><span class="s1">? ((-aValue) &lt;&lt; 1) + 1</span><span class="s3">\n\t    </span><span class="s1">: (aValue &lt;&lt; 1) + 0;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Converts to a two-complement value from a value where the sign bit is</span><span class="s3">\n\t </span><span class="s1">* placed in the least significant bit.  For example, as decimals:</span><span class="s3">\n\t </span><span class="s1">*   2 (10 binary) becomes 1, 3 (11 binary) becomes -1</span><span class="s3">\n\t </span><span class="s1">*   4 (100 binary) becomes 2, 5 (101 binary) becomes -2</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function fromVLQSigned(aValue) {</span><span class="s3">\n\t  </span><span class="s1">var isNegative = (aValue &amp; 1) === 1;</span><span class="s3">\n\t  </span><span class="s1">var shifted = aValue &gt;&gt; 1;</span><span class="s3">\n\t  </span><span class="s1">return isNegative</span><span class="s3">\n\t    </span><span class="s1">? -shifted</span><span class="s3">\n\t    </span><span class="s1">: shifted;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Returns the base 64 VLQ encoded value.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">exports.encode = function base64VLQ_encode(aValue) {</span><span class="s3">\n\t  </span><span class="s1">var encoded = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n\t  </span><span class="s1">var digit;</span><span class="s3">\n\t\n\t  </span><span class="s1">var vlq = toVLQSigned(aValue);</span><span class="s3">\n\t\n\t  </span><span class="s1">do {</span><span class="s3">\n\t    </span><span class="s1">digit = vlq &amp; VLQ_BASE_MASK;</span><span class="s3">\n\t    </span><span class="s1">vlq &gt;&gt;&gt;= VLQ_BASE_SHIFT;</span><span class="s3">\n\t    </span><span class="s1">if (vlq &gt; 0) {</span><span class="s3">\n\t      </span><span class="s1">// There are still more digits in this value, so we must make sure the</span><span class="s3">\n\t      </span><span class="s1">// continuation bit is marked.</span><span class="s3">\n\t      </span><span class="s1">digit |= VLQ_CONTINUATION_BIT;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">encoded += base64.encode(digit);</span><span class="s3">\n\t  </span><span class="s1">} while (vlq &gt; 0);</span><span class="s3">\n\t\n\t  </span><span class="s1">return encoded;</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Decodes the next base 64 VLQ value from the given string and returns the</span><span class="s3">\n\t </span><span class="s1">* value and the rest of the string via the out parameter.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {</span><span class="s3">\n\t  </span><span class="s1">var strLen = aStr.length;</span><span class="s3">\n\t  </span><span class="s1">var result = 0;</span><span class="s3">\n\t  </span><span class="s1">var shift = 0;</span><span class="s3">\n\t  </span><span class="s1">var continuation, digit;</span><span class="s3">\n\t\n\t  </span><span class="s1">do {</span><span class="s3">\n\t    </span><span class="s1">if (aIndex &gt;= strLen) {</span><span class="s3">\n\t      </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Expected more digits in base 64 VLQ value.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">digit = base64.decode(aStr.charCodeAt(aIndex++));</span><span class="s3">\n\t    </span><span class="s1">if (digit === -1) {</span><span class="s3">\n\t      </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Invalid base64 digit: </span><span class="s3">\&quot; </span><span class="s1">+ aStr.charAt(aIndex - 1));</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">continuation = !!(digit &amp; VLQ_CONTINUATION_BIT);</span><span class="s3">\n\t    </span><span class="s1">digit &amp;= VLQ_BASE_MASK;</span><span class="s3">\n\t    </span><span class="s1">result = result + (digit &lt;&lt; shift);</span><span class="s3">\n\t    </span><span class="s1">shift += VLQ_BASE_SHIFT;</span><span class="s3">\n\t  </span><span class="s1">} while (continuation);</span><span class="s3">\n\t\n\t  </span><span class="s1">aOutParam.value = fromVLQSigned(result);</span><span class="s3">\n\t  </span><span class="s1">aOutParam.rest = aIndex;</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 3 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports) {</span><span class="s3">\n\n\t</span><span class="s1">/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n\t</span><span class="s1">/*</span><span class="s3">\n\t </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n\t </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n\t </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t\n\t</span><span class="s1">var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Encode an integer in the range of 0 to 63 to a single base 64 digit.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">exports.encode = function (number) {</span><span class="s3">\n\t  </span><span class="s1">if (0 &lt;= number &amp;&amp; number &lt; intToCharMap.length) {</span><span class="s3">\n\t    </span><span class="s1">return intToCharMap[number];</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Must be between 0 and 63: </span><span class="s3">\&quot; </span><span class="s1">+ number);</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Decode a single base 64 character code digit to an integer. Returns -1 on</span><span class="s3">\n\t </span><span class="s1">* failure.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">exports.decode = function (charCode) {</span><span class="s3">\n\t  </span><span class="s1">var bigA = 65;     // 'A'</span><span class="s3">\n\t  </span><span class="s1">var bigZ = 90;     // 'Z'</span><span class="s3">\n\t\n\t  </span><span class="s1">var littleA = 97;  // 'a'</span><span class="s3">\n\t  </span><span class="s1">var littleZ = 122; // 'z'</span><span class="s3">\n\t\n\t  </span><span class="s1">var zero = 48;     // '0'</span><span class="s3">\n\t  </span><span class="s1">var nine = 57;     // '9'</span><span class="s3">\n\t\n\t  </span><span class="s1">var plus = 43;     // '+'</span><span class="s3">\n\t  </span><span class="s1">var slash = 47;    // '/'</span><span class="s3">\n\t\n\t  </span><span class="s1">var littleOffset = 26;</span><span class="s3">\n\t  </span><span class="s1">var numberOffset = 52;</span><span class="s3">\n\t\n\t  </span><span class="s1">// 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><span class="s3">\n\t  </span><span class="s1">if (bigA &lt;= charCode &amp;&amp; charCode &lt;= bigZ) {</span><span class="s3">\n\t    </span><span class="s1">return (charCode - bigA);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">// 26 - 51: abcdefghijklmnopqrstuvwxyz</span><span class="s3">\n\t  </span><span class="s1">if (littleA &lt;= charCode &amp;&amp; charCode &lt;= littleZ) {</span><span class="s3">\n\t    </span><span class="s1">return (charCode - littleA + littleOffset);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">// 52 - 61: 0123456789</span><span class="s3">\n\t  </span><span class="s1">if (zero &lt;= charCode &amp;&amp; charCode &lt;= nine) {</span><span class="s3">\n\t    </span><span class="s1">return (charCode - zero + numberOffset);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">// 62: +</span><span class="s3">\n\t  </span><span class="s1">if (charCode == plus) {</span><span class="s3">\n\t    </span><span class="s1">return 62;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">// 63: /</span><span class="s3">\n\t  </span><span class="s1">if (charCode == slash) {</span><span class="s3">\n\t    </span><span class="s1">return 63;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">// Invalid base64 digit.</span><span class="s3">\n\t  </span><span class="s1">return -1;</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 4 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports) {</span><span class="s3">\n\n\t</span><span class="s1">/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n\t</span><span class="s1">/*</span><span class="s3">\n\t </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n\t </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n\t </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* This is a helper function for getting values from parameter/options</span><span class="s3">\n\t </span><span class="s1">* objects.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param args The object we are extracting values from</span><span class="s3">\n\t </span><span class="s1">* @param name The name of the property we are getting.</span><span class="s3">\n\t </span><span class="s1">* @param defaultValue An optional value to return if the property is missing</span><span class="s3">\n\t </span><span class="s1">* from the object. If this is not specified and the property is missing, an</span><span class="s3">\n\t </span><span class="s1">* error will be thrown.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function getArg(aArgs, aName, aDefaultValue) {</span><span class="s3">\n\t  </span><span class="s1">if (aName in aArgs) {</span><span class="s3">\n\t    </span><span class="s1">return aArgs[aName];</span><span class="s3">\n\t  </span><span class="s1">} else if (arguments.length === 3) {</span><span class="s3">\n\t    </span><span class="s1">return aDefaultValue;</span><span class="s3">\n\t  </span><span class="s1">} else {</span><span class="s3">\n\t    </span><span class="s1">throw new Error('</span><span class="s3">\&quot;</span><span class="s1">' + aName + '</span><span class="s3">\&quot; </span><span class="s1">is a required argument.');</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">exports.getArg = getArg;</span><span class="s3">\n\t\n\t</span><span class="s1">var urlRegexp = /^(?:([</span><span class="s3">\\</span><span class="s1">w+</span><span class="s3">\\</span><span class="s1">-.]+):)?</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/(?:(</span><span class="s3">\\</span><span class="s1">w+:</span><span class="s3">\\</span><span class="s1">w+)@)?([</span><span class="s3">\\</span><span class="s1">w.-]*)(?::(</span><span class="s3">\\</span><span class="s1">d+))?(.*)$/;</span><span class="s3">\n\t</span><span class="s1">var dataUrlRegexp = /^data:.+</span><span class="s3">\\</span><span class="s1">,.+$/;</span><span class="s3">\n\t\n\t</span><span class="s1">function urlParse(aUrl) {</span><span class="s3">\n\t  </span><span class="s1">var match = aUrl.match(urlRegexp);</span><span class="s3">\n\t  </span><span class="s1">if (!match) {</span><span class="s3">\n\t    </span><span class="s1">return null;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return {</span><span class="s3">\n\t    </span><span class="s1">scheme: match[1],</span><span class="s3">\n\t    </span><span class="s1">auth: match[2],</span><span class="s3">\n\t    </span><span class="s1">host: match[3],</span><span class="s3">\n\t    </span><span class="s1">port: match[4],</span><span class="s3">\n\t    </span><span class="s1">path: match[5]</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">exports.urlParse = urlParse;</span><span class="s3">\n\t\n\t</span><span class="s1">function urlGenerate(aParsedUrl) {</span><span class="s3">\n\t  </span><span class="s1">var url = '';</span><span class="s3">\n\t  </span><span class="s1">if (aParsedUrl.scheme) {</span><span class="s3">\n\t    </span><span class="s1">url += aParsedUrl.scheme + ':';</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">url += '//';</span><span class="s3">\n\t  </span><span class="s1">if (aParsedUrl.auth) {</span><span class="s3">\n\t    </span><span class="s1">url += aParsedUrl.auth + '@';</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">if (aParsedUrl.host) {</span><span class="s3">\n\t    </span><span class="s1">url += aParsedUrl.host;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">if (aParsedUrl.port) {</span><span class="s3">\n\t    </span><span class="s1">url += </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ aParsedUrl.port</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">if (aParsedUrl.path) {</span><span class="s3">\n\t    </span><span class="s1">url += aParsedUrl.path;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return url;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">exports.urlGenerate = urlGenerate;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Normalizes a path, or the path portion of a URL:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* - Replaces consecutive slashes with one slash.</span><span class="s3">\n\t </span><span class="s1">* - Removes unnecessary '.' parts.</span><span class="s3">\n\t </span><span class="s1">* - Removes unnecessary '&lt;dir&gt;/..' parts.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* Based on code in the Node.js 'path' core module.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param aPath The path or url to normalize.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function normalize(aPath) {</span><span class="s3">\n\t  </span><span class="s1">var path = aPath;</span><span class="s3">\n\t  </span><span class="s1">var url = urlParse(aPath);</span><span class="s3">\n\t  </span><span class="s1">if (url) {</span><span class="s3">\n\t    </span><span class="s1">if (!url.path) {</span><span class="s3">\n\t      </span><span class="s1">return aPath;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">path = url.path;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">var isAbsolute = exports.isAbsolute(path);</span><span class="s3">\n\t\n\t  </span><span class="s1">var parts = path.split(/</span><span class="s3">\\</span><span class="s1">/+/);</span><span class="s3">\n\t  </span><span class="s1">for (var part, up = 0, i = parts.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n\t    </span><span class="s1">part = parts[i];</span><span class="s3">\n\t    </span><span class="s1">if (part === '.') {</span><span class="s3">\n\t      </span><span class="s1">parts.splice(i, 1);</span><span class="s3">\n\t    </span><span class="s1">} else if (part === '..') {</span><span class="s3">\n\t      </span><span class="s1">up++;</span><span class="s3">\n\t    </span><span class="s1">} else if (up &gt; 0) {</span><span class="s3">\n\t      </span><span class="s1">if (part === '') {</span><span class="s3">\n\t        </span><span class="s1">// The first part is blank if the path is absolute. Trying to go</span><span class="s3">\n\t        </span><span class="s1">// above the root is a no-op. Therefore we can remove all '..' parts</span><span class="s3">\n\t        </span><span class="s1">// directly after the root.</span><span class="s3">\n\t        </span><span class="s1">parts.splice(i + 1, up);</span><span class="s3">\n\t        </span><span class="s1">up = 0;</span><span class="s3">\n\t      </span><span class="s1">} else {</span><span class="s3">\n\t        </span><span class="s1">parts.splice(i, 2);</span><span class="s3">\n\t        </span><span class="s1">up--;</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">path = parts.join('/');</span><span class="s3">\n\t\n\t  </span><span class="s1">if (path === '') {</span><span class="s3">\n\t    </span><span class="s1">path = isAbsolute ? '/' : '.';</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">if (url) {</span><span class="s3">\n\t    </span><span class="s1">url.path = path;</span><span class="s3">\n\t    </span><span class="s1">return urlGenerate(url);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return path;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">exports.normalize = normalize;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Joins two paths/URLs.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param aRoot The root path or URL.</span><span class="s3">\n\t </span><span class="s1">* @param aPath The path or URL to be joined with the root.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* - If aPath is a URL or a data URI, aPath is returned, unless aPath is a</span><span class="s3">\n\t </span><span class="s1">*   scheme-relative URL: Then the scheme of aRoot, if any, is prepended</span><span class="s3">\n\t </span><span class="s1">*   first.</span><span class="s3">\n\t </span><span class="s1">* - Otherwise aPath is a path. If aRoot is a URL, then its path portion</span><span class="s3">\n\t </span><span class="s1">*   is updated with the result and aRoot is returned. Otherwise the result</span><span class="s3">\n\t </span><span class="s1">*   is returned.</span><span class="s3">\n\t </span><span class="s1">*   - If aPath is absolute, the result is aPath.</span><span class="s3">\n\t </span><span class="s1">*   - Otherwise the two paths are joined with a slash.</span><span class="s3">\n\t </span><span class="s1">* - Joining for example 'http://' and 'www.example.com' is also supported.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function join(aRoot, aPath) {</span><span class="s3">\n\t  </span><span class="s1">if (aRoot === </span><span class="s3">\&quot;\&quot;</span><span class="s1">) {</span><span class="s3">\n\t    </span><span class="s1">aRoot = </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">if (aPath === </span><span class="s3">\&quot;\&quot;</span><span class="s1">) {</span><span class="s3">\n\t    </span><span class="s1">aPath = </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">var aPathUrl = urlParse(aPath);</span><span class="s3">\n\t  </span><span class="s1">var aRootUrl = urlParse(aRoot);</span><span class="s3">\n\t  </span><span class="s1">if (aRootUrl) {</span><span class="s3">\n\t    </span><span class="s1">aRoot = aRootUrl.path || '/';</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">// `join(foo, '//www.example.org')`</span><span class="s3">\n\t  </span><span class="s1">if (aPathUrl &amp;&amp; !aPathUrl.scheme) {</span><span class="s3">\n\t    </span><span class="s1">if (aRootUrl) {</span><span class="s3">\n\t      </span><span class="s1">aPathUrl.scheme = aRootUrl.scheme;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">return urlGenerate(aPathUrl);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">if (aPathUrl || aPath.match(dataUrlRegexp)) {</span><span class="s3">\n\t    </span><span class="s1">return aPath;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">// `join('http://', 'www.example.com')`</span><span class="s3">\n\t  </span><span class="s1">if (aRootUrl &amp;&amp; !aRootUrl.host &amp;&amp; !aRootUrl.path) {</span><span class="s3">\n\t    </span><span class="s1">aRootUrl.host = aPath;</span><span class="s3">\n\t    </span><span class="s1">return urlGenerate(aRootUrl);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">var joined = aPath.charAt(0) === '/'</span><span class="s3">\n\t    </span><span class="s1">? aPath</span><span class="s3">\n\t    </span><span class="s1">: normalize(aRoot.replace(/</span><span class="s3">\\</span><span class="s1">/+$/, '') + '/' + aPath);</span><span class="s3">\n\t\n\t  </span><span class="s1">if (aRootUrl) {</span><span class="s3">\n\t    </span><span class="s1">aRootUrl.path = joined;</span><span class="s3">\n\t    </span><span class="s1">return urlGenerate(aRootUrl);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return joined;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">exports.join = join;</span><span class="s3">\n\t\n\t</span><span class="s1">exports.isAbsolute = function (aPath) {</span><span class="s3">\n\t  </span><span class="s1">return aPath.charAt(0) === '/' || urlRegexp.test(aPath);</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Make a path relative to a URL or another path.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param aRoot The root path or URL.</span><span class="s3">\n\t </span><span class="s1">* @param aPath The path or URL to be made relative to aRoot.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function relative(aRoot, aPath) {</span><span class="s3">\n\t  </span><span class="s1">if (aRoot === </span><span class="s3">\&quot;\&quot;</span><span class="s1">) {</span><span class="s3">\n\t    </span><span class="s1">aRoot = </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">aRoot = aRoot.replace(/</span><span class="s3">\\</span><span class="s1">/$/, '');</span><span class="s3">\n\t\n\t  </span><span class="s1">// It is possible for the path to be above the root. In this case, simply</span><span class="s3">\n\t  </span><span class="s1">// checking whether the root is a prefix of the path won't work. Instead, we</span><span class="s3">\n\t  </span><span class="s1">// need to remove components from the root one by one, until either we find</span><span class="s3">\n\t  </span><span class="s1">// a prefix that fits, or we run out of components to remove.</span><span class="s3">\n\t  </span><span class="s1">var level = 0;</span><span class="s3">\n\t  </span><span class="s1">while (aPath.indexOf(aRoot + '/') !== 0) {</span><span class="s3">\n\t    </span><span class="s1">var index = aRoot.lastIndexOf(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t    </span><span class="s1">if (index &lt; 0) {</span><span class="s3">\n\t      </span><span class="s1">return aPath;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">// If the only part of the root that is left is the scheme (i.e. http://,</span><span class="s3">\n\t    </span><span class="s1">// file:///, etc.), one or more slashes (/), or simply nothing at all, we</span><span class="s3">\n\t    </span><span class="s1">// have exhausted all components, so the path is not relative to the root.</span><span class="s3">\n\t    </span><span class="s1">aRoot = aRoot.slice(0, index);</span><span class="s3">\n\t    </span><span class="s1">if (aRoot.match(/^([^</span><span class="s3">\\</span><span class="s1">/]+:</span><span class="s3">\\</span><span class="s1">/)?</span><span class="s3">\\</span><span class="s1">/*$/)) {</span><span class="s3">\n\t      </span><span class="s1">return aPath;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">++level;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">// Make sure we add a </span><span class="s3">\&quot;</span><span class="s1">../</span><span class="s3">\&quot; </span><span class="s1">for each component we removed from the root.</span><span class="s3">\n\t  </span><span class="s1">return Array(level + 1).join(</span><span class="s3">\&quot;</span><span class="s1">../</span><span class="s3">\&quot;</span><span class="s1">) + aPath.substr(aRoot.length + 1);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">exports.relative = relative;</span><span class="s3">\n\t\n\t</span><span class="s1">var supportsNullProto = (function () {</span><span class="s3">\n\t  </span><span class="s1">var obj = Object.create(null);</span><span class="s3">\n\t  </span><span class="s1">return !('__proto__' in obj);</span><span class="s3">\n\t</span><span class="s1">}());</span><span class="s3">\n\t\n\t</span><span class="s1">function identity (s) {</span><span class="s3">\n\t  </span><span class="s1">return s;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Because behavior goes wacky when you set `__proto__` on objects, we</span><span class="s3">\n\t </span><span class="s1">* have to prefix all the strings in our set with an arbitrary character.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* See https://github.com/mozilla/source-map/pull/31 and</span><span class="s3">\n\t </span><span class="s1">* https://github.com/mozilla/source-map/issues/30</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param String aStr</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function toSetString(aStr) {</span><span class="s3">\n\t  </span><span class="s1">if (isProtoString(aStr)) {</span><span class="s3">\n\t    </span><span class="s1">return '$' + aStr;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">return aStr;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">exports.toSetString = supportsNullProto ? identity : toSetString;</span><span class="s3">\n\t\n\t</span><span class="s1">function fromSetString(aStr) {</span><span class="s3">\n\t  </span><span class="s1">if (isProtoString(aStr)) {</span><span class="s3">\n\t    </span><span class="s1">return aStr.slice(1);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">return aStr;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">exports.fromSetString = supportsNullProto ? identity : fromSetString;</span><span class="s3">\n\t\n\t</span><span class="s1">function isProtoString(s) {</span><span class="s3">\n\t  </span><span class="s1">if (!s) {</span><span class="s3">\n\t    </span><span class="s1">return false;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">var length = s.length;</span><span class="s3">\n\t\n\t  </span><span class="s1">if (length &lt; 9 /* </span><span class="s3">\&quot;</span><span class="s1">__proto__</span><span class="s3">\&quot;</span><span class="s1">.length */) {</span><span class="s3">\n\t    </span><span class="s1">return false;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||</span><span class="s3">\n\t      </span><span class="s1">s.charCodeAt(length - 2) !== 95  /* '_' */ ||</span><span class="s3">\n\t      </span><span class="s1">s.charCodeAt(length - 3) !== 111 /* 'o' */ ||</span><span class="s3">\n\t      </span><span class="s1">s.charCodeAt(length - 4) !== 116 /* 't' */ ||</span><span class="s3">\n\t      </span><span class="s1">s.charCodeAt(length - 5) !== 111 /* 'o' */ ||</span><span class="s3">\n\t      </span><span class="s1">s.charCodeAt(length - 6) !== 114 /* 'r' */ ||</span><span class="s3">\n\t      </span><span class="s1">s.charCodeAt(length - 7) !== 112 /* 'p' */ ||</span><span class="s3">\n\t      </span><span class="s1">s.charCodeAt(length - 8) !== 95  /* '_' */ ||</span><span class="s3">\n\t      </span><span class="s1">s.charCodeAt(length - 9) !== 95  /* '_' */) {</span><span class="s3">\n\t    </span><span class="s1">return false;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">for (var i = length - 10; i &gt;= 0; i--) {</span><span class="s3">\n\t    </span><span class="s1">if (s.charCodeAt(i) !== 36 /* '$' */) {</span><span class="s3">\n\t      </span><span class="s1">return false;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">return true;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Comparator between two mappings where the original positions are compared.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* Optionally pass in `true` as `onlyCompareGenerated` to consider two</span><span class="s3">\n\t </span><span class="s1">* mappings with the same original source/line/column, but different generated</span><span class="s3">\n\t </span><span class="s1">* line and column the same. Useful when searching for a mapping with a</span><span class="s3">\n\t </span><span class="s1">* stubbed out mapping.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {</span><span class="s3">\n\t  </span><span class="s1">var cmp = strcmp(mappingA.source, mappingB.source);</span><span class="s3">\n\t  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n\t    </span><span class="s1">return cmp;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">cmp = mappingA.originalLine - mappingB.originalLine;</span><span class="s3">\n\t  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n\t    </span><span class="s1">return cmp;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">cmp = mappingA.originalColumn - mappingB.originalColumn;</span><span class="s3">\n\t  </span><span class="s1">if (cmp !== 0 || onlyCompareOriginal) {</span><span class="s3">\n\t    </span><span class="s1">return cmp;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">cmp = mappingA.generatedColumn - mappingB.generatedColumn;</span><span class="s3">\n\t  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n\t    </span><span class="s1">return cmp;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">cmp = mappingA.generatedLine - mappingB.generatedLine;</span><span class="s3">\n\t  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n\t    </span><span class="s1">return cmp;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">return strcmp(mappingA.name, mappingB.name);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">exports.compareByOriginalPositions = compareByOriginalPositions;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Comparator between two mappings with deflated source and name indices where</span><span class="s3">\n\t </span><span class="s1">* the generated positions are compared.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* Optionally pass in `true` as `onlyCompareGenerated` to consider two</span><span class="s3">\n\t </span><span class="s1">* mappings with the same generated line and column, but different</span><span class="s3">\n\t </span><span class="s1">* source/name/original line and column the same. Useful when searching for a</span><span class="s3">\n\t </span><span class="s1">* mapping with a stubbed out mapping.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {</span><span class="s3">\n\t  </span><span class="s1">var cmp = mappingA.generatedLine - mappingB.generatedLine;</span><span class="s3">\n\t  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n\t    </span><span class="s1">return cmp;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">cmp = mappingA.generatedColumn - mappingB.generatedColumn;</span><span class="s3">\n\t  </span><span class="s1">if (cmp !== 0 || onlyCompareGenerated) {</span><span class="s3">\n\t    </span><span class="s1">return cmp;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">cmp = strcmp(mappingA.source, mappingB.source);</span><span class="s3">\n\t  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n\t    </span><span class="s1">return cmp;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">cmp = mappingA.originalLine - mappingB.originalLine;</span><span class="s3">\n\t  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n\t    </span><span class="s1">return cmp;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">cmp = mappingA.originalColumn - mappingB.originalColumn;</span><span class="s3">\n\t  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n\t    </span><span class="s1">return cmp;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">return strcmp(mappingA.name, mappingB.name);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;</span><span class="s3">\n\t\n\t</span><span class="s1">function strcmp(aStr1, aStr2) {</span><span class="s3">\n\t  </span><span class="s1">if (aStr1 === aStr2) {</span><span class="s3">\n\t    </span><span class="s1">return 0;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">if (aStr1 === null) {</span><span class="s3">\n\t    </span><span class="s1">return 1; // aStr2 !== null</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">if (aStr2 === null) {</span><span class="s3">\n\t    </span><span class="s1">return -1; // aStr1 !== null</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">if (aStr1 &gt; aStr2) {</span><span class="s3">\n\t    </span><span class="s1">return 1;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">return -1;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Comparator between two mappings with inflated source and name strings where</span><span class="s3">\n\t </span><span class="s1">* the generated positions are compared.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function compareByGeneratedPositionsInflated(mappingA, mappingB) {</span><span class="s3">\n\t  </span><span class="s1">var cmp = mappingA.generatedLine - mappingB.generatedLine;</span><span class="s3">\n\t  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n\t    </span><span class="s1">return cmp;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">cmp = mappingA.generatedColumn - mappingB.generatedColumn;</span><span class="s3">\n\t  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n\t    </span><span class="s1">return cmp;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">cmp = strcmp(mappingA.source, mappingB.source);</span><span class="s3">\n\t  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n\t    </span><span class="s1">return cmp;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">cmp = mappingA.originalLine - mappingB.originalLine;</span><span class="s3">\n\t  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n\t    </span><span class="s1">return cmp;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">cmp = mappingA.originalColumn - mappingB.originalColumn;</span><span class="s3">\n\t  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n\t    </span><span class="s1">return cmp;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">return strcmp(mappingA.name, mappingB.name);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Strip any JSON XSSI avoidance prefix from the string (as documented</span><span class="s3">\n\t </span><span class="s1">* in the source maps specification), and then parse the string as</span><span class="s3">\n\t </span><span class="s1">* JSON.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function parseSourceMapInput(str) {</span><span class="s3">\n\t  </span><span class="s1">return JSON.parse(str.replace(/^</span><span class="s3">\\</span><span class="s1">)]}'[^</span><span class="s3">\\</span><span class="s1">n]*</span><span class="s3">\\</span><span class="s1">n/, ''));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">exports.parseSourceMapInput = parseSourceMapInput;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Compute the URL of a source given the the source root, the source's</span><span class="s3">\n\t </span><span class="s1">* URL, and the source map's URL.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {</span><span class="s3">\n\t  </span><span class="s1">sourceURL = sourceURL || '';</span><span class="s3">\n\t\n\t  </span><span class="s1">if (sourceRoot) {</span><span class="s3">\n\t    </span><span class="s1">// This follows what Chrome does.</span><span class="s3">\n\t    </span><span class="s1">if (sourceRoot[sourceRoot.length - 1] !== '/' &amp;&amp; sourceURL[0] !== '/') {</span><span class="s3">\n\t      </span><span class="s1">sourceRoot += '/';</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">// The spec says:</span><span class="s3">\n\t    </span><span class="s1">//   Line 4: An optional source root, useful for relocating source</span><span class="s3">\n\t    </span><span class="s1">//   files on a server or removing repeated values in the</span><span class="s3">\n\t    </span><span class="s1">//   “sources” entry.  This value is prepended to the individual</span><span class="s3">\n\t    </span><span class="s1">//   entries in the “source” field.</span><span class="s3">\n\t    </span><span class="s1">sourceURL = sourceRoot + sourceURL;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">// Historically, SourceMapConsumer did not take the sourceMapURL as</span><span class="s3">\n\t  </span><span class="s1">// a parameter.  This mode is still somewhat supported, which is why</span><span class="s3">\n\t  </span><span class="s1">// this code block is conditional.  However, it's preferable to pass</span><span class="s3">\n\t  </span><span class="s1">// the source map URL to SourceMapConsumer, so that this function</span><span class="s3">\n\t  </span><span class="s1">// can implement the source URL resolution algorithm as outlined in</span><span class="s3">\n\t  </span><span class="s1">// the spec.  This block is basically the equivalent of:</span><span class="s3">\n\t  </span><span class="s1">//    new URL(sourceURL, sourceMapURL).toString()</span><span class="s3">\n\t  </span><span class="s1">// ... except it avoids using URL, which wasn't available in the</span><span class="s3">\n\t  </span><span class="s1">// older releases of node still supported by this library.</span><span class="s3">\n\t  </span><span class="s1">//</span><span class="s3">\n\t  </span><span class="s1">// The spec says:</span><span class="s3">\n\t  </span><span class="s1">//   If the sources are not absolute URLs after prepending of the</span><span class="s3">\n\t  </span><span class="s1">//   “sourceRoot”, the sources are resolved relative to the</span><span class="s3">\n\t  </span><span class="s1">//   SourceMap (like resolving script src in a html document).</span><span class="s3">\n\t  </span><span class="s1">if (sourceMapURL) {</span><span class="s3">\n\t    </span><span class="s1">var parsed = urlParse(sourceMapURL);</span><span class="s3">\n\t    </span><span class="s1">if (!parsed) {</span><span class="s3">\n\t      </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">sourceMapURL could not be parsed</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">if (parsed.path) {</span><span class="s3">\n\t      </span><span class="s1">// Strip the last path component, but keep the </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n\t      </span><span class="s1">var index = parsed.path.lastIndexOf('/');</span><span class="s3">\n\t      </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n\t        </span><span class="s1">parsed.path = parsed.path.substring(0, index + 1);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">sourceURL = join(urlGenerate(parsed), sourceURL);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">return normalize(sourceURL);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">exports.computeSourceURL = computeSourceURL;</span><span class="s3">\n\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 5 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\t</span><span class="s1">/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n\t</span><span class="s1">/*</span><span class="s3">\n\t </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n\t </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n\t </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t\n\t</span><span class="s1">var util = __webpack_require__(4);</span><span class="s3">\n\t</span><span class="s1">var has = Object.prototype.hasOwnProperty;</span><span class="s3">\n\t</span><span class="s1">var hasNativeMap = typeof Map !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* A data structure which is a combination of an array and a set. Adding a new</span><span class="s3">\n\t </span><span class="s1">* member is O(1), testing for membership is O(1), and finding the index of an</span><span class="s3">\n\t </span><span class="s1">* element is O(1). Removing elements from the set is not supported. Only</span><span class="s3">\n\t </span><span class="s1">* strings are supported for membership.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function ArraySet() {</span><span class="s3">\n\t  </span><span class="s1">this._array = [];</span><span class="s3">\n\t  </span><span class="s1">this._set = hasNativeMap ? new Map() : Object.create(null);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Static method for creating ArraySet instances from an existing array.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {</span><span class="s3">\n\t  </span><span class="s1">var set = new ArraySet();</span><span class="s3">\n\t  </span><span class="s1">for (var i = 0, len = aArray.length; i &lt; len; i++) {</span><span class="s3">\n\t    </span><span class="s1">set.add(aArray[i], aAllowDuplicates);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return set;</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Return how many unique items are in this ArraySet. If duplicates have been</span><span class="s3">\n\t </span><span class="s1">* added, than those do not count towards the size.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @returns Number</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">ArraySet.prototype.size = function ArraySet_size() {</span><span class="s3">\n\t  </span><span class="s1">return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Add the given string to this set.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param String aStr</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {</span><span class="s3">\n\t  </span><span class="s1">var sStr = hasNativeMap ? aStr : util.toSetString(aStr);</span><span class="s3">\n\t  </span><span class="s1">var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);</span><span class="s3">\n\t  </span><span class="s1">var idx = this._array.length;</span><span class="s3">\n\t  </span><span class="s1">if (!isDuplicate || aAllowDuplicates) {</span><span class="s3">\n\t    </span><span class="s1">this._array.push(aStr);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">if (!isDuplicate) {</span><span class="s3">\n\t    </span><span class="s1">if (hasNativeMap) {</span><span class="s3">\n\t      </span><span class="s1">this._set.set(aStr, idx);</span><span class="s3">\n\t    </span><span class="s1">} else {</span><span class="s3">\n\t      </span><span class="s1">this._set[sStr] = idx;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Is the given string a member of this set?</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param String aStr</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">ArraySet.prototype.has = function ArraySet_has(aStr) {</span><span class="s3">\n\t  </span><span class="s1">if (hasNativeMap) {</span><span class="s3">\n\t    </span><span class="s1">return this._set.has(aStr);</span><span class="s3">\n\t  </span><span class="s1">} else {</span><span class="s3">\n\t    </span><span class="s1">var sStr = util.toSetString(aStr);</span><span class="s3">\n\t    </span><span class="s1">return has.call(this._set, sStr);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* What is the index of the given string in the array?</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param String aStr</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {</span><span class="s3">\n\t  </span><span class="s1">if (hasNativeMap) {</span><span class="s3">\n\t    </span><span class="s1">var idx = this._set.get(aStr);</span><span class="s3">\n\t    </span><span class="s1">if (idx &gt;= 0) {</span><span class="s3">\n\t        </span><span class="s1">return idx;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">} else {</span><span class="s3">\n\t    </span><span class="s1">var sStr = util.toSetString(aStr);</span><span class="s3">\n\t    </span><span class="s1">if (has.call(this._set, sStr)) {</span><span class="s3">\n\t      </span><span class="s1">return this._set[sStr];</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">throw new Error('</span><span class="s3">\&quot;</span><span class="s1">' + aStr + '</span><span class="s3">\&quot; </span><span class="s1">is not in the set.');</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* What is the element at the given index?</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param Number aIdx</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">ArraySet.prototype.at = function ArraySet_at(aIdx) {</span><span class="s3">\n\t  </span><span class="s1">if (aIdx &gt;= 0 &amp;&amp; aIdx &lt; this._array.length) {</span><span class="s3">\n\t    </span><span class="s1">return this._array[aIdx];</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">throw new Error('No element indexed by ' + aIdx);</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Returns the array representation of this set (which has the proper indices</span><span class="s3">\n\t </span><span class="s1">* indicated by indexOf). Note that this is a copy of the internal array used</span><span class="s3">\n\t </span><span class="s1">* for storing the members so that no one can mess with internal state.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">ArraySet.prototype.toArray = function ArraySet_toArray() {</span><span class="s3">\n\t  </span><span class="s1">return this._array.slice();</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">exports.ArraySet = ArraySet;</span><span class="s3">\n\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 6 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\t</span><span class="s1">/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n\t</span><span class="s1">/*</span><span class="s3">\n\t </span><span class="s1">* Copyright 2014 Mozilla Foundation and contributors</span><span class="s3">\n\t </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n\t </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t\n\t</span><span class="s1">var util = __webpack_require__(4);</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Determine whether mappingB is after mappingA with respect to generated</span><span class="s3">\n\t </span><span class="s1">* position.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function generatedPositionAfter(mappingA, mappingB) {</span><span class="s3">\n\t  </span><span class="s1">// Optimized for most common case</span><span class="s3">\n\t  </span><span class="s1">var lineA = mappingA.generatedLine;</span><span class="s3">\n\t  </span><span class="s1">var lineB = mappingB.generatedLine;</span><span class="s3">\n\t  </span><span class="s1">var columnA = mappingA.generatedColumn;</span><span class="s3">\n\t  </span><span class="s1">var columnB = mappingB.generatedColumn;</span><span class="s3">\n\t  </span><span class="s1">return lineB &gt; lineA || lineB == lineA &amp;&amp; columnB &gt;= columnA ||</span><span class="s3">\n\t         </span><span class="s1">util.compareByGeneratedPositionsInflated(mappingA, mappingB) &lt;= 0;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* A data structure to provide a sorted view of accumulated mappings in a</span><span class="s3">\n\t </span><span class="s1">* performance conscious manner. It trades a neglibable overhead in general</span><span class="s3">\n\t </span><span class="s1">* case for a large speedup in case of mappings being added in order.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function MappingList() {</span><span class="s3">\n\t  </span><span class="s1">this._array = [];</span><span class="s3">\n\t  </span><span class="s1">this._sorted = true;</span><span class="s3">\n\t  </span><span class="s1">// Serves as infimum</span><span class="s3">\n\t  </span><span class="s1">this._last = {generatedLine: -1, generatedColumn: 0};</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Iterate through internal items. This method takes the same arguments that</span><span class="s3">\n\t </span><span class="s1">* `Array.prototype.forEach` takes.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* NOTE: The order of the mappings is NOT guaranteed.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">MappingList.prototype.unsortedForEach =</span><span class="s3">\n\t  </span><span class="s1">function MappingList_forEach(aCallback, aThisArg) {</span><span class="s3">\n\t    </span><span class="s1">this._array.forEach(aCallback, aThisArg);</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Add the given source mapping.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param Object aMapping</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">MappingList.prototype.add = function MappingList_add(aMapping) {</span><span class="s3">\n\t  </span><span class="s1">if (generatedPositionAfter(this._last, aMapping)) {</span><span class="s3">\n\t    </span><span class="s1">this._last = aMapping;</span><span class="s3">\n\t    </span><span class="s1">this._array.push(aMapping);</span><span class="s3">\n\t  </span><span class="s1">} else {</span><span class="s3">\n\t    </span><span class="s1">this._sorted = false;</span><span class="s3">\n\t    </span><span class="s1">this._array.push(aMapping);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Returns the flat, sorted array of mappings. The mappings are sorted by</span><span class="s3">\n\t </span><span class="s1">* generated position.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* WARNING: This method returns internal data without copying, for</span><span class="s3">\n\t </span><span class="s1">* performance. The return value must NOT be mutated, and should be treated as</span><span class="s3">\n\t </span><span class="s1">* an immutable borrow. If you want to take ownership, you must make your own</span><span class="s3">\n\t </span><span class="s1">* copy.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">MappingList.prototype.toArray = function MappingList_toArray() {</span><span class="s3">\n\t  </span><span class="s1">if (!this._sorted) {</span><span class="s3">\n\t    </span><span class="s1">this._array.sort(util.compareByGeneratedPositionsInflated);</span><span class="s3">\n\t    </span><span class="s1">this._sorted = true;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return this._array;</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">exports.MappingList = MappingList;</span><span class="s3">\n\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 7 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\t</span><span class="s1">/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n\t</span><span class="s1">/*</span><span class="s3">\n\t </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n\t </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n\t </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t\n\t</span><span class="s1">var util = __webpack_require__(4);</span><span class="s3">\n\t</span><span class="s1">var binarySearch = __webpack_require__(8);</span><span class="s3">\n\t</span><span class="s1">var ArraySet = __webpack_require__(5).ArraySet;</span><span class="s3">\n\t</span><span class="s1">var base64VLQ = __webpack_require__(2);</span><span class="s3">\n\t</span><span class="s1">var quickSort = __webpack_require__(9).quickSort;</span><span class="s3">\n\t\n\t</span><span class="s1">function SourceMapConsumer(aSourceMap, aSourceMapURL) {</span><span class="s3">\n\t  </span><span class="s1">var sourceMap = aSourceMap;</span><span class="s3">\n\t  </span><span class="s1">if (typeof aSourceMap === 'string') {</span><span class="s3">\n\t    </span><span class="s1">sourceMap = util.parseSourceMapInput(aSourceMap);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">return sourceMap.sections != null</span><span class="s3">\n\t    </span><span class="s1">? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)</span><span class="s3">\n\t    </span><span class="s1">: new BasicSourceMapConsumer(sourceMap, aSourceMapURL);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {</span><span class="s3">\n\t  </span><span class="s1">return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* The version of the source mapping spec that we are consuming.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceMapConsumer.prototype._version = 3;</span><span class="s3">\n\t\n\t</span><span class="s1">// `__generatedMappings` and `__originalMappings` are arrays that hold the</span><span class="s3">\n\t</span><span class="s1">// parsed mapping coordinates from the source map's </span><span class="s3">\&quot;</span><span class="s1">mappings</span><span class="s3">\&quot; </span><span class="s1">attribute. They</span><span class="s3">\n\t</span><span class="s1">// are lazily instantiated, accessed via the `_generatedMappings` and</span><span class="s3">\n\t</span><span class="s1">// `_originalMappings` getters respectively, and we only parse the mappings</span><span class="s3">\n\t</span><span class="s1">// and create these arrays once queried for a source location. We jump through</span><span class="s3">\n\t</span><span class="s1">// these hoops because there can be many thousands of mappings, and parsing</span><span class="s3">\n\t</span><span class="s1">// them is expensive, so we only want to do it if we must.</span><span class="s3">\n\t</span><span class="s1">//</span><span class="s3">\n\t</span><span class="s1">// Each object in the arrays is of the form:</span><span class="s3">\n\t</span><span class="s1">//</span><span class="s3">\n\t</span><span class="s1">//     {</span><span class="s3">\n\t</span><span class="s1">//       generatedLine: The line number in the generated code,</span><span class="s3">\n\t</span><span class="s1">//       generatedColumn: The column number in the generated code,</span><span class="s3">\n\t</span><span class="s1">//       source: The path to the original source file that generated this</span><span class="s3">\n\t</span><span class="s1">//               chunk of code,</span><span class="s3">\n\t</span><span class="s1">//       originalLine: The line number in the original source that</span><span class="s3">\n\t</span><span class="s1">//                     corresponds to this chunk of generated code,</span><span class="s3">\n\t</span><span class="s1">//       originalColumn: The column number in the original source that</span><span class="s3">\n\t</span><span class="s1">//                       corresponds to this chunk of generated code,</span><span class="s3">\n\t</span><span class="s1">//       name: The name of the original symbol which generated this chunk of</span><span class="s3">\n\t</span><span class="s1">//             code.</span><span class="s3">\n\t</span><span class="s1">//     }</span><span class="s3">\n\t</span><span class="s1">//</span><span class="s3">\n\t</span><span class="s1">// All properties except for `generatedLine` and `generatedColumn` can be</span><span class="s3">\n\t</span><span class="s1">// `null`.</span><span class="s3">\n\t</span><span class="s1">//</span><span class="s3">\n\t</span><span class="s1">// `_generatedMappings` is ordered by the generated positions.</span><span class="s3">\n\t</span><span class="s1">//</span><span class="s3">\n\t</span><span class="s1">// `_originalMappings` is ordered by the original positions.</span><span class="s3">\n\t\n\t</span><span class="s1">SourceMapConsumer.prototype.__generatedMappings = null;</span><span class="s3">\n\t</span><span class="s1">Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {</span><span class="s3">\n\t  </span><span class="s1">configurable: true,</span><span class="s3">\n\t  </span><span class="s1">enumerable: true,</span><span class="s3">\n\t  </span><span class="s1">get: function () {</span><span class="s3">\n\t    </span><span class="s1">if (!this.__generatedMappings) {</span><span class="s3">\n\t      </span><span class="s1">this._parseMappings(this._mappings, this.sourceRoot);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">return this.__generatedMappings;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">});</span><span class="s3">\n\t\n\t</span><span class="s1">SourceMapConsumer.prototype.__originalMappings = null;</span><span class="s3">\n\t</span><span class="s1">Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {</span><span class="s3">\n\t  </span><span class="s1">configurable: true,</span><span class="s3">\n\t  </span><span class="s1">enumerable: true,</span><span class="s3">\n\t  </span><span class="s1">get: function () {</span><span class="s3">\n\t    </span><span class="s1">if (!this.__originalMappings) {</span><span class="s3">\n\t      </span><span class="s1">this._parseMappings(this._mappings, this.sourceRoot);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">return this.__originalMappings;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">});</span><span class="s3">\n\t\n\t</span><span class="s1">SourceMapConsumer.prototype._charIsMappingSeparator =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapConsumer_charIsMappingSeparator(aStr, index) {</span><span class="s3">\n\t    </span><span class="s1">var c = aStr.charAt(index);</span><span class="s3">\n\t    </span><span class="s1">return c === </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot; </span><span class="s1">|| c === </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Parse the mappings in a string in to a data structure which we can easily</span><span class="s3">\n\t </span><span class="s1">* query (the ordered arrays in the `this.__generatedMappings` and</span><span class="s3">\n\t </span><span class="s1">* `this.__originalMappings` properties).</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceMapConsumer.prototype._parseMappings =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {</span><span class="s3">\n\t    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Subclasses must implement _parseMappings</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">SourceMapConsumer.GENERATED_ORDER = 1;</span><span class="s3">\n\t</span><span class="s1">SourceMapConsumer.ORIGINAL_ORDER = 2;</span><span class="s3">\n\t\n\t</span><span class="s1">SourceMapConsumer.GREATEST_LOWER_BOUND = 1;</span><span class="s3">\n\t</span><span class="s1">SourceMapConsumer.LEAST_UPPER_BOUND = 2;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Iterate over each mapping between an original source/line/column and a</span><span class="s3">\n\t </span><span class="s1">* generated line/column in this source map.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param Function aCallback</span><span class="s3">\n\t </span><span class="s1">*        The function that is called with each mapping.</span><span class="s3">\n\t </span><span class="s1">* @param Object aContext</span><span class="s3">\n\t </span><span class="s1">*        Optional. If specified, this object will be the value of `this` every</span><span class="s3">\n\t </span><span class="s1">*        time that `aCallback` is called.</span><span class="s3">\n\t </span><span class="s1">* @param aOrder</span><span class="s3">\n\t </span><span class="s1">*        Either `SourceMapConsumer.GENERATED_ORDER` or</span><span class="s3">\n\t </span><span class="s1">*        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to</span><span class="s3">\n\t </span><span class="s1">*        iterate over the mappings sorted by the generated file's line/column</span><span class="s3">\n\t </span><span class="s1">*        order or the original's source/line/column order, respectively. Defaults to</span><span class="s3">\n\t </span><span class="s1">*        `SourceMapConsumer.GENERATED_ORDER`.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceMapConsumer.prototype.eachMapping =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {</span><span class="s3">\n\t    </span><span class="s1">var context = aContext || null;</span><span class="s3">\n\t    </span><span class="s1">var order = aOrder || SourceMapConsumer.GENERATED_ORDER;</span><span class="s3">\n\t\n\t    </span><span class="s1">var mappings;</span><span class="s3">\n\t    </span><span class="s1">switch (order) {</span><span class="s3">\n\t    </span><span class="s1">case SourceMapConsumer.GENERATED_ORDER:</span><span class="s3">\n\t      </span><span class="s1">mappings = this._generatedMappings;</span><span class="s3">\n\t      </span><span class="s1">break;</span><span class="s3">\n\t    </span><span class="s1">case SourceMapConsumer.ORIGINAL_ORDER:</span><span class="s3">\n\t      </span><span class="s1">mappings = this._originalMappings;</span><span class="s3">\n\t      </span><span class="s1">break;</span><span class="s3">\n\t    </span><span class="s1">default:</span><span class="s3">\n\t      </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Unknown order of iteration.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">var sourceRoot = this.sourceRoot;</span><span class="s3">\n\t    </span><span class="s1">mappings.map(function (mapping) {</span><span class="s3">\n\t      </span><span class="s1">var source = mapping.source === null ? null : this._sources.at(mapping.source);</span><span class="s3">\n\t      </span><span class="s1">source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);</span><span class="s3">\n\t      </span><span class="s1">return {</span><span class="s3">\n\t        </span><span class="s1">source: source,</span><span class="s3">\n\t        </span><span class="s1">generatedLine: mapping.generatedLine,</span><span class="s3">\n\t        </span><span class="s1">generatedColumn: mapping.generatedColumn,</span><span class="s3">\n\t        </span><span class="s1">originalLine: mapping.originalLine,</span><span class="s3">\n\t        </span><span class="s1">originalColumn: mapping.originalColumn,</span><span class="s3">\n\t        </span><span class="s1">name: mapping.name === null ? null : this._names.at(mapping.name)</span><span class="s3">\n\t      </span><span class="s1">};</span><span class="s3">\n\t    </span><span class="s1">}, this).forEach(aCallback, context);</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Returns all generated line and column information for the original source,</span><span class="s3">\n\t </span><span class="s1">* line, and column provided. If no column is provided, returns all mappings</span><span class="s3">\n\t </span><span class="s1">* corresponding to a either the line we are searching for or the next</span><span class="s3">\n\t </span><span class="s1">* closest line that has any mappings. Otherwise, returns all mappings</span><span class="s3">\n\t </span><span class="s1">* corresponding to the given line and either the column we are searching for</span><span class="s3">\n\t </span><span class="s1">* or the next closest column that has any offsets.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* The only argument is an object with the following properties:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*   - source: The filename of the original source.</span><span class="s3">\n\t </span><span class="s1">*   - line: The line number in the original source.  The line number is 1-based.</span><span class="s3">\n\t </span><span class="s1">*   - column: Optional. the column number in the original source.</span><span class="s3">\n\t </span><span class="s1">*    The column number is 0-based.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* and an array of objects is returned, each with the following properties:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*   - line: The line number in the generated source, or null.  The</span><span class="s3">\n\t </span><span class="s1">*    line number is 1-based.</span><span class="s3">\n\t </span><span class="s1">*   - column: The column number in the generated source, or null.</span><span class="s3">\n\t </span><span class="s1">*    The column number is 0-based.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceMapConsumer.prototype.allGeneratedPositionsFor =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {</span><span class="s3">\n\t    </span><span class="s1">var line = util.getArg(aArgs, 'line');</span><span class="s3">\n\t\n\t    </span><span class="s1">// When there is no exact match, BasicSourceMapConsumer.prototype._findMapping</span><span class="s3">\n\t    </span><span class="s1">// returns the index of the closest mapping less than the needle. By</span><span class="s3">\n\t    </span><span class="s1">// setting needle.originalColumn to 0, we thus find the last mapping for</span><span class="s3">\n\t    </span><span class="s1">// the given line, provided such a mapping exists.</span><span class="s3">\n\t    </span><span class="s1">var needle = {</span><span class="s3">\n\t      </span><span class="s1">source: util.getArg(aArgs, 'source'),</span><span class="s3">\n\t      </span><span class="s1">originalLine: line,</span><span class="s3">\n\t      </span><span class="s1">originalColumn: util.getArg(aArgs, 'column', 0)</span><span class="s3">\n\t    </span><span class="s1">};</span><span class="s3">\n\t\n\t    </span><span class="s1">needle.source = this._findSourceIndex(needle.source);</span><span class="s3">\n\t    </span><span class="s1">if (needle.source &lt; 0) {</span><span class="s3">\n\t      </span><span class="s1">return [];</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">var mappings = [];</span><span class="s3">\n\t\n\t    </span><span class="s1">var index = this._findMapping(needle,</span><span class="s3">\n\t                                  </span><span class="s1">this._originalMappings,</span><span class="s3">\n\t                                  \&quot;</span><span class="s1">originalLine</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t                                  \&quot;</span><span class="s1">originalColumn</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t                                  </span><span class="s1">util.compareByOriginalPositions,</span><span class="s3">\n\t                                  </span><span class="s1">binarySearch.LEAST_UPPER_BOUND);</span><span class="s3">\n\t    </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n\t      </span><span class="s1">var mapping = this._originalMappings[index];</span><span class="s3">\n\t\n\t      </span><span class="s1">if (aArgs.column === undefined) {</span><span class="s3">\n\t        </span><span class="s1">var originalLine = mapping.originalLine;</span><span class="s3">\n\t\n\t        </span><span class="s1">// Iterate until either we run out of mappings, or we run into</span><span class="s3">\n\t        </span><span class="s1">// a mapping for a different line than the one we found. Since</span><span class="s3">\n\t        </span><span class="s1">// mappings are sorted, this is guaranteed to find all mappings for</span><span class="s3">\n\t        </span><span class="s1">// the line we found.</span><span class="s3">\n\t        </span><span class="s1">while (mapping &amp;&amp; mapping.originalLine === originalLine) {</span><span class="s3">\n\t          </span><span class="s1">mappings.push({</span><span class="s3">\n\t            </span><span class="s1">line: util.getArg(mapping, 'generatedLine', null),</span><span class="s3">\n\t            </span><span class="s1">column: util.getArg(mapping, 'generatedColumn', null),</span><span class="s3">\n\t            </span><span class="s1">lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)</span><span class="s3">\n\t          </span><span class="s1">});</span><span class="s3">\n\t\n\t          </span><span class="s1">mapping = this._originalMappings[++index];</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">} else {</span><span class="s3">\n\t        </span><span class="s1">var originalColumn = mapping.originalColumn;</span><span class="s3">\n\t\n\t        </span><span class="s1">// Iterate until either we run out of mappings, or we run into</span><span class="s3">\n\t        </span><span class="s1">// a mapping for a different line than the one we were searching for.</span><span class="s3">\n\t        </span><span class="s1">// Since mappings are sorted, this is guaranteed to find all mappings for</span><span class="s3">\n\t        </span><span class="s1">// the line we are searching for.</span><span class="s3">\n\t        </span><span class="s1">while (mapping &amp;&amp;</span><span class="s3">\n\t               </span><span class="s1">mapping.originalLine === line &amp;&amp;</span><span class="s3">\n\t               </span><span class="s1">mapping.originalColumn == originalColumn) {</span><span class="s3">\n\t          </span><span class="s1">mappings.push({</span><span class="s3">\n\t            </span><span class="s1">line: util.getArg(mapping, 'generatedLine', null),</span><span class="s3">\n\t            </span><span class="s1">column: util.getArg(mapping, 'generatedColumn', null),</span><span class="s3">\n\t            </span><span class="s1">lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)</span><span class="s3">\n\t          </span><span class="s1">});</span><span class="s3">\n\t\n\t          </span><span class="s1">mapping = this._originalMappings[++index];</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">return mappings;</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">exports.SourceMapConsumer = SourceMapConsumer;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* A BasicSourceMapConsumer instance represents a parsed source map which we can</span><span class="s3">\n\t </span><span class="s1">* query for information about the original file positions by giving it a file</span><span class="s3">\n\t </span><span class="s1">* position in the generated source.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* The first parameter is the raw source map (either as a JSON string, or</span><span class="s3">\n\t </span><span class="s1">* already parsed to an object). According to the spec, source maps have the</span><span class="s3">\n\t </span><span class="s1">* following attributes:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*   - version: Which version of the source map spec this map is following.</span><span class="s3">\n\t </span><span class="s1">*   - sources: An array of URLs to the original source files.</span><span class="s3">\n\t </span><span class="s1">*   - names: An array of identifiers which can be referrenced by individual mappings.</span><span class="s3">\n\t </span><span class="s1">*   - sourceRoot: Optional. The URL root from which all sources are relative.</span><span class="s3">\n\t </span><span class="s1">*   - sourcesContent: Optional. An array of contents of the original source files.</span><span class="s3">\n\t </span><span class="s1">*   - mappings: A string of base64 VLQs which contain the actual mappings.</span><span class="s3">\n\t </span><span class="s1">*   - file: Optional. The generated file this source map is associated with.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* Here is an example source map, taken from the source map spec[0]:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*     {</span><span class="s3">\n\t </span><span class="s1">*       version : 3,</span><span class="s3">\n\t </span><span class="s1">*       file: </span><span class="s3">\&quot;</span><span class="s1">out.js</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t </span><span class="s1">*       sourceRoot : </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n\t </span><span class="s1">*       sources: [</span><span class="s3">\&quot;</span><span class="s1">foo.js</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">bar.js</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n\t </span><span class="s1">*       names: [</span><span class="s3">\&quot;</span><span class="s1">src</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">maps</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">are</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">fun</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n\t </span><span class="s1">*       mappings: </span><span class="s3">\&quot;</span><span class="s1">AA,AB;;ABCDE;</span><span class="s3">\&quot;\n\t </span><span class="s1">*     }</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* The second parameter, if given, is a string whose value is the URL</span><span class="s3">\n\t </span><span class="s1">* at which the source map was found.  This URL is used to compute the</span><span class="s3">\n\t </span><span class="s1">* sources array.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {</span><span class="s3">\n\t  </span><span class="s1">var sourceMap = aSourceMap;</span><span class="s3">\n\t  </span><span class="s1">if (typeof aSourceMap === 'string') {</span><span class="s3">\n\t    </span><span class="s1">sourceMap = util.parseSourceMapInput(aSourceMap);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">var version = util.getArg(sourceMap, 'version');</span><span class="s3">\n\t  </span><span class="s1">var sources = util.getArg(sourceMap, 'sources');</span><span class="s3">\n\t  </span><span class="s1">// Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which</span><span class="s3">\n\t  </span><span class="s1">// requires the array) to play nice here.</span><span class="s3">\n\t  </span><span class="s1">var names = util.getArg(sourceMap, 'names', []);</span><span class="s3">\n\t  </span><span class="s1">var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);</span><span class="s3">\n\t  </span><span class="s1">var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);</span><span class="s3">\n\t  </span><span class="s1">var mappings = util.getArg(sourceMap, 'mappings');</span><span class="s3">\n\t  </span><span class="s1">var file = util.getArg(sourceMap, 'file', null);</span><span class="s3">\n\t\n\t  </span><span class="s1">// Once again, Sass deviates from the spec and supplies the version as a</span><span class="s3">\n\t  </span><span class="s1">// string rather than a number, so we use loose equality checking here.</span><span class="s3">\n\t  </span><span class="s1">if (version != this._version) {</span><span class="s3">\n\t    </span><span class="s1">throw new Error('Unsupported version: ' + version);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">if (sourceRoot) {</span><span class="s3">\n\t    </span><span class="s1">sourceRoot = util.normalize(sourceRoot);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">sources = sources</span><span class="s3">\n\t    </span><span class="s1">.map(String)</span><span class="s3">\n\t    </span><span class="s1">// Some source maps produce relative source paths like </span><span class="s3">\&quot;</span><span class="s1">./foo.js</span><span class="s3">\&quot; </span><span class="s1">instead of</span><span class="s3">\n\t    </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">foo.js</span><span class="s3">\&quot;</span><span class="s1">.  Normalize these first so that future comparisons will succeed.</span><span class="s3">\n\t    </span><span class="s1">// See bugzil.la/1090768.</span><span class="s3">\n\t    </span><span class="s1">.map(util.normalize)</span><span class="s3">\n\t    </span><span class="s1">// Always ensure that absolute sources are internally stored relative to</span><span class="s3">\n\t    </span><span class="s1">// the source root, if the source root is absolute. Not doing this would</span><span class="s3">\n\t    </span><span class="s1">// be particularly problematic when the source root is a prefix of the</span><span class="s3">\n\t    </span><span class="s1">// source (valid, but why??). See github issue #199 and bugzil.la/1188982.</span><span class="s3">\n\t    </span><span class="s1">.map(function (source) {</span><span class="s3">\n\t      </span><span class="s1">return sourceRoot &amp;&amp; util.isAbsolute(sourceRoot) &amp;&amp; util.isAbsolute(source)</span><span class="s3">\n\t        </span><span class="s1">? util.relative(sourceRoot, source)</span><span class="s3">\n\t        </span><span class="s1">: source;</span><span class="s3">\n\t    </span><span class="s1">});</span><span class="s3">\n\t\n\t  </span><span class="s1">// Pass `true` below to allow duplicate names and sources. While source maps</span><span class="s3">\n\t  </span><span class="s1">// are intended to be compressed and deduplicated, the TypeScript compiler</span><span class="s3">\n\t  </span><span class="s1">// sometimes generates source maps with duplicates in them. See Github issue</span><span class="s3">\n\t  </span><span class="s1">// #72 and bugzil.la/889492.</span><span class="s3">\n\t  </span><span class="s1">this._names = ArraySet.fromArray(names.map(String), true);</span><span class="s3">\n\t  </span><span class="s1">this._sources = ArraySet.fromArray(sources, true);</span><span class="s3">\n\t\n\t  </span><span class="s1">this._absoluteSources = this._sources.toArray().map(function (s) {</span><span class="s3">\n\t    </span><span class="s1">return util.computeSourceURL(sourceRoot, s, aSourceMapURL);</span><span class="s3">\n\t  </span><span class="s1">});</span><span class="s3">\n\t\n\t  </span><span class="s1">this.sourceRoot = sourceRoot;</span><span class="s3">\n\t  </span><span class="s1">this.sourcesContent = sourcesContent;</span><span class="s3">\n\t  </span><span class="s1">this._mappings = mappings;</span><span class="s3">\n\t  </span><span class="s1">this._sourceMapURL = aSourceMapURL;</span><span class="s3">\n\t  </span><span class="s1">this.file = file;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);</span><span class="s3">\n\t</span><span class="s1">BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Utility function to find the index of a source.  Returns -1 if not</span><span class="s3">\n\t </span><span class="s1">* found.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {</span><span class="s3">\n\t  </span><span class="s1">var relativeSource = aSource;</span><span class="s3">\n\t  </span><span class="s1">if (this.sourceRoot != null) {</span><span class="s3">\n\t    </span><span class="s1">relativeSource = util.relative(this.sourceRoot, relativeSource);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">if (this._sources.has(relativeSource)) {</span><span class="s3">\n\t    </span><span class="s1">return this._sources.indexOf(relativeSource);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">// Maybe aSource is an absolute URL as returned by |sources|.  In</span><span class="s3">\n\t  </span><span class="s1">// this case we can't simply undo the transform.</span><span class="s3">\n\t  </span><span class="s1">var i;</span><span class="s3">\n\t  </span><span class="s1">for (i = 0; i &lt; this._absoluteSources.length; ++i) {</span><span class="s3">\n\t    </span><span class="s1">if (this._absoluteSources[i] == aSource) {</span><span class="s3">\n\t      </span><span class="s1">return i;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">return -1;</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Create a BasicSourceMapConsumer from a SourceMapGenerator.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param SourceMapGenerator aSourceMap</span><span class="s3">\n\t </span><span class="s1">*        The source map that will be consumed.</span><span class="s3">\n\t </span><span class="s1">* @param String aSourceMapURL</span><span class="s3">\n\t </span><span class="s1">*        The URL at which the source map can be found (optional)</span><span class="s3">\n\t </span><span class="s1">* @returns BasicSourceMapConsumer</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">BasicSourceMapConsumer.fromSourceMap =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {</span><span class="s3">\n\t    </span><span class="s1">var smc = Object.create(BasicSourceMapConsumer.prototype);</span><span class="s3">\n\t\n\t    </span><span class="s1">var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);</span><span class="s3">\n\t    </span><span class="s1">var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);</span><span class="s3">\n\t    </span><span class="s1">smc.sourceRoot = aSourceMap._sourceRoot;</span><span class="s3">\n\t    </span><span class="s1">smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),</span><span class="s3">\n\t                                                            </span><span class="s1">smc.sourceRoot);</span><span class="s3">\n\t    </span><span class="s1">smc.file = aSourceMap._file;</span><span class="s3">\n\t    </span><span class="s1">smc._sourceMapURL = aSourceMapURL;</span><span class="s3">\n\t    </span><span class="s1">smc._absoluteSources = smc._sources.toArray().map(function (s) {</span><span class="s3">\n\t      </span><span class="s1">return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);</span><span class="s3">\n\t    </span><span class="s1">});</span><span class="s3">\n\t\n\t    </span><span class="s1">// Because we are modifying the entries (by converting string sources and</span><span class="s3">\n\t    </span><span class="s1">// names to indices into the sources and names ArraySets), we have to make</span><span class="s3">\n\t    </span><span class="s1">// a copy of the entry or else bad things happen. Shared mutable state</span><span class="s3">\n\t    </span><span class="s1">// strikes again! See github issue #191.</span><span class="s3">\n\t\n\t    </span><span class="s1">var generatedMappings = aSourceMap._mappings.toArray().slice();</span><span class="s3">\n\t    </span><span class="s1">var destGeneratedMappings = smc.__generatedMappings = [];</span><span class="s3">\n\t    </span><span class="s1">var destOriginalMappings = smc.__originalMappings = [];</span><span class="s3">\n\t\n\t    </span><span class="s1">for (var i = 0, length = generatedMappings.length; i &lt; length; i++) {</span><span class="s3">\n\t      </span><span class="s1">var srcMapping = generatedMappings[i];</span><span class="s3">\n\t      </span><span class="s1">var destMapping = new Mapping;</span><span class="s3">\n\t      </span><span class="s1">destMapping.generatedLine = srcMapping.generatedLine;</span><span class="s3">\n\t      </span><span class="s1">destMapping.generatedColumn = srcMapping.generatedColumn;</span><span class="s3">\n\t\n\t      </span><span class="s1">if (srcMapping.source) {</span><span class="s3">\n\t        </span><span class="s1">destMapping.source = sources.indexOf(srcMapping.source);</span><span class="s3">\n\t        </span><span class="s1">destMapping.originalLine = srcMapping.originalLine;</span><span class="s3">\n\t        </span><span class="s1">destMapping.originalColumn = srcMapping.originalColumn;</span><span class="s3">\n\t\n\t        </span><span class="s1">if (srcMapping.name) {</span><span class="s3">\n\t          </span><span class="s1">destMapping.name = names.indexOf(srcMapping.name);</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t\n\t        </span><span class="s1">destOriginalMappings.push(destMapping);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t\n\t      </span><span class="s1">destGeneratedMappings.push(destMapping);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">quickSort(smc.__originalMappings, util.compareByOriginalPositions);</span><span class="s3">\n\t\n\t    </span><span class="s1">return smc;</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* The version of the source mapping spec that we are consuming.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">BasicSourceMapConsumer.prototype._version = 3;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* The list of original sources.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {</span><span class="s3">\n\t  </span><span class="s1">get: function () {</span><span class="s3">\n\t    </span><span class="s1">return this._absoluteSources.slice();</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">});</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Provide the JIT with a nice shape / hidden class.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function Mapping() {</span><span class="s3">\n\t  </span><span class="s1">this.generatedLine = 0;</span><span class="s3">\n\t  </span><span class="s1">this.generatedColumn = 0;</span><span class="s3">\n\t  </span><span class="s1">this.source = null;</span><span class="s3">\n\t  </span><span class="s1">this.originalLine = null;</span><span class="s3">\n\t  </span><span class="s1">this.originalColumn = null;</span><span class="s3">\n\t  </span><span class="s1">this.name = null;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Parse the mappings in a string in to a data structure which we can easily</span><span class="s3">\n\t </span><span class="s1">* query (the ordered arrays in the `this.__generatedMappings` and</span><span class="s3">\n\t </span><span class="s1">* `this.__originalMappings` properties).</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">BasicSourceMapConsumer.prototype._parseMappings =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {</span><span class="s3">\n\t    </span><span class="s1">var generatedLine = 1;</span><span class="s3">\n\t    </span><span class="s1">var previousGeneratedColumn = 0;</span><span class="s3">\n\t    </span><span class="s1">var previousOriginalLine = 0;</span><span class="s3">\n\t    </span><span class="s1">var previousOriginalColumn = 0;</span><span class="s3">\n\t    </span><span class="s1">var previousSource = 0;</span><span class="s3">\n\t    </span><span class="s1">var previousName = 0;</span><span class="s3">\n\t    </span><span class="s1">var length = aStr.length;</span><span class="s3">\n\t    </span><span class="s1">var index = 0;</span><span class="s3">\n\t    </span><span class="s1">var cachedSegments = {};</span><span class="s3">\n\t    </span><span class="s1">var temp = {};</span><span class="s3">\n\t    </span><span class="s1">var originalMappings = [];</span><span class="s3">\n\t    </span><span class="s1">var generatedMappings = [];</span><span class="s3">\n\t    </span><span class="s1">var mapping, str, segment, end, value;</span><span class="s3">\n\t\n\t    </span><span class="s1">while (index &lt; length) {</span><span class="s3">\n\t      </span><span class="s1">if (aStr.charAt(index) === ';') {</span><span class="s3">\n\t        </span><span class="s1">generatedLine++;</span><span class="s3">\n\t        </span><span class="s1">index++;</span><span class="s3">\n\t        </span><span class="s1">previousGeneratedColumn = 0;</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">else if (aStr.charAt(index) === ',') {</span><span class="s3">\n\t        </span><span class="s1">index++;</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">else {</span><span class="s3">\n\t        </span><span class="s1">mapping = new Mapping();</span><span class="s3">\n\t        </span><span class="s1">mapping.generatedLine = generatedLine;</span><span class="s3">\n\t\n\t        </span><span class="s1">// Because each offset is encoded relative to the previous one,</span><span class="s3">\n\t        </span><span class="s1">// many segments often have the same encoding. We can exploit this</span><span class="s3">\n\t        </span><span class="s1">// fact by caching the parsed variable length fields of each segment,</span><span class="s3">\n\t        </span><span class="s1">// allowing us to avoid a second parse if we encounter the same</span><span class="s3">\n\t        </span><span class="s1">// segment again.</span><span class="s3">\n\t        </span><span class="s1">for (end = index; end &lt; length; end++) {</span><span class="s3">\n\t          </span><span class="s1">if (this._charIsMappingSeparator(aStr, end)) {</span><span class="s3">\n\t            </span><span class="s1">break;</span><span class="s3">\n\t          </span><span class="s1">}</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t        </span><span class="s1">str = aStr.slice(index, end);</span><span class="s3">\n\t\n\t        </span><span class="s1">segment = cachedSegments[str];</span><span class="s3">\n\t        </span><span class="s1">if (segment) {</span><span class="s3">\n\t          </span><span class="s1">index += str.length;</span><span class="s3">\n\t        </span><span class="s1">} else {</span><span class="s3">\n\t          </span><span class="s1">segment = [];</span><span class="s3">\n\t          </span><span class="s1">while (index &lt; end) {</span><span class="s3">\n\t            </span><span class="s1">base64VLQ.decode(aStr, index, temp);</span><span class="s3">\n\t            </span><span class="s1">value = temp.value;</span><span class="s3">\n\t            </span><span class="s1">index = temp.rest;</span><span class="s3">\n\t            </span><span class="s1">segment.push(value);</span><span class="s3">\n\t          </span><span class="s1">}</span><span class="s3">\n\t\n\t          </span><span class="s1">if (segment.length === 2) {</span><span class="s3">\n\t            </span><span class="s1">throw new Error('Found a source, but no line and column');</span><span class="s3">\n\t          </span><span class="s1">}</span><span class="s3">\n\t\n\t          </span><span class="s1">if (segment.length === 3) {</span><span class="s3">\n\t            </span><span class="s1">throw new Error('Found a source and line, but no column');</span><span class="s3">\n\t          </span><span class="s1">}</span><span class="s3">\n\t\n\t          </span><span class="s1">cachedSegments[str] = segment;</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t\n\t        </span><span class="s1">// Generated column.</span><span class="s3">\n\t        </span><span class="s1">mapping.generatedColumn = previousGeneratedColumn + segment[0];</span><span class="s3">\n\t        </span><span class="s1">previousGeneratedColumn = mapping.generatedColumn;</span><span class="s3">\n\t\n\t        </span><span class="s1">if (segment.length &gt; 1) {</span><span class="s3">\n\t          </span><span class="s1">// Original source.</span><span class="s3">\n\t          </span><span class="s1">mapping.source = previousSource + segment[1];</span><span class="s3">\n\t          </span><span class="s1">previousSource += segment[1];</span><span class="s3">\n\t\n\t          </span><span class="s1">// Original line.</span><span class="s3">\n\t          </span><span class="s1">mapping.originalLine = previousOriginalLine + segment[2];</span><span class="s3">\n\t          </span><span class="s1">previousOriginalLine = mapping.originalLine;</span><span class="s3">\n\t          </span><span class="s1">// Lines are stored 0-based</span><span class="s3">\n\t          </span><span class="s1">mapping.originalLine += 1;</span><span class="s3">\n\t\n\t          </span><span class="s1">// Original column.</span><span class="s3">\n\t          </span><span class="s1">mapping.originalColumn = previousOriginalColumn + segment[3];</span><span class="s3">\n\t          </span><span class="s1">previousOriginalColumn = mapping.originalColumn;</span><span class="s3">\n\t\n\t          </span><span class="s1">if (segment.length &gt; 4) {</span><span class="s3">\n\t            </span><span class="s1">// Original name.</span><span class="s3">\n\t            </span><span class="s1">mapping.name = previousName + segment[4];</span><span class="s3">\n\t            </span><span class="s1">previousName += segment[4];</span><span class="s3">\n\t          </span><span class="s1">}</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t\n\t        </span><span class="s1">generatedMappings.push(mapping);</span><span class="s3">\n\t        </span><span class="s1">if (typeof mapping.originalLine === 'number') {</span><span class="s3">\n\t          </span><span class="s1">originalMappings.push(mapping);</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);</span><span class="s3">\n\t    </span><span class="s1">this.__generatedMappings = generatedMappings;</span><span class="s3">\n\t\n\t    </span><span class="s1">quickSort(originalMappings, util.compareByOriginalPositions);</span><span class="s3">\n\t    </span><span class="s1">this.__originalMappings = originalMappings;</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Find the mapping that best matches the hypothetical </span><span class="s3">\&quot;</span><span class="s1">needle</span><span class="s3">\&quot; </span><span class="s1">mapping that</span><span class="s3">\n\t </span><span class="s1">* we are searching for in the given </span><span class="s3">\&quot;</span><span class="s1">haystack</span><span class="s3">\&quot; </span><span class="s1">of mappings.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">BasicSourceMapConsumer.prototype._findMapping =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,</span><span class="s3">\n\t                                         </span><span class="s1">aColumnName, aComparator, aBias) {</span><span class="s3">\n\t    </span><span class="s1">// To return the position we are searching for, we must first find the</span><span class="s3">\n\t    </span><span class="s1">// mapping for the given position and then return the opposite position it</span><span class="s3">\n\t    </span><span class="s1">// points to. Because the mappings are sorted, we can use binary search to</span><span class="s3">\n\t    </span><span class="s1">// find the best mapping.</span><span class="s3">\n\t\n\t    </span><span class="s1">if (aNeedle[aLineName] &lt;= 0) {</span><span class="s3">\n\t      </span><span class="s1">throw new TypeError('Line must be greater than or equal to 1, got '</span><span class="s3">\n\t                          </span><span class="s1">+ aNeedle[aLineName]);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">if (aNeedle[aColumnName] &lt; 0) {</span><span class="s3">\n\t      </span><span class="s1">throw new TypeError('Column must be greater than or equal to 0, got '</span><span class="s3">\n\t                          </span><span class="s1">+ aNeedle[aColumnName]);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">return binarySearch.search(aNeedle, aMappings, aComparator, aBias);</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Compute the last column for each generated mapping. The last column is</span><span class="s3">\n\t </span><span class="s1">* inclusive.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">BasicSourceMapConsumer.prototype.computeColumnSpans =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapConsumer_computeColumnSpans() {</span><span class="s3">\n\t    </span><span class="s1">for (var index = 0; index &lt; this._generatedMappings.length; ++index) {</span><span class="s3">\n\t      </span><span class="s1">var mapping = this._generatedMappings[index];</span><span class="s3">\n\t\n\t      </span><span class="s1">// Mappings do not contain a field for the last generated columnt. We</span><span class="s3">\n\t      </span><span class="s1">// can come up with an optimistic estimate, however, by assuming that</span><span class="s3">\n\t      </span><span class="s1">// mappings are contiguous (i.e. given two consecutive mappings, the</span><span class="s3">\n\t      </span><span class="s1">// first mapping ends where the second one starts).</span><span class="s3">\n\t      </span><span class="s1">if (index + 1 &lt; this._generatedMappings.length) {</span><span class="s3">\n\t        </span><span class="s1">var nextMapping = this._generatedMappings[index + 1];</span><span class="s3">\n\t\n\t        </span><span class="s1">if (mapping.generatedLine === nextMapping.generatedLine) {</span><span class="s3">\n\t          </span><span class="s1">mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;</span><span class="s3">\n\t          </span><span class="s1">continue;</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t\n\t      </span><span class="s1">// The last mapping for each line spans the entire line.</span><span class="s3">\n\t      </span><span class="s1">mapping.lastGeneratedColumn = Infinity;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Returns the original source, line, and column information for the generated</span><span class="s3">\n\t </span><span class="s1">* source's line and column positions provided. The only argument is an object</span><span class="s3">\n\t </span><span class="s1">* with the following properties:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*   - line: The line number in the generated source.  The line number</span><span class="s3">\n\t </span><span class="s1">*     is 1-based.</span><span class="s3">\n\t </span><span class="s1">*   - column: The column number in the generated source.  The column</span><span class="s3">\n\t </span><span class="s1">*     number is 0-based.</span><span class="s3">\n\t </span><span class="s1">*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or</span><span class="s3">\n\t </span><span class="s1">*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the</span><span class="s3">\n\t </span><span class="s1">*     closest element that is smaller than or greater than the one we are</span><span class="s3">\n\t </span><span class="s1">*     searching for, respectively, if the exact element cannot be found.</span><span class="s3">\n\t </span><span class="s1">*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* and an object is returned with the following properties:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*   - source: The original source file, or null.</span><span class="s3">\n\t </span><span class="s1">*   - line: The line number in the original source, or null.  The</span><span class="s3">\n\t </span><span class="s1">*     line number is 1-based.</span><span class="s3">\n\t </span><span class="s1">*   - column: The column number in the original source, or null.  The</span><span class="s3">\n\t </span><span class="s1">*     column number is 0-based.</span><span class="s3">\n\t </span><span class="s1">*   - name: The original identifier, or null.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">BasicSourceMapConsumer.prototype.originalPositionFor =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapConsumer_originalPositionFor(aArgs) {</span><span class="s3">\n\t    </span><span class="s1">var needle = {</span><span class="s3">\n\t      </span><span class="s1">generatedLine: util.getArg(aArgs, 'line'),</span><span class="s3">\n\t      </span><span class="s1">generatedColumn: util.getArg(aArgs, 'column')</span><span class="s3">\n\t    </span><span class="s1">};</span><span class="s3">\n\t\n\t    </span><span class="s1">var index = this._findMapping(</span><span class="s3">\n\t      </span><span class="s1">needle,</span><span class="s3">\n\t      </span><span class="s1">this._generatedMappings,</span><span class="s3">\n\t      \&quot;</span><span class="s1">generatedLine</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t      \&quot;</span><span class="s1">generatedColumn</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t      </span><span class="s1">util.compareByGeneratedPositionsDeflated,</span><span class="s3">\n\t      </span><span class="s1">util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)</span><span class="s3">\n\t    </span><span class="s1">);</span><span class="s3">\n\t\n\t    </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n\t      </span><span class="s1">var mapping = this._generatedMappings[index];</span><span class="s3">\n\t\n\t      </span><span class="s1">if (mapping.generatedLine === needle.generatedLine) {</span><span class="s3">\n\t        </span><span class="s1">var source = util.getArg(mapping, 'source', null);</span><span class="s3">\n\t        </span><span class="s1">if (source !== null) {</span><span class="s3">\n\t          </span><span class="s1">source = this._sources.at(source);</span><span class="s3">\n\t          </span><span class="s1">source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t        </span><span class="s1">var name = util.getArg(mapping, 'name', null);</span><span class="s3">\n\t        </span><span class="s1">if (name !== null) {</span><span class="s3">\n\t          </span><span class="s1">name = this._names.at(name);</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t        </span><span class="s1">return {</span><span class="s3">\n\t          </span><span class="s1">source: source,</span><span class="s3">\n\t          </span><span class="s1">line: util.getArg(mapping, 'originalLine', null),</span><span class="s3">\n\t          </span><span class="s1">column: util.getArg(mapping, 'originalColumn', null),</span><span class="s3">\n\t          </span><span class="s1">name: name</span><span class="s3">\n\t        </span><span class="s1">};</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">return {</span><span class="s3">\n\t      </span><span class="s1">source: null,</span><span class="s3">\n\t      </span><span class="s1">line: null,</span><span class="s3">\n\t      </span><span class="s1">column: null,</span><span class="s3">\n\t      </span><span class="s1">name: null</span><span class="s3">\n\t    </span><span class="s1">};</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Return true if we have the source content for every source in the source</span><span class="s3">\n\t </span><span class="s1">* map, false otherwise.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">BasicSourceMapConsumer.prototype.hasContentsOfAllSources =</span><span class="s3">\n\t  </span><span class="s1">function BasicSourceMapConsumer_hasContentsOfAllSources() {</span><span class="s3">\n\t    </span><span class="s1">if (!this.sourcesContent) {</span><span class="s3">\n\t      </span><span class="s1">return false;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">return this.sourcesContent.length &gt;= this._sources.size() &amp;&amp;</span><span class="s3">\n\t      </span><span class="s1">!this.sourcesContent.some(function (sc) { return sc == null; });</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Returns the original source content. The only argument is the url of the</span><span class="s3">\n\t </span><span class="s1">* original source file. Returns null if no original source content is</span><span class="s3">\n\t </span><span class="s1">* available.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">BasicSourceMapConsumer.prototype.sourceContentFor =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {</span><span class="s3">\n\t    </span><span class="s1">if (!this.sourcesContent) {</span><span class="s3">\n\t      </span><span class="s1">return null;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">var index = this._findSourceIndex(aSource);</span><span class="s3">\n\t    </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n\t      </span><span class="s1">return this.sourcesContent[index];</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">var relativeSource = aSource;</span><span class="s3">\n\t    </span><span class="s1">if (this.sourceRoot != null) {</span><span class="s3">\n\t      </span><span class="s1">relativeSource = util.relative(this.sourceRoot, relativeSource);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">var url;</span><span class="s3">\n\t    </span><span class="s1">if (this.sourceRoot != null</span><span class="s3">\n\t        </span><span class="s1">&amp;&amp; (url = util.urlParse(this.sourceRoot))) {</span><span class="s3">\n\t      </span><span class="s1">// XXX: file:// URIs and absolute paths lead to unexpected behavior for</span><span class="s3">\n\t      </span><span class="s1">// many users. We can help them out when they expect file:// URIs to</span><span class="s3">\n\t      </span><span class="s1">// behave like it would if they were running a local HTTP server. See</span><span class="s3">\n\t      </span><span class="s1">// https://bugzilla.mozilla.org/show_bug.cgi?id=885597.</span><span class="s3">\n\t      </span><span class="s1">var fileUriAbsPath = relativeSource.replace(/^file:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">//, </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n\t      </span><span class="s1">if (url.scheme == </span><span class="s3">\&quot;</span><span class="s1">file</span><span class="s3">\&quot;\n\t          </span><span class="s1">&amp;&amp; this._sources.has(fileUriAbsPath)) {</span><span class="s3">\n\t        </span><span class="s1">return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t\n\t      </span><span class="s1">if ((!url.path || url.path == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n\t          </span><span class="s1">&amp;&amp; this._sources.has(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ relativeSource)) {</span><span class="s3">\n\t        </span><span class="s1">return this.sourcesContent[this._sources.indexOf(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ relativeSource)];</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">// This function is used recursively from</span><span class="s3">\n\t    </span><span class="s1">// IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we</span><span class="s3">\n\t    </span><span class="s1">// don't want to throw if we can't find the source - we just want to</span><span class="s3">\n\t    </span><span class="s1">// return null, so we provide a flag to exit gracefully.</span><span class="s3">\n\t    </span><span class="s1">if (nullOnMissing) {</span><span class="s3">\n\t      </span><span class="s1">return null;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">else {</span><span class="s3">\n\t      </span><span class="s1">throw new Error('</span><span class="s3">\&quot;</span><span class="s1">' + relativeSource + '</span><span class="s3">\&quot; </span><span class="s1">is not in the SourceMap.');</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Returns the generated line and column information for the original source,</span><span class="s3">\n\t </span><span class="s1">* line, and column positions provided. The only argument is an object with</span><span class="s3">\n\t </span><span class="s1">* the following properties:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*   - source: The filename of the original source.</span><span class="s3">\n\t </span><span class="s1">*   - line: The line number in the original source.  The line number</span><span class="s3">\n\t </span><span class="s1">*     is 1-based.</span><span class="s3">\n\t </span><span class="s1">*   - column: The column number in the original source.  The column</span><span class="s3">\n\t </span><span class="s1">*     number is 0-based.</span><span class="s3">\n\t </span><span class="s1">*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or</span><span class="s3">\n\t </span><span class="s1">*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the</span><span class="s3">\n\t </span><span class="s1">*     closest element that is smaller than or greater than the one we are</span><span class="s3">\n\t </span><span class="s1">*     searching for, respectively, if the exact element cannot be found.</span><span class="s3">\n\t </span><span class="s1">*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* and an object is returned with the following properties:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*   - line: The line number in the generated source, or null.  The</span><span class="s3">\n\t </span><span class="s1">*     line number is 1-based.</span><span class="s3">\n\t </span><span class="s1">*   - column: The column number in the generated source, or null.</span><span class="s3">\n\t </span><span class="s1">*     The column number is 0-based.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">BasicSourceMapConsumer.prototype.generatedPositionFor =</span><span class="s3">\n\t  </span><span class="s1">function SourceMapConsumer_generatedPositionFor(aArgs) {</span><span class="s3">\n\t    </span><span class="s1">var source = util.getArg(aArgs, 'source');</span><span class="s3">\n\t    </span><span class="s1">source = this._findSourceIndex(source);</span><span class="s3">\n\t    </span><span class="s1">if (source &lt; 0) {</span><span class="s3">\n\t      </span><span class="s1">return {</span><span class="s3">\n\t        </span><span class="s1">line: null,</span><span class="s3">\n\t        </span><span class="s1">column: null,</span><span class="s3">\n\t        </span><span class="s1">lastColumn: null</span><span class="s3">\n\t      </span><span class="s1">};</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">var needle = {</span><span class="s3">\n\t      </span><span class="s1">source: source,</span><span class="s3">\n\t      </span><span class="s1">originalLine: util.getArg(aArgs, 'line'),</span><span class="s3">\n\t      </span><span class="s1">originalColumn: util.getArg(aArgs, 'column')</span><span class="s3">\n\t    </span><span class="s1">};</span><span class="s3">\n\t\n\t    </span><span class="s1">var index = this._findMapping(</span><span class="s3">\n\t      </span><span class="s1">needle,</span><span class="s3">\n\t      </span><span class="s1">this._originalMappings,</span><span class="s3">\n\t      \&quot;</span><span class="s1">originalLine</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t      \&quot;</span><span class="s1">originalColumn</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t      </span><span class="s1">util.compareByOriginalPositions,</span><span class="s3">\n\t      </span><span class="s1">util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)</span><span class="s3">\n\t    </span><span class="s1">);</span><span class="s3">\n\t\n\t    </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n\t      </span><span class="s1">var mapping = this._originalMappings[index];</span><span class="s3">\n\t\n\t      </span><span class="s1">if (mapping.source === needle.source) {</span><span class="s3">\n\t        </span><span class="s1">return {</span><span class="s3">\n\t          </span><span class="s1">line: util.getArg(mapping, 'generatedLine', null),</span><span class="s3">\n\t          </span><span class="s1">column: util.getArg(mapping, 'generatedColumn', null),</span><span class="s3">\n\t          </span><span class="s1">lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)</span><span class="s3">\n\t        </span><span class="s1">};</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">return {</span><span class="s3">\n\t      </span><span class="s1">line: null,</span><span class="s3">\n\t      </span><span class="s1">column: null,</span><span class="s3">\n\t      </span><span class="s1">lastColumn: null</span><span class="s3">\n\t    </span><span class="s1">};</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">exports.BasicSourceMapConsumer = BasicSourceMapConsumer;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* An IndexedSourceMapConsumer instance represents a parsed source map which</span><span class="s3">\n\t </span><span class="s1">* we can query for information. It differs from BasicSourceMapConsumer in</span><span class="s3">\n\t </span><span class="s1">* that it takes </span><span class="s3">\&quot;</span><span class="s1">indexed</span><span class="s3">\&quot; </span><span class="s1">source maps (i.e. ones with a </span><span class="s3">\&quot;</span><span class="s1">sections</span><span class="s3">\&quot; </span><span class="s1">field) as</span><span class="s3">\n\t </span><span class="s1">* input.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* The first parameter is a raw source map (either as a JSON string, or already</span><span class="s3">\n\t </span><span class="s1">* parsed to an object). According to the spec for indexed source maps, they</span><span class="s3">\n\t </span><span class="s1">* have the following attributes:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*   - version: Which version of the source map spec this map is following.</span><span class="s3">\n\t </span><span class="s1">*   - file: Optional. The generated file this source map is associated with.</span><span class="s3">\n\t </span><span class="s1">*   - sections: A list of section definitions.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* Each value under the </span><span class="s3">\&quot;</span><span class="s1">sections</span><span class="s3">\&quot; </span><span class="s1">field has two fields:</span><span class="s3">\n\t </span><span class="s1">*   - offset: The offset into the original specified at which this section</span><span class="s3">\n\t </span><span class="s1">*       begins to apply, defined as an object with a </span><span class="s3">\&quot;</span><span class="s1">line</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">column</span><span class="s3">\&quot;\n\t </span><span class="s1">*       field.</span><span class="s3">\n\t </span><span class="s1">*   - map: A source map definition. This source map could also be indexed,</span><span class="s3">\n\t </span><span class="s1">*       but doesn't have to be.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* Instead of the </span><span class="s3">\&quot;</span><span class="s1">map</span><span class="s3">\&quot; </span><span class="s1">field, it's also possible to have a </span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">field</span><span class="s3">\n\t </span><span class="s1">* specifying a URL to retrieve a source map from, but that's currently</span><span class="s3">\n\t </span><span class="s1">* unsupported.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* Here's an example source map, taken from the source map spec[0], but</span><span class="s3">\n\t </span><span class="s1">* modified to omit a section which uses the </span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">field.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*  {</span><span class="s3">\n\t </span><span class="s1">*    version : 3,</span><span class="s3">\n\t </span><span class="s1">*    file: </span><span class="s3">\&quot;</span><span class="s1">app.js</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t </span><span class="s1">*    sections: [{</span><span class="s3">\n\t </span><span class="s1">*      offset: {line:100, column:10},</span><span class="s3">\n\t </span><span class="s1">*      map: {</span><span class="s3">\n\t </span><span class="s1">*        version : 3,</span><span class="s3">\n\t </span><span class="s1">*        file: </span><span class="s3">\&quot;</span><span class="s1">section.js</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\t </span><span class="s1">*        sources: [</span><span class="s3">\&quot;</span><span class="s1">foo.js</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">bar.js</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n\t </span><span class="s1">*        names: [</span><span class="s3">\&quot;</span><span class="s1">src</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">maps</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">are</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">fun</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n\t </span><span class="s1">*        mappings: </span><span class="s3">\&quot;</span><span class="s1">AAAA,E;;ABCDE;</span><span class="s3">\&quot;\n\t </span><span class="s1">*      }</span><span class="s3">\n\t </span><span class="s1">*    }],</span><span class="s3">\n\t </span><span class="s1">*  }</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* The second parameter, if given, is a string whose value is the URL</span><span class="s3">\n\t </span><span class="s1">* at which the source map was found.  This URL is used to compute the</span><span class="s3">\n\t </span><span class="s1">* sources array.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {</span><span class="s3">\n\t  </span><span class="s1">var sourceMap = aSourceMap;</span><span class="s3">\n\t  </span><span class="s1">if (typeof aSourceMap === 'string') {</span><span class="s3">\n\t    </span><span class="s1">sourceMap = util.parseSourceMapInput(aSourceMap);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">var version = util.getArg(sourceMap, 'version');</span><span class="s3">\n\t  </span><span class="s1">var sections = util.getArg(sourceMap, 'sections');</span><span class="s3">\n\t\n\t  </span><span class="s1">if (version != this._version) {</span><span class="s3">\n\t    </span><span class="s1">throw new Error('Unsupported version: ' + version);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">this._sources = new ArraySet();</span><span class="s3">\n\t  </span><span class="s1">this._names = new ArraySet();</span><span class="s3">\n\t\n\t  </span><span class="s1">var lastOffset = {</span><span class="s3">\n\t    </span><span class="s1">line: -1,</span><span class="s3">\n\t    </span><span class="s1">column: 0</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t  </span><span class="s1">this._sections = sections.map(function (s) {</span><span class="s3">\n\t    </span><span class="s1">if (s.url) {</span><span class="s3">\n\t      </span><span class="s1">// The url field will require support for asynchronicity.</span><span class="s3">\n\t      </span><span class="s1">// See https://github.com/mozilla/source-map/issues/16</span><span class="s3">\n\t      </span><span class="s1">throw new Error('Support for url field in sections not implemented.');</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">var offset = util.getArg(s, 'offset');</span><span class="s3">\n\t    </span><span class="s1">var offsetLine = util.getArg(offset, 'line');</span><span class="s3">\n\t    </span><span class="s1">var offsetColumn = util.getArg(offset, 'column');</span><span class="s3">\n\t\n\t    </span><span class="s1">if (offsetLine &lt; lastOffset.line ||</span><span class="s3">\n\t        </span><span class="s1">(offsetLine === lastOffset.line &amp;&amp; offsetColumn &lt; lastOffset.column)) {</span><span class="s3">\n\t      </span><span class="s1">throw new Error('Section offsets must be ordered and non-overlapping.');</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">lastOffset = offset;</span><span class="s3">\n\t\n\t    </span><span class="s1">return {</span><span class="s3">\n\t      </span><span class="s1">generatedOffset: {</span><span class="s3">\n\t        </span><span class="s1">// The offset fields are 0-based, but we use 1-based indices when</span><span class="s3">\n\t        </span><span class="s1">// encoding/decoding from VLQ.</span><span class="s3">\n\t        </span><span class="s1">generatedLine: offsetLine + 1,</span><span class="s3">\n\t        </span><span class="s1">generatedColumn: offsetColumn + 1</span><span class="s3">\n\t      </span><span class="s1">},</span><span class="s3">\n\t      </span><span class="s1">consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">});</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);</span><span class="s3">\n\t</span><span class="s1">IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* The version of the source mapping spec that we are consuming.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">IndexedSourceMapConsumer.prototype._version = 3;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* The list of original sources.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {</span><span class="s3">\n\t  </span><span class="s1">get: function () {</span><span class="s3">\n\t    </span><span class="s1">var sources = [];</span><span class="s3">\n\t    </span><span class="s1">for (var i = 0; i &lt; this._sections.length; i++) {</span><span class="s3">\n\t      </span><span class="s1">for (var j = 0; j &lt; this._sections[i].consumer.sources.length; j++) {</span><span class="s3">\n\t        </span><span class="s1">sources.push(this._sections[i].consumer.sources[j]);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">return sources;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">});</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Returns the original source, line, and column information for the generated</span><span class="s3">\n\t </span><span class="s1">* source's line and column positions provided. The only argument is an object</span><span class="s3">\n\t </span><span class="s1">* with the following properties:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*   - line: The line number in the generated source.  The line number</span><span class="s3">\n\t </span><span class="s1">*     is 1-based.</span><span class="s3">\n\t </span><span class="s1">*   - column: The column number in the generated source.  The column</span><span class="s3">\n\t </span><span class="s1">*     number is 0-based.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* and an object is returned with the following properties:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*   - source: The original source file, or null.</span><span class="s3">\n\t </span><span class="s1">*   - line: The line number in the original source, or null.  The</span><span class="s3">\n\t </span><span class="s1">*     line number is 1-based.</span><span class="s3">\n\t </span><span class="s1">*   - column: The column number in the original source, or null.  The</span><span class="s3">\n\t </span><span class="s1">*     column number is 0-based.</span><span class="s3">\n\t </span><span class="s1">*   - name: The original identifier, or null.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">IndexedSourceMapConsumer.prototype.originalPositionFor =</span><span class="s3">\n\t  </span><span class="s1">function IndexedSourceMapConsumer_originalPositionFor(aArgs) {</span><span class="s3">\n\t    </span><span class="s1">var needle = {</span><span class="s3">\n\t      </span><span class="s1">generatedLine: util.getArg(aArgs, 'line'),</span><span class="s3">\n\t      </span><span class="s1">generatedColumn: util.getArg(aArgs, 'column')</span><span class="s3">\n\t    </span><span class="s1">};</span><span class="s3">\n\t\n\t    </span><span class="s1">// Find the section containing the generated position we're trying to map</span><span class="s3">\n\t    </span><span class="s1">// to an original position.</span><span class="s3">\n\t    </span><span class="s1">var sectionIndex = binarySearch.search(needle, this._sections,</span><span class="s3">\n\t      </span><span class="s1">function(needle, section) {</span><span class="s3">\n\t        </span><span class="s1">var cmp = needle.generatedLine - section.generatedOffset.generatedLine;</span><span class="s3">\n\t        </span><span class="s1">if (cmp) {</span><span class="s3">\n\t          </span><span class="s1">return cmp;</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t\n\t        </span><span class="s1">return (needle.generatedColumn -</span><span class="s3">\n\t                </span><span class="s1">section.generatedOffset.generatedColumn);</span><span class="s3">\n\t      </span><span class="s1">});</span><span class="s3">\n\t    </span><span class="s1">var section = this._sections[sectionIndex];</span><span class="s3">\n\t\n\t    </span><span class="s1">if (!section) {</span><span class="s3">\n\t      </span><span class="s1">return {</span><span class="s3">\n\t        </span><span class="s1">source: null,</span><span class="s3">\n\t        </span><span class="s1">line: null,</span><span class="s3">\n\t        </span><span class="s1">column: null,</span><span class="s3">\n\t        </span><span class="s1">name: null</span><span class="s3">\n\t      </span><span class="s1">};</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">return section.consumer.originalPositionFor({</span><span class="s3">\n\t      </span><span class="s1">line: needle.generatedLine -</span><span class="s3">\n\t        </span><span class="s1">(section.generatedOffset.generatedLine - 1),</span><span class="s3">\n\t      </span><span class="s1">column: needle.generatedColumn -</span><span class="s3">\n\t        </span><span class="s1">(section.generatedOffset.generatedLine === needle.generatedLine</span><span class="s3">\n\t         </span><span class="s1">? section.generatedOffset.generatedColumn - 1</span><span class="s3">\n\t         </span><span class="s1">: 0),</span><span class="s3">\n\t      </span><span class="s1">bias: aArgs.bias</span><span class="s3">\n\t    </span><span class="s1">});</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Return true if we have the source content for every source in the source</span><span class="s3">\n\t </span><span class="s1">* map, false otherwise.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =</span><span class="s3">\n\t  </span><span class="s1">function IndexedSourceMapConsumer_hasContentsOfAllSources() {</span><span class="s3">\n\t    </span><span class="s1">return this._sections.every(function (s) {</span><span class="s3">\n\t      </span><span class="s1">return s.consumer.hasContentsOfAllSources();</span><span class="s3">\n\t    </span><span class="s1">});</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Returns the original source content. The only argument is the url of the</span><span class="s3">\n\t </span><span class="s1">* original source file. Returns null if no original source content is</span><span class="s3">\n\t </span><span class="s1">* available.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">IndexedSourceMapConsumer.prototype.sourceContentFor =</span><span class="s3">\n\t  </span><span class="s1">function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {</span><span class="s3">\n\t    </span><span class="s1">for (var i = 0; i &lt; this._sections.length; i++) {</span><span class="s3">\n\t      </span><span class="s1">var section = this._sections[i];</span><span class="s3">\n\t\n\t      </span><span class="s1">var content = section.consumer.sourceContentFor(aSource, true);</span><span class="s3">\n\t      </span><span class="s1">if (content) {</span><span class="s3">\n\t        </span><span class="s1">return content;</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">if (nullOnMissing) {</span><span class="s3">\n\t      </span><span class="s1">return null;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">else {</span><span class="s3">\n\t      </span><span class="s1">throw new Error('</span><span class="s3">\&quot;</span><span class="s1">' + aSource + '</span><span class="s3">\&quot; </span><span class="s1">is not in the SourceMap.');</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Returns the generated line and column information for the original source,</span><span class="s3">\n\t </span><span class="s1">* line, and column positions provided. The only argument is an object with</span><span class="s3">\n\t </span><span class="s1">* the following properties:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*   - source: The filename of the original source.</span><span class="s3">\n\t </span><span class="s1">*   - line: The line number in the original source.  The line number</span><span class="s3">\n\t </span><span class="s1">*     is 1-based.</span><span class="s3">\n\t </span><span class="s1">*   - column: The column number in the original source.  The column</span><span class="s3">\n\t </span><span class="s1">*     number is 0-based.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* and an object is returned with the following properties:</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">*   - line: The line number in the generated source, or null.  The</span><span class="s3">\n\t </span><span class="s1">*     line number is 1-based. </span><span class="s3">\n\t </span><span class="s1">*   - column: The column number in the generated source, or null.</span><span class="s3">\n\t </span><span class="s1">*     The column number is 0-based.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">IndexedSourceMapConsumer.prototype.generatedPositionFor =</span><span class="s3">\n\t  </span><span class="s1">function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {</span><span class="s3">\n\t    </span><span class="s1">for (var i = 0; i &lt; this._sections.length; i++) {</span><span class="s3">\n\t      </span><span class="s1">var section = this._sections[i];</span><span class="s3">\n\t\n\t      </span><span class="s1">// Only consider this section if the requested source is in the list of</span><span class="s3">\n\t      </span><span class="s1">// sources of the consumer.</span><span class="s3">\n\t      </span><span class="s1">if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {</span><span class="s3">\n\t        </span><span class="s1">continue;</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">var generatedPosition = section.consumer.generatedPositionFor(aArgs);</span><span class="s3">\n\t      </span><span class="s1">if (generatedPosition) {</span><span class="s3">\n\t        </span><span class="s1">var ret = {</span><span class="s3">\n\t          </span><span class="s1">line: generatedPosition.line +</span><span class="s3">\n\t            </span><span class="s1">(section.generatedOffset.generatedLine - 1),</span><span class="s3">\n\t          </span><span class="s1">column: generatedPosition.column +</span><span class="s3">\n\t            </span><span class="s1">(section.generatedOffset.generatedLine === generatedPosition.line</span><span class="s3">\n\t             </span><span class="s1">? section.generatedOffset.generatedColumn - 1</span><span class="s3">\n\t             </span><span class="s1">: 0)</span><span class="s3">\n\t        </span><span class="s1">};</span><span class="s3">\n\t        </span><span class="s1">return ret;</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">return {</span><span class="s3">\n\t      </span><span class="s1">line: null,</span><span class="s3">\n\t      </span><span class="s1">column: null</span><span class="s3">\n\t    </span><span class="s1">};</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Parse the mappings in a string in to a data structure which we can easily</span><span class="s3">\n\t </span><span class="s1">* query (the ordered arrays in the `this.__generatedMappings` and</span><span class="s3">\n\t </span><span class="s1">* `this.__originalMappings` properties).</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">IndexedSourceMapConsumer.prototype._parseMappings =</span><span class="s3">\n\t  </span><span class="s1">function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {</span><span class="s3">\n\t    </span><span class="s1">this.__generatedMappings = [];</span><span class="s3">\n\t    </span><span class="s1">this.__originalMappings = [];</span><span class="s3">\n\t    </span><span class="s1">for (var i = 0; i &lt; this._sections.length; i++) {</span><span class="s3">\n\t      </span><span class="s1">var section = this._sections[i];</span><span class="s3">\n\t      </span><span class="s1">var sectionMappings = section.consumer._generatedMappings;</span><span class="s3">\n\t      </span><span class="s1">for (var j = 0; j &lt; sectionMappings.length; j++) {</span><span class="s3">\n\t        </span><span class="s1">var mapping = sectionMappings[j];</span><span class="s3">\n\t\n\t        </span><span class="s1">var source = section.consumer._sources.at(mapping.source);</span><span class="s3">\n\t        </span><span class="s1">source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);</span><span class="s3">\n\t        </span><span class="s1">this._sources.add(source);</span><span class="s3">\n\t        </span><span class="s1">source = this._sources.indexOf(source);</span><span class="s3">\n\t\n\t        </span><span class="s1">var name = null;</span><span class="s3">\n\t        </span><span class="s1">if (mapping.name) {</span><span class="s3">\n\t          </span><span class="s1">name = section.consumer._names.at(mapping.name);</span><span class="s3">\n\t          </span><span class="s1">this._names.add(name);</span><span class="s3">\n\t          </span><span class="s1">name = this._names.indexOf(name);</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t\n\t        </span><span class="s1">// The mappings coming from the consumer for the section have</span><span class="s3">\n\t        </span><span class="s1">// generated positions relative to the start of the section, so we</span><span class="s3">\n\t        </span><span class="s1">// need to offset them to be relative to the start of the concatenated</span><span class="s3">\n\t        </span><span class="s1">// generated file.</span><span class="s3">\n\t        </span><span class="s1">var adjustedMapping = {</span><span class="s3">\n\t          </span><span class="s1">source: source,</span><span class="s3">\n\t          </span><span class="s1">generatedLine: mapping.generatedLine +</span><span class="s3">\n\t            </span><span class="s1">(section.generatedOffset.generatedLine - 1),</span><span class="s3">\n\t          </span><span class="s1">generatedColumn: mapping.generatedColumn +</span><span class="s3">\n\t            </span><span class="s1">(section.generatedOffset.generatedLine === mapping.generatedLine</span><span class="s3">\n\t            </span><span class="s1">? section.generatedOffset.generatedColumn - 1</span><span class="s3">\n\t            </span><span class="s1">: 0),</span><span class="s3">\n\t          </span><span class="s1">originalLine: mapping.originalLine,</span><span class="s3">\n\t          </span><span class="s1">originalColumn: mapping.originalColumn,</span><span class="s3">\n\t          </span><span class="s1">name: name</span><span class="s3">\n\t        </span><span class="s1">};</span><span class="s3">\n\t\n\t        </span><span class="s1">this.__generatedMappings.push(adjustedMapping);</span><span class="s3">\n\t        </span><span class="s1">if (typeof adjustedMapping.originalLine === 'number') {</span><span class="s3">\n\t          </span><span class="s1">this.__originalMappings.push(adjustedMapping);</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);</span><span class="s3">\n\t    </span><span class="s1">quickSort(this.__originalMappings, util.compareByOriginalPositions);</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;</span><span class="s3">\n\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 8 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports) {</span><span class="s3">\n\n\t</span><span class="s1">/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n\t</span><span class="s1">/*</span><span class="s3">\n\t </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n\t </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n\t </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t\n\t</span><span class="s1">exports.GREATEST_LOWER_BOUND = 1;</span><span class="s3">\n\t</span><span class="s1">exports.LEAST_UPPER_BOUND = 2;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Recursive implementation of binary search.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param aLow Indices here and lower do not contain the needle.</span><span class="s3">\n\t </span><span class="s1">* @param aHigh Indices here and higher do not contain the needle.</span><span class="s3">\n\t </span><span class="s1">* @param aNeedle The element being searched for.</span><span class="s3">\n\t </span><span class="s1">* @param aHaystack The non-empty array being searched.</span><span class="s3">\n\t </span><span class="s1">* @param aCompare Function which takes two elements and returns -1, 0, or 1.</span><span class="s3">\n\t </span><span class="s1">* @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or</span><span class="s3">\n\t </span><span class="s1">*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the</span><span class="s3">\n\t </span><span class="s1">*     closest element that is smaller than or greater than the one we are</span><span class="s3">\n\t </span><span class="s1">*     searching for, respectively, if the exact element cannot be found.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {</span><span class="s3">\n\t  </span><span class="s1">// This function terminates when one of the following is true:</span><span class="s3">\n\t  </span><span class="s1">//</span><span class="s3">\n\t  </span><span class="s1">//   1. We find the exact element we are looking for.</span><span class="s3">\n\t  </span><span class="s1">//</span><span class="s3">\n\t  </span><span class="s1">//   2. We did not find the exact element, but we can return the index of</span><span class="s3">\n\t  </span><span class="s1">//      the next-closest element.</span><span class="s3">\n\t  </span><span class="s1">//</span><span class="s3">\n\t  </span><span class="s1">//   3. We did not find the exact element, and there is no next-closest</span><span class="s3">\n\t  </span><span class="s1">//      element than the one we are searching for, so we return -1.</span><span class="s3">\n\t  </span><span class="s1">var mid = Math.floor((aHigh - aLow) / 2) + aLow;</span><span class="s3">\n\t  </span><span class="s1">var cmp = aCompare(aNeedle, aHaystack[mid], true);</span><span class="s3">\n\t  </span><span class="s1">if (cmp === 0) {</span><span class="s3">\n\t    </span><span class="s1">// Found the element we are looking for.</span><span class="s3">\n\t    </span><span class="s1">return mid;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">else if (cmp &gt; 0) {</span><span class="s3">\n\t    </span><span class="s1">// Our needle is greater than aHaystack[mid].</span><span class="s3">\n\t    </span><span class="s1">if (aHigh - mid &gt; 1) {</span><span class="s3">\n\t      </span><span class="s1">// The element is in the upper half.</span><span class="s3">\n\t      </span><span class="s1">return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">// The exact needle element was not found in this haystack. Determine if</span><span class="s3">\n\t    </span><span class="s1">// we are in termination case (3) or (2) and return the appropriate thing.</span><span class="s3">\n\t    </span><span class="s1">if (aBias == exports.LEAST_UPPER_BOUND) {</span><span class="s3">\n\t      </span><span class="s1">return aHigh &lt; aHaystack.length ? aHigh : -1;</span><span class="s3">\n\t    </span><span class="s1">} else {</span><span class="s3">\n\t      </span><span class="s1">return mid;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">else {</span><span class="s3">\n\t    </span><span class="s1">// Our needle is less than aHaystack[mid].</span><span class="s3">\n\t    </span><span class="s1">if (mid - aLow &gt; 1) {</span><span class="s3">\n\t      </span><span class="s1">// The element is in the lower half.</span><span class="s3">\n\t      </span><span class="s1">return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">// we are in termination case (3) or (2) and return the appropriate thing.</span><span class="s3">\n\t    </span><span class="s1">if (aBias == exports.LEAST_UPPER_BOUND) {</span><span class="s3">\n\t      </span><span class="s1">return mid;</span><span class="s3">\n\t    </span><span class="s1">} else {</span><span class="s3">\n\t      </span><span class="s1">return aLow &lt; 0 ? -1 : aLow;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* This is an implementation of binary search which will always try and return</span><span class="s3">\n\t </span><span class="s1">* the index of the closest element if there is no exact hit. This is because</span><span class="s3">\n\t </span><span class="s1">* mappings between original and generated line/col pairs are single points,</span><span class="s3">\n\t </span><span class="s1">* and there is an implicit region between each of them, so a miss just means</span><span class="s3">\n\t </span><span class="s1">* that you aren't on the very start of a region.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param aNeedle The element you are looking for.</span><span class="s3">\n\t </span><span class="s1">* @param aHaystack The array that is being searched.</span><span class="s3">\n\t </span><span class="s1">* @param aCompare A function which takes the needle and an element in the</span><span class="s3">\n\t </span><span class="s1">*     array and returns -1, 0, or 1 depending on whether the needle is less</span><span class="s3">\n\t </span><span class="s1">*     than, equal to, or greater than the element, respectively.</span><span class="s3">\n\t </span><span class="s1">* @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or</span><span class="s3">\n\t </span><span class="s1">*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the</span><span class="s3">\n\t </span><span class="s1">*     closest element that is smaller than or greater than the one we are</span><span class="s3">\n\t </span><span class="s1">*     searching for, respectively, if the exact element cannot be found.</span><span class="s3">\n\t </span><span class="s1">*     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {</span><span class="s3">\n\t  </span><span class="s1">if (aHaystack.length === 0) {</span><span class="s3">\n\t    </span><span class="s1">return -1;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,</span><span class="s3">\n\t                              </span><span class="s1">aCompare, aBias || exports.GREATEST_LOWER_BOUND);</span><span class="s3">\n\t  </span><span class="s1">if (index &lt; 0) {</span><span class="s3">\n\t    </span><span class="s1">return -1;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">// We have found either the exact element, or the next-closest element than</span><span class="s3">\n\t  </span><span class="s1">// the one we are searching for. However, there may be more than one such</span><span class="s3">\n\t  </span><span class="s1">// element. Make sure we always return the smallest of these.</span><span class="s3">\n\t  </span><span class="s1">while (index - 1 &gt;= 0) {</span><span class="s3">\n\t    </span><span class="s1">if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {</span><span class="s3">\n\t      </span><span class="s1">break;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">--index;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t\n\t  </span><span class="s1">return index;</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 9 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports) {</span><span class="s3">\n\n\t</span><span class="s1">/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n\t</span><span class="s1">/*</span><span class="s3">\n\t </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n\t </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n\t </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t\n\t</span><span class="s1">// It turns out that some (most?) JavaScript engines don't self-host</span><span class="s3">\n\t</span><span class="s1">// `Array.prototype.sort`. This makes sense because C++ will likely remain</span><span class="s3">\n\t</span><span class="s1">// faster than JS when doing raw CPU-intensive sorting. However, when using a</span><span class="s3">\n\t</span><span class="s1">// custom comparator function, calling back and forth between the VM's C++ and</span><span class="s3">\n\t</span><span class="s1">// JIT'd JS is rather slow *and* loses JIT type information, resulting in</span><span class="s3">\n\t</span><span class="s1">// worse generated code for the comparator function than would be optimal. In</span><span class="s3">\n\t</span><span class="s1">// fact, when sorting with a comparator, these costs outweigh the benefits of</span><span class="s3">\n\t</span><span class="s1">// sorting in C++. By using our own JS-implemented Quick Sort (below), we get</span><span class="s3">\n\t</span><span class="s1">// a ~3500ms mean speed-up in `bench/bench.html`.</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Swap the elements indexed by `x` and `y` in the array `ary`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param {Array} ary</span><span class="s3">\n\t </span><span class="s1">*        The array.</span><span class="s3">\n\t </span><span class="s1">* @param {Number} x</span><span class="s3">\n\t </span><span class="s1">*        The index of the first item.</span><span class="s3">\n\t </span><span class="s1">* @param {Number} y</span><span class="s3">\n\t </span><span class="s1">*        The index of the second item.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function swap(ary, x, y) {</span><span class="s3">\n\t  </span><span class="s1">var temp = ary[x];</span><span class="s3">\n\t  </span><span class="s1">ary[x] = ary[y];</span><span class="s3">\n\t  </span><span class="s1">ary[y] = temp;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Returns a random integer within the range `low .. high` inclusive.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param {Number} low</span><span class="s3">\n\t </span><span class="s1">*        The lower bound on the range.</span><span class="s3">\n\t </span><span class="s1">* @param {Number} high</span><span class="s3">\n\t </span><span class="s1">*        The upper bound on the range.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function randomIntInRange(low, high) {</span><span class="s3">\n\t  </span><span class="s1">return Math.round(low + (Math.random() * (high - low)));</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* The Quick Sort algorithm.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param {Array} ary</span><span class="s3">\n\t </span><span class="s1">*        An array to sort.</span><span class="s3">\n\t </span><span class="s1">* @param {function} comparator</span><span class="s3">\n\t </span><span class="s1">*        Function to use to compare two items.</span><span class="s3">\n\t </span><span class="s1">* @param {Number} p</span><span class="s3">\n\t </span><span class="s1">*        Start index of the array</span><span class="s3">\n\t </span><span class="s1">* @param {Number} r</span><span class="s3">\n\t </span><span class="s1">*        End index of the array</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function doQuickSort(ary, comparator, p, r) {</span><span class="s3">\n\t  </span><span class="s1">// If our lower bound is less than our upper bound, we (1) partition the</span><span class="s3">\n\t  </span><span class="s1">// array into two pieces and (2) recurse on each half. If it is not, this is</span><span class="s3">\n\t  </span><span class="s1">// the empty array and our base case.</span><span class="s3">\n\t\n\t  </span><span class="s1">if (p &lt; r) {</span><span class="s3">\n\t    </span><span class="s1">// (1) Partitioning.</span><span class="s3">\n\t    </span><span class="s1">//</span><span class="s3">\n\t    </span><span class="s1">// The partitioning chooses a pivot between `p` and `r` and moves all</span><span class="s3">\n\t    </span><span class="s1">// elements that are less than or equal to the pivot to the before it, and</span><span class="s3">\n\t    </span><span class="s1">// all the elements that are greater than it after it. The effect is that</span><span class="s3">\n\t    </span><span class="s1">// once partition is done, the pivot is in the exact place it will be when</span><span class="s3">\n\t    </span><span class="s1">// the array is put in sorted order, and it will not need to be moved</span><span class="s3">\n\t    </span><span class="s1">// again. This runs in O(n) time.</span><span class="s3">\n\t\n\t    </span><span class="s1">// Always choose a random pivot so that an input array which is reverse</span><span class="s3">\n\t    </span><span class="s1">// sorted does not cause O(n^2) running time.</span><span class="s3">\n\t    </span><span class="s1">var pivotIndex = randomIntInRange(p, r);</span><span class="s3">\n\t    </span><span class="s1">var i = p - 1;</span><span class="s3">\n\t\n\t    </span><span class="s1">swap(ary, pivotIndex, r);</span><span class="s3">\n\t    </span><span class="s1">var pivot = ary[r];</span><span class="s3">\n\t\n\t    </span><span class="s1">// Immediately after `j` is incremented in this loop, the following hold</span><span class="s3">\n\t    </span><span class="s1">// true:</span><span class="s3">\n\t    </span><span class="s1">//</span><span class="s3">\n\t    </span><span class="s1">//   * Every element in `ary[p .. i]` is less than or equal to the pivot.</span><span class="s3">\n\t    </span><span class="s1">//</span><span class="s3">\n\t    </span><span class="s1">//   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.</span><span class="s3">\n\t    </span><span class="s1">for (var j = p; j &lt; r; j++) {</span><span class="s3">\n\t      </span><span class="s1">if (comparator(ary[j], pivot) &lt;= 0) {</span><span class="s3">\n\t        </span><span class="s1">i += 1;</span><span class="s3">\n\t        </span><span class="s1">swap(ary, i, j);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">swap(ary, i + 1, j);</span><span class="s3">\n\t    </span><span class="s1">var q = i + 1;</span><span class="s3">\n\t\n\t    </span><span class="s1">// (2) Recurse on each half.</span><span class="s3">\n\t\n\t    </span><span class="s1">doQuickSort(ary, comparator, p, q - 1);</span><span class="s3">\n\t    </span><span class="s1">doQuickSort(ary, comparator, q + 1, r);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Sort the given array in-place with the given comparator function.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param {Array} ary</span><span class="s3">\n\t </span><span class="s1">*        An array to sort.</span><span class="s3">\n\t </span><span class="s1">* @param {function} comparator</span><span class="s3">\n\t </span><span class="s1">*        Function to use to compare two items.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">exports.quickSort = function (ary, comparator) {</span><span class="s3">\n\t  </span><span class="s1">doQuickSort(ary, comparator, 0, ary.length - 1);</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 10 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\t</span><span class="s1">/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n\t</span><span class="s1">/*</span><span class="s3">\n\t </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n\t </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n\t </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t\n\t</span><span class="s1">var SourceMapGenerator = __webpack_require__(1).SourceMapGenerator;</span><span class="s3">\n\t</span><span class="s1">var util = __webpack_require__(4);</span><span class="s3">\n\t\n\t</span><span class="s1">// Matches a Windows-style `</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n` newline or a `</span><span class="s3">\\</span><span class="s1">n` newline used by all other</span><span class="s3">\n\t</span><span class="s1">// operating systems these days (capturing the result).</span><span class="s3">\n\t</span><span class="s1">var REGEX_NEWLINE = /(</span><span class="s3">\\</span><span class="s1">r?</span><span class="s3">\\</span><span class="s1">n)/;</span><span class="s3">\n\t\n\t</span><span class="s1">// Newline character code for charCodeAt() comparisons</span><span class="s3">\n\t</span><span class="s1">var NEWLINE_CODE = 10;</span><span class="s3">\n\t\n\t</span><span class="s1">// Private symbol for identifying `SourceNode`s when multiple versions of</span><span class="s3">\n\t</span><span class="s1">// the source-map library are loaded. This MUST NOT CHANGE across</span><span class="s3">\n\t</span><span class="s1">// versions!</span><span class="s3">\n\t</span><span class="s1">var isSourceNode = </span><span class="s3">\&quot;</span><span class="s1">$$$isSourceNode$$$</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* SourceNodes provide a way to abstract over interpolating/concatenating</span><span class="s3">\n\t </span><span class="s1">* snippets of generated JavaScript source code while maintaining the line and</span><span class="s3">\n\t </span><span class="s1">* column information associated with the original source code.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param aLine The original line number.</span><span class="s3">\n\t </span><span class="s1">* @param aColumn The original column number.</span><span class="s3">\n\t </span><span class="s1">* @param aSource The original source's filename.</span><span class="s3">\n\t </span><span class="s1">* @param aChunks Optional. An array of strings which are snippets of</span><span class="s3">\n\t </span><span class="s1">*        generated JS, or other SourceNodes.</span><span class="s3">\n\t </span><span class="s1">* @param aName The original identifier.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">function SourceNode(aLine, aColumn, aSource, aChunks, aName) {</span><span class="s3">\n\t  </span><span class="s1">this.children = [];</span><span class="s3">\n\t  </span><span class="s1">this.sourceContents = {};</span><span class="s3">\n\t  </span><span class="s1">this.line = aLine == null ? null : aLine;</span><span class="s3">\n\t  </span><span class="s1">this.column = aColumn == null ? null : aColumn;</span><span class="s3">\n\t  </span><span class="s1">this.source = aSource == null ? null : aSource;</span><span class="s3">\n\t  </span><span class="s1">this.name = aName == null ? null : aName;</span><span class="s3">\n\t  </span><span class="s1">this[isSourceNode] = true;</span><span class="s3">\n\t  </span><span class="s1">if (aChunks != null) this.add(aChunks);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Creates a SourceNode from generated code and a SourceMapConsumer.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param aGeneratedCode The generated code</span><span class="s3">\n\t </span><span class="s1">* @param aSourceMapConsumer The SourceMap for the generated code</span><span class="s3">\n\t </span><span class="s1">* @param aRelativePath Optional. The path that relative sources in the</span><span class="s3">\n\t </span><span class="s1">*        SourceMapConsumer should be relative to.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceNode.fromStringWithSourceMap =</span><span class="s3">\n\t  </span><span class="s1">function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {</span><span class="s3">\n\t    </span><span class="s1">// The SourceNode we want to fill with the generated code</span><span class="s3">\n\t    </span><span class="s1">// and the SourceMap</span><span class="s3">\n\t    </span><span class="s1">var node = new SourceNode();</span><span class="s3">\n\t\n\t    </span><span class="s1">// All even indices of this array are one line of the generated code,</span><span class="s3">\n\t    </span><span class="s1">// while all odd indices are the newlines between two adjacent lines</span><span class="s3">\n\t    </span><span class="s1">// (since `REGEX_NEWLINE` captures its match).</span><span class="s3">\n\t    </span><span class="s1">// Processed fragments are accessed by calling `shiftNextLine`.</span><span class="s3">\n\t    </span><span class="s1">var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);</span><span class="s3">\n\t    </span><span class="s1">var remainingLinesIndex = 0;</span><span class="s3">\n\t    </span><span class="s1">var shiftNextLine = function() {</span><span class="s3">\n\t      </span><span class="s1">var lineContents = getNextLine();</span><span class="s3">\n\t      </span><span class="s1">// The last line of a file might not have a newline.</span><span class="s3">\n\t      </span><span class="s1">var newLine = getNextLine() || </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n\t      </span><span class="s1">return lineContents + newLine;</span><span class="s3">\n\t\n\t      </span><span class="s1">function getNextLine() {</span><span class="s3">\n\t        </span><span class="s1">return remainingLinesIndex &lt; remainingLines.length ?</span><span class="s3">\n\t            </span><span class="s1">remainingLines[remainingLinesIndex++] : undefined;</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">};</span><span class="s3">\n\t\n\t    </span><span class="s1">// We need to remember the position of </span><span class="s3">\&quot;</span><span class="s1">remainingLines</span><span class="s3">\&quot;\n\t    </span><span class="s1">var lastGeneratedLine = 1, lastGeneratedColumn = 0;</span><span class="s3">\n\t\n\t    </span><span class="s1">// The generate SourceNodes we need a code range.</span><span class="s3">\n\t    </span><span class="s1">// To extract it current and last mapping is used.</span><span class="s3">\n\t    </span><span class="s1">// Here we store the last mapping.</span><span class="s3">\n\t    </span><span class="s1">var lastMapping = null;</span><span class="s3">\n\t\n\t    </span><span class="s1">aSourceMapConsumer.eachMapping(function (mapping) {</span><span class="s3">\n\t      </span><span class="s1">if (lastMapping !== null) {</span><span class="s3">\n\t        </span><span class="s1">// We add the code from </span><span class="s3">\&quot;</span><span class="s1">lastMapping</span><span class="s3">\&quot; </span><span class="s1">to </span><span class="s3">\&quot;</span><span class="s1">mapping</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n\t        </span><span class="s1">// First check if there is a new line in between.</span><span class="s3">\n\t        </span><span class="s1">if (lastGeneratedLine &lt; mapping.generatedLine) {</span><span class="s3">\n\t          </span><span class="s1">// Associate first line with </span><span class="s3">\&quot;</span><span class="s1">lastMapping</span><span class="s3">\&quot;\n\t          </span><span class="s1">addMappingWithCode(lastMapping, shiftNextLine());</span><span class="s3">\n\t          </span><span class="s1">lastGeneratedLine++;</span><span class="s3">\n\t          </span><span class="s1">lastGeneratedColumn = 0;</span><span class="s3">\n\t          </span><span class="s1">// The remaining code is added without mapping</span><span class="s3">\n\t        </span><span class="s1">} else {</span><span class="s3">\n\t          </span><span class="s1">// There is no new line in between.</span><span class="s3">\n\t          </span><span class="s1">// Associate the code between </span><span class="s3">\&quot;</span><span class="s1">lastGeneratedColumn</span><span class="s3">\&quot; </span><span class="s1">and</span><span class="s3">\n\t          </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">mapping.generatedColumn</span><span class="s3">\&quot; </span><span class="s1">with </span><span class="s3">\&quot;</span><span class="s1">lastMapping</span><span class="s3">\&quot;\n\t          </span><span class="s1">var nextLine = remainingLines[remainingLinesIndex] || '';</span><span class="s3">\n\t          </span><span class="s1">var code = nextLine.substr(0, mapping.generatedColumn -</span><span class="s3">\n\t                                        </span><span class="s1">lastGeneratedColumn);</span><span class="s3">\n\t          </span><span class="s1">remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -</span><span class="s3">\n\t                                              </span><span class="s1">lastGeneratedColumn);</span><span class="s3">\n\t          </span><span class="s1">lastGeneratedColumn = mapping.generatedColumn;</span><span class="s3">\n\t          </span><span class="s1">addMappingWithCode(lastMapping, code);</span><span class="s3">\n\t          </span><span class="s1">// No more remaining code, continue</span><span class="s3">\n\t          </span><span class="s1">lastMapping = mapping;</span><span class="s3">\n\t          </span><span class="s1">return;</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">// We add the generated code until the first mapping</span><span class="s3">\n\t      </span><span class="s1">// to the SourceNode without any mapping.</span><span class="s3">\n\t      </span><span class="s1">// Each line is added as separate string.</span><span class="s3">\n\t      </span><span class="s1">while (lastGeneratedLine &lt; mapping.generatedLine) {</span><span class="s3">\n\t        </span><span class="s1">node.add(shiftNextLine());</span><span class="s3">\n\t        </span><span class="s1">lastGeneratedLine++;</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">if (lastGeneratedColumn &lt; mapping.generatedColumn) {</span><span class="s3">\n\t        </span><span class="s1">var nextLine = remainingLines[remainingLinesIndex] || '';</span><span class="s3">\n\t        </span><span class="s1">node.add(nextLine.substr(0, mapping.generatedColumn));</span><span class="s3">\n\t        </span><span class="s1">remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);</span><span class="s3">\n\t        </span><span class="s1">lastGeneratedColumn = mapping.generatedColumn;</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">lastMapping = mapping;</span><span class="s3">\n\t    </span><span class="s1">}, this);</span><span class="s3">\n\t    </span><span class="s1">// We have processed all mappings.</span><span class="s3">\n\t    </span><span class="s1">if (remainingLinesIndex &lt; remainingLines.length) {</span><span class="s3">\n\t      </span><span class="s1">if (lastMapping) {</span><span class="s3">\n\t        </span><span class="s1">// Associate the remaining code in the current line with </span><span class="s3">\&quot;</span><span class="s1">lastMapping</span><span class="s3">\&quot;\n\t        </span><span class="s1">addMappingWithCode(lastMapping, shiftNextLine());</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">// and add the remaining lines without any mapping</span><span class="s3">\n\t      </span><span class="s1">node.add(remainingLines.splice(remainingLinesIndex).join(</span><span class="s3">\&quot;\&quot;</span><span class="s1">));</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">// Copy sourcesContent into SourceNode</span><span class="s3">\n\t    </span><span class="s1">aSourceMapConsumer.sources.forEach(function (sourceFile) {</span><span class="s3">\n\t      </span><span class="s1">var content = aSourceMapConsumer.sourceContentFor(sourceFile);</span><span class="s3">\n\t      </span><span class="s1">if (content != null) {</span><span class="s3">\n\t        </span><span class="s1">if (aRelativePath != null) {</span><span class="s3">\n\t          </span><span class="s1">sourceFile = util.join(aRelativePath, sourceFile);</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t        </span><span class="s1">node.setSourceContent(sourceFile, content);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">});</span><span class="s3">\n\t\n\t    </span><span class="s1">return node;</span><span class="s3">\n\t\n\t    </span><span class="s1">function addMappingWithCode(mapping, code) {</span><span class="s3">\n\t      </span><span class="s1">if (mapping === null || mapping.source === undefined) {</span><span class="s3">\n\t        </span><span class="s1">node.add(code);</span><span class="s3">\n\t      </span><span class="s1">} else {</span><span class="s3">\n\t        </span><span class="s1">var source = aRelativePath</span><span class="s3">\n\t          </span><span class="s1">? util.join(aRelativePath, mapping.source)</span><span class="s3">\n\t          </span><span class="s1">: mapping.source;</span><span class="s3">\n\t        </span><span class="s1">node.add(new SourceNode(mapping.originalLine,</span><span class="s3">\n\t                                </span><span class="s1">mapping.originalColumn,</span><span class="s3">\n\t                                </span><span class="s1">source,</span><span class="s3">\n\t                                </span><span class="s1">code,</span><span class="s3">\n\t                                </span><span class="s1">mapping.name));</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Add a chunk of generated JS to this source node.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param aChunk A string snippet of generated JS code, another instance of</span><span class="s3">\n\t </span><span class="s1">*        SourceNode, or an array where each member is one of those things.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceNode.prototype.add = function SourceNode_add(aChunk) {</span><span class="s3">\n\t  </span><span class="s1">if (Array.isArray(aChunk)) {</span><span class="s3">\n\t    </span><span class="s1">aChunk.forEach(function (chunk) {</span><span class="s3">\n\t      </span><span class="s1">this.add(chunk);</span><span class="s3">\n\t    </span><span class="s1">}, this);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">else if (aChunk[isSourceNode] || typeof aChunk === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t    </span><span class="s1">if (aChunk) {</span><span class="s3">\n\t      </span><span class="s1">this.children.push(aChunk);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">else {</span><span class="s3">\n\t    </span><span class="s1">throw new TypeError(</span><span class="s3">\n\t      \&quot;</span><span class="s1">Expected a SourceNode, string, or an array of SourceNodes and strings. Got </span><span class="s3">\&quot; </span><span class="s1">+ aChunk</span><span class="s3">\n\t    </span><span class="s1">);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Add a chunk of generated JS to the beginning of this source node.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param aChunk A string snippet of generated JS code, another instance of</span><span class="s3">\n\t </span><span class="s1">*        SourceNode, or an array where each member is one of those things.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {</span><span class="s3">\n\t  </span><span class="s1">if (Array.isArray(aChunk)) {</span><span class="s3">\n\t    </span><span class="s1">for (var i = aChunk.length-1; i &gt;= 0; i--) {</span><span class="s3">\n\t      </span><span class="s1">this.prepend(aChunk[i]);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">else if (aChunk[isSourceNode] || typeof aChunk === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t    </span><span class="s1">this.children.unshift(aChunk);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">else {</span><span class="s3">\n\t    </span><span class="s1">throw new TypeError(</span><span class="s3">\n\t      \&quot;</span><span class="s1">Expected a SourceNode, string, or an array of SourceNodes and strings. Got </span><span class="s3">\&quot; </span><span class="s1">+ aChunk</span><span class="s3">\n\t    </span><span class="s1">);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Walk over the tree of JS snippets in this node and its children. The</span><span class="s3">\n\t </span><span class="s1">* walking function is called once for each snippet of JS and is passed that</span><span class="s3">\n\t </span><span class="s1">* snippet and the its original associated source's line/column location.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param aFn The traversal function.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceNode.prototype.walk = function SourceNode_walk(aFn) {</span><span class="s3">\n\t  </span><span class="s1">var chunk;</span><span class="s3">\n\t  </span><span class="s1">for (var i = 0, len = this.children.length; i &lt; len; i++) {</span><span class="s3">\n\t    </span><span class="s1">chunk = this.children[i];</span><span class="s3">\n\t    </span><span class="s1">if (chunk[isSourceNode]) {</span><span class="s3">\n\t      </span><span class="s1">chunk.walk(aFn);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">else {</span><span class="s3">\n\t      </span><span class="s1">if (chunk !== '') {</span><span class="s3">\n\t        </span><span class="s1">aFn(chunk, { source: this.source,</span><span class="s3">\n\t                     </span><span class="s1">line: this.line,</span><span class="s3">\n\t                     </span><span class="s1">column: this.column,</span><span class="s3">\n\t                     </span><span class="s1">name: this.name });</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between</span><span class="s3">\n\t </span><span class="s1">* each of `this.children`.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param aSep The separator.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceNode.prototype.join = function SourceNode_join(aSep) {</span><span class="s3">\n\t  </span><span class="s1">var newChildren;</span><span class="s3">\n\t  </span><span class="s1">var i;</span><span class="s3">\n\t  </span><span class="s1">var len = this.children.length;</span><span class="s3">\n\t  </span><span class="s1">if (len &gt; 0) {</span><span class="s3">\n\t    </span><span class="s1">newChildren = [];</span><span class="s3">\n\t    </span><span class="s1">for (i = 0; i &lt; len-1; i++) {</span><span class="s3">\n\t      </span><span class="s1">newChildren.push(this.children[i]);</span><span class="s3">\n\t      </span><span class="s1">newChildren.push(aSep);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">newChildren.push(this.children[i]);</span><span class="s3">\n\t    </span><span class="s1">this.children = newChildren;</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Call String.prototype.replace on the very right-most source snippet. Useful</span><span class="s3">\n\t </span><span class="s1">* for trimming whitespace from the end of a source node, etc.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param aPattern The pattern to replace.</span><span class="s3">\n\t </span><span class="s1">* @param aReplacement The thing to replace the pattern with.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {</span><span class="s3">\n\t  </span><span class="s1">var lastChild = this.children[this.children.length - 1];</span><span class="s3">\n\t  </span><span class="s1">if (lastChild[isSourceNode]) {</span><span class="s3">\n\t    </span><span class="s1">lastChild.replaceRight(aPattern, aReplacement);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">else if (typeof lastChild === 'string') {</span><span class="s3">\n\t    </span><span class="s1">this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">else {</span><span class="s3">\n\t    </span><span class="s1">this.children.push(''.replace(aPattern, aReplacement));</span><span class="s3">\n\t  </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">return this;</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Set the source content for a source file. This will be added to the SourceMapGenerator</span><span class="s3">\n\t </span><span class="s1">* in the sourcesContent field.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param aSourceFile The filename of the source file</span><span class="s3">\n\t </span><span class="s1">* @param aSourceContent The content of the source file</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceNode.prototype.setSourceContent =</span><span class="s3">\n\t  </span><span class="s1">function SourceNode_setSourceContent(aSourceFile, aSourceContent) {</span><span class="s3">\n\t    </span><span class="s1">this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Walk over the tree of SourceNodes. The walking function is called for each</span><span class="s3">\n\t </span><span class="s1">* source file content and is passed the filename and source content.</span><span class="s3">\n\t </span><span class="s1">*</span><span class="s3">\n\t </span><span class="s1">* @param aFn The traversal function.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceNode.prototype.walkSourceContents =</span><span class="s3">\n\t  </span><span class="s1">function SourceNode_walkSourceContents(aFn) {</span><span class="s3">\n\t    </span><span class="s1">for (var i = 0, len = this.children.length; i &lt; len; i++) {</span><span class="s3">\n\t      </span><span class="s1">if (this.children[i][isSourceNode]) {</span><span class="s3">\n\t        </span><span class="s1">this.children[i].walkSourceContents(aFn);</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t\n\t    </span><span class="s1">var sources = Object.keys(this.sourceContents);</span><span class="s3">\n\t    </span><span class="s1">for (var i = 0, len = sources.length; i &lt; len; i++) {</span><span class="s3">\n\t      </span><span class="s1">aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Return the string representation of this source node. Walks over the tree</span><span class="s3">\n\t </span><span class="s1">* and concatenates all the various snippets together to one string.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceNode.prototype.toString = function SourceNode_toString() {</span><span class="s3">\n\t  </span><span class="s1">var str = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n\t  </span><span class="s1">this.walk(function (chunk) {</span><span class="s3">\n\t    </span><span class="s1">str += chunk;</span><span class="s3">\n\t  </span><span class="s1">});</span><span class="s3">\n\t  </span><span class="s1">return str;</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">/**</span><span class="s3">\n\t </span><span class="s1">* Returns the string representation of this source node along with a source</span><span class="s3">\n\t </span><span class="s1">* map.</span><span class="s3">\n\t </span><span class="s1">*/</span><span class="s3">\n\t</span><span class="s1">SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {</span><span class="s3">\n\t  </span><span class="s1">var generated = {</span><span class="s3">\n\t    </span><span class="s1">code: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n\t    </span><span class="s1">line: 1,</span><span class="s3">\n\t    </span><span class="s1">column: 0</span><span class="s3">\n\t  </span><span class="s1">};</span><span class="s3">\n\t  </span><span class="s1">var map = new SourceMapGenerator(aArgs);</span><span class="s3">\n\t  </span><span class="s1">var sourceMappingActive = false;</span><span class="s3">\n\t  </span><span class="s1">var lastOriginalSource = null;</span><span class="s3">\n\t  </span><span class="s1">var lastOriginalLine = null;</span><span class="s3">\n\t  </span><span class="s1">var lastOriginalColumn = null;</span><span class="s3">\n\t  </span><span class="s1">var lastOriginalName = null;</span><span class="s3">\n\t  </span><span class="s1">this.walk(function (chunk, original) {</span><span class="s3">\n\t    </span><span class="s1">generated.code += chunk;</span><span class="s3">\n\t    </span><span class="s1">if (original.source !== null</span><span class="s3">\n\t        </span><span class="s1">&amp;&amp; original.line !== null</span><span class="s3">\n\t        </span><span class="s1">&amp;&amp; original.column !== null) {</span><span class="s3">\n\t      </span><span class="s1">if(lastOriginalSource !== original.source</span><span class="s3">\n\t         </span><span class="s1">|| lastOriginalLine !== original.line</span><span class="s3">\n\t         </span><span class="s1">|| lastOriginalColumn !== original.column</span><span class="s3">\n\t         </span><span class="s1">|| lastOriginalName !== original.name) {</span><span class="s3">\n\t        </span><span class="s1">map.addMapping({</span><span class="s3">\n\t          </span><span class="s1">source: original.source,</span><span class="s3">\n\t          </span><span class="s1">original: {</span><span class="s3">\n\t            </span><span class="s1">line: original.line,</span><span class="s3">\n\t            </span><span class="s1">column: original.column</span><span class="s3">\n\t          </span><span class="s1">},</span><span class="s3">\n\t          </span><span class="s1">generated: {</span><span class="s3">\n\t            </span><span class="s1">line: generated.line,</span><span class="s3">\n\t            </span><span class="s1">column: generated.column</span><span class="s3">\n\t          </span><span class="s1">},</span><span class="s3">\n\t          </span><span class="s1">name: original.name</span><span class="s3">\n\t        </span><span class="s1">});</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">lastOriginalSource = original.source;</span><span class="s3">\n\t      </span><span class="s1">lastOriginalLine = original.line;</span><span class="s3">\n\t      </span><span class="s1">lastOriginalColumn = original.column;</span><span class="s3">\n\t      </span><span class="s1">lastOriginalName = original.name;</span><span class="s3">\n\t      </span><span class="s1">sourceMappingActive = true;</span><span class="s3">\n\t    </span><span class="s1">} else if (sourceMappingActive) {</span><span class="s3">\n\t      </span><span class="s1">map.addMapping({</span><span class="s3">\n\t        </span><span class="s1">generated: {</span><span class="s3">\n\t          </span><span class="s1">line: generated.line,</span><span class="s3">\n\t          </span><span class="s1">column: generated.column</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">});</span><span class="s3">\n\t      </span><span class="s1">lastOriginalSource = null;</span><span class="s3">\n\t      </span><span class="s1">sourceMappingActive = false;</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">for (var idx = 0, length = chunk.length; idx &lt; length; idx++) {</span><span class="s3">\n\t      </span><span class="s1">if (chunk.charCodeAt(idx) === NEWLINE_CODE) {</span><span class="s3">\n\t        </span><span class="s1">generated.line++;</span><span class="s3">\n\t        </span><span class="s1">generated.column = 0;</span><span class="s3">\n\t        </span><span class="s1">// Mappings end at eol</span><span class="s3">\n\t        </span><span class="s1">if (idx + 1 === length) {</span><span class="s3">\n\t          </span><span class="s1">lastOriginalSource = null;</span><span class="s3">\n\t          </span><span class="s1">sourceMappingActive = false;</span><span class="s3">\n\t        </span><span class="s1">} else if (sourceMappingActive) {</span><span class="s3">\n\t          </span><span class="s1">map.addMapping({</span><span class="s3">\n\t            </span><span class="s1">source: original.source,</span><span class="s3">\n\t            </span><span class="s1">original: {</span><span class="s3">\n\t              </span><span class="s1">line: original.line,</span><span class="s3">\n\t              </span><span class="s1">column: original.column</span><span class="s3">\n\t            </span><span class="s1">},</span><span class="s3">\n\t            </span><span class="s1">generated: {</span><span class="s3">\n\t              </span><span class="s1">line: generated.line,</span><span class="s3">\n\t              </span><span class="s1">column: generated.column</span><span class="s3">\n\t            </span><span class="s1">},</span><span class="s3">\n\t            </span><span class="s1">name: original.name</span><span class="s3">\n\t          </span><span class="s1">});</span><span class="s3">\n\t        </span><span class="s1">}</span><span class="s3">\n\t      </span><span class="s1">} else {</span><span class="s3">\n\t        </span><span class="s1">generated.column++;</span><span class="s3">\n\t      </span><span class="s1">}</span><span class="s3">\n\t    </span><span class="s1">}</span><span class="s3">\n\t  </span><span class="s1">});</span><span class="s3">\n\t  </span><span class="s1">this.walkSourceContents(function (sourceFile, sourceContent) {</span><span class="s3">\n\t    </span><span class="s1">map.setSourceContent(sourceFile, sourceContent);</span><span class="s3">\n\t  </span><span class="s1">});</span><span class="s3">\n\t\n\t  </span><span class="s1">return { code: generated.code, map: map };</span><span class="s3">\n\t</span><span class="s1">};</span><span class="s3">\n\t\n\t</span><span class="s1">exports.SourceNode = SourceNode;</span><span class="s3">\n\n\n</span><span class="s1">/***/ })</span><span class="s3">\n</span><span class="s1">/******/ ])</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">// WEBPACK FOOTER //</span><span class="s3">\n</span><span class="s1">// source-map.min.js&quot;</span><span class="s0">,</span><span class="s1">&quot; </span><span class="s3">\t</span><span class="s1">// The module cache</span><span class="s3">\n \t</span><span class="s1">var installedModules = {};</span><span class="s3">\n\n \t</span><span class="s1">// The require function</span><span class="s3">\n \t</span><span class="s1">function __webpack_require__(moduleId) {</span><span class="s3">\n\n \t\t</span><span class="s1">// Check if module is in cache</span><span class="s3">\n \t\t</span><span class="s1">if(installedModules[moduleId])</span><span class="s3">\n \t\t\t</span><span class="s1">return installedModules[moduleId].exports;</span><span class="s3">\n\n \t\t</span><span class="s1">// Create a new module (and put it into the cache)</span><span class="s3">\n \t\t</span><span class="s1">var module = installedModules[moduleId] = {</span><span class="s3">\n \t\t\t</span><span class="s1">exports: {},</span><span class="s3">\n \t\t\t</span><span class="s1">id: moduleId,</span><span class="s3">\n \t\t\t</span><span class="s1">loaded: false</span><span class="s3">\n \t\t</span><span class="s1">};</span><span class="s3">\n\n \t\t</span><span class="s1">// Execute the module function</span><span class="s3">\n \t\t</span><span class="s1">modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><span class="s3">\n\n \t\t</span><span class="s1">// Flag the module as loaded</span><span class="s3">\n \t\t</span><span class="s1">module.loaded = true;</span><span class="s3">\n\n \t\t</span><span class="s1">// Return the exports of the module</span><span class="s3">\n \t\t</span><span class="s1">return module.exports;</span><span class="s3">\n \t</span><span class="s1">}</span><span class="s3">\n\n\n \t</span><span class="s1">// expose the modules object (__webpack_modules__)</span><span class="s3">\n \t</span><span class="s1">__webpack_require__.m = modules;</span><span class="s3">\n\n \t</span><span class="s1">// expose the module cache</span><span class="s3">\n \t</span><span class="s1">__webpack_require__.c = installedModules;</span><span class="s3">\n\n \t</span><span class="s1">// __webpack_public_path__</span><span class="s3">\n \t</span><span class="s1">__webpack_require__.p = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n\n \t</span><span class="s1">// Load entry module and return exports</span><span class="s3">\n \t</span><span class="s1">return __webpack_require__(0);</span><span class="s3">\n\n\n\n</span><span class="s1">// WEBPACK FOOTER //</span><span class="s3">\n</span><span class="s1">// webpack/bootstrap 0fd5815da764db5fb9fe&quot;</span><span class="s0">,</span><span class="s1">&quot;/*</span><span class="s3">\n </span><span class="s1">* Copyright 2009-2011 Mozilla Foundation and contributors</span><span class="s3">\n </span><span class="s1">* Licensed under the New BSD license. See LICENSE.txt or:</span><span class="s3">\n </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;</span><span class="s3">\n</span><span class="s1">exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;</span><span class="s3">\n</span><span class="s1">exports.SourceNode = require('./lib/source-node').SourceNode;</span><span class="s3">\n\n\n\n</span><span class="s1">//////////////////</span><span class="s3">\n</span><span class="s1">// WEBPACK FOOTER</span><span class="s3">\n</span><span class="s1">// ./source-map.js</span><span class="s3">\n</span><span class="s1">// module id = 0</span><span class="s3">\n</span><span class="s1">// module chunks = 0&quot;</span><span class="s0">,</span><span class="s1">&quot;/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var base64VLQ = require('./base64-vlq');</span><span class="s3">\n</span><span class="s1">var util = require('./util');</span><span class="s3">\n</span><span class="s1">var ArraySet = require('./array-set').ArraySet;</span><span class="s3">\n</span><span class="s1">var MappingList = require('./mapping-list').MappingList;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An instance of the SourceMapGenerator represents a source map which is</span><span class="s3">\n </span><span class="s1">* being built incrementally. You may pass an object with the following</span><span class="s3">\n </span><span class="s1">* properties:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   - file: The filename of the generated source.</span><span class="s3">\n </span><span class="s1">*   - sourceRoot: A root for all relative URLs in this source map.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function SourceMapGenerator(aArgs) {</span><span class="s3">\n  </span><span class="s1">if (!aArgs) {</span><span class="s3">\n    </span><span class="s1">aArgs = {};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this._file = util.getArg(aArgs, 'file', null);</span><span class="s3">\n  </span><span class="s1">this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);</span><span class="s3">\n  </span><span class="s1">this._skipValidation = util.getArg(aArgs, 'skipValidation', false);</span><span class="s3">\n  </span><span class="s1">this._sources = new ArraySet();</span><span class="s3">\n  </span><span class="s1">this._names = new ArraySet();</span><span class="s3">\n  </span><span class="s1">this._mappings = new MappingList();</span><span class="s3">\n  </span><span class="s1">this._sourcesContents = null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">SourceMapGenerator.prototype._version = 3;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a new SourceMapGenerator based on a SourceMapConsumer</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param aSourceMapConsumer The SourceMap.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceMapGenerator.fromSourceMap =</span><span class="s3">\n  </span><span class="s1">function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {</span><span class="s3">\n    </span><span class="s1">var sourceRoot = aSourceMapConsumer.sourceRoot;</span><span class="s3">\n    </span><span class="s1">var generator = new SourceMapGenerator({</span><span class="s3">\n      </span><span class="s1">file: aSourceMapConsumer.file,</span><span class="s3">\n      </span><span class="s1">sourceRoot: sourceRoot</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">aSourceMapConsumer.eachMapping(function (mapping) {</span><span class="s3">\n      </span><span class="s1">var newMapping = {</span><span class="s3">\n        </span><span class="s1">generated: {</span><span class="s3">\n          </span><span class="s1">line: mapping.generatedLine,</span><span class="s3">\n          </span><span class="s1">column: mapping.generatedColumn</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n\n      </span><span class="s1">if (mapping.source != null) {</span><span class="s3">\n        </span><span class="s1">newMapping.source = mapping.source;</span><span class="s3">\n        </span><span class="s1">if (sourceRoot != null) {</span><span class="s3">\n          </span><span class="s1">newMapping.source = util.relative(sourceRoot, newMapping.source);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">newMapping.original = {</span><span class="s3">\n          </span><span class="s1">line: mapping.originalLine,</span><span class="s3">\n          </span><span class="s1">column: mapping.originalColumn</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n\n        </span><span class="s1">if (mapping.name != null) {</span><span class="s3">\n          </span><span class="s1">newMapping.name = mapping.name;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">generator.addMapping(newMapping);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">aSourceMapConsumer.sources.forEach(function (sourceFile) {</span><span class="s3">\n      </span><span class="s1">var sourceRelative = sourceFile;</span><span class="s3">\n      </span><span class="s1">if (sourceRoot !== null) {</span><span class="s3">\n        </span><span class="s1">sourceRelative = util.relative(sourceRoot, sourceFile);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!generator._sources.has(sourceRelative)) {</span><span class="s3">\n        </span><span class="s1">generator._sources.add(sourceRelative);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">var content = aSourceMapConsumer.sourceContentFor(sourceFile);</span><span class="s3">\n      </span><span class="s1">if (content != null) {</span><span class="s3">\n        </span><span class="s1">generator.setSourceContent(sourceFile, content);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return generator;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Add a single mapping from original source line and column to the generated</span><span class="s3">\n </span><span class="s1">* source's line and column for this source map being created. The mapping</span><span class="s3">\n </span><span class="s1">* object should have the following properties:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   - generated: An object with the generated line and column positions.</span><span class="s3">\n </span><span class="s1">*   - original: An object with the original line and column positions.</span><span class="s3">\n </span><span class="s1">*   - source: The original source file (relative to the sourceRoot).</span><span class="s3">\n </span><span class="s1">*   - name: An optional original token name for this mapping.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceMapGenerator.prototype.addMapping =</span><span class="s3">\n  </span><span class="s1">function SourceMapGenerator_addMapping(aArgs) {</span><span class="s3">\n    </span><span class="s1">var generated = util.getArg(aArgs, 'generated');</span><span class="s3">\n    </span><span class="s1">var original = util.getArg(aArgs, 'original', null);</span><span class="s3">\n    </span><span class="s1">var source = util.getArg(aArgs, 'source', null);</span><span class="s3">\n    </span><span class="s1">var name = util.getArg(aArgs, 'name', null);</span><span class="s3">\n\n    </span><span class="s1">if (!this._skipValidation) {</span><span class="s3">\n      </span><span class="s1">this._validateMapping(generated, original, source, name);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (source != null) {</span><span class="s3">\n      </span><span class="s1">source = String(source);</span><span class="s3">\n      </span><span class="s1">if (!this._sources.has(source)) {</span><span class="s3">\n        </span><span class="s1">this._sources.add(source);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (name != null) {</span><span class="s3">\n      </span><span class="s1">name = String(name);</span><span class="s3">\n      </span><span class="s1">if (!this._names.has(name)) {</span><span class="s3">\n        </span><span class="s1">this._names.add(name);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._mappings.add({</span><span class="s3">\n      </span><span class="s1">generatedLine: generated.line,</span><span class="s3">\n      </span><span class="s1">generatedColumn: generated.column,</span><span class="s3">\n      </span><span class="s1">originalLine: original != null &amp;&amp; original.line,</span><span class="s3">\n      </span><span class="s1">originalColumn: original != null &amp;&amp; original.column,</span><span class="s3">\n      </span><span class="s1">source: source,</span><span class="s3">\n      </span><span class="s1">name: name</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Set the source content for a source file.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceMapGenerator.prototype.setSourceContent =</span><span class="s3">\n  </span><span class="s1">function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {</span><span class="s3">\n    </span><span class="s1">var source = aSourceFile;</span><span class="s3">\n    </span><span class="s1">if (this._sourceRoot != null) {</span><span class="s3">\n      </span><span class="s1">source = util.relative(this._sourceRoot, source);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (aSourceContent != null) {</span><span class="s3">\n      </span><span class="s1">// Add the source content to the _sourcesContents map.</span><span class="s3">\n      </span><span class="s1">// Create a new _sourcesContents map if the property is null.</span><span class="s3">\n      </span><span class="s1">if (!this._sourcesContents) {</span><span class="s3">\n        </span><span class="s1">this._sourcesContents = Object.create(null);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this._sourcesContents[util.toSetString(source)] = aSourceContent;</span><span class="s3">\n    </span><span class="s1">} else if (this._sourcesContents) {</span><span class="s3">\n      </span><span class="s1">// Remove the source file from the _sourcesContents map.</span><span class="s3">\n      </span><span class="s1">// If the _sourcesContents map is empty, set the property to null.</span><span class="s3">\n      </span><span class="s1">delete this._sourcesContents[util.toSetString(source)];</span><span class="s3">\n      </span><span class="s1">if (Object.keys(this._sourcesContents).length === 0) {</span><span class="s3">\n        </span><span class="s1">this._sourcesContents = null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Applies the mappings of a sub-source-map for a specific source file to the</span><span class="s3">\n </span><span class="s1">* source map being generated. Each mapping to the supplied source file is</span><span class="s3">\n </span><span class="s1">* rewritten using the supplied source map. Note: The resolution for the</span><span class="s3">\n </span><span class="s1">* resulting mappings is the minimium of this map and the supplied map.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param aSourceMapConsumer The source map to be applied.</span><span class="s3">\n </span><span class="s1">* @param aSourceFile Optional. The filename of the source file.</span><span class="s3">\n </span><span class="s1">*        If omitted, SourceMapConsumer's file property will be used.</span><span class="s3">\n </span><span class="s1">* @param aSourceMapPath Optional. The dirname of the path to the source map</span><span class="s3">\n </span><span class="s1">*        to be applied. If relative, it is relative to the SourceMapConsumer.</span><span class="s3">\n </span><span class="s1">*        This parameter is needed when the two source maps aren't in the same</span><span class="s3">\n </span><span class="s1">*        directory, and the source map to be applied contains relative source</span><span class="s3">\n </span><span class="s1">*        paths. If so, those relative source paths need to be rewritten</span><span class="s3">\n </span><span class="s1">*        relative to the SourceMapGenerator.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceMapGenerator.prototype.applySourceMap =</span><span class="s3">\n  </span><span class="s1">function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {</span><span class="s3">\n    </span><span class="s1">var sourceFile = aSourceFile;</span><span class="s3">\n    </span><span class="s1">// If aSourceFile is omitted, we will use the file property of the SourceMap</span><span class="s3">\n    </span><span class="s1">if (aSourceFile == null) {</span><span class="s3">\n      </span><span class="s1">if (aSourceMapConsumer.file == null) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +</span><span class="s3">\n          </span><span class="s1">'or the source map</span><span class="s3">\\</span><span class="s1">'s </span><span class="s3">\&quot;</span><span class="s1">file</span><span class="s3">\&quot; </span><span class="s1">property. Both were omitted.'</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">sourceFile = aSourceMapConsumer.file;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var sourceRoot = this._sourceRoot;</span><span class="s3">\n    </span><span class="s1">// Make </span><span class="s3">\&quot;</span><span class="s1">sourceFile</span><span class="s3">\&quot; </span><span class="s1">relative if an absolute Url is passed.</span><span class="s3">\n    </span><span class="s1">if (sourceRoot != null) {</span><span class="s3">\n      </span><span class="s1">sourceFile = util.relative(sourceRoot, sourceFile);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Applying the SourceMap can add and remove items from the sources and</span><span class="s3">\n    </span><span class="s1">// the names array.</span><span class="s3">\n    </span><span class="s1">var newSources = new ArraySet();</span><span class="s3">\n    </span><span class="s1">var newNames = new ArraySet();</span><span class="s3">\n\n    </span><span class="s1">// Find mappings for the </span><span class="s3">\&quot;</span><span class="s1">sourceFile</span><span class="s3">\&quot;\n    </span><span class="s1">this._mappings.unsortedForEach(function (mapping) {</span><span class="s3">\n      </span><span class="s1">if (mapping.source === sourceFile &amp;&amp; mapping.originalLine != null) {</span><span class="s3">\n        </span><span class="s1">// Check if it can be mapped by the source map, then update the mapping.</span><span class="s3">\n        </span><span class="s1">var original = aSourceMapConsumer.originalPositionFor({</span><span class="s3">\n          </span><span class="s1">line: mapping.originalLine,</span><span class="s3">\n          </span><span class="s1">column: mapping.originalColumn</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">if (original.source != null) {</span><span class="s3">\n          </span><span class="s1">// Copy mapping</span><span class="s3">\n          </span><span class="s1">mapping.source = original.source;</span><span class="s3">\n          </span><span class="s1">if (aSourceMapPath != null) {</span><span class="s3">\n            </span><span class="s1">mapping.source = util.join(aSourceMapPath, mapping.source)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (sourceRoot != null) {</span><span class="s3">\n            </span><span class="s1">mapping.source = util.relative(sourceRoot, mapping.source);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">mapping.originalLine = original.line;</span><span class="s3">\n          </span><span class="s1">mapping.originalColumn = original.column;</span><span class="s3">\n          </span><span class="s1">if (original.name != null) {</span><span class="s3">\n            </span><span class="s1">mapping.name = original.name;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">var source = mapping.source;</span><span class="s3">\n      </span><span class="s1">if (source != null &amp;&amp; !newSources.has(source)) {</span><span class="s3">\n        </span><span class="s1">newSources.add(source);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">var name = mapping.name;</span><span class="s3">\n      </span><span class="s1">if (name != null &amp;&amp; !newNames.has(name)) {</span><span class="s3">\n        </span><span class="s1">newNames.add(name);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">}, this);</span><span class="s3">\n    </span><span class="s1">this._sources = newSources;</span><span class="s3">\n    </span><span class="s1">this._names = newNames;</span><span class="s3">\n\n    </span><span class="s1">// Copy sourcesContents of applied map.</span><span class="s3">\n    </span><span class="s1">aSourceMapConsumer.sources.forEach(function (sourceFile) {</span><span class="s3">\n      </span><span class="s1">var content = aSourceMapConsumer.sourceContentFor(sourceFile);</span><span class="s3">\n      </span><span class="s1">if (content != null) {</span><span class="s3">\n        </span><span class="s1">if (aSourceMapPath != null) {</span><span class="s3">\n          </span><span class="s1">sourceFile = util.join(aSourceMapPath, sourceFile);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (sourceRoot != null) {</span><span class="s3">\n          </span><span class="s1">sourceFile = util.relative(sourceRoot, sourceFile);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.setSourceContent(sourceFile, content);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, this);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A mapping can have one of the three levels of data:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   1. Just the generated position.</span><span class="s3">\n </span><span class="s1">*   2. The Generated position, original position, and original source.</span><span class="s3">\n </span><span class="s1">*   3. Generated and original position, original source, as well as a name</span><span class="s3">\n </span><span class="s1">*      token.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* To maintain consistency, we validate that any new mapping being added falls</span><span class="s3">\n </span><span class="s1">* in to one of these categories.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceMapGenerator.prototype._validateMapping =</span><span class="s3">\n  </span><span class="s1">function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,</span><span class="s3">\n                                              </span><span class="s1">aName) {</span><span class="s3">\n    </span><span class="s1">// When aOriginal is truthy but has empty values for .line and .column,</span><span class="s3">\n    </span><span class="s1">// it is most likely a programmer error. In this case we throw a very</span><span class="s3">\n    </span><span class="s1">// specific error message to try to guide them the right way.</span><span class="s3">\n    </span><span class="s1">// For example: https://github.com/Polymer/polymer-bundler/pull/519</span><span class="s3">\n    </span><span class="s1">if (aOriginal &amp;&amp; typeof aOriginal.line !== 'number' &amp;&amp; typeof aOriginal.column !== 'number') {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n            </span><span class="s1">'original.line and original.column are not numbers -- you probably meant to omit ' +</span><span class="s3">\n            </span><span class="s1">'the original mapping entirely and only map the generated position. If so, pass ' +</span><span class="s3">\n            </span><span class="s1">'null for the original mapping instead of an object with empty or null values.'</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (aGenerated &amp;&amp; 'line' in aGenerated &amp;&amp; 'column' in aGenerated</span><span class="s3">\n        </span><span class="s1">&amp;&amp; aGenerated.line &gt; 0 &amp;&amp; aGenerated.column &gt;= 0</span><span class="s3">\n        </span><span class="s1">&amp;&amp; !aOriginal &amp;&amp; !aSource &amp;&amp; !aName) {</span><span class="s3">\n      </span><span class="s1">// Case 1.</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (aGenerated &amp;&amp; 'line' in aGenerated &amp;&amp; 'column' in aGenerated</span><span class="s3">\n             </span><span class="s1">&amp;&amp; aOriginal &amp;&amp; 'line' in aOriginal &amp;&amp; 'column' in aOriginal</span><span class="s3">\n             </span><span class="s1">&amp;&amp; aGenerated.line &gt; 0 &amp;&amp; aGenerated.column &gt;= 0</span><span class="s3">\n             </span><span class="s1">&amp;&amp; aOriginal.line &gt; 0 &amp;&amp; aOriginal.column &gt;= 0</span><span class="s3">\n             </span><span class="s1">&amp;&amp; aSource) {</span><span class="s3">\n      </span><span class="s1">// Cases 2 and 3.</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n      </span><span class="s1">throw new Error('Invalid mapping: ' + JSON.stringify({</span><span class="s3">\n        </span><span class="s1">generated: aGenerated,</span><span class="s3">\n        </span><span class="s1">source: aSource,</span><span class="s3">\n        </span><span class="s1">original: aOriginal,</span><span class="s3">\n        </span><span class="s1">name: aName</span><span class="s3">\n      </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Serialize the accumulated mappings in to the stream of base 64 VLQs</span><span class="s3">\n </span><span class="s1">* specified by the source map format.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceMapGenerator.prototype._serializeMappings =</span><span class="s3">\n  </span><span class="s1">function SourceMapGenerator_serializeMappings() {</span><span class="s3">\n    </span><span class="s1">var previousGeneratedColumn = 0;</span><span class="s3">\n    </span><span class="s1">var previousGeneratedLine = 1;</span><span class="s3">\n    </span><span class="s1">var previousOriginalColumn = 0;</span><span class="s3">\n    </span><span class="s1">var previousOriginalLine = 0;</span><span class="s3">\n    </span><span class="s1">var previousName = 0;</span><span class="s3">\n    </span><span class="s1">var previousSource = 0;</span><span class="s3">\n    </span><span class="s1">var result = '';</span><span class="s3">\n    </span><span class="s1">var next;</span><span class="s3">\n    </span><span class="s1">var mapping;</span><span class="s3">\n    </span><span class="s1">var nameIdx;</span><span class="s3">\n    </span><span class="s1">var sourceIdx;</span><span class="s3">\n\n    </span><span class="s1">var mappings = this._mappings.toArray();</span><span class="s3">\n    </span><span class="s1">for (var i = 0, len = mappings.length; i &lt; len; i++) {</span><span class="s3">\n      </span><span class="s1">mapping = mappings[i];</span><span class="s3">\n      </span><span class="s1">next = ''</span><span class="s3">\n\n      </span><span class="s1">if (mapping.generatedLine !== previousGeneratedLine) {</span><span class="s3">\n        </span><span class="s1">previousGeneratedColumn = 0;</span><span class="s3">\n        </span><span class="s1">while (mapping.generatedLine !== previousGeneratedLine) {</span><span class="s3">\n          </span><span class="s1">next += ';';</span><span class="s3">\n          </span><span class="s1">previousGeneratedLine++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">if (i &gt; 0) {</span><span class="s3">\n          </span><span class="s1">if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">next += ',';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">next += base64VLQ.encode(mapping.generatedColumn</span><span class="s3">\n                                 </span><span class="s1">- previousGeneratedColumn);</span><span class="s3">\n      </span><span class="s1">previousGeneratedColumn = mapping.generatedColumn;</span><span class="s3">\n\n      </span><span class="s1">if (mapping.source != null) {</span><span class="s3">\n        </span><span class="s1">sourceIdx = this._sources.indexOf(mapping.source);</span><span class="s3">\n        </span><span class="s1">next += base64VLQ.encode(sourceIdx - previousSource);</span><span class="s3">\n        </span><span class="s1">previousSource = sourceIdx;</span><span class="s3">\n\n        </span><span class="s1">// lines are stored 0-based in SourceMap spec version 3</span><span class="s3">\n        </span><span class="s1">next += base64VLQ.encode(mapping.originalLine - 1</span><span class="s3">\n                                   </span><span class="s1">- previousOriginalLine);</span><span class="s3">\n        </span><span class="s1">previousOriginalLine = mapping.originalLine - 1;</span><span class="s3">\n\n        </span><span class="s1">next += base64VLQ.encode(mapping.originalColumn</span><span class="s3">\n                                   </span><span class="s1">- previousOriginalColumn);</span><span class="s3">\n        </span><span class="s1">previousOriginalColumn = mapping.originalColumn;</span><span class="s3">\n\n        </span><span class="s1">if (mapping.name != null) {</span><span class="s3">\n          </span><span class="s1">nameIdx = this._names.indexOf(mapping.name);</span><span class="s3">\n          </span><span class="s1">next += base64VLQ.encode(nameIdx - previousName);</span><span class="s3">\n          </span><span class="s1">previousName = nameIdx;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">result += next;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return result;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">SourceMapGenerator.prototype._generateSourcesContent =</span><span class="s3">\n  </span><span class="s1">function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {</span><span class="s3">\n    </span><span class="s1">return aSources.map(function (source) {</span><span class="s3">\n      </span><span class="s1">if (!this._sourcesContents) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (aSourceRoot != null) {</span><span class="s3">\n        </span><span class="s1">source = util.relative(aSourceRoot, source);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var key = util.toSetString(source);</span><span class="s3">\n      </span><span class="s1">return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)</span><span class="s3">\n        </span><span class="s1">? this._sourcesContents[key]</span><span class="s3">\n        </span><span class="s1">: null;</span><span class="s3">\n    </span><span class="s1">}, this);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Externalize the source map.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceMapGenerator.prototype.toJSON =</span><span class="s3">\n  </span><span class="s1">function SourceMapGenerator_toJSON() {</span><span class="s3">\n    </span><span class="s1">var map = {</span><span class="s3">\n      </span><span class="s1">version: this._version,</span><span class="s3">\n      </span><span class="s1">sources: this._sources.toArray(),</span><span class="s3">\n      </span><span class="s1">names: this._names.toArray(),</span><span class="s3">\n      </span><span class="s1">mappings: this._serializeMappings()</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">if (this._file != null) {</span><span class="s3">\n      </span><span class="s1">map.file = this._file;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this._sourceRoot != null) {</span><span class="s3">\n      </span><span class="s1">map.sourceRoot = this._sourceRoot;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this._sourcesContents) {</span><span class="s3">\n      </span><span class="s1">map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return map;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Render the source map being generated to a string.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceMapGenerator.prototype.toString =</span><span class="s3">\n  </span><span class="s1">function SourceMapGenerator_toString() {</span><span class="s3">\n    </span><span class="s1">return JSON.stringify(this.toJSON());</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">exports.SourceMapGenerator = SourceMapGenerator;</span><span class="s3">\n\n\n\n</span><span class="s1">//////////////////</span><span class="s3">\n</span><span class="s1">// WEBPACK FOOTER</span><span class="s3">\n</span><span class="s1">// ./lib/source-map-generator.js</span><span class="s3">\n</span><span class="s1">// module id = 1</span><span class="s3">\n</span><span class="s1">// module chunks = 0&quot;</span><span class="s0">,</span><span class="s1">&quot;/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Based on the Base 64 VLQ implementation in Closure Compiler:</span><span class="s3">\n </span><span class="s1">* https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Copyright 2011 The Closure Compiler Authors. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Redistribution and use in source and binary forms, with or without</span><span class="s3">\n </span><span class="s1">* modification, are permitted provided that the following conditions are</span><span class="s3">\n </span><span class="s1">* met:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*  * Redistributions of source code must retain the above copyright</span><span class="s3">\n </span><span class="s1">*    notice, this list of conditions and the following disclaimer.</span><span class="s3">\n </span><span class="s1">*  * Redistributions in binary form must reproduce the above</span><span class="s3">\n </span><span class="s1">*    copyright notice, this list of conditions and the following</span><span class="s3">\n </span><span class="s1">*    disclaimer in the documentation and/or other materials provided</span><span class="s3">\n </span><span class="s1">*    with the distribution.</span><span class="s3">\n </span><span class="s1">*  * Neither the name of Google Inc. nor the names of its</span><span class="s3">\n </span><span class="s1">*    contributors may be used to endorse or promote products derived</span><span class="s3">\n </span><span class="s1">*    from this software without specific prior written permission.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span><span class="s3">\n </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">AS IS</span><span class="s3">\&quot; </span><span class="s1">AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span><span class="s3">\n </span><span class="s1">* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span><span class="s3">\n </span><span class="s1">* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span><span class="s3">\n </span><span class="s1">* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span><span class="s3">\n </span><span class="s1">* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span><span class="s3">\n </span><span class="s1">* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span><span class="s3">\n </span><span class="s1">* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span><span class="s3">\n </span><span class="s1">* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span><span class="s3">\n </span><span class="s1">* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span><span class="s3">\n </span><span class="s1">* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var base64 = require('./base64');</span><span class="s3">\n\n</span><span class="s1">// A single base 64 digit can contain 6 bits of data. For the base 64 variable</span><span class="s3">\n</span><span class="s1">// length quantities we use in the source map spec, the first bit is the sign,</span><span class="s3">\n</span><span class="s1">// the next four bits are the actual value, and the 6th bit is the</span><span class="s3">\n</span><span class="s1">// continuation bit. The continuation bit tells us whether there are more</span><span class="s3">\n</span><span class="s1">// digits in this value following this digit.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">//   Continuation</span><span class="s3">\n</span><span class="s1">//   |    Sign</span><span class="s3">\n</span><span class="s1">//   |    |</span><span class="s3">\n</span><span class="s1">//   V    V</span><span class="s3">\n</span><span class="s1">//   101011</span><span class="s3">\n\n</span><span class="s1">var VLQ_BASE_SHIFT = 5;</span><span class="s3">\n\n</span><span class="s1">// binary: 100000</span><span class="s3">\n</span><span class="s1">var VLQ_BASE = 1 &lt;&lt; VLQ_BASE_SHIFT;</span><span class="s3">\n\n</span><span class="s1">// binary: 011111</span><span class="s3">\n</span><span class="s1">var VLQ_BASE_MASK = VLQ_BASE - 1;</span><span class="s3">\n\n</span><span class="s1">// binary: 100000</span><span class="s3">\n</span><span class="s1">var VLQ_CONTINUATION_BIT = VLQ_BASE;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts from a two-complement value to a value where the sign bit is</span><span class="s3">\n </span><span class="s1">* placed in the least significant bit.  For example, as decimals:</span><span class="s3">\n </span><span class="s1">*   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)</span><span class="s3">\n </span><span class="s1">*   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toVLQSigned(aValue) {</span><span class="s3">\n  </span><span class="s1">return aValue &lt; 0</span><span class="s3">\n    </span><span class="s1">? ((-aValue) &lt;&lt; 1) + 1</span><span class="s3">\n    </span><span class="s1">: (aValue &lt;&lt; 1) + 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts to a two-complement value from a value where the sign bit is</span><span class="s3">\n </span><span class="s1">* placed in the least significant bit.  For example, as decimals:</span><span class="s3">\n </span><span class="s1">*   2 (10 binary) becomes 1, 3 (11 binary) becomes -1</span><span class="s3">\n </span><span class="s1">*   4 (100 binary) becomes 2, 5 (101 binary) becomes -2</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function fromVLQSigned(aValue) {</span><span class="s3">\n  </span><span class="s1">var isNegative = (aValue &amp; 1) === 1;</span><span class="s3">\n  </span><span class="s1">var shifted = aValue &gt;&gt; 1;</span><span class="s3">\n  </span><span class="s1">return isNegative</span><span class="s3">\n    </span><span class="s1">? -shifted</span><span class="s3">\n    </span><span class="s1">: shifted;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the base 64 VLQ encoded value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">exports.encode = function base64VLQ_encode(aValue) {</span><span class="s3">\n  </span><span class="s1">var encoded = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">var digit;</span><span class="s3">\n\n  </span><span class="s1">var vlq = toVLQSigned(aValue);</span><span class="s3">\n\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">digit = vlq &amp; VLQ_BASE_MASK;</span><span class="s3">\n    </span><span class="s1">vlq &gt;&gt;&gt;= VLQ_BASE_SHIFT;</span><span class="s3">\n    </span><span class="s1">if (vlq &gt; 0) {</span><span class="s3">\n      </span><span class="s1">// There are still more digits in this value, so we must make sure the</span><span class="s3">\n      </span><span class="s1">// continuation bit is marked.</span><span class="s3">\n      </span><span class="s1">digit |= VLQ_CONTINUATION_BIT;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">encoded += base64.encode(digit);</span><span class="s3">\n  </span><span class="s1">} while (vlq &gt; 0);</span><span class="s3">\n\n  </span><span class="s1">return encoded;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Decodes the next base 64 VLQ value from the given string and returns the</span><span class="s3">\n </span><span class="s1">* value and the rest of the string via the out parameter.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {</span><span class="s3">\n  </span><span class="s1">var strLen = aStr.length;</span><span class="s3">\n  </span><span class="s1">var result = 0;</span><span class="s3">\n  </span><span class="s1">var shift = 0;</span><span class="s3">\n  </span><span class="s1">var continuation, digit;</span><span class="s3">\n\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">if (aIndex &gt;= strLen) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Expected more digits in base 64 VLQ value.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">digit = base64.decode(aStr.charCodeAt(aIndex++));</span><span class="s3">\n    </span><span class="s1">if (digit === -1) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Invalid base64 digit: </span><span class="s3">\&quot; </span><span class="s1">+ aStr.charAt(aIndex - 1));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">continuation = !!(digit &amp; VLQ_CONTINUATION_BIT);</span><span class="s3">\n    </span><span class="s1">digit &amp;= VLQ_BASE_MASK;</span><span class="s3">\n    </span><span class="s1">result = result + (digit &lt;&lt; shift);</span><span class="s3">\n    </span><span class="s1">shift += VLQ_BASE_SHIFT;</span><span class="s3">\n  </span><span class="s1">} while (continuation);</span><span class="s3">\n\n  </span><span class="s1">aOutParam.value = fromVLQSigned(result);</span><span class="s3">\n  </span><span class="s1">aOutParam.rest = aIndex;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n\n\n</span><span class="s1">//////////////////</span><span class="s3">\n</span><span class="s1">// WEBPACK FOOTER</span><span class="s3">\n</span><span class="s1">// ./lib/base64-vlq.js</span><span class="s3">\n</span><span class="s1">// module id = 2</span><span class="s3">\n</span><span class="s1">// module chunks = 0&quot;</span><span class="s0">,</span><span class="s1">&quot;/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Encode an integer in the range of 0 to 63 to a single base 64 digit.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">exports.encode = function (number) {</span><span class="s3">\n  </span><span class="s1">if (0 &lt;= number &amp;&amp; number &lt; intToCharMap.length) {</span><span class="s3">\n    </span><span class="s1">return intToCharMap[number];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Must be between 0 and 63: </span><span class="s3">\&quot; </span><span class="s1">+ number);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Decode a single base 64 character code digit to an integer. Returns -1 on</span><span class="s3">\n </span><span class="s1">* failure.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">exports.decode = function (charCode) {</span><span class="s3">\n  </span><span class="s1">var bigA = 65;     // 'A'</span><span class="s3">\n  </span><span class="s1">var bigZ = 90;     // 'Z'</span><span class="s3">\n\n  </span><span class="s1">var littleA = 97;  // 'a'</span><span class="s3">\n  </span><span class="s1">var littleZ = 122; // 'z'</span><span class="s3">\n\n  </span><span class="s1">var zero = 48;     // '0'</span><span class="s3">\n  </span><span class="s1">var nine = 57;     // '9'</span><span class="s3">\n\n  </span><span class="s1">var plus = 43;     // '+'</span><span class="s3">\n  </span><span class="s1">var slash = 47;    // '/'</span><span class="s3">\n\n  </span><span class="s1">var littleOffset = 26;</span><span class="s3">\n  </span><span class="s1">var numberOffset = 52;</span><span class="s3">\n\n  </span><span class="s1">// 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><span class="s3">\n  </span><span class="s1">if (bigA &lt;= charCode &amp;&amp; charCode &lt;= bigZ) {</span><span class="s3">\n    </span><span class="s1">return (charCode - bigA);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// 26 - 51: abcdefghijklmnopqrstuvwxyz</span><span class="s3">\n  </span><span class="s1">if (littleA &lt;= charCode &amp;&amp; charCode &lt;= littleZ) {</span><span class="s3">\n    </span><span class="s1">return (charCode - littleA + littleOffset);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// 52 - 61: 0123456789</span><span class="s3">\n  </span><span class="s1">if (zero &lt;= charCode &amp;&amp; charCode &lt;= nine) {</span><span class="s3">\n    </span><span class="s1">return (charCode - zero + numberOffset);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// 62: +</span><span class="s3">\n  </span><span class="s1">if (charCode == plus) {</span><span class="s3">\n    </span><span class="s1">return 62;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// 63: /</span><span class="s3">\n  </span><span class="s1">if (charCode == slash) {</span><span class="s3">\n    </span><span class="s1">return 63;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Invalid base64 digit.</span><span class="s3">\n  </span><span class="s1">return -1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n\n\n</span><span class="s1">//////////////////</span><span class="s3">\n</span><span class="s1">// WEBPACK FOOTER</span><span class="s3">\n</span><span class="s1">// ./lib/base64.js</span><span class="s3">\n</span><span class="s1">// module id = 3</span><span class="s3">\n</span><span class="s1">// module chunks = 0&quot;</span><span class="s0">,</span><span class="s1">&quot;/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This is a helper function for getting values from parameter/options</span><span class="s3">\n </span><span class="s1">* objects.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param args The object we are extracting values from</span><span class="s3">\n </span><span class="s1">* @param name The name of the property we are getting.</span><span class="s3">\n </span><span class="s1">* @param defaultValue An optional value to return if the property is missing</span><span class="s3">\n </span><span class="s1">* from the object. If this is not specified and the property is missing, an</span><span class="s3">\n </span><span class="s1">* error will be thrown.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getArg(aArgs, aName, aDefaultValue) {</span><span class="s3">\n  </span><span class="s1">if (aName in aArgs) {</span><span class="s3">\n    </span><span class="s1">return aArgs[aName];</span><span class="s3">\n  </span><span class="s1">} else if (arguments.length === 3) {</span><span class="s3">\n    </span><span class="s1">return aDefaultValue;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw new Error('</span><span class="s3">\&quot;</span><span class="s1">' + aName + '</span><span class="s3">\&quot; </span><span class="s1">is a required argument.');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.getArg = getArg;</span><span class="s3">\n\n</span><span class="s1">var urlRegexp = /^(?:([</span><span class="s3">\\</span><span class="s1">w+</span><span class="s3">\\</span><span class="s1">-.]+):)?</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/(?:(</span><span class="s3">\\</span><span class="s1">w+:</span><span class="s3">\\</span><span class="s1">w+)@)?([</span><span class="s3">\\</span><span class="s1">w.-]*)(?::(</span><span class="s3">\\</span><span class="s1">d+))?(.*)$/;</span><span class="s3">\n</span><span class="s1">var dataUrlRegexp = /^data:.+</span><span class="s3">\\</span><span class="s1">,.+$/;</span><span class="s3">\n\n</span><span class="s1">function urlParse(aUrl) {</span><span class="s3">\n  </span><span class="s1">var match = aUrl.match(urlRegexp);</span><span class="s3">\n  </span><span class="s1">if (!match) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">scheme: match[1],</span><span class="s3">\n    </span><span class="s1">auth: match[2],</span><span class="s3">\n    </span><span class="s1">host: match[3],</span><span class="s3">\n    </span><span class="s1">port: match[4],</span><span class="s3">\n    </span><span class="s1">path: match[5]</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.urlParse = urlParse;</span><span class="s3">\n\n</span><span class="s1">function urlGenerate(aParsedUrl) {</span><span class="s3">\n  </span><span class="s1">var url = '';</span><span class="s3">\n  </span><span class="s1">if (aParsedUrl.scheme) {</span><span class="s3">\n    </span><span class="s1">url += aParsedUrl.scheme + ':';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">url += '//';</span><span class="s3">\n  </span><span class="s1">if (aParsedUrl.auth) {</span><span class="s3">\n    </span><span class="s1">url += aParsedUrl.auth + '@';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (aParsedUrl.host) {</span><span class="s3">\n    </span><span class="s1">url += aParsedUrl.host;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (aParsedUrl.port) {</span><span class="s3">\n    </span><span class="s1">url += </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ aParsedUrl.port</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (aParsedUrl.path) {</span><span class="s3">\n    </span><span class="s1">url += aParsedUrl.path;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return url;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.urlGenerate = urlGenerate;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes a path, or the path portion of a URL:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* - Replaces consecutive slashes with one slash.</span><span class="s3">\n </span><span class="s1">* - Removes unnecessary '.' parts.</span><span class="s3">\n </span><span class="s1">* - Removes unnecessary '&lt;dir&gt;/..' parts.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Based on code in the Node.js 'path' core module.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param aPath The path or url to normalize.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function normalize(aPath) {</span><span class="s3">\n  </span><span class="s1">var path = aPath;</span><span class="s3">\n  </span><span class="s1">var url = urlParse(aPath);</span><span class="s3">\n  </span><span class="s1">if (url) {</span><span class="s3">\n    </span><span class="s1">if (!url.path) {</span><span class="s3">\n      </span><span class="s1">return aPath;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">path = url.path;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var isAbsolute = exports.isAbsolute(path);</span><span class="s3">\n\n  </span><span class="s1">var parts = path.split(/</span><span class="s3">\\</span><span class="s1">/+/);</span><span class="s3">\n  </span><span class="s1">for (var part, up = 0, i = parts.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n    </span><span class="s1">part = parts[i];</span><span class="s3">\n    </span><span class="s1">if (part === '.') {</span><span class="s3">\n      </span><span class="s1">parts.splice(i, 1);</span><span class="s3">\n    </span><span class="s1">} else if (part === '..') {</span><span class="s3">\n      </span><span class="s1">up++;</span><span class="s3">\n    </span><span class="s1">} else if (up &gt; 0) {</span><span class="s3">\n      </span><span class="s1">if (part === '') {</span><span class="s3">\n        </span><span class="s1">// The first part is blank if the path is absolute. Trying to go</span><span class="s3">\n        </span><span class="s1">// above the root is a no-op. Therefore we can remove all '..' parts</span><span class="s3">\n        </span><span class="s1">// directly after the root.</span><span class="s3">\n        </span><span class="s1">parts.splice(i + 1, up);</span><span class="s3">\n        </span><span class="s1">up = 0;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">parts.splice(i, 2);</span><span class="s3">\n        </span><span class="s1">up--;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">path = parts.join('/');</span><span class="s3">\n\n  </span><span class="s1">if (path === '') {</span><span class="s3">\n    </span><span class="s1">path = isAbsolute ? '/' : '.';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (url) {</span><span class="s3">\n    </span><span class="s1">url.path = path;</span><span class="s3">\n    </span><span class="s1">return urlGenerate(url);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return path;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.normalize = normalize;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Joins two paths/URLs.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param aRoot The root path or URL.</span><span class="s3">\n </span><span class="s1">* @param aPath The path or URL to be joined with the root.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* - If aPath is a URL or a data URI, aPath is returned, unless aPath is a</span><span class="s3">\n </span><span class="s1">*   scheme-relative URL: Then the scheme of aRoot, if any, is prepended</span><span class="s3">\n </span><span class="s1">*   first.</span><span class="s3">\n </span><span class="s1">* - Otherwise aPath is a path. If aRoot is a URL, then its path portion</span><span class="s3">\n </span><span class="s1">*   is updated with the result and aRoot is returned. Otherwise the result</span><span class="s3">\n </span><span class="s1">*   is returned.</span><span class="s3">\n </span><span class="s1">*   - If aPath is absolute, the result is aPath.</span><span class="s3">\n </span><span class="s1">*   - Otherwise the two paths are joined with a slash.</span><span class="s3">\n </span><span class="s1">* - Joining for example 'http://' and 'www.example.com' is also supported.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function join(aRoot, aPath) {</span><span class="s3">\n  </span><span class="s1">if (aRoot === </span><span class="s3">\&quot;\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">aRoot = </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (aPath === </span><span class="s3">\&quot;\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">aPath = </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var aPathUrl = urlParse(aPath);</span><span class="s3">\n  </span><span class="s1">var aRootUrl = urlParse(aRoot);</span><span class="s3">\n  </span><span class="s1">if (aRootUrl) {</span><span class="s3">\n    </span><span class="s1">aRoot = aRootUrl.path || '/';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// `join(foo, '//www.example.org')`</span><span class="s3">\n  </span><span class="s1">if (aPathUrl &amp;&amp; !aPathUrl.scheme) {</span><span class="s3">\n    </span><span class="s1">if (aRootUrl) {</span><span class="s3">\n      </span><span class="s1">aPathUrl.scheme = aRootUrl.scheme;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return urlGenerate(aPathUrl);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (aPathUrl || aPath.match(dataUrlRegexp)) {</span><span class="s3">\n    </span><span class="s1">return aPath;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// `join('http://', 'www.example.com')`</span><span class="s3">\n  </span><span class="s1">if (aRootUrl &amp;&amp; !aRootUrl.host &amp;&amp; !aRootUrl.path) {</span><span class="s3">\n    </span><span class="s1">aRootUrl.host = aPath;</span><span class="s3">\n    </span><span class="s1">return urlGenerate(aRootUrl);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var joined = aPath.charAt(0) === '/'</span><span class="s3">\n    </span><span class="s1">? aPath</span><span class="s3">\n    </span><span class="s1">: normalize(aRoot.replace(/</span><span class="s3">\\</span><span class="s1">/+$/, '') + '/' + aPath);</span><span class="s3">\n\n  </span><span class="s1">if (aRootUrl) {</span><span class="s3">\n    </span><span class="s1">aRootUrl.path = joined;</span><span class="s3">\n    </span><span class="s1">return urlGenerate(aRootUrl);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return joined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.join = join;</span><span class="s3">\n\n</span><span class="s1">exports.isAbsolute = function (aPath) {</span><span class="s3">\n  </span><span class="s1">return aPath.charAt(0) === '/' || urlRegexp.test(aPath);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Make a path relative to a URL or another path.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param aRoot The root path or URL.</span><span class="s3">\n </span><span class="s1">* @param aPath The path or URL to be made relative to aRoot.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function relative(aRoot, aPath) {</span><span class="s3">\n  </span><span class="s1">if (aRoot === </span><span class="s3">\&quot;\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">aRoot = </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">aRoot = aRoot.replace(/</span><span class="s3">\\</span><span class="s1">/$/, '');</span><span class="s3">\n\n  </span><span class="s1">// It is possible for the path to be above the root. In this case, simply</span><span class="s3">\n  </span><span class="s1">// checking whether the root is a prefix of the path won't work. Instead, we</span><span class="s3">\n  </span><span class="s1">// need to remove components from the root one by one, until either we find</span><span class="s3">\n  </span><span class="s1">// a prefix that fits, or we run out of components to remove.</span><span class="s3">\n  </span><span class="s1">var level = 0;</span><span class="s3">\n  </span><span class="s1">while (aPath.indexOf(aRoot + '/') !== 0) {</span><span class="s3">\n    </span><span class="s1">var index = aRoot.lastIndexOf(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (index &lt; 0) {</span><span class="s3">\n      </span><span class="s1">return aPath;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the only part of the root that is left is the scheme (i.e. http://,</span><span class="s3">\n    </span><span class="s1">// file:///, etc.), one or more slashes (/), or simply nothing at all, we</span><span class="s3">\n    </span><span class="s1">// have exhausted all components, so the path is not relative to the root.</span><span class="s3">\n    </span><span class="s1">aRoot = aRoot.slice(0, index);</span><span class="s3">\n    </span><span class="s1">if (aRoot.match(/^([^</span><span class="s3">\\</span><span class="s1">/]+:</span><span class="s3">\\</span><span class="s1">/)?</span><span class="s3">\\</span><span class="s1">/*$/)) {</span><span class="s3">\n      </span><span class="s1">return aPath;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">++level;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Make sure we add a </span><span class="s3">\&quot;</span><span class="s1">../</span><span class="s3">\&quot; </span><span class="s1">for each component we removed from the root.</span><span class="s3">\n  </span><span class="s1">return Array(level + 1).join(</span><span class="s3">\&quot;</span><span class="s1">../</span><span class="s3">\&quot;</span><span class="s1">) + aPath.substr(aRoot.length + 1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.relative = relative;</span><span class="s3">\n\n</span><span class="s1">var supportsNullProto = (function () {</span><span class="s3">\n  </span><span class="s1">var obj = Object.create(null);</span><span class="s3">\n  </span><span class="s1">return !('__proto__' in obj);</span><span class="s3">\n</span><span class="s1">}());</span><span class="s3">\n\n</span><span class="s1">function identity (s) {</span><span class="s3">\n  </span><span class="s1">return s;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Because behavior goes wacky when you set `__proto__` on objects, we</span><span class="s3">\n </span><span class="s1">* have to prefix all the strings in our set with an arbitrary character.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* See https://github.com/mozilla/source-map/pull/31 and</span><span class="s3">\n </span><span class="s1">* https://github.com/mozilla/source-map/issues/30</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param String aStr</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toSetString(aStr) {</span><span class="s3">\n  </span><span class="s1">if (isProtoString(aStr)) {</span><span class="s3">\n    </span><span class="s1">return '$' + aStr;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return aStr;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.toSetString = supportsNullProto ? identity : toSetString;</span><span class="s3">\n\n</span><span class="s1">function fromSetString(aStr) {</span><span class="s3">\n  </span><span class="s1">if (isProtoString(aStr)) {</span><span class="s3">\n    </span><span class="s1">return aStr.slice(1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return aStr;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.fromSetString = supportsNullProto ? identity : fromSetString;</span><span class="s3">\n\n</span><span class="s1">function isProtoString(s) {</span><span class="s3">\n  </span><span class="s1">if (!s) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var length = s.length;</span><span class="s3">\n\n  </span><span class="s1">if (length &lt; 9 /* </span><span class="s3">\&quot;</span><span class="s1">__proto__</span><span class="s3">\&quot;</span><span class="s1">.length */) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||</span><span class="s3">\n      </span><span class="s1">s.charCodeAt(length - 2) !== 95  /* '_' */ ||</span><span class="s3">\n      </span><span class="s1">s.charCodeAt(length - 3) !== 111 /* 'o' */ ||</span><span class="s3">\n      </span><span class="s1">s.charCodeAt(length - 4) !== 116 /* 't' */ ||</span><span class="s3">\n      </span><span class="s1">s.charCodeAt(length - 5) !== 111 /* 'o' */ ||</span><span class="s3">\n      </span><span class="s1">s.charCodeAt(length - 6) !== 114 /* 'r' */ ||</span><span class="s3">\n      </span><span class="s1">s.charCodeAt(length - 7) !== 112 /* 'p' */ ||</span><span class="s3">\n      </span><span class="s1">s.charCodeAt(length - 8) !== 95  /* '_' */ ||</span><span class="s3">\n      </span><span class="s1">s.charCodeAt(length - 9) !== 95  /* '_' */) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (var i = length - 10; i &gt;= 0; i--) {</span><span class="s3">\n    </span><span class="s1">if (s.charCodeAt(i) !== 36 /* '$' */) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Comparator between two mappings where the original positions are compared.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Optionally pass in `true` as `onlyCompareGenerated` to consider two</span><span class="s3">\n </span><span class="s1">* mappings with the same original source/line/column, but different generated</span><span class="s3">\n </span><span class="s1">* line and column the same. Useful when searching for a mapping with a</span><span class="s3">\n </span><span class="s1">* stubbed out mapping.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {</span><span class="s3">\n  </span><span class="s1">var cmp = strcmp(mappingA.source, mappingB.source);</span><span class="s3">\n  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n    </span><span class="s1">return cmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">cmp = mappingA.originalLine - mappingB.originalLine;</span><span class="s3">\n  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n    </span><span class="s1">return cmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">cmp = mappingA.originalColumn - mappingB.originalColumn;</span><span class="s3">\n  </span><span class="s1">if (cmp !== 0 || onlyCompareOriginal) {</span><span class="s3">\n    </span><span class="s1">return cmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">cmp = mappingA.generatedColumn - mappingB.generatedColumn;</span><span class="s3">\n  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n    </span><span class="s1">return cmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">cmp = mappingA.generatedLine - mappingB.generatedLine;</span><span class="s3">\n  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n    </span><span class="s1">return cmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return strcmp(mappingA.name, mappingB.name);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.compareByOriginalPositions = compareByOriginalPositions;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Comparator between two mappings with deflated source and name indices where</span><span class="s3">\n </span><span class="s1">* the generated positions are compared.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Optionally pass in `true` as `onlyCompareGenerated` to consider two</span><span class="s3">\n </span><span class="s1">* mappings with the same generated line and column, but different</span><span class="s3">\n </span><span class="s1">* source/name/original line and column the same. Useful when searching for a</span><span class="s3">\n </span><span class="s1">* mapping with a stubbed out mapping.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {</span><span class="s3">\n  </span><span class="s1">var cmp = mappingA.generatedLine - mappingB.generatedLine;</span><span class="s3">\n  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n    </span><span class="s1">return cmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">cmp = mappingA.generatedColumn - mappingB.generatedColumn;</span><span class="s3">\n  </span><span class="s1">if (cmp !== 0 || onlyCompareGenerated) {</span><span class="s3">\n    </span><span class="s1">return cmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">cmp = strcmp(mappingA.source, mappingB.source);</span><span class="s3">\n  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n    </span><span class="s1">return cmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">cmp = mappingA.originalLine - mappingB.originalLine;</span><span class="s3">\n  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n    </span><span class="s1">return cmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">cmp = mappingA.originalColumn - mappingB.originalColumn;</span><span class="s3">\n  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n    </span><span class="s1">return cmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return strcmp(mappingA.name, mappingB.name);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;</span><span class="s3">\n\n</span><span class="s1">function strcmp(aStr1, aStr2) {</span><span class="s3">\n  </span><span class="s1">if (aStr1 === aStr2) {</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (aStr1 === null) {</span><span class="s3">\n    </span><span class="s1">return 1; // aStr2 !== null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (aStr2 === null) {</span><span class="s3">\n    </span><span class="s1">return -1; // aStr1 !== null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (aStr1 &gt; aStr2) {</span><span class="s3">\n    </span><span class="s1">return 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return -1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Comparator between two mappings with inflated source and name strings where</span><span class="s3">\n </span><span class="s1">* the generated positions are compared.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function compareByGeneratedPositionsInflated(mappingA, mappingB) {</span><span class="s3">\n  </span><span class="s1">var cmp = mappingA.generatedLine - mappingB.generatedLine;</span><span class="s3">\n  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n    </span><span class="s1">return cmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">cmp = mappingA.generatedColumn - mappingB.generatedColumn;</span><span class="s3">\n  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n    </span><span class="s1">return cmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">cmp = strcmp(mappingA.source, mappingB.source);</span><span class="s3">\n  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n    </span><span class="s1">return cmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">cmp = mappingA.originalLine - mappingB.originalLine;</span><span class="s3">\n  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n    </span><span class="s1">return cmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">cmp = mappingA.originalColumn - mappingB.originalColumn;</span><span class="s3">\n  </span><span class="s1">if (cmp !== 0) {</span><span class="s3">\n    </span><span class="s1">return cmp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return strcmp(mappingA.name, mappingB.name);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Strip any JSON XSSI avoidance prefix from the string (as documented</span><span class="s3">\n </span><span class="s1">* in the source maps specification), and then parse the string as</span><span class="s3">\n </span><span class="s1">* JSON.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function parseSourceMapInput(str) {</span><span class="s3">\n  </span><span class="s1">return JSON.parse(str.replace(/^</span><span class="s3">\\</span><span class="s1">)]}'[^</span><span class="s3">\\</span><span class="s1">n]*</span><span class="s3">\\</span><span class="s1">n/, ''));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.parseSourceMapInput = parseSourceMapInput;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Compute the URL of a source given the the source root, the source's</span><span class="s3">\n </span><span class="s1">* URL, and the source map's URL.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {</span><span class="s3">\n  </span><span class="s1">sourceURL = sourceURL || '';</span><span class="s3">\n\n  </span><span class="s1">if (sourceRoot) {</span><span class="s3">\n    </span><span class="s1">// This follows what Chrome does.</span><span class="s3">\n    </span><span class="s1">if (sourceRoot[sourceRoot.length - 1] !== '/' &amp;&amp; sourceURL[0] !== '/') {</span><span class="s3">\n      </span><span class="s1">sourceRoot += '/';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// The spec says:</span><span class="s3">\n    </span><span class="s1">//   Line 4: An optional source root, useful for relocating source</span><span class="s3">\n    </span><span class="s1">//   files on a server or removing repeated values in the</span><span class="s3">\n    </span><span class="s1">//   “sources” entry.  This value is prepended to the individual</span><span class="s3">\n    </span><span class="s1">//   entries in the “source” field.</span><span class="s3">\n    </span><span class="s1">sourceURL = sourceRoot + sourceURL;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Historically, SourceMapConsumer did not take the sourceMapURL as</span><span class="s3">\n  </span><span class="s1">// a parameter.  This mode is still somewhat supported, which is why</span><span class="s3">\n  </span><span class="s1">// this code block is conditional.  However, it's preferable to pass</span><span class="s3">\n  </span><span class="s1">// the source map URL to SourceMapConsumer, so that this function</span><span class="s3">\n  </span><span class="s1">// can implement the source URL resolution algorithm as outlined in</span><span class="s3">\n  </span><span class="s1">// the spec.  This block is basically the equivalent of:</span><span class="s3">\n  </span><span class="s1">//    new URL(sourceURL, sourceMapURL).toString()</span><span class="s3">\n  </span><span class="s1">// ... except it avoids using URL, which wasn't available in the</span><span class="s3">\n  </span><span class="s1">// older releases of node still supported by this library.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// The spec says:</span><span class="s3">\n  </span><span class="s1">//   If the sources are not absolute URLs after prepending of the</span><span class="s3">\n  </span><span class="s1">//   “sourceRoot”, the sources are resolved relative to the</span><span class="s3">\n  </span><span class="s1">//   SourceMap (like resolving script src in a html document).</span><span class="s3">\n  </span><span class="s1">if (sourceMapURL) {</span><span class="s3">\n    </span><span class="s1">var parsed = urlParse(sourceMapURL);</span><span class="s3">\n    </span><span class="s1">if (!parsed) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">sourceMapURL could not be parsed</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (parsed.path) {</span><span class="s3">\n      </span><span class="s1">// Strip the last path component, but keep the </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n      </span><span class="s1">var index = parsed.path.lastIndexOf('/');</span><span class="s3">\n      </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n        </span><span class="s1">parsed.path = parsed.path.substring(0, index + 1);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sourceURL = join(urlGenerate(parsed), sourceURL);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return normalize(sourceURL);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.computeSourceURL = computeSourceURL;</span><span class="s3">\n\n\n\n</span><span class="s1">//////////////////</span><span class="s3">\n</span><span class="s1">// WEBPACK FOOTER</span><span class="s3">\n</span><span class="s1">// ./lib/util.js</span><span class="s3">\n</span><span class="s1">// module id = 4</span><span class="s3">\n</span><span class="s1">// module chunks = 0&quot;</span><span class="s0">,</span><span class="s1">&quot;/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var util = require('./util');</span><span class="s3">\n</span><span class="s1">var has = Object.prototype.hasOwnProperty;</span><span class="s3">\n</span><span class="s1">var hasNativeMap = typeof Map !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A data structure which is a combination of an array and a set. Adding a new</span><span class="s3">\n </span><span class="s1">* member is O(1), testing for membership is O(1), and finding the index of an</span><span class="s3">\n </span><span class="s1">* element is O(1). Removing elements from the set is not supported. Only</span><span class="s3">\n </span><span class="s1">* strings are supported for membership.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function ArraySet() {</span><span class="s3">\n  </span><span class="s1">this._array = [];</span><span class="s3">\n  </span><span class="s1">this._set = hasNativeMap ? new Map() : Object.create(null);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Static method for creating ArraySet instances from an existing array.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {</span><span class="s3">\n  </span><span class="s1">var set = new ArraySet();</span><span class="s3">\n  </span><span class="s1">for (var i = 0, len = aArray.length; i &lt; len; i++) {</span><span class="s3">\n    </span><span class="s1">set.add(aArray[i], aAllowDuplicates);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return set;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Return how many unique items are in this ArraySet. If duplicates have been</span><span class="s3">\n </span><span class="s1">* added, than those do not count towards the size.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @returns Number</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">ArraySet.prototype.size = function ArraySet_size() {</span><span class="s3">\n  </span><span class="s1">return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Add the given string to this set.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param String aStr</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {</span><span class="s3">\n  </span><span class="s1">var sStr = hasNativeMap ? aStr : util.toSetString(aStr);</span><span class="s3">\n  </span><span class="s1">var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);</span><span class="s3">\n  </span><span class="s1">var idx = this._array.length;</span><span class="s3">\n  </span><span class="s1">if (!isDuplicate || aAllowDuplicates) {</span><span class="s3">\n    </span><span class="s1">this._array.push(aStr);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!isDuplicate) {</span><span class="s3">\n    </span><span class="s1">if (hasNativeMap) {</span><span class="s3">\n      </span><span class="s1">this._set.set(aStr, idx);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this._set[sStr] = idx;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Is the given string a member of this set?</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param String aStr</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">ArraySet.prototype.has = function ArraySet_has(aStr) {</span><span class="s3">\n  </span><span class="s1">if (hasNativeMap) {</span><span class="s3">\n    </span><span class="s1">return this._set.has(aStr);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var sStr = util.toSetString(aStr);</span><span class="s3">\n    </span><span class="s1">return has.call(this._set, sStr);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* What is the index of the given string in the array?</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param String aStr</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {</span><span class="s3">\n  </span><span class="s1">if (hasNativeMap) {</span><span class="s3">\n    </span><span class="s1">var idx = this._set.get(aStr);</span><span class="s3">\n    </span><span class="s1">if (idx &gt;= 0) {</span><span class="s3">\n        </span><span class="s1">return idx;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var sStr = util.toSetString(aStr);</span><span class="s3">\n    </span><span class="s1">if (has.call(this._set, sStr)) {</span><span class="s3">\n      </span><span class="s1">return this._set[sStr];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">throw new Error('</span><span class="s3">\&quot;</span><span class="s1">' + aStr + '</span><span class="s3">\&quot; </span><span class="s1">is not in the set.');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* What is the element at the given index?</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param Number aIdx</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">ArraySet.prototype.at = function ArraySet_at(aIdx) {</span><span class="s3">\n  </span><span class="s1">if (aIdx &gt;= 0 &amp;&amp; aIdx &lt; this._array.length) {</span><span class="s3">\n    </span><span class="s1">return this._array[aIdx];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throw new Error('No element indexed by ' + aIdx);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the array representation of this set (which has the proper indices</span><span class="s3">\n </span><span class="s1">* indicated by indexOf). Note that this is a copy of the internal array used</span><span class="s3">\n </span><span class="s1">* for storing the members so that no one can mess with internal state.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">ArraySet.prototype.toArray = function ArraySet_toArray() {</span><span class="s3">\n  </span><span class="s1">return this._array.slice();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">exports.ArraySet = ArraySet;</span><span class="s3">\n\n\n\n</span><span class="s1">//////////////////</span><span class="s3">\n</span><span class="s1">// WEBPACK FOOTER</span><span class="s3">\n</span><span class="s1">// ./lib/array-set.js</span><span class="s3">\n</span><span class="s1">// module id = 5</span><span class="s3">\n</span><span class="s1">// module chunks = 0&quot;</span><span class="s0">,</span><span class="s1">&quot;/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Copyright 2014 Mozilla Foundation and contributors</span><span class="s3">\n </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var util = require('./util');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determine whether mappingB is after mappingA with respect to generated</span><span class="s3">\n </span><span class="s1">* position.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function generatedPositionAfter(mappingA, mappingB) {</span><span class="s3">\n  </span><span class="s1">// Optimized for most common case</span><span class="s3">\n  </span><span class="s1">var lineA = mappingA.generatedLine;</span><span class="s3">\n  </span><span class="s1">var lineB = mappingB.generatedLine;</span><span class="s3">\n  </span><span class="s1">var columnA = mappingA.generatedColumn;</span><span class="s3">\n  </span><span class="s1">var columnB = mappingB.generatedColumn;</span><span class="s3">\n  </span><span class="s1">return lineB &gt; lineA || lineB == lineA &amp;&amp; columnB &gt;= columnA ||</span><span class="s3">\n         </span><span class="s1">util.compareByGeneratedPositionsInflated(mappingA, mappingB) &lt;= 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A data structure to provide a sorted view of accumulated mappings in a</span><span class="s3">\n </span><span class="s1">* performance conscious manner. It trades a neglibable overhead in general</span><span class="s3">\n </span><span class="s1">* case for a large speedup in case of mappings being added in order.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function MappingList() {</span><span class="s3">\n  </span><span class="s1">this._array = [];</span><span class="s3">\n  </span><span class="s1">this._sorted = true;</span><span class="s3">\n  </span><span class="s1">// Serves as infimum</span><span class="s3">\n  </span><span class="s1">this._last = {generatedLine: -1, generatedColumn: 0};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Iterate through internal items. This method takes the same arguments that</span><span class="s3">\n </span><span class="s1">* `Array.prototype.forEach` takes.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* NOTE: The order of the mappings is NOT guaranteed.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">MappingList.prototype.unsortedForEach =</span><span class="s3">\n  </span><span class="s1">function MappingList_forEach(aCallback, aThisArg) {</span><span class="s3">\n    </span><span class="s1">this._array.forEach(aCallback, aThisArg);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Add the given source mapping.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param Object aMapping</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">MappingList.prototype.add = function MappingList_add(aMapping) {</span><span class="s3">\n  </span><span class="s1">if (generatedPositionAfter(this._last, aMapping)) {</span><span class="s3">\n    </span><span class="s1">this._last = aMapping;</span><span class="s3">\n    </span><span class="s1">this._array.push(aMapping);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this._sorted = false;</span><span class="s3">\n    </span><span class="s1">this._array.push(aMapping);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the flat, sorted array of mappings. The mappings are sorted by</span><span class="s3">\n </span><span class="s1">* generated position.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* WARNING: This method returns internal data without copying, for</span><span class="s3">\n </span><span class="s1">* performance. The return value must NOT be mutated, and should be treated as</span><span class="s3">\n </span><span class="s1">* an immutable borrow. If you want to take ownership, you must make your own</span><span class="s3">\n </span><span class="s1">* copy.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">MappingList.prototype.toArray = function MappingList_toArray() {</span><span class="s3">\n  </span><span class="s1">if (!this._sorted) {</span><span class="s3">\n    </span><span class="s1">this._array.sort(util.compareByGeneratedPositionsInflated);</span><span class="s3">\n    </span><span class="s1">this._sorted = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this._array;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">exports.MappingList = MappingList;</span><span class="s3">\n\n\n\n</span><span class="s1">//////////////////</span><span class="s3">\n</span><span class="s1">// WEBPACK FOOTER</span><span class="s3">\n</span><span class="s1">// ./lib/mapping-list.js</span><span class="s3">\n</span><span class="s1">// module id = 6</span><span class="s3">\n</span><span class="s1">// module chunks = 0&quot;</span><span class="s0">,</span><span class="s1">&quot;/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var util = require('./util');</span><span class="s3">\n</span><span class="s1">var binarySearch = require('./binary-search');</span><span class="s3">\n</span><span class="s1">var ArraySet = require('./array-set').ArraySet;</span><span class="s3">\n</span><span class="s1">var base64VLQ = require('./base64-vlq');</span><span class="s3">\n</span><span class="s1">var quickSort = require('./quick-sort').quickSort;</span><span class="s3">\n\n</span><span class="s1">function SourceMapConsumer(aSourceMap, aSourceMapURL) {</span><span class="s3">\n  </span><span class="s1">var sourceMap = aSourceMap;</span><span class="s3">\n  </span><span class="s1">if (typeof aSourceMap === 'string') {</span><span class="s3">\n    </span><span class="s1">sourceMap = util.parseSourceMapInput(aSourceMap);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return sourceMap.sections != null</span><span class="s3">\n    </span><span class="s1">? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)</span><span class="s3">\n    </span><span class="s1">: new BasicSourceMapConsumer(sourceMap, aSourceMapURL);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {</span><span class="s3">\n  </span><span class="s1">return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The version of the source mapping spec that we are consuming.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceMapConsumer.prototype._version = 3;</span><span class="s3">\n\n</span><span class="s1">// `__generatedMappings` and `__originalMappings` are arrays that hold the</span><span class="s3">\n</span><span class="s1">// parsed mapping coordinates from the source map's </span><span class="s3">\&quot;</span><span class="s1">mappings</span><span class="s3">\&quot; </span><span class="s1">attribute. They</span><span class="s3">\n</span><span class="s1">// are lazily instantiated, accessed via the `_generatedMappings` and</span><span class="s3">\n</span><span class="s1">// `_originalMappings` getters respectively, and we only parse the mappings</span><span class="s3">\n</span><span class="s1">// and create these arrays once queried for a source location. We jump through</span><span class="s3">\n</span><span class="s1">// these hoops because there can be many thousands of mappings, and parsing</span><span class="s3">\n</span><span class="s1">// them is expensive, so we only want to do it if we must.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Each object in the arrays is of the form:</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">//     {</span><span class="s3">\n</span><span class="s1">//       generatedLine: The line number in the generated code,</span><span class="s3">\n</span><span class="s1">//       generatedColumn: The column number in the generated code,</span><span class="s3">\n</span><span class="s1">//       source: The path to the original source file that generated this</span><span class="s3">\n</span><span class="s1">//               chunk of code,</span><span class="s3">\n</span><span class="s1">//       originalLine: The line number in the original source that</span><span class="s3">\n</span><span class="s1">//                     corresponds to this chunk of generated code,</span><span class="s3">\n</span><span class="s1">//       originalColumn: The column number in the original source that</span><span class="s3">\n</span><span class="s1">//                       corresponds to this chunk of generated code,</span><span class="s3">\n</span><span class="s1">//       name: The name of the original symbol which generated this chunk of</span><span class="s3">\n</span><span class="s1">//             code.</span><span class="s3">\n</span><span class="s1">//     }</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// All properties except for `generatedLine` and `generatedColumn` can be</span><span class="s3">\n</span><span class="s1">// `null`.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// `_generatedMappings` is ordered by the generated positions.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// `_originalMappings` is ordered by the original positions.</span><span class="s3">\n\n</span><span class="s1">SourceMapConsumer.prototype.__generatedMappings = null;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {</span><span class="s3">\n  </span><span class="s1">configurable: true,</span><span class="s3">\n  </span><span class="s1">enumerable: true,</span><span class="s3">\n  </span><span class="s1">get: function () {</span><span class="s3">\n    </span><span class="s1">if (!this.__generatedMappings) {</span><span class="s3">\n      </span><span class="s1">this._parseMappings(this._mappings, this.sourceRoot);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.__generatedMappings;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">SourceMapConsumer.prototype.__originalMappings = null;</span><span class="s3">\n</span><span class="s1">Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {</span><span class="s3">\n  </span><span class="s1">configurable: true,</span><span class="s3">\n  </span><span class="s1">enumerable: true,</span><span class="s3">\n  </span><span class="s1">get: function () {</span><span class="s3">\n    </span><span class="s1">if (!this.__originalMappings) {</span><span class="s3">\n      </span><span class="s1">this._parseMappings(this._mappings, this.sourceRoot);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.__originalMappings;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">SourceMapConsumer.prototype._charIsMappingSeparator =</span><span class="s3">\n  </span><span class="s1">function SourceMapConsumer_charIsMappingSeparator(aStr, index) {</span><span class="s3">\n    </span><span class="s1">var c = aStr.charAt(index);</span><span class="s3">\n    </span><span class="s1">return c === </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot; </span><span class="s1">|| c === </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parse the mappings in a string in to a data structure which we can easily</span><span class="s3">\n </span><span class="s1">* query (the ordered arrays in the `this.__generatedMappings` and</span><span class="s3">\n </span><span class="s1">* `this.__originalMappings` properties).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceMapConsumer.prototype._parseMappings =</span><span class="s3">\n  </span><span class="s1">function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Subclasses must implement _parseMappings</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">SourceMapConsumer.GENERATED_ORDER = 1;</span><span class="s3">\n</span><span class="s1">SourceMapConsumer.ORIGINAL_ORDER = 2;</span><span class="s3">\n\n</span><span class="s1">SourceMapConsumer.GREATEST_LOWER_BOUND = 1;</span><span class="s3">\n</span><span class="s1">SourceMapConsumer.LEAST_UPPER_BOUND = 2;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Iterate over each mapping between an original source/line/column and a</span><span class="s3">\n </span><span class="s1">* generated line/column in this source map.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param Function aCallback</span><span class="s3">\n </span><span class="s1">*        The function that is called with each mapping.</span><span class="s3">\n </span><span class="s1">* @param Object aContext</span><span class="s3">\n </span><span class="s1">*        Optional. If specified, this object will be the value of `this` every</span><span class="s3">\n </span><span class="s1">*        time that `aCallback` is called.</span><span class="s3">\n </span><span class="s1">* @param aOrder</span><span class="s3">\n </span><span class="s1">*        Either `SourceMapConsumer.GENERATED_ORDER` or</span><span class="s3">\n </span><span class="s1">*        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to</span><span class="s3">\n </span><span class="s1">*        iterate over the mappings sorted by the generated file's line/column</span><span class="s3">\n </span><span class="s1">*        order or the original's source/line/column order, respectively. Defaults to</span><span class="s3">\n </span><span class="s1">*        `SourceMapConsumer.GENERATED_ORDER`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceMapConsumer.prototype.eachMapping =</span><span class="s3">\n  </span><span class="s1">function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {</span><span class="s3">\n    </span><span class="s1">var context = aContext || null;</span><span class="s3">\n    </span><span class="s1">var order = aOrder || SourceMapConsumer.GENERATED_ORDER;</span><span class="s3">\n\n    </span><span class="s1">var mappings;</span><span class="s3">\n    </span><span class="s1">switch (order) {</span><span class="s3">\n    </span><span class="s1">case SourceMapConsumer.GENERATED_ORDER:</span><span class="s3">\n      </span><span class="s1">mappings = this._generatedMappings;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case SourceMapConsumer.ORIGINAL_ORDER:</span><span class="s3">\n      </span><span class="s1">mappings = this._originalMappings;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Unknown order of iteration.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var sourceRoot = this.sourceRoot;</span><span class="s3">\n    </span><span class="s1">mappings.map(function (mapping) {</span><span class="s3">\n      </span><span class="s1">var source = mapping.source === null ? null : this._sources.at(mapping.source);</span><span class="s3">\n      </span><span class="s1">source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">source: source,</span><span class="s3">\n        </span><span class="s1">generatedLine: mapping.generatedLine,</span><span class="s3">\n        </span><span class="s1">generatedColumn: mapping.generatedColumn,</span><span class="s3">\n        </span><span class="s1">originalLine: mapping.originalLine,</span><span class="s3">\n        </span><span class="s1">originalColumn: mapping.originalColumn,</span><span class="s3">\n        </span><span class="s1">name: mapping.name === null ? null : this._names.at(mapping.name)</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}, this).forEach(aCallback, context);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns all generated line and column information for the original source,</span><span class="s3">\n </span><span class="s1">* line, and column provided. If no column is provided, returns all mappings</span><span class="s3">\n </span><span class="s1">* corresponding to a either the line we are searching for or the next</span><span class="s3">\n </span><span class="s1">* closest line that has any mappings. Otherwise, returns all mappings</span><span class="s3">\n </span><span class="s1">* corresponding to the given line and either the column we are searching for</span><span class="s3">\n </span><span class="s1">* or the next closest column that has any offsets.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The only argument is an object with the following properties:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   - source: The filename of the original source.</span><span class="s3">\n </span><span class="s1">*   - line: The line number in the original source.  The line number is 1-based.</span><span class="s3">\n </span><span class="s1">*   - column: Optional. the column number in the original source.</span><span class="s3">\n </span><span class="s1">*    The column number is 0-based.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* and an array of objects is returned, each with the following properties:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   - line: The line number in the generated source, or null.  The</span><span class="s3">\n </span><span class="s1">*    line number is 1-based.</span><span class="s3">\n </span><span class="s1">*   - column: The column number in the generated source, or null.</span><span class="s3">\n </span><span class="s1">*    The column number is 0-based.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceMapConsumer.prototype.allGeneratedPositionsFor =</span><span class="s3">\n  </span><span class="s1">function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {</span><span class="s3">\n    </span><span class="s1">var line = util.getArg(aArgs, 'line');</span><span class="s3">\n\n    </span><span class="s1">// When there is no exact match, BasicSourceMapConsumer.prototype._findMapping</span><span class="s3">\n    </span><span class="s1">// returns the index of the closest mapping less than the needle. By</span><span class="s3">\n    </span><span class="s1">// setting needle.originalColumn to 0, we thus find the last mapping for</span><span class="s3">\n    </span><span class="s1">// the given line, provided such a mapping exists.</span><span class="s3">\n    </span><span class="s1">var needle = {</span><span class="s3">\n      </span><span class="s1">source: util.getArg(aArgs, 'source'),</span><span class="s3">\n      </span><span class="s1">originalLine: line,</span><span class="s3">\n      </span><span class="s1">originalColumn: util.getArg(aArgs, 'column', 0)</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">needle.source = this._findSourceIndex(needle.source);</span><span class="s3">\n    </span><span class="s1">if (needle.source &lt; 0) {</span><span class="s3">\n      </span><span class="s1">return [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var mappings = [];</span><span class="s3">\n\n    </span><span class="s1">var index = this._findMapping(needle,</span><span class="s3">\n                                  </span><span class="s1">this._originalMappings,</span><span class="s3">\n                                  \&quot;</span><span class="s1">originalLine</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                                  \&quot;</span><span class="s1">originalColumn</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                                  </span><span class="s1">util.compareByOriginalPositions,</span><span class="s3">\n                                  </span><span class="s1">binarySearch.LEAST_UPPER_BOUND);</span><span class="s3">\n    </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n      </span><span class="s1">var mapping = this._originalMappings[index];</span><span class="s3">\n\n      </span><span class="s1">if (aArgs.column === undefined) {</span><span class="s3">\n        </span><span class="s1">var originalLine = mapping.originalLine;</span><span class="s3">\n\n        </span><span class="s1">// Iterate until either we run out of mappings, or we run into</span><span class="s3">\n        </span><span class="s1">// a mapping for a different line than the one we found. Since</span><span class="s3">\n        </span><span class="s1">// mappings are sorted, this is guaranteed to find all mappings for</span><span class="s3">\n        </span><span class="s1">// the line we found.</span><span class="s3">\n        </span><span class="s1">while (mapping &amp;&amp; mapping.originalLine === originalLine) {</span><span class="s3">\n          </span><span class="s1">mappings.push({</span><span class="s3">\n            </span><span class="s1">line: util.getArg(mapping, 'generatedLine', null),</span><span class="s3">\n            </span><span class="s1">column: util.getArg(mapping, 'generatedColumn', null),</span><span class="s3">\n            </span><span class="s1">lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n\n          </span><span class="s1">mapping = this._originalMappings[++index];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var originalColumn = mapping.originalColumn;</span><span class="s3">\n\n        </span><span class="s1">// Iterate until either we run out of mappings, or we run into</span><span class="s3">\n        </span><span class="s1">// a mapping for a different line than the one we were searching for.</span><span class="s3">\n        </span><span class="s1">// Since mappings are sorted, this is guaranteed to find all mappings for</span><span class="s3">\n        </span><span class="s1">// the line we are searching for.</span><span class="s3">\n        </span><span class="s1">while (mapping &amp;&amp;</span><span class="s3">\n               </span><span class="s1">mapping.originalLine === line &amp;&amp;</span><span class="s3">\n               </span><span class="s1">mapping.originalColumn == originalColumn) {</span><span class="s3">\n          </span><span class="s1">mappings.push({</span><span class="s3">\n            </span><span class="s1">line: util.getArg(mapping, 'generatedLine', null),</span><span class="s3">\n            </span><span class="s1">column: util.getArg(mapping, 'generatedColumn', null),</span><span class="s3">\n            </span><span class="s1">lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n\n          </span><span class="s1">mapping = this._originalMappings[++index];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return mappings;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">exports.SourceMapConsumer = SourceMapConsumer;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A BasicSourceMapConsumer instance represents a parsed source map which we can</span><span class="s3">\n </span><span class="s1">* query for information about the original file positions by giving it a file</span><span class="s3">\n </span><span class="s1">* position in the generated source.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The first parameter is the raw source map (either as a JSON string, or</span><span class="s3">\n </span><span class="s1">* already parsed to an object). According to the spec, source maps have the</span><span class="s3">\n </span><span class="s1">* following attributes:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   - version: Which version of the source map spec this map is following.</span><span class="s3">\n </span><span class="s1">*   - sources: An array of URLs to the original source files.</span><span class="s3">\n </span><span class="s1">*   - names: An array of identifiers which can be referrenced by individual mappings.</span><span class="s3">\n </span><span class="s1">*   - sourceRoot: Optional. The URL root from which all sources are relative.</span><span class="s3">\n </span><span class="s1">*   - sourcesContent: Optional. An array of contents of the original source files.</span><span class="s3">\n </span><span class="s1">*   - mappings: A string of base64 VLQs which contain the actual mappings.</span><span class="s3">\n </span><span class="s1">*   - file: Optional. The generated file this source map is associated with.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Here is an example source map, taken from the source map spec[0]:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*     {</span><span class="s3">\n </span><span class="s1">*       version : 3,</span><span class="s3">\n </span><span class="s1">*       file: </span><span class="s3">\&quot;</span><span class="s1">out.js</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n </span><span class="s1">*       sourceRoot : </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n </span><span class="s1">*       sources: [</span><span class="s3">\&quot;</span><span class="s1">foo.js</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">bar.js</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n </span><span class="s1">*       names: [</span><span class="s3">\&quot;</span><span class="s1">src</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">maps</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">are</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">fun</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n </span><span class="s1">*       mappings: </span><span class="s3">\&quot;</span><span class="s1">AA,AB;;ABCDE;</span><span class="s3">\&quot;\n </span><span class="s1">*     }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The second parameter, if given, is a string whose value is the URL</span><span class="s3">\n </span><span class="s1">* at which the source map was found.  This URL is used to compute the</span><span class="s3">\n </span><span class="s1">* sources array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {</span><span class="s3">\n  </span><span class="s1">var sourceMap = aSourceMap;</span><span class="s3">\n  </span><span class="s1">if (typeof aSourceMap === 'string') {</span><span class="s3">\n    </span><span class="s1">sourceMap = util.parseSourceMapInput(aSourceMap);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var version = util.getArg(sourceMap, 'version');</span><span class="s3">\n  </span><span class="s1">var sources = util.getArg(sourceMap, 'sources');</span><span class="s3">\n  </span><span class="s1">// Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which</span><span class="s3">\n  </span><span class="s1">// requires the array) to play nice here.</span><span class="s3">\n  </span><span class="s1">var names = util.getArg(sourceMap, 'names', []);</span><span class="s3">\n  </span><span class="s1">var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);</span><span class="s3">\n  </span><span class="s1">var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);</span><span class="s3">\n  </span><span class="s1">var mappings = util.getArg(sourceMap, 'mappings');</span><span class="s3">\n  </span><span class="s1">var file = util.getArg(sourceMap, 'file', null);</span><span class="s3">\n\n  </span><span class="s1">// Once again, Sass deviates from the spec and supplies the version as a</span><span class="s3">\n  </span><span class="s1">// string rather than a number, so we use loose equality checking here.</span><span class="s3">\n  </span><span class="s1">if (version != this._version) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Unsupported version: ' + version);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (sourceRoot) {</span><span class="s3">\n    </span><span class="s1">sourceRoot = util.normalize(sourceRoot);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">sources = sources</span><span class="s3">\n    </span><span class="s1">.map(String)</span><span class="s3">\n    </span><span class="s1">// Some source maps produce relative source paths like </span><span class="s3">\&quot;</span><span class="s1">./foo.js</span><span class="s3">\&quot; </span><span class="s1">instead of</span><span class="s3">\n    </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">foo.js</span><span class="s3">\&quot;</span><span class="s1">.  Normalize these first so that future comparisons will succeed.</span><span class="s3">\n    </span><span class="s1">// See bugzil.la/1090768.</span><span class="s3">\n    </span><span class="s1">.map(util.normalize)</span><span class="s3">\n    </span><span class="s1">// Always ensure that absolute sources are internally stored relative to</span><span class="s3">\n    </span><span class="s1">// the source root, if the source root is absolute. Not doing this would</span><span class="s3">\n    </span><span class="s1">// be particularly problematic when the source root is a prefix of the</span><span class="s3">\n    </span><span class="s1">// source (valid, but why??). See github issue #199 and bugzil.la/1188982.</span><span class="s3">\n    </span><span class="s1">.map(function (source) {</span><span class="s3">\n      </span><span class="s1">return sourceRoot &amp;&amp; util.isAbsolute(sourceRoot) &amp;&amp; util.isAbsolute(source)</span><span class="s3">\n        </span><span class="s1">? util.relative(sourceRoot, source)</span><span class="s3">\n        </span><span class="s1">: source;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// Pass `true` below to allow duplicate names and sources. While source maps</span><span class="s3">\n  </span><span class="s1">// are intended to be compressed and deduplicated, the TypeScript compiler</span><span class="s3">\n  </span><span class="s1">// sometimes generates source maps with duplicates in them. See Github issue</span><span class="s3">\n  </span><span class="s1">// #72 and bugzil.la/889492.</span><span class="s3">\n  </span><span class="s1">this._names = ArraySet.fromArray(names.map(String), true);</span><span class="s3">\n  </span><span class="s1">this._sources = ArraySet.fromArray(sources, true);</span><span class="s3">\n\n  </span><span class="s1">this._absoluteSources = this._sources.toArray().map(function (s) {</span><span class="s3">\n    </span><span class="s1">return util.computeSourceURL(sourceRoot, s, aSourceMapURL);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">this.sourceRoot = sourceRoot;</span><span class="s3">\n  </span><span class="s1">this.sourcesContent = sourcesContent;</span><span class="s3">\n  </span><span class="s1">this._mappings = mappings;</span><span class="s3">\n  </span><span class="s1">this._sourceMapURL = aSourceMapURL;</span><span class="s3">\n  </span><span class="s1">this.file = file;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);</span><span class="s3">\n</span><span class="s1">BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Utility function to find the index of a source.  Returns -1 if not</span><span class="s3">\n </span><span class="s1">* found.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {</span><span class="s3">\n  </span><span class="s1">var relativeSource = aSource;</span><span class="s3">\n  </span><span class="s1">if (this.sourceRoot != null) {</span><span class="s3">\n    </span><span class="s1">relativeSource = util.relative(this.sourceRoot, relativeSource);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this._sources.has(relativeSource)) {</span><span class="s3">\n    </span><span class="s1">return this._sources.indexOf(relativeSource);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Maybe aSource is an absolute URL as returned by |sources|.  In</span><span class="s3">\n  </span><span class="s1">// this case we can't simply undo the transform.</span><span class="s3">\n  </span><span class="s1">var i;</span><span class="s3">\n  </span><span class="s1">for (i = 0; i &lt; this._absoluteSources.length; ++i) {</span><span class="s3">\n    </span><span class="s1">if (this._absoluteSources[i] == aSource) {</span><span class="s3">\n      </span><span class="s1">return i;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return -1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create a BasicSourceMapConsumer from a SourceMapGenerator.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param SourceMapGenerator aSourceMap</span><span class="s3">\n </span><span class="s1">*        The source map that will be consumed.</span><span class="s3">\n </span><span class="s1">* @param String aSourceMapURL</span><span class="s3">\n </span><span class="s1">*        The URL at which the source map can be found (optional)</span><span class="s3">\n </span><span class="s1">* @returns BasicSourceMapConsumer</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">BasicSourceMapConsumer.fromSourceMap =</span><span class="s3">\n  </span><span class="s1">function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {</span><span class="s3">\n    </span><span class="s1">var smc = Object.create(BasicSourceMapConsumer.prototype);</span><span class="s3">\n\n    </span><span class="s1">var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);</span><span class="s3">\n    </span><span class="s1">var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);</span><span class="s3">\n    </span><span class="s1">smc.sourceRoot = aSourceMap._sourceRoot;</span><span class="s3">\n    </span><span class="s1">smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),</span><span class="s3">\n                                                            </span><span class="s1">smc.sourceRoot);</span><span class="s3">\n    </span><span class="s1">smc.file = aSourceMap._file;</span><span class="s3">\n    </span><span class="s1">smc._sourceMapURL = aSourceMapURL;</span><span class="s3">\n    </span><span class="s1">smc._absoluteSources = smc._sources.toArray().map(function (s) {</span><span class="s3">\n      </span><span class="s1">return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">// Because we are modifying the entries (by converting string sources and</span><span class="s3">\n    </span><span class="s1">// names to indices into the sources and names ArraySets), we have to make</span><span class="s3">\n    </span><span class="s1">// a copy of the entry or else bad things happen. Shared mutable state</span><span class="s3">\n    </span><span class="s1">// strikes again! See github issue #191.</span><span class="s3">\n\n    </span><span class="s1">var generatedMappings = aSourceMap._mappings.toArray().slice();</span><span class="s3">\n    </span><span class="s1">var destGeneratedMappings = smc.__generatedMappings = [];</span><span class="s3">\n    </span><span class="s1">var destOriginalMappings = smc.__originalMappings = [];</span><span class="s3">\n\n    </span><span class="s1">for (var i = 0, length = generatedMappings.length; i &lt; length; i++) {</span><span class="s3">\n      </span><span class="s1">var srcMapping = generatedMappings[i];</span><span class="s3">\n      </span><span class="s1">var destMapping = new Mapping;</span><span class="s3">\n      </span><span class="s1">destMapping.generatedLine = srcMapping.generatedLine;</span><span class="s3">\n      </span><span class="s1">destMapping.generatedColumn = srcMapping.generatedColumn;</span><span class="s3">\n\n      </span><span class="s1">if (srcMapping.source) {</span><span class="s3">\n        </span><span class="s1">destMapping.source = sources.indexOf(srcMapping.source);</span><span class="s3">\n        </span><span class="s1">destMapping.originalLine = srcMapping.originalLine;</span><span class="s3">\n        </span><span class="s1">destMapping.originalColumn = srcMapping.originalColumn;</span><span class="s3">\n\n        </span><span class="s1">if (srcMapping.name) {</span><span class="s3">\n          </span><span class="s1">destMapping.name = names.indexOf(srcMapping.name);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">destOriginalMappings.push(destMapping);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">destGeneratedMappings.push(destMapping);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">quickSort(smc.__originalMappings, util.compareByOriginalPositions);</span><span class="s3">\n\n    </span><span class="s1">return smc;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The version of the source mapping spec that we are consuming.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">BasicSourceMapConsumer.prototype._version = 3;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The list of original sources.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {</span><span class="s3">\n  </span><span class="s1">get: function () {</span><span class="s3">\n    </span><span class="s1">return this._absoluteSources.slice();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Provide the JIT with a nice shape / hidden class.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function Mapping() {</span><span class="s3">\n  </span><span class="s1">this.generatedLine = 0;</span><span class="s3">\n  </span><span class="s1">this.generatedColumn = 0;</span><span class="s3">\n  </span><span class="s1">this.source = null;</span><span class="s3">\n  </span><span class="s1">this.originalLine = null;</span><span class="s3">\n  </span><span class="s1">this.originalColumn = null;</span><span class="s3">\n  </span><span class="s1">this.name = null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parse the mappings in a string in to a data structure which we can easily</span><span class="s3">\n </span><span class="s1">* query (the ordered arrays in the `this.__generatedMappings` and</span><span class="s3">\n </span><span class="s1">* `this.__originalMappings` properties).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">BasicSourceMapConsumer.prototype._parseMappings =</span><span class="s3">\n  </span><span class="s1">function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {</span><span class="s3">\n    </span><span class="s1">var generatedLine = 1;</span><span class="s3">\n    </span><span class="s1">var previousGeneratedColumn = 0;</span><span class="s3">\n    </span><span class="s1">var previousOriginalLine = 0;</span><span class="s3">\n    </span><span class="s1">var previousOriginalColumn = 0;</span><span class="s3">\n    </span><span class="s1">var previousSource = 0;</span><span class="s3">\n    </span><span class="s1">var previousName = 0;</span><span class="s3">\n    </span><span class="s1">var length = aStr.length;</span><span class="s3">\n    </span><span class="s1">var index = 0;</span><span class="s3">\n    </span><span class="s1">var cachedSegments = {};</span><span class="s3">\n    </span><span class="s1">var temp = {};</span><span class="s3">\n    </span><span class="s1">var originalMappings = [];</span><span class="s3">\n    </span><span class="s1">var generatedMappings = [];</span><span class="s3">\n    </span><span class="s1">var mapping, str, segment, end, value;</span><span class="s3">\n\n    </span><span class="s1">while (index &lt; length) {</span><span class="s3">\n      </span><span class="s1">if (aStr.charAt(index) === ';') {</span><span class="s3">\n        </span><span class="s1">generatedLine++;</span><span class="s3">\n        </span><span class="s1">index++;</span><span class="s3">\n        </span><span class="s1">previousGeneratedColumn = 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">else if (aStr.charAt(index) === ',') {</span><span class="s3">\n        </span><span class="s1">index++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">mapping = new Mapping();</span><span class="s3">\n        </span><span class="s1">mapping.generatedLine = generatedLine;</span><span class="s3">\n\n        </span><span class="s1">// Because each offset is encoded relative to the previous one,</span><span class="s3">\n        </span><span class="s1">// many segments often have the same encoding. We can exploit this</span><span class="s3">\n        </span><span class="s1">// fact by caching the parsed variable length fields of each segment,</span><span class="s3">\n        </span><span class="s1">// allowing us to avoid a second parse if we encounter the same</span><span class="s3">\n        </span><span class="s1">// segment again.</span><span class="s3">\n        </span><span class="s1">for (end = index; end &lt; length; end++) {</span><span class="s3">\n          </span><span class="s1">if (this._charIsMappingSeparator(aStr, end)) {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">str = aStr.slice(index, end);</span><span class="s3">\n\n        </span><span class="s1">segment = cachedSegments[str];</span><span class="s3">\n        </span><span class="s1">if (segment) {</span><span class="s3">\n          </span><span class="s1">index += str.length;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">segment = [];</span><span class="s3">\n          </span><span class="s1">while (index &lt; end) {</span><span class="s3">\n            </span><span class="s1">base64VLQ.decode(aStr, index, temp);</span><span class="s3">\n            </span><span class="s1">value = temp.value;</span><span class="s3">\n            </span><span class="s1">index = temp.rest;</span><span class="s3">\n            </span><span class="s1">segment.push(value);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (segment.length === 2) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Found a source, but no line and column');</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (segment.length === 3) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Found a source and line, but no column');</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">cachedSegments[str] = segment;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Generated column.</span><span class="s3">\n        </span><span class="s1">mapping.generatedColumn = previousGeneratedColumn + segment[0];</span><span class="s3">\n        </span><span class="s1">previousGeneratedColumn = mapping.generatedColumn;</span><span class="s3">\n\n        </span><span class="s1">if (segment.length &gt; 1) {</span><span class="s3">\n          </span><span class="s1">// Original source.</span><span class="s3">\n          </span><span class="s1">mapping.source = previousSource + segment[1];</span><span class="s3">\n          </span><span class="s1">previousSource += segment[1];</span><span class="s3">\n\n          </span><span class="s1">// Original line.</span><span class="s3">\n          </span><span class="s1">mapping.originalLine = previousOriginalLine + segment[2];</span><span class="s3">\n          </span><span class="s1">previousOriginalLine = mapping.originalLine;</span><span class="s3">\n          </span><span class="s1">// Lines are stored 0-based</span><span class="s3">\n          </span><span class="s1">mapping.originalLine += 1;</span><span class="s3">\n\n          </span><span class="s1">// Original column.</span><span class="s3">\n          </span><span class="s1">mapping.originalColumn = previousOriginalColumn + segment[3];</span><span class="s3">\n          </span><span class="s1">previousOriginalColumn = mapping.originalColumn;</span><span class="s3">\n\n          </span><span class="s1">if (segment.length &gt; 4) {</span><span class="s3">\n            </span><span class="s1">// Original name.</span><span class="s3">\n            </span><span class="s1">mapping.name = previousName + segment[4];</span><span class="s3">\n            </span><span class="s1">previousName += segment[4];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">generatedMappings.push(mapping);</span><span class="s3">\n        </span><span class="s1">if (typeof mapping.originalLine === 'number') {</span><span class="s3">\n          </span><span class="s1">originalMappings.push(mapping);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);</span><span class="s3">\n    </span><span class="s1">this.__generatedMappings = generatedMappings;</span><span class="s3">\n\n    </span><span class="s1">quickSort(originalMappings, util.compareByOriginalPositions);</span><span class="s3">\n    </span><span class="s1">this.__originalMappings = originalMappings;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Find the mapping that best matches the hypothetical </span><span class="s3">\&quot;</span><span class="s1">needle</span><span class="s3">\&quot; </span><span class="s1">mapping that</span><span class="s3">\n </span><span class="s1">* we are searching for in the given </span><span class="s3">\&quot;</span><span class="s1">haystack</span><span class="s3">\&quot; </span><span class="s1">of mappings.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">BasicSourceMapConsumer.prototype._findMapping =</span><span class="s3">\n  </span><span class="s1">function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,</span><span class="s3">\n                                         </span><span class="s1">aColumnName, aComparator, aBias) {</span><span class="s3">\n    </span><span class="s1">// To return the position we are searching for, we must first find the</span><span class="s3">\n    </span><span class="s1">// mapping for the given position and then return the opposite position it</span><span class="s3">\n    </span><span class="s1">// points to. Because the mappings are sorted, we can use binary search to</span><span class="s3">\n    </span><span class="s1">// find the best mapping.</span><span class="s3">\n\n    </span><span class="s1">if (aNeedle[aLineName] &lt;= 0) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError('Line must be greater than or equal to 1, got '</span><span class="s3">\n                          </span><span class="s1">+ aNeedle[aLineName]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (aNeedle[aColumnName] &lt; 0) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError('Column must be greater than or equal to 0, got '</span><span class="s3">\n                          </span><span class="s1">+ aNeedle[aColumnName]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return binarySearch.search(aNeedle, aMappings, aComparator, aBias);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Compute the last column for each generated mapping. The last column is</span><span class="s3">\n </span><span class="s1">* inclusive.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">BasicSourceMapConsumer.prototype.computeColumnSpans =</span><span class="s3">\n  </span><span class="s1">function SourceMapConsumer_computeColumnSpans() {</span><span class="s3">\n    </span><span class="s1">for (var index = 0; index &lt; this._generatedMappings.length; ++index) {</span><span class="s3">\n      </span><span class="s1">var mapping = this._generatedMappings[index];</span><span class="s3">\n\n      </span><span class="s1">// Mappings do not contain a field for the last generated columnt. We</span><span class="s3">\n      </span><span class="s1">// can come up with an optimistic estimate, however, by assuming that</span><span class="s3">\n      </span><span class="s1">// mappings are contiguous (i.e. given two consecutive mappings, the</span><span class="s3">\n      </span><span class="s1">// first mapping ends where the second one starts).</span><span class="s3">\n      </span><span class="s1">if (index + 1 &lt; this._generatedMappings.length) {</span><span class="s3">\n        </span><span class="s1">var nextMapping = this._generatedMappings[index + 1];</span><span class="s3">\n\n        </span><span class="s1">if (mapping.generatedLine === nextMapping.generatedLine) {</span><span class="s3">\n          </span><span class="s1">mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// The last mapping for each line spans the entire line.</span><span class="s3">\n      </span><span class="s1">mapping.lastGeneratedColumn = Infinity;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the original source, line, and column information for the generated</span><span class="s3">\n </span><span class="s1">* source's line and column positions provided. The only argument is an object</span><span class="s3">\n </span><span class="s1">* with the following properties:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   - line: The line number in the generated source.  The line number</span><span class="s3">\n </span><span class="s1">*     is 1-based.</span><span class="s3">\n </span><span class="s1">*   - column: The column number in the generated source.  The column</span><span class="s3">\n </span><span class="s1">*     number is 0-based.</span><span class="s3">\n </span><span class="s1">*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or</span><span class="s3">\n </span><span class="s1">*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the</span><span class="s3">\n </span><span class="s1">*     closest element that is smaller than or greater than the one we are</span><span class="s3">\n </span><span class="s1">*     searching for, respectively, if the exact element cannot be found.</span><span class="s3">\n </span><span class="s1">*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* and an object is returned with the following properties:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   - source: The original source file, or null.</span><span class="s3">\n </span><span class="s1">*   - line: The line number in the original source, or null.  The</span><span class="s3">\n </span><span class="s1">*     line number is 1-based.</span><span class="s3">\n </span><span class="s1">*   - column: The column number in the original source, or null.  The</span><span class="s3">\n </span><span class="s1">*     column number is 0-based.</span><span class="s3">\n </span><span class="s1">*   - name: The original identifier, or null.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">BasicSourceMapConsumer.prototype.originalPositionFor =</span><span class="s3">\n  </span><span class="s1">function SourceMapConsumer_originalPositionFor(aArgs) {</span><span class="s3">\n    </span><span class="s1">var needle = {</span><span class="s3">\n      </span><span class="s1">generatedLine: util.getArg(aArgs, 'line'),</span><span class="s3">\n      </span><span class="s1">generatedColumn: util.getArg(aArgs, 'column')</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">var index = this._findMapping(</span><span class="s3">\n      </span><span class="s1">needle,</span><span class="s3">\n      </span><span class="s1">this._generatedMappings,</span><span class="s3">\n      \&quot;</span><span class="s1">generatedLine</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      \&quot;</span><span class="s1">generatedColumn</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">util.compareByGeneratedPositionsDeflated,</span><span class="s3">\n      </span><span class="s1">util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n      </span><span class="s1">var mapping = this._generatedMappings[index];</span><span class="s3">\n\n      </span><span class="s1">if (mapping.generatedLine === needle.generatedLine) {</span><span class="s3">\n        </span><span class="s1">var source = util.getArg(mapping, 'source', null);</span><span class="s3">\n        </span><span class="s1">if (source !== null) {</span><span class="s3">\n          </span><span class="s1">source = this._sources.at(source);</span><span class="s3">\n          </span><span class="s1">source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var name = util.getArg(mapping, 'name', null);</span><span class="s3">\n        </span><span class="s1">if (name !== null) {</span><span class="s3">\n          </span><span class="s1">name = this._names.at(name);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">source: source,</span><span class="s3">\n          </span><span class="s1">line: util.getArg(mapping, 'originalLine', null),</span><span class="s3">\n          </span><span class="s1">column: util.getArg(mapping, 'originalColumn', null),</span><span class="s3">\n          </span><span class="s1">name: name</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">source: null,</span><span class="s3">\n      </span><span class="s1">line: null,</span><span class="s3">\n      </span><span class="s1">column: null,</span><span class="s3">\n      </span><span class="s1">name: null</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Return true if we have the source content for every source in the source</span><span class="s3">\n </span><span class="s1">* map, false otherwise.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">BasicSourceMapConsumer.prototype.hasContentsOfAllSources =</span><span class="s3">\n  </span><span class="s1">function BasicSourceMapConsumer_hasContentsOfAllSources() {</span><span class="s3">\n    </span><span class="s1">if (!this.sourcesContent) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.sourcesContent.length &gt;= this._sources.size() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!this.sourcesContent.some(function (sc) { return sc == null; });</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the original source content. The only argument is the url of the</span><span class="s3">\n </span><span class="s1">* original source file. Returns null if no original source content is</span><span class="s3">\n </span><span class="s1">* available.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">BasicSourceMapConsumer.prototype.sourceContentFor =</span><span class="s3">\n  </span><span class="s1">function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {</span><span class="s3">\n    </span><span class="s1">if (!this.sourcesContent) {</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var index = this._findSourceIndex(aSource);</span><span class="s3">\n    </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n      </span><span class="s1">return this.sourcesContent[index];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var relativeSource = aSource;</span><span class="s3">\n    </span><span class="s1">if (this.sourceRoot != null) {</span><span class="s3">\n      </span><span class="s1">relativeSource = util.relative(this.sourceRoot, relativeSource);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var url;</span><span class="s3">\n    </span><span class="s1">if (this.sourceRoot != null</span><span class="s3">\n        </span><span class="s1">&amp;&amp; (url = util.urlParse(this.sourceRoot))) {</span><span class="s3">\n      </span><span class="s1">// XXX: file:// URIs and absolute paths lead to unexpected behavior for</span><span class="s3">\n      </span><span class="s1">// many users. We can help them out when they expect file:// URIs to</span><span class="s3">\n      </span><span class="s1">// behave like it would if they were running a local HTTP server. See</span><span class="s3">\n      </span><span class="s1">// https://bugzilla.mozilla.org/show_bug.cgi?id=885597.</span><span class="s3">\n      </span><span class="s1">var fileUriAbsPath = relativeSource.replace(/^file:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">//, </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (url.scheme == </span><span class="s3">\&quot;</span><span class="s1">file</span><span class="s3">\&quot;\n          </span><span class="s1">&amp;&amp; this._sources.has(fileUriAbsPath)) {</span><span class="s3">\n        </span><span class="s1">return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if ((!url.path || url.path == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">&amp;&amp; this._sources.has(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ relativeSource)) {</span><span class="s3">\n        </span><span class="s1">return this.sourcesContent[this._sources.indexOf(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">+ relativeSource)];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// This function is used recursively from</span><span class="s3">\n    </span><span class="s1">// IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we</span><span class="s3">\n    </span><span class="s1">// don't want to throw if we can't find the source - we just want to</span><span class="s3">\n    </span><span class="s1">// return null, so we provide a flag to exit gracefully.</span><span class="s3">\n    </span><span class="s1">if (nullOnMissing) {</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n      </span><span class="s1">throw new Error('</span><span class="s3">\&quot;</span><span class="s1">' + relativeSource + '</span><span class="s3">\&quot; </span><span class="s1">is not in the SourceMap.');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the generated line and column information for the original source,</span><span class="s3">\n </span><span class="s1">* line, and column positions provided. The only argument is an object with</span><span class="s3">\n </span><span class="s1">* the following properties:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   - source: The filename of the original source.</span><span class="s3">\n </span><span class="s1">*   - line: The line number in the original source.  The line number</span><span class="s3">\n </span><span class="s1">*     is 1-based.</span><span class="s3">\n </span><span class="s1">*   - column: The column number in the original source.  The column</span><span class="s3">\n </span><span class="s1">*     number is 0-based.</span><span class="s3">\n </span><span class="s1">*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or</span><span class="s3">\n </span><span class="s1">*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the</span><span class="s3">\n </span><span class="s1">*     closest element that is smaller than or greater than the one we are</span><span class="s3">\n </span><span class="s1">*     searching for, respectively, if the exact element cannot be found.</span><span class="s3">\n </span><span class="s1">*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* and an object is returned with the following properties:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   - line: The line number in the generated source, or null.  The</span><span class="s3">\n </span><span class="s1">*     line number is 1-based.</span><span class="s3">\n </span><span class="s1">*   - column: The column number in the generated source, or null.</span><span class="s3">\n </span><span class="s1">*     The column number is 0-based.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">BasicSourceMapConsumer.prototype.generatedPositionFor =</span><span class="s3">\n  </span><span class="s1">function SourceMapConsumer_generatedPositionFor(aArgs) {</span><span class="s3">\n    </span><span class="s1">var source = util.getArg(aArgs, 'source');</span><span class="s3">\n    </span><span class="s1">source = this._findSourceIndex(source);</span><span class="s3">\n    </span><span class="s1">if (source &lt; 0) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">line: null,</span><span class="s3">\n        </span><span class="s1">column: null,</span><span class="s3">\n        </span><span class="s1">lastColumn: null</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var needle = {</span><span class="s3">\n      </span><span class="s1">source: source,</span><span class="s3">\n      </span><span class="s1">originalLine: util.getArg(aArgs, 'line'),</span><span class="s3">\n      </span><span class="s1">originalColumn: util.getArg(aArgs, 'column')</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">var index = this._findMapping(</span><span class="s3">\n      </span><span class="s1">needle,</span><span class="s3">\n      </span><span class="s1">this._originalMappings,</span><span class="s3">\n      \&quot;</span><span class="s1">originalLine</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      \&quot;</span><span class="s1">originalColumn</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">util.compareByOriginalPositions,</span><span class="s3">\n      </span><span class="s1">util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n      </span><span class="s1">var mapping = this._originalMappings[index];</span><span class="s3">\n\n      </span><span class="s1">if (mapping.source === needle.source) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">line: util.getArg(mapping, 'generatedLine', null),</span><span class="s3">\n          </span><span class="s1">column: util.getArg(mapping, 'generatedColumn', null),</span><span class="s3">\n          </span><span class="s1">lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">line: null,</span><span class="s3">\n      </span><span class="s1">column: null,</span><span class="s3">\n      </span><span class="s1">lastColumn: null</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">exports.BasicSourceMapConsumer = BasicSourceMapConsumer;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An IndexedSourceMapConsumer instance represents a parsed source map which</span><span class="s3">\n </span><span class="s1">* we can query for information. It differs from BasicSourceMapConsumer in</span><span class="s3">\n </span><span class="s1">* that it takes </span><span class="s3">\&quot;</span><span class="s1">indexed</span><span class="s3">\&quot; </span><span class="s1">source maps (i.e. ones with a </span><span class="s3">\&quot;</span><span class="s1">sections</span><span class="s3">\&quot; </span><span class="s1">field) as</span><span class="s3">\n </span><span class="s1">* input.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The first parameter is a raw source map (either as a JSON string, or already</span><span class="s3">\n </span><span class="s1">* parsed to an object). According to the spec for indexed source maps, they</span><span class="s3">\n </span><span class="s1">* have the following attributes:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   - version: Which version of the source map spec this map is following.</span><span class="s3">\n </span><span class="s1">*   - file: Optional. The generated file this source map is associated with.</span><span class="s3">\n </span><span class="s1">*   - sections: A list of section definitions.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Each value under the </span><span class="s3">\&quot;</span><span class="s1">sections</span><span class="s3">\&quot; </span><span class="s1">field has two fields:</span><span class="s3">\n </span><span class="s1">*   - offset: The offset into the original specified at which this section</span><span class="s3">\n </span><span class="s1">*       begins to apply, defined as an object with a </span><span class="s3">\&quot;</span><span class="s1">line</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">column</span><span class="s3">\&quot;\n </span><span class="s1">*       field.</span><span class="s3">\n </span><span class="s1">*   - map: A source map definition. This source map could also be indexed,</span><span class="s3">\n </span><span class="s1">*       but doesn't have to be.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Instead of the </span><span class="s3">\&quot;</span><span class="s1">map</span><span class="s3">\&quot; </span><span class="s1">field, it's also possible to have a </span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">field</span><span class="s3">\n </span><span class="s1">* specifying a URL to retrieve a source map from, but that's currently</span><span class="s3">\n </span><span class="s1">* unsupported.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Here's an example source map, taken from the source map spec[0], but</span><span class="s3">\n </span><span class="s1">* modified to omit a section which uses the </span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">field.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*  {</span><span class="s3">\n </span><span class="s1">*    version : 3,</span><span class="s3">\n </span><span class="s1">*    file: </span><span class="s3">\&quot;</span><span class="s1">app.js</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n </span><span class="s1">*    sections: [{</span><span class="s3">\n </span><span class="s1">*      offset: {line:100, column:10},</span><span class="s3">\n </span><span class="s1">*      map: {</span><span class="s3">\n </span><span class="s1">*        version : 3,</span><span class="s3">\n </span><span class="s1">*        file: </span><span class="s3">\&quot;</span><span class="s1">section.js</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n </span><span class="s1">*        sources: [</span><span class="s3">\&quot;</span><span class="s1">foo.js</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">bar.js</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n </span><span class="s1">*        names: [</span><span class="s3">\&quot;</span><span class="s1">src</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">maps</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">are</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">fun</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n </span><span class="s1">*        mappings: </span><span class="s3">\&quot;</span><span class="s1">AAAA,E;;ABCDE;</span><span class="s3">\&quot;\n </span><span class="s1">*      }</span><span class="s3">\n </span><span class="s1">*    }],</span><span class="s3">\n </span><span class="s1">*  }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The second parameter, if given, is a string whose value is the URL</span><span class="s3">\n </span><span class="s1">* at which the source map was found.  This URL is used to compute the</span><span class="s3">\n </span><span class="s1">* sources array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {</span><span class="s3">\n  </span><span class="s1">var sourceMap = aSourceMap;</span><span class="s3">\n  </span><span class="s1">if (typeof aSourceMap === 'string') {</span><span class="s3">\n    </span><span class="s1">sourceMap = util.parseSourceMapInput(aSourceMap);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var version = util.getArg(sourceMap, 'version');</span><span class="s3">\n  </span><span class="s1">var sections = util.getArg(sourceMap, 'sections');</span><span class="s3">\n\n  </span><span class="s1">if (version != this._version) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Unsupported version: ' + version);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this._sources = new ArraySet();</span><span class="s3">\n  </span><span class="s1">this._names = new ArraySet();</span><span class="s3">\n\n  </span><span class="s1">var lastOffset = {</span><span class="s3">\n    </span><span class="s1">line: -1,</span><span class="s3">\n    </span><span class="s1">column: 0</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">this._sections = sections.map(function (s) {</span><span class="s3">\n    </span><span class="s1">if (s.url) {</span><span class="s3">\n      </span><span class="s1">// The url field will require support for asynchronicity.</span><span class="s3">\n      </span><span class="s1">// See https://github.com/mozilla/source-map/issues/16</span><span class="s3">\n      </span><span class="s1">throw new Error('Support for url field in sections not implemented.');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var offset = util.getArg(s, 'offset');</span><span class="s3">\n    </span><span class="s1">var offsetLine = util.getArg(offset, 'line');</span><span class="s3">\n    </span><span class="s1">var offsetColumn = util.getArg(offset, 'column');</span><span class="s3">\n\n    </span><span class="s1">if (offsetLine &lt; lastOffset.line ||</span><span class="s3">\n        </span><span class="s1">(offsetLine === lastOffset.line &amp;&amp; offsetColumn &lt; lastOffset.column)) {</span><span class="s3">\n      </span><span class="s1">throw new Error('Section offsets must be ordered and non-overlapping.');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lastOffset = offset;</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">generatedOffset: {</span><span class="s3">\n        </span><span class="s1">// The offset fields are 0-based, but we use 1-based indices when</span><span class="s3">\n        </span><span class="s1">// encoding/decoding from VLQ.</span><span class="s3">\n        </span><span class="s1">generatedLine: offsetLine + 1,</span><span class="s3">\n        </span><span class="s1">generatedColumn: offsetColumn + 1</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);</span><span class="s3">\n</span><span class="s1">IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The version of the source mapping spec that we are consuming.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IndexedSourceMapConsumer.prototype._version = 3;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The list of original sources.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {</span><span class="s3">\n  </span><span class="s1">get: function () {</span><span class="s3">\n    </span><span class="s1">var sources = [];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this._sections.length; i++) {</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; this._sections[i].consumer.sources.length; j++) {</span><span class="s3">\n        </span><span class="s1">sources.push(this._sections[i].consumer.sources[j]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return sources;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the original source, line, and column information for the generated</span><span class="s3">\n </span><span class="s1">* source's line and column positions provided. The only argument is an object</span><span class="s3">\n </span><span class="s1">* with the following properties:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   - line: The line number in the generated source.  The line number</span><span class="s3">\n </span><span class="s1">*     is 1-based.</span><span class="s3">\n </span><span class="s1">*   - column: The column number in the generated source.  The column</span><span class="s3">\n </span><span class="s1">*     number is 0-based.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* and an object is returned with the following properties:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   - source: The original source file, or null.</span><span class="s3">\n </span><span class="s1">*   - line: The line number in the original source, or null.  The</span><span class="s3">\n </span><span class="s1">*     line number is 1-based.</span><span class="s3">\n </span><span class="s1">*   - column: The column number in the original source, or null.  The</span><span class="s3">\n </span><span class="s1">*     column number is 0-based.</span><span class="s3">\n </span><span class="s1">*   - name: The original identifier, or null.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IndexedSourceMapConsumer.prototype.originalPositionFor =</span><span class="s3">\n  </span><span class="s1">function IndexedSourceMapConsumer_originalPositionFor(aArgs) {</span><span class="s3">\n    </span><span class="s1">var needle = {</span><span class="s3">\n      </span><span class="s1">generatedLine: util.getArg(aArgs, 'line'),</span><span class="s3">\n      </span><span class="s1">generatedColumn: util.getArg(aArgs, 'column')</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// Find the section containing the generated position we're trying to map</span><span class="s3">\n    </span><span class="s1">// to an original position.</span><span class="s3">\n    </span><span class="s1">var sectionIndex = binarySearch.search(needle, this._sections,</span><span class="s3">\n      </span><span class="s1">function(needle, section) {</span><span class="s3">\n        </span><span class="s1">var cmp = needle.generatedLine - section.generatedOffset.generatedLine;</span><span class="s3">\n        </span><span class="s1">if (cmp) {</span><span class="s3">\n          </span><span class="s1">return cmp;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return (needle.generatedColumn -</span><span class="s3">\n                </span><span class="s1">section.generatedOffset.generatedColumn);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">var section = this._sections[sectionIndex];</span><span class="s3">\n\n    </span><span class="s1">if (!section) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">source: null,</span><span class="s3">\n        </span><span class="s1">line: null,</span><span class="s3">\n        </span><span class="s1">column: null,</span><span class="s3">\n        </span><span class="s1">name: null</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return section.consumer.originalPositionFor({</span><span class="s3">\n      </span><span class="s1">line: needle.generatedLine -</span><span class="s3">\n        </span><span class="s1">(section.generatedOffset.generatedLine - 1),</span><span class="s3">\n      </span><span class="s1">column: needle.generatedColumn -</span><span class="s3">\n        </span><span class="s1">(section.generatedOffset.generatedLine === needle.generatedLine</span><span class="s3">\n         </span><span class="s1">? section.generatedOffset.generatedColumn - 1</span><span class="s3">\n         </span><span class="s1">: 0),</span><span class="s3">\n      </span><span class="s1">bias: aArgs.bias</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Return true if we have the source content for every source in the source</span><span class="s3">\n </span><span class="s1">* map, false otherwise.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =</span><span class="s3">\n  </span><span class="s1">function IndexedSourceMapConsumer_hasContentsOfAllSources() {</span><span class="s3">\n    </span><span class="s1">return this._sections.every(function (s) {</span><span class="s3">\n      </span><span class="s1">return s.consumer.hasContentsOfAllSources();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the original source content. The only argument is the url of the</span><span class="s3">\n </span><span class="s1">* original source file. Returns null if no original source content is</span><span class="s3">\n </span><span class="s1">* available.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IndexedSourceMapConsumer.prototype.sourceContentFor =</span><span class="s3">\n  </span><span class="s1">function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this._sections.length; i++) {</span><span class="s3">\n      </span><span class="s1">var section = this._sections[i];</span><span class="s3">\n\n      </span><span class="s1">var content = section.consumer.sourceContentFor(aSource, true);</span><span class="s3">\n      </span><span class="s1">if (content) {</span><span class="s3">\n        </span><span class="s1">return content;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (nullOnMissing) {</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n      </span><span class="s1">throw new Error('</span><span class="s3">\&quot;</span><span class="s1">' + aSource + '</span><span class="s3">\&quot; </span><span class="s1">is not in the SourceMap.');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the generated line and column information for the original source,</span><span class="s3">\n </span><span class="s1">* line, and column positions provided. The only argument is an object with</span><span class="s3">\n </span><span class="s1">* the following properties:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   - source: The filename of the original source.</span><span class="s3">\n </span><span class="s1">*   - line: The line number in the original source.  The line number</span><span class="s3">\n </span><span class="s1">*     is 1-based.</span><span class="s3">\n </span><span class="s1">*   - column: The column number in the original source.  The column</span><span class="s3">\n </span><span class="s1">*     number is 0-based.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* and an object is returned with the following properties:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   - line: The line number in the generated source, or null.  The</span><span class="s3">\n </span><span class="s1">*     line number is 1-based. </span><span class="s3">\n </span><span class="s1">*   - column: The column number in the generated source, or null.</span><span class="s3">\n </span><span class="s1">*     The column number is 0-based.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IndexedSourceMapConsumer.prototype.generatedPositionFor =</span><span class="s3">\n  </span><span class="s1">function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this._sections.length; i++) {</span><span class="s3">\n      </span><span class="s1">var section = this._sections[i];</span><span class="s3">\n\n      </span><span class="s1">// Only consider this section if the requested source is in the list of</span><span class="s3">\n      </span><span class="s1">// sources of the consumer.</span><span class="s3">\n      </span><span class="s1">if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var generatedPosition = section.consumer.generatedPositionFor(aArgs);</span><span class="s3">\n      </span><span class="s1">if (generatedPosition) {</span><span class="s3">\n        </span><span class="s1">var ret = {</span><span class="s3">\n          </span><span class="s1">line: generatedPosition.line +</span><span class="s3">\n            </span><span class="s1">(section.generatedOffset.generatedLine - 1),</span><span class="s3">\n          </span><span class="s1">column: generatedPosition.column +</span><span class="s3">\n            </span><span class="s1">(section.generatedOffset.generatedLine === generatedPosition.line</span><span class="s3">\n             </span><span class="s1">? section.generatedOffset.generatedColumn - 1</span><span class="s3">\n             </span><span class="s1">: 0)</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">return ret;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">line: null,</span><span class="s3">\n      </span><span class="s1">column: null</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parse the mappings in a string in to a data structure which we can easily</span><span class="s3">\n </span><span class="s1">* query (the ordered arrays in the `this.__generatedMappings` and</span><span class="s3">\n </span><span class="s1">* `this.__originalMappings` properties).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IndexedSourceMapConsumer.prototype._parseMappings =</span><span class="s3">\n  </span><span class="s1">function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {</span><span class="s3">\n    </span><span class="s1">this.__generatedMappings = [];</span><span class="s3">\n    </span><span class="s1">this.__originalMappings = [];</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; this._sections.length; i++) {</span><span class="s3">\n      </span><span class="s1">var section = this._sections[i];</span><span class="s3">\n      </span><span class="s1">var sectionMappings = section.consumer._generatedMappings;</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; sectionMappings.length; j++) {</span><span class="s3">\n        </span><span class="s1">var mapping = sectionMappings[j];</span><span class="s3">\n\n        </span><span class="s1">var source = section.consumer._sources.at(mapping.source);</span><span class="s3">\n        </span><span class="s1">source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);</span><span class="s3">\n        </span><span class="s1">this._sources.add(source);</span><span class="s3">\n        </span><span class="s1">source = this._sources.indexOf(source);</span><span class="s3">\n\n        </span><span class="s1">var name = null;</span><span class="s3">\n        </span><span class="s1">if (mapping.name) {</span><span class="s3">\n          </span><span class="s1">name = section.consumer._names.at(mapping.name);</span><span class="s3">\n          </span><span class="s1">this._names.add(name);</span><span class="s3">\n          </span><span class="s1">name = this._names.indexOf(name);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// The mappings coming from the consumer for the section have</span><span class="s3">\n        </span><span class="s1">// generated positions relative to the start of the section, so we</span><span class="s3">\n        </span><span class="s1">// need to offset them to be relative to the start of the concatenated</span><span class="s3">\n        </span><span class="s1">// generated file.</span><span class="s3">\n        </span><span class="s1">var adjustedMapping = {</span><span class="s3">\n          </span><span class="s1">source: source,</span><span class="s3">\n          </span><span class="s1">generatedLine: mapping.generatedLine +</span><span class="s3">\n            </span><span class="s1">(section.generatedOffset.generatedLine - 1),</span><span class="s3">\n          </span><span class="s1">generatedColumn: mapping.generatedColumn +</span><span class="s3">\n            </span><span class="s1">(section.generatedOffset.generatedLine === mapping.generatedLine</span><span class="s3">\n            </span><span class="s1">? section.generatedOffset.generatedColumn - 1</span><span class="s3">\n            </span><span class="s1">: 0),</span><span class="s3">\n          </span><span class="s1">originalLine: mapping.originalLine,</span><span class="s3">\n          </span><span class="s1">originalColumn: mapping.originalColumn,</span><span class="s3">\n          </span><span class="s1">name: name</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n\n        </span><span class="s1">this.__generatedMappings.push(adjustedMapping);</span><span class="s3">\n        </span><span class="s1">if (typeof adjustedMapping.originalLine === 'number') {</span><span class="s3">\n          </span><span class="s1">this.__originalMappings.push(adjustedMapping);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);</span><span class="s3">\n    </span><span class="s1">quickSort(this.__originalMappings, util.compareByOriginalPositions);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;</span><span class="s3">\n\n\n\n</span><span class="s1">//////////////////</span><span class="s3">\n</span><span class="s1">// WEBPACK FOOTER</span><span class="s3">\n</span><span class="s1">// ./lib/source-map-consumer.js</span><span class="s3">\n</span><span class="s1">// module id = 7</span><span class="s3">\n</span><span class="s1">// module chunks = 0&quot;</span><span class="s0">,</span><span class="s1">&quot;/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">exports.GREATEST_LOWER_BOUND = 1;</span><span class="s3">\n</span><span class="s1">exports.LEAST_UPPER_BOUND = 2;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Recursive implementation of binary search.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param aLow Indices here and lower do not contain the needle.</span><span class="s3">\n </span><span class="s1">* @param aHigh Indices here and higher do not contain the needle.</span><span class="s3">\n </span><span class="s1">* @param aNeedle The element being searched for.</span><span class="s3">\n </span><span class="s1">* @param aHaystack The non-empty array being searched.</span><span class="s3">\n </span><span class="s1">* @param aCompare Function which takes two elements and returns -1, 0, or 1.</span><span class="s3">\n </span><span class="s1">* @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or</span><span class="s3">\n </span><span class="s1">*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the</span><span class="s3">\n </span><span class="s1">*     closest element that is smaller than or greater than the one we are</span><span class="s3">\n </span><span class="s1">*     searching for, respectively, if the exact element cannot be found.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {</span><span class="s3">\n  </span><span class="s1">// This function terminates when one of the following is true:</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//   1. We find the exact element we are looking for.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//   2. We did not find the exact element, but we can return the index of</span><span class="s3">\n  </span><span class="s1">//      the next-closest element.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//   3. We did not find the exact element, and there is no next-closest</span><span class="s3">\n  </span><span class="s1">//      element than the one we are searching for, so we return -1.</span><span class="s3">\n  </span><span class="s1">var mid = Math.floor((aHigh - aLow) / 2) + aLow;</span><span class="s3">\n  </span><span class="s1">var cmp = aCompare(aNeedle, aHaystack[mid], true);</span><span class="s3">\n  </span><span class="s1">if (cmp === 0) {</span><span class="s3">\n    </span><span class="s1">// Found the element we are looking for.</span><span class="s3">\n    </span><span class="s1">return mid;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">else if (cmp &gt; 0) {</span><span class="s3">\n    </span><span class="s1">// Our needle is greater than aHaystack[mid].</span><span class="s3">\n    </span><span class="s1">if (aHigh - mid &gt; 1) {</span><span class="s3">\n      </span><span class="s1">// The element is in the upper half.</span><span class="s3">\n      </span><span class="s1">return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// The exact needle element was not found in this haystack. Determine if</span><span class="s3">\n    </span><span class="s1">// we are in termination case (3) or (2) and return the appropriate thing.</span><span class="s3">\n    </span><span class="s1">if (aBias == exports.LEAST_UPPER_BOUND) {</span><span class="s3">\n      </span><span class="s1">return aHigh &lt; aHaystack.length ? aHigh : -1;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return mid;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">else {</span><span class="s3">\n    </span><span class="s1">// Our needle is less than aHaystack[mid].</span><span class="s3">\n    </span><span class="s1">if (mid - aLow &gt; 1) {</span><span class="s3">\n      </span><span class="s1">// The element is in the lower half.</span><span class="s3">\n      </span><span class="s1">return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// we are in termination case (3) or (2) and return the appropriate thing.</span><span class="s3">\n    </span><span class="s1">if (aBias == exports.LEAST_UPPER_BOUND) {</span><span class="s3">\n      </span><span class="s1">return mid;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return aLow &lt; 0 ? -1 : aLow;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This is an implementation of binary search which will always try and return</span><span class="s3">\n </span><span class="s1">* the index of the closest element if there is no exact hit. This is because</span><span class="s3">\n </span><span class="s1">* mappings between original and generated line/col pairs are single points,</span><span class="s3">\n </span><span class="s1">* and there is an implicit region between each of them, so a miss just means</span><span class="s3">\n </span><span class="s1">* that you aren't on the very start of a region.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param aNeedle The element you are looking for.</span><span class="s3">\n </span><span class="s1">* @param aHaystack The array that is being searched.</span><span class="s3">\n </span><span class="s1">* @param aCompare A function which takes the needle and an element in the</span><span class="s3">\n </span><span class="s1">*     array and returns -1, 0, or 1 depending on whether the needle is less</span><span class="s3">\n </span><span class="s1">*     than, equal to, or greater than the element, respectively.</span><span class="s3">\n </span><span class="s1">* @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or</span><span class="s3">\n </span><span class="s1">*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the</span><span class="s3">\n </span><span class="s1">*     closest element that is smaller than or greater than the one we are</span><span class="s3">\n </span><span class="s1">*     searching for, respectively, if the exact element cannot be found.</span><span class="s3">\n </span><span class="s1">*     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {</span><span class="s3">\n  </span><span class="s1">if (aHaystack.length === 0) {</span><span class="s3">\n    </span><span class="s1">return -1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,</span><span class="s3">\n                              </span><span class="s1">aCompare, aBias || exports.GREATEST_LOWER_BOUND);</span><span class="s3">\n  </span><span class="s1">if (index &lt; 0) {</span><span class="s3">\n    </span><span class="s1">return -1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We have found either the exact element, or the next-closest element than</span><span class="s3">\n  </span><span class="s1">// the one we are searching for. However, there may be more than one such</span><span class="s3">\n  </span><span class="s1">// element. Make sure we always return the smallest of these.</span><span class="s3">\n  </span><span class="s1">while (index - 1 &gt;= 0) {</span><span class="s3">\n    </span><span class="s1">if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">--index;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n\n\n</span><span class="s1">//////////////////</span><span class="s3">\n</span><span class="s1">// WEBPACK FOOTER</span><span class="s3">\n</span><span class="s1">// ./lib/binary-search.js</span><span class="s3">\n</span><span class="s1">// module id = 8</span><span class="s3">\n</span><span class="s1">// module chunks = 0&quot;</span><span class="s0">,</span><span class="s1">&quot;/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">// It turns out that some (most?) JavaScript engines don't self-host</span><span class="s3">\n</span><span class="s1">// `Array.prototype.sort`. This makes sense because C++ will likely remain</span><span class="s3">\n</span><span class="s1">// faster than JS when doing raw CPU-intensive sorting. However, when using a</span><span class="s3">\n</span><span class="s1">// custom comparator function, calling back and forth between the VM's C++ and</span><span class="s3">\n</span><span class="s1">// JIT'd JS is rather slow *and* loses JIT type information, resulting in</span><span class="s3">\n</span><span class="s1">// worse generated code for the comparator function than would be optimal. In</span><span class="s3">\n</span><span class="s1">// fact, when sorting with a comparator, these costs outweigh the benefits of</span><span class="s3">\n</span><span class="s1">// sorting in C++. By using our own JS-implemented Quick Sort (below), we get</span><span class="s3">\n</span><span class="s1">// a ~3500ms mean speed-up in `bench/bench.html`.</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Swap the elements indexed by `x` and `y` in the array `ary`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Array} ary</span><span class="s3">\n </span><span class="s1">*        The array.</span><span class="s3">\n </span><span class="s1">* @param {Number} x</span><span class="s3">\n </span><span class="s1">*        The index of the first item.</span><span class="s3">\n </span><span class="s1">* @param {Number} y</span><span class="s3">\n </span><span class="s1">*        The index of the second item.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function swap(ary, x, y) {</span><span class="s3">\n  </span><span class="s1">var temp = ary[x];</span><span class="s3">\n  </span><span class="s1">ary[x] = ary[y];</span><span class="s3">\n  </span><span class="s1">ary[y] = temp;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a random integer within the range `low .. high` inclusive.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Number} low</span><span class="s3">\n </span><span class="s1">*        The lower bound on the range.</span><span class="s3">\n </span><span class="s1">* @param {Number} high</span><span class="s3">\n </span><span class="s1">*        The upper bound on the range.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function randomIntInRange(low, high) {</span><span class="s3">\n  </span><span class="s1">return Math.round(low + (Math.random() * (high - low)));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The Quick Sort algorithm.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Array} ary</span><span class="s3">\n </span><span class="s1">*        An array to sort.</span><span class="s3">\n </span><span class="s1">* @param {function} comparator</span><span class="s3">\n </span><span class="s1">*        Function to use to compare two items.</span><span class="s3">\n </span><span class="s1">* @param {Number} p</span><span class="s3">\n </span><span class="s1">*        Start index of the array</span><span class="s3">\n </span><span class="s1">* @param {Number} r</span><span class="s3">\n </span><span class="s1">*        End index of the array</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function doQuickSort(ary, comparator, p, r) {</span><span class="s3">\n  </span><span class="s1">// If our lower bound is less than our upper bound, we (1) partition the</span><span class="s3">\n  </span><span class="s1">// array into two pieces and (2) recurse on each half. If it is not, this is</span><span class="s3">\n  </span><span class="s1">// the empty array and our base case.</span><span class="s3">\n\n  </span><span class="s1">if (p &lt; r) {</span><span class="s3">\n    </span><span class="s1">// (1) Partitioning.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// The partitioning chooses a pivot between `p` and `r` and moves all</span><span class="s3">\n    </span><span class="s1">// elements that are less than or equal to the pivot to the before it, and</span><span class="s3">\n    </span><span class="s1">// all the elements that are greater than it after it. The effect is that</span><span class="s3">\n    </span><span class="s1">// once partition is done, the pivot is in the exact place it will be when</span><span class="s3">\n    </span><span class="s1">// the array is put in sorted order, and it will not need to be moved</span><span class="s3">\n    </span><span class="s1">// again. This runs in O(n) time.</span><span class="s3">\n\n    </span><span class="s1">// Always choose a random pivot so that an input array which is reverse</span><span class="s3">\n    </span><span class="s1">// sorted does not cause O(n^2) running time.</span><span class="s3">\n    </span><span class="s1">var pivotIndex = randomIntInRange(p, r);</span><span class="s3">\n    </span><span class="s1">var i = p - 1;</span><span class="s3">\n\n    </span><span class="s1">swap(ary, pivotIndex, r);</span><span class="s3">\n    </span><span class="s1">var pivot = ary[r];</span><span class="s3">\n\n    </span><span class="s1">// Immediately after `j` is incremented in this loop, the following hold</span><span class="s3">\n    </span><span class="s1">// true:</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">//   * Every element in `ary[p .. i]` is less than or equal to the pivot.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">//   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.</span><span class="s3">\n    </span><span class="s1">for (var j = p; j &lt; r; j++) {</span><span class="s3">\n      </span><span class="s1">if (comparator(ary[j], pivot) &lt;= 0) {</span><span class="s3">\n        </span><span class="s1">i += 1;</span><span class="s3">\n        </span><span class="s1">swap(ary, i, j);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">swap(ary, i + 1, j);</span><span class="s3">\n    </span><span class="s1">var q = i + 1;</span><span class="s3">\n\n    </span><span class="s1">// (2) Recurse on each half.</span><span class="s3">\n\n    </span><span class="s1">doQuickSort(ary, comparator, p, q - 1);</span><span class="s3">\n    </span><span class="s1">doQuickSort(ary, comparator, q + 1, r);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sort the given array in-place with the given comparator function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Array} ary</span><span class="s3">\n </span><span class="s1">*        An array to sort.</span><span class="s3">\n </span><span class="s1">* @param {function} comparator</span><span class="s3">\n </span><span class="s1">*        Function to use to compare two items.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">exports.quickSort = function (ary, comparator) {</span><span class="s3">\n  </span><span class="s1">doQuickSort(ary, comparator, 0, ary.length - 1);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n\n\n</span><span class="s1">//////////////////</span><span class="s3">\n</span><span class="s1">// WEBPACK FOOTER</span><span class="s3">\n</span><span class="s1">// ./lib/quick-sort.js</span><span class="s3">\n</span><span class="s1">// module id = 9</span><span class="s3">\n</span><span class="s1">// module chunks = 0&quot;</span><span class="s0">,</span><span class="s1">&quot;/* -*- Mode: js; js-indent-level: 2; -*- */</span><span class="s3">\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Copyright 2011 Mozilla Foundation and contributors</span><span class="s3">\n </span><span class="s1">* Licensed under the New BSD license. See LICENSE or:</span><span class="s3">\n </span><span class="s1">* http://opensource.org/licenses/BSD-3-Clause</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;</span><span class="s3">\n</span><span class="s1">var util = require('./util');</span><span class="s3">\n\n</span><span class="s1">// Matches a Windows-style `</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n` newline or a `</span><span class="s3">\\</span><span class="s1">n` newline used by all other</span><span class="s3">\n</span><span class="s1">// operating systems these days (capturing the result).</span><span class="s3">\n</span><span class="s1">var REGEX_NEWLINE = /(</span><span class="s3">\\</span><span class="s1">r?</span><span class="s3">\\</span><span class="s1">n)/;</span><span class="s3">\n\n</span><span class="s1">// Newline character code for charCodeAt() comparisons</span><span class="s3">\n</span><span class="s1">var NEWLINE_CODE = 10;</span><span class="s3">\n\n</span><span class="s1">// Private symbol for identifying `SourceNode`s when multiple versions of</span><span class="s3">\n</span><span class="s1">// the source-map library are loaded. This MUST NOT CHANGE across</span><span class="s3">\n</span><span class="s1">// versions!</span><span class="s3">\n</span><span class="s1">var isSourceNode = </span><span class="s3">\&quot;</span><span class="s1">$$$isSourceNode$$$</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* SourceNodes provide a way to abstract over interpolating/concatenating</span><span class="s3">\n </span><span class="s1">* snippets of generated JavaScript source code while maintaining the line and</span><span class="s3">\n </span><span class="s1">* column information associated with the original source code.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param aLine The original line number.</span><span class="s3">\n </span><span class="s1">* @param aColumn The original column number.</span><span class="s3">\n </span><span class="s1">* @param aSource The original source's filename.</span><span class="s3">\n </span><span class="s1">* @param aChunks Optional. An array of strings which are snippets of</span><span class="s3">\n </span><span class="s1">*        generated JS, or other SourceNodes.</span><span class="s3">\n </span><span class="s1">* @param aName The original identifier.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function SourceNode(aLine, aColumn, aSource, aChunks, aName) {</span><span class="s3">\n  </span><span class="s1">this.children = [];</span><span class="s3">\n  </span><span class="s1">this.sourceContents = {};</span><span class="s3">\n  </span><span class="s1">this.line = aLine == null ? null : aLine;</span><span class="s3">\n  </span><span class="s1">this.column = aColumn == null ? null : aColumn;</span><span class="s3">\n  </span><span class="s1">this.source = aSource == null ? null : aSource;</span><span class="s3">\n  </span><span class="s1">this.name = aName == null ? null : aName;</span><span class="s3">\n  </span><span class="s1">this[isSourceNode] = true;</span><span class="s3">\n  </span><span class="s1">if (aChunks != null) this.add(aChunks);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a SourceNode from generated code and a SourceMapConsumer.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param aGeneratedCode The generated code</span><span class="s3">\n </span><span class="s1">* @param aSourceMapConsumer The SourceMap for the generated code</span><span class="s3">\n </span><span class="s1">* @param aRelativePath Optional. The path that relative sources in the</span><span class="s3">\n </span><span class="s1">*        SourceMapConsumer should be relative to.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceNode.fromStringWithSourceMap =</span><span class="s3">\n  </span><span class="s1">function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {</span><span class="s3">\n    </span><span class="s1">// The SourceNode we want to fill with the generated code</span><span class="s3">\n    </span><span class="s1">// and the SourceMap</span><span class="s3">\n    </span><span class="s1">var node = new SourceNode();</span><span class="s3">\n\n    </span><span class="s1">// All even indices of this array are one line of the generated code,</span><span class="s3">\n    </span><span class="s1">// while all odd indices are the newlines between two adjacent lines</span><span class="s3">\n    </span><span class="s1">// (since `REGEX_NEWLINE` captures its match).</span><span class="s3">\n    </span><span class="s1">// Processed fragments are accessed by calling `shiftNextLine`.</span><span class="s3">\n    </span><span class="s1">var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);</span><span class="s3">\n    </span><span class="s1">var remainingLinesIndex = 0;</span><span class="s3">\n    </span><span class="s1">var shiftNextLine = function() {</span><span class="s3">\n      </span><span class="s1">var lineContents = getNextLine();</span><span class="s3">\n      </span><span class="s1">// The last line of a file might not have a newline.</span><span class="s3">\n      </span><span class="s1">var newLine = getNextLine() || </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">return lineContents + newLine;</span><span class="s3">\n\n      </span><span class="s1">function getNextLine() {</span><span class="s3">\n        </span><span class="s1">return remainingLinesIndex &lt; remainingLines.length ?</span><span class="s3">\n            </span><span class="s1">remainingLines[remainingLinesIndex++] : undefined;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// We need to remember the position of </span><span class="s3">\&quot;</span><span class="s1">remainingLines</span><span class="s3">\&quot;\n    </span><span class="s1">var lastGeneratedLine = 1, lastGeneratedColumn = 0;</span><span class="s3">\n\n    </span><span class="s1">// The generate SourceNodes we need a code range.</span><span class="s3">\n    </span><span class="s1">// To extract it current and last mapping is used.</span><span class="s3">\n    </span><span class="s1">// Here we store the last mapping.</span><span class="s3">\n    </span><span class="s1">var lastMapping = null;</span><span class="s3">\n\n    </span><span class="s1">aSourceMapConsumer.eachMapping(function (mapping) {</span><span class="s3">\n      </span><span class="s1">if (lastMapping !== null) {</span><span class="s3">\n        </span><span class="s1">// We add the code from </span><span class="s3">\&quot;</span><span class="s1">lastMapping</span><span class="s3">\&quot; </span><span class="s1">to </span><span class="s3">\&quot;</span><span class="s1">mapping</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">// First check if there is a new line in between.</span><span class="s3">\n        </span><span class="s1">if (lastGeneratedLine &lt; mapping.generatedLine) {</span><span class="s3">\n          </span><span class="s1">// Associate first line with </span><span class="s3">\&quot;</span><span class="s1">lastMapping</span><span class="s3">\&quot;\n          </span><span class="s1">addMappingWithCode(lastMapping, shiftNextLine());</span><span class="s3">\n          </span><span class="s1">lastGeneratedLine++;</span><span class="s3">\n          </span><span class="s1">lastGeneratedColumn = 0;</span><span class="s3">\n          </span><span class="s1">// The remaining code is added without mapping</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// There is no new line in between.</span><span class="s3">\n          </span><span class="s1">// Associate the code between </span><span class="s3">\&quot;</span><span class="s1">lastGeneratedColumn</span><span class="s3">\&quot; </span><span class="s1">and</span><span class="s3">\n          </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">mapping.generatedColumn</span><span class="s3">\&quot; </span><span class="s1">with </span><span class="s3">\&quot;</span><span class="s1">lastMapping</span><span class="s3">\&quot;\n          </span><span class="s1">var nextLine = remainingLines[remainingLinesIndex] || '';</span><span class="s3">\n          </span><span class="s1">var code = nextLine.substr(0, mapping.generatedColumn -</span><span class="s3">\n                                        </span><span class="s1">lastGeneratedColumn);</span><span class="s3">\n          </span><span class="s1">remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -</span><span class="s3">\n                                              </span><span class="s1">lastGeneratedColumn);</span><span class="s3">\n          </span><span class="s1">lastGeneratedColumn = mapping.generatedColumn;</span><span class="s3">\n          </span><span class="s1">addMappingWithCode(lastMapping, code);</span><span class="s3">\n          </span><span class="s1">// No more remaining code, continue</span><span class="s3">\n          </span><span class="s1">lastMapping = mapping;</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// We add the generated code until the first mapping</span><span class="s3">\n      </span><span class="s1">// to the SourceNode without any mapping.</span><span class="s3">\n      </span><span class="s1">// Each line is added as separate string.</span><span class="s3">\n      </span><span class="s1">while (lastGeneratedLine &lt; mapping.generatedLine) {</span><span class="s3">\n        </span><span class="s1">node.add(shiftNextLine());</span><span class="s3">\n        </span><span class="s1">lastGeneratedLine++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (lastGeneratedColumn &lt; mapping.generatedColumn) {</span><span class="s3">\n        </span><span class="s1">var nextLine = remainingLines[remainingLinesIndex] || '';</span><span class="s3">\n        </span><span class="s1">node.add(nextLine.substr(0, mapping.generatedColumn));</span><span class="s3">\n        </span><span class="s1">remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);</span><span class="s3">\n        </span><span class="s1">lastGeneratedColumn = mapping.generatedColumn;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">lastMapping = mapping;</span><span class="s3">\n    </span><span class="s1">}, this);</span><span class="s3">\n    </span><span class="s1">// We have processed all mappings.</span><span class="s3">\n    </span><span class="s1">if (remainingLinesIndex &lt; remainingLines.length) {</span><span class="s3">\n      </span><span class="s1">if (lastMapping) {</span><span class="s3">\n        </span><span class="s1">// Associate the remaining code in the current line with </span><span class="s3">\&quot;</span><span class="s1">lastMapping</span><span class="s3">\&quot;\n        </span><span class="s1">addMappingWithCode(lastMapping, shiftNextLine());</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// and add the remaining lines without any mapping</span><span class="s3">\n      </span><span class="s1">node.add(remainingLines.splice(remainingLinesIndex).join(</span><span class="s3">\&quot;\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Copy sourcesContent into SourceNode</span><span class="s3">\n    </span><span class="s1">aSourceMapConsumer.sources.forEach(function (sourceFile) {</span><span class="s3">\n      </span><span class="s1">var content = aSourceMapConsumer.sourceContentFor(sourceFile);</span><span class="s3">\n      </span><span class="s1">if (content != null) {</span><span class="s3">\n        </span><span class="s1">if (aRelativePath != null) {</span><span class="s3">\n          </span><span class="s1">sourceFile = util.join(aRelativePath, sourceFile);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">node.setSourceContent(sourceFile, content);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">return node;</span><span class="s3">\n\n    </span><span class="s1">function addMappingWithCode(mapping, code) {</span><span class="s3">\n      </span><span class="s1">if (mapping === null || mapping.source === undefined) {</span><span class="s3">\n        </span><span class="s1">node.add(code);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var source = aRelativePath</span><span class="s3">\n          </span><span class="s1">? util.join(aRelativePath, mapping.source)</span><span class="s3">\n          </span><span class="s1">: mapping.source;</span><span class="s3">\n        </span><span class="s1">node.add(new SourceNode(mapping.originalLine,</span><span class="s3">\n                                </span><span class="s1">mapping.originalColumn,</span><span class="s3">\n                                </span><span class="s1">source,</span><span class="s3">\n                                </span><span class="s1">code,</span><span class="s3">\n                                </span><span class="s1">mapping.name));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Add a chunk of generated JS to this source node.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param aChunk A string snippet of generated JS code, another instance of</span><span class="s3">\n </span><span class="s1">*        SourceNode, or an array where each member is one of those things.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceNode.prototype.add = function SourceNode_add(aChunk) {</span><span class="s3">\n  </span><span class="s1">if (Array.isArray(aChunk)) {</span><span class="s3">\n    </span><span class="s1">aChunk.forEach(function (chunk) {</span><span class="s3">\n      </span><span class="s1">this.add(chunk);</span><span class="s3">\n    </span><span class="s1">}, this);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">else if (aChunk[isSourceNode] || typeof aChunk === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (aChunk) {</span><span class="s3">\n      </span><span class="s1">this.children.push(aChunk);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">else {</span><span class="s3">\n    </span><span class="s1">throw new TypeError(</span><span class="s3">\n      \&quot;</span><span class="s1">Expected a SourceNode, string, or an array of SourceNodes and strings. Got </span><span class="s3">\&quot; </span><span class="s1">+ aChunk</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Add a chunk of generated JS to the beginning of this source node.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param aChunk A string snippet of generated JS code, another instance of</span><span class="s3">\n </span><span class="s1">*        SourceNode, or an array where each member is one of those things.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {</span><span class="s3">\n  </span><span class="s1">if (Array.isArray(aChunk)) {</span><span class="s3">\n    </span><span class="s1">for (var i = aChunk.length-1; i &gt;= 0; i--) {</span><span class="s3">\n      </span><span class="s1">this.prepend(aChunk[i]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">else if (aChunk[isSourceNode] || typeof aChunk === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.children.unshift(aChunk);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">else {</span><span class="s3">\n    </span><span class="s1">throw new TypeError(</span><span class="s3">\n      \&quot;</span><span class="s1">Expected a SourceNode, string, or an array of SourceNodes and strings. Got </span><span class="s3">\&quot; </span><span class="s1">+ aChunk</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Walk over the tree of JS snippets in this node and its children. The</span><span class="s3">\n </span><span class="s1">* walking function is called once for each snippet of JS and is passed that</span><span class="s3">\n </span><span class="s1">* snippet and the its original associated source's line/column location.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param aFn The traversal function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceNode.prototype.walk = function SourceNode_walk(aFn) {</span><span class="s3">\n  </span><span class="s1">var chunk;</span><span class="s3">\n  </span><span class="s1">for (var i = 0, len = this.children.length; i &lt; len; i++) {</span><span class="s3">\n    </span><span class="s1">chunk = this.children[i];</span><span class="s3">\n    </span><span class="s1">if (chunk[isSourceNode]) {</span><span class="s3">\n      </span><span class="s1">chunk.walk(aFn);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n      </span><span class="s1">if (chunk !== '') {</span><span class="s3">\n        </span><span class="s1">aFn(chunk, { source: this.source,</span><span class="s3">\n                     </span><span class="s1">line: this.line,</span><span class="s3">\n                     </span><span class="s1">column: this.column,</span><span class="s3">\n                     </span><span class="s1">name: this.name });</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between</span><span class="s3">\n </span><span class="s1">* each of `this.children`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param aSep The separator.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceNode.prototype.join = function SourceNode_join(aSep) {</span><span class="s3">\n  </span><span class="s1">var newChildren;</span><span class="s3">\n  </span><span class="s1">var i;</span><span class="s3">\n  </span><span class="s1">var len = this.children.length;</span><span class="s3">\n  </span><span class="s1">if (len &gt; 0) {</span><span class="s3">\n    </span><span class="s1">newChildren = [];</span><span class="s3">\n    </span><span class="s1">for (i = 0; i &lt; len-1; i++) {</span><span class="s3">\n      </span><span class="s1">newChildren.push(this.children[i]);</span><span class="s3">\n      </span><span class="s1">newChildren.push(aSep);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">newChildren.push(this.children[i]);</span><span class="s3">\n    </span><span class="s1">this.children = newChildren;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Call String.prototype.replace on the very right-most source snippet. Useful</span><span class="s3">\n </span><span class="s1">* for trimming whitespace from the end of a source node, etc.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param aPattern The pattern to replace.</span><span class="s3">\n </span><span class="s1">* @param aReplacement The thing to replace the pattern with.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {</span><span class="s3">\n  </span><span class="s1">var lastChild = this.children[this.children.length - 1];</span><span class="s3">\n  </span><span class="s1">if (lastChild[isSourceNode]) {</span><span class="s3">\n    </span><span class="s1">lastChild.replaceRight(aPattern, aReplacement);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">else if (typeof lastChild === 'string') {</span><span class="s3">\n    </span><span class="s1">this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">else {</span><span class="s3">\n    </span><span class="s1">this.children.push(''.replace(aPattern, aReplacement));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Set the source content for a source file. This will be added to the SourceMapGenerator</span><span class="s3">\n </span><span class="s1">* in the sourcesContent field.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param aSourceFile The filename of the source file</span><span class="s3">\n </span><span class="s1">* @param aSourceContent The content of the source file</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceNode.prototype.setSourceContent =</span><span class="s3">\n  </span><span class="s1">function SourceNode_setSourceContent(aSourceFile, aSourceContent) {</span><span class="s3">\n    </span><span class="s1">this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Walk over the tree of SourceNodes. The walking function is called for each</span><span class="s3">\n </span><span class="s1">* source file content and is passed the filename and source content.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param aFn The traversal function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceNode.prototype.walkSourceContents =</span><span class="s3">\n  </span><span class="s1">function SourceNode_walkSourceContents(aFn) {</span><span class="s3">\n    </span><span class="s1">for (var i = 0, len = this.children.length; i &lt; len; i++) {</span><span class="s3">\n      </span><span class="s1">if (this.children[i][isSourceNode]) {</span><span class="s3">\n        </span><span class="s1">this.children[i].walkSourceContents(aFn);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var sources = Object.keys(this.sourceContents);</span><span class="s3">\n    </span><span class="s1">for (var i = 0, len = sources.length; i &lt; len; i++) {</span><span class="s3">\n      </span><span class="s1">aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Return the string representation of this source node. Walks over the tree</span><span class="s3">\n </span><span class="s1">* and concatenates all the various snippets together to one string.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceNode.prototype.toString = function SourceNode_toString() {</span><span class="s3">\n  </span><span class="s1">var str = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">this.walk(function (chunk) {</span><span class="s3">\n    </span><span class="s1">str += chunk;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return str;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the string representation of this source node along with a source</span><span class="s3">\n </span><span class="s1">* map.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {</span><span class="s3">\n  </span><span class="s1">var generated = {</span><span class="s3">\n    </span><span class="s1">code: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">line: 1,</span><span class="s3">\n    </span><span class="s1">column: 0</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var map = new SourceMapGenerator(aArgs);</span><span class="s3">\n  </span><span class="s1">var sourceMappingActive = false;</span><span class="s3">\n  </span><span class="s1">var lastOriginalSource = null;</span><span class="s3">\n  </span><span class="s1">var lastOriginalLine = null;</span><span class="s3">\n  </span><span class="s1">var lastOriginalColumn = null;</span><span class="s3">\n  </span><span class="s1">var lastOriginalName = null;</span><span class="s3">\n  </span><span class="s1">this.walk(function (chunk, original) {</span><span class="s3">\n    </span><span class="s1">generated.code += chunk;</span><span class="s3">\n    </span><span class="s1">if (original.source !== null</span><span class="s3">\n        </span><span class="s1">&amp;&amp; original.line !== null</span><span class="s3">\n        </span><span class="s1">&amp;&amp; original.column !== null) {</span><span class="s3">\n      </span><span class="s1">if(lastOriginalSource !== original.source</span><span class="s3">\n         </span><span class="s1">|| lastOriginalLine !== original.line</span><span class="s3">\n         </span><span class="s1">|| lastOriginalColumn !== original.column</span><span class="s3">\n         </span><span class="s1">|| lastOriginalName !== original.name) {</span><span class="s3">\n        </span><span class="s1">map.addMapping({</span><span class="s3">\n          </span><span class="s1">source: original.source,</span><span class="s3">\n          </span><span class="s1">original: {</span><span class="s3">\n            </span><span class="s1">line: original.line,</span><span class="s3">\n            </span><span class="s1">column: original.column</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">generated: {</span><span class="s3">\n            </span><span class="s1">line: generated.line,</span><span class="s3">\n            </span><span class="s1">column: generated.column</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">name: original.name</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">lastOriginalSource = original.source;</span><span class="s3">\n      </span><span class="s1">lastOriginalLine = original.line;</span><span class="s3">\n      </span><span class="s1">lastOriginalColumn = original.column;</span><span class="s3">\n      </span><span class="s1">lastOriginalName = original.name;</span><span class="s3">\n      </span><span class="s1">sourceMappingActive = true;</span><span class="s3">\n    </span><span class="s1">} else if (sourceMappingActive) {</span><span class="s3">\n      </span><span class="s1">map.addMapping({</span><span class="s3">\n        </span><span class="s1">generated: {</span><span class="s3">\n          </span><span class="s1">line: generated.line,</span><span class="s3">\n          </span><span class="s1">column: generated.column</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">lastOriginalSource = null;</span><span class="s3">\n      </span><span class="s1">sourceMappingActive = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var idx = 0, length = chunk.length; idx &lt; length; idx++) {</span><span class="s3">\n      </span><span class="s1">if (chunk.charCodeAt(idx) === NEWLINE_CODE) {</span><span class="s3">\n        </span><span class="s1">generated.line++;</span><span class="s3">\n        </span><span class="s1">generated.column = 0;</span><span class="s3">\n        </span><span class="s1">// Mappings end at eol</span><span class="s3">\n        </span><span class="s1">if (idx + 1 === length) {</span><span class="s3">\n          </span><span class="s1">lastOriginalSource = null;</span><span class="s3">\n          </span><span class="s1">sourceMappingActive = false;</span><span class="s3">\n        </span><span class="s1">} else if (sourceMappingActive) {</span><span class="s3">\n          </span><span class="s1">map.addMapping({</span><span class="s3">\n            </span><span class="s1">source: original.source,</span><span class="s3">\n            </span><span class="s1">original: {</span><span class="s3">\n              </span><span class="s1">line: original.line,</span><span class="s3">\n              </span><span class="s1">column: original.column</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">generated: {</span><span class="s3">\n              </span><span class="s1">line: generated.line,</span><span class="s3">\n              </span><span class="s1">column: generated.column</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">name: original.name</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">generated.column++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">this.walkSourceContents(function (sourceFile, sourceContent) {</span><span class="s3">\n    </span><span class="s1">map.setSourceContent(sourceFile, sourceContent);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return { code: generated.code, map: map };</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">exports.SourceNode = SourceNode;</span><span class="s3">\n\n\n\n</span><span class="s1">//////////////////</span><span class="s3">\n</span><span class="s1">// WEBPACK FOOTER</span><span class="s3">\n</span><span class="s1">// ./lib/source-node.js</span><span class="s3">\n</span><span class="s1">// module id = 10</span><span class="s3">\n</span><span class="s1">// module chunks = 0&quot;</span><span class="s0">],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>