<html>
<head>
<title>cipherModes.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #67a37c; font-style: italic;}
.s2 { color: #bcbec4;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #7a7e85;}
.s7 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cipherModes.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Supported cipher modes.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Dave Longley</span>
 <span class="s0">*</span>
 <span class="s0">* Copyright (c) 2010-2014 Digital Bazaar, Inc.</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">forge </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s5">'./forge'</span><span class="s4">);</span>
<span class="s2">require</span><span class="s4">(</span><span class="s5">'./util'</span><span class="s4">);</span>

<span class="s2">forge</span><span class="s4">.</span><span class="s2">cipher </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">cipher </span><span class="s4">|| {};</span>

<span class="s6">// supported cipher modes</span>
<span class="s3">var </span><span class="s2">modes </span><span class="s4">= </span><span class="s2">module</span><span class="s4">.</span><span class="s2">exports </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">modes </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">modes </span><span class="s4">|| {};</span>

<span class="s0">/** Electronic codebook (ECB) (Don't use this; it's not secure) **/</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">ecb </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s2">options </span><span class="s4">= </span><span class="s2">options </span><span class="s4">|| {};</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">name </span><span class="s4">= </span><span class="s5">'ECB'</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">|| </span><span class="s7">16</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_ints </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">/ </span><span class="s7">4</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">);</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">);</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">ecb</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">start </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">options</span><span class="s4">) {};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">ecb</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">encrypt </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">input</span><span class="s4">, </span><span class="s2">output</span><span class="s4">, </span><span class="s2">finish</span><span class="s4">) {</span>
  <span class="s6">// not enough input to encrypt</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() &lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">&amp;&amp; !(</span><span class="s2">finish </span><span class="s4">&amp;&amp; </span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() &gt; </span><span class="s7">0</span><span class="s4">)) {</span>
    <span class="s3">return true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// get next block</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">();</span>
  <span class="s4">}</span>

  <span class="s6">// encrypt block</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">encrypt</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">);</span>

  <span class="s6">// write output</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s2">output</span><span class="s4">.</span><span class="s2">putInt32</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
  <span class="s4">}</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">ecb</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">decrypt </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">input</span><span class="s4">, </span><span class="s2">output</span><span class="s4">, </span><span class="s2">finish</span><span class="s4">) {</span>
  <span class="s6">// not enough input to decrypt</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() &lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">&amp;&amp; !(</span><span class="s2">finish </span><span class="s4">&amp;&amp; </span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() &gt; </span><span class="s7">0</span><span class="s4">)) {</span>
    <span class="s3">return true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// get next block</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">();</span>
  <span class="s4">}</span>

  <span class="s6">// decrypt block</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">decrypt</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">);</span>

  <span class="s6">// write output</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s2">output</span><span class="s4">.</span><span class="s2">putInt32</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
  <span class="s4">}</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">ecb</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">pad </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">input</span><span class="s4">, </span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s6">// add PKCS#7 padding to block (each pad byte is the</span>
  <span class="s6">// value of the number of pad bytes)</span>
  <span class="s3">var </span><span class="s2">padding </span><span class="s4">= (</span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() === </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">?</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">: (</span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">- </span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">()));</span>
  <span class="s2">input</span><span class="s4">.</span><span class="s2">fillWithByte</span><span class="s4">(</span><span class="s2">padding</span><span class="s4">, </span><span class="s2">padding</span><span class="s4">);</span>
  <span class="s3">return true</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">ecb</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">unpad </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">output</span><span class="s4">, </span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s6">// check for error: input data not a multiple of blockSize</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">overflow </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s3">return false</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// ensure padding byte count is valid</span>
  <span class="s3">var </span><span class="s2">len </span><span class="s4">= </span><span class="s2">output</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
  <span class="s3">var </span><span class="s2">count </span><span class="s4">= </span><span class="s2">output</span><span class="s4">.</span><span class="s2">at</span><span class="s4">(</span><span class="s2">len </span><span class="s4">- </span><span class="s7">1</span><span class="s4">);</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">count </span><span class="s4">&gt; (</span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">&lt;&lt; </span><span class="s7">2</span><span class="s4">)) {</span>
    <span class="s3">return false</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// trim off padding bytes</span>
  <span class="s2">output</span><span class="s4">.</span><span class="s2">truncate</span><span class="s4">(</span><span class="s2">count</span><span class="s4">);</span>
  <span class="s3">return true</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/** Cipher-block Chaining (CBC) **/</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">cbc </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s2">options </span><span class="s4">= </span><span class="s2">options </span><span class="s4">|| {};</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">name </span><span class="s4">= </span><span class="s5">'CBC'</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">|| </span><span class="s7">16</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_ints </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">/ </span><span class="s7">4</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">);</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">);</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">cbc</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">start </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s6">// Note: legacy support for using IV residue (has security flaws)</span>
  <span class="s6">// if IV is null, reuse block from previous processing</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">iv </span><span class="s4">=== </span><span class="s3">null</span><span class="s4">) {</span>
    <span class="s6">// must have a previous block</span>
    <span class="s3">if</span><span class="s4">(!</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_prev</span><span class="s4">) {</span>
      <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Invalid IV parameter.'</span><span class="s4">);</span>
    <span class="s4">}</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_iv </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_prev</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s7">0</span><span class="s4">);</span>
  <span class="s4">} </span><span class="s3">else if</span><span class="s4">(!(</span><span class="s5">'iv' </span><span class="s3">in </span><span class="s2">options</span><span class="s4">)) {</span>
    <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Invalid IV parameter.'</span><span class="s4">);</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s6">// save IV as &quot;previous&quot; block</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_iv </span><span class="s4">= </span><span class="s2">transformIV</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">iv</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">);</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_prev </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_iv</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s7">0</span><span class="s4">);</span>
  <span class="s4">}</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">cbc</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">encrypt </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">input</span><span class="s4">, </span><span class="s2">output</span><span class="s4">, </span><span class="s2">finish</span><span class="s4">) {</span>
  <span class="s6">// not enough input to encrypt</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() &lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">&amp;&amp; !(</span><span class="s2">finish </span><span class="s4">&amp;&amp; </span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() &gt; </span><span class="s7">0</span><span class="s4">)) {</span>
    <span class="s3">return true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// get next block</span>
  <span class="s6">// CBC XOR's IV (or previous block) with plaintext</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_prev</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] ^ </span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">();</span>
  <span class="s4">}</span>

  <span class="s6">// encrypt block</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">encrypt</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">);</span>

  <span class="s6">// write output, save previous block</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s2">output</span><span class="s4">.</span><span class="s2">putInt32</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
  <span class="s4">}</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_prev </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">cbc</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">decrypt </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">input</span><span class="s4">, </span><span class="s2">output</span><span class="s4">, </span><span class="s2">finish</span><span class="s4">) {</span>
  <span class="s6">// not enough input to decrypt</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() &lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">&amp;&amp; !(</span><span class="s2">finish </span><span class="s4">&amp;&amp; </span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() &gt; </span><span class="s7">0</span><span class="s4">)) {</span>
    <span class="s3">return true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// get next block</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">();</span>
  <span class="s4">}</span>

  <span class="s6">// decrypt block</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">decrypt</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">);</span>

  <span class="s6">// write output, save previous ciphered block</span>
  <span class="s6">// CBC XOR's IV (or previous block) with ciphertext</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s2">output</span><span class="s4">.</span><span class="s2">putInt32</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_prev</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] ^ </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
  <span class="s4">}</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_prev </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s7">0</span><span class="s4">);</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">cbc</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">pad </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">input</span><span class="s4">, </span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s6">// add PKCS#7 padding to block (each pad byte is the</span>
  <span class="s6">// value of the number of pad bytes)</span>
  <span class="s3">var </span><span class="s2">padding </span><span class="s4">= (</span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() === </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">?</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">: (</span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">- </span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">()));</span>
  <span class="s2">input</span><span class="s4">.</span><span class="s2">fillWithByte</span><span class="s4">(</span><span class="s2">padding</span><span class="s4">, </span><span class="s2">padding</span><span class="s4">);</span>
  <span class="s3">return true</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">cbc</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">unpad </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">output</span><span class="s4">, </span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s6">// check for error: input data not a multiple of blockSize</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">overflow </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s3">return false</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// ensure padding byte count is valid</span>
  <span class="s3">var </span><span class="s2">len </span><span class="s4">= </span><span class="s2">output</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
  <span class="s3">var </span><span class="s2">count </span><span class="s4">= </span><span class="s2">output</span><span class="s4">.</span><span class="s2">at</span><span class="s4">(</span><span class="s2">len </span><span class="s4">- </span><span class="s7">1</span><span class="s4">);</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">count </span><span class="s4">&gt; (</span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">&lt;&lt; </span><span class="s7">2</span><span class="s4">)) {</span>
    <span class="s3">return false</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// trim off padding bytes</span>
  <span class="s2">output</span><span class="s4">.</span><span class="s2">truncate</span><span class="s4">(</span><span class="s2">count</span><span class="s4">);</span>
  <span class="s3">return true</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/** Cipher feedback (CFB) **/</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">cfb </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s2">options </span><span class="s4">= </span><span class="s2">options </span><span class="s4">|| {};</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">name </span><span class="s4">= </span><span class="s5">'CFB'</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">|| </span><span class="s7">16</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_ints </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">/ </span><span class="s7">4</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">);</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBlock </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">);</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">();</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">cfb</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">start </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s3">if</span><span class="s4">(!(</span><span class="s5">'iv' </span><span class="s3">in </span><span class="s2">options</span><span class="s4">)) {</span>
    <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Invalid IV parameter.'</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s6">// use IV as first input</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_iv </span><span class="s4">= </span><span class="s2">transformIV</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">iv</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">);</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_iv</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s7">0</span><span class="s4">);</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">cfb</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">encrypt </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">input</span><span class="s4">, </span><span class="s2">output</span><span class="s4">, </span><span class="s2">finish</span><span class="s4">) {</span>
  <span class="s6">// not enough input to encrypt</span>
  <span class="s3">var </span><span class="s2">inputLength </span><span class="s4">= </span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">inputLength </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s3">return true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// encrypt block</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">encrypt</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">);</span>

  <span class="s6">// handle full block</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">=== </span><span class="s7">0 </span><span class="s4">&amp;&amp; </span><span class="s2">inputLength </span><span class="s4">&gt;= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">) {</span>
    <span class="s6">// XOR input with output, write input as output</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">() ^ </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>
      <span class="s2">output</span><span class="s4">.</span><span class="s2">putInt32</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
    <span class="s4">}</span>
    <span class="s3">return</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// handle partial block</span>
  <span class="s3">var </span><span class="s2">partialBytes </span><span class="s4">= (</span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">- </span><span class="s2">inputLength</span><span class="s4">) % </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">partialBytes </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s2">partialBytes </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">- </span><span class="s2">partialBytes</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// XOR input with output, write input as partial output</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">clear</span><span class="s4">();</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">() ^ </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">putInt32</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
  <span class="s4">}</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">partialBytes </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s6">// block still incomplete, restore input buffer</span>
    <span class="s2">input</span><span class="s4">.</span><span class="s2">read </span><span class="s4">-= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">;</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s6">// block complete, update input block</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s6">// skip any previous partial bytes</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">partialBytes </span><span class="s4">&gt; </span><span class="s7">0 </span><span class="s4">&amp;&amp; !</span><span class="s2">finish</span><span class="s4">) {</span>
    <span class="s2">output</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span>
      <span class="s2">partialBytes </span><span class="s4">- </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes</span><span class="s4">));</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s2">partialBytes</span><span class="s4">;</span>
    <span class="s3">return true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s2">output</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span>
    <span class="s2">inputLength </span><span class="s4">- </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes</span><span class="s4">));</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">cfb</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">decrypt </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">input</span><span class="s4">, </span><span class="s2">output</span><span class="s4">, </span><span class="s2">finish</span><span class="s4">) {</span>
  <span class="s6">// not enough input to decrypt</span>
  <span class="s3">var </span><span class="s2">inputLength </span><span class="s4">= </span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">inputLength </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s3">return true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// encrypt block (CFB always uses encryption mode)</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">encrypt</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">);</span>

  <span class="s6">// handle full block</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">=== </span><span class="s7">0 </span><span class="s4">&amp;&amp; </span><span class="s2">inputLength </span><span class="s4">&gt;= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">) {</span>
    <span class="s6">// XOR input with output, write input as output</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">();</span>
      <span class="s2">output</span><span class="s4">.</span><span class="s2">putInt32</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] ^ </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
    <span class="s4">}</span>
    <span class="s3">return</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// handle partial block</span>
  <span class="s3">var </span><span class="s2">partialBytes </span><span class="s4">= (</span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">- </span><span class="s2">inputLength</span><span class="s4">) % </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">partialBytes </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s2">partialBytes </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">- </span><span class="s2">partialBytes</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// XOR input with output, write input as partial output</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">clear</span><span class="s4">();</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">();</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">putInt32</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] ^ </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
  <span class="s4">}</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">partialBytes </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s6">// block still incomplete, restore input buffer</span>
    <span class="s2">input</span><span class="s4">.</span><span class="s2">read </span><span class="s4">-= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">;</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s6">// block complete, update input block</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s6">// skip any previous partial bytes</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">partialBytes </span><span class="s4">&gt; </span><span class="s7">0 </span><span class="s4">&amp;&amp; !</span><span class="s2">finish</span><span class="s4">) {</span>
    <span class="s2">output</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span>
      <span class="s2">partialBytes </span><span class="s4">- </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes</span><span class="s4">));</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s2">partialBytes</span><span class="s4">;</span>
    <span class="s3">return true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s2">output</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span>
    <span class="s2">inputLength </span><span class="s4">- </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes</span><span class="s4">));</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/** Output feedback (OFB) **/</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">ofb </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s2">options </span><span class="s4">= </span><span class="s2">options </span><span class="s4">|| {};</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">name </span><span class="s4">= </span><span class="s5">'OFB'</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">|| </span><span class="s7">16</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_ints </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">/ </span><span class="s7">4</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">);</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">();</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">ofb</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">start </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s3">if</span><span class="s4">(!(</span><span class="s5">'iv' </span><span class="s3">in </span><span class="s2">options</span><span class="s4">)) {</span>
    <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Invalid IV parameter.'</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s6">// use IV as first input</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_iv </span><span class="s4">= </span><span class="s2">transformIV</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">iv</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">);</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_iv</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s7">0</span><span class="s4">);</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">ofb</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">encrypt </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">input</span><span class="s4">, </span><span class="s2">output</span><span class="s4">, </span><span class="s2">finish</span><span class="s4">) {</span>
  <span class="s6">// not enough input to encrypt</span>
  <span class="s3">var </span><span class="s2">inputLength </span><span class="s4">= </span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() === </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s3">return true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// encrypt block (OFB always uses encryption mode)</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">encrypt</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">);</span>

  <span class="s6">// handle full block</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">=== </span><span class="s7">0 </span><span class="s4">&amp;&amp; </span><span class="s2">inputLength </span><span class="s4">&gt;= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">) {</span>
    <span class="s6">// XOR input with output and update next input</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s2">output</span><span class="s4">.</span><span class="s2">putInt32</span><span class="s4">(</span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">() ^ </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
      <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>
    <span class="s4">}</span>
    <span class="s3">return</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// handle partial block</span>
  <span class="s3">var </span><span class="s2">partialBytes </span><span class="s4">= (</span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">- </span><span class="s2">inputLength</span><span class="s4">) % </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">partialBytes </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s2">partialBytes </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">- </span><span class="s2">partialBytes</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// XOR input with output</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">clear</span><span class="s4">();</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">putInt32</span><span class="s4">(</span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">() ^ </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
  <span class="s4">}</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">partialBytes </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s6">// block still incomplete, restore input buffer</span>
    <span class="s2">input</span><span class="s4">.</span><span class="s2">read </span><span class="s4">-= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">;</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s6">// block complete, update input block</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s6">// skip any previous partial bytes</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">partialBytes </span><span class="s4">&gt; </span><span class="s7">0 </span><span class="s4">&amp;&amp; !</span><span class="s2">finish</span><span class="s4">) {</span>
    <span class="s2">output</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span>
      <span class="s2">partialBytes </span><span class="s4">- </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes</span><span class="s4">));</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s2">partialBytes</span><span class="s4">;</span>
    <span class="s3">return true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s2">output</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span>
    <span class="s2">inputLength </span><span class="s4">- </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes</span><span class="s4">));</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">ofb</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">decrypt </span><span class="s4">= </span><span class="s2">modes</span><span class="s4">.</span><span class="s2">ofb</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">encrypt</span><span class="s4">;</span>

<span class="s0">/** Counter (CTR) **/</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">ctr </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s2">options </span><span class="s4">= </span><span class="s2">options </span><span class="s4">|| {};</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">name </span><span class="s4">= </span><span class="s5">'CTR'</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">|| </span><span class="s7">16</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_ints </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">/ </span><span class="s7">4</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">);</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">();</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">ctr</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">start </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s3">if</span><span class="s4">(!(</span><span class="s5">'iv' </span><span class="s3">in </span><span class="s2">options</span><span class="s4">)) {</span>
    <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Invalid IV parameter.'</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s6">// use IV as first input</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_iv </span><span class="s4">= </span><span class="s2">transformIV</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">iv</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">);</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_iv</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s7">0</span><span class="s4">);</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">ctr</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">encrypt </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">input</span><span class="s4">, </span><span class="s2">output</span><span class="s4">, </span><span class="s2">finish</span><span class="s4">) {</span>
  <span class="s6">// not enough input to encrypt</span>
  <span class="s3">var </span><span class="s2">inputLength </span><span class="s4">= </span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">inputLength </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s3">return true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// encrypt block (CTR always uses encryption mode)</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">encrypt</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">);</span>

  <span class="s6">// handle full block</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">=== </span><span class="s7">0 </span><span class="s4">&amp;&amp; </span><span class="s2">inputLength </span><span class="s4">&gt;= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">) {</span>
    <span class="s6">// XOR input with output</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s2">output</span><span class="s4">.</span><span class="s2">putInt32</span><span class="s4">(</span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">() ^ </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
    <span class="s4">}</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s6">// handle partial block</span>
    <span class="s3">var </span><span class="s2">partialBytes </span><span class="s4">= (</span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">- </span><span class="s2">inputLength</span><span class="s4">) % </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">;</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">partialBytes </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
      <span class="s2">partialBytes </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">- </span><span class="s2">partialBytes</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s6">// XOR input with output</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">clear</span><span class="s4">();</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">putInt32</span><span class="s4">(</span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">() ^ </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
    <span class="s4">}</span>

    <span class="s3">if</span><span class="s4">(</span><span class="s2">partialBytes </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
      <span class="s6">// block still incomplete, restore input buffer</span>
      <span class="s2">input</span><span class="s4">.</span><span class="s2">read </span><span class="s4">-= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s6">// skip any previous partial bytes</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
      <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s3">if</span><span class="s4">(</span><span class="s2">partialBytes </span><span class="s4">&gt; </span><span class="s7">0 </span><span class="s4">&amp;&amp; !</span><span class="s2">finish</span><span class="s4">) {</span>
      <span class="s2">output</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span>
        <span class="s2">partialBytes </span><span class="s4">- </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes</span><span class="s4">));</span>
      <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s2">partialBytes</span><span class="s4">;</span>
      <span class="s3">return true</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s2">output</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span>
      <span class="s2">inputLength </span><span class="s4">- </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes</span><span class="s4">));</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// block complete, increment counter (input block)</span>
  <span class="s2">inc32</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">);</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">ctr</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">decrypt </span><span class="s4">= </span><span class="s2">modes</span><span class="s4">.</span><span class="s2">ctr</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">encrypt</span><span class="s4">;</span>

<span class="s0">/** Galois/Counter Mode (GCM) **/</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">gcm </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s2">options </span><span class="s4">= </span><span class="s2">options </span><span class="s4">|| {};</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">name </span><span class="s4">= </span><span class="s5">'GCM'</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">|| </span><span class="s7">16</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_ints </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">/ </span><span class="s7">4</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">);</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">);</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">();</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>

  <span class="s6">// R is actually this value concatenated with 120 more zero bits, but</span>
  <span class="s6">// we only XOR against R so the other zeros have no effect -- we just</span>
  <span class="s6">// apply this value to the first integer in a block</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_R </span><span class="s4">= </span><span class="s7">0xE1000000</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">gcm</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">start </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s3">if</span><span class="s4">(!(</span><span class="s5">'iv' </span><span class="s3">in </span><span class="s2">options</span><span class="s4">)) {</span>
    <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Invalid IV parameter.'</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s6">// ensure IV is a byte buffer</span>
  <span class="s3">var </span><span class="s2">iv </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">iv</span><span class="s4">);</span>

  <span class="s6">// no ciphered data processed yet</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_cipherLength </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>

  <span class="s6">// default additional data is none</span>
  <span class="s3">var </span><span class="s2">additionalData</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s5">'additionalData' </span><span class="s3">in </span><span class="s2">options</span><span class="s4">) {</span>
    <span class="s2">additionalData </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">additionalData</span><span class="s4">);</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s2">additionalData </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">();</span>
  <span class="s4">}</span>

  <span class="s6">// default tag length is 128 bits</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s5">'tagLength' </span><span class="s3">in </span><span class="s2">options</span><span class="s4">) {</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_tagLength </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">tagLength</span><span class="s4">;</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_tagLength </span><span class="s4">= </span><span class="s7">128</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// if tag is given, ensure tag matches tag length</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_tag </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">decrypt</span><span class="s4">) {</span>
    <span class="s6">// save tag to check later</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_tag </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">tag</span><span class="s4">).</span><span class="s2">getBytes</span><span class="s4">();</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_tag</span><span class="s4">.</span><span class="s2">length </span><span class="s4">!== (</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_tagLength </span><span class="s4">/ </span><span class="s7">8</span><span class="s4">)) {</span>
      <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Authentication tag does not match tag length.'</span><span class="s4">);</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s6">// create tmp storage for hash calculation</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_hashBlock </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">);</span>

  <span class="s6">// no tag generated yet</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">tag </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>

  <span class="s6">// generate hash subkey</span>
  <span class="s6">// (apply block cipher to &quot;zero&quot; block)</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_hashSubkey </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">);</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">encrypt</span><span class="s4">([</span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">], </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_hashSubkey</span><span class="s4">);</span>

  <span class="s6">// generate table M</span>
  <span class="s6">// use 4-bit tables (32 component decomposition of a 16 byte value)</span>
  <span class="s6">// 8-bit tables take more space and are known to have security</span>
  <span class="s6">// vulnerabilities (in native implementations)</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">componentBits </span><span class="s4">= </span><span class="s7">4</span><span class="s4">;</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_m </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">generateHashTable</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_hashSubkey</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">componentBits</span><span class="s4">);</span>

  <span class="s6">// Note: support IV length different from 96 bits? (only supporting</span>
  <span class="s6">// 96 bits is recommended by NIST SP-800-38D)</span>
  <span class="s6">// generate J_0</span>
  <span class="s3">var </span><span class="s2">ivLength </span><span class="s4">= </span><span class="s2">iv</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">ivLength </span><span class="s4">=== </span><span class="s7">12</span><span class="s4">) {</span>
    <span class="s6">// 96-bit IV</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_j0 </span><span class="s4">= [</span><span class="s2">iv</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">(), </span><span class="s2">iv</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">(), </span><span class="s2">iv</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">(), </span><span class="s7">1</span><span class="s4">];</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s6">// IV is NOT 96-bits</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_j0 </span><span class="s4">= [</span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">];</span>
    <span class="s3">while</span><span class="s4">(</span><span class="s2">iv</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() &gt; </span><span class="s7">0</span><span class="s4">) {</span>
      <span class="s3">this</span><span class="s4">.</span><span class="s2">_j0 </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">ghash</span><span class="s4">(</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s2">_hashSubkey</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_j0</span><span class="s4">,</span>
        <span class="s4">[</span><span class="s2">iv</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">(), </span><span class="s2">iv</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">(), </span><span class="s2">iv</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">(), </span><span class="s2">iv</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">()]);</span>
    <span class="s4">}</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_j0 </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">ghash</span><span class="s4">(</span>
      <span class="s3">this</span><span class="s4">.</span><span class="s2">_hashSubkey</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_j0</span><span class="s4">, [</span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">].</span><span class="s2">concat</span><span class="s4">(</span><span class="s2">from64To32</span><span class="s4">(</span><span class="s2">ivLength </span><span class="s4">* </span><span class="s7">8</span><span class="s4">)));</span>
  <span class="s4">}</span>

  <span class="s6">// generate ICB (initial counter block)</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_j0</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s7">0</span><span class="s4">);</span>
  <span class="s2">inc32</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">);</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>

  <span class="s6">// consume authentication data</span>
  <span class="s2">additionalData </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">additionalData</span><span class="s4">);</span>
  <span class="s6">// save additional data length as a BE 64-bit number</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_aDataLength </span><span class="s4">= </span><span class="s2">from64To32</span><span class="s4">(</span><span class="s2">additionalData</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() * </span><span class="s7">8</span><span class="s4">);</span>
  <span class="s6">// pad additional data to 128 bit (16 byte) block size</span>
  <span class="s3">var </span><span class="s2">overflow </span><span class="s4">= </span><span class="s2">additionalData</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() % </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">overflow</span><span class="s4">) {</span>
    <span class="s2">additionalData</span><span class="s4">.</span><span class="s2">fillWithByte</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">- </span><span class="s2">overflow</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_s </span><span class="s4">= [</span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">];</span>
  <span class="s3">while</span><span class="s4">(</span><span class="s2">additionalData</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() &gt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_s </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">ghash</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_hashSubkey</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_s</span><span class="s4">, [</span>
      <span class="s2">additionalData</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">(),</span>
      <span class="s2">additionalData</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">(),</span>
      <span class="s2">additionalData</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">(),</span>
      <span class="s2">additionalData</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">()</span>
    <span class="s4">]);</span>
  <span class="s4">}</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">gcm</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">encrypt </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">input</span><span class="s4">, </span><span class="s2">output</span><span class="s4">, </span><span class="s2">finish</span><span class="s4">) {</span>
  <span class="s6">// not enough input to encrypt</span>
  <span class="s3">var </span><span class="s2">inputLength </span><span class="s4">= </span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">inputLength </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s3">return true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// encrypt block</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">encrypt</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">);</span>

  <span class="s6">// handle full block</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">=== </span><span class="s7">0 </span><span class="s4">&amp;&amp; </span><span class="s2">inputLength </span><span class="s4">&gt;= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">) {</span>
    <span class="s6">// XOR input with output</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s2">output</span><span class="s4">.</span><span class="s2">putInt32</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] ^= </span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">());</span>
    <span class="s4">}</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_cipherLength </span><span class="s4">+= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">;</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s6">// handle partial block</span>
    <span class="s3">var </span><span class="s2">partialBytes </span><span class="s4">= (</span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">- </span><span class="s2">inputLength</span><span class="s4">) % </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">;</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">partialBytes </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
      <span class="s2">partialBytes </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">- </span><span class="s2">partialBytes</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s6">// XOR input with output</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">clear</span><span class="s4">();</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">putInt32</span><span class="s4">(</span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">() ^ </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
    <span class="s4">}</span>

    <span class="s3">if</span><span class="s4">(</span><span class="s2">partialBytes </span><span class="s4">&lt;= </span><span class="s7">0 </span><span class="s4">|| </span><span class="s2">finish</span><span class="s4">) {</span>
      <span class="s6">// handle overflow prior to hashing</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">finish</span><span class="s4">) {</span>
        <span class="s6">// get block overflow</span>
        <span class="s3">var </span><span class="s2">overflow </span><span class="s4">= </span><span class="s2">inputLength </span><span class="s4">% </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">;</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s2">_cipherLength </span><span class="s4">+= </span><span class="s2">overflow</span><span class="s4">;</span>
        <span class="s6">// truncate for hash function</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">truncate</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">- </span><span class="s2">overflow</span><span class="s4">);</span>
      <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s2">_cipherLength </span><span class="s4">+= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">;</span>
      <span class="s4">}</span>

      <span class="s6">// get output block for hashing</span>
      <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">();</span>
      <span class="s4">}</span>
      <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">read </span><span class="s4">-= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s6">// skip any previous partial bytes</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
      <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s3">if</span><span class="s4">(</span><span class="s2">partialBytes </span><span class="s4">&gt; </span><span class="s7">0 </span><span class="s4">&amp;&amp; !</span><span class="s2">finish</span><span class="s4">) {</span>
      <span class="s6">// block still incomplete, restore input buffer, get partial output,</span>
      <span class="s6">// and return early</span>
      <span class="s2">input</span><span class="s4">.</span><span class="s2">read </span><span class="s4">-= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">;</span>
      <span class="s2">output</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span>
        <span class="s2">partialBytes </span><span class="s4">- </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes</span><span class="s4">));</span>
      <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s2">partialBytes</span><span class="s4">;</span>
      <span class="s3">return true</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s2">output</span><span class="s4">.</span><span class="s2">putBytes</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialOutput</span><span class="s4">.</span><span class="s2">getBytes</span><span class="s4">(</span>
      <span class="s2">inputLength </span><span class="s4">- </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes</span><span class="s4">));</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_partialBytes </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// update hash block S</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_s </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">ghash</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_hashSubkey</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_s</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">);</span>

  <span class="s6">// increment counter (input block)</span>
  <span class="s2">inc32</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">);</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">gcm</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">decrypt </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">input</span><span class="s4">, </span><span class="s2">output</span><span class="s4">, </span><span class="s2">finish</span><span class="s4">) {</span>
  <span class="s6">// not enough input to decrypt</span>
  <span class="s3">var </span><span class="s2">inputLength </span><span class="s4">= </span><span class="s2">input</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">inputLength </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">&amp;&amp; !(</span><span class="s2">finish </span><span class="s4">&amp;&amp; </span><span class="s2">inputLength </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">)) {</span>
    <span class="s3">return true</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// encrypt block (GCM always uses encryption mode)</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">encrypt</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">);</span>

  <span class="s6">// increment counter (input block)</span>
  <span class="s2">inc32</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_inBlock</span><span class="s4">);</span>

  <span class="s6">// update hash block S</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_hashBlock</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] = </span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">();</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_hashBlock</span><span class="s4">[</span><span class="s7">1</span><span class="s4">] = </span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">();</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_hashBlock</span><span class="s4">[</span><span class="s7">2</span><span class="s4">] = </span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">();</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_hashBlock</span><span class="s4">[</span><span class="s7">3</span><span class="s4">] = </span><span class="s2">input</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">();</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_s </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">ghash</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_hashSubkey</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_s</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_hashBlock</span><span class="s4">);</span>

  <span class="s6">// XOR hash input with output</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s2">output</span><span class="s4">.</span><span class="s2">putInt32</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_outBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] ^ </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_hashBlock</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
  <span class="s4">}</span>

  <span class="s6">// increment cipher data length</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">inputLength </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">) {</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_cipherLength </span><span class="s4">+= </span><span class="s2">inputLength </span><span class="s4">% </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">;</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">_cipherLength </span><span class="s4">+= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize</span><span class="s4">;</span>
  <span class="s4">}</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">gcm</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">afterFinish </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">output</span><span class="s4">, </span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">rval </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>

  <span class="s6">// handle overflow</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">decrypt </span><span class="s4">&amp;&amp; </span><span class="s2">options</span><span class="s4">.</span><span class="s2">overflow</span><span class="s4">) {</span>
    <span class="s2">output</span><span class="s4">.</span><span class="s2">truncate</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">blockSize </span><span class="s4">- </span><span class="s2">options</span><span class="s4">.</span><span class="s2">overflow</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s6">// handle authentication tag</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">tag </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">();</span>

  <span class="s6">// concatenate additional data length with cipher length</span>
  <span class="s3">var </span><span class="s2">lengths </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_aDataLength</span><span class="s4">.</span><span class="s2">concat</span><span class="s4">(</span><span class="s2">from64To32</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_cipherLength </span><span class="s4">* </span><span class="s7">8</span><span class="s4">));</span>

  <span class="s6">// include lengths in hash</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_s </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">ghash</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_hashSubkey</span><span class="s4">, </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_s</span><span class="s4">, </span><span class="s2">lengths</span><span class="s4">);</span>

  <span class="s6">// do GCTR(J_0, S)</span>
  <span class="s3">var </span><span class="s2">tag </span><span class="s4">= [];</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">encrypt</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_j0</span><span class="s4">, </span><span class="s2">tag</span><span class="s4">);</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_ints</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">tag</span><span class="s4">.</span><span class="s2">putInt32</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_s</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] ^ </span><span class="s2">tag</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
  <span class="s4">}</span>

  <span class="s6">// trim tag to length</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">tag</span><span class="s4">.</span><span class="s2">truncate</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">tag</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() % (</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_tagLength </span><span class="s4">/ </span><span class="s7">8</span><span class="s4">));</span>

  <span class="s6">// check authentication tag</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">decrypt </span><span class="s4">&amp;&amp; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">tag</span><span class="s4">.</span><span class="s2">bytes</span><span class="s4">() !== </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_tag</span><span class="s4">) {</span>
    <span class="s2">rval </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s3">return </span><span class="s2">rval</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois</span>
 <span class="s0">* field multiplication. The field, GF(2^128), is defined by the polynomial:</span>
 <span class="s0">*</span>
 <span class="s0">* x^128 + x^7 + x^2 + x + 1</span>
 <span class="s0">*</span>
 <span class="s0">* Which is represented in little-endian binary form as: 11100001 (0xe1). When</span>
 <span class="s0">* the value of a coefficient is 1, a bit is set. The value R, is the</span>
 <span class="s0">* concatenation of this value and 120 zero bits, yielding a 128-bit value</span>
 <span class="s0">* which matches the block size.</span>
 <span class="s0">*</span>
 <span class="s0">* This function will multiply two elements (vectors of bytes), X and Y, in</span>
 <span class="s0">* the field GF(2^128). The result is initialized to zero. For each bit of</span>
 <span class="s0">* X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)</span>
 <span class="s0">* by the current value of Y. For each bit, the value of Y will be raised by</span>
 <span class="s0">* a power of x (multiplied by the polynomial x). This can be achieved by</span>
 <span class="s0">* shifting Y once to the right. If the current value of Y, prior to being</span>
 <span class="s0">* multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.</span>
 <span class="s0">* Otherwise, we must divide by R after shifting to find the remainder.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">x the first block to multiply by the second.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">y the second block to multiply by the first.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the block result of the multiplication.</span>
 <span class="s0">*/</span>
<span class="s2">modes</span><span class="s4">.</span><span class="s2">gcm</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">multiply </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">x</span><span class="s4">, </span><span class="s2">y</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">z_i </span><span class="s4">= [</span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">];</span>
  <span class="s3">var </span><span class="s2">v_i </span><span class="s4">= </span><span class="s2">y</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s7">0</span><span class="s4">);</span>

  <span class="s6">// calculate Z_128 (block has 128 bits)</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s7">128</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s6">// if x_i is 0, Z_{i+1} = Z_i (unchanged)</span>
    <span class="s6">// else Z_{i+1} = Z_i ^ V_i</span>
    <span class="s6">// get x_i by finding 32-bit int position, then left shift 1 by remainder</span>
    <span class="s3">var </span><span class="s2">x_i </span><span class="s4">= </span><span class="s2">x</span><span class="s4">[(</span><span class="s2">i </span><span class="s4">/ </span><span class="s7">32</span><span class="s4">) | </span><span class="s7">0</span><span class="s4">] &amp; (</span><span class="s7">1 </span><span class="s4">&lt;&lt; (</span><span class="s7">31 </span><span class="s4">- </span><span class="s2">i </span><span class="s4">% </span><span class="s7">32</span><span class="s4">));</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">x_i</span><span class="s4">) {</span>
      <span class="s2">z_i</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] ^= </span><span class="s2">v_i</span><span class="s4">[</span><span class="s7">0</span><span class="s4">];</span>
      <span class="s2">z_i</span><span class="s4">[</span><span class="s7">1</span><span class="s4">] ^= </span><span class="s2">v_i</span><span class="s4">[</span><span class="s7">1</span><span class="s4">];</span>
      <span class="s2">z_i</span><span class="s4">[</span><span class="s7">2</span><span class="s4">] ^= </span><span class="s2">v_i</span><span class="s4">[</span><span class="s7">2</span><span class="s4">];</span>
      <span class="s2">z_i</span><span class="s4">[</span><span class="s7">3</span><span class="s4">] ^= </span><span class="s2">v_i</span><span class="s4">[</span><span class="s7">3</span><span class="s4">];</span>
    <span class="s4">}</span>

    <span class="s6">// if LSB(V_i) is 1, V_i = V_i &gt;&gt; 1</span>
    <span class="s6">// else V_i = (V_i &gt;&gt; 1) ^ R</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">pow</span><span class="s4">(</span><span class="s2">v_i</span><span class="s4">, </span><span class="s2">v_i</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s3">return </span><span class="s2">z_i</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">gcm</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">pow </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">x</span><span class="s4">, </span><span class="s2">out</span><span class="s4">) {</span>
  <span class="s6">// if LSB(x) is 1, x = x &gt;&gt;&gt; 1</span>
  <span class="s6">// else x = (x &gt;&gt;&gt; 1) ^ R</span>
  <span class="s3">var </span><span class="s2">lsb </span><span class="s4">= </span><span class="s2">x</span><span class="s4">[</span><span class="s7">3</span><span class="s4">] &amp; </span><span class="s7">1</span><span class="s4">;</span>

  <span class="s6">// always do x &gt;&gt;&gt; 1:</span>
  <span class="s6">// starting with the rightmost integer, shift each integer to the right</span>
  <span class="s6">// one bit, pulling in the bit from the integer to the left as its top</span>
  <span class="s6">// most bit (do this for the last 3 integers)</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">3</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">; --</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s2">out</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = (</span><span class="s2">x</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] &gt;&gt;&gt; </span><span class="s7">1</span><span class="s4">) | ((</span><span class="s2">x</span><span class="s4">[</span><span class="s2">i </span><span class="s4">- </span><span class="s7">1</span><span class="s4">] &amp; </span><span class="s7">1</span><span class="s4">) &lt;&lt; </span><span class="s7">31</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s6">// shift the first integer normally</span>
  <span class="s2">out</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] = </span><span class="s2">x</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] &gt;&gt;&gt; </span><span class="s7">1</span><span class="s4">;</span>

  <span class="s6">// if lsb was not set, then polynomial had a degree of 127 and doesn't</span>
  <span class="s6">// need to divided; otherwise, XOR with R to find the remainder; we only</span>
  <span class="s6">// need to XOR the first integer since R technically ends w/120 zero bits</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">lsb</span><span class="s4">) {</span>
    <span class="s2">out</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] ^= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_R</span><span class="s4">;</span>
  <span class="s4">}</span>
<span class="s4">};</span>

<span class="s2">modes</span><span class="s4">.</span><span class="s2">gcm</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">tableMultiply </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">x</span><span class="s4">) {</span>
  <span class="s6">// assumes 4-bit tables are used</span>
  <span class="s3">var </span><span class="s2">z </span><span class="s4">= [</span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">];</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s7">32</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">idx </span><span class="s4">= (</span><span class="s2">i </span><span class="s4">/ </span><span class="s7">8</span><span class="s4">) | </span><span class="s7">0</span><span class="s4">;</span>
    <span class="s3">var </span><span class="s2">x_i </span><span class="s4">= (</span><span class="s2">x</span><span class="s4">[</span><span class="s2">idx</span><span class="s4">] &gt;&gt;&gt; ((</span><span class="s7">7 </span><span class="s4">- (</span><span class="s2">i </span><span class="s4">% </span><span class="s7">8</span><span class="s4">)) * </span><span class="s7">4</span><span class="s4">)) &amp; </span><span class="s7">0xF</span><span class="s4">;</span>
    <span class="s3">var </span><span class="s2">ah </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">_m</span><span class="s4">[</span><span class="s2">i</span><span class="s4">][</span><span class="s2">x_i</span><span class="s4">];</span>
    <span class="s2">z</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] ^= </span><span class="s2">ah</span><span class="s4">[</span><span class="s7">0</span><span class="s4">];</span>
    <span class="s2">z</span><span class="s4">[</span><span class="s7">1</span><span class="s4">] ^= </span><span class="s2">ah</span><span class="s4">[</span><span class="s7">1</span><span class="s4">];</span>
    <span class="s2">z</span><span class="s4">[</span><span class="s7">2</span><span class="s4">] ^= </span><span class="s2">ah</span><span class="s4">[</span><span class="s7">2</span><span class="s4">];</span>
    <span class="s2">z</span><span class="s4">[</span><span class="s7">3</span><span class="s4">] ^= </span><span class="s2">ah</span><span class="s4">[</span><span class="s7">3</span><span class="s4">];</span>
  <span class="s4">}</span>
  <span class="s3">return </span><span class="s2">z</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* A continuing version of the GHASH algorithm that operates on a single</span>
 <span class="s0">* block. The hash block, last hash value (Ym) and the new block to hash</span>
 <span class="s0">* are given.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">h the hash block.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">y the previous value for Ym, use [0, 0, 0, 0] for a new hash.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">x the block to hash.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the hashed value (Ym).</span>
 <span class="s0">*/</span>
<span class="s2">modes</span><span class="s4">.</span><span class="s2">gcm</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">ghash </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">h</span><span class="s4">, </span><span class="s2">y</span><span class="s4">, </span><span class="s2">x</span><span class="s4">) {</span>
  <span class="s2">y</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] ^= </span><span class="s2">x</span><span class="s4">[</span><span class="s7">0</span><span class="s4">];</span>
  <span class="s2">y</span><span class="s4">[</span><span class="s7">1</span><span class="s4">] ^= </span><span class="s2">x</span><span class="s4">[</span><span class="s7">1</span><span class="s4">];</span>
  <span class="s2">y</span><span class="s4">[</span><span class="s7">2</span><span class="s4">] ^= </span><span class="s2">x</span><span class="s4">[</span><span class="s7">2</span><span class="s4">];</span>
  <span class="s2">y</span><span class="s4">[</span><span class="s7">3</span><span class="s4">] ^= </span><span class="s2">x</span><span class="s4">[</span><span class="s7">3</span><span class="s4">];</span>
  <span class="s3">return this</span><span class="s4">.</span><span class="s2">tableMultiply</span><span class="s4">(</span><span class="s2">y</span><span class="s4">);</span>
  <span class="s6">//return this.multiply(y, h);</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Precomputes a table for multiplying against the hash subkey. This</span>
 <span class="s0">* mechanism provides a substantial speed increase over multiplication</span>
 <span class="s0">* performed without a table. The table-based multiplication this table is</span>
 <span class="s0">* for solves X * H by multiplying each component of X by H and then</span>
 <span class="s0">* composing the results together using XOR.</span>
 <span class="s0">*</span>
 <span class="s0">* This function can be used to generate tables with different bit sizes</span>
 <span class="s0">* for the components, however, this implementation assumes there are</span>
 <span class="s0">* 32 components of X (which is a 16 byte vector), therefore each component</span>
 <span class="s0">* takes 4-bits (so the table is constructed with bits=4).</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">h the hash subkey.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">bits the bit size for a component.</span>
 <span class="s0">*/</span>
<span class="s2">modes</span><span class="s4">.</span><span class="s2">gcm</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">generateHashTable </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">h</span><span class="s4">, </span><span class="s2">bits</span><span class="s4">) {</span>
  <span class="s6">// TODO: There are further optimizations that would use only the</span>
  <span class="s6">// first table M_0 (or some variant) along with a remainder table;</span>
  <span class="s6">// this can be explored in the future</span>
  <span class="s3">var </span><span class="s2">multiplier </span><span class="s4">= </span><span class="s7">8 </span><span class="s4">/ </span><span class="s2">bits</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">perInt </span><span class="s4">= </span><span class="s7">4 </span><span class="s4">* </span><span class="s2">multiplier</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">size </span><span class="s4">= </span><span class="s7">16 </span><span class="s4">* </span><span class="s2">multiplier</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">m </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s2">size</span><span class="s4">);</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">size</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">tmp </span><span class="s4">= [</span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">];</span>
    <span class="s3">var </span><span class="s2">idx </span><span class="s4">= (</span><span class="s2">i </span><span class="s4">/ </span><span class="s2">perInt</span><span class="s4">) | </span><span class="s7">0</span><span class="s4">;</span>
    <span class="s3">var </span><span class="s2">shft </span><span class="s4">= ((</span><span class="s2">perInt </span><span class="s4">- </span><span class="s7">1 </span><span class="s4">- (</span><span class="s2">i </span><span class="s4">% </span><span class="s2">perInt</span><span class="s4">)) * </span><span class="s2">bits</span><span class="s4">);</span>
    <span class="s2">tmp</span><span class="s4">[</span><span class="s2">idx</span><span class="s4">] = (</span><span class="s7">1 </span><span class="s4">&lt;&lt; (</span><span class="s2">bits </span><span class="s4">- </span><span class="s7">1</span><span class="s4">)) &lt;&lt; </span><span class="s2">shft</span><span class="s4">;</span>
    <span class="s2">m</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s3">this</span><span class="s4">.</span><span class="s2">generateSubHashTable</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">multiply</span><span class="s4">(</span><span class="s2">tmp</span><span class="s4">, </span><span class="s2">h</span><span class="s4">), </span><span class="s2">bits</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s3">return </span><span class="s2">m</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Generates a table for multiplying against the hash subkey for one</span>
 <span class="s0">* particular component (out of all possible component values).</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">mid the pre-multiplied value for the middle key of the table.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">bits the bit size for a component.</span>
 <span class="s0">*/</span>
<span class="s2">modes</span><span class="s4">.</span><span class="s2">gcm</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">generateSubHashTable </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">mid</span><span class="s4">, </span><span class="s2">bits</span><span class="s4">) {</span>
  <span class="s6">// compute the table quickly by minimizing the number of</span>
  <span class="s6">// POW operations -- they only need to be performed for powers of 2,</span>
  <span class="s6">// all other entries can be composed from those powers using XOR</span>
  <span class="s3">var </span><span class="s2">size </span><span class="s4">= </span><span class="s7">1 </span><span class="s4">&lt;&lt; </span><span class="s2">bits</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">half </span><span class="s4">= </span><span class="s2">size </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">1</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">m </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s2">size</span><span class="s4">);</span>
  <span class="s2">m</span><span class="s4">[</span><span class="s2">half</span><span class="s4">] = </span><span class="s2">mid</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s7">0</span><span class="s4">);</span>
  <span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s2">half </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">1</span><span class="s4">;</span>
  <span class="s3">while</span><span class="s4">(</span><span class="s2">i </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
    <span class="s6">// raise m0[2 * i] and store in m0[i]</span>
    <span class="s3">this</span><span class="s4">.</span><span class="s2">pow</span><span class="s4">(</span><span class="s2">m</span><span class="s4">[</span><span class="s7">2 </span><span class="s4">* </span><span class="s2">i</span><span class="s4">], </span><span class="s2">m</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = []);</span>
    <span class="s2">i </span><span class="s4">&gt;&gt;= </span><span class="s7">1</span><span class="s4">;</span>
  <span class="s4">}</span>
  <span class="s2">i </span><span class="s4">= </span><span class="s7">2</span><span class="s4">;</span>
  <span class="s3">while</span><span class="s4">(</span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">half</span><span class="s4">) {</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">j </span><span class="s4">= </span><span class="s7">1</span><span class="s4">; </span><span class="s2">j </span><span class="s4">&lt; </span><span class="s2">i</span><span class="s4">; ++</span><span class="s2">j</span><span class="s4">) {</span>
      <span class="s3">var </span><span class="s2">m_i </span><span class="s4">= </span><span class="s2">m</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>
      <span class="s3">var </span><span class="s2">m_j </span><span class="s4">= </span><span class="s2">m</span><span class="s4">[</span><span class="s2">j</span><span class="s4">];</span>
      <span class="s2">m</span><span class="s4">[</span><span class="s2">i </span><span class="s4">+ </span><span class="s2">j</span><span class="s4">] = [</span>
        <span class="s2">m_i</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] ^ </span><span class="s2">m_j</span><span class="s4">[</span><span class="s7">0</span><span class="s4">],</span>
        <span class="s2">m_i</span><span class="s4">[</span><span class="s7">1</span><span class="s4">] ^ </span><span class="s2">m_j</span><span class="s4">[</span><span class="s7">1</span><span class="s4">],</span>
        <span class="s2">m_i</span><span class="s4">[</span><span class="s7">2</span><span class="s4">] ^ </span><span class="s2">m_j</span><span class="s4">[</span><span class="s7">2</span><span class="s4">],</span>
        <span class="s2">m_i</span><span class="s4">[</span><span class="s7">3</span><span class="s4">] ^ </span><span class="s2">m_j</span><span class="s4">[</span><span class="s7">3</span><span class="s4">]</span>
      <span class="s4">];</span>
    <span class="s4">}</span>
    <span class="s2">i </span><span class="s4">*= </span><span class="s7">2</span><span class="s4">;</span>
  <span class="s4">}</span>
  <span class="s2">m</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] = [</span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">, </span><span class="s7">0</span><span class="s4">];</span>
  <span class="s6">/* Note: We could avoid storing these by doing composition during multiply 
  calculate top half using composition by speed is preferred. */</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s2">i </span><span class="s4">= </span><span class="s2">half </span><span class="s4">+ </span><span class="s7">1</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">size</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">c </span><span class="s4">= </span><span class="s2">m</span><span class="s4">[</span><span class="s2">i </span><span class="s4">^ </span><span class="s2">half</span><span class="s4">];</span>
    <span class="s2">m</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = [</span><span class="s2">mid</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] ^ </span><span class="s2">c</span><span class="s4">[</span><span class="s7">0</span><span class="s4">], </span><span class="s2">mid</span><span class="s4">[</span><span class="s7">1</span><span class="s4">] ^ </span><span class="s2">c</span><span class="s4">[</span><span class="s7">1</span><span class="s4">], </span><span class="s2">mid</span><span class="s4">[</span><span class="s7">2</span><span class="s4">] ^ </span><span class="s2">c</span><span class="s4">[</span><span class="s7">2</span><span class="s4">], </span><span class="s2">mid</span><span class="s4">[</span><span class="s7">3</span><span class="s4">] ^ </span><span class="s2">c</span><span class="s4">[</span><span class="s7">3</span><span class="s4">]];</span>
  <span class="s4">}</span>
  <span class="s3">return </span><span class="s2">m</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/** Utility functions */</span>

<span class="s3">function </span><span class="s2">transformIV</span><span class="s4">(</span><span class="s2">iv</span><span class="s4">, </span><span class="s2">blockSize</span><span class="s4">) {</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">iv </span><span class="s4">=== </span><span class="s5">'string'</span><span class="s4">) {</span>
    <span class="s6">// convert iv string into byte buffer</span>
    <span class="s2">iv </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">iv</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">iv</span><span class="s4">) &amp;&amp; </span><span class="s2">iv</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s7">4</span><span class="s4">) {</span>
    <span class="s6">// convert iv byte array into byte buffer</span>
    <span class="s3">var </span><span class="s2">tmp </span><span class="s4">= </span><span class="s2">iv</span><span class="s4">;</span>
    <span class="s2">iv </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">();</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">tmp</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s2">iv</span><span class="s4">.</span><span class="s2">putByte</span><span class="s4">(</span><span class="s2">tmp</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s2">iv</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() &lt; </span><span class="s2">blockSize</span><span class="s4">) {</span>
    <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span>
      <span class="s5">'Invalid IV length; got ' </span><span class="s4">+ </span><span class="s2">iv</span><span class="s4">.</span><span class="s2">length</span><span class="s4">() +</span>
      <span class="s5">' bytes and expected ' </span><span class="s4">+ </span><span class="s2">blockSize </span><span class="s4">+ </span><span class="s5">' bytes.'</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s3">if</span><span class="s4">(!</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">iv</span><span class="s4">)) {</span>
    <span class="s6">// convert iv byte buffer into 32-bit integer array</span>
    <span class="s3">var </span><span class="s2">ints </span><span class="s4">= [];</span>
    <span class="s3">var </span><span class="s2">blocks </span><span class="s4">= </span><span class="s2">blockSize </span><span class="s4">/ </span><span class="s7">4</span><span class="s4">;</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">blocks</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s2">ints</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">iv</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">());</span>
    <span class="s4">}</span>
    <span class="s2">iv </span><span class="s4">= </span><span class="s2">ints</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s3">return </span><span class="s2">iv</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">inc32</span><span class="s4">(</span><span class="s2">block</span><span class="s4">) {</span>
  <span class="s6">// increment last 32 bits of block only</span>
  <span class="s2">block</span><span class="s4">[</span><span class="s2">block</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s7">1</span><span class="s4">] = (</span><span class="s2">block</span><span class="s4">[</span><span class="s2">block</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s7">1</span><span class="s4">] + </span><span class="s7">1</span><span class="s4">) &amp; </span><span class="s7">0xFFFFFFFF</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">from64To32</span><span class="s4">(</span><span class="s2">num</span><span class="s4">) {</span>
  <span class="s6">// convert 64-bit number to two BE Int32s</span>
  <span class="s3">return </span><span class="s4">[(</span><span class="s2">num </span><span class="s4">/ </span><span class="s7">0x100000000</span><span class="s4">) | </span><span class="s7">0</span><span class="s4">, </span><span class="s2">num </span><span class="s4">&amp; </span><span class="s7">0xFFFFFFFF</span><span class="s4">];</span>
<span class="s4">}</span>
</pre>
</body>
</html>