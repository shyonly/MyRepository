<html>
<head>
<title>aes.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #67a37c; font-style: italic;}
.s2 { color: #bcbec4;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #7a7e85;}
.s7 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
aes.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Advanced Encryption Standard (AES) implementation.</span>
 <span class="s0">*</span>
 <span class="s0">* This implementation is based on the public domain library 'jscrypto' which</span>
 <span class="s0">* was written by:</span>
 <span class="s0">*</span>
 <span class="s0">* Emily Stark (estark@stanford.edu)</span>
 <span class="s0">* Mike Hamburg (mhamburg@stanford.edu)</span>
 <span class="s0">* Dan Boneh (dabo@cs.stanford.edu)</span>
 <span class="s0">*</span>
 <span class="s0">* Parts of this code are based on the OpenSSL implementation of AES:</span>
 <span class="s0">* http://www.openssl.org</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Dave Longley</span>
 <span class="s0">*</span>
 <span class="s0">* Copyright (c) 2010-2014 Digital Bazaar, Inc.</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">forge </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s5">'./forge'</span><span class="s4">);</span>
<span class="s2">require</span><span class="s4">(</span><span class="s5">'./cipher'</span><span class="s4">);</span>
<span class="s2">require</span><span class="s4">(</span><span class="s5">'./cipherModes'</span><span class="s4">);</span>
<span class="s2">require</span><span class="s4">(</span><span class="s5">'./util'</span><span class="s4">);</span>

<span class="s6">/* AES API */</span>
<span class="s2">module</span><span class="s4">.</span><span class="s2">exports </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">aes </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">aes </span><span class="s4">|| {};</span>

<span class="s0">/**</span>
 <span class="s0">* Deprecated. Instead, use:</span>
 <span class="s0">*</span>
 <span class="s0">* var cipher = forge.cipher.createCipher('AES-&lt;mode&gt;', key);</span>
 <span class="s0">* cipher.start({iv: iv});</span>
 <span class="s0">*</span>
 <span class="s0">* Creates an AES cipher object to encrypt data using the given symmetric key.</span>
 <span class="s0">* The output will be stored in the 'output' member of the returned cipher.</span>
 <span class="s0">*</span>
 <span class="s0">* The key and iv may be given as a string of bytes, an array of bytes,</span>
 <span class="s0">* a byte buffer, or an array of 32-bit words.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">key the symmetric key to use.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">iv the initialization vector to use.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">output the buffer to write to, null to create one.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">mode the cipher mode to use (default: 'CBC').</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the cipher.</span>
 <span class="s0">*/</span>
<span class="s2">forge</span><span class="s4">.</span><span class="s2">aes</span><span class="s4">.</span><span class="s2">startEncrypting </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, </span><span class="s2">iv</span><span class="s4">, </span><span class="s2">output</span><span class="s4">, </span><span class="s2">mode</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">cipher </span><span class="s4">= </span><span class="s2">_createCipher</span><span class="s4">({</span>
    <span class="s2">key</span><span class="s4">: </span><span class="s2">key</span><span class="s4">,</span>
    <span class="s2">output</span><span class="s4">: </span><span class="s2">output</span><span class="s4">,</span>
    <span class="s2">decrypt</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">mode</span><span class="s4">: </span><span class="s2">mode</span>
  <span class="s4">});</span>
  <span class="s2">cipher</span><span class="s4">.</span><span class="s2">start</span><span class="s4">(</span><span class="s2">iv</span><span class="s4">);</span>
  <span class="s3">return </span><span class="s2">cipher</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Deprecated. Instead, use:</span>
 <span class="s0">*</span>
 <span class="s0">* var cipher = forge.cipher.createCipher('AES-&lt;mode&gt;', key);</span>
 <span class="s0">*</span>
 <span class="s0">* Creates an AES cipher object to encrypt data using the given symmetric key.</span>
 <span class="s0">*</span>
 <span class="s0">* The key may be given as a string of bytes, an array of bytes, a</span>
 <span class="s0">* byte buffer, or an array of 32-bit words.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">key the symmetric key to use.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">mode the cipher mode to use (default: 'CBC').</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the cipher.</span>
 <span class="s0">*/</span>
<span class="s2">forge</span><span class="s4">.</span><span class="s2">aes</span><span class="s4">.</span><span class="s2">createEncryptionCipher </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, </span><span class="s2">mode</span><span class="s4">) {</span>
  <span class="s3">return </span><span class="s2">_createCipher</span><span class="s4">({</span>
    <span class="s2">key</span><span class="s4">: </span><span class="s2">key</span><span class="s4">,</span>
    <span class="s2">output</span><span class="s4">: </span><span class="s3">null</span><span class="s4">,</span>
    <span class="s2">decrypt</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
    <span class="s2">mode</span><span class="s4">: </span><span class="s2">mode</span>
  <span class="s4">});</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Deprecated. Instead, use:</span>
 <span class="s0">*</span>
 <span class="s0">* var decipher = forge.cipher.createDecipher('AES-&lt;mode&gt;', key);</span>
 <span class="s0">* decipher.start({iv: iv});</span>
 <span class="s0">*</span>
 <span class="s0">* Creates an AES cipher object to decrypt data using the given symmetric key.</span>
 <span class="s0">* The output will be stored in the 'output' member of the returned cipher.</span>
 <span class="s0">*</span>
 <span class="s0">* The key and iv may be given as a string of bytes, an array of bytes,</span>
 <span class="s0">* a byte buffer, or an array of 32-bit words.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">key the symmetric key to use.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">iv the initialization vector to use.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">output the buffer to write to, null to create one.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">mode the cipher mode to use (default: 'CBC').</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the cipher.</span>
 <span class="s0">*/</span>
<span class="s2">forge</span><span class="s4">.</span><span class="s2">aes</span><span class="s4">.</span><span class="s2">startDecrypting </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, </span><span class="s2">iv</span><span class="s4">, </span><span class="s2">output</span><span class="s4">, </span><span class="s2">mode</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">cipher </span><span class="s4">= </span><span class="s2">_createCipher</span><span class="s4">({</span>
    <span class="s2">key</span><span class="s4">: </span><span class="s2">key</span><span class="s4">,</span>
    <span class="s2">output</span><span class="s4">: </span><span class="s2">output</span><span class="s4">,</span>
    <span class="s2">decrypt</span><span class="s4">: </span><span class="s3">true</span><span class="s4">,</span>
    <span class="s2">mode</span><span class="s4">: </span><span class="s2">mode</span>
  <span class="s4">});</span>
  <span class="s2">cipher</span><span class="s4">.</span><span class="s2">start</span><span class="s4">(</span><span class="s2">iv</span><span class="s4">);</span>
  <span class="s3">return </span><span class="s2">cipher</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Deprecated. Instead, use:</span>
 <span class="s0">*</span>
 <span class="s0">* var decipher = forge.cipher.createDecipher('AES-&lt;mode&gt;', key);</span>
 <span class="s0">*</span>
 <span class="s0">* Creates an AES cipher object to decrypt data using the given symmetric key.</span>
 <span class="s0">*</span>
 <span class="s0">* The key may be given as a string of bytes, an array of bytes, a</span>
 <span class="s0">* byte buffer, or an array of 32-bit words.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">key the symmetric key to use.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">mode the cipher mode to use (default: 'CBC').</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the cipher.</span>
 <span class="s0">*/</span>
<span class="s2">forge</span><span class="s4">.</span><span class="s2">aes</span><span class="s4">.</span><span class="s2">createDecryptionCipher </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, </span><span class="s2">mode</span><span class="s4">) {</span>
  <span class="s3">return </span><span class="s2">_createCipher</span><span class="s4">({</span>
    <span class="s2">key</span><span class="s4">: </span><span class="s2">key</span><span class="s4">,</span>
    <span class="s2">output</span><span class="s4">: </span><span class="s3">null</span><span class="s4">,</span>
    <span class="s2">decrypt</span><span class="s4">: </span><span class="s3">true</span><span class="s4">,</span>
    <span class="s2">mode</span><span class="s4">: </span><span class="s2">mode</span>
  <span class="s4">});</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a new AES cipher algorithm object.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">name the name of the algorithm.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">mode the mode factory function.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the AES algorithm object.</span>
 <span class="s0">*/</span>
<span class="s2">forge</span><span class="s4">.</span><span class="s2">aes</span><span class="s4">.</span><span class="s2">Algorithm </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">name</span><span class="s4">, </span><span class="s2">mode</span><span class="s4">) {</span>
  <span class="s3">if</span><span class="s4">(!</span><span class="s2">init</span><span class="s4">) {</span>
    <span class="s2">initialize</span><span class="s4">();</span>
  <span class="s4">}</span>
  <span class="s3">var </span><span class="s2">self </span><span class="s4">= </span><span class="s3">this</span><span class="s4">;</span>
  <span class="s2">self</span><span class="s4">.</span><span class="s2">name </span><span class="s4">= </span><span class="s2">name</span><span class="s4">;</span>
  <span class="s2">self</span><span class="s4">.</span><span class="s2">mode </span><span class="s4">= </span><span class="s3">new </span><span class="s2">mode</span><span class="s4">({</span>
    <span class="s2">blockSize</span><span class="s4">: </span><span class="s7">16</span><span class="s4">,</span>
    <span class="s2">cipher</span><span class="s4">: {</span>
      <span class="s2">encrypt</span><span class="s4">: </span><span class="s3">function</span><span class="s4">(</span><span class="s2">inBlock</span><span class="s4">, </span><span class="s2">outBlock</span><span class="s4">) {</span>
        <span class="s3">return </span><span class="s2">_updateBlock</span><span class="s4">(</span><span class="s2">self</span><span class="s4">.</span><span class="s2">_w</span><span class="s4">, </span><span class="s2">inBlock</span><span class="s4">, </span><span class="s2">outBlock</span><span class="s4">, </span><span class="s3">false</span><span class="s4">);</span>
      <span class="s4">},</span>
      <span class="s2">decrypt</span><span class="s4">: </span><span class="s3">function</span><span class="s4">(</span><span class="s2">inBlock</span><span class="s4">, </span><span class="s2">outBlock</span><span class="s4">) {</span>
        <span class="s3">return </span><span class="s2">_updateBlock</span><span class="s4">(</span><span class="s2">self</span><span class="s4">.</span><span class="s2">_w</span><span class="s4">, </span><span class="s2">inBlock</span><span class="s4">, </span><span class="s2">outBlock</span><span class="s4">, </span><span class="s3">true</span><span class="s4">);</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
  <span class="s4">});</span>
  <span class="s2">self</span><span class="s4">.</span><span class="s2">_init </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Initializes this AES algorithm by expanding its key.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">options the options to use.</span>
 <span class="s0">*          key the key to use with this algorithm.</span>
 <span class="s0">*          decrypt true if the algorithm should be initialized for decryption,</span>
 <span class="s0">*            false for encryption.</span>
 <span class="s0">*/</span>
<span class="s2">forge</span><span class="s4">.</span><span class="s2">aes</span><span class="s4">.</span><span class="s2">Algorithm</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">initialize </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">_init</span><span class="s4">) {</span>
    <span class="s3">return</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s3">var </span><span class="s2">key </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">key</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">tmp</span><span class="s4">;</span>

  <span class="s6">/* Note: The key may be a string of bytes, an array of bytes, a byte 
    buffer, or an array of 32-bit integers. If the key is in bytes, then 
    it must be 16, 24, or 32 bytes in length. If it is in 32-bit 
    integers, it must be 4, 6, or 8 integers long. */</span>

  <span class="s3">if</span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">key </span><span class="s4">=== </span><span class="s5">'string' </span><span class="s4">&amp;&amp;</span>
    <span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">16 </span><span class="s4">|| </span><span class="s2">key</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">24 </span><span class="s4">|| </span><span class="s2">key</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">32</span><span class="s4">)) {</span>
    <span class="s6">// convert key string into byte buffer</span>
    <span class="s2">key </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">(</span><span class="s2">key</span><span class="s4">);</span>
  <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">key</span><span class="s4">) &amp;&amp;</span>
    <span class="s4">(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">16 </span><span class="s4">|| </span><span class="s2">key</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">24 </span><span class="s4">|| </span><span class="s2">key</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">32</span><span class="s4">)) {</span>
    <span class="s6">// convert key integer array into byte buffer</span>
    <span class="s2">tmp </span><span class="s4">= </span><span class="s2">key</span><span class="s4">;</span>
    <span class="s2">key </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">createBuffer</span><span class="s4">();</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">tmp</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
      <span class="s2">key</span><span class="s4">.</span><span class="s2">putByte</span><span class="s4">(</span><span class="s2">tmp</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s6">// convert key byte buffer into 32-bit integer array</span>
  <span class="s3">if</span><span class="s4">(!</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">key</span><span class="s4">)) {</span>
    <span class="s2">tmp </span><span class="s4">= </span><span class="s2">key</span><span class="s4">;</span>
    <span class="s2">key </span><span class="s4">= [];</span>

    <span class="s6">// key lengths of 16, 24, 32 bytes allowed</span>
    <span class="s3">var </span><span class="s2">len </span><span class="s4">= </span><span class="s2">tmp</span><span class="s4">.</span><span class="s2">length</span><span class="s4">();</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">len </span><span class="s4">=== </span><span class="s7">16 </span><span class="s4">|| </span><span class="s2">len </span><span class="s4">=== </span><span class="s7">24 </span><span class="s4">|| </span><span class="s2">len </span><span class="s4">=== </span><span class="s7">32</span><span class="s4">) {</span>
      <span class="s2">len </span><span class="s4">= </span><span class="s2">len </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">2</span><span class="s4">;</span>
      <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">len</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
        <span class="s2">key</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">tmp</span><span class="s4">.</span><span class="s2">getInt32</span><span class="s4">());</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
  <span class="s4">}</span>

  <span class="s6">// key must be an array of 32-bit integers by now</span>
  <span class="s3">if</span><span class="s4">(!</span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">key</span><span class="s4">) ||</span>
    <span class="s4">!(</span><span class="s2">key</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">4 </span><span class="s4">|| </span><span class="s2">key</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">6 </span><span class="s4">|| </span><span class="s2">key</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">8</span><span class="s4">)) {</span>
    <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s5">'Invalid key parameter.'</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s6">// encryption operation is always used for these modes</span>
  <span class="s3">var </span><span class="s2">mode </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">mode</span><span class="s4">.</span><span class="s2">name</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">encryptOp </span><span class="s4">= ([</span><span class="s5">'CFB'</span><span class="s4">, </span><span class="s5">'OFB'</span><span class="s4">, </span><span class="s5">'CTR'</span><span class="s4">, </span><span class="s5">'GCM'</span><span class="s4">].</span><span class="s2">indexOf</span><span class="s4">(</span><span class="s2">mode</span><span class="s4">) !== -</span><span class="s7">1</span><span class="s4">);</span>

  <span class="s6">// do key expansion</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_w </span><span class="s4">= </span><span class="s2">_expandKey</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, </span><span class="s2">options</span><span class="s4">.</span><span class="s2">decrypt </span><span class="s4">&amp;&amp; !</span><span class="s2">encryptOp</span><span class="s4">);</span>
  <span class="s3">this</span><span class="s4">.</span><span class="s2">_init </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Expands a key. Typically only used for testing.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">key the symmetric key to expand, as an array of 32-bit words.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">decrypt true to expand for decryption, false for encryption.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the expanded key.</span>
 <span class="s0">*/</span>
<span class="s2">forge</span><span class="s4">.</span><span class="s2">aes</span><span class="s4">.</span><span class="s2">_expandKey </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, </span><span class="s2">decrypt</span><span class="s4">) {</span>
  <span class="s3">if</span><span class="s4">(!</span><span class="s2">init</span><span class="s4">) {</span>
    <span class="s2">initialize</span><span class="s4">();</span>
  <span class="s4">}</span>
  <span class="s3">return </span><span class="s2">_expandKey</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, </span><span class="s2">decrypt</span><span class="s4">);</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Updates a single block. Typically only used for testing.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">w the expanded key to use.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">input an array of block-size 32-bit words.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">output an array of block-size 32-bit words.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">decrypt true to decrypt, false to encrypt.</span>
 <span class="s0">*/</span>
<span class="s2">forge</span><span class="s4">.</span><span class="s2">aes</span><span class="s4">.</span><span class="s2">_updateBlock </span><span class="s4">= </span><span class="s2">_updateBlock</span><span class="s4">;</span>

<span class="s0">/** Register AES algorithms **/</span>

<span class="s2">registerAlgorithm</span><span class="s4">(</span><span class="s5">'AES-ECB'</span><span class="s4">, </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">modes</span><span class="s4">.</span><span class="s2">ecb</span><span class="s4">);</span>
<span class="s2">registerAlgorithm</span><span class="s4">(</span><span class="s5">'AES-CBC'</span><span class="s4">, </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">modes</span><span class="s4">.</span><span class="s2">cbc</span><span class="s4">);</span>
<span class="s2">registerAlgorithm</span><span class="s4">(</span><span class="s5">'AES-CFB'</span><span class="s4">, </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">modes</span><span class="s4">.</span><span class="s2">cfb</span><span class="s4">);</span>
<span class="s2">registerAlgorithm</span><span class="s4">(</span><span class="s5">'AES-OFB'</span><span class="s4">, </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">modes</span><span class="s4">.</span><span class="s2">ofb</span><span class="s4">);</span>
<span class="s2">registerAlgorithm</span><span class="s4">(</span><span class="s5">'AES-CTR'</span><span class="s4">, </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">modes</span><span class="s4">.</span><span class="s2">ctr</span><span class="s4">);</span>
<span class="s2">registerAlgorithm</span><span class="s4">(</span><span class="s5">'AES-GCM'</span><span class="s4">, </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">modes</span><span class="s4">.</span><span class="s2">gcm</span><span class="s4">);</span>

<span class="s3">function </span><span class="s2">registerAlgorithm</span><span class="s4">(</span><span class="s2">name</span><span class="s4">, </span><span class="s2">mode</span><span class="s4">) {</span>
  <span class="s3">var </span><span class="s2">factory </span><span class="s4">= </span><span class="s3">function</span><span class="s4">() {</span>
    <span class="s3">return new </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">aes</span><span class="s4">.</span><span class="s2">Algorithm</span><span class="s4">(</span><span class="s2">name</span><span class="s4">, </span><span class="s2">mode</span><span class="s4">);</span>
  <span class="s4">};</span>
  <span class="s2">forge</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">registerAlgorithm</span><span class="s4">(</span><span class="s2">name</span><span class="s4">, </span><span class="s2">factory</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s0">/** AES implementation **/</span>

<span class="s3">var </span><span class="s2">init </span><span class="s4">= </span><span class="s3">false</span><span class="s4">; </span><span class="s6">// not yet initialized</span>
<span class="s3">var </span><span class="s2">Nb </span><span class="s4">= </span><span class="s7">4</span><span class="s4">;       </span><span class="s6">// number of words comprising the state (AES = 4)</span>
<span class="s3">var </span><span class="s2">sbox</span><span class="s4">;         </span><span class="s6">// non-linear substitution table used in key expansion</span>
<span class="s3">var </span><span class="s2">isbox</span><span class="s4">;        </span><span class="s6">// inversion of sbox</span>
<span class="s3">var </span><span class="s2">rcon</span><span class="s4">;         </span><span class="s6">// round constant word array</span>
<span class="s3">var </span><span class="s2">mix</span><span class="s4">;          </span><span class="s6">// mix-columns table</span>
<span class="s3">var </span><span class="s2">imix</span><span class="s4">;         </span><span class="s6">// inverse mix-columns table</span>

<span class="s0">/**</span>
 <span class="s0">* Performs initialization, ie: precomputes tables to optimize for speed.</span>
 <span class="s0">*</span>
 <span class="s0">* One way to understand how AES works is to imagine that 'addition' and</span>
 <span class="s0">* 'multiplication' are interfaces that require certain mathematical</span>
 <span class="s0">* properties to hold true (ie: they are associative) but they might have</span>
 <span class="s0">* different implementations and produce different kinds of results ...</span>
 <span class="s0">* provided that their mathematical properties remain true. AES defines</span>
 <span class="s0">* its own methods of addition and multiplication but keeps some important</span>
 <span class="s0">* properties the same, ie: associativity and distributivity. The</span>
 <span class="s0">* explanation below tries to shed some light on how AES defines addition</span>
 <span class="s0">* and multiplication of bytes and 32-bit words in order to perform its</span>
 <span class="s0">* encryption and decryption algorithms.</span>
 <span class="s0">*</span>
 <span class="s0">* The basics:</span>
 <span class="s0">*</span>
 <span class="s0">* The AES algorithm views bytes as binary representations of polynomials</span>
 <span class="s0">* that have either 1 or 0 as the coefficients. It defines the addition</span>
 <span class="s0">* or subtraction of two bytes as the XOR operation. It also defines the</span>
 <span class="s0">* multiplication of two bytes as a finite field referred to as GF(2^8)</span>
 <span class="s0">* (Note: 'GF' means &quot;Galois Field&quot; which is a field that contains a finite</span>
 <span class="s0">* number of elements so GF(2^8) has 256 elements).</span>
 <span class="s0">*</span>
 <span class="s0">* This means that any two bytes can be represented as binary polynomials;</span>
 <span class="s0">* when they multiplied together and modularly reduced by an irreducible</span>
 <span class="s0">* polynomial of the 8th degree, the results are the field GF(2^8). The</span>
 <span class="s0">* specific irreducible polynomial that AES uses in hexadecimal is 0x11b.</span>
 <span class="s0">* This multiplication is associative with 0x01 as the identity:</span>
 <span class="s0">*</span>
 <span class="s0">* (b * 0x01 = GF(b, 0x01) = b).</span>
 <span class="s0">*</span>
 <span class="s0">* The operation GF(b, 0x02) can be performed at the byte level by left</span>
 <span class="s0">* shifting b once and then XOR'ing it (to perform the modular reduction)</span>
 <span class="s0">* with 0x11b if b is &gt;= 128. Repeated application of the multiplication</span>
 <span class="s0">* of 0x02 can be used to implement the multiplication of any two bytes.</span>
 <span class="s0">*</span>
 <span class="s0">* For instance, multiplying 0x57 and 0x13, denoted as GF(0x57, 0x13), can</span>
 <span class="s0">* be performed by factoring 0x13 into 0x01, 0x02, and 0x10. Then these</span>
 <span class="s0">* factors can each be multiplied by 0x57 and then added together. To do</span>
 <span class="s0">* the multiplication, values for 0x57 multiplied by each of these 3 factors</span>
 <span class="s0">* can be precomputed and stored in a table. To add them, the values from</span>
 <span class="s0">* the table are XOR'd together.</span>
 <span class="s0">*</span>
 <span class="s0">* AES also defines addition and multiplication of words, that is 4-byte</span>
 <span class="s0">* numbers represented as polynomials of 3 degrees where the coefficients</span>
 <span class="s0">* are the values of the bytes.</span>
 <span class="s0">*</span>
 <span class="s0">* The word [a0, a1, a2, a3] is a polynomial a3x^3 + a2x^2 + a1x + a0.</span>
 <span class="s0">*</span>
 <span class="s0">* Addition is performed by XOR'ing like powers of x. Multiplication</span>
 <span class="s0">* is performed in two steps, the first is an algebriac expansion as</span>
 <span class="s0">* you would do normally (where addition is XOR). But the result is</span>
 <span class="s0">* a polynomial larger than 3 degrees and thus it cannot fit in a word. So</span>
 <span class="s0">* next the result is modularly reduced by an AES-specific polynomial of</span>
 <span class="s0">* degree 4 which will always produce a polynomial of less than 4 degrees</span>
 <span class="s0">* such that it will fit in a word. In AES, this polynomial is x^4 + 1.</span>
 <span class="s0">*</span>
 <span class="s0">* The modular product of two polynomials 'a' and 'b' is thus:</span>
 <span class="s0">*</span>
 <span class="s0">* d(x) = d3x^3 + d2x^2 + d1x + d0</span>
 <span class="s0">* with</span>
 <span class="s0">* d0 = GF(a0, b0) ^ GF(a3, b1) ^ GF(a2, b2) ^ GF(a1, b3)</span>
 <span class="s0">* d1 = GF(a1, b0) ^ GF(a0, b1) ^ GF(a3, b2) ^ GF(a2, b3)</span>
 <span class="s0">* d2 = GF(a2, b0) ^ GF(a1, b1) ^ GF(a0, b2) ^ GF(a3, b3)</span>
 <span class="s0">* d3 = GF(a3, b0) ^ GF(a2, b1) ^ GF(a1, b2) ^ GF(a0, b3)</span>
 <span class="s0">*</span>
 <span class="s0">* As a matrix:</span>
 <span class="s0">*</span>
 <span class="s0">* [d0] = [a0 a3 a2 a1][b0]</span>
 <span class="s0">* [d1]   [a1 a0 a3 a2][b1]</span>
 <span class="s0">* [d2]   [a2 a1 a0 a3][b2]</span>
 <span class="s0">* [d3]   [a3 a2 a1 a0][b3]</span>
 <span class="s0">*</span>
 <span class="s0">* Special polynomials defined by AES (0x02 == {02}):</span>
 <span class="s0">* a(x)    = {03}x^3 + {01}x^2 + {01}x + {02}</span>
 <span class="s0">* a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}.</span>
 <span class="s0">*</span>
 <span class="s0">* These polynomials are used in the MixColumns() and InverseMixColumns()</span>
 <span class="s0">* operations, respectively, to cause each element in the state to affect</span>
 <span class="s0">* the output (referred to as diffusing).</span>
 <span class="s0">*</span>
 <span class="s0">* RotWord() uses: a0 = a1 = a2 = {00} and a3 = {01}, which is the</span>
 <span class="s0">* polynomial x3.</span>
 <span class="s0">*</span>
 <span class="s0">* The ShiftRows() method modifies the last 3 rows in the state (where</span>
 <span class="s0">* the state is 4 words with 4 bytes per word) by shifting bytes cyclically.</span>
 <span class="s0">* The 1st byte in the second row is moved to the end of the row. The 1st</span>
 <span class="s0">* and 2nd bytes in the third row are moved to the end of the row. The 1st,</span>
 <span class="s0">* 2nd, and 3rd bytes are moved in the fourth row.</span>
 <span class="s0">*</span>
 <span class="s0">* More details on how AES arithmetic works:</span>
 <span class="s0">*</span>
 <span class="s0">* In the polynomial representation of binary numbers, XOR performs addition</span>
 <span class="s0">* and subtraction and multiplication in GF(2^8) denoted as GF(a, b)</span>
 <span class="s0">* corresponds with the multiplication of polynomials modulo an irreducible</span>
 <span class="s0">* polynomial of degree 8. In other words, for AES, GF(a, b) will multiply</span>
 <span class="s0">* polynomial 'a' with polynomial 'b' and then do a modular reduction by</span>
 <span class="s0">* an AES-specific irreducible polynomial of degree 8.</span>
 <span class="s0">*</span>
 <span class="s0">* A polynomial is irreducible if its only divisors are one and itself. For</span>
 <span class="s0">* the AES algorithm, this irreducible polynomial is:</span>
 <span class="s0">*</span>
 <span class="s0">* m(x) = x^8 + x^4 + x^3 + x + 1,</span>
 <span class="s0">*</span>
 <span class="s0">* or {01}{1b} in hexadecimal notation, where each coefficient is a bit:</span>
 <span class="s0">* 100011011 = 283 = 0x11b.</span>
 <span class="s0">*</span>
 <span class="s0">* For example, GF(0x57, 0x83) = 0xc1 because</span>
 <span class="s0">*</span>
 <span class="s0">* 0x57 = 87  = 01010111 = x^6 + x^4 + x^2 + x + 1</span>
 <span class="s0">* 0x85 = 131 = 10000101 = x^7 + x + 1</span>
 <span class="s0">*</span>
 <span class="s0">* (x^6 + x^4 + x^2 + x + 1) * (x^7 + x + 1)</span>
 <span class="s0">* =  x^13 + x^11 + x^9 + x^8 + x^7 +</span>
 <span class="s0">*    x^7 + x^5 + x^3 + x^2 + x +</span>
 <span class="s0">*    x^6 + x^4 + x^2 + x + 1</span>
 <span class="s0">* =  x^13 + x^11 + x^9 + x^8 + x^6 + x^5 + x^4 + x^3 + 1 = y</span>
 <span class="s0">*    y modulo (x^8 + x^4 + x^3 + x + 1)</span>
 <span class="s0">* =  x^7 + x^6 + 1.</span>
 <span class="s0">*</span>
 <span class="s0">* The modular reduction by m(x) guarantees the result will be a binary</span>
 <span class="s0">* polynomial of less than degree 8, so that it can fit in a byte.</span>
 <span class="s0">*</span>
 <span class="s0">* The operation to multiply a binary polynomial b with x (the polynomial</span>
 <span class="s0">* x in binary representation is 00000010) is:</span>
 <span class="s0">*</span>
 <span class="s0">* b_7x^8 + b_6x^7 + b_5x^6 + b_4x^5 + b_3x^4 + b_2x^3 + b_1x^2 + b_0x^1</span>
 <span class="s0">*</span>
 <span class="s0">* To get GF(b, x) we must reduce that by m(x). If b_7 is 0 (that is the</span>
 <span class="s0">* most significant bit is 0 in b) then the result is already reduced. If</span>
 <span class="s0">* it is 1, then we can reduce it by subtracting m(x) via an XOR.</span>
 <span class="s0">*</span>
 <span class="s0">* It follows that multiplication by x (00000010 or 0x02) can be implemented</span>
 <span class="s0">* by performing a left shift followed by a conditional bitwise XOR with</span>
 <span class="s0">* 0x1b. This operation on bytes is denoted by xtime(). Multiplication by</span>
 <span class="s0">* higher powers of x can be implemented by repeated application of xtime().</span>
 <span class="s0">*</span>
 <span class="s0">* By adding intermediate results, multiplication by any constant can be</span>
 <span class="s0">* implemented. For instance:</span>
 <span class="s0">*</span>
 <span class="s0">* GF(0x57, 0x13) = 0xfe because:</span>
 <span class="s0">*</span>
 <span class="s0">* xtime(b) = (b &amp; 128) ? (b &lt;&lt; 1 ^ 0x11b) : (b &lt;&lt; 1)</span>
 <span class="s0">*</span>
 <span class="s0">* Note: We XOR with 0x11b instead of 0x1b because in javascript our</span>
 <span class="s0">* datatype for b can be larger than 1 byte, so a left shift will not</span>
 <span class="s0">* automatically eliminate bits that overflow a byte ... by XOR'ing the</span>
 <span class="s0">* overflow bit with 1 (the extra one from 0x11b) we zero it out.</span>
 <span class="s0">*</span>
 <span class="s0">* GF(0x57, 0x02) = xtime(0x57) = 0xae</span>
 <span class="s0">* GF(0x57, 0x04) = xtime(0xae) = 0x47</span>
 <span class="s0">* GF(0x57, 0x08) = xtime(0x47) = 0x8e</span>
 <span class="s0">* GF(0x57, 0x10) = xtime(0x8e) = 0x07</span>
 <span class="s0">*</span>
 <span class="s0">* GF(0x57, 0x13) = GF(0x57, (0x01 ^ 0x02 ^ 0x10))</span>
 <span class="s0">*</span>
 <span class="s0">* And by the distributive property (since XOR is addition and GF() is</span>
 <span class="s0">* multiplication):</span>
 <span class="s0">*</span>
 <span class="s0">* = GF(0x57, 0x01) ^ GF(0x57, 0x02) ^ GF(0x57, 0x10)</span>
 <span class="s0">* = 0x57 ^ 0xae ^ 0x07</span>
 <span class="s0">* = 0xfe.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">initialize</span><span class="s4">() {</span>
  <span class="s2">init </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>

  <span class="s6">/* Populate the Rcon table. These are the values given by 
    [x^(i-1),{00},{00},{00}] where x^(i-1) are powers of x (and x = 0x02) 
    in the field of GF(2^8), where i starts at 1. 
 
    rcon[0] = [0x00, 0x00, 0x00, 0x00] 
    rcon[1] = [0x01, 0x00, 0x00, 0x00] 2^(1-1) = 2^0 = 1 
    rcon[2] = [0x02, 0x00, 0x00, 0x00] 2^(2-1) = 2^1 = 2 
    ... 
    rcon[9]  = [0x1B, 0x00, 0x00, 0x00] 2^(9-1)  = 2^8 = 0x1B 
    rcon[10] = [0x36, 0x00, 0x00, 0x00] 2^(10-1) = 2^9 = 0x36 
 
    We only store the first byte because it is the only one used. 
  */</span>
  <span class="s2">rcon </span><span class="s4">= [</span><span class="s7">0x00</span><span class="s4">, </span><span class="s7">0x01</span><span class="s4">, </span><span class="s7">0x02</span><span class="s4">, </span><span class="s7">0x04</span><span class="s4">, </span><span class="s7">0x08</span><span class="s4">, </span><span class="s7">0x10</span><span class="s4">, </span><span class="s7">0x20</span><span class="s4">, </span><span class="s7">0x40</span><span class="s4">, </span><span class="s7">0x80</span><span class="s4">, </span><span class="s7">0x1B</span><span class="s4">, </span><span class="s7">0x36</span><span class="s4">];</span>

  <span class="s6">// compute xtime table which maps i onto GF(i, 0x02)</span>
  <span class="s3">var </span><span class="s2">xtime </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s7">256</span><span class="s4">);</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s7">128</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s2">xtime</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s2">i </span><span class="s4">&lt;&lt; </span><span class="s7">1</span><span class="s4">;</span>
    <span class="s2">xtime</span><span class="s4">[</span><span class="s2">i </span><span class="s4">+ </span><span class="s7">128</span><span class="s4">] = (</span><span class="s2">i </span><span class="s4">+ </span><span class="s7">128</span><span class="s4">) &lt;&lt; </span><span class="s7">1 </span><span class="s4">^ </span><span class="s7">0x11B</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">// compute all other tables</span>
  <span class="s2">sbox </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s7">256</span><span class="s4">);</span>
  <span class="s2">isbox </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s7">256</span><span class="s4">);</span>
  <span class="s2">mix </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s7">4</span><span class="s4">);</span>
  <span class="s2">imix </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s7">4</span><span class="s4">);</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s7">4</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s2">mix</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s7">256</span><span class="s4">);</span>
    <span class="s2">imix</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s7">256</span><span class="s4">);</span>
  <span class="s4">}</span>
  <span class="s3">var </span><span class="s2">e </span><span class="s4">= </span><span class="s7">0</span><span class="s4">, </span><span class="s2">ei </span><span class="s4">= </span><span class="s7">0</span><span class="s4">, </span><span class="s2">e2</span><span class="s4">, </span><span class="s2">e4</span><span class="s4">, </span><span class="s2">e8</span><span class="s4">, </span><span class="s2">sx</span><span class="s4">, </span><span class="s2">sx2</span><span class="s4">, </span><span class="s2">me</span><span class="s4">, </span><span class="s2">ime</span><span class="s4">;</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s7">256</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s6">/* We need to generate the SubBytes() sbox and isbox tables so that 
      we can perform byte substitutions. This requires us to traverse 
      all of the elements in GF, find their multiplicative inverses, 
      and apply to each the following affine transformation: 
 
      bi' = bi ^ b(i + 4) mod 8 ^ b(i + 5) mod 8 ^ b(i + 6) mod 8 ^ 
            b(i + 7) mod 8 ^ ci 
      for 0 &lt;= i &lt; 8, where bi is the ith bit of the byte, and ci is the 
      ith bit of a byte c with the value {63} or {01100011}. 
 
      It is possible to traverse every possible value in a Galois field 
      using what is referred to as a 'generator'. There are many 
      generators (128 out of 256): 3,5,6,9,11,82 to name a few. To fully 
      traverse GF we iterate 255 times, multiplying by our generator 
      each time. 
 
      On each iteration we can determine the multiplicative inverse for 
      the current element. 
 
      Suppose there is an element in GF 'e'. For a given generator 'g', 
      e = g^x. The multiplicative inverse of e is g^(255 - x). It turns 
      out that if use the inverse of a generator as another generator 
      it will produce all of the corresponding multiplicative inverses 
      at the same time. For this reason, we choose 5 as our inverse 
      generator because it only requires 2 multiplies and 1 add and its 
      inverse, 82, requires relatively few operations as well. 
 
      In order to apply the affine transformation, the multiplicative 
      inverse 'ei' of 'e' can be repeatedly XOR'd (4 times) with a 
      bit-cycling of 'ei'. To do this 'ei' is first stored in 's' and 
      'x'. Then 's' is left shifted and the high bit of 's' is made the 
      low bit. The resulting value is stored in 's'. Then 'x' is XOR'd 
      with 's' and stored in 'x'. On each subsequent iteration the same 
      operation is performed. When 4 iterations are complete, 'x' is 
      XOR'd with 'c' (0x63) and the transformed value is stored in 'x'. 
      For example: 
 
      s = 01000001 
      x = 01000001 
 
      iteration 1: s = 10000010, x ^= s 
      iteration 2: s = 00000101, x ^= s 
      iteration 3: s = 00001010, x ^= s 
      iteration 4: s = 00010100, x ^= s 
      x ^= 0x63 
 
      This can be done with a loop where s = (s &lt;&lt; 1) | (s &gt;&gt; 7). However, 
      it can also be done by using a single 16-bit (in this case 32-bit) 
      number 'sx'. Since XOR is an associative operation, we can set 'sx' 
      to 'ei' and then XOR it with 'sx' left-shifted 1,2,3, and 4 times. 
      The most significant bits will flow into the high 8 bit positions 
      and be correctly XOR'd with one another. All that remains will be 
      to cycle the high 8 bits by XOR'ing them all with the lower 8 bits 
      afterwards. 
 
      At the same time we're populating sbox and isbox we can precompute 
      the multiplication we'll need to do to do MixColumns() later. 
    */</span>

    <span class="s6">// apply affine transformation</span>
    <span class="s2">sx </span><span class="s4">= </span><span class="s2">ei </span><span class="s4">^ (</span><span class="s2">ei </span><span class="s4">&lt;&lt; </span><span class="s7">1</span><span class="s4">) ^ (</span><span class="s2">ei </span><span class="s4">&lt;&lt; </span><span class="s7">2</span><span class="s4">) ^ (</span><span class="s2">ei </span><span class="s4">&lt;&lt; </span><span class="s7">3</span><span class="s4">) ^ (</span><span class="s2">ei </span><span class="s4">&lt;&lt; </span><span class="s7">4</span><span class="s4">);</span>
    <span class="s2">sx </span><span class="s4">= (</span><span class="s2">sx </span><span class="s4">&gt;&gt; </span><span class="s7">8</span><span class="s4">) ^ (</span><span class="s2">sx </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">) ^ </span><span class="s7">0x63</span><span class="s4">;</span>

    <span class="s6">// update tables</span>
    <span class="s2">sbox</span><span class="s4">[</span><span class="s2">e</span><span class="s4">] = </span><span class="s2">sx</span><span class="s4">;</span>
    <span class="s2">isbox</span><span class="s4">[</span><span class="s2">sx</span><span class="s4">] = </span><span class="s2">e</span><span class="s4">;</span>

    <span class="s6">/* Mixing columns is done using matrix multiplication. The columns 
      that are to be mixed are each a single word in the current state. 
      The state has Nb columns (4 columns). Therefore each column is a 
      4 byte word. So to mix the columns in a single column 'c' where 
      its rows are r0, r1, r2, and r3, we use the following matrix 
      multiplication: 
 
      [2 3 1 1]*[r0,c]=[r'0,c] 
      [1 2 3 1] [r1,c] [r'1,c] 
      [1 1 2 3] [r2,c] [r'2,c] 
      [3 1 1 2] [r3,c] [r'3,c] 
 
      r0, r1, r2, and r3 are each 1 byte of one of the words in the 
      state (a column). To do matrix multiplication for each mixed 
      column c' we multiply the corresponding row from the left matrix 
      with the corresponding column from the right matrix. In total, we 
      get 4 equations: 
 
      r0,c' = 2*r0,c + 3*r1,c + 1*r2,c + 1*r3,c 
      r1,c' = 1*r0,c + 2*r1,c + 3*r2,c + 1*r3,c 
      r2,c' = 1*r0,c + 1*r1,c + 2*r2,c + 3*r3,c 
      r3,c' = 3*r0,c + 1*r1,c + 1*r2,c + 2*r3,c 
 
      As usual, the multiplication is as previously defined and the 
      addition is XOR. In order to optimize mixing columns we can store 
      the multiplication results in tables. If you think of the whole 
      column as a word (it might help to visualize by mentally rotating 
      the equations above by counterclockwise 90 degrees) then you can 
      see that it would be useful to map the multiplications performed on 
      each byte (r0, r1, r2, r3) onto a word as well. For instance, we 
      could map 2*r0,1*r0,1*r0,3*r0 onto a word by storing 2*r0 in the 
      highest 8 bits and 3*r0 in the lowest 8 bits (with the other two 
      respectively in the middle). This means that a table can be 
      constructed that uses r0 as an index to the word. We can do the 
      same with r1, r2, and r3, creating a total of 4 tables. 
 
      To construct a full c', we can just look up each byte of c in 
      their respective tables and XOR the results together. 
 
      Also, to build each table we only have to calculate the word 
      for 2,1,1,3 for every byte ... which we can do on each iteration 
      of this loop since we will iterate over every byte. After we have 
      calculated 2,1,1,3 we can get the results for the other tables 
      by cycling the byte at the end to the beginning. For instance 
      we can take the result of table 2,1,1,3 and produce table 3,2,1,1 
      by moving the right most byte to the left most position just like 
      how you can imagine the 3 moved out of 2,1,1,3 and to the front 
      to produce 3,2,1,1. 
 
      There is another optimization in that the same multiples of 
      the current element we need in order to advance our generator 
      to the next iteration can be reused in performing the 2,1,1,3 
      calculation. We also calculate the inverse mix column tables, 
      with e,9,d,b being the inverse of 2,1,1,3. 
 
      When we're done, and we need to actually mix columns, the first 
      byte of each state word should be put through mix[0] (2,1,1,3), 
      the second through mix[1] (3,2,1,1) and so forth. Then they should 
      be XOR'd together to produce the fully mixed column. 
    */</span>

    <span class="s6">// calculate mix and imix table values</span>
    <span class="s2">sx2 </span><span class="s4">= </span><span class="s2">xtime</span><span class="s4">[</span><span class="s2">sx</span><span class="s4">];</span>
    <span class="s2">e2 </span><span class="s4">= </span><span class="s2">xtime</span><span class="s4">[</span><span class="s2">e</span><span class="s4">];</span>
    <span class="s2">e4 </span><span class="s4">= </span><span class="s2">xtime</span><span class="s4">[</span><span class="s2">e2</span><span class="s4">];</span>
    <span class="s2">e8 </span><span class="s4">= </span><span class="s2">xtime</span><span class="s4">[</span><span class="s2">e4</span><span class="s4">];</span>
    <span class="s2">me </span><span class="s4">=</span>
      <span class="s4">(</span><span class="s2">sx2 </span><span class="s4">&lt;&lt; </span><span class="s7">24</span><span class="s4">) ^  </span><span class="s6">// 2</span>
      <span class="s4">(</span><span class="s2">sx </span><span class="s4">&lt;&lt; </span><span class="s7">16</span><span class="s4">) ^   </span><span class="s6">// 1</span>
      <span class="s4">(</span><span class="s2">sx </span><span class="s4">&lt;&lt; </span><span class="s7">8</span><span class="s4">) ^    </span><span class="s6">// 1</span>
      <span class="s4">(</span><span class="s2">sx </span><span class="s4">^ </span><span class="s2">sx2</span><span class="s4">);    </span><span class="s6">// 3</span>
    <span class="s2">ime </span><span class="s4">=</span>
      <span class="s4">(</span><span class="s2">e2 </span><span class="s4">^ </span><span class="s2">e4 </span><span class="s4">^ </span><span class="s2">e8</span><span class="s4">) &lt;&lt; </span><span class="s7">24 </span><span class="s4">^  </span><span class="s6">// E (14)</span>
      <span class="s4">(</span><span class="s2">e </span><span class="s4">^ </span><span class="s2">e8</span><span class="s4">) &lt;&lt; </span><span class="s7">16 </span><span class="s4">^        </span><span class="s6">// 9</span>
      <span class="s4">(</span><span class="s2">e </span><span class="s4">^ </span><span class="s2">e4 </span><span class="s4">^ </span><span class="s2">e8</span><span class="s4">) &lt;&lt; </span><span class="s7">8 </span><span class="s4">^    </span><span class="s6">// D (13)</span>
      <span class="s4">(</span><span class="s2">e </span><span class="s4">^ </span><span class="s2">e2 </span><span class="s4">^ </span><span class="s2">e8</span><span class="s4">);          </span><span class="s6">// B (11)</span>
    <span class="s6">// produce each of the mix tables by rotating the 2,1,1,3 value</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">n </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">n </span><span class="s4">&lt; </span><span class="s7">4</span><span class="s4">; ++</span><span class="s2">n</span><span class="s4">) {</span>
      <span class="s2">mix</span><span class="s4">[</span><span class="s2">n</span><span class="s4">][</span><span class="s2">e</span><span class="s4">] = </span><span class="s2">me</span><span class="s4">;</span>
      <span class="s2">imix</span><span class="s4">[</span><span class="s2">n</span><span class="s4">][</span><span class="s2">sx</span><span class="s4">] = </span><span class="s2">ime</span><span class="s4">;</span>
      <span class="s6">// cycle the right most byte to the left most position</span>
      <span class="s6">// ie: 2,1,1,3 becomes 3,2,1,1</span>
      <span class="s2">me </span><span class="s4">= </span><span class="s2">me </span><span class="s4">&lt;&lt; </span><span class="s7">24 </span><span class="s4">| </span><span class="s2">me </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">8</span><span class="s4">;</span>
      <span class="s2">ime </span><span class="s4">= </span><span class="s2">ime </span><span class="s4">&lt;&lt; </span><span class="s7">24 </span><span class="s4">| </span><span class="s2">ime </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">8</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s6">// get next element and inverse</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">e </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
      <span class="s6">// 1 is the inverse of 1</span>
      <span class="s2">e </span><span class="s4">= </span><span class="s2">ei </span><span class="s4">= </span><span class="s7">1</span><span class="s4">;</span>
    <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
      <span class="s6">// e = 2e + 2*2*2*(10e)) = multiply e by 82 (chosen generator)</span>
      <span class="s6">// ei = ei + 2*2*ei = multiply ei by 5 (inverse generator)</span>
      <span class="s2">e </span><span class="s4">= </span><span class="s2">e2 </span><span class="s4">^ </span><span class="s2">xtime</span><span class="s4">[</span><span class="s2">xtime</span><span class="s4">[</span><span class="s2">xtime</span><span class="s4">[</span><span class="s2">e2 </span><span class="s4">^ </span><span class="s2">e8</span><span class="s4">]]];</span>
      <span class="s2">ei </span><span class="s4">^= </span><span class="s2">xtime</span><span class="s4">[</span><span class="s2">xtime</span><span class="s4">[</span><span class="s2">ei</span><span class="s4">]];</span>
    <span class="s4">}</span>
  <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Generates a key schedule using the AES key expansion algorithm.</span>
 <span class="s0">*</span>
 <span class="s0">* The AES algorithm takes the Cipher Key, K, and performs a Key Expansion</span>
 <span class="s0">* routine to generate a key schedule. The Key Expansion generates a total</span>
 <span class="s0">* of Nb*(Nr + 1) words: the algorithm requires an initial set of Nb words,</span>
 <span class="s0">* and each of the Nr rounds requires Nb words of key data. The resulting</span>
 <span class="s0">* key schedule consists of a linear array of 4-byte words, denoted [wi ],</span>
 <span class="s0">* with i in the range 0 &lt;= i &lt; Nb(Nr + 1).</span>
 <span class="s0">*</span>
 <span class="s0">* KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)</span>
 <span class="s0">* AES-128 (Nb=4, Nk=4, Nr=10)</span>
 <span class="s0">* AES-192 (Nb=4, Nk=6, Nr=12)</span>
 <span class="s0">* AES-256 (Nb=4, Nk=8, Nr=14)</span>
 <span class="s0">* Note: Nr=Nk+6.</span>
 <span class="s0">*</span>
 <span class="s0">* Nb is the number of columns (32-bit words) comprising the State (or</span>
 <span class="s0">* number of bytes in a block). For AES, Nb=4.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">key the key to schedule (as an array of 32-bit words).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">decrypt true to modify the key schedule to decrypt, false not to.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the generated key schedule.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">_expandKey</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, </span><span class="s2">decrypt</span><span class="s4">) {</span>
  <span class="s6">// copy the key's words to initialize the key schedule</span>
  <span class="s3">var </span><span class="s2">w </span><span class="s4">= </span><span class="s2">key</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s7">0</span><span class="s4">);</span>

  <span class="s6">/* RotWord() will rotate a word, moving the first byte to the last 
    byte's position (shifting the other bytes left). 
 
    We will be getting the value of Rcon at i / Nk. 'i' will iterate 
    from Nk to (Nb * Nr+1). Nk = 4 (4 byte key), Nb = 4 (4 words in 
    a block), Nr = Nk + 6 (10). Therefore 'i' will iterate from 
    4 to 44 (exclusive). Each time we iterate 4 times, i / Nk will 
    increase by 1. We use a counter iNk to keep track of this. 
   */</span>

  <span class="s6">// go through the rounds expanding the key</span>
  <span class="s3">var </span><span class="s2">temp</span><span class="s4">, </span><span class="s2">iNk </span><span class="s4">= </span><span class="s7">1</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">Nk </span><span class="s4">= </span><span class="s2">w</span><span class="s4">.</span><span class="s2">length</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">Nr1 </span><span class="s4">= </span><span class="s2">Nk </span><span class="s4">+ </span><span class="s7">6 </span><span class="s4">+ </span><span class="s7">1</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">end </span><span class="s4">= </span><span class="s2">Nb </span><span class="s4">* </span><span class="s2">Nr1</span><span class="s4">;</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s2">Nk</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">end</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s2">temp </span><span class="s4">= </span><span class="s2">w</span><span class="s4">[</span><span class="s2">i </span><span class="s4">- </span><span class="s7">1</span><span class="s4">];</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">i </span><span class="s4">% </span><span class="s2">Nk </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
      <span class="s6">// temp = SubWord(RotWord(temp)) ^ Rcon[i / Nk]</span>
      <span class="s2">temp </span><span class="s4">=</span>
        <span class="s2">sbox</span><span class="s4">[</span><span class="s2">temp </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">16 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] &lt;&lt; </span><span class="s7">24 </span><span class="s4">^</span>
        <span class="s2">sbox</span><span class="s4">[</span><span class="s2">temp </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">8 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] &lt;&lt; </span><span class="s7">16 </span><span class="s4">^</span>
        <span class="s2">sbox</span><span class="s4">[</span><span class="s2">temp </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] &lt;&lt; </span><span class="s7">8 </span><span class="s4">^</span>
        <span class="s2">sbox</span><span class="s4">[</span><span class="s2">temp </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">24</span><span class="s4">] ^ (</span><span class="s2">rcon</span><span class="s4">[</span><span class="s2">iNk</span><span class="s4">] &lt;&lt; </span><span class="s7">24</span><span class="s4">);</span>
      <span class="s2">iNk</span><span class="s4">++;</span>
    <span class="s4">} </span><span class="s3">else if</span><span class="s4">(</span><span class="s2">Nk </span><span class="s4">&gt; </span><span class="s7">6 </span><span class="s4">&amp;&amp; (</span><span class="s2">i </span><span class="s4">% </span><span class="s2">Nk </span><span class="s4">=== </span><span class="s7">4</span><span class="s4">)) {</span>
      <span class="s6">// temp = SubWord(temp)</span>
      <span class="s2">temp </span><span class="s4">=</span>
        <span class="s2">sbox</span><span class="s4">[</span><span class="s2">temp </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">24</span><span class="s4">] &lt;&lt; </span><span class="s7">24 </span><span class="s4">^</span>
        <span class="s2">sbox</span><span class="s4">[</span><span class="s2">temp </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">16 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] &lt;&lt; </span><span class="s7">16 </span><span class="s4">^</span>
        <span class="s2">sbox</span><span class="s4">[</span><span class="s2">temp </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">8 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] &lt;&lt; </span><span class="s7">8 </span><span class="s4">^</span>
        <span class="s2">sbox</span><span class="s4">[</span><span class="s2">temp </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">];</span>
    <span class="s4">}</span>
    <span class="s2">w</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s2">w</span><span class="s4">[</span><span class="s2">i </span><span class="s4">- </span><span class="s2">Nk</span><span class="s4">] ^ </span><span class="s2">temp</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">/* When we are updating a cipher block we always use the code path for 
     encryption whether we are decrypting or not (to shorten code and 
     simplify the generation of look up tables). However, because there 
     are differences in the decryption algorithm, other than just swapping 
     in different look up tables, we must transform our key schedule to 
     account for these changes: 
 
     1. The decryption algorithm gets its key rounds in reverse order. 
     2. The decryption algorithm adds the round key before mixing columns 
       instead of afterwards. 
 
     We don't need to modify our key schedule to handle the first case, 
     we can just traverse the key schedule in reverse order when decrypting. 
 
     The second case requires a little work. 
 
     The tables we built for performing rounds will take an input and then 
     perform SubBytes() and MixColumns() or, for the decrypt version, 
     InvSubBytes() and InvMixColumns(). But the decrypt algorithm requires 
     us to AddRoundKey() before InvMixColumns(). This means we'll need to 
     apply some transformations to the round key to inverse-mix its columns 
     so they'll be correct for moving AddRoundKey() to after the state has 
     had its columns inverse-mixed. 
 
     To inverse-mix the columns of the state when we're decrypting we use a 
     lookup table that will apply InvSubBytes() and InvMixColumns() at the 
     same time. However, the round key's bytes are not inverse-substituted 
     in the decryption algorithm. To get around this problem, we can first 
     substitute the bytes in the round key so that when we apply the 
     transformation via the InvSubBytes()+InvMixColumns() table, it will 
     undo our substitution leaving us with the original value that we 
     want -- and then inverse-mix that value. 
 
     This change will correctly alter our key schedule so that we can XOR 
     each round key with our already transformed decryption state. This 
     allows us to use the same code path as the encryption algorithm. 
 
     We make one more change to the decryption key. Since the decryption 
     algorithm runs in reverse from the encryption algorithm, we reverse 
     the order of the round keys to avoid having to iterate over the key 
     schedule backwards when running the encryption algorithm later in 
     decryption mode. In addition to reversing the order of the round keys, 
     we also swap each round key's 2nd and 4th rows. See the comments 
     section where rounds are performed for more details about why this is 
     done. These changes are done inline with the other substitution 
     described above. 
  */</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">decrypt</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">tmp</span><span class="s4">;</span>
    <span class="s3">var </span><span class="s2">m0 </span><span class="s4">= </span><span class="s2">imix</span><span class="s4">[</span><span class="s7">0</span><span class="s4">];</span>
    <span class="s3">var </span><span class="s2">m1 </span><span class="s4">= </span><span class="s2">imix</span><span class="s4">[</span><span class="s7">1</span><span class="s4">];</span>
    <span class="s3">var </span><span class="s2">m2 </span><span class="s4">= </span><span class="s2">imix</span><span class="s4">[</span><span class="s7">2</span><span class="s4">];</span>
    <span class="s3">var </span><span class="s2">m3 </span><span class="s4">= </span><span class="s2">imix</span><span class="s4">[</span><span class="s7">3</span><span class="s4">];</span>
    <span class="s3">var </span><span class="s2">wnew </span><span class="s4">= </span><span class="s2">w</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s7">0</span><span class="s4">);</span>
    <span class="s2">end </span><span class="s4">= </span><span class="s2">w</span><span class="s4">.</span><span class="s2">length</span><span class="s4">;</span>
    <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">, </span><span class="s2">wi </span><span class="s4">= </span><span class="s2">end </span><span class="s4">- </span><span class="s2">Nb</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">end</span><span class="s4">; </span><span class="s2">i </span><span class="s4">+= </span><span class="s2">Nb</span><span class="s4">, </span><span class="s2">wi </span><span class="s4">-= </span><span class="s2">Nb</span><span class="s4">) {</span>
      <span class="s6">// do not sub the first or last round key (round keys are Nb</span>
      <span class="s6">// words) as no column mixing is performed before they are added,</span>
      <span class="s6">// but do change the key order</span>
      <span class="s3">if</span><span class="s4">(</span><span class="s2">i </span><span class="s4">=== </span><span class="s7">0 </span><span class="s4">|| </span><span class="s2">i </span><span class="s4">=== (</span><span class="s2">end </span><span class="s4">- </span><span class="s2">Nb</span><span class="s4">)) {</span>
        <span class="s2">wnew</span><span class="s4">[</span><span class="s2">i</span><span class="s4">] = </span><span class="s2">w</span><span class="s4">[</span><span class="s2">wi</span><span class="s4">];</span>
        <span class="s2">wnew</span><span class="s4">[</span><span class="s2">i </span><span class="s4">+ </span><span class="s7">1</span><span class="s4">] = </span><span class="s2">w</span><span class="s4">[</span><span class="s2">wi </span><span class="s4">+ </span><span class="s7">3</span><span class="s4">];</span>
        <span class="s2">wnew</span><span class="s4">[</span><span class="s2">i </span><span class="s4">+ </span><span class="s7">2</span><span class="s4">] = </span><span class="s2">w</span><span class="s4">[</span><span class="s2">wi </span><span class="s4">+ </span><span class="s7">2</span><span class="s4">];</span>
        <span class="s2">wnew</span><span class="s4">[</span><span class="s2">i </span><span class="s4">+ </span><span class="s7">3</span><span class="s4">] = </span><span class="s2">w</span><span class="s4">[</span><span class="s2">wi </span><span class="s4">+ </span><span class="s7">1</span><span class="s4">];</span>
      <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
        <span class="s6">// substitute each round key byte because the inverse-mix</span>
        <span class="s6">// table will inverse-substitute it (effectively cancel the</span>
        <span class="s6">// substitution because round key bytes aren't sub'd in</span>
        <span class="s6">// decryption mode) and swap indexes 3 and 1</span>
        <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">n </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">n </span><span class="s4">&lt; </span><span class="s2">Nb</span><span class="s4">; ++</span><span class="s2">n</span><span class="s4">) {</span>
          <span class="s2">tmp </span><span class="s4">= </span><span class="s2">w</span><span class="s4">[</span><span class="s2">wi </span><span class="s4">+ </span><span class="s2">n</span><span class="s4">];</span>
          <span class="s2">wnew</span><span class="s4">[</span><span class="s2">i </span><span class="s4">+ (</span><span class="s7">3</span><span class="s4">&amp;-</span><span class="s2">n</span><span class="s4">)] =</span>
            <span class="s2">m0</span><span class="s4">[</span><span class="s2">sbox</span><span class="s4">[</span><span class="s2">tmp </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">24</span><span class="s4">]] ^</span>
            <span class="s2">m1</span><span class="s4">[</span><span class="s2">sbox</span><span class="s4">[</span><span class="s2">tmp </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">16 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">]] ^</span>
            <span class="s2">m2</span><span class="s4">[</span><span class="s2">sbox</span><span class="s4">[</span><span class="s2">tmp </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">8 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">]] ^</span>
            <span class="s2">m3</span><span class="s4">[</span><span class="s2">sbox</span><span class="s4">[</span><span class="s2">tmp </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">]];</span>
        <span class="s4">}</span>
      <span class="s4">}</span>
    <span class="s4">}</span>
    <span class="s2">w </span><span class="s4">= </span><span class="s2">wnew</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s3">return </span><span class="s2">w</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Updates a single block (16 bytes) using AES. The update will either</span>
 <span class="s0">* encrypt or decrypt the block.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">w the key schedule.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">input the input block (an array of 32-bit words).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">output the updated output block.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">decrypt true to decrypt the block, false to encrypt it.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">_updateBlock</span><span class="s4">(</span><span class="s2">w</span><span class="s4">, </span><span class="s2">input</span><span class="s4">, </span><span class="s2">output</span><span class="s4">, </span><span class="s2">decrypt</span><span class="s4">) {</span>
  <span class="s6">/* 
  Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)]) 
  begin 
    byte state[4,Nb] 
    state = in 
    AddRoundKey(state, w[0, Nb-1]) 
    for round = 1 step 1 to Nr-1 
      SubBytes(state) 
      ShiftRows(state) 
      MixColumns(state) 
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1]) 
    end for 
    SubBytes(state) 
    ShiftRows(state) 
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1]) 
    out = state 
  end 
 
  InvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)]) 
  begin 
    byte state[4,Nb] 
    state = in 
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1]) 
    for round = Nr-1 step -1 downto 1 
      InvShiftRows(state) 
      InvSubBytes(state) 
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1]) 
      InvMixColumns(state) 
    end for 
    InvShiftRows(state) 
    InvSubBytes(state) 
    AddRoundKey(state, w[0, Nb-1]) 
    out = state 
  end 
  */</span>

  <span class="s6">// Encrypt: AddRoundKey(state, w[0, Nb-1])</span>
  <span class="s6">// Decrypt: AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])</span>
  <span class="s3">var </span><span class="s2">Nr </span><span class="s4">= </span><span class="s2">w</span><span class="s4">.</span><span class="s2">length </span><span class="s4">/ </span><span class="s7">4 </span><span class="s4">- </span><span class="s7">1</span><span class="s4">;</span>
  <span class="s3">var </span><span class="s2">m0</span><span class="s4">, </span><span class="s2">m1</span><span class="s4">, </span><span class="s2">m2</span><span class="s4">, </span><span class="s2">m3</span><span class="s4">, </span><span class="s2">sub</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">decrypt</span><span class="s4">) {</span>
    <span class="s2">m0 </span><span class="s4">= </span><span class="s2">imix</span><span class="s4">[</span><span class="s7">0</span><span class="s4">];</span>
    <span class="s2">m1 </span><span class="s4">= </span><span class="s2">imix</span><span class="s4">[</span><span class="s7">1</span><span class="s4">];</span>
    <span class="s2">m2 </span><span class="s4">= </span><span class="s2">imix</span><span class="s4">[</span><span class="s7">2</span><span class="s4">];</span>
    <span class="s2">m3 </span><span class="s4">= </span><span class="s2">imix</span><span class="s4">[</span><span class="s7">3</span><span class="s4">];</span>
    <span class="s2">sub </span><span class="s4">= </span><span class="s2">isbox</span><span class="s4">;</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s2">m0 </span><span class="s4">= </span><span class="s2">mix</span><span class="s4">[</span><span class="s7">0</span><span class="s4">];</span>
    <span class="s2">m1 </span><span class="s4">= </span><span class="s2">mix</span><span class="s4">[</span><span class="s7">1</span><span class="s4">];</span>
    <span class="s2">m2 </span><span class="s4">= </span><span class="s2">mix</span><span class="s4">[</span><span class="s7">2</span><span class="s4">];</span>
    <span class="s2">m3 </span><span class="s4">= </span><span class="s2">mix</span><span class="s4">[</span><span class="s7">3</span><span class="s4">];</span>
    <span class="s2">sub </span><span class="s4">= </span><span class="s2">sbox</span><span class="s4">;</span>
  <span class="s4">}</span>
  <span class="s3">var </span><span class="s2">a</span><span class="s4">, </span><span class="s2">b</span><span class="s4">, </span><span class="s2">c</span><span class="s4">, </span><span class="s2">d</span><span class="s4">, </span><span class="s2">a2</span><span class="s4">, </span><span class="s2">b2</span><span class="s4">, </span><span class="s2">c2</span><span class="s4">;</span>
  <span class="s2">a </span><span class="s4">= </span><span class="s2">input</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] ^ </span><span class="s2">w</span><span class="s4">[</span><span class="s7">0</span><span class="s4">];</span>
  <span class="s2">b </span><span class="s4">= </span><span class="s2">input</span><span class="s4">[</span><span class="s2">decrypt </span><span class="s4">? </span><span class="s7">3 </span><span class="s4">: </span><span class="s7">1</span><span class="s4">] ^ </span><span class="s2">w</span><span class="s4">[</span><span class="s7">1</span><span class="s4">];</span>
  <span class="s2">c </span><span class="s4">= </span><span class="s2">input</span><span class="s4">[</span><span class="s7">2</span><span class="s4">] ^ </span><span class="s2">w</span><span class="s4">[</span><span class="s7">2</span><span class="s4">];</span>
  <span class="s2">d </span><span class="s4">= </span><span class="s2">input</span><span class="s4">[</span><span class="s2">decrypt </span><span class="s4">? </span><span class="s7">1 </span><span class="s4">: </span><span class="s7">3</span><span class="s4">] ^ </span><span class="s2">w</span><span class="s4">[</span><span class="s7">3</span><span class="s4">];</span>
  <span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">3</span><span class="s4">;</span>

  <span class="s6">/* In order to share code we follow the encryption algorithm when both 
    encrypting and decrypting. To account for the changes required in the 
    decryption algorithm, we use different lookup tables when decrypting 
    and use a modified key schedule to account for the difference in the 
    order of transformations applied when performing rounds. We also get 
    key rounds in reverse order (relative to encryption). */</span>
  <span class="s3">for</span><span class="s4">(</span><span class="s3">var </span><span class="s2">round </span><span class="s4">= </span><span class="s7">1</span><span class="s4">; </span><span class="s2">round </span><span class="s4">&lt; </span><span class="s2">Nr</span><span class="s4">; ++</span><span class="s2">round</span><span class="s4">) {</span>
    <span class="s6">/* As described above, we'll be using table lookups to perform the 
      column mixing. Each column is stored as a word in the state (the 
      array 'input' has one column as a word at each index). In order to 
      mix a column, we perform these transformations on each row in c, 
      which is 1 byte in each word. The new column for c0 is c'0: 
 
               m0      m1      m2      m3 
      r0,c'0 = 2*r0,c0 + 3*r1,c0 + 1*r2,c0 + 1*r3,c0 
      r1,c'0 = 1*r0,c0 + 2*r1,c0 + 3*r2,c0 + 1*r3,c0 
      r2,c'0 = 1*r0,c0 + 1*r1,c0 + 2*r2,c0 + 3*r3,c0 
      r3,c'0 = 3*r0,c0 + 1*r1,c0 + 1*r2,c0 + 2*r3,c0 
 
      So using mix tables where c0 is a word with r0 being its upper 
      8 bits and r3 being its lower 8 bits: 
 
      m0[c0 &gt;&gt; 24] will yield this word: [2*r0,1*r0,1*r0,3*r0] 
      ... 
      m3[c0 &amp; 255] will yield this word: [1*r3,1*r3,3*r3,2*r3] 
 
      Therefore to mix the columns in each word in the state we 
      do the following (&amp; 255 omitted for brevity): 
      c'0,r0 = m0[c0 &gt;&gt; 24] ^ m1[c1 &gt;&gt; 16] ^ m2[c2 &gt;&gt; 8] ^ m3[c3] 
      c'0,r1 = m0[c0 &gt;&gt; 24] ^ m1[c1 &gt;&gt; 16] ^ m2[c2 &gt;&gt; 8] ^ m3[c3] 
      c'0,r2 = m0[c0 &gt;&gt; 24] ^ m1[c1 &gt;&gt; 16] ^ m2[c2 &gt;&gt; 8] ^ m3[c3] 
      c'0,r3 = m0[c0 &gt;&gt; 24] ^ m1[c1 &gt;&gt; 16] ^ m2[c2 &gt;&gt; 8] ^ m3[c3] 
 
      However, before mixing, the algorithm requires us to perform 
      ShiftRows(). The ShiftRows() transformation cyclically shifts the 
      last 3 rows of the state over different offsets. The first row 
      (r = 0) is not shifted. 
 
      s'_r,c = s_r,(c + shift(r, Nb) mod Nb 
      for 0 &lt; r &lt; 4 and 0 &lt;= c &lt; Nb and 
      shift(1, 4) = 1 
      shift(2, 4) = 2 
      shift(3, 4) = 3. 
 
      This causes the first byte in r = 1 to be moved to the end of 
      the row, the first 2 bytes in r = 2 to be moved to the end of 
      the row, the first 3 bytes in r = 3 to be moved to the end of 
      the row: 
 
      r1: [c0 c1 c2 c3] =&gt; [c1 c2 c3 c0] 
      r2: [c0 c1 c2 c3]    [c2 c3 c0 c1] 
      r3: [c0 c1 c2 c3]    [c3 c0 c1 c2] 
 
      We can make these substitutions inline with our column mixing to 
      generate an updated set of equations to produce each word in the 
      state (note the columns have changed positions): 
 
      c0 c1 c2 c3 =&gt; c0 c1 c2 c3 
      c0 c1 c2 c3    c1 c2 c3 c0  (cycled 1 byte) 
      c0 c1 c2 c3    c2 c3 c0 c1  (cycled 2 bytes) 
      c0 c1 c2 c3    c3 c0 c1 c2  (cycled 3 bytes) 
 
      Therefore: 
 
      c'0 = 2*r0,c0 + 3*r1,c1 + 1*r2,c2 + 1*r3,c3 
      c'0 = 1*r0,c0 + 2*r1,c1 + 3*r2,c2 + 1*r3,c3 
      c'0 = 1*r0,c0 + 1*r1,c1 + 2*r2,c2 + 3*r3,c3 
      c'0 = 3*r0,c0 + 1*r1,c1 + 1*r2,c2 + 2*r3,c3 
 
      c'1 = 2*r0,c1 + 3*r1,c2 + 1*r2,c3 + 1*r3,c0 
      c'1 = 1*r0,c1 + 2*r1,c2 + 3*r2,c3 + 1*r3,c0 
      c'1 = 1*r0,c1 + 1*r1,c2 + 2*r2,c3 + 3*r3,c0 
      c'1 = 3*r0,c1 + 1*r1,c2 + 1*r2,c3 + 2*r3,c0 
 
      ... and so forth for c'2 and c'3. The important distinction is 
      that the columns are cycling, with c0 being used with the m0 
      map when calculating c0, but c1 being used with the m0 map when 
      calculating c1 ... and so forth. 
 
      When performing the inverse we transform the mirror image and 
      skip the bottom row, instead of the top one, and move upwards: 
 
      c3 c2 c1 c0 =&gt; c0 c3 c2 c1  (cycled 3 bytes) *same as encryption 
      c3 c2 c1 c0    c1 c0 c3 c2  (cycled 2 bytes) 
      c3 c2 c1 c0    c2 c1 c0 c3  (cycled 1 byte)  *same as encryption 
      c3 c2 c1 c0    c3 c2 c1 c0 
 
      If you compare the resulting matrices for ShiftRows()+MixColumns() 
      and for InvShiftRows()+InvMixColumns() the 2nd and 4th columns are 
      different (in encrypt mode vs. decrypt mode). So in order to use 
      the same code to handle both encryption and decryption, we will 
      need to do some mapping. 
 
      If in encryption mode we let a=c0, b=c1, c=c2, d=c3, and r&lt;N&gt; be 
      a row number in the state, then the resulting matrix in encryption 
      mode for applying the above transformations would be: 
 
      r1: a b c d 
      r2: b c d a 
      r3: c d a b 
      r4: d a b c 
 
      If we did the same in decryption mode we would get: 
 
      r1: a d c b 
      r2: b a d c 
      r3: c b a d 
      r4: d c b a 
 
      If instead we swap d and b (set b=c3 and d=c1), then we get: 
 
      r1: a b c d 
      r2: d a b c 
      r3: c d a b 
      r4: b c d a 
 
      Now the 1st and 3rd rows are the same as the encryption matrix. All 
      we need to do then to make the mapping exactly the same is to swap 
      the 2nd and 4th rows when in decryption mode. To do this without 
      having to do it on each iteration, we swapped the 2nd and 4th rows 
      in the decryption key schedule. We also have to do the swap above 
      when we first pull in the input and when we set the final output. */</span>
    <span class="s2">a2 </span><span class="s4">=</span>
      <span class="s2">m0</span><span class="s4">[</span><span class="s2">a </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">24</span><span class="s4">] ^</span>
      <span class="s2">m1</span><span class="s4">[</span><span class="s2">b </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">16 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] ^</span>
      <span class="s2">m2</span><span class="s4">[</span><span class="s2">c </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">8 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] ^</span>
      <span class="s2">m3</span><span class="s4">[</span><span class="s2">d </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] ^ </span><span class="s2">w</span><span class="s4">[++</span><span class="s2">i</span><span class="s4">];</span>
    <span class="s2">b2 </span><span class="s4">=</span>
      <span class="s2">m0</span><span class="s4">[</span><span class="s2">b </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">24</span><span class="s4">] ^</span>
      <span class="s2">m1</span><span class="s4">[</span><span class="s2">c </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">16 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] ^</span>
      <span class="s2">m2</span><span class="s4">[</span><span class="s2">d </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">8 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] ^</span>
      <span class="s2">m3</span><span class="s4">[</span><span class="s2">a </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] ^ </span><span class="s2">w</span><span class="s4">[++</span><span class="s2">i</span><span class="s4">];</span>
    <span class="s2">c2 </span><span class="s4">=</span>
      <span class="s2">m0</span><span class="s4">[</span><span class="s2">c </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">24</span><span class="s4">] ^</span>
      <span class="s2">m1</span><span class="s4">[</span><span class="s2">d </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">16 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] ^</span>
      <span class="s2">m2</span><span class="s4">[</span><span class="s2">a </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">8 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] ^</span>
      <span class="s2">m3</span><span class="s4">[</span><span class="s2">b </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] ^ </span><span class="s2">w</span><span class="s4">[++</span><span class="s2">i</span><span class="s4">];</span>
    <span class="s2">d </span><span class="s4">=</span>
      <span class="s2">m0</span><span class="s4">[</span><span class="s2">d </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">24</span><span class="s4">] ^</span>
      <span class="s2">m1</span><span class="s4">[</span><span class="s2">a </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">16 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] ^</span>
      <span class="s2">m2</span><span class="s4">[</span><span class="s2">b </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">8 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] ^</span>
      <span class="s2">m3</span><span class="s4">[</span><span class="s2">c </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] ^ </span><span class="s2">w</span><span class="s4">[++</span><span class="s2">i</span><span class="s4">];</span>
    <span class="s2">a </span><span class="s4">= </span><span class="s2">a2</span><span class="s4">;</span>
    <span class="s2">b </span><span class="s4">= </span><span class="s2">b2</span><span class="s4">;</span>
    <span class="s2">c </span><span class="s4">= </span><span class="s2">c2</span><span class="s4">;</span>
  <span class="s4">}</span>

  <span class="s6">/* 
    Encrypt: 
    SubBytes(state) 
    ShiftRows(state) 
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1]) 
 
    Decrypt: 
    InvShiftRows(state) 
    InvSubBytes(state) 
    AddRoundKey(state, w[0, Nb-1]) 
   */</span>
  <span class="s6">// Note: rows are shifted inline</span>
  <span class="s2">output</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] =</span>
    <span class="s4">(</span><span class="s2">sub</span><span class="s4">[</span><span class="s2">a </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">24</span><span class="s4">] &lt;&lt; </span><span class="s7">24</span><span class="s4">) ^</span>
    <span class="s4">(</span><span class="s2">sub</span><span class="s4">[</span><span class="s2">b </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">16 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] &lt;&lt; </span><span class="s7">16</span><span class="s4">) ^</span>
    <span class="s4">(</span><span class="s2">sub</span><span class="s4">[</span><span class="s2">c </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">8 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] &lt;&lt; </span><span class="s7">8</span><span class="s4">) ^</span>
    <span class="s4">(</span><span class="s2">sub</span><span class="s4">[</span><span class="s2">d </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">]) ^ </span><span class="s2">w</span><span class="s4">[++</span><span class="s2">i</span><span class="s4">];</span>
  <span class="s2">output</span><span class="s4">[</span><span class="s2">decrypt </span><span class="s4">? </span><span class="s7">3 </span><span class="s4">: </span><span class="s7">1</span><span class="s4">] =</span>
    <span class="s4">(</span><span class="s2">sub</span><span class="s4">[</span><span class="s2">b </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">24</span><span class="s4">] &lt;&lt; </span><span class="s7">24</span><span class="s4">) ^</span>
    <span class="s4">(</span><span class="s2">sub</span><span class="s4">[</span><span class="s2">c </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">16 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] &lt;&lt; </span><span class="s7">16</span><span class="s4">) ^</span>
    <span class="s4">(</span><span class="s2">sub</span><span class="s4">[</span><span class="s2">d </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">8 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] &lt;&lt; </span><span class="s7">8</span><span class="s4">) ^</span>
    <span class="s4">(</span><span class="s2">sub</span><span class="s4">[</span><span class="s2">a </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">]) ^ </span><span class="s2">w</span><span class="s4">[++</span><span class="s2">i</span><span class="s4">];</span>
  <span class="s2">output</span><span class="s4">[</span><span class="s7">2</span><span class="s4">] =</span>
    <span class="s4">(</span><span class="s2">sub</span><span class="s4">[</span><span class="s2">c </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">24</span><span class="s4">] &lt;&lt; </span><span class="s7">24</span><span class="s4">) ^</span>
    <span class="s4">(</span><span class="s2">sub</span><span class="s4">[</span><span class="s2">d </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">16 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] &lt;&lt; </span><span class="s7">16</span><span class="s4">) ^</span>
    <span class="s4">(</span><span class="s2">sub</span><span class="s4">[</span><span class="s2">a </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">8 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] &lt;&lt; </span><span class="s7">8</span><span class="s4">) ^</span>
    <span class="s4">(</span><span class="s2">sub</span><span class="s4">[</span><span class="s2">b </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">]) ^ </span><span class="s2">w</span><span class="s4">[++</span><span class="s2">i</span><span class="s4">];</span>
  <span class="s2">output</span><span class="s4">[</span><span class="s2">decrypt </span><span class="s4">? </span><span class="s7">1 </span><span class="s4">: </span><span class="s7">3</span><span class="s4">] =</span>
    <span class="s4">(</span><span class="s2">sub</span><span class="s4">[</span><span class="s2">d </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">24</span><span class="s4">] &lt;&lt; </span><span class="s7">24</span><span class="s4">) ^</span>
    <span class="s4">(</span><span class="s2">sub</span><span class="s4">[</span><span class="s2">a </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">16 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] &lt;&lt; </span><span class="s7">16</span><span class="s4">) ^</span>
    <span class="s4">(</span><span class="s2">sub</span><span class="s4">[</span><span class="s2">b </span><span class="s4">&gt;&gt;&gt; </span><span class="s7">8 </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">] &lt;&lt; </span><span class="s7">8</span><span class="s4">) ^</span>
    <span class="s4">(</span><span class="s2">sub</span><span class="s4">[</span><span class="s2">c </span><span class="s4">&amp; </span><span class="s7">255</span><span class="s4">]) ^ </span><span class="s2">w</span><span class="s4">[++</span><span class="s2">i</span><span class="s4">];</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Deprecated. Instead, use:</span>
 <span class="s0">*</span>
 <span class="s0">* forge.cipher.createCipher('AES-&lt;mode&gt;', key);</span>
 <span class="s0">* forge.cipher.createDecipher('AES-&lt;mode&gt;', key);</span>
 <span class="s0">*</span>
 <span class="s0">* Creates a deprecated AES cipher object. This object's mode will default to</span>
 <span class="s0">* CBC (cipher-block-chaining).</span>
 <span class="s0">*</span>
 <span class="s0">* The key and iv may be given as a string of bytes, an array of bytes, a</span>
 <span class="s0">* byte buffer, or an array of 32-bit words.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">options the options to use.</span>
 <span class="s0">*          key the symmetric key to use.</span>
 <span class="s0">*          output the buffer to write to.</span>
 <span class="s0">*          decrypt true for decryption, false for encryption.</span>
 <span class="s0">*          mode the cipher mode to use (default: 'CBC').</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">the cipher.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">_createCipher</span><span class="s4">(</span><span class="s2">options</span><span class="s4">) {</span>
  <span class="s2">options </span><span class="s4">= </span><span class="s2">options </span><span class="s4">|| {};</span>
  <span class="s3">var </span><span class="s2">mode </span><span class="s4">= (</span><span class="s2">options</span><span class="s4">.</span><span class="s2">mode </span><span class="s4">|| </span><span class="s5">'CBC'</span><span class="s4">).</span><span class="s2">toUpperCase</span><span class="s4">();</span>
  <span class="s3">var </span><span class="s2">algorithm </span><span class="s4">= </span><span class="s5">'AES-' </span><span class="s4">+ </span><span class="s2">mode</span><span class="s4">;</span>

  <span class="s3">var </span><span class="s2">cipher</span><span class="s4">;</span>
  <span class="s3">if</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">decrypt</span><span class="s4">) {</span>
    <span class="s2">cipher </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">createDecipher</span><span class="s4">(</span><span class="s2">algorithm</span><span class="s4">, </span><span class="s2">options</span><span class="s4">.</span><span class="s2">key</span><span class="s4">);</span>
  <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s2">cipher </span><span class="s4">= </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">createCipher</span><span class="s4">(</span><span class="s2">algorithm</span><span class="s4">, </span><span class="s2">options</span><span class="s4">.</span><span class="s2">key</span><span class="s4">);</span>
  <span class="s4">}</span>

  <span class="s6">// backwards compatible start API</span>
  <span class="s3">var </span><span class="s2">start </span><span class="s4">= </span><span class="s2">cipher</span><span class="s4">.</span><span class="s2">start</span><span class="s4">;</span>
  <span class="s2">cipher</span><span class="s4">.</span><span class="s2">start </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">iv</span><span class="s4">, </span><span class="s2">options</span><span class="s4">) {</span>
    <span class="s6">// backwards compatibility: support second arg as output buffer</span>
    <span class="s3">var </span><span class="s2">output </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
    <span class="s3">if</span><span class="s4">(</span><span class="s2">options </span><span class="s3">instanceof </span><span class="s2">forge</span><span class="s4">.</span><span class="s2">util</span><span class="s4">.</span><span class="s2">ByteBuffer</span><span class="s4">) {</span>
      <span class="s2">output </span><span class="s4">= </span><span class="s2">options</span><span class="s4">;</span>
      <span class="s2">options </span><span class="s4">= {};</span>
    <span class="s4">}</span>
    <span class="s2">options </span><span class="s4">= </span><span class="s2">options </span><span class="s4">|| {};</span>
    <span class="s2">options</span><span class="s4">.</span><span class="s2">output </span><span class="s4">= </span><span class="s2">output</span><span class="s4">;</span>
    <span class="s2">options</span><span class="s4">.</span><span class="s2">iv </span><span class="s4">= </span><span class="s2">iv</span><span class="s4">;</span>
    <span class="s2">start</span><span class="s4">.</span><span class="s2">call</span><span class="s4">(</span><span class="s2">cipher</span><span class="s4">, </span><span class="s2">options</span><span class="s4">);</span>
  <span class="s4">};</span>

  <span class="s3">return </span><span class="s2">cipher</span><span class="s4">;</span>
<span class="s4">}</span>
</pre>
</body>
</html>